# <!-- rdoc-file=thread.c -->
# ThreadGroup provides a means of keeping track of a number of threads as a
# group.
#
# A given Thread object can only belong to one ThreadGroup at a time; adding a
# thread to a new group will remove it from any previous group.
#
# Newly created threads belong to the same group as the thread from which they
# were created.
#
class ThreadGroup < Object
  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.add(thread)   -> thgrp
  # -->
  # Adds the given `thread` to this group, removing it from any other group to
  # which it may have previously been a member.
  #
  #     puts "Initial group is #{ThreadGroup::Default.list}"
  #     tg = ThreadGroup.new
  #     t1 = Thread.new { sleep }
  #     t2 = Thread.new { sleep }
  #     puts "t1 is #{t1}"
  #     puts "t2 is #{t2}"
  #     tg.add(t1)
  #     puts "Initial group now #{ThreadGroup::Default.list}"
  #     puts "tg group now #{tg.list}"
  #
  # This will produce:
  #
  #     Initial group is #<Thread:0x401bdf4c>
  #     t1 is #<Thread:0x401b3c90>
  #     t2 is #<Thread:0x401b3c18>
  #     Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>
  #     tg group now #<Thread:0x401b3c90>
  #
  def add: (Thread thread) -> ThreadGroup

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclose   -> thgrp
  # -->
  # Prevents threads from being added to or removed from the receiving
  # ThreadGroup.
  #
  # New threads can still be started in an enclosed ThreadGroup.
  #
  #     ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>
  #     thr = Thread.new { Thread.stop }    #=> #<Thread:0x402a7210 sleep>
  #     tg = ThreadGroup.new                #=> #<ThreadGroup:0x402752d4>
  #     tg.add thr
  #     #=> ThreadError: can't move from the enclosed thread group
  #
  def enclose: () -> self

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclosed?   -> true or false
  # -->
  # Returns `true` if the `thgrp` is enclosed. See also ThreadGroup#enclose.
  #
  def enclosed?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.list   -> array
  # -->
  # Returns an array of all existing Thread objects that belong to this group.
  #
  #     ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]
  #
  def list: () -> ::Array[Thread]
end

# <!-- rdoc-file=thread.c -->
# The default ThreadGroup created when Ruby starts; all Threads belong to it by
# default.
#
ThreadGroup::Default: ThreadGroup

# <!-- rdoc-file=ractor.rb -->
# Ractor is a Actor-model abstraction for Ruby that provides thread-safe
# parallel execution.
#
# Ractor.new can make a new Ractor, and it will run in parallel.
#
#     # The simplest ractor
#     r = Ractor.new {puts "I am in Ractor!"}
#     r.take # wait for it to finish
#     # here "I am in Ractor!" would be printed
#
# Ractors do not share usual objects, so the same kinds of thread-safety
# concerns such as data-race, race-conditions are not available on multi-ractor
# programming.
#
# To achieve this, ractors severely limit object sharing between different
# ractors. For example, unlike threads, ractors can't access each other's
# objects, nor any objects through variables of the outer scope.
#
#     a = 1
#     r = Ractor.new {puts "I am in Ractor! a=#{a}"}
#     # fails immediately with
#     # ArgumentError (can not isolate a Proc because it accesses outer variables (a).)
#
# On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is
# held per ractor, so ractors are performed in parallel without locking each
# other.
#
# Instead of accessing the shared state, the objects should be passed to and
# from ractors via sending and receiving objects as messages.
#
#     a = 1
#     r = Ractor.new do
#       a_in_ractor = receive # receive blocks till somebody will pass message
#       puts "I am in Ractor! a=#{a_in_ractor}"
#     end
#     r.send(a)  # pass it
#     r.take
#     # here "I am in Ractor! a=1" would be printed
#
# There are two pairs of methods for sending/receiving messages:
#
# *   Ractor#send and Ractor.receive for when the *sender* knows the receiver
#     (push);
# *   Ractor.yield and Ractor#take for when the *receiver* knows the sender
#     (pull);
#
#
# In addition to that, an argument to Ractor.new would be passed to block and
# available there as if received by Ractor.receive, and the last block value
# would be sent outside of the ractor as if sent by Ractor.yield.
#
# A little demonstration on a classic ping-pong:
#
#     server = Ractor.new do
#       puts "Server starts: #{self.inspect}"
#       puts "Server sends: ping"
#       Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested
#       received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent
#       puts "Server received: #{received}"
#     end
#
#     client = Ractor.new(server) do |srv|        # The server is sent inside client, and available as srv
#       puts "Client starts: #{self.inspect}"
#       received = srv.take                       # The Client takes a message specifically from the server
#       puts "Client received from " \
#            "#{srv.inspect}: #{received}"
#       puts "Client sends to " \
#            "#{srv.inspect}: pong"
#       srv.send 'pong'                           # The client sends a message specifically to the server
#     end
#
#     [client, server].each(&:take)               # Wait till they both finish
#
# This will output:
#
#     Server starts: #<Ractor:#2 test.rb:1 running>
#     Server sends: ping
#     Client starts: #<Ractor:#3 test.rb:8 running>
#     Client received from #<Ractor:#2 rac.rb:1 blocking>: ping
#     Client sends to #<Ractor:#2 rac.rb:1 blocking>: pong
#     Server received: pong
#
# It is said that Ractor receives messages via the *incoming port*, and sends
# them to the *outgoing port*. Either one can be disabled with
# Ractor#close_incoming and Ractor#close_outgoing respectively. If a ractor
# terminated, its ports will be closed automatically.
#
# ## Shareable and unshareable objects
#
# When the object is sent to and from the ractor, it is important to understand
# whether the object is shareable or unshareable. Most of objects are
# unshareable objects.
#
# Shareable objects are basically those which can be used by several threads
# without compromising thread-safety; e.g. immutable ones. Ractor.shareable?
# allows to check this, and Ractor.make_shareable tries to make object shareable
# if it is not.
#
#     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are
#     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
#     Ractor.shareable?('foo'.freeze) #=> true
#
#     ary = ['hello', 'world']
#     ary.frozen?                 #=> false
#     ary[0].frozen?              #=> false
#     Ractor.make_shareable(ary)
#     ary.frozen?                 #=> true
#     ary[0].frozen?              #=> true
#     ary[1].frozen?              #=> true
#
# When a shareable object is sent (via #send or Ractor.yield), no additional
# processing happens, and it just becomes usable by both ractors. When an
# unshareable object is sent, it can be either *copied* or *moved*. The first is
# the default, and it makes the object's full copy by deep cloning of
# non-shareable parts of its structure.
#
#     data = ['foo', 'bar'.freeze]
#     r = Ractor.new do
#       data2 = Ractor.receive
#       puts "In ractor: #{data2.object_id}, #{data2[0].object_id}, #{data2[1].object_id}"
#     end
#     r.send(data)
#     r.take
#     puts "Outside  : #{data.object_id}, #{data[0].object_id}, #{data[1].object_id}"
#
# This will output:
#
#     In ractor: 340, 360, 320
#     Outside  : 380, 400, 320
#
# (Note that object id of both array and non-frozen string inside array have
# changed inside the ractor, showing it is different objects. But the second
# array's element, which is a shareable frozen string, has the same object_id.)
#
# Deep cloning of the objects may be slow, and sometimes impossible.
# Alternatively, `move: true` may be used on sending. This will *move* the
# object to the receiving ractor, making it inaccessible for a sending ractor.
#
#     data = ['foo', 'bar']
#     r = Ractor.new do
#       data_in_ractor = Ractor.receive
#       puts "In ractor: #{data_in_ractor.object_id}, #{data_in_ractor[0].object_id}"
#     end
#     r.send(data, move: true)
#     r.take
#     puts "Outside: moved? #{Ractor::MovedObject === data}"
#     puts "Outside: #{data.inspect}"
#
# This will output:
#
#     In ractor: 100, 120
#     Outside: moved? true
#     test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError)
#
# Notice that even `inspect` (and more basic methods like `__id__`) is
# inaccessible on a moved object.
#
# Besides frozen objects, there are shareable objects. Class and Module objects
# are shareable so the Class/Module definitions are shared between ractors.
# Ractor objects are also shareable objects. All operations for the shareable
# mutable objects are thread-safe, so the thread-safety property will be kept.
# We can not define mutable shareable objects in Ruby, but C extensions can
# introduce them.
#
# It is prohibited to access instance variables of mutable shareable objects
# (especially Modules and classes) from ractors other than main:
#
#     class C
#       class << self
#         attr_accessor :tricky
#       end
#     end
#
#     C.tricky = 'test'
#
#     r = Ractor.new(C) do |cls|
#       puts "I see #{cls}"
#       puts "I can't see #{cls.tricky}"
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# Ractors can access constants if they are shareable. The main Ractor is the
# only one that can access non-shareable constants.
#
#     GOOD = 'good'.freeze
#     BAD = 'bad'
#
#     r = Ractor.new do
#       puts "GOOD=#{GOOD}"
#       puts "BAD=#{BAD}"
#     end
#     r.take
#     # GOOD=good
#     # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError)
#
#     # Consider the same C class from above
#
#     r = Ractor.new do
#       puts "I see #{C}"
#       puts "I can't see #{C.tricky}"
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# See also the description of `# shareable_constant_value` pragma in [Comments
# syntax](rdoc-ref:syntax/comments.rdoc) explanation.
#
# ## Ractors vs threads
#
# Each ractor creates its own thread. New threads can be created from inside
# ractor (and, on CRuby, sharing GVL with other threads of this ractor).
#
#     r = Ractor.new do
#       a = 1
#       Thread.new {puts "Thread in ractor: a=#{a}"}.join
#     end
#     r.take
#     # Here "Thread in ractor: a=1" will be printed
#
# ## Note on code examples
#
# In examples below, sometimes we use the following method to wait till ractors
# that are not currently blocked will finish (or process till next blocking)
# method.
#
#     def wait
#       sleep(0.1)
#     end
#
# It is **only for demonstration purposes** and shouldn't be used in a real
# code. Most of the times, just #take is used to wait till ractor will finish.
#
# ## Reference
#
# See [Ractor design doc](rdoc-ref:ractor.md) for more details.
#
class Ractor
  # <!--
  #   rdoc-file=ractor.rb
  #   - count()
  # -->
  # Returns total count of Ractors currently running.
  #
  #     Ractor.count                   #=> 1
  #     r = Ractor.new(name: 'example') { Ractor.yield(1) }
  #     Ractor.count                   #=> 2 (main + example ractor)
  #     r.take                         # wait for Ractor.yield(1)
  #     r.take                         # wait till r will finish
  #     Ractor.count                   #=> 1
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=ractor.rb
  #   - current()
  # -->
  # Returns the currently executing Ractor.
  #
  #     Ractor.current #=> #<Ractor:#1 running>
  #
  def self.current: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - main()
  # -->
  # returns main ractor
  #
  def self.main: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.make_shareable(obj, copy: false) -> shareable_obj
  # -->
  # Make `obj` shareable between ractors.
  #
  # `obj` and all the objects it refers to will be frozen, unless they are already
  # shareable.
  #
  # If `copy` keyword is `true`, the method will copy objects before freezing them
  # This is safer option but it can take be slower.
  #
  # Note that the specification and implementation of this method are not mature
  # and may be changed in the future.
  #
  #     obj = ['test']
  #     Ractor.shareable?(obj)     #=> false
  #     Ractor.make_shareable(obj) #=> ["test"]
  #     Ractor.shareable?(obj)     #=> true
  #     obj.frozen?                #=> true
  #     obj[0].frozen?             #=> true
  #
  #     # Copy vs non-copy versions:
  #     obj1 = ['test']
  #     obj1s = Ractor.make_shareable(obj1)
  #     obj1.frozen?                        #=> true
  #     obj1s.object_id == obj1.object_id   #=> true
  #     obj2 = ['test']
  #     obj2s = Ractor.make_shareable(obj2, copy: true)
  #     obj2.frozen?                        #=> false
  #     obj2s.frozen?                       #=> true
  #     obj2s.object_id == obj2.object_id   #=> false
  #     obj2s[0].object_id == obj2[0].object_id #=> false
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.make_shareable: [T] (T obj, ?copy: boolish) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.new(*args, name: nil) {|*args| block } -> ractor
  # -->
  # Create a new Ractor with args and a block.
  #
  # A block (Proc) will be isolated (can't access to outer variables). `self`
  # inside the block will refer to the current Ractor.
  #
  #     r = Ractor.new { puts "Hi, I am #{self.inspect}" }
  #     r.take
  #     # Prints "Hi, I am #<Ractor:#2 test.rb:1 running>"
  #
  # `args` passed to the method would be propagated to block args by the same
  # rules as objects passed through #send/Ractor.receive: if `args` are not
  # shareable, they will be copied (via deep cloning, which might be inefficient).
  #
  #     arg = [1, 2, 3]
  #     puts "Passing: #{arg} (##{arg.object_id})"
  #     r = Ractor.new(arg) {|received_arg|
  #       puts "Received: #{received_arg} (##{received_arg.object_id})"
  #     }
  #     r.take
  #     # Prints:
  #     #   Passing: [1, 2, 3] (#280)
  #     #   Received: [1, 2, 3] (#300)
  #
  # Ractor's `name` can be set for debugging purposes:
  #
  #     r = Ractor.new(name: 'my ractor') {}
  #     p r
  #     #=> #<Ractor:#3 my ractor test.rb:1 terminated>
  #
  def self.new: (*untyped args, ?name: string) { (*untyped) -> untyped } -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive -> msg
  # -->
  # Receive an incoming message from the current Ractor's incoming port's queue,
  # which was sent there by #send.
  #
  #     r = Ractor.new do
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # Here will be printed: "Received: message1"
  #
  # Alternatively, private instance method `receive` may be used:
  #
  #     r = Ractor.new do
  #       v1 = receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # Here will be printed: "Received: message1"
  #
  # The method blocks if the queue is empty.
  #
  #     r = Ractor.new do
  #       puts "Before first receive"
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #       v2 = Ractor.receive
  #       puts "Received: #{v2}"
  #     end
  #     wait
  #     puts "Still not received"
  #     r.send('message1')
  #     wait
  #     puts "Still received only one"
  #     r.send('message2')
  #     r.take
  #
  # Output:
  #
  #     Before first receive
  #     Still not received
  #     Received: message1
  #     Still received only one
  #     Received: message2
  #
  # If close_incoming was called on the ractor, the method raises
  # Ractor::ClosedError if there are no more messages in incoming queue:
  #
  #     Ractor.new do
  #       close_incoming
  #       receive
  #     end
  #     wait
  #     # in `receive': The incoming port is already closed => #<Ractor:#2 test.rb:1 running> (Ractor::ClosedError)
  #
  def self.receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive_if {|msg| block } -> msg
  # -->
  # Receive only a specific message.
  #
  # Instead of Ractor.receive, Ractor.receive_if can provide a pattern by a block
  # and you can choose the receiving message.
  #
  #     r = Ractor.new do
  #       p Ractor.receive_if{|msg| msg.match?(/foo/)} #=> "foo3"
  #       p Ractor.receive_if{|msg| msg.match?(/bar/)} #=> "bar1"
  #       p Ractor.receive_if{|msg| msg.match?(/baz/)} #=> "baz2"
  #     end
  #     r << "bar1"
  #     r << "baz2"
  #     r << "foo3"
  #     r.take
  #
  # This will output:
  #
  #     foo3
  #     bar1
  #     baz2
  #
  # If the block returns a truthy value, the message will be removed from the
  # incoming queue and returned. Otherwise, the message remains in the incoming
  # queue and the following received messages are checked by the given block.
  #
  # If there are no messages left in the incoming queue, the method will block
  # until new messages arrive.
  #
  # If the block is escaped by break/return/exception/throw, the message is
  # removed from the incoming queue as if a truthy value had been returned.
  #
  #     r = Ractor.new do
  #       val = Ractor.receive_if{|msg| msg.is_a?(Array)}
  #       puts "Received successfully: #{val}"
  #     end
  #
  #     r.send(1)
  #     r.send('test')
  #     wait
  #     puts "2 non-matching sent, nothing received"
  #     r.send([1, 2, 3])
  #     wait
  #
  # Prints:
  #
  #     2 non-matching sent, nothing received
  #     Received successfully: [1, 2, 3]
  #
  # Note that you can not call receive/receive_if in the given block recursively.
  # It means that you should not do any tasks in the block.
  #
  #     Ractor.current << true
  #     Ractor.receive_if{|msg| Ractor.receive}
  #     #=> `receive': can not call receive/receive_if recursively (Ractor::Error)
  #
  def self.receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias self.recv self.receive

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.select(*ractors, [yield_value:, move: false]) -> [ractor or symbol, obj]
  # -->
  # Waits for the first ractor to have something in its outgoing port, reads from
  # this ractor, and returns that ractor and the object received.
  #
  #     r1 = Ractor.new {Ractor.yield 'from 1'}
  #     r2 = Ractor.new {Ractor.yield 'from 2'}
  #
  #     r, obj = Ractor.select(r1, r2)
  #
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Prints: received "from 1" from #<Ractor:#2 test.rb:1 running>
  #
  # If one of the given ractors is the current ractor, and it would be selected,
  # `r` will contain `:receive` symbol instead of the ractor object.
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       main.send 'to main'
  #       Ractor.yield 'from 1'
  #     end
  #     r2 = Ractor.new do
  #       Ractor.yield 'from 2'
  #     end
  #
  #     r, obj = Ractor.select(r1, r2, Ractor.current)
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Prints: received "to main" from :receive
  #
  # If `yield_value` is provided, that value may be yielded if another Ractor is
  # calling #take. In this case, the pair `[:yield, nil]` would be returned:
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       puts "Received from main: #{main.take}"
  #     end
  #
  #     puts "Trying to select"
  #     r, obj = Ractor.select(r1, Ractor.current, yield_value: 123)
  #     wait
  #     puts "Received #{obj.inspect} from #{r.inspect}"
  #
  # This will print:
  #
  #     Trying to select
  #     Received from main: 123
  #     Received nil from :yield
  #
  # `move` boolean flag defines whether yielded value should be copied (default)
  # or moved.
  #
  def self.select: (*Ractor ractors, ?move: boolish, ?yield_value: untyped) -> [ Ractor | Symbol, untyped ]

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.shareable?(obj) -> true | false
  # -->
  # Checks if the object is shareable by ractors.
  #
  #     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are frozen
  #     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
  #     Ractor.shareable?('foo'.freeze) #=> true
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.shareable?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.yield(msg, move: false) -> nil
  # -->
  # Send a message to the current ractor's outgoing port to be consumed by #take.
  #
  #     r = Ractor.new {Ractor.yield 'Hello from ractor'}
  #     puts r.take
  #     # Prints: "Hello from ractor"
  #
  # The method is blocking, and will return only when somebody consumes the sent
  # message.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'Hello from ractor'
  #       puts "Ractor: after yield"
  #     end
  #     wait
  #     puts "Still not taken"
  #     puts r.take
  #
  # This will print:
  #
  #     Still not taken
  #     Hello from ractor
  #     Ractor: after yield
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise:
  #
  #     r = Ractor.new do
  #       close_outgoing
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     wait
  #     # `yield': The outgoing-port is already closed (Ractor::ClosedError)
  #
  # The meaning of `move` argument is the same as for #send.
  #
  def self.yield: (untyped obj, ?move: boolish) -> untyped

  public

  # <!--
  #   rdoc-file=ractor.rb
  #   - <<(obj, move: false)
  # -->
  #
  alias << send

  # <!--
  #   rdoc-file=ractor.rb
  #   - [](sym)
  # -->
  # get a value from ractor-local storage
  #
  def []: (Symbol | String sym) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - []=(sym, val)
  # -->
  # set a value in ractor-local storage
  #
  def []=: [T] (Symbol | String sym, T val) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_incoming -> true | false
  # -->
  # Closes the incoming port and returns its previous state. All further attempts
  # to Ractor.receive in the ractor, and #send to the ractor will fail with
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_incoming  #=> false
  #     r.close_incoming  #=> true
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  def close_incoming: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_outgoing -> true | false
  # -->
  # Closes the outgoing port and returns its previous state. All further attempts
  # to Ractor.yield in the ractor, and #take from the ractor will fail with
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_outgoing  #=> false
  #     r.close_outgoing  #=> true
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #
  def close_outgoing: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - inspect()
  # -->
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ractor.rb
  #   - name()
  # -->
  # The name set in Ractor.new, or `nil`.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.send(msg, move: false) -> self
  # -->
  # Send a message to a Ractor's incoming queue to be consumed by Ractor.receive.
  #
  #     r = Ractor.new do
  #       value = Ractor.receive
  #       puts "Received #{value}"
  #     end
  #     r.send 'message'
  #     # Prints: "Received: message"
  #
  # The method is non-blocking (will return immediately even if the ractor is not
  # ready to receive anything):
  #
  #     r = Ractor.new {sleep(5)}
  #     r.send('test')
  #     puts "Sent successfully"
  #     # Prints: "Sent successfully" immediately
  #
  # Attempt to send to ractor which already finished its execution will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {}
  #     r.take
  #     p r
  #     # "#<Ractor:#6 (irb):23 terminated>"
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  # If close_incoming was called on the ractor, the method also raises
  # Ractor::ClosedError.
  #
  #     r =  Ractor.new do
  #       sleep(500)
  #       receive
  #     end
  #     r.close_incoming
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #     # The error would be raised immediately, not when ractor will try to receive
  #
  # If the `obj` is unshareable, by default it would be copied into ractor by deep
  # cloning. If the `move: true` is passed, object is *moved* into ractor and
  # becomes inaccessible to sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     msg = 'message'
  #     r.send(msg, move: true)
  #     r.take
  #     p msg
  #
  # This prints:
  #
  #     Received: message
  #     in `p': undefined method `inspect' for #<Ractor::MovedObject:0x000055c99b9b69b8>
  #
  # All references to the object and its parts will become invalid in sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'
  #     ary = [s]
  #     copy = ary.dup
  #     r.send(ary, move: true)
  #
  #     s.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     ary.class
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     copy.class
  #     # => Array, it is different object
  #     copy[0].inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     # ...but its item was still a reference to `s`, which was moved
  #
  # If the object was shareable, `move: true` has no effect on it:
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'.freeze
  #     r.send(s, move: true)
  #     s.inspect #=> "message", still available
  #
  def send: (untyped obj, ?move: boolish) -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.take -> msg
  # -->
  # Take a message from ractor's outgoing port, which was put there by
  # Ractor.yield or at ractor's finalization.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'explicit yield'
  #       'last value'
  #     end
  #     puts r.take #=> 'explicit yield'
  #     puts r.take #=> 'last value'
  #     puts r.take # Ractor::ClosedError (The outgoing-port is already closed)
  #
  # The fact that the last value is also put to outgoing port means that `take`
  # can be used as some analog of Thread#join ("just wait till ractor finishes"),
  # but don't forget it will raise if somebody had already consumed everything
  # ractor have produced.
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new do
  #       sleep(500)
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     r.close_outgoing
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #     # The error would be raised immediately, not when ractor will try to receive
  #
  # If an uncaught exception is raised in the Ractor, it is propagated on take as
  # a Ractor::RemoteError.
  #
  #     r = Ractor.new {raise "Something weird happened"}
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e              #  => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r  # => true
  #       p e.cause        # => #<RuntimeError: Something weird happened>
  #     end
  #
  # Ractor::ClosedError is a descendant of StopIteration, so the closing of the
  # ractor will break the loops without propagating the error:
  #
  #     r = Ractor.new do
  #       3.times {|i| Ractor.yield "message #{i}"}
  #       "finishing"
  #     end
  #
  #     loop {puts "Received: " + r.take}
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: message 0
  #     Received: message 1
  #     Received: message 2
  #     Received: finishing
  #     Continue successfully
  #
  def take: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - to_s()
  # -->
  #
  alias to_s inspect

  private

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive()
  # -->
  # same as Ractor.receive
  #
  def receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive_if(&b)
  # -->
  #
  def receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias recv receive

  # <!-- rdoc-file=ractor.c -->
  # Raised when an attempt is made to send a message to a closed port, or to
  # retrieve a message from a closed and empty port. Ports may be closed
  # explicitly with Ractor#close_outgoing/close_incoming and are closed implicitly
  # when a Ractor terminates.
  #
  #     r = Ractor.new { sleep(500) }
  #     r.close_outgoing
  #     r.take # Ractor::ClosedError
  #
  # ClosedError is a descendant of StopIteration, so the closing of the ractor
  # will break the loops without propagating the error:
  #
  #     r = Ractor.new do
  #       loop do
  #         msg = receive # raises ClosedError and loop traps it
  #         puts "Received: #{msg}"
  #       end
  #       puts "loop exited"
  #     end
  #
  #     3.times{|i| r << i}
  #     r.close_incoming
  #     r.take
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: 0
  #     Received: 1
  #     Received: 2
  #     loop exited
  #     Continue successfully
  #
  class ClosedError < StopIteration
  end

  class Error < RuntimeError
  end

  class IsolationError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on an attempt to access an object which was moved in Ractor#send or
  # Ractor.yield.
  #
  #     r = Ractor.new { sleep }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # A special object which replaces any value that was moved to another ractor in
  # Ractor#send or Ractor.yield. Any attempt to access the object results in
  # Ractor::MovedError.
  #
  #     r = Ractor.new { receive }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     p Ractor::MovedObject === ary
  #     # => true
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedObject < BasicObject
    public

    # <!--
    #   rdoc-file=ractor.c
    #   - !(*args)
    # -->
    #
    def !: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - !=(*args)
    # -->
    #
    def !=: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - ==(*args)
    # -->
    #
    def ==: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __id__(*args)
    # -->
    #
    def __id__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __send__(*args)
    # -->
    #
    def __send__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - equal?(*args)
    # -->
    #
    def equal?: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_eval(*args)
    # -->
    #
    def instance_eval: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_exec(*args)
    # -->
    #
    def instance_exec: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - method_missing(*args)
    # -->
    #
    def method_missing: (*untyped) -> untyped
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on attempt to Ractor#take if there was an uncaught exception in the
  # Ractor. Its `cause` will contain the original exception, and `ractor` is the
  # original ractor it was raised in.
  #
  #     r = Ractor.new { raise "Something weird happened" }
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e             # => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r # => true
  #       p e.cause       # => #<RuntimeError: Something weird happened>
  #     end
  #
  class RemoteError < Ractor::Error
    public

    def ractor: () -> Ractor
  end

  class UnsafeError < Ractor::Error
  end
end

# <!-- rdoc-file=array.c -->
# An Array is an ordered, integer-indexed collection of objects, called
# *elements*.  Any object may be an Array element.
#
# ## Array Indexes
#
# Array indexing starts at 0, as in C or Java.
#
# A positive index is an offset from the first element:
# *   Index 0 indicates the first element.
# *   Index 1 indicates the second element.
# *   ...
#
#
# A negative index is an offset, backwards, from the end of the array:
# *   Index -1 indicates the last element.
# *   Index -2 indicates the next-to-last element.
# *   ...
#
#
# A non-negative index is *in range* if it is smaller than the size of the
# array.  For a 3-element array:
# *   Indexes 0 through 2 are in range.
# *   Index 3 is out of range.
#
#
# A negative index is *in range* if its absolute value is not larger than the
# size of the array.  For a 3-element array:
# *   Indexes -1 through -3 are in range.
# *   Index -4 is out of range.
#
#
# ## Creating Arrays
#
# You can create an Array object explicitly with:
#
# *   An [array literal](doc/syntax/literals_rdoc.html#label-Array+Literals).
#
#
# You can convert certain objects to Arrays with:
#
# *   Method [Array](Kernel.html#method-i-Array).
#
#
# An Array can contain different types of objects.  For example, the array below
# contains an Integer, a String and a Float:
#
#     ary = [1, "two", 3.0] #=> [1, "two", 3.0]
#
# An array can also be created by calling Array.new with zero, one (the initial
# size of the Array) or two arguments (the initial size and a default object).
#
#     ary = Array.new    #=> []
#     Array.new(3)       #=> [nil, nil, nil]
#     Array.new(3, true) #=> [true, true, true]
#
# Note that the second argument populates the array with references to the same
# object.  Therefore, it is only recommended in cases when you need to
# instantiate arrays with natively immutable objects such as Symbols, numbers,
# true or false.
#
# To create an array with separate objects a block can be passed instead. This
# method is safe to use with mutable objects such as hashes, strings or other
# arrays:
#
#     Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
#     Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]
#
# This is also a quick way to build up multi-dimensional arrays:
#
#     empty_table = Array.new(3) {Array.new(3)}
#     #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
#
# An array can also be created by using the Array() method, provided by Kernel,
# which tries to call #to_ary, then #to_a on its argument.
#
#     Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]
#
# ## Example Usage
#
# In addition to the methods it mixes in through the Enumerable module, the
# Array class has proprietary methods for accessing, searching and otherwise
# manipulating arrays.
#
# Some of the more common ones are illustrated below.
#
# ## Accessing Elements
#
# Elements in an array can be retrieved using the Array#[] method.  It can take
# a single integer argument (a numeric index), a pair of arguments (start and
# length) or a range. Negative indices start counting from the end, with -1
# being the last element.
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr[2]    #=> 3
#     arr[100]  #=> nil
#     arr[-3]   #=> 4
#     arr[2, 3] #=> [3, 4, 5]
#     arr[1..4] #=> [2, 3, 4, 5]
#     arr[1..-3] #=> [2, 3, 4]
#
# Another way to access a particular array element is by using the #at method
#
#     arr.at(0) #=> 1
#
# The #slice method works in an identical manner to Array#[].
#
# To raise an error for indices outside of the array bounds or else to provide a
# default value when that happens, you can use #fetch.
#
#     arr = ['a', 'b', 'c', 'd', 'e', 'f']
#     arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
#     arr.fetch(100, "oops") #=> "oops"
#
# The special methods #first and #last will return the first and last elements
# of an array, respectively.
#
#     arr.first #=> 1
#     arr.last  #=> 6
#
# To return the first `n` elements of an array, use #take
#
#     arr.take(3) #=> [1, 2, 3]
#
# #drop does the opposite of #take, by returning the elements after `n` elements
# have been dropped:
#
#     arr.drop(3) #=> [4, 5, 6]
#
# ## Obtaining Information about an Array
#
# Arrays keep track of their own length at all times.  To query an array about
# the number of elements it contains, use #length, #count or #size.
#
#     browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
#     browsers.length #=> 5
#     browsers.count #=> 5
#
# To check whether an array contains any elements at all
#
#     browsers.empty? #=> false
#
# To check whether a particular item is included in the array
#
#     browsers.include?('Konqueror') #=> false
#
# ## Adding Items to Arrays
#
# Items can be added to the end of an array by using either #push or #<<
#
#     arr = [1, 2, 3, 4]
#     arr.push(5) #=> [1, 2, 3, 4, 5]
#     arr << 6    #=> [1, 2, 3, 4, 5, 6]
#
# #unshift will add a new item to the beginning of an array.
#
#     arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]
#
# With #insert you can add a new element to an array at any position.
#
#     arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]
#
# Using the #insert method, you can also insert multiple values at once:
#
#     arr.insert(3, 'orange', 'pear', 'grapefruit')
#     #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
#
# ## Removing Items from an Array
#
# The method #pop removes the last element in an array and returns it:
#
#     arr =  [1, 2, 3, 4, 5, 6]
#     arr.pop #=> 6
#     arr #=> [1, 2, 3, 4, 5]
#
# To retrieve and at the same time remove the first item, use #shift:
#
#     arr.shift #=> 1
#     arr #=> [2, 3, 4, 5]
#
# To delete an element at a particular index:
#
#     arr.delete_at(2) #=> 4
#     arr #=> [2, 3, 5]
#
# To delete a particular element anywhere in an array, use #delete:
#
#     arr = [1, 2, 2, 3]
#     arr.delete(2) #=> 2
#     arr #=> [1,3]
#
# A useful method if you need to remove `nil` values from an array is #compact:
#
#     arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, 'bar', 7, 'baz']
#
# Another common need is to remove duplicate elements from an array.
#
# It has the non-destructive #uniq, and destructive method #uniq!
#
#     arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
#     arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]
#
# ## Iterating over Arrays
#
# Like all classes that include the Enumerable module, Array has an each method,
# which defines what elements should be iterated over and how.  In case of
# Array's #each, all elements in the Array instance are yielded to the supplied
# block in sequence.
#
# Note that this operation leaves the array unchanged.
#
#     arr = [1, 2, 3, 4, 5]
#     arr.each {|a| print a -= 10, " "}
#     # prints: -9 -8 -7 -6 -5
#     #=> [1, 2, 3, 4, 5]
#
# Another sometimes useful iterator is #reverse_each which will iterate over the
# elements in the array in reverse order.
#
#     words = %w[first second third fourth fifth sixth]
#     str = ""
#     words.reverse_each {|word| str += "#{word} "}
#     p str #=> "sixth fifth fourth third second first "
#
# The #map method can be used to create a new array based on the original array,
# but with the values modified by the supplied block:
#
#     arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
#     arr                   #=> [1, 2, 3, 4, 5]
#     arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
#     arr                   #=> [1, 4, 9, 16, 25]
#
# ## Selecting Items from an Array
#
# Elements can be selected from an array according to criteria defined in a
# block.  The selection can happen in a destructive or a non-destructive manner.
#  While the destructive operations will modify the array they were called on,
# the non-destructive methods usually return a new array with the selected
# elements, but leave the original array unchanged.
#
# ### Non-destructive Selection
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.select {|a| a > 3}       #=> [4, 5, 6]
#     arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
#     arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
#     arr                          #=> [1, 2, 3, 4, 5, 6]
#
# ### Destructive Selection
#
# #select! and #reject! are the corresponding destructive methods to #select and
# #reject
#
# Similar to #select vs. #reject, #delete_if and #keep_if have the exact
# opposite result when supplied with the same block:
#
#     arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
#     arr                         #=> [4, 5, 6]
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
#     arr                       #=> [1, 2, 3]
#
# ## What's Here
#
# First, what's elsewhere. Class Array:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Array provides methods that are useful for:
#
# *   [Creating an Array](#class-Array-label-Methods+for+Creating+an+Array)
# *   [Querying](#class-Array-label-Methods+for+Querying)
# *   [Comparing](#class-Array-label-Methods+for+Comparing)
# *   [Fetching](#class-Array-label-Methods+for+Fetching)
# *   [Assigning](#class-Array-label-Methods+for+Assigning)
# *   [Deleting](#class-Array-label-Methods+for+Deleting)
# *   [Combining](#class-Array-label-Methods+for+Combining)
# *   [Iterating](#class-Array-label-Methods+for+Iterating)
# *   [Converting](#class-Array-label-Methods+for+Converting)
# *   [And more....](#class-Array-label-Other+Methods)
#
#
# ### Methods for Creating an Array
#
# ::[]
# :   Returns a new array populated with given objects.
# ::new
# :   Returns a new array.
# ::try_convert
# :   Returns a new array created from a given object.
#
#
# ### Methods for Querying
#
# #length, #size
# :   Returns the count of elements.
# #include?
# :   Returns whether any element `==` a given object.
# #empty?
# :   Returns whether there are no elements.
# #all?
# :   Returns whether all elements meet a given criterion.
# #any?
# :   Returns whether any element meets a given criterion.
# #none?
# :   Returns whether no element `==` a given object.
# #one?
# :   Returns whether exactly one element `==` a given object.
# #count
# :   Returns the count of elements that meet a given criterion.
# #find_index, #index
# :   Returns the index of the first element that meets a given criterion.
# #rindex
# :   Returns the index of the last element that meets a given criterion.
# #hash
# :   Returns the integer hash code.
#
#
# ### Methods for Comparing
# [#<=>](#method-i-3C-3D-3E)
# :   Returns -1, 0, or 1 as `self` is less than, equal to, or greater than a
#     given object.
# [#==](#method-i-3D-3D)
# :   Returns whether each element in `self` is `==` to the corresponding
#     element in a given object.
# #eql?
# :   Returns whether each element in `self` is `eql?` to the corresponding
#     element in a given object.
#
#
# ### Methods for Fetching
#
# These methods do not modify `self`.
#
# #[]
# :   Returns one or more elements.
# #fetch
# :   Returns the element at a given offset.
# #first
# :   Returns one or more leading elements.
# #last
# :   Returns one or more trailing elements.
# #max
# :   Returns one or more maximum-valued elements, as determined by `<=>` or a
#     given block.
# #max
# :   Returns one or more minimum-valued elements, as determined by `<=>` or a
#     given block.
# #minmax
# :   Returns the minimum-valued and maximum-valued elements, as determined by
#     `<=>` or a given block.
# #assoc
# :   Returns the first element that is an array whose first element `==` a
#     given object.
# #rassoc
# :   Returns the first element that is an array whose second element `==` a
#     given object.
# #at
# :   Returns the element at a given offset.
# #values_at
# :   Returns the elements at given offsets.
# #dig
# :   Returns the object in nested objects that is specified by a given index
#     and additional arguments.
# #drop
# :   Returns trailing elements as determined by a given index.
# #take
# :   Returns leading elements as determined by a given index.
# #drop_while
# :   Returns trailing elements as determined by a given block.
# #take_while
# :   Returns leading elements as determined by a given block.
# #slice
# :   Returns consecutive elements as determined by a given argument.
# #sort
# :   Returns all elements in an order determined by `<=>` or a given block.
# #reverse
# :   Returns all elements in reverse order.
# #compact
# :   Returns an array containing all non-`nil` elements.
# #select, #filter
# :   Returns an array containing elements selected by a given block.
# #uniq
# :   Returns an array containing non-duplicate elements.
# #rotate
# :   Returns all elements with some rotated from one end to the other.
# #bsearch
# :   Returns an element selected via a binary search as determined by a given
#     block.
# #bsearch_index
# :   Returns the index of an element selected via a binary search as determined
#     by a given block.
# #sample
# :   Returns one or more random elements.
# #shuffle
# :   Returns elements in a random order.
#
#
# ### Methods for Assigning
#
# These methods add, replace, or reorder elements in `self`.
#
# #[]=
# :   Assigns specified elements with a given object.
# #push, #append, #<<
# :   Appends trailing elements.
# #unshift, #prepend
# :   Prepends leading elements.
# #insert
# :   Inserts given objects at a given offset; does not replace elements.
# #concat
# :   Appends all elements from given arrays.
# #fill
# :   Replaces specified elements with specified objects.
# #replace
# :   Replaces the content of `self` with the content of a given array.
# #reverse!
# :   Replaces `self` with its elements reversed.
# #rotate!
# :   Replaces `self` with its elements rotated.
# #shuffle!
# :   Replaces `self` with its elements in random order.
# #sort!
# :   Replaces `self` with its elements sorted, as determined by `<=>` or a
#     given block.
# #sort_by!
# :   Replaces `self` with its elements sorted, as determined by a given block.
#
#
# ### Methods for Deleting
#
# Each of these methods removes elements from `self`:
#
# #pop
# :   Removes and returns the last element.
# #shift
# :   Removes and returns the first element.
# #compact!
# :   Removes all non-`nil` elements.
# #delete
# :   Removes elements equal to a given object.
# #delete_at
# :   Removes the element at a given offset.
# #delete_if
# :   Removes elements specified by a given block.
# #keep_if
# :   Removes elements not specified by a given block.
# #reject!
# :   Removes elements specified by a given block.
# #select!, #filter!
# :   Removes elements not specified by a given block.
# #slice!
# :   Removes and returns a sequence of elements.
# #uniq!
# :   Removes duplicates.
#
#
# ### Methods for Combining
#
# [#&](#method-i-26)
# :   Returns an array containing elements found both in `self` and a given
#     array.
# #intersection
# :   Returns an array containing elements found both in `self` and in each
#     given array.
# #+
# :   Returns an array containing all elements of `self` followed by all
#     elements of a given array.
# #-
# :   Returns an array containiing all elements of `self` that are not found in
#     a given array.
# [#|](#method-i-7C)
# :   Returns an array containing all elements of `self` and all elements of a
#     given array, duplicates removed.
# #union
# :   Returns an array containing all elements of `self` and all elements of
#     given arrays, duplicates removed.
# #difference
# :   Returns an array containing all elements of `self` that are not found in
#     any of the given arrays..
# #product
# :   Returns or yields all combinations of elements from `self` and given
#     arrays.
#
#
# ### Methods for Iterating
#
# #each
# :   Passes each element to a given block.
# #reverse_each
# :   Passes each element, in reverse order, to a given block.
# #each_index
# :   Passes each element index to a given block.
# #cycle
# :   Calls a given block with each element, then does so again, for a specified
#     number of times, or forever.
# #combination
# :   Calls a given block with combinations of elements of `self`; a combination
#     does not use the same element more than once.
# #permutation
# :   Calls a given block with permutations of elements of `self`; a permutation
#     does not use the same element more than once.
# #repeated_combination
# :   Calls a given block with combinations of elements of `self`; a combination
#     may use the same element more than once.
# #repeated_permutation
# :   Calls a given block with permutations of elements of `self`; a permutation
#     may use the same element more than once.
#
#
# ### Methods for Converting
#
# #map, #collect
# :   Returns an array containing the block return-value for each element.
# #map!, #collect!
# :   Replaces each element with a block return-value.
# #flatten
# :   Returns an array that is a recursive flattening of `self`.
# #flatten!
# :   Replaces each nested array in `self` with the elements from that array.
# #inspect, #to_s
# :   Returns a new String containing the elements.
# #join
# :   Returns a newsString containing the elements joined by the field
#     separator.
# #to_a
# :   Returns `self` or a new array containing all elements.
# #to_ary
# :   Returns `self`.
# #to_h
# :   Returns a new hash formed from the elements.
# #transpose
# :   Transposes `self`, which must be an array of arrays.
# #zip
# :   Returns a new array of arrays containing `self` and given arrays; follow
#     the link for details.
#
#
# ### Other Methods
#
# #*
# :   Returns one of the following:
#     *   With integer argument `n`, a new array that is the concatenation of
#         `n` copies of `self`.
#     *   With string argument `field_separator`, a new string that is
#         equivalent to `join(field_separator)`.
#
# #abbrev
# :   Returns a hash of unambiguous abbreviations for elements.
# #pack
# :   Packs the elements into a binary sequence.
# #sum
# :   Returns a sum of elements according to either `+` or a given block.
#
%a{annotate:rdoc:source:from=array.c}
class Array[unchecked out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - Array.new -> new_empty_array
  #   - Array.new(array) -> new_array
  #   - Array.new(size) -> new_array
  #   - Array.new(size, default_value) -> new_array
  #   - Array.new(size) {|index| ... } -> new_array
  # -->
  # Returns a new Array.
  #
  # With no block and no arguments, returns a new empty Array object.
  #
  # With no block and a single Array argument `array`, returns a new Array formed
  # from `array`:
  #     a = Array.new([:foo, 'bar', 2])
  #     a.class # => Array
  #     a # => [:foo, "bar", 2]
  #
  # With no block and a single Integer argument `size`, returns a new Array of the
  # given size whose elements are all `nil`:
  #     a = Array.new(3)
  #     a # => [nil, nil, nil]
  #
  # With no block and arguments `size` and `default_value`, returns an Array of
  # the given size; each element is that same `default_value`:
  #     a = Array.new(3, 'x')
  #     a # => ['x', 'x', 'x']
  #
  # With a block and argument `size`, returns an Array of the given size; the
  # block is called with each successive integer `index`; the element for that
  # `index` is the return value from the block:
  #     a = Array.new(3) {|index| "Element #{index}" }
  #     a # => ["Element 0", "Element 1", "Element 2"]
  #
  # Raises ArgumentError if `size` is negative.
  #
  # With a block and no argument, or a single argument `0`, ignores the block and
  # returns a new empty Array.
  #
  def initialize: () -> void
                | (::Array[Elem] ary) -> void
                | (int size, ?Elem val) -> void
                | (int size) { (::Integer index) -> Elem } -> void

  # <!--
  #   rdoc-file=array.c
  #   - [](*args)
  # -->
  # Returns a new array populated with the given objects.
  #
  #     Array.[]( 1, 'a', /^A/)  # => [1, "a", /^A/]
  #     Array[ 1, 'a', /^A/ ]    # => [1, "a", /^A/]
  #     [ 1, 'a', /^A/ ]         # => [1, "a", /^A/]
  #
  def self.[]: [U] (*U) -> ::Array[U]

  # <!--
  #   rdoc-file=array.c
  #   - Array.try_convert(object) -> object, new_array, or nil
  # -->
  # If `object` is an Array object, returns `object`.
  #
  # Otherwise if `object` responds to `:to_ary`, calls `object.to_ary` and returns
  # the result.
  #
  # Returns `nil` if `object` does not respond to `:to_ary`
  #
  # Raises an exception unless `object.to_ary` returns an Array object.
  #
  def self.try_convert: [U] (untyped) -> ::Array[U]?

  public

  # <!--
  #   rdoc-file=array.c
  #   - array & other_array -> new_array
  # -->
  # Returns a new Array containing each element found in both `array` and Array
  # `other_array`; duplicates are omitted; items are compared using `eql?`:
  #     [0, 1, 2, 3] & [1, 2] # => [1, 2]
  #     [0, 1, 0, 1] & [0, 1] # => [0, 1]
  #
  # Preserves order from `array`:
  #     [0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]
  #
  # Related: Array#intersection.
  #
  def &: (::Array[untyped] | _ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array * n -> new_array
  #   - array * string_separator -> new_string
  # -->
  # When non-negative argument Integer `n` is given, returns a new Array built by
  # concatenating the `n` copies of `self`:
  #     a = ['x', 'y']
  #     a * 3 # => ["x", "y", "x", "y", "x", "y"]
  #
  # When String argument `string_separator` is given, equivalent to
  # `array.join(string_separator)`:
  #     [0, [0, 1], {foo: 0}] * ', ' # => "0, 0, 1, {:foo=>0}"
  #
  def *: (string str) -> ::String
       | (int int) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array + other_array -> new_array
  # -->
  # Returns a new Array containing all elements of `array` followed by all
  # elements of `other_array`:
  #     a = [0, 1] + [2, 3]
  #     a # => [0, 1, 2, 3]
  #
  # Related: #concat.
  #
  def +: [U] (_ToAry[U]) -> ::Array[Elem | U]

  # <!--
  #   rdoc-file=array.c
  #   - array - other_array -> new_array
  # -->
  # Returns a new Array containing only those elements from `array` that are not
  # found in Array `other_array`; items are compared using `eql?`; the order from
  # `array` is preserved:
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1] - [1] # => [0, 2, 3]
  #     [0, 1, 2, 3] - [3, 0] # => [1, 2]
  #     [0, 1, 2] - [4] # => [0, 1, 2]
  #
  # Related: Array#difference.
  #
  def -: (_ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array << object -> self
  # -->
  # Appends `object` to `self`; returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a << :baz # => [:foo, "bar", 2, :baz]
  #
  # Appends `object` as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a << [3, 4]
  #     a1 # => [:foo, "bar", 2, [3, 4]]
  #
  def <<: (Elem) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array <=> other_array -> -1, 0, or 1
  # -->
  # Returns -1, 0, or 1 as `self` is less than, equal to, or greater than
  # `other_array`. For each index `i` in `self`, evaluates `result = self[i] <=>
  # other_array[i]`.
  #
  # Returns -1 if any result is -1:
  #     [0, 1, 2] <=> [0, 1, 3] # => -1
  #
  # Returns 1 if any result is 1:
  #     [0, 1, 2] <=> [0, 1, 1] # => 1
  #
  # When all results are zero:
  # *   Returns -1 if `array` is smaller than `other_array`:
  #         [0, 1, 2] <=> [0, 1, 2, 3] # => -1
  #
  # *   Returns 1 if `array` is larger than `other_array`:
  #         [0, 1, 2] <=> [0, 1] # => 1
  #
  # *   Returns 0 if `array` and `other_array` are the same size:
  #         [0, 1, 2] <=> [0, 1, 2] # => 0
  #
  def <=>: (untyped) -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array == other_array -> true or false
  # -->
  # Returns `true` if both `array.size == other_array.size` and for each index `i`
  # in `array`, `array[i] == other_array[i]`:
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2.0]
  #     a1 == a0 # => true
  #     [] == [] # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method Array#eql?, which compares elements using
  # `Object#eql?`.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array[index] -> object or nil
  #   - array[start, length] -> object or nil
  #   - array[range] -> object or nil
  #   - array[aseq] -> object or nil
  #   - array.slice(index) -> object or nil
  #   - array.slice(start, length) -> object or nil
  #   - array.slice(range) -> object or nil
  #   - array.slice(aseq) -> object or nil
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When a single Integer argument `index` is given, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts relative to the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new Array
  # of size `length` containing successive elements beginning at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an Array of elements corresponding to the indexes produced by the sequence.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Array#slice is an alias for Array#[].
  #
  def []: (int index) -> Elem
        | (int start, int length) -> ::Array[Elem]?
        | (::Range[::Integer?] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array[index] = object -> object
  #   - array[start, length] = object -> object
  #   - array[range] = object -> object
  # -->
  # Assigns elements in `self`; returns the given `object`.
  #
  # When Integer argument `index` is given, assigns `object` to an element in
  # `self`.
  #
  # If `index` is non-negative, assigns `object` the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] = 'foo' # => "foo"
  #     a # => ["foo", "bar", 2]
  #
  # If `index` is greater than `self.length`, extends the array:
  #     a = [:foo, 'bar', 2]
  #     a[7] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
  #
  # If `index` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-1] = 'two' # => "two"
  #     a # => [:foo, "bar", "two"]
  #
  # When Integer arguments `start` and `length` are given and `object` is not an
  # Array, removes `length - 1` elements beginning at offset `start`, and assigns
  # `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # If `start` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-2, 2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If `start` is non-negative and outside the array (` >= self.size`), extends
  # the array with `nil`, assigns `object` at offset `start`, and ignores
  # `length`:
  #     a = [:foo, 'bar', 2]
  #     a[6, 50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `length` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[1, 0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `length` is too large for the existing array, does not extend the array:
  #     a = [:foo, 'bar', 2]
  #     a[1, 5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # When Range argument `range` is given and `object` is an Array, removes `length
  # - 1` elements beginning at offset `start`, and assigns `object` at offset
  # `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # if `range.begin` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-2..2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If the array length is less than `range.begin`, assigns `object` at offset
  # `range.begin`, and ignores `length`:
  #     a = [:foo, 'bar', 2]
  #     a[6..50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `range.end` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[1..0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `range.end` is negative, assigns `object` at offset `start`, retains
  # `range.end.abs -1` elements past that, and removes those beyond:
  #     a = [:foo, 'bar', 2]
  #     a[1..-1] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #     a = [:foo, 'bar', 2]
  #     a[1..-2] = 'foo' # => "foo"
  #     a # => [:foo, "foo", 2]
  #     a = [:foo, 'bar', 2]
  #     a[1..-3] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #     a = [:foo, 'bar', 2]
  #
  # If `range.end` is too large for the existing array, replaces array elements,
  # but does not extend the array with `nil` values:
  #     a = [:foo, 'bar', 2]
  #     a[1..5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  def []=: (int index, Elem obj) -> Elem
         | (int start, int length, Elem obj) -> Elem
         | (int start, int length, ::Array[Elem]) -> ::Array[Elem]
         | (int start, int length, nil) -> nil
         | (::Range[::Integer?], Elem obj) -> Elem
         | (::Range[::Integer?], ::Array[Elem]) -> ::Array[Elem]
         | (::Range[::Integer?], nil) -> nil

  # <!--
  #   rdoc-file=array.c
  #   - array.all? -> true or false
  #   - array.all? {|element| ... } -> true or false
  #   - array.all?(obj) -> true or false
  # -->
  # Returns `true` if all elements of `self` meet a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` contains only
  # truthy elements, `false` otherwise:
  #     [0, 1, :foo].all? # => true
  #     [0, nil, 2].all? # => false
  #     [].all? # => true
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns only truthy values, `false`
  # otherwise:
  #     [0, 1, 2].all? { |element| element < 3 } # => true
  #     [0, 1, 2].all? { |element| element < 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` every element, `false`
  # otherwise:
  #     ['food', 'fool', 'foot'].all?(/foo/) # => true
  #     ['food', 'drink'].all?(/bar/) # => false
  #     [].all?(/foo/) # => true
  #     [0, 0, 0].all?(0) # => true
  #     [0, 1, 2].all?(1) # => false
  #
  # Related: Enumerable#all?
  #
  def all?: () -> bool
          | (_Pattern[Elem] pattern) -> bool
          | () { (Elem obj) -> boolish } -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.any? -> true or false
  #   - array.any? {|element| ... } -> true or false
  #   - array.any?(obj) -> true or false
  # -->
  # Returns `true` if any element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has any truthy
  # element, `false` otherwise:
  #     [nil, 0, false].any? # => true
  #     [nil, false].any? # => false
  #     [].any? # => false
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns any truthy value, `false`
  # otherwise:
  #     [0, 1, 2].any? {|element| element > 1 } # => true
  #     [0, 1, 2].any? {|element| element > 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj`.`===` any element, `false`
  # otherwise:
  #     ['food', 'drink'].any?(/foo/) # => true
  #     ['food', 'drink'].any?(/bar/) # => false
  #     [].any?(/foo/) # => false
  #     [0, 1, 2].any?(1) # => true
  #     [0, 1, 2].any?(3) # => false
  #
  # Related: Enumerable#any?
  #
  alias any? all?

  # <!-- rdoc-file=array.c -->
  # Appends trailing elements.
  #
  # Appends each argument in `objects` to `self`;  returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.push([:baz, :bat], [:bam, :bad])
  #     a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Array#append is an alias for Array#push.
  #
  # Related: #pop, #shift, #unshift.
  #
  alias append push

  # <!--
  #   rdoc-file=array.c
  #   - array.assoc(obj) -> found_array or nil
  # -->
  # Returns the first element in `self` that is an Array whose first element `==`
  # `obj`:
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.assoc(4) # => [4, 5, 6]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: #rassoc.
  #
  def assoc: (untyped) -> ::Array[untyped]?

  # <!--
  #   rdoc-file=array.c
  #   - array.at(index) -> object
  # -->
  # Returns the element at Integer offset `index`; does not modify `self`.
  #     a = [:foo, 'bar', 2]
  #     a.at(0) # => :foo
  #     a.at(2) # => 2
  #
  def at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.bsearch {|element| ... } -> object
  #   - array.bsearch -> new_enumerator
  # -->
  # Returns an element from `self` selected by a binary search.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.bsearch_index {|element| ... } -> integer or nil
  #   - array.bsearch_index -> new_enumerator
  # -->
  # Searches `self` as described at method #bsearch, but returns the *index* of
  # the found element instead of the element itself.
  #
  def bsearch_index: () { (Elem) -> (true | false) } -> ::Integer?
                   | () { (Elem) -> ::Integer } -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array.clear -> self
  # -->
  # Removes all elements from `self`:
  #     a = [:foo, 'bar', 2]
  #     a.clear # => []
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.map {|element| ... } -> new_array
  #   - array.map -> new_enumerator
  # -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # whose elements are the return values from the block:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map>
  #
  # Array#collect is an alias for Array#map.
  #
  def collect: [U] () { (Elem item) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - array.map! {|element| ... } -> self
  #   - array.map! -> new_enumerator
  # -->
  # Calls the block, if given, with each element; replaces the element with the
  # block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map!
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map!>
  #
  # Array#collect! is an alias for Array#map!.
  #
  def collect!: () { (Elem item) -> Elem } -> self
              | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.combination(n) {|element| ... } -> self
  #   - array.combination(n) -> new_enumerator
  # -->
  # Calls the block, if given, with combinations of elements of `self`; returns
  # `self`. The order of combinations is indeterminate.
  #
  # When a block and an in-range positive Integer argument `n` (`0 < n <=
  # self.size`) are given, calls the block with all `n`-tuple combinations of
  # `self`.
  #
  # Example:
  #     a = [0, 1, 2]
  #     a.combination(2) {|combination| p combination }
  #
  # Output:
  #     [0, 1]
  #     [0, 2]
  #     [1, 2]
  #
  # Another example:
  #     a = [0, 1, 2]
  #     a.combination(3) {|combination| p combination }
  #
  # Output:
  #     [0, 1, 2]
  #
  # When `n` is zero, calls the block once with a new empty Array:
  #     a = [0, 1, 2]
  #     a1 = a.combination(0) {|combination| p combination }
  #
  # Output:
  #     []
  #
  # When `n` is out of range (negative or larger than `self.size`), does not call
  # the block:
  #     a = [0, 1, 2]
  #     a.combination(-1) {|combination| fail 'Cannot happen' }
  #     a.combination(4) {|combination| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>
  #
  def combination: (int n) { (::Array[Elem]) -> void } -> self
                 | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - array.compact -> new_array
  # -->
  # Returns a new Array containing all non-`nil` elements from `self`:
  #     a = [nil, 0, nil, 1, nil, 2, nil]
  #     a.compact # => [0, 1, 2]
  #
  def compact: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.compact! -> self or nil
  # -->
  # Removes all `nil` elements from `self`.
  #
  # Returns `self` if any elements removed, otherwise `nil`.
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.concat(*other_arrays) -> self
  # -->
  # Adds to `array` all elements from each Array in `other_arrays`; returns
  # `self`:
  #     a = [0, 1]
  #     a.concat([2, 3], [4, 5]) # => [0, 1, 2, 3, 4, 5]
  #
  def concat: (*::Array[Elem] arrays) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.count -> an_integer
  #   - array.count(obj) -> an_integer
  #   - array.count {|element| ... } -> an_integer
  # -->
  # Returns a count of specified elements.
  #
  # With no argument and no block, returns the count of all elements:
  #     [0, 1, 2].count # => 3
  #     [].count # => 0
  #
  # With argument `obj`, returns the count of elements `==` to `obj`:
  #     [0, 1, 2, 0.0].count(0) # => 2
  #     [0, 1, 2].count(3) # => 0
  #
  # With no argument and a block given, calls the block with each element; returns
  # the count of elements for which the block returns a truthy value:
  #     [0, 1, 2, 3].count {|element| element > 1} # => 2
  #
  # With argument `obj` and a block given, issues a warning, ignores the block,
  # and returns the count of elements `==` to `obj`:
  #
  def count: () -> ::Integer
           | (Elem obj) -> ::Integer
           | () { (Elem) -> boolish } -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.cycle {|element| ... } -> nil
  #   - array.cycle(count) {|element| ... } -> nil
  #   - array.cycle -> new_enumerator
  #   - array.cycle(count) -> new_enumerator
  # -->
  # When called with positive Integer argument `count` and a block, calls the
  # block with each element, then does so again, until it has done so `count`
  # times; returns `nil`:
  #     output = []
  #     [0, 1].cycle(2) {|element| output.push(element) } # => nil
  #     output # => [0, 1, 0, 1]
  #
  # If `count` is zero or negative, does not call the block:
  #     [0, 1].cycle(0) {|element| fail 'Cannot happen' } # => nil
  #     [0, 1].cycle(-1) {|element| fail 'Cannot happen' } # => nil
  #
  # When a block is given, and argument is omitted or `nil`, cycles forever:
  #     # Prints 0 and 1 forever.
  #     [0, 1].cycle {|element| puts element }
  #     [0, 1].cycle(nil) {|element| puts element }
  #
  # When no block is given, returns a new Enumerator:
  #
  #     [0, 1].cycle(2) # => #<Enumerator: [0, 1]:cycle(2)>
  #     [0, 1].cycle # => # => #<Enumerator: [0, 1]:cycle>
  #     [0, 1].cycle.first(5) # => [0, 1, 0, 1, 0]
  #
  def cycle: (?int? n) { (Elem) -> void } -> nil
           | (?int? n) -> ::Enumerator[Elem, nil]

  # <!--
  #   rdoc-file=array.c
  #   - deconstruct()
  # -->
  #
  def deconstruct: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.delete(obj) -> deleted_object
  #   - array.delete(obj) {|nosuch| ... } -> deleted_object or block_return
  # -->
  # Removes zero or more elements from `self`; returns `self`.
  #
  # When no block is given, removes from `self` each element `ele` such that `ele
  # == obj`; returns the last deleted element:
  #     s1 = 'bar'; s2 = 'bar'
  #     a = [:foo, s1, 2, s2]
  #     a.delete('bar') # => "bar"
  #     a # => [:foo, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # When a block is given, removes from `self` each element `ele` such that `ele
  # == obj`.
  #
  # If any such elements are found, ignores the block and returns the last deleted
  # element:
  #     s1 = 'bar'; s2 = 'bar'
  #     a = [:foo, s1, 2, s2]
  #     deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
  #     a # => [:foo, 2]
  #
  # If no such elements are found, returns the block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.delete(:nosuch) {|obj| "#{obj} not found" } # => "nosuch not found"
  #
  def delete: (Elem obj) -> Elem?
            | [S, T] (S obj) { (S) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_at(index) -> deleted_object or nil
  # -->
  # Deletes an element from `self`, per the given Integer `index`.
  #
  # When `index` is non-negative, deletes the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # If index is too large, returns `nil`.
  #
  # When `index` is negative, counts backward from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(-2) # => "bar"
  #     a # => [:foo, 2]
  #
  # If `index` is too small (far from zero), returns nil.
  #
  def delete_at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_if {|element| ... } -> self
  #   - array.delete_if -> Enumerator
  # -->
  # Removes each element in `self` for which the block returns a truthy value;
  # returns `self`:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.delete_if {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.delete_if # => #<Enumerator: [:foo, "bar", 2]:delete_if>
  #
  def delete_if: () { (Elem item) -> boolish } -> self
               | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.difference(*other_arrays) -> new_array
  # -->
  # Returns a new Array containing only those elements from `self` that are not
  # found in any of the Arrays `other_arrays`; items are compared using `eql?`;
  # order from `self` is preserved:
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # => [0, 2, 3]
  #     [0, 1, 2, 3].difference([3, 0], [1, 3]) # => [2]
  #     [0, 1, 2].difference([4]) # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#-.
  #
  def difference: (*::Array[untyped] arrays) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.dig(index, *identifiers) -> object
  # -->
  # Finds and returns the object in nested objects that is specified by `index`
  # and `identifiers`. The nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Examples:
  #     a = [:foo, [:bar, :baz, [:bat, :bam]]]
  #     a.dig(1) # => [:bar, :baz, [:bat, :bam]]
  #     a.dig(1, 2) # => [:bat, :bam]
  #     a.dig(1, 2, 0) # => :bat
  #     a.dig(1, 2, 3) # => nil
  #
  def dig: (int idx) -> Elem?
         | (int idx, untyped, *untyped) -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - array.drop(n) -> new_array
  # -->
  # Returns a new Array containing all but the first `n` element of `self`, where
  # `n` is a non-negative Integer; does not modify `self`.
  #
  # Examples:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop(0) # => [0, 1, 2, 3, 4, 5]
  #     a.drop(1) # => [1, 2, 3, 4, 5]
  #     a.drop(2) # => [2, 3, 4, 5]
  #
  def drop: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.drop_while {|element| ... } -> new_array
  #   - array.drop_while -> new_enumerator
  # -->
  # Returns a new Array containing zero or more trailing elements of `self`; does
  # not modify `self`.
  #
  # With a block given, calls the block with each successive element of `self`;
  # stops if the block returns `false` or `nil`; returns a new Array *omitting*
  # those elements for which the block returned a truthy value:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop_while {|element| element < 3 } # => [3, 4, 5]
  #
  # With no block given, returns a new Enumerator:
  #     [0, 1].drop_while # => # => #<Enumerator: [0, 1]:drop_while>
  #
  def drop_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.each {|element| ... } -> self
  #   - array.each -> Enumerator
  # -->
  # Iterates over array elements.
  #
  # When a block given, passes each successive array element to the block; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #     foo
  #     bar
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.each
  #     e # => #<Enumerator: [:foo, "bar", 2]:each>
  #     a1 = e.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Related: #each_index, #reverse_each.
  #
  def each: () -> ::Enumerator[Elem, self]
          | () { (Elem item) -> void } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.each_index {|index| ... } -> self
  #   - array.each_index -> Enumerator
  # -->
  # Iterates over array indexes.
  #
  # When a block given, passes each successive array index to the block; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index|  puts "#{index} #{a[index]}" }
  #
  # Output:
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index| puts index; a.clear if index > 0 }
  #
  # Output:
  #     0
  #     1
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.each_index
  #     e # => #<Enumerator: [:foo, "bar", 2]:each_index>
  #     a1 = e.each {|index|  puts "#{index} #{a[index]}"}
  #
  # Output:
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Related: #each, #reverse_each.
  #
  def each_index: () { (::Integer index) -> void } -> self
                | () -> ::Enumerator[::Integer, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.empty?  -> true or false
  # -->
  # Returns `true` if the count of elements in `self` is zero, `false` otherwise.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.eql? other_array -> true or false
  # -->
  # Returns `true` if `self` and `other_array` are the same size, and if, for each
  # index `i` in `self`, `self[i].eql? other_array[i]`:
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2]
  #     a1.eql?(a0) # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method [Array#==](#method-i-3D-3D), which
  # compares using method `Object#==`.
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.fetch(index) -> element
  #   - array.fetch(index, default_value) -> element
  #   - array.fetch(index) {|index| ... } -> element
  # -->
  # Returns the element at offset  `index`.
  #
  # With the single Integer argument `index`, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1) # => "bar"
  #
  # If `index` is negative, counts from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(-1) # => 2
  #     a.fetch(-2) # => "bar"
  #
  # With arguments `index` and `default_value`, returns the element at offset
  # `index` if index is in range, otherwise returns `default_value`:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1, nil) # => "bar"
  #
  # With argument `index` and a block, returns the element at offset `index` if
  # index is in range (and the block is not called); otherwise calls the block
  # with index and returns its return value:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1) {|index| raise 'Cannot happen' } # => "bar"
  #     a.fetch(50) {|index| "Value for #{index}" } # => "Value for 50"
  #
  def fetch: (int index) -> Elem
           | [T] (int index, T default) -> (Elem | T)
           | [T] (int index) { (int index) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.c
  #   - array.fill(obj) -> self
  #   - array.fill(obj, start) -> self
  #   - array.fill(obj, start, length) -> self
  #   - array.fill(obj, range) -> self
  #   - array.fill {|index| ... } -> self
  #   - array.fill(start) {|index| ... } -> self
  #   - array.fill(start, length) {|index| ... } -> self
  #   - array.fill(range) {|index| ... } -> self
  # -->
  # Replaces specified elements in `self` with specified objects; returns `self`.
  #
  # With argument `obj` and no block given, replaces all elements with that one
  # object:
  #     a = ['a', 'b', 'c', 'd']
  #     a # => ["a", "b", "c", "d"]
  #     a.fill(:X) # => [:X, :X, :X, :X]
  #
  # With arguments `obj` and Integer `start`, and no block given, replaces
  # elements based on the given start.
  #
  # If `start` is in range (`0 <= start < array.size`), replaces all elements from
  # offset `start` through the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 2) # => ["a", "b", :X, :X]
  #
  # If `start` is too large (`start >= array.size`), does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 4) # => ["a", "b", "c", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5) # => ["a", "b", "c", "d"]
  #
  # If `start` is negative, counts from the end (starting index is `start +
  # array.size`):
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -2) # => ["a", "b", :X, :X]
  #
  # If `start` is too small (less than and far from zero), replaces all elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -6) # => [:X, :X, :X, :X]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -50) # => [:X, :X, :X, :X]
  #
  # With arguments `obj`, Integer `start`, and Integer `length`, and no block
  # given, replaces elements based on the given `start` and `length`.
  #
  # If `start` is in range, replaces `length` elements beginning at offset
  # `start`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 1, 1) # => ["a", :X, "c", "d"]
  #
  # If `start` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -2, 1) # => ["a", "b", :X, "d"]
  #
  # If `start` is large (`start >= array.size`), extends `self` with `nil`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5, 0) # => ["a", "b", "c", "d", nil]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5, 2) # => ["a", "b", "c", "d", nil, :X, :X]
  #
  # If `length` is zero or negative, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 1, 0) # => ["a", "b", "c", "d"]
  #     a.fill(:X, 1, -1) # => ["a", "b", "c", "d"]
  #
  # With arguments `obj` and Range `range`, and no block given, replaces elements
  # based on the given range.
  #
  # If the range is positive and ascending (`0 < range.begin <= range.end`),
  # replaces elements from `range.begin` to `range.end`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (1..1)) # => ["a", :X, "c", "d"]
  #
  # If `range.first` is negative, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-1..1)) # => ["a", "b", "c", "d"]
  #
  # If `range.last` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (0..-2)) # => [:X, :X, :X, "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (1..-2)) # => ["a", :X, :X, "d"]
  #
  # If `range.last` and `range.last` are both negative, both count from the end of
  # the array:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-1..-1)) # => ["a", "b", "c", :X]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-2..-2)) # => ["a", "b", :X, "d"]
  #
  # With no arguments and a block given, calls the block with each index; replaces
  # the corresponding element with the block's return value:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #
  # With argument `start` and a block given, calls the block with each index from
  # offset `start` to the end; replaces the corresponding element with the block's
  # return value:
  #
  # If start is in range (`0 <= start < array.size`), replaces from offset `start`
  # to the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "new_3"]
  #
  # If `start` is too large(`start >= array.size`), does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # If `start` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "new_3"]
  #
  # If start is too small (`start <= -array.size`, replaces all elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-6) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-50) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #
  # With arguments `start` and `length`, and a block given, calls the block for
  # each index specified by start length; replaces the corresponding element with
  # the block's return value.
  #
  # If `start` is in range, replaces `length` elements beginning at offset
  # `start`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1, 1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]
  #
  # If start is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2, 1) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]
  #
  # If `start` is large (`start >= array.size`), extends `self` with `nil`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(5, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(5, 2) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil, "new_5", "new_6"]
  #
  # If `length` is zero or less, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]
  #     a.fill(1, -1) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]
  #
  # With arguments `obj` and `range`, and a block given, calls the block with each
  # index in the given range; replaces the corresponding element with the block's
  # return value.
  #
  # If the range is positive and ascending (`range 0 < range.begin <= range.end`,
  # replaces elements from `range.begin` to `range.end`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1..1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]
  #
  # If `range.first` is negative, does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-1..1) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # If `range.last` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(0..-2) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1..-2) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "d"]
  #
  # If `range.first` and `range.last` are both negative, both count from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-1..-1) { |index| "new_#{index}" } # => ["a", "b", "c", "new_3"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2..-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]
  #
  def fill: (Elem obj) -> self
          | (Elem obj, int? start, ?int? length) -> self
          | (Elem obj, ::Range[::Integer] range) -> self
          | (?int? start, ?int? length) { (::Integer index) -> Elem } -> self
          | (::Range[::Integer] range) { (::Integer index) -> Elem } -> self

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # containing those elements of `self` for which the block returns a truthy
  # value:
  #     a = [:foo, 'bar', 2, :bam]
  #     a1 = a.select {|element| element.to_s.start_with?('b') }
  #     a1 # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>
  #
  # Array#filter is an alias for Array#select.
  #
  def filter: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given  with each element of `self`; removes from `self`
  # those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>
  #
  # Array#filter! is an alias for Array#select!.
  #
  def filter!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.index(object) -> integer or nil
  #   - array.index {|element| ... } -> integer or nil
  #   - array.index -> new_enumerator
  # -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  def find_index: (untyped obj) -> ::Integer?
                | () { (Elem item) -> boolish } -> ::Integer?
                | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.c
  #   - array.first -> object or nil
  #   - array.first(n) -> new_array
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When no argument is given, returns the first element:
  #     a = [:foo, 'bar', 2]
  #     a.first # => :foo
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Integer argument `n` is given, returns the first `n`
  # elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.first(2) # => [:foo, "bar"]
  #
  # If `n >= array.size`, returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.first(50) # => [:foo, "bar", 2]
  #
  # If `n == 0` returns an new empty Array:
  #     a = [:foo, 'bar', 2]
  #     a.first(0) # []
  #
  # Related: #last.
  #
  def first: () -> Elem?
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.flatten -> new_array
  #   - array.flatten(level) -> new_array
  # -->
  # Returns a new Array that is a recursive flattening of `self`:
  # *   Each non-Array element is unchanged.
  # *   Each Array is replaced by its individual elements.
  #
  #
  # With non-negative Integer argument `level`, flattens recursively through
  # `level` levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(0) # => [0, [1, [2, 3], 4], 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(1) # => [0, 1, [2, 3], 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(2) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(3) # => [0, 1, 2, 3, 4, 5]
  #
  # With no argument, a `nil` argument, or with negative argument `level`,
  # flattens all levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten # => [0, 1, 2]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(-1) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(-2) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten(-1) # => [0, 1, 2]
  #
  def flatten: (?int level) -> ::Array[untyped]

  # <!--
  #   rdoc-file=array.c
  #   - array.flatten! -> self or nil
  #   - array.flatten!(level) -> self or nil
  # -->
  # Replaces each nested Array in `self` with the elements from that Array;
  # returns `self` if any changes, `nil` otherwise.
  #
  # With non-negative Integer argument `level`, flattens recursively through
  # `level` levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(1) # => [0, 1, [2, 3], 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(2) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(3) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten!(1) # => nil
  #
  # With no argument, a `nil` argument, or with negative argument `level`,
  # flattens all levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten! # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten! # => nil
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(-1) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(-2) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten!(-1) # => nil
  #
  def flatten!: (?int level) -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two arrays with the same content will have the same hash code (and will
  # compare using eql?):
  #     [0, 1, 2].hash == [0, 1, 2].hash # => true
  #     [0, 1, 2].hash == [0, 1, 3].hash # => false
  #
  def hash: () -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.include?(obj) -> true or false
  # -->
  # Returns `true` if for some index `i` in `self`, `obj == self[i]`; otherwise
  # `false`:
  #     [0, 1, 2].include?(2) # => true
  #     [0, 1, 2].include?(3) # => false
  #
  def include?: (Elem object) -> bool

  # <!-- rdoc-file=array.c -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  alias index find_index

  # <!--
  #   rdoc-file=array.c
  #   - array.insert(index, *objects) -> self
  # -->
  # Inserts given `objects` before or after the element at Integer index `offset`;
  # returns `self`.
  #
  # When `index` is non-negative, inserts all given `objects` before the element
  # at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.insert(1, :bat, :bam) # => [:foo, :bat, :bam, "bar", 2]
  #
  # Extends the array if `index` is beyond the array (`index >= self.size`):
  #     a = [:foo, 'bar', 2]
  #     a.insert(5, :bat, :bam)
  #     a # => [:foo, "bar", 2, nil, nil, :bat, :bam]
  #
  # Does nothing if no objects given:
  #     a = [:foo, 'bar', 2]
  #     a.insert(1)
  #     a.insert(50)
  #     a.insert(-50)
  #     a # => [:foo, "bar", 2]
  #
  # When `index` is negative, inserts all given `objects` *after* the element at
  # offset `index+self.size`:
  #     a = [:foo, 'bar', 2]
  #     a.insert(-2, :bat, :bam)
  #     a # => [:foo, "bar", :bat, :bam, 2]
  #
  def insert: (int index, *Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.inspect -> new_string
  # -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=array.c
  #   - ary.intersect?(other_ary)   -> true or false
  # -->
  # Returns `true` if the array and `other_ary` have at least one element in
  # common, otherwise returns `false`.
  #
  #     a = [ 1, 2, 3 ]
  #     b = [ 3, 4, 5 ]
  #     c = [ 5, 6, 7 ]
  #     a.intersect?(b)   #=> true
  #     a.intersect?(c)   #=> false
  #
  def intersect?: (_ToAry[untyped]) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.intersection(*other_arrays) -> new_array
  # -->
  # Returns a new Array containing each element found both in `self` and in all of
  # the given Arrays `other_arrays`; duplicates are omitted; items are compared
  # using `eql?`:
  #     [0, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
  #     [0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
  #
  # Preserves order from `self`:
  #     [0, 1, 2].intersection([2, 1, 0]) # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#&.
  #
  def intersection: (*::Array[untyped] | _ToAry[untyped] other_ary) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.join ->new_string
  #   - array.join(separator = $,) -> new_string
  # -->
  # Returns the new String formed by joining the array elements after conversion.
  # For each element `element`
  # *   Uses `element.to_s` if `element` is not a `kind_of?(Array)`.
  # *   Uses recursive `element.join(separator)` if `element` is a
  #     `kind_of?(Array)`.
  #
  #
  # With no argument, joins using the output field separator, `$,`:
  #     a = [:foo, 'bar', 2]
  #     $, # => nil
  #     a.join # => "foobar2"
  #
  # With string argument `separator`, joins using that separator:
  #     a = [:foo, 'bar', 2]
  #     a.join("\n") # => "foo\nbar\n2"
  #
  # Joins recursively for nested Arrays:
  #     a = [:foo, [:bar, [:baz, :bat]]]
  #     a.join # => "foobarbazbat"
  #
  def join: (?string separator) -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.keep_if {|element| ... } -> self
  #   - array.keep_if -> new_enumeration
  # -->
  # Retains those elements for which the block returns a truthy value; deletes all
  # other elements; returns `self`:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.keep_if # => #<Enumerator: [:foo, "bar", 2, :bam]:keep_if>
  #
  def keep_if: () { (Elem item) -> boolish } -> self
             | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.last  -> object or nil
  #   - array.last(n) -> new_array
  # -->
  # Returns elements from `self`; `self` is not modified.
  #
  # When no argument is given, returns the last element:
  #     a = [:foo, 'bar', 2]
  #     a.last # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Innteger argument `n` is given, returns the last `n`
  # elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.last(2) # => ["bar", 2]
  #
  # If `n >= array.size`, returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.last(50) # => [:foo, "bar", 2]
  #
  # If `n == 0`, returns an new empty Array:
  #     a = [:foo, 'bar', 2]
  #     a.last(0) # []
  #
  # Related: #first.
  #
  def last: () -> Elem?
          | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.length -> an_integer
  # -->
  # Returns the count of elements in `self`.
  #
  def length: () -> ::Integer

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # whose elements are the return values from the block:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map>
  #
  # Array#collect is an alias for Array#map.
  #
  alias map collect

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element; replaces the element with the
  # block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map!
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map!>
  #
  # Array#collect! is an alias for Array#map!.
  #
  alias map! collect!

  # <!--
  #   rdoc-file=array.c
  #   - array.max -> element
  #   - array.max {|a, b| ... } -> element
  #   - array.max(n) -> new_array
  #   - array.max(n) {|a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  # *   The maximum-valued element from `self`.
  # *   A new Array of maximum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # maximum value per method `<=>`:
  #     [0, 1, 2].max # => 2
  #
  # With an argument Integer `n` and no block, returns a new Array with at most
  # `n` elements, in descending order per method `<=>`:
  #     [0, 1, 2, 3].max(3) # => [3, 2, 1]
  #     [0, 1, 2, 3].max(6) # => [3, 2, 1, 0]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the maximum value per the block:
  #     ['0', '00', '000'].max {|a, b| a.size <=> b.size } # => "000"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in descending order per the block:
  #     ['0', '00', '000'].max(2) {|a, b| a.size <=> b.size } # => ["000", "00"]
  #
  def max: () -> Elem?
         | () { (Elem a, Elem b) -> ::Integer? } -> Elem?
         | (int n) -> ::Array[Elem]
         | (int n) { (Elem a, Elem b) -> ::Integer? } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.min -> element
  #   - array.min { |a, b| ... } -> element
  #   - array.min(n) -> new_array
  #   - array.min(n) { |a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  # *   The minimum-valued element from `self`.
  # *   A new Array of minimum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # minimum value per method `<=>`:
  #     [0, 1, 2].min # => 0
  #
  # With Integer argument `n` and no block, returns a new Array with at most `n`
  # elements, in ascending order per method `<=>`:
  #     [0, 1, 2, 3].min(3) # => [0, 1, 2]
  #     [0, 1, 2, 3].min(6) # => [0, 1, 2, 3]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the minimum value per the block:
  #     ['0', '00', '000'].min { |a, b| a.size <=> b.size } # => "0"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in ascending order per the block:
  #     ['0', '00', '000'].min(2) {|a, b| a.size <=> b.size } # => ["0", "00"]
  #
  alias min max

  # <!--
  #   rdoc-file=array.c
  #   - array.minmax -> [min_val, max_val]
  #   - array.minmax {|a, b| ... } -> [min_val, max_val]
  # -->
  # Returns a new 2-element Array containing the minimum and maximum values from
  # `self`, either per method `<=>` or per a given block:.
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer; returns a new 2-element Array containing the minimum and
  # maximum values from `self`, per method `<=>`:
  #     [0, 1, 2].minmax # => [0, 2]
  #
  # When a block is given, the block must return an Integer; the block is called
  # `self.size-1` times to compare elements; returns a new 2-element Array
  # containing the minimum and maximum values from `self`, per the block:
  #     ['0', '00', '000'].minmax {|a, b| a.size <=> b.size } # => ["0", "000"]
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem a, Elem b) -> ::Integer? } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=array.c
  #   - array.none? -> true or false
  #   - array.none? {|element| ... } -> true or false
  #   - array.none?(obj) -> true or false
  # -->
  # Returns `true` if no element of `self` meet a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has no truthy
  # elements, `false` otherwise:
  #     [nil, false].none? # => true
  #     [nil, 0, false].none? # => false
  #     [].none? # => true
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns no truthy value, `false`
  # otherwise:
  #     [0, 1, 2].none? {|element| element > 3 } # => true
  #     [0, 1, 2].none? {|element| element > 1 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` no element, `false`
  # otherwise:
  #     ['food', 'drink'].none?(/bar/) # => true
  #     ['food', 'drink'].none?(/foo/) # => false
  #     [].none?(/foo/) # => true
  #     [0, 1, 2].none?(3) # => true
  #     [0, 1, 2].none?(1) # => false
  #
  # Related: Enumerable#none?
  #
  alias none? all?

  # <!--
  #   rdoc-file=array.c
  #   - array.one? -> true or false
  #   - array.one? {|element| ... } -> true or false
  #   - array.one?(obj) -> true or false
  # -->
  # Returns `true` if exactly one element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has exactly one
  # truthy element, `false` otherwise:
  #     [nil, 0].one? # => true
  #     [0, 0].one? # => false
  #     [nil, nil].one? # => false
  #     [].one? # => false
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block a truthy value for exactly one element,
  # `false` otherwise:
  #     [0, 1, 2].one? {|element| element > 0 } # => false
  #     [0, 1, 2].one? {|element| element > 1 } # => true
  #     [0, 1, 2].one? {|element| element > 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` exactly one element,
  # `false` otherwise:
  #     [0, 1, 2].one?(0) # => true
  #     [0, 0, 1].one?(0) # => false
  #     [1, 1, 2].one?(0) # => false
  #     ['food', 'drink'].one?(/bar/) # => false
  #     ['food', 'drink'].one?(/foo/) # => true
  #     [].one?(/foo/) # => false
  #
  # Related: Enumerable#one?
  #
  alias one? none?

  # <!--
  #   rdoc-file=pack.rb
  #   - arr.pack( aTemplateString ) -> aBinaryString
  #   - arr.pack( aTemplateString, buffer: aBufferString ) -> aBufferString
  # -->
  # Packs the contents of *arr* into a binary sequence according to the directives
  # in *aTemplateString* (see the table below) Directives ``A,'' ``a,'' and ``Z''
  # may be followed by a count, which gives the width of the resulting field. The
  # remaining directives also may take a count, indicating the number of array
  # elements to convert. If the count is an asterisk (```*`''), all remaining
  # array elements will be converted. Any of the directives ```sSiIlL`'' may be
  # followed by an underscore (```_`'') or exclamation mark (```!`'') to use the
  # underlying platform's native size for the specified type; otherwise, they use
  # a platform-independent size. Spaces are ignored in the template string. See
  # also String#unpack.
  #
  #     a = [ "a", "b", "c" ]
  #     n = [ 65, 66, 67 ]
  #     a.pack("A3A3A3")   #=> "a  b  c  "
  #     a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
  #     n.pack("ccc")      #=> "ABC"
  #
  # If *aBufferString* is specified and its capacity is enough, `pack` uses it as
  # the buffer and returns it. When the offset is specified by the beginning of
  # *aTemplateString*, the result is filled after the offset. If original contents
  # of *aBufferString* exists and it's longer than the offset, the rest of
  # *offsetOfBuffer* are overwritten by the result. If it's shorter, the gap is
  # filled with ```\0`''.
  #
  #     # packed data is appended by default
  #     [255].pack("C", buffer:"foo".b) #=> "foo\xFF"
  #
  #     # "@0" (offset 0) specifies that packed data is filled from beginning.
  #     # Also, original data after packed data is removed. ("oo" is removed.)
  #     [255].pack("@0C", buffer:"foo".b) #=> "\xFF"
  #
  #     # If the offset is bigger than the original length, \x00 is filled.
  #     [255].pack("@5C", buffer:"foo".b) #=> "foo\x00\x00\xFF"
  #
  # Note that ``buffer:'' option does not guarantee not to allocate memory in
  # `pack`.  If the capacity of *aBufferString* is not enough, `pack` allocates
  # memory.
  #
  # Directives for `pack`.
  #
  #     Integer       | Array   |
  #     Directive     | Element | Meaning
  #     ----------------------------------------------------------------------------
  #     C             | Integer | 8-bit unsigned (unsigned char)
  #     S             | Integer | 16-bit unsigned, native endian (uint16_t)
  #     L             | Integer | 32-bit unsigned, native endian (uint32_t)
  #     Q             | Integer | 64-bit unsigned, native endian (uint64_t)
  #     J             | Integer | pointer width unsigned, native endian (uintptr_t)
  #                   |         | (J is available since Ruby 2.3.)
  #                   |         |
  #     c             | Integer | 8-bit signed (signed char)
  #     s             | Integer | 16-bit signed, native endian (int16_t)
  #     l             | Integer | 32-bit signed, native endian (int32_t)
  #     q             | Integer | 64-bit signed, native endian (int64_t)
  #     j             | Integer | pointer width signed, native endian (intptr_t)
  #                   |         | (j is available since Ruby 2.3.)
  #                   |         |
  #     S_ S!         | Integer | unsigned short, native endian
  #     I I_ I!       | Integer | unsigned int, native endian
  #     L_ L!         | Integer | unsigned long, native endian
  #     Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #                   |         | (Q_ and Q! is available since Ruby 2.1.)
  #     J!            | Integer | uintptr_t, native endian (same with J)
  #                   |         | (J! is available since Ruby 2.3.)
  #                   |         |
  #     s_ s!         | Integer | signed short, native endian
  #     i i_ i!       | Integer | signed int, native endian
  #     l_ l!         | Integer | signed long, native endian
  #     q_ q!         | Integer | signed long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #                   |         | (q_ and q! is available since Ruby 2.1.)
  #     j!            | Integer | intptr_t, native endian (same with j)
  #                   |         | (j! is available since Ruby 2.3.)
  #                   |         |
  #     S> s> S!> s!> | Integer | same as the directives without ">" except
  #     L> l> L!> l!> |         | big endian
  #     I!> i!>       |         | (available since Ruby 1.9.3)
  #     Q> q> Q!> q!> |         | "S>" is the same as "n"
  #     J> j> J!> j!> |         | "L>" is the same as "N"
  #                   |         |
  #     S< s< S!< s!< | Integer | same as the directives without "<" except
  #     L< l< L!< l!< |         | little endian
  #     I!< i!<       |         | (available since Ruby 1.9.3)
  #     Q< q< Q!< q!< |         | "S<" is the same as "v"
  #     J< j< J!< j!< |         | "L<" is the same as "V"
  #                   |         |
  #     n             | Integer | 16-bit unsigned, network (big-endian) byte order
  #     N             | Integer | 32-bit unsigned, network (big-endian) byte order
  #     v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
  #     V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
  #                   |         |
  #     U             | Integer | UTF-8 character
  #     w             | Integer | BER-compressed integer
  #
  #     Float        | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     D d          | Float   | double-precision, native format
  #     F f          | Float   | single-precision, native format
  #     E            | Float   | double-precision, little-endian byte order
  #     e            | Float   | single-precision, little-endian byte order
  #     G            | Float   | double-precision, network (big-endian) byte order
  #     g            | Float   | single-precision, network (big-endian) byte order
  #
  #     String       | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     A            | String  | arbitrary binary string (space padded, count is width)
  #     a            | String  | arbitrary binary string (null padded, count is width)
  #     Z            | String  | same as ``a'', except that null is added with *
  #     B            | String  | bit string (MSB first)
  #     b            | String  | bit string (LSB first)
  #     H            | String  | hex string (high nibble first)
  #     h            | String  | hex string (low nibble first)
  #     u            | String  | UU-encoded string
  #     M            | String  | quoted printable, MIME encoding (see also RFC2045)
  #                  |         | (text mode but input must use LF and output LF)
  #     m            | String  | base64 encoded string (see RFC 2045)
  #                  |         | (if count is 0, no line feed are added, see RFC 4648)
  #                  |         | (count specifies input bytes between each LF,
  #                  |         | rounded down to nearest multiple of 3)
  #     P            | String  | pointer to a structure (fixed-length string)
  #     p            | String  | pointer to a null-terminated string
  #
  #     Misc.        | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     @            | ---     | moves to absolute position
  #     X            | ---     | back up a byte
  #     x            | ---     | null byte
  #
  def pack: (string fmt, ?buffer: String?) -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.permutation {|element| ... } -> self
  #   - array.permutation(n) {|element| ... } -> self
  #   - array.permutation -> new_enumerator
  #   - array.permutation(n) -> new_enumerator
  # -->
  # When invoked with a block, yield all permutations of elements of `self`;
  # returns `self`. The order of permutations is indeterminate.
  #
  # When a block and an in-range positive Integer argument `n` (`0 < n <=
  # self.size`) are given, calls the block with all `n`-tuple permutations of
  # `self`.
  #
  # Example:
  #     a = [0, 1, 2]
  #     a.permutation(2) {|permutation| p permutation }
  #
  # Output:
  #     [0, 1]
  #     [0, 2]
  #     [1, 0]
  #     [1, 2]
  #     [2, 0]
  #     [2, 1]
  #
  # Another example:
  #     a = [0, 1, 2]
  #     a.permutation(3) {|permutation| p permutation }
  #
  # Output:
  #     [0, 1, 2]
  #     [0, 2, 1]
  #     [1, 0, 2]
  #     [1, 2, 0]
  #     [2, 0, 1]
  #     [2, 1, 0]
  #
  # When `n` is zero, calls the block once with a new empty Array:
  #     a = [0, 1, 2]
  #     a.permutation(0) {|permutation| p permutation }
  #
  # Output:
  #     []
  #
  # When `n` is out of range (negative or larger than `self.size`), does not call
  # the block:
  #     a = [0, 1, 2]
  #     a.permutation(-1) {|permutation| fail 'Cannot happen' }
  #     a.permutation(4) {|permutation| fail 'Cannot happen' }
  #
  # When a block given but no argument, behaves the same as
  # `a.permutation(a.size)`:
  #     a = [0, 1, 2]
  #     a.permutation {|permutation| p permutation }
  #
  # Output:
  #     [0, 1, 2]
  #     [0, 2, 1]
  #     [1, 0, 2]
  #     [1, 2, 0]
  #     [2, 0, 1]
  #     [2, 1, 0]
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.permutation # => #<Enumerator: [0, 1, 2]:permutation>
  #     a.permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>
  #
  def permutation: (?int n) -> ::Enumerator[::Array[Elem], ::Array[Elem]]
                 | (?int n) { (::Array[Elem] p) -> void } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.pop -> object or nil
  #   - array.pop(n) -> new_array
  # -->
  # Removes and returns trailing elements.
  #
  # When no argument is given and `self` is not empty, removes and returns the
  # last element:
  #     a = [:foo, 'bar', 2]
  #     a.pop # => 2
  #     a # => [:foo, "bar"]
  #
  # Returns `nil` if the array is empty.
  #
  # When a non-negative Integer argument `n` is given and is in range, removes and
  # returns the last `n` elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.pop(2) # => ["bar", 2]
  #
  # If `n` is positive and out of range, removes and returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.pop(50) # => [:foo, "bar", 2]
  #
  # Related: #push, #shift, #unshift.
  #
  def pop: () -> Elem?
         | (int n) -> ::Array[Elem]

  # <!-- rdoc-file=array.c -->
  # Prepends the given `objects` to `self`:
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Array#prepend is an alias for Array#unshift.
  #
  # Related: #push, #pop, #shift.
  #
  alias prepend unshift

  # <!--
  #   rdoc-file=array.c
  #   - array.product(*other_arrays) -> new_array
  #   - array.product(*other_arrays) {|combination| ... } -> self
  # -->
  # Computes and returns or yields all combinations of elements from all the
  # Arrays, including both `self` and `other_arrays`.
  # *   The number of combinations is the product of the sizes of all the arrays,
  #     including both `self` and `other_arrays`.
  # *   The order of the returned combinations is indeterminate.
  #
  #
  # When no block is given, returns the combinations as an Array of Arrays:
  #     a = [0, 1, 2]
  #     a1 = [3, 4]
  #     a2 = [5, 6]
  #     p = a.product(a1)
  #     p.size # => 6 # a.size * a1.size
  #     p # => [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]
  #     p = a.product(a1, a2)
  #     p.size # => 12 # a.size * a1.size * a2.size
  #     p # => [[0, 3, 5], [0, 3, 6], [0, 4, 5], [0, 4, 6], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]
  #
  # If any argument is an empty Array, returns an empty Array.
  #
  # If no argument is given, returns an Array of 1-element Arrays, each containing
  # an element of `self`:
  #     a.product # => [[0], [1], [2]]
  #
  # When a block is given, yields each combination as an Array; returns `self`:
  #     a.product(a1) {|combination| p combination }
  #
  # Output:
  #     [0, 3]
  #     [0, 4]
  #     [1, 3]
  #     [1, 4]
  #     [2, 3]
  #     [2, 4]
  #
  # If any argument is an empty Array, does not call the block:
  #     a.product(a1, a2, []) {|combination| fail 'Cannot happen' }
  #
  # If no argument is given, yields each element of `self` as a 1-element Array:
  #     a.product {|combination| p combination }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  def product: () -> ::Array[[ Elem ]]
             | [X] (::Array[X] other_ary) -> ::Array[[ Elem, X ]]
             | [X, Y] (::Array[X] other_ary1, ::Array[Y] other_ary2) -> ::Array[[ Elem, X, Y ]]
             | [U] (*::Array[U] other_arys) -> ::Array[::Array[Elem | U]]

  # <!--
  #   rdoc-file=array.c
  #   - array.push(*objects) -> self
  # -->
  # Appends trailing elements.
  #
  # Appends each argument in `objects` to `self`;  returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.push([:baz, :bat], [:bam, :bad])
  #     a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Array#append is an alias for Array#push.
  #
  # Related: #pop, #shift, #unshift.
  #
  def push: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.rassoc(obj) -> found_array or nil
  # -->
  # Returns the first element in `self` that is an Array whose second element `==`
  # `obj`:
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.rassoc(4) # => [2, 4]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: #assoc.
  #
  alias rassoc assoc

  # <!--
  #   rdoc-file=array.c
  #   - array.reject {|element| ... } -> new_array
  #   - array.reject -> new_enumerator
  # -->
  # Returns a new Array whose elements are all those from `self` for which the
  # block returns `false` or `nil`:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a1 = a.reject {|element| element.to_s.start_with?('b') }
  #     a1 # => [:foo, 2]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.reject # => #<Enumerator: [:foo, "bar", 2]:reject>
  #
  alias reject delete_if

  # <!--
  #   rdoc-file=array.c
  #   - array.reject! {|element| ... } -> self or nil
  #   - array.reject! -> new_enumerator
  # -->
  # Removes each element for which the block returns a truthy value.
  #
  # Returns `self` if any elements removed:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.reject! {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.reject! # => #<Enumerator: [:foo, "bar", 2]:reject!>
  #
  def reject!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.repeated_combination(n) {|combination| ... } -> self
  #   - array.repeated_combination(n) -> new_enumerator
  # -->
  # Calls the block with each repeated combination of length `n` of the elements
  # of `self`; each combination is an Array; returns `self`. The order of the
  # combinations is indeterminate.
  #
  # When a block and a positive Integer argument `n` are given, calls the block
  # with each `n`-tuple repeated combination of the elements of `self`. The number
  # of combinations is `(n+1)(n+2)/2`.
  #
  # `n` = 1:
  #     a = [0, 1, 2]
  #     a.repeated_combination(1) {|combination| p combination }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  # `n` = 2:
  #     a.repeated_combination(2) {|combination| p combination }
  #
  # Output:
  #     [0, 0]
  #     [0, 1]
  #     [0, 2]
  #     [1, 1]
  #     [1, 2]
  #     [2, 2]
  #
  # If `n` is zero, calls the block once with an empty Array.
  #
  # If `n` is negative, does not call the block:
  #     a.repeated_combination(-1) {|combination| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.repeated_combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>
  #
  # Using Enumerators, it's convenient to show the combinations and counts for
  # some values of `n`:
  #     e = a.repeated_combination(0)
  #     e.size # => 1
  #     e.to_a # => [[]]
  #     e = a.repeated_combination(1)
  #     e.size # => 3
  #     e.to_a # => [[0], [1], [2]]
  #     e = a.repeated_combination(2)
  #     e.size # => 6
  #     e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]
  #
  def repeated_combination: (int n) { (::Array[Elem] c) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - array.repeated_permutation(n) {|permutation| ... } -> self
  #   - array.repeated_permutation(n) -> new_enumerator
  # -->
  # Calls the block with each repeated permutation of length `n` of the elements
  # of `self`; each permutation is an Array; returns `self`. The order of the
  # permutations is indeterminate.
  #
  # When a block and a positive Integer argument `n` are given, calls the block
  # with each `n`-tuple repeated permutation of the elements of `self`. The number
  # of permutations is `self.size**n`.
  #
  # `n` = 1:
  #     a = [0, 1, 2]
  #     a.repeated_permutation(1) {|permutation| p permutation }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  # `n` = 2:
  #     a.repeated_permutation(2) {|permutation| p permutation }
  #
  # Output:
  #     [0, 0]
  #     [0, 1]
  #     [0, 2]
  #     [1, 0]
  #     [1, 1]
  #     [1, 2]
  #     [2, 0]
  #     [2, 1]
  #     [2, 2]
  #
  # If `n` is zero, calls the block once with an empty Array.
  #
  # If `n` is negative, does not call the block:
  #     a.repeated_permutation(-1) {|permutation| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.repeated_permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>
  #
  # Using Enumerators, it's convenient to show the permutations and counts for
  # some values of `n`:
  #     e = a.repeated_permutation(0)
  #     e.size # => 1
  #     e.to_a # => [[]]
  #     e = a.repeated_permutation(1)
  #     e.size # => 3
  #     e.to_a # => [[0], [1], [2]]
  #     e = a.repeated_permutation(2)
  #     e.size # => 9
  #     e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
  #
  def repeated_permutation: (int n) { (::Array[Elem] p) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!-- rdoc-file=array.c -->
  # Replaces the content of `self` with the content of `other_array`; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
  #
  def replace: (::Array[Elem]) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse -> new_array
  # -->
  # Returns a new Array with the elements of `self` in reverse order.
  #     a = ['foo', 'bar', 'two']
  #     a1 = a.reverse
  #     a1 # => ["two", "bar", "foo"]
  #
  def reverse: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse! -> self
  # -->
  # Reverses `self` in place:
  #     a = ['foo', 'bar', 'two']
  #     a.reverse! # => ["two", "bar", "foo"]
  #
  def reverse!: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse_each {|element| ... } -> self
  #   - array.reverse_each -> Enumerator
  # -->
  # Iterates backwards over array elements.
  #
  # When a block given, passes, in reverse order, each element to the block;
  # returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.reverse_each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Integer 2
  #     String bar
  #     Symbol foo
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #     2
  #     bar
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.reverse_each
  #     e # => #<Enumerator: [:foo, "bar", 2]:reverse_each>
  #     a1 = e.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Integer 2
  #     String bar
  #     Symbol foo
  #
  # Related: #each, #each_index.
  #
  def reverse_each: () { (Elem item) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.rindex(object) -> integer or nil
  #   - array.rindex {|element| ... } -> integer or nil
  #   - array.rindex -> new_enumerator
  # -->
  # Returns the index of the last element for which `object == element`.
  #
  # When argument `object` is given but no block, returns the index of the last
  # such element found:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex('bar') # => 3
  #
  # Returns `nil` if no such object found.
  #
  # When a block is given but no argument, calls the block with each successive
  # element; returns the index of the last element for which the block returns a
  # truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex {|element| element == 'bar' } # => 3
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     e = a.rindex
  #     e # => #<Enumerator: [:foo, "bar", 2, "bar"]:rindex>
  #     e.each {|element| element == 'bar' } # => 3
  #
  # Related: #index.
  #
  def rindex: (untyped obj) -> ::Integer?
            | () { (Elem item) -> boolish } -> ::Integer?
            | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.c
  #   - array.rotate -> new_array
  #   - array.rotate(count) -> new_array
  # -->
  # Returns a new Array formed from `self` with elements rotated from one end to
  # the other.
  #
  # When no argument given, returns a new Array that is like `self`, except that
  # the first element has been rotated to the last position:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a1 = a.rotate
  #     a1 # => ["bar", 2, "bar", :foo]
  #
  # When given a non-negative Integer `count`, returns a new Array with `count`
  # elements rotated from the beginning to the end:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(2)
  #     a1 # => [2, :foo, "bar"]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(20)
  #     a1 # => [2, :foo, "bar"]
  #
  # If `count` is zero, returns a copy of `self`, unmodified:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(0)
  #     a1 # => [:foo, "bar", 2]
  #
  # When given a negative Integer `count`, rotates in the opposite direction, from
  # end to beginning:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(-2)
  #     a1 # => ["bar", 2, :foo]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(-5)
  #     a1 # => ["bar", 2, :foo]
  #
  def rotate: (?int count) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.rotate! -> self
  #   - array.rotate!(count) -> self
  # -->
  # Rotates `self` in place by moving elements from one end to the other; returns
  # `self`.
  #
  # When no argument given, rotates the first element to the last position:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rotate! # => ["bar", 2, "bar", :foo]
  #
  # When given a non-negative Integer `count`, rotates `count` elements from the
  # beginning to the end:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(2)
  #     a # => [2, :foo, "bar"]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(20)
  #     a # => [2, :foo, "bar"]
  #
  # If `count` is zero, returns `self` unmodified:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(0)
  #     a # => [:foo, "bar", 2]
  #
  # When given a negative Integer `count`, rotates in the opposite direction, from
  # end to beginning:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(-2)
  #     a # => ["bar", 2, :foo]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(-5)
  #     a # => ["bar", 2, :foo]
  #
  def rotate!: (?int count) -> self

  # <!--
  #   rdoc-file=array.rb
  #   - array.sample(random: Random) -> object
  #   - array.sample(n, random: Random) -> new_ary
  # -->
  # Returns random elements from `self`.
  #
  # When no arguments are given, returns a random element from `self`:
  #     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a.sample # => 3
  #     a.sample # => 8
  #
  # If `self` is empty, returns `nil`.
  #
  # When argument `n` is given, returns a new Array containing `n` random elements
  # from `self`:
  #     a.sample(3) # => [8, 9, 2]
  #     a.sample(6) # => [9, 6, 10, 3, 1, 4]
  #
  # Returns no more than `a.size` elements (because no new duplicates are
  # introduced):
  #     a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]
  #
  # But `self` may contain duplicates:
  #     a = [1, 1, 1, 2, 2, 3]
  #     a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2]
  #
  # The argument `n` must be a non-negative numeric value. The order of the result
  # array is unrelated to the order of `self`. Returns a new empty Array if `self`
  # is empty.
  #
  # The optional `random` argument will be used as the random number generator:
  #     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a.sample(random: Random.new(1))     #=> 6
  #     a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2]
  #
  def sample: (?random: _Rand rng) -> Elem?
            | (int n, ?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.select {|element| ... } -> new_array
  #   - array.select -> new_enumerator
  # -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # containing those elements of `self` for which the block returns a truthy
  # value:
  #     a = [:foo, 'bar', 2, :bam]
  #     a1 = a.select {|element| element.to_s.start_with?('b') }
  #     a1 # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>
  #
  # Array#filter is an alias for Array#select.
  #
  def select: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.select! {|element| ... } -> self or nil
  #   - array.select! -> new_enumerator
  # -->
  # Calls the block, if given  with each element of `self`; removes from `self`
  # those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>
  #
  # Array#filter! is an alias for Array#select!.
  #
  def select!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.shift -> object or nil
  #   - array.shift(n) -> new_array
  # -->
  # Removes and returns leading elements.
  #
  # When no argument is given, removes and returns the first element:
  #     a = [:foo, 'bar', 2]
  #     a.shift # => :foo
  #     a # => ['bar', 2]
  #
  # Returns `nil` if `self` is empty.
  #
  # When positive Integer argument `n` is given, removes the first `n` elements;
  # returns those elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.shift(2) # => [:foo, 'bar']
  #     a # => [2]
  #
  # If `n` is as large as or larger than `self.length`, removes all elements;
  # returns those elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.shift(3) # => [:foo, 'bar', 2]
  #
  # If `n` is zero, returns a new empty Array; `self` is unmodified.
  #
  # Related: #push, #pop, #unshift.
  #
  def shift: () -> Elem?
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - array.shuffle(random: Random) -> new_ary
  # -->
  # Returns a new array with elements of `self` shuffled.
  #     a = [1, 2, 3] #=> [1, 2, 3]
  #     a.shuffle     #=> [2, 3, 1]
  #     a             #=> [1, 2, 3]
  #
  # The optional `random` argument will be used as the random number generator:
  #     a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
  #
  def shuffle: (?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - array.shuffle!(random: Random) -> array
  # -->
  # Shuffles the elements of `self` in place.
  #     a = [1, 2, 3] #=> [1, 2, 3]
  #     a.shuffle!    #=> [2, 3, 1]
  #     a             #=> [2, 3, 1]
  #
  # The optional `random` argument will be used as the random number generator:
  #     a.shuffle!(random: Random.new(1))  #=> [1, 3, 2]
  #
  def shuffle!: (?random: _Rand rng) -> self

  # <!-- rdoc-file=array.c -->
  # Returns the count of elements in `self`.
  #
  alias size length

  # <!-- rdoc-file=array.c -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When a single Integer argument `index` is given, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts relative to the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new Array
  # of size `length` containing successive elements beginning at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an Array of elements corresponding to the indexes produced by the sequence.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Array#slice is an alias for Array#[].
  #
  def slice: (int index) -> Elem?
           | (int start, int length) -> ::Array[Elem]?
           | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array.slice!(n) -> object or nil
  #   - array.slice!(start, length) -> new_array or nil
  #   - array.slice!(range) -> new_array or nil
  # -->
  # Removes and returns elements from `self`.
  #
  # When the only argument is an Integer `n`, removes and returns the *nth*
  # element in `self`:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # If `n` is negative, counts backwards from the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(-1) # => 2
  #     a # => [:foo, "bar"]
  #
  # If `n` is out of range, returns `nil`.
  #
  # When the only arguments are Integers `start` and `length`, removes `length`
  # elements from `self` beginning at offset  `start`; returns the deleted objects
  # in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(0, 2) # => [:foo, "bar"]
  #     a # => [2]
  #
  # If `start + length` exceeds the array size, removes and returns all elements
  # from offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(1, 50) # => ["bar", 2]
  #     a # => [:foo]
  #
  # If `start == a.size` and `length` is non-negative, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When the only argument is a Range object `range`, treats `range.min` as
  # `start` above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #      a.slice!(1..2) # => ["bar", 2]
  #     a # => [:foo]
  #
  # If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #
  # If `range.end` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(0..-2) # => [:foo, "bar"]
  #     a # => [2]
  #
  # If `range.start` is negative, calculates the start index backwards from the
  # end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(-2..2) # => ["bar", 2]
  #     a # => [:foo]
  #
  def slice!: (int index) -> Elem?
            | (int start, int length) -> ::Array[Elem]?
            | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array.sort -> new_array
  #   - array.sort {|a, b| ... } -> new_array
  # -->
  # Returns a new Array whose elements are those from `self`, sorted.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort
  #     a1 # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| a <=> b }
  #     a1 # => ["a", "b", "c", "d", "e"]
  #     a2 = a.sort {|a, b| b <=> a }
  #     a2 # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| 0 }
  #     a1 # =>  ["c", "e", "b", "d", "a"]
  #
  # Related: Enumerable#sort_by.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem a, Elem b) -> ::Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.sort! -> self
  #   - array.sort! {|a, b| ... } -> self
  # -->
  # Returns `self` with its elements sorted in place.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort!
  #     a # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| a <=> b }
  #     a # => ["a", "b", "c", "d", "e"]
  #     a.sort! {|a, b| b <=> a }
  #     a # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| 0 }
  #     a # => ["d", "e", "c", "a", "b"]
  #
  def sort!: () -> self
           | () { (Elem a, Elem b) -> ::Integer } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.sort_by! {|element| ... } -> self
  #   - array.sort_by! -> new_enumerator
  # -->
  # Sorts the elements of `self` in place, using an ordering determined by the
  # block; returns self.
  #
  # Calls the block with each successive element; sorts elements based on the
  # values returned from the block.
  #
  # For duplicates returned by the block, the ordering is indeterminate, and may
  # be unstable.
  #
  # This example sorts strings based on their sizes:
  #     a = ['aaaa', 'bbb', 'cc', 'd']
  #     a.sort_by! {|element| element.size }
  #     a # => ["d", "cc", "bbb", "aaaa"]
  #
  # Returns a new Enumerator if no block given:
  #
  #     a = ['aaaa', 'bbb', 'cc', 'd']
  #     a.sort_by! # => #<Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!>
  #
  def sort_by!: [U] () { (Elem obj) -> U } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.sum(init = 0) -> object
  #   - array.sum(init = 0) {|element| ... } -> object
  # -->
  # When no block is given, returns the object equivalent to:
  #     sum = init
  #     array.each {|element| sum += element }
  #     sum
  #
  # For example, `[e1, e2, e3].sum` returns `init + e1 + e2 + e3`.
  #
  # Examples:
  #     a = [0, 1, 2, 3]
  #     a.sum # => 6
  #     a.sum(100) # => 106
  #
  # The elements need not be numeric, but must be `+`-compatible with each other
  # and with `init`:
  #     a = ['abc', 'def', 'ghi']
  #     a.sum('jkl') # => "jklabcdefghi"
  #
  # When a block is given, it is called with each element and the block's return
  # value (instead of the element itself) is used as the addend:
  #     a = ['zero', 1, :two]
  #     s = a.sum('Coerced and concatenated: ') {|element| element.to_s }
  #     s # => "Coerced and concatenated: zero1two"
  #
  # Notes:
  # *   Array#join and Array#flatten may be faster than Array#sum for an Array of
  #     Strings or an Array of Arrays.
  # *   Array#sum method may not respect method redefinition of "+" methods such
  #     as Integer#+.
  #
  def sum: (?untyped init) -> untyped
         | (?untyped init) { (Elem e) -> untyped } -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - array.take(n) -> new_array
  # -->
  # Returns a new Array containing the first `n` element of `self`, where `n` is a
  # non-negative Integer; does not modify `self`.
  #
  # Examples:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.take(1) # => [0]
  #     a.take(2) # => [0, 1]
  #     a.take(50) # => [0, 1, 2, 3, 4, 5]
  #     a # => [0, 1, 2, 3, 4, 5]
  #
  def take: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.take_while {|element| ... } -> new_array
  #   - array.take_while -> new_enumerator
  # -->
  # Returns a new Array containing zero or more leading elements of `self`; does
  # not modify `self`.
  #
  # With a block given, calls the block with each successive element of `self`;
  # stops if the block returns `false` or `nil`; returns a new Array containing
  # those elements for which the block returned a truthy value:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.take_while {|element| element < 3 } # => [0, 1, 2]
  #     a.take_while {|element| true } # => [0, 1, 2, 3, 4, 5]
  #     a # => [0, 1, 2, 3, 4, 5]
  #
  # With no block given, returns a new Enumerator:
  #     [0, 1].take_while # => #<Enumerator: [0, 1]:take_while>
  #
  def take_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - to_a -> self or new_array
  # -->
  # When `self` is an instance of Array, returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.to_a # => [:foo, "bar", 2]
  #
  # Otherwise, returns a new Array containing the elements of `self`:
  #     class MyArray < Array; end
  #     a = MyArray.new(['foo', 'bar', 'two'])
  #     a.instance_of?(Array) # => false
  #     a.kind_of?(Array) # => true
  #     a1 = a.to_a
  #     a1 # => ["foo", "bar", "two"]
  #     a1.class # => Array # Not MyArray
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.to_ary -> self
  # -->
  # Returns `self`.
  #
  def to_ary: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.to_h -> new_hash
  #   - array.to_h {|item| ... } -> new_hash
  # -->
  # Returns a new Hash formed from `self`.
  #
  # When a block is given, calls the block with each array element; the block must
  # return a 2-element Array whose two elements form a key-value pair in the
  # returned Hash:
  #     a = ['foo', :bar, 1, [2, 3], {baz: 4}]
  #     h = a.to_h {|item| [item, item] }
  #     h # => {"foo"=>"foo", :bar=>:bar, 1=>1, [2, 3]=>[2, 3], {:baz=>4}=>{:baz=>4}}
  #
  # When no block is given, `self` must be an Array of 2-element sub-arrays, each
  # sub-array is formed into a key-value pair in the new Hash:
  #     [].to_h # => {}
  #     a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
  #     h = a.to_h
  #     h # => {"foo"=>"zero", "bar"=>"one", "baz"=>"two"}
  #
  def to_h: () -> Hash[untyped, untyped]
          | [T, S] () { (Elem) -> [ T, S ] } -> Hash[T, S]

  # <!-- rdoc-file=array.c -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=array.c
  #   - array.transpose -> new_array
  # -->
  # Transposes the rows and columns in an Array of Arrays; the nested Arrays must
  # all be the same size:
  #     a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
  #     a.transpose # => [[:a0, :b0, :c0], [:a1, :b1, :c1]]
  #
  def transpose: () -> ::Array[::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - array.union(*other_arrays) -> new_array
  # -->
  # Returns a new Array that is the union of `self` and all given Arrays
  # `other_arrays`; duplicates are removed;  order is preserved;  items are
  # compared using `eql?`:
  #     [0, 1, 2, 3].union([4, 5], [6, 7]) # => [0, 1, 2, 3, 4, 5, 6, 7]
  #     [0, 1, 1].union([2, 1], [3, 1]) # => [0, 1, 2, 3]
  #     [0, 1, 2, 3].union([3, 2], [1, 0]) # => [0, 1, 2, 3]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#|.
  #
  def union: [T] (*::Array[T] other_arys) -> ::Array[T | Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.uniq -> new_array
  #   - array.uniq {|element| ... } -> new_array
  # -->
  # Returns a new Array containing those elements from `self` that are not
  # duplicates, the first occurrence always being retained.
  #
  # With no block given, identifies and omits duplicates using method `eql?` to
  # compare.
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq # => [0, 1, 2]
  #
  # With a block given, calls the block for each element; identifies (using method
  # `eql?`) and omits duplicate values, that is, those elements for which the
  # block returns the same value:
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq {|element| element.size } # => ["a", "aa", "aaa"]
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.uniq! -> self or nil
  #   - array.uniq! {|element| ... } -> self or nil
  # -->
  # Removes duplicate elements from `self`, the first occurrence always being
  # retained; returns `self` if any elements removed, `nil` otherwise.
  #
  # With no block given, identifies and removes elements using method `eql?` to
  # compare.
  #
  # Returns `self` if any elements removed:
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq! # => [0, 1, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # With a block given, calls the block for each element; identifies (using method
  # `eql?`) and removes elements for which the block returns duplicate values.
  #
  # Returns `self` if any elements removed:
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq! {|element| element.size } # => ['a', 'aa', 'aaa']
  #
  # Returns `nil` if no elements removed.
  #
  def uniq!: () -> self?
           | () { (Elem) -> untyped } -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.unshift(*objects) -> self
  # -->
  # Prepends the given `objects` to `self`:
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Array#prepend is an alias for Array#unshift.
  #
  # Related: #push, #pop, #shift.
  #
  def unshift: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.values_at(*indexes) -> new_array
  # -->
  # Returns a new Array whose elements are the elements of `self` at the given
  # Integer or Range `indexes`.
  #
  # For each positive `index`, returns the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, 2) # => [:foo, 2]
  #     a.values_at(0..1) # => [:foo, "bar"]
  #
  # The given `indexes` may be in any order, and may repeat:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(2, 0, 1, 0, 2) # => [2, :foo, "bar", :foo, 2]
  #     a.values_at(1, 0..2) # => ["bar", :foo, "bar", 2]
  #
  # Assigns `nil` for an `index` that is too large:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, 3, 1, 3) # => [:foo, nil, "bar", nil]
  #
  # Returns a new empty Array if no arguments given.
  #
  # For each negative `index`, counts backward from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(-1, -3) # => [2, :foo]
  #
  # Assigns `nil` for an `index` that is too small:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, -5, 1, -6, 2) # => [:foo, nil, "bar", nil, 2]
  #
  # The given `indexes` may have a mixture of signs:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, -2, 1, -1) # => [:foo, "bar", "bar", 2]
  #
  def values_at: (*int | ::Range[::Integer] selector) -> ::Array[Elem?]

  # <!--
  #   rdoc-file=array.c
  #   - array.zip(*other_arrays) -> new_array
  #   - array.zip(*other_arrays) {|other_array| ... } -> nil
  # -->
  # When no block given, returns a new Array `new_array` of size `self.size` whose
  # elements are Arrays.
  #
  # Each nested array `new_array[n]` is of size `other_arrays.size+1`, and
  # contains:
  # *   The *nth* element of `self`.
  # *   The *nth* element of each of the `other_arrays`.
  #
  #
  # If all `other_arrays` and `self` are the same size:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # If any array in `other_arrays` is smaller than `self`, fills to `self.size`
  # with `nil`:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
  #
  # If any array in `other_arrays` is larger than `self`, its trailing elements
  # are ignored:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # When a block is given, calls the block with each of the sub-arrays (formed as
  # above); returns nil
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| p sub_array} # => nil
  #
  # Output:
  #     [:a0, :b0, :c0]
  #     [:a1, :b1, :c1]
  #     [:a2, :b2, :c2]
  #     [:a3, :b3, :c3]
  #
  def zip: [U] (::Array[U] arg) -> ::Array[[ Elem, U? ]]
         | (::Array[untyped] arg, *::Array[untyped] args) -> ::Array[::Array[untyped]]
         | [U] (::Array[U] arg) { ([ Elem, U? ]) -> void } -> void
         | (::Array[untyped] arg, *::Array[untyped] args) { (::Array[untyped]) -> void } -> void

  # <!--
  #   rdoc-file=array.c
  #   - array | other_array -> new_array
  # -->
  # Returns the union of `array` and Array `other_array`; duplicates are removed;
  # order is preserved; items are compared using `eql?`:
  #     [0, 1] | [2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 1] | [2, 2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 2] | [3, 2, 1, 0] # => [0, 1, 2, 3]
  #
  # Related: Array#union.
  #
  def |: [T] (::Array[T] other_ary) -> ::Array[Elem | T]

  private

  # <!--
  #   rdoc-file=array.c
  #   - array.replace(other_array) -> self
  # -->
  # Replaces the content of `self` with the content of `other_array`; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
  #
  def initialize_copy: (self other_ary) -> void
end

interface _ToA[T]
  def to_a: () -> Array[T]
end

interface _ToAry[T]
  def to_ary: () -> ::Array[T]
end

interface _Rand
  def rand: (::Integer max) -> ::Integer
end

interface Array::_Pattern[T]
  def ===: (T) -> bool
end

# <!-- rdoc-file=compar.c -->
# The Comparable mixin is used by classes whose objects may be ordered. The
# class must define the `<=>` operator, which compares the receiver against
# another object, returning a value less than 0, returning 0, or returning a
# value greater than 0, depending on whether the receiver is less than, equal
# to, or greater than the other object. If the other object is not comparable
# then the `<=>` operator should return `nil`. Comparable uses `<=>` to
# implement the conventional comparison operators (`<`, `<=`, `==`, `>=`, and
# `>`) and the method `between?`.
#
#     class SizeMatters
#       include Comparable
#       attr :str
#       def <=>(other)
#         str.size <=> other.str.size
#       end
#       def initialize(str)
#         @str = str
#       end
#       def inspect
#         @str
#       end
#     end
#
#     s1 = SizeMatters.new("Z")
#     s2 = SizeMatters.new("YY")
#     s3 = SizeMatters.new("XXX")
#     s4 = SizeMatters.new("WWWW")
#     s5 = SizeMatters.new("VVVVV")
#
#     s1 < s2                       #=> true
#     s4.between?(s1, s3)           #=> false
#     s4.between?(s3, s5)           #=> true
#     [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]
#
# ## What's Here
#
# Module Comparable provides these methods, all of which use method `<=>`:
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given object.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given object.
#
#     [==](#method-i-3D-3D)
# :       Returns whether `self` is equal to the given object.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than or equal to the given object.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than the given object.
#
# *   #between? Returns `true` if `self` is between two given objects.
#     #clamp
# :       For given objects `min` and `max`, or range `(min..max)`, returns:
#
#     *   `min` if `(self <=> min) < 0`.
#     *   `max` if `(self <=> max) > 0`.
#     *   `self` otherwise.
#
module Comparable : _WithSpaceshipOperator
  # <!--
  #   rdoc-file=compar.c
  #   - obj < other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than 0.
  #
  def <: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj <= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than or equal to 0.
  #
  def <=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj == other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns 0. Also returns true if *obj* and *other* are the same object.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj > other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than 0.
  #
  def >: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj >= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than or equal to 0.
  #
  def >=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.between?(min, max)    -> true or false
  # -->
  # Returns `false` if *obj* `<=>` *min* is less than zero or if *obj* `<=>` *max*
  # is greater than zero, `true` otherwise.
  #
  #     3.between?(1, 5)               #=> true
  #     6.between?(1, 5)               #=> false
  #     'cat'.between?('ant', 'dog')   #=> true
  #     'gnu'.between?('ant', 'dog')   #=> false
  #
  def between?: (untyped min, untyped max) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.clamp(min, max) ->  obj
  #   - obj.clamp(range)    ->  obj
  # -->
  # In `(min, max)` form, returns *min* if *obj* `<=>` *min* is less than zero,
  # *max* if *obj* `<=>` *max* is greater than zero, and *obj* otherwise.
  #
  #     12.clamp(0, 100)         #=> 12
  #     523.clamp(0, 100)        #=> 100
  #     -3.123.clamp(0, 100)     #=> 0
  #
  #     'd'.clamp('a', 'f')      #=> 'd'
  #     'z'.clamp('a', 'f')      #=> 'f'
  #
  # In `(range)` form, returns *range.begin* if *obj* `<=>` *range.begin* is less
  # than zero, *range.end* if *obj* `<=>` *range.end* is greater than zero, and
  # *obj* otherwise.
  #
  #     12.clamp(0..100)         #=> 12
  #     523.clamp(0..100)        #=> 100
  #     -3.123.clamp(0..100)     #=> 0
  #
  #     'd'.clamp('a'..'f')      #=> 'd'
  #     'z'.clamp('a'..'f')      #=> 'f'
  #
  # If *range.begin* is `nil`, it is considered smaller than *obj*, and if
  # *range.end* is `nil`, it is considered greater than *obj*.
  #
  #     -20.clamp(0..)           #=> 0
  #     523.clamp(..100)         #=> 100
  #
  # When *range.end* is excluded and not `nil`, an exception is raised.
  #
  #     100.clamp(0...100)       # ArgumentError
  #
  def clamp: [A, B] (A min, B max) -> (self | A | B)
           | [A] (Range[A]) -> (self | A)
end

# This interface defines the condition for Comparable mixin.
#
interface Comparable::_WithSpaceshipOperator
  # `<=>` operator must return Integer or `nil`.
  # If `other` is greater than `self`, it returns a positive Integer.
  # If `other` equals to `self`, it returns zero.
  # If `other` is less than `self`, it returns a positive Integer.
  # If no comparison is defined with `other` and `self`, it returns `nil`.
  #
  def <=>: (untyped other) -> Integer?
end

# <!-- rdoc-file=hash.c -->
# A Hash maps each of its unique keys to a specific value.
#
# A Hash has certain similarities to an Array, but:
# *   An Array index is always an Integer.
# *   A Hash key can be (almost) any object.
#
#
# ### Hash Data Syntax
#
# The older syntax for Hash data uses the "hash rocket," `=>`:
#
#     h = {:foo => 0, :bar => 1, :baz => 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Alternatively, but only for a Hash key that's a Symbol, you can use a newer
# JSON-style syntax, where each bareword becomes a Symbol:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can also use a String in place of a bareword:
#
#     h = {'foo': 0, 'bar': 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# And you can mix the styles:
#
#     h = {foo: 0, :bar => 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# But it's an error to try the JSON-style syntax for a key that's not a bareword
# or a String:
#
#     # Raises SyntaxError (syntax error, unexpected ':', expecting =>):
#     h = {0: 'zero'}
#
# Hash value can be omitted, meaning that value will be fetched from the context
# by the name of the key:
#
#     x = 0
#     y = 100
#     h = {x:, y:}
#     h # => {:x=>0, :y=>100}
#
# ### Common Uses
#
# You can use a Hash to give names to objects:
#
#     person = {name: 'Matz', language: 'Ruby'}
#     person # => {:name=>"Matz", :language=>"Ruby"}
#
# You can use a Hash to give names to method arguments:
#
#     def some_method(hash)
#       p hash
#     end
#     some_method({foo: 0, bar: 1, baz: 2}) # => {:foo=>0, :bar=>1, :baz=>2}
#
# Note: when the last argument in a method call is a Hash, the curly braces may
# be omitted:
#
#     some_method(foo: 0, bar: 1, baz: 2) # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can use a Hash to initialize an object:
#
#     class Dev
#       attr_accessor :name, :language
#       def initialize(hash)
#         self.name = hash[:name]
#         self.language = hash[:language]
#       end
#     end
#     matz = Dev.new(name: 'Matz', language: 'Ruby')
#     matz # => #<Dev: @name="Matz", @language="Ruby">
#
# ### Creating a Hash
#
# You can create a Hash object explicitly with:
#
# *   A [hash literal](doc/syntax/literals_rdoc.html#label-Hash+Literals).
#
#
# You can convert certain objects to Hashes with:
#
# *   Method [Hash](Kernel.html#method-i-Hash).
#
#
# You can create a Hash by calling method Hash.new.
#
# Create an empty Hash:
#
#     h = Hash.new
#     h # => {}
#     h.class # => Hash
#
# You can create a Hash by calling method Hash.[].
#
# Create an empty Hash:
#
#     h = Hash[]
#     h # => {}
#
# Create a Hash with initial entries:
#
#     h = Hash[foo: 0, bar: 1, baz: 2]
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can create a Hash by using its literal form (curly braces).
#
# Create an empty Hash:
#
#     h = {}
#     h # => {}
#
# Create a Hash with initial entries:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# ### Hash Value Basics
#
# The simplest way to retrieve a Hash value (instance method #[]):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:foo] # => 0
#
# The simplest way to create or update a Hash value (instance method #[]=):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:bat] = 3 # => 3
#     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
#     h[:foo] = 4 # => 4
#     h # => {:foo=>4, :bar=>1, :baz=>2, :bat=>3}
#
# The simplest way to delete a Hash entry (instance method #delete):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h.delete(:bar) # => 1
#     h # => {:foo=>0, :baz=>2}
#
# ### Entry Order
#
# A Hash object presents its entries in the order of their creation. This is
# seen in:
#
# *   Iterative methods such as `each`, `each_key`, `each_pair`, `each_value`.
# *   Other order-sensitive methods such as `shift`, `keys`, `values`.
# *   The String returned by method `inspect`.
#
#
# A new Hash has its initial ordering per the given entries:
#
#     h = Hash[foo: 0, bar: 1]
#     h # => {:foo=>0, :bar=>1}
#
# New entries are added at the end:
#
#     h[:baz] = 2
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Updating a value does not affect the order:
#
#     h[:baz] = 3
#     h # => {:foo=>0, :bar=>1, :baz=>3}
#
# But re-creating a deleted entry can affect the order:
#
#     h.delete(:foo)
#     h[:foo] = 5
#     h # => {:bar=>1, :baz=>3, :foo=>5}
#
# ### Hash Keys
#
# #### Hash Key Equivalence
#
# Two objects are treated as the same hash key when their `hash` value is
# identical and the two objects are `eql?` to each other.
#
# #### Modifying an Active Hash Key
#
# Modifying a Hash key while it is in use damages the hash's index.
#
# This Hash has keys that are Arrays:
#
#     a0 = [ :foo, :bar ]
#     a1 = [ :baz, :bat ]
#     h = {a0 => 0, a1 => 1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#     a0.hash # => 110002110
#
# Modifying array element `a0[0]` changes its hash value:
#
#     a0[0] = :bam
#     a0.hash # => 1069447059
#
# And damages the Hash index:
#
#     h.include?(a0) # => false
#     h[a0] # => nil
#
# You can repair the hash index using method `rehash`:
#
#     h.rehash # => {[:bam, :bar]=>0, [:baz, :bat]=>1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#
# A String key is always safe. That's because an unfrozen String passed as a key
# will be replaced by a duplicated and frozen String:
#
#     s = 'foo'
#     s.frozen? # => false
#     h = {s => 0}
#     first_key = h.keys.first
#     first_key.frozen? # => true
#
# #### User-Defined Hash Keys
#
# To be useable as a Hash key, objects must implement the methods `hash` and
# `eql?`. Note: this requirement does not apply if the Hash uses
# #compare_by_identity since comparison will then rely on the keys' object id
# instead of `hash` and `eql?`.
#
# Object defines basic implementation for `hash` and `eq?` that makes each
# object a distinct key. Typically, user-defined classes will want to override
# these methods to provide meaningful behavior, or for example inherit Struct
# that has useful definitions for these.
#
# A typical implementation of `hash` is based on the object's data while `eql?`
# is usually aliased to the overridden `==` method:
#
#     class Book
#       attr_reader :author, :title
#
#       def initialize(author, title)
#         @author = author
#         @title = title
#       end
#
#       def ==(other)
#         self.class === other &&
#           other.author == @author &&
#           other.title == @title
#       end
#
#       alias eql? ==
#
#       def hash
#         @author.hash ^ @title.hash # XOR
#       end
#     end
#
#     book1 = Book.new 'matz', 'Ruby in a Nutshell'
#     book2 = Book.new 'matz', 'Ruby in a Nutshell'
#
#     reviews = {}
#
#     reviews[book1] = 'Great reference!'
#     reviews[book2] = 'Nice and compact!'
#
#     reviews.length #=> 1
#
# ### Default Values
#
# The methods #[], #values_at and #dig need to return the value associated to a
# certain key. When that key is not found, that value will be determined by its
# default proc (if any) or else its default (initially `nil`).
#
# You can retrieve the default value with method #default:
#
#     h = Hash.new
#     h.default # => nil
#
# You can set the default value by passing an argument to method Hash.new or
# with method #default=
#
#     h = Hash.new(-1)
#     h.default # => -1
#     h.default = 0
#     h.default # => 0
#
# This default value is returned for #[], #values_at and #dig when a key is not
# found:
#
#     counts = {foo: 42}
#     counts.default # => nil (default)
#     counts[:foo] = 42
#     counts[:bar] # => nil
#     counts.default = 0
#     counts[:bar] # => 0
#     counts.values_at(:foo, :bar, :baz) # => [42, 0, 0]
#     counts.dig(:bar) # => 0
#
# Note that the default value is used without being duplicated. It is not
# advised to set the default value to a mutable object:
#
#     synonyms = Hash.new([])
#     synonyms[:hello] # => []
#     synonyms[:hello] << :hi # => [:hi], but this mutates the default!
#     synonyms.default # => [:hi]
#     synonyms[:world] << :universe
#     synonyms[:world] # => [:hi, :universe], oops
#     synonyms.keys # => [], oops
#
# To use a mutable object as default, it is recommended to use a default proc
#
# #### Default Proc
#
# When the default proc for a Hash is set (i.e., not `nil`), the default value
# returned by method #[] is determined by the default proc alone.
#
# You can retrieve the default proc with method #default_proc:
#
#     h = Hash.new
#     h.default_proc # => nil
#
# You can set the default proc by calling Hash.new with a block or calling the
# method #default_proc=
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h.default_proc.class # => Proc
#     h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
#     h.default_proc.class # => Proc
#
# When the default proc is set (i.e., not `nil`) and method #[] is called with
# with a non-existent key, #[] calls the default proc with both the Hash object
# itself and the missing key, then returns the proc's return value:
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h[:nosuch] # => "Default value for nosuch"
#
# Note that in the example above no entry for key `:nosuch` is created:
#
#     h.include?(:nosuch) # => false
#
# However, the proc itself can add a new entry:
#
#     synonyms = Hash.new { |hash, key| hash[key] = [] }
#     synonyms.include?(:hello) # => false
#     synonyms[:hello] << :hi # => [:hi]
#     synonyms[:world] << :universe # => [:universe]
#     synonyms.keys # => [:hello, :world]
#
# Note that setting the default proc will clear the default value and vice
# versa.
#
# ### What's Here
#
# First, what's elsewhere. Class Hash:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Hash provides methods that are useful for:
#
# *   [Creating a Hash](#class-Hash-label-Methods+for+Creating+a+Hash)
# *   [Setting Hash State](#class-Hash-label-Methods+for+Setting+Hash+State)
# *   [Querying](#class-Hash-label-Methods+for+Querying)
# *   [Comparing](#class-Hash-label-Methods+for+Comparing)
# *   [Fetching](#class-Hash-label-Methods+for+Fetching)
# *   [Assigning](#class-Hash-label-Methods+for+Assigning)
# *   [Deleting](#class-Hash-label-Methods+for+Deleting)
# *   [Iterating](#class-Hash-label-Methods+for+Iterating)
# *   [Converting](#class-Hash-label-Methods+for+Converting)
# *   [Transforming Keys and
#     Values](#class-Hash-label-Methods+for+Transforming+Keys+and+Values)
# *   [And more....](#class-Hash-label-Other+Methods)
#
#
# Class Hash also includes methods from module Enumerable.
#
# #### Methods for Creating a Hash
#
# ::[]
# :   Returns a new hash populated with given objects.
# ::new
# :   Returns a new empty hash.
# ::try_convert
# :   Returns a new hash created from a given object.
#
#
# #### Methods for Setting Hash State
#
# #compare_by_identity
# :   Sets `self` to consider only identity in comparing keys.
# #default=
# :   Sets the default to a given value.
# #default_proc=
# :   Sets the default proc to a given proc.
# #rehash
# :   Rebuilds the hash table by recomputing the hash index for each key.
#
#
# #### Methods for Querying
#
# #any?
# :   Returns whether any element satisfies a given criterion.
# #compare_by_identity?
# :   Returns whether the hash considers only identity when comparing keys.
# #default
# :   Returns the default value, or the default value for a given key.
# #default_proc
# :   Returns the default proc.
# #empty?
# :   Returns whether there are no entries.
# #eql?
# :   Returns whether a given object is equal to `self`.
# #hash
# :   Returns the integer hash code.
# #has_value?
# :   Returns whether a given object is a value in `self`.
# #include?, #has_key?, #member?, #key?
# :   Returns whether a given object is a key in `self`.
# #length, #size
# :   Returns the count of entries.
# #value?
# :   Returns whether a given object is a value in `self`.
#
#
# #### Methods for Comparing
#
# [#<](#method-i-3C)
# :   Returns whether `self` is a proper subset of a given object.
# [#<=](#method-i-3C-3D)
# :   Returns whether `self` is a subset of a given object.
# [#==](#method-i-3D-3D)
# :   Returns whether a given object is equal to `self`.
# [#>](#method-i-3E)
# :   Returns whether `self` is a proper superset of a given object
# [#>=](#method-i-3E-3D)
# :   Returns whether `self` is a proper superset of a given object.
#
#
# #### Methods for Fetching
#
# #[]
# :   Returns the value associated with a given key.
# #assoc
# :   Returns a 2-element array containing a given key and its value.
# #dig
# :   Returns the object in nested objects that is specified by a given key and
#     additional arguments.
# #fetch
# :   Returns the value for a given key.
# #fetch_values
# :   Returns array containing the values associated with given keys.
# #key
# :   Returns the key for the first-found entry with a given value.
# #keys
# :   Returns an array containing all keys in `self`.
# #rassoc
# :   Returns a 2-element array consisting of the key and value of the
#     first-found entry having a given value.
# #values
# :   Returns an array containing all values in `self`/
# #values_at
# :   Returns an array containing values for given keys.
#
#
# #### Methods for Assigning
#
# #[]=, #store
# :   Associates a given key with a given value.
# #merge
# :   Returns the hash formed by merging each given hash into a copy of `self`.
# #merge!, #update
# :   Merges each given hash into `self`.
# #replace
# :   Replaces the entire contents of `self` with the contents of a givan hash.
#
#
# #### Methods for Deleting
#
# These methods remove entries from `self`:
#
# #clear
# :   Removes all entries from `self`.
# #compact!
# :   Removes all `nil`-valued entries from `self`.
# #delete
# :   Removes the entry for a given key.
# #delete_if
# :   Removes entries selected by a given block.
# #filter!, #select!
# :   Keep only those entries selected by a given block.
# #keep_if
# :   Keep only those entries selected by a given block.
# #reject!
# :   Removes entries selected by a given block.
# #shift
# :   Removes and returns the first entry.
#
#
# These methods return a copy of `self` with some entries removed:
#
# #compact
# :   Returns a copy of `self` with all `nil`-valued entries removed.
# #except
# :   Returns a copy of `self` with entries removed for specified keys.
# #filter, #select
# :   Returns a copy of `self` with only those entries selected by a given
#     block.
# #reject
# :   Returns a copy of `self` with entries removed as specified by a given
#     block.
# #slice
# :   Returns a hash containing the entries for given keys.
#
#
# #### Methods for Iterating
# #each, #each_pair
# :   Calls a given block with each key-value pair.
# #each_key
# :   Calls a given block with each key.
# #each_value
# :   Calls a given block with each value.
#
#
# #### Methods for Converting
#
# #inspect, #to_s
# :   Returns a new String containing the hash entries.
# #to_a
# :   Returns a new array of 2-element arrays; each nested array contains a
#     key-value pair from `self`.
# #to_h
# :   Returns `self` if a Hash; if a subclass of Hash, returns a Hash containing
#     the entries from `self`.
# #to_hash
# :   Returns `self`.
# #to_proc
# :   Returns a proc that maps a given key to its value.
#
#
# #### Methods for Transforming Keys and Values
#
# #transform_keys
# :   Returns a copy of `self` with modified keys.
# #transform_keys!
# :   Modifies keys in `self`
# #transform_values
# :   Returns a copy of `self` with modified values.
# #transform_values!
# :   Modifies values in `self`.
#
#
# #### Other Methods
# #flatten
# :   Returns an array that is a 1-dimensional flattening of `self`.
# #invert
# :   Returns a hash with the each key-value pair inverted.
#
class Hash[unchecked out K, unchecked out V] < Object
  include Enumerable[[ K, V ]]

  # <!--
  #   rdoc-file=hash.c
  #   - Hash[] -> new_empty_hash
  #   - Hash[hash] -> new_hash
  #   - Hash[ [*2_element_arrays] ] -> new_hash
  #   - Hash[*objects] -> new_hash
  # -->
  # Returns a new Hash object populated with the given objects, if any. See
  # Hash::new.
  #
  # With no argument, returns a new empty Hash.
  #
  # When the single given argument is a Hash, returns a new Hash populated with
  # the entries from the given Hash, excluding the default value or proc.
  #
  #     h = {foo: 0, bar: 1, baz: 2}
  #     Hash[h] # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When the single given argument is an Array of 2-element Arrays, returns a new
  # Hash object wherein each 2-element array forms a key-value entry:
  #
  #     Hash[ [ [:foo, 0], [:bar, 1] ] ] # => {:foo=>0, :bar=>1}
  #
  # When the argument count is an even number; returns a new Hash object wherein
  # each successive pair of arguments has become a key-value entry:
  #
  #     Hash[:foo, 0, :bar, 1] # => {:foo=>0, :bar=>1}
  #
  # Raises an exception if the argument list does not conform to any of the above.
  #
  def self.[]: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
             | [U, V] (Array[[ U, V ]]) -> ::Hash[U, V]
             | (*untyped) -> ::Hash[untyped, untyped]

  # <!--
  #   rdoc-file=hash.c
  #   - Hash.try_convert(obj) -> obj, new_hash, or nil
  # -->
  # If `obj` is a Hash object, returns `obj`.
  #
  # Otherwise if `obj` responds to `:to_hash`, calls `obj.to_hash` and returns the
  # result.
  #
  # Returns `nil` if `obj` does not respond to `:to_hash`
  #
  # Raises an exception unless `obj.to_hash` returns a Hash object.
  #
  def self.try_convert: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
                      | (untyped) -> (::Hash[untyped, untyped] | nil)

  public

  # <!--
  #   rdoc-file=hash.c
  #   - hash < other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper subset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 < h2 # => true
  #     h2 < h1 # => false
  #     h1 < h1 # => false
  #
  def <: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash <= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a subset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 <= h2 # => true
  #     h2 <= h1 # => false
  #     h1 <= h1 # => true
  #
  def <=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash == object -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a Hash object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `hash[key] == object[key]`.
  #
  #
  # Otherwise, returns `false`.
  #
  # Equal:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 == h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1 == h3 # => true
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash > other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper superset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 > h2 # => true
  #     h2 > h1 # => false
  #     h1 > h1 # => false
  #
  def >: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash >= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a superset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 >= h2 # => true
  #     h2 >= h1 # => false
  #     h1 >= h1 # => true
  #
  def >=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] -> value
  # -->
  # Returns the value associated with the given `key`, if found:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:foo] # => 0
  #
  # If `key` is not found, returns a default value (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:nosuch] # => nil
  #
  def []: (K arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] = value -> value
  #   - hash.store(key, value)
  # -->
  # Hash#store is an alias for Hash#[]=.
  #
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  def []=: (K arg0, V arg1) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.any? -> true or false
  #   - hash.any?(object) -> true or false
  #   - hash.any? {|key, value| ... } -> true or false
  # -->
  # Returns `true` if any element satisfies a given criterion; `false` otherwise.
  #
  # With no argument and no block, returns `true` if `self` is non-empty; `false`
  # if empty.
  #
  # With argument `object` and no block, returns `true` if for any key `key`
  # `h.assoc(key) == object`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any?([:bar, 1]) # => true
  #     h.any?([:bar, 0]) # => false
  #     h.any?([:baz, 1]) # => false
  #
  # With no argument and a block, calls the block with each key-value pair;
  # returns `true` if the block returns any truthy value, `false` otherwise:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any? {|key, value| value < 3 } # => true
  #     h.any? {|key, value| value > 3 } # => false
  #
  def any?: () -> bool
          | (untyped pattern) -> bool
          | () { (K, V) -> boolish } -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.assoc(key) -> new_array or nil
  # -->
  # If the given `key` is found, returns a 2-element Array containing that key and
  # its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.assoc(:bar) # => [:bar, 1]
  #
  # Returns `nil` if key `key` is not found.
  #
  def assoc: (K arg0) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.clear -> self
  # -->
  # Removes all hash entries; returns `self`.
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact -> new_hash
  # -->
  # Returns a copy of `self` with all `nil`-valued entries removed:
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h1 = h.compact
  #     h1 # => {:foo=>0, :baz=>2}
  #
  def compact: () -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact! -> self or nil
  # -->
  # Returns `self` with all its `nil`-valued entries removed (in place):
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h.compact! # => {:foo=>0, :baz=>2}
  #
  # Returns `nil` if no entries were removed.
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity -> self
  # -->
  # Sets `self` to consider only identity in comparing keys; two keys are
  # considered the same only if they are the same object; returns `self`.
  #
  # By default, these two object are considered to be the same key, so `s1` will
  # overwrite `s0`:
  #     s0 = 'x'
  #     s1 = 'x'
  #     h = {}
  #     h.compare_by_identity? # => false
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>1}
  #
  # After calling #compare_by_identity, the keys are considered to be different,
  # and therefore do not overwrite each other:
  #     h = {}
  #     h.compare_by_identity # => {}
  #     h.compare_by_identity? # => true
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>0, "x"=>1}
  #
  def compare_by_identity: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity? -> true or false
  # -->
  # Returns `true` if #compare_by_identity has been called, `false` otherwise.
  #
  def compare_by_identity?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - deconstruct_keys(p1)
  # -->
  #
  def deconstruct_keys: (Array[K] | nil) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default -> object
  #   - hash.default(key) -> object
  # -->
  # Returns the default value for the given `key`. The returned value will be
  # determined either by the default proc or by the default value. See [Default
  # Values](#class-Hash-label-Default+Values).
  #
  # With no argument, returns the current default value:
  #     h = {}
  #     h.default # => nil
  #
  # If `key` is given, returns the default value for `key`, regardless of whether
  # that key exists:
  #     h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
  #     h[:foo] = "Hello"
  #     h.default(:foo) # => "No key foo"
  #
  def default: (?K arg0) -> V?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default = value -> object
  # -->
  # Sets the default value to `value`; returns `value`:
  #     h = {}
  #     h.default # => nil
  #     h.default = false # => false
  #     h.default # => false
  #
  # See [Default Values](#class-Hash-label-Default+Values).
  #
  def default=: (V arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc -> proc or nil
  # -->
  # Returns the default proc for `self` (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc {|hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #
  def default_proc: () -> (Proc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc = proc -> proc
  # -->
  # Sets the default proc for `self` to `proc`: (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc { |hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #     h.default_proc = nil
  #     h.default_proc # => nil
  #
  def default_proc=: (Proc | _ToProc | nil) -> (Proc | _ToProc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete(key) -> value or nil
  #   - hash.delete(key) {|key| ... } -> object
  # -->
  # Deletes the entry for the given `key` and returns its associated value.
  #
  # If no block is given and `key` is found, deletes the entry and returns the
  # associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:bar) # => 1
  #     h # => {:foo=>0, :baz=>2}
  #
  # If no block given and `key` is not found, returns `nil`.
  #
  # If a block is given and `key` is found, ignores the block, deletes the entry,
  # and returns the associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:baz) { |key| raise 'Will never happen'} # => 2
  #     h # => {:foo=>0, :bar=>1}
  #
  # If a block is given and `key` is not found, calls the block and returns the
  # block's return value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:nosuch) { |key| "Key #{key} not found" } # => "Key nosuch not found"
  #     h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def delete: (K arg0) -> V?
            | [U] (K arg0) { (K arg0) -> U } -> (U | V)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete_if {|key, value| ... } -> self
  #   - hash.delete_if -> new_enumerator
  # -->
  # If a block given, calls the block with each key-value pair; deletes each entry
  # for which the block returns a truthy value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete_if {|key, value| value > 0 } # => {:foo=>0}
  #
  # If no block given, returns a new Enumerator:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.delete_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:delete_if>
  #     e.each { |key, value| value > 0 } # => {:foo=>0}
  #
  def delete_if: () { (K, V) -> boolish } -> self
               | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.dig(key, *identifiers) -> object
  # -->
  # Finds and returns the object in nested objects that is specified by `key` and
  # `identifiers`. The nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Nested Hashes:
  #     h = {foo: {bar: {baz: 2}}}
  #     h.dig(:foo) # => {:bar=>{:baz=>2}}
  #     h.dig(:foo, :bar) # => {:baz=>2}
  #     h.dig(:foo, :bar, :baz) # => 2
  #     h.dig(:foo, :bar, :BAZ) # => nil
  #
  # Nested Hashes and Arrays:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:foo, :bar, 2) # => :c
  #
  # This method will use the [default values](#class-Hash-label-Default+Values)
  # for keys that are not present:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:hello) # => nil
  #     h.default_proc = -> (hash, _key) { hash }
  #     h.dig(:hello, :world) # => h
  #     h.dig(:hello, :world, :foo, :bar, 2) # => :c
  #
  def dig: (*untyped) -> untyped

  # <!-- rdoc-file=hash.c -->
  # Hash#each is an alias for Hash#each_pair.
  #
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  def each: () { ([ K, V ] arg0) -> untyped } -> self
          | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_key {|key| ... } -> self
  #   - hash.each_key -> new_enumerator
  # -->
  # Calls the given block with each key; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_key {|key| puts key }  # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_key # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_key>
  #     h1 = e.each {|key| puts key }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  def each_key: () { (K arg0) -> untyped } -> ::Hash[K, V]
              | () -> ::Enumerator[K, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each {|key, value| ... } -> self
  #   - hash.each_pair {|key, value| ... } -> self
  #   - hash.each -> new_enumerator
  #   - hash.each_pair -> new_enumerator
  # -->
  # Hash#each is an alias for Hash#each_pair.
  #
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  alias each_pair each

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_value {|value| ... } -> self
  #   - hash.each_value -> new_enumerator
  # -->
  # Calls the given block with each value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_value {|value| puts value } # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_value # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_value>
  #     h1 = e.each {|value| puts value }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  def each_value: () { (V arg0) -> untyped } -> self
                | () -> ::Enumerator[V, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.empty? -> true or false
  # -->
  # Returns `true` if there are no hash entries, `false` otherwise:
  #     {}.empty? # => true
  #     {foo: 0, bar: 1, baz: 2}.empty? # => false
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.eql? object -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a Hash object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `h[key] eql? object[key]`.
  #
  #
  # Otherwise, returns `false`.
  #
  # Equal:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1.eql? h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1.eql? h3 # => true
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hsh.except(*keys) -> a_hash
  # -->
  # Returns a new Hash excluding entries for the given `keys`:
  #     h = { a: 100, b: 200, c: 300 }
  #     h.except(:a)          #=> {:b=>200, :c=>300}
  #
  # Any given `keys` that are not found are ignored.
  #
  def except: (*K) -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch(key) -> object
  #   - hash.fetch(key, default_value) -> object
  #   - hash.fetch(key) {|key| ... } -> object
  # -->
  # Returns the value for the given `key`, if found.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch(:bar) # => 1
  #
  # If `key` is not found and no block was given, returns `default_value`:
  #     {}.fetch(:nosuch, :default) # => :default
  #
  # If `key` is not found and a block was given, yields `key` to the block and
  # returns the block's return value:
  #     {}.fetch(:nosuch) {|key| "No key #{key}"} # => "No key nosuch"
  #
  # Raises KeyError if neither `default_value` nor a block was given.
  #
  # Note that this method does not use the values of either #default or
  # #default_proc.
  #
  def fetch: (K arg0) -> V
           | [X] (K arg0, X arg1) -> (V | X)
           | [X] (K arg0) { (K arg0) -> X } -> (V | X)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch_values(*keys) -> new_array
  #   - hash.fetch_values(*keys) {|key| ... } -> new_array
  # -->
  # Returns a new Array containing the values associated with the given keys
  # *keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch_values(:baz, :foo) # => [2, 0]
  #
  # Returns a new empty Array if no arguments given.
  #
  # When a block is given, calls the block with each missing key, treating the
  # block's return value as the value for that key:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
  #     values # => [1, 0, "bad", "bam"]
  #
  # When no block is given, raises an exception if any given key is not found.
  #
  def fetch_values: (*K) -> ::Array[V]
                  | [X] (*K) { (K) -> X } -> ::Array[V | X]

  # <!-- rdoc-file=hash.c -->
  # Hash#filter is an alias for Hash#select.
  #
  # Returns a new Hash object whose entries are those for which the block returns
  # a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter: () { (K, V) -> boolish } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], ::Hash[K, V]]

  # <!-- rdoc-file=hash.c -->
  # Hash#filter! is an alias for Hash#select!.
  #
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter!: () { (K, V) -> boolish } -> self?
             | () -> ::Enumerator[[ K, V ], self?]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.flatten -> new_array
  #   - hash.flatten(level) -> new_array
  # -->
  # Returns a new Array object that is a 1-dimensional flattening of `self`.
  #
  # ---
  #
  # By default, nested Arrays are not flattened:
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten # => [:foo, 0, :bar, [:bat, 3], :baz, 2]
  #
  # Takes the depth of recursive flattening from Integer argument `level`:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(1) # => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
  #     h.flatten(2) # => [:foo, 0, :bar, :bat, [:baz, [:bat]]]
  #     h.flatten(3) # => [:foo, 0, :bar, :bat, :baz, [:bat]]
  #     h.flatten(4) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is negative, flattens all nested Arrays:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(-1) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #     h.flatten(-2) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is zero, returns the equivalent of #to_a :
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten(0) # => [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
  #     h.flatten(0) == h.to_a # => true
  #
  def flatten: () -> ::Array[K | V]
             | (1 level) -> ::Array[K | V]
             | (Integer level) -> Array[untyped]

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  def has_key?: (K arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.has_value?(value) -> true or false
  #   - hash.value?(value) -> true or false
  # -->
  # Method #value? is an alias for #has_value?.
  #
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  def has_value?: (V arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.hash -> an_integer
  # -->
  # Returns the Integer hash-code for the hash.
  #
  # Two Hash objects have the same hash-code if their content is the same
  # (regardless or order):
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {baz: 2, bar: 1, foo: 0}
  #     h2.hash == h1.hash # => true
  #     h2.eql? h1 # => true
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=hash.c
  #   - hash.include?(key) -> true or false
  #   - hash.has_key?(key) -> true or false
  #   - hash.key?(key) -> true or false
  #   - hash.member?(key) -> true or false
  # -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias include? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.inspect -> new_string
  # -->
  # Returns a new String containing the hash entries:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{:foo=>0, :bar=>1, :baz=>2}"
  #
  # Hash#to_s is an alias for Hash#inspect.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=hash.c
  #   - hash.invert -> new_hash
  # -->
  # Returns a new Hash object with the each key-value pair inverted:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.invert
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # Overwrites any repeated new keys: (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 0, baz: 0}
  #     h.invert # => {0=>:baz}
  #
  def invert: () -> ::Hash[V, K]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keep_if {|key, value| ... } -> self
  #   - hash.keep_if -> new_enumerator
  # -->
  # Calls the block for each key-value pair; retains the entry if the block
  # returns a truthy value; otherwise deletes the entry; returns `self`.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keep_if { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.keep_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:keep_if>
  #     e.each { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  def keep_if: () { (K, V) -> boolish } -> self
             | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.key(value) -> key or nil
  # -->
  # Returns the key for the first-found entry with the given `value` (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 2, baz: 2}
  #     h.key(0) # => :foo
  #     h.key(2) # => :bar
  #
  # Returns `nil` if so such value is found.
  #
  def key: (V) -> K?

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias key? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keys -> new_array
  # -->
  # Returns a new Array containing all keys in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keys # => [:foo, :bar, :baz]
  #
  def keys: () -> ::Array[K]

  # <!-- rdoc-file=hash.c -->
  # Returns the count of entries in `self`:
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  # Hash#length is an alias for Hash#size.
  #
  def length: () -> Integer

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias member? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge -> copy_of_self
  #   - hash.merge(*other_hashes) -> new_hash
  #   - hash.merge(*other_hashes) { |key, old_value, new_value| ... } -> new_hash
  # -->
  # Returns the new Hash formed by merging each of `other_hashes` into a copy of
  # `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # ---
  #
  # With arguments and no block:
  # *   Returns the new Hash object formed by merging each successive Hash in
  #     `other_hashes` into `self`.
  # *   Each new-key entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns a new Hash object that is the merge of `self` and each given hash.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns a copy of `self`.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge: [A, B] (*::Hash[A, B] other_hashes) -> ::Hash[A | K, B | V]
           | [A, B, C] (*::Hash[A, B] other_hashes) { (K key, V oldval, B newval) -> C } -> ::Hash[A | K, B | V | C]

  # <!-- rdoc-file=hash.c -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # Method #update is an alias for #merge!.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge!: (*::Hash[K, V] other_hashes) -> self
            | (*::Hash[K, V] other_hashes) { (K key, V oldval, V newval) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rassoc(value) -> new_array or nil
  # -->
  # Returns a new 2-element Array consisting of the key and value of the
  # first-found entry whose value is `==` to value (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1, baz: 1}
  #     h.rassoc(1) # => [:bar, 1]
  #
  # Returns `nil` if no such value found.
  #
  def rassoc: (V) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rehash -> self
  # -->
  # Rebuilds the hash table by recomputing the hash index for each key; returns
  # `self`.
  #
  # The hash table becomes invalid if the hash value of a key has changed after
  # the entry was created. See [Modifying an Active Hash
  # Key](#class-Hash-label-Modifying+an+Active+Hash+Key).
  #
  def rehash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject {|key, value| ... } -> new_hash
  #   - hash.reject -> new_enumerator
  # -->
  # Returns a new Hash object whose entries are all those from `self` for which
  # the block returns `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.reject {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject>
  #     h1 = e.each {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  def reject: () -> ::Enumerator[[ K, V ], self]
            | () { (K, V) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject! {|key, value| ... } -> self or nil
  #   - hash.reject! -> new_enumerator
  # -->
  # Returns `self`, whose remaining entries are those for which the block returns
  # `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.reject! {|key, value| value < 2 } # => {:baz=>2}
  #
  # Returns `nil` if no entries are removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject! # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject!>
  #     e.each {|key, value| key.start_with?('b') } # => {:foo=>0}
  #
  def reject!: () -> ::Enumerator[[ K, V ], self?]
             | () { (K, V) -> boolish } -> self?

  # <!-- rdoc-file=hash.c -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def replace: (Hash[K, V]) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select {|key, value| ... } -> new_hash
  #   - hash.select -> new_enumerator
  # -->
  # Hash#filter is an alias for Hash#select.
  #
  # Returns a new Hash object whose entries are those for which the block returns
  # a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select filter

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select! {|key, value| ... } -> self or nil
  #   - hash.select! -> new_enumerator
  # -->
  # Hash#filter! is an alias for Hash#select!.
  #
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select! filter!

  # <!--
  #   rdoc-file=hash.c
  #   - hash.shift -> [key, value] or default_value
  # -->
  # Removes the first hash entry (see [Entry
  # Order](#class-Hash-label-Entry+Order)); returns a 2-element Array containing
  # the removed key and value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.shift # => [:foo, 0]
  #     h # => {:bar=>1, :baz=>2}
  #
  # Returns the default value if the hash is empty (see [Default
  # Values](#class-Hash-label-Default+Values)).
  #
  def shift: () -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.length -> integer
  #   - hash.size -> integer
  # -->
  # Returns the count of entries in `self`:
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  # Hash#length is an alias for Hash#size.
  #
  alias size length

  # <!--
  #   rdoc-file=hash.c
  #   - hash.slice(*keys) -> new_hash
  # -->
  # Returns a new Hash object containing the entries for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.slice(:baz, :foo) # => {:baz=>2, :foo=>0}
  #
  # Any given `keys` that are not found are ignored.
  #
  def slice: (*K) -> ::Hash[K, V]

  # <!-- rdoc-file=hash.c -->
  # Hash#store is an alias for Hash#[]=.
  #
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  alias store []=

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_a -> new_array
  # -->
  # Returns a new Array of 2-element Array objects; each nested Array contains a
  # key-value pair from `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.to_a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  def to_a: () -> ::Array[[ K, V ]]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_h -> self or new_hash
  #   - hash.to_h {|key, value| ... } -> new_hash
  # -->
  # For an instance of Hash, returns `self`.
  #
  # For a subclass of Hash, returns a new Hash containing the content of `self`.
  #
  # When a block is given, returns a new Hash object whose content is based on the
  # block; the block should return a 2-element Array object specifying the
  # key-value pair to be included in the returned Array:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.to_h {|key, value| [value, key] }
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  def to_h: () -> Hash[K, V]
          | [A, B] () { (K, V) -> [ A, B ] } -> Hash[A, B]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_hash -> self
  # -->
  # Returns `self`.
  #
  def to_hash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_proc -> proc
  # -->
  # Returns a Proc object that maps a key to its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     proc = h.to_proc
  #     proc.class # => Proc
  #     proc.call(:foo) # => 0
  #     proc.call(:bar) # => 1
  #     proc.call(:nosuch) # => nil
  #
  def to_proc: () -> ^(K) -> V?

  # <!-- rdoc-file=hash.c -->
  # Returns a new String containing the hash entries:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{:foo=>0, :bar=>1, :baz=>2}"
  #
  # Hash#to_s is an alias for Hash#inspect.
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys {|key| ... } -> new_hash
  #   - hash.transform_keys(hash2) -> new_hash
  #   - hash.transform_keys(hash2) {|other_key| ...} -> new_hash
  #   - hash.transform_keys -> new_enumerator
  # -->
  # Returns a new Hash object; each entry has:
  # *   A key provided by the block.
  # *   The value from `self`.
  #
  #
  # An optional hash argument can be provided to map keys to new keys. Any key not
  # given will be mapped using the provided block, or remain the same if no block
  # is given.
  #
  # Transform keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  #     h.transform_keys(foo: :bar, bar: :foo)
  #     #=> {bar: 0, foo: 1, baz: 2}
  #
  #     h.transform_keys(foo: :hello, &:to_s)
  #     #=> {:hello=>0, "bar"=>1, "baz"=>2}
  #
  # Overwrites values for duplicate keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| :bat }
  #     h1 # => {:bat=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_keys # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_keys>
  #     h1 = e.each { |key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  def transform_keys: () -> Enumerator[K, Hash[untyped, V]]
                    | [A] () { (K) -> A } -> Hash[A, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys! {|key| ... } -> self
  #   - hash.transform_keys!(hash2) -> self
  #   - hash.transform_keys!(hash2) {|other_key| ...} -> self
  #   - hash.transform_keys! -> new_enumerator
  # -->
  # Same as Hash#transform_keys but modifies the receiver in place instead of
  # returning a new hash.
  #
  def transform_keys!: () -> Enumerator[K, self]
                     | () { (K) -> K } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values {|value| ... } -> new_hash
  #   - hash.transform_values -> new_enumerator
  # -->
  # Returns a new Hash object; each entry has:
  # *   A key from `self`.
  # *   A value provided by the block.
  #
  #
  # Transform values:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_values {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_values>
  #     h1 = e.each { |value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values: () -> Enumerator[V, Hash[K, untyped]]
                      | [A] () { (V) -> A } -> Hash[K, A]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values! {|value| ... } -> self
  #   - hash.transform_values! -> new_enumerator
  # -->
  # Returns `self`, whose keys are unchanged, and whose values are determined by
  # the given block.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.transform_values! {|value| value * 100} # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values! # => #<Enumerator: {:foo=>0, :bar=>100, :baz=>200}:transform_values!>
  #     h1 = e.each {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values!: () -> Enumerator[V, self]
                       | () { (V) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge! -> self
  #   - hash.merge!(*other_hashes) -> self
  #   - hash.merge!(*other_hashes) { |key, old_value, new_value| ... } -> self
  # -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # Method #update is an alias for #merge!.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  alias update merge!

  # <!-- rdoc-file=hash.c -->
  # Method #value? is an alias for #has_value?.
  #
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  alias value? has_value?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values -> new_array
  # -->
  # Returns a new Array containing all values in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values # => [0, 1, 2]
  #
  def values: () -> ::Array[V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values_at(*keys) -> new_array
  # -->
  # Returns a new Array containing values for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values_at(:baz, :foo) # => [2, 0]
  #
  # The [default values](#class-Hash-label-Default+Values) are returned for any
  # keys that are not found:
  #     h.values_at(:hello, :foo) # => [nil, 0]
  #
  def values_at: (*K arg0) -> ::Array[V?]

  private

  # <!--
  #   rdoc-file=hash.c
  #   - Hash.new(default_value = nil) -> new_hash
  #   - Hash.new {|hash, key| ... } -> new_hash
  # -->
  # Returns a new empty Hash object.
  #
  # The initial default value and initial default proc for the new hash depend on
  # which form above was used. See [Default
  # Values](#class-Hash-label-Default+Values).
  #
  # If neither an argument nor a block given, initializes both the default value
  # and the default proc to `nil`:
  #     h = Hash.new
  #     h.default # => nil
  #     h.default_proc # => nil
  #
  # If argument `default_value` given but no block given, initializes the default
  # value to the given `default_value` and the default proc to `nil`:
  #     h = Hash.new(false)
  #     h.default # => false
  #     h.default_proc # => nil
  #
  # If a block given but no argument, stores the block as the default proc and
  # sets the default value to `nil`:
  #     h = Hash.new {|hash, key| "Default value for #{key}" }
  #     h.default # => nil
  #     h.default_proc.class # => Proc
  #     h[:nosuch] # => "Default value for nosuch"
  #
  def initialize: () -> void
                | (untyped default) -> void
                | [A, B] () { (Hash[A, B] hash, A key) -> B } -> void

  # <!--
  #   rdoc-file=hash.c
  #   - hash.replace(other_hash) -> self
  # -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def initialize_copy: (self object) -> self
end

# <!-- rdoc-file=proc.c -->
# Ruby supports two forms of objectified methods. Class Method is used to
# represent methods that are associated with a particular object: these method
# objects are bound to that object. Bound method objects for an object can be
# created using Object#method.
#
# Ruby also supports unbound methods; methods objects that are not associated
# with a particular object. These can be created either by calling
# Module#instance_method or by calling #unbind on a bound method object. The
# result of both of these is an UnboundMethod object.
#
# Unbound methods can only be called after they are bound to an object. That
# object must be a kind_of? the method's original class.
#
#     class Square
#       def area
#         @side * @side
#       end
#       def initialize(side)
#         @side = side
#       end
#     end
#
#     area_un = Square.instance_method(:area)
#
#     s = Square.new(12)
#     area = area_un.bind(s)
#     area.call   #=> 144
#
# Unbound methods are a reference to the method at the time it was objectified:
# subsequent changes to the underlying class will not affect the unbound method.
#
#     class Test
#       def test
#         :original
#       end
#     end
#     um = Test.instance_method(:test)
#     class Test
#       def test
#         :modified
#       end
#     end
#     t = Test.new
#     t.test            #=> :modified
#     um.bind(t).call   #=> :original
#
class UnboundMethod
  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind(obj) -> method
  # -->
  # Bind *umeth* to *obj*. If Klass was the class from which *umeth* was obtained,
  # `obj.kind_of?(Klass)` must be true.
  #
  #     class A
  #       def test
  #         puts "In test, class = #{self.class}"
  #       end
  #     end
  #     class B < A
  #     end
  #     class C < B
  #     end
  #
  #     um = B.instance_method(:test)
  #     bm = um.bind(C.new)
  #     bm.call
  #     bm = um.bind(B.new)
  #     bm.call
  #     bm = um.bind(A.new)
  #     bm.call
  #
  # *produces:*
  #
  #     In test, class = C
  #     In test, class = B
  #     prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)
  #      from prog.rb:16
  #
  def bind: (untyped obj) -> Method

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module that defines the method. See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> Module

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> ::Array[[ Symbol, Symbol ]]
                | () -> ::Array[[ Symbol ]]

  # <!--
  #   rdoc-file=proc.c
  #   - meth.private? -> true or false
  # -->
  # Returns whether the method is private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.protected? -> true or false
  # -->
  # Returns whether the method is protected.
  #
  def protected?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.public? -> true or false
  # -->
  # Returns whether the method is public.
  #
  def public?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> UnboundMethod?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind_call(recv, args, ...) -> obj
  # -->
  # Bind *umeth* to *recv* and then invokes the method with the specified
  # arguments. This is semantically equivalent to `umeth.bind(recv).call(args,
  # ...)`.
  #
  def bind_call: (untyped recv, *untyped args) ?{ (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=numeric.c -->
# A Float object represents a sometimes-inexact real number using the native
# architecture's double-precision floating point representation.
#
# Floating point has a different arithmetic and is an inexact number. So you
# should know its esoteric system. See following:
#
# *   https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
# *   https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#floats_impre
#     cise
# *   https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
#
#
# You can create a Float object explicitly with:
#
# *   A [floating-point
#     literal](doc/syntax/literals_rdoc.html#label-Float+Literals).
#
#
# You can convert certain objects to Floats with:
#
# *   Method [Float](Kernel.html#method-i-Float).
#
#
# ## What's Here
#
# First, what's elsewhere. Class Float:
#
# *   Inherits from [class
#     Numeric](Numeric.html#class-Numeric-label-What-27s+Here).
#
#
# Here, class Float provides methods for:
#
# *   [Querying](#class-Float-label-Querying)
# *   [Comparing](#class-Float-label-Comparing)
# *   [Converting](#class-Float-label-Converting)
#
#
# ### Querying
#
#     #finite?
# :       Returns whether `self` is finite.
#
#     #hash
# :       Returns the integer hash code for `self`.
#
#     #infinite?
# :       Returns whether `self` is infinite.
#
#     #nan?
# :       Returns whether `self` is a NaN (not-a-number).
#
#
#
# ### Comparing
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given value.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given value.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns a number indicating whether `self` is less than, equal to, or
#         greater than the given value.
#
#     [==](#method-i-3D-3D) (aliased as #=== and #eql>)
# :       Returns whether `self` is equal to the given value.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than the given value.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than or equal to the given value.
#
#
#
# ### Converting
#
#     #% (aliased as #modulo)
# :       Returns `self` modulo the given value.
#
#     #*
# :       Returns the product of `self` and the given value.
#
#     [**](#method-i-2A-2A)
# :       Returns the value of `self` raised to the power of the given value.
#
#     #+
# :       Returns the sum of `self` and the given value.
#
#     #-
# :       Returns the difference of `self` and the given value.
#
#     [/](#method-i-2F)
# :       Returns the quotient of `self` and the given value.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`.
#
#     #coerce
# :       Returns a 2-element array containing the given value converted to a
#         Float and `self`
#
#     #divmod
# :       Returns a 2-element array containing the quotient and remainder
#         results of dividing `self` by the given value.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given value.
#
#     #floor
# :       Returns the greatest number smaller than or equal to `self`.
#
#     #next_float
# :       Returns the next-larger representable Float.
#
#     #prev_float
# :       Returns the next-smaller representable Float.
#
#     #quo
# :       Returns the quotient from dividing `self` by the given value.
#
#     #round
# :       Returns `self` rounded to the nearest value, to a given precision.
#
#     #to_i (aliased as #to_int)
# :       Returns `self` truncated to an Integer.
#
#     #to_s (aliased as #inspect)
# :       Returns a string containing the place-value representation of `self`
#         in the given radix.
#
#     #truncate
# :       Returns `self` truncated to a given precision.
#
class Float < Numeric
  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> float
  # -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  # Float#modulo is an alias for Float#%.
  #
  def %: (Integer) -> Float
       | (Float) -> Float
       | (Rational) -> Float
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self * other -> numeric
  # -->
  # Returns a new Float which is the product of `self` and `other`:
  #
  #     f = 3.14
  #     f * 2              # => 6.28
  #     f * 2.0            # => 6.28
  #     f * Rational(1, 2) # => 1.57
  #     f * Complex(2, 0)  # => (6.28+0.0i)
  #
  def *: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** other -> numeric
  # -->
  # Raises `self` to the power of `other`:
  #
  #     f = 3.14
  #     f ** 2              # => 9.8596
  #     f ** -2             # => 0.1014239928597509
  #     f ** 2.1            # => 11.054834900588839
  #     f ** Rational(2, 1) # => 9.8596
  #     f ** Complex(2, 0)  # => (9.8596+0i)
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self + other -> numeric
  # -->
  # Returns a new Float which is the sum of `self` and `other`:
  #
  #     f = 3.14
  #     f + 1                 # => 4.140000000000001
  #     f + 1.0               # => 4.140000000000001
  #     f + Rational(1, 1)    # => 4.140000000000001
  #     f + Complex(1, 0)     # => (4.140000000000001+0i)
  #
  def +: (Complex) -> Complex
       | (Numeric) -> Float

  def +@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self - other -> numeric
  # -->
  # Returns a new Float which is the difference of `self` and `other`:
  #
  #     f = 3.14
  #     f - 1                 # => 2.14
  #     f - 1.0               # => 2.14
  #     f - Rational(1, 1)    # => 2.14
  #     f - Complex(1, 0)     # => (2.14+0i)
  #
  def -: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - -float  ->  float
  # -->
  # Returns `float`, negated.
  #
  def -@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self / other -> numeric
  # -->
  # Returns a new Float which is the result of dividing `self` by `other`:
  #
  #     f = 3.14
  #     f / 2              # => 1.57
  #     f / 2.0            # => 1.57
  #     f / Rational(2, 1) # => 1.57
  #     f / Complex(2, 0)  # => (1.57+0.0i)
  #
  def /: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than `other`:
  #
  #     2.0 < 3              # => true
  #     2.0 < 3.0            # => true
  #     2.0 < Rational(3, 1) # => true
  #     2.0 < 2.0            # => false
  #
  # `Float::NAN < Float::NAN` returns an implementation-dependent value.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than or equal to `other`:
  #
  #     2.0 <= 3              # => true
  #     2.0 <= 3.0            # => true
  #     2.0 <= Rational(3, 1) # => true
  #     2.0 <= 2.0            # => true
  #     2.0 <= 1.0            # => false
  #
  # `Float::NAN <= Float::NAN` returns an implementation-dependent value.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other ->  -1, 0, +1, or nil
  # -->
  # Returns a value that depends on the numeric relation between `self` and
  # `other`:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater than `other`.
  # *   `nil`, if the two values are incommensurate.
  #
  #
  # Examples:
  #
  #     2.0 <=> 2              # => 0
  #     2.0 <=> 2.0            # => 0
  #     2.0 <=> Rational(2, 1) # => 0
  #     2.0 <=> Complex(2, 0)  # => 0
  #     2.0 <=> 1.9            # => 1
  #     2.0 <=> 2.1            # => -1
  #     2.0 <=> 'foo'          # => nil
  #
  # This is the basis for the tests in the Comparable module.
  #
  # `Float::NAN <=> Float::NAN` returns an implementation-dependent value.
  #
  def <=>: (Numeric) -> Integer?

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than `other`:
  #
  #     2.0 > 1              # => true
  #     2.0 > 1.0            # => true
  #     2.0 > Rational(1, 2) # => true
  #     2.0 > 2.0            # => false
  #
  # `Float::NAN > Float::NAN` returns an implementation-dependent value.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than or equal to `other`:
  #
  #     2.0 >= 1              # => true
  #     2.0 >= 1.0            # => true
  #     2.0 >= Rational(1, 2) # => true
  #     2.0 >= 2.0            # => true
  #     2.0 >= 2.1            # => false
  #
  # `Float::NAN >= Float::NAN` returns an implementation-dependent value.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.abs        ->  float
  #   - float.magnitude  ->  float
  # -->
  # Returns the absolute value of `float`.
  #
  #     (-34.56).abs   #=> 34.56
  #     -34.56.abs     #=> 34.56
  #     34.56.abs      #=> 34.56
  #
  # Float#magnitude is an alias for Float#abs.
  #
  def abs: () -> Float

  def abs2: () -> Float

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=complex.c
  #   - flo.arg    ->  0 or float
  #   - flo.angle  ->  0 or float
  #   - flo.phase  ->  0 or float
  # -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> float or integer
  # -->
  # Returns the smallest number greater than or equal to `self` with a precision
  # of `ndigits` decimal digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.ceil(1) # => 12345.7
  #     f.ceil(3) # => 12345.679
  #     f = -12345.6789
  #     f.ceil(1) # => -12345.6
  #     f.ceil(3) # => -12345.678
  #
  # When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.ceil(0)  # => 12346
  #     f.ceil(-3) # => 13000
  #     f = -12345.6789
  #     f.ceil(0)  # => -12345
  #     f.ceil(-3) # => -12000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (2.1 / 0.7).ceil  #=> 4 (!)
  #
  # Related: Float#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing `other` converted to a Float and `self`:
  #
  #     f = 3.14                 # => 3.14
  #     f.coerce(2)              # => [2.0, 3.14]
  #     f.coerce(2.0)            # => [2.0, 3.14]
  #     f.coerce(Rational(1, 2)) # => [0.5, 3.14]
  #     f.coerce(Complex(1, 0))  # => [1.0, 3.14]
  #
  # Raises an exception if a type conversion fails.
  #
  def coerce: (Numeric) -> [ Float, Float ]

  def conj: () -> Float

  def conjugate: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flo.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).  The result is machine dependent.
  #
  # See also Float#numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor      # Quotient
  #     r = self % other            # Remainder
  #
  # Examples:
  #
  #     11.0.divmod(4)              # => [2, 3.0]
  #     11.0.divmod(-4)             # => [-3, -1.0]
  #     -11.0.divmod(4)             # => [-3, 1.0]
  #     -11.0.divmod(-4)            # => [2, -3.0]
  #
  #     12.0.divmod(4)              # => [3, 0.0]
  #     12.0.divmod(-4)             # => [-3, 0.0]
  #     -12.0.divmod(4)             # => [-3, -0.0]
  #     -12.0.divmod(-4)            # => [3, -0.0]
  #
  #     13.0.divmod(4.0)            # => [3, 1.0]
  #     13.0.divmod(Rational(4, 1)) # => [3, 1.0]
  #
  def divmod: (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `other` is a Float with the same value as `self`, `false`
  # otherwise:
  #
  #     2.0.eql?(2.0)            # => true
  #     2.0.eql?(1.0)            # => false
  #     2.0.eql?(1)              # => false
  #     2.0.eql?(Rational(2, 1)) # => false
  #     2.0.eql?(Complex(2, 0))  # => false
  #
  # `Float::NAN.eql?(Float::NAN)` returns an implementation-dependent value.
  #
  # Related: Float#== (performs type conversions).
  #
  def eql?: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  # Float#fdiv is an alias for Float#quo.
  #
  def fdiv: (Complex) -> Complex
          | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - finite? -> true or false
  # -->
  # Returns `true` if `self` is not `Infinity`, `-Infinity`, or `Nan`, `false`
  # otherwise:
  #
  #     f = 2.0      # => 2.0
  #     f.finite?    # => true
  #     f = 1.0/0.0  # => Infinity
  #     f.finite?    # => false
  #     f = -1.0/0.0 # => -Infinity
  #     f.finite?    # => false
  #     f = 0.0/0.0  # => NaN
  #     f.finite?    # => false
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> float or integer
  # -->
  # Returns the largest number less than or equal to `self` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.floor(1) # => 12345.6
  #     f.floor(3) # => 12345.678
  #     f = -12345.6789
  #     f.floor(1) # => -12345.7
  #     f.floor(3) # => -12345.679
  #
  # When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.floor(0)  # => 12345
  #     f.floor(-3) # => 12000
  #     f = -12345.6789
  #     f.floor(0)  # => -12346
  #     f.floor(-3) # => -13000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).floor  #=> 2 (!)
  #
  # Related: Float#ceil.
  #
  def floor: () -> Integer
           | (int digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - infinite? -> -1, 1, or nil
  # -->
  # Returns:
  #
  # *   1, if `self` is `Infinity`.
  # *   -1 if `self` is `-Infinity`.
  # *   `nil`, otherwise.
  #
  #
  # Examples:
  #
  #     f = 1.0/0.0  # => Infinity
  #     f.infinite?  # => 1
  #     f = -1.0/0.0 # => -Infinity
  #     f.infinite?  # => -1
  #     f = 1.0      # => 1.0
  #     f.infinite?  # => nil
  #     f = 0.0/0.0  # => NaN
  #     f.infinite?  # => nil
  #
  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  # *   A number in "scientific notation" (containing an exponent).
  # *   'Infinity'.
  # *   '-Infinity'.
  # *   'NaN' (indicating not-a-number).
  #
  #     3.14.to_s         # => "3.14" (10.1**50).to_s   # =>
  #     "1.644631821843879e+50" (10.1**500).to_s  # => "Infinity"
  #     (-10.1**500).to_s # => "-Infinity" (0.0/0.0).to_s    # => "NaN"
  #
  alias inspect to_s

  def integer?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  # Float#modulo is an alias for Float#%.
  #
  def modulo: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - nan? -> true or false
  # -->
  # Returns `true` if `self` is a NaN, `false` otherwise.
  #
  #     f = -1.0     #=> -1.0
  #     f.nan?       #=> false
  #     f = 0.0/0.0  #=> NaN
  #     f.nan?       #=> true
  #
  def nan?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.negative?  ->  true or false
  # -->
  # Returns `true` if `float` is less than 0.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - next_float -> float
  # -->
  # Returns the next-larger representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.next_float`:
  #
  #     f = 0.0      # 0x0000000000000000
  #     f.next_float # 0x0000000000000001
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.next_float # 0x3f847ae147ae147c
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.next_float    # => 0.010000000000000002
  #     1.0.next_float     # => 1.0000000000000002
  #     100.0.next_float   # => 100.00000000000001
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.next_float }
  #
  # Output:
  #
  #      0 0x1.47ae147ae147bp-7 0.01
  #      1 0x1.47ae147ae147cp-7 0.010000000000000002
  #      2 0x1.47ae147ae147dp-7 0.010000000000000004
  #      3 0x1.47ae147ae147ep-7 0.010000000000000005
  #
  #     f = 0.0; 100.times { f += 0.1 }
  #     f                           # => 9.99999999999998       # should be 10.0 in the ideal world.
  #     10-f                        # => 1.9539925233402755e-14 # the floating point error.
  #     10.0.next_float-10          # => 1.7763568394002505e-15 # 1 ulp (unit in the last place).
  #     (10-f)/(10.0.next_float-10) # => 11.0                   # the error is 11 ulp.
  #     (10-f)/(10*Float::EPSILON)  # => 8.8                    # approximation of the above.
  #     "%a" % 10                   # => "0x1.4p+3"
  #     "%a" % f                    # => "0x1.3fffffffffff5p+3" # the last hex digit is 5.  16 - 5 = 11 ulp.
  #
  # Related: Float#prev_float
  #
  def next_float: () -> Float

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - flo.numerator  ->  integer
  # -->
  # Returns the numerator.  The result is machine dependent.
  #
  #     n = 0.3.numerator    #=> 5404319552844595
  #     d = 0.3.denominator  #=> 18014398509481984
  #     n.fdiv(d)            #=> 0.3
  #
  # See also Float#denominator.
  #
  def numerator: () -> Integer

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias phase angle

  def polar: () -> [ Float, Integer | Float ]

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.positive?  ->  true or false
  # -->
  # Returns `true` if `float` is greater than 0.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - float.prev_float  ->  float
  # -->
  # Returns the next-smaller representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.pev_float`:
  #
  #     f = 5e-324   # 0x0000000000000001
  #     f.prev_float # 0x0000000000000000
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.prev_float # 0x3f847ae147ae147a
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.prev_float   # => 0.009999999999999998
  #     1.0.prev_float    # => 0.9999999999999999
  #     100.0.prev_float  # => 99.99999999999999
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.prev_float }
  #
  # Output:
  #
  #     0 0x1.47ae147ae147bp-7 0.01
  #     1 0x1.47ae147ae147ap-7 0.009999999999999998
  #     2 0x1.47ae147ae1479p-7 0.009999999999999997
  #     3 0x1.47ae147ae1478p-7 0.009999999999999995
  #
  # Related: Float#next_float.
  #
  def prev_float: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - quo(other) -> numeric
  # -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  # Float#fdiv is an alias for Float#quo.
  #
  def quo: (Complex) -> Complex
         | (Numeric) -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flt.rationalize([eps])  ->  rational
  # -->
  # Returns a simpler approximation of the value (flt-|eps| <= result <=
  # flt+|eps|).  If the optional argument `eps` is not given, it will be chosen
  # automatically.
  #
  #     0.3.rationalize          #=> (3/10)
  #     1.333.rationalize        #=> (1333/1000)
  #     1.333.rationalize(0.01)  #=> (4/3)
  #
  # See also Float#to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Float

  def real?: () -> true

  def rect: () -> [ Float, Numeric ]

  alias rectangular rect

  def remainder: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits = 0, half: :up]) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is non-negative, returns a float with `ndigits` after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.round(1) # => 12345.7
  #     f.round(3) # => 12345.679
  #     f = -12345.6789
  #     f.round(1) # => -12345.7
  #     f.round(3) # => -12345.679
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.round(0)  # => 12346
  #     f.round(-3) # => 12000
  #     f = -12345.6789
  #     f.round(0)  # => -12346
  #     f.round(-3) # => -12000
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         2.5.round(half: :up)      # => 3
  #         3.5.round(half: :up)      # => 4
  #         (-2.5).round(half: :up)   # => -3
  #
  # *   `:down`: round toward zero:
  #
  #         2.5.round(half: :down)    # => 2
  #         3.5.round(half: :down)    # => 3
  #         (-2.5).round(half: :down) # => -2
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         2.5.round(half: :even)    # => 2
  #         3.5.round(half: :even)    # => 4
  #         (-2.5).round(half: :even) # => -2
  #
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Float#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  def step: (?Numeric limit, ?Numeric step) { (Float) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Float, self]
          | (?by: Numeric, ?to: Numeric) { (Float) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Float, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.to_f  ->  self
  # -->
  # Since `float` is already a Float, returns `self`.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - to_i -> integer
  # -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  # Float#to_int is an alias for Float#to_i.
  #
  def to_i: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  # Float#to_int is an alias for Float#to_i.
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - flt.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     2.0.to_r    #=> (2/1)
  #     2.5.to_r    #=> (5/2)
  #     -0.75.to_r  #=> (-3/4)
  #     0.0.to_r    #=> (0/1)
  #     0.3.to_r    #=> (5404319552844595/18014398509481984)
  #
  # NOTE: 0.3.to_r isn't the same as "0.3".to_r.  The latter is equivalent to
  # "3/10".to_r, but the former isn't so.
  #
  #     0.3.to_r   == 3/10r  #=> false
  #     "0.3".to_r == 3/10r  #=> true
  #
  # See also Float#rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s -> string
  # -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  # *   A number in "scientific notation" (containing an exponent).
  # *   'Infinity'.
  # *   '-Infinity'.
  # *   'NaN' (indicating not-a-number).
  #
  #     3.14.to_s         # => "3.14" (10.1**50).to_s   # =>
  #     "1.644631821843879e+50" (10.1**500).to_s  # => "Infinity"
  #     (-10.1**500).to_s # => "-Infinity" (0.0/0.0).to_s    # => "NaN"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> float or integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.truncate(1) # => 12345.6
  #     f.truncate(3) # => 12345.678
  #     f = -12345.6789
  #     f.truncate(1) # => -12345.6
  #     f.truncate(3) # => -12345.678
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.truncate(0)  # => 12345
  #     f.truncate(-3) # => 12000
  #     f = -12345.6789
  #     f.truncate(0)  # => -12345
  #     f.truncate(-3) # => -12000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).truncate  #=> 2 (!)
  #
  # Related: Float#round.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.zero?  ->  true or false
  # -->
  # Returns `true` if `float` is 0.0.
  #
  def zero?: () -> bool
end

# <!-- rdoc-file=numeric.c -->
# The minimum number of significant decimal digits in a double-precision
# floating point.
#
# Usually defaults to 15.
#
Float::DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The difference between 1 and the smallest double-precision floating point
# number greater than 1.
#
# Usually defaults to 2.2204460492503131e-16.
#
Float::EPSILON: Float

# <!-- rdoc-file=numeric.c -->
# An expression representing positive infinity.
#
Float::INFINITY: Float

# <!-- rdoc-file=numeric.c -->
# The number of base digits for the `double` data type.
#
# Usually defaults to 53.
#
Float::MANT_DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible integer in a double-precision floating point number.
#
# Usually defaults to 1.7976931348623157e+308.
#
Float::MAX: Float

# <!-- rdoc-file=numeric.c -->
# The largest positive exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to 308.
#
Float::MAX_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible exponent value in a double-precision floating point.
#
# Usually defaults to 1024.
#
Float::MAX_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest positive normalized number in a double-precision floating point.
#
# Usually defaults to 2.2250738585072014e-308.
#
# If the platform supports denormalized numbers, there are numbers between zero
# and Float::MIN. 0.0.next_float returns the smallest positive floating point
# number including denormalized numbers.
#
Float::MIN: Float

# <!-- rdoc-file=numeric.c -->
# The smallest negative exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to -307.
#
Float::MIN_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest possible exponent value in a double-precision floating point.
#
# Usually defaults to -1021.
#
Float::MIN_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# An expression representing a value which is "not a number".
#
Float::NAN: Float

# <!-- rdoc-file=numeric.c -->
# The base of the floating point, or number of unique digits used to represent
# the number.
#
# Usually defaults to 2 on most systems, which would represent a base-10
# decimal.
#
Float::RADIX: Integer

# Deprecated, do not use.
#
# Represents the rounding mode for floating point addition at the start time.
#
# Usually defaults to 1, rounding to the nearest number.
#
# Other modes include:
#
# -1
# :   Indeterminable
# 0
# :   Rounding towards zero
# 1
# :   Rounding to the nearest number
# 2
# :   Rounding towards positive infinity
# 3
# :   Rounding towards negative infinity
#
#
Float::ROUNDS: Integer

# <!-- rdoc-file=hash.c -->
# ENV is a hash-like accessor for environment variables.
#
# ### Interaction with the Operating System
#
# The ENV object interacts with the operating system's environment variables:
#
# *   When you get the value for a name in ENV, the value is retrieved from
#     among the current environment variables.
# *   When you create or set a name-value pair in ENV, the name and value are
#     immediately set in the environment variables.
# *   When you delete a name-value pair in ENV, it is immediately deleted from
#     the environment variables.
#
#
# ### Names and Values
#
# Generally, a name or value is a String.
#
# #### Valid Names and Values
#
# Each name or value must be one of the following:
#
# *   A String.
# *   An object that responds to #to_str by returning a String, in which case
#     that String will be used as the name or value.
#
#
# #### Invalid Names and Values
#
# A new name:
#
# *   May not be the empty string:
#         ENV[''] = '0'
#         # Raises Errno::EINVAL (Invalid argument - ruby_setenv())
#
# *   May not contain character `"="`:
#         ENV['='] = '0'
#         # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))
#
#
# A new name or value:
#
# *   May not be a non-String that does not respond to #to_str:
#
#         ENV['foo'] = Object.new
#         # Raises TypeError (no implicit conversion of Object into String)
#         ENV[Object.new] = '0'
#         # Raises TypeError (no implicit conversion of Object into String)
#
# *   May not contain the NUL character `"\0"`:
#
#         ENV['foo'] = "\0"
#         # Raises ArgumentError (bad environment variable value: contains null byte)
#         ENV["\0"] == '0'
#         # Raises ArgumentError (bad environment variable name: contains null byte)
#
# *   May not have an ASCII-incompatible encoding such as UTF-16LE or
#     ISO-2022-JP:
#
#         ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
#         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
#         ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
#         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
#
#
# ### About Ordering
#
# ENV enumerates its name/value pairs in the order found in the operating
# system's environment variables. Therefore the ordering of ENV content is
# OS-dependent, and may be indeterminate.
#
# This will be seen in:
# *   A Hash returned by an ENV method.
# *   An Enumerator returned by an ENV method.
# *   An Array returned by ENV.keys, ENV.values, or ENV.to_a.
# *   The String returned by ENV.inspect.
# *   The Array returned by ENV.shift.
# *   The name returned by ENV.key.
#
#
# ### About the Examples
# Some methods in ENV return ENV itself. Typically, there are many environment
# variables. It's not useful to display a large ENV in the examples here, so
# most example snippets begin by resetting the contents of ENV:
# *   ENV.replace replaces ENV with a new collection of entries.
# *   ENV.clear empties ENV.
#
#
# ## What's Here
#
# First, what's elsewhere. Class ENV:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Extends [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here),
#
#
# Here, class ENV provides methods that are useful for:
#
# *   [Querying](#class-ENV-label-Methods+for+Querying)
# *   [Assigning](#class-ENV-label-Methods+for+Assigning)
# *   [Deleting](#class-ENV-label-Methods+for+Deleting)
# *   [Iterating](#class-ENV-label-Methods+for+Iterating)
# *   [Converting](#class-ENV-label-Methods+for+Converting)
# *   [And more ....](#class-ENV-label-More+Methods)
#
#
# ### Methods for Querying
#
#     ::[]
# :       Returns the value for the given environment variable name if it
#         exists:
#
#     ::empty?
# :       Returns whether ENV is empty.
#
#     ::has_value?, ::value?
# :       Returns whether the given value is in ENV.
#
#     ::include?, ::has_key?, ::key?, ::member?
# :       Returns whether the given name is in ENV.
#
#     ::key
# :       Returns the name of the first entry with the given value.
#
#     ::size, ::length
# :       Returns the number of entries.
#
#     ::value?
# :       Returns whether any entry has the given value.
#
#
#
# ### Methods for Assigning
#
#     ::[]=, ::store
# :       Creates, updates, or deletes the named environment variable.
#
#     ::clear
# :       Removes every environment variable; returns ENV:
#
#     ::update, ::merge!
# :       Adds to ENV each key/value pair in the given hash.
#
#     ::replace
# :       Replaces the entire content of the ENV with the name/value pairs in
#         the given hash.
#
#
#
# ### Methods for Deleting
#
#     ::delete
# :       Deletes the named environment variable name if it exists.
#
#     ::delete_if
# :       Deletes entries selected by the block.
#
#     ::keep_if
# :       Deletes entries not selected by the block.
#
#     ::reject!
# :       Similar to #delete_if, but returns `nil` if no change was made.
#
#     ::select!, ::filter!
# :       Deletes entries selected by the block.
#
#     ::shift
# :       Removes and returns the first entry.
#
#
#
# ### Methods for Iterating
#
#     ::each, ::each_pair
# :       Calls the block with each name/value pair.
#
#     ::each_key
# :       Calls the block with each name.
#
#     ::each_value
# :       Calls the block with each value.
#
#
#
# ### Methods for Converting
#
#     ::assoc
# :       Returns a 2-element array containing the name and value of the named
#         environment variable if it exists:
#
#     ::clone
# :       Returns ENV (and issues a warning).
#
#     ::except
# :       Returns a hash of all name/value pairs except those given.
#
#     ::fetch
# :       Returns the value for the given name.
#
#     ::inspect
# :       Returns the contents of ENV as a string.
#
#     ::invert
# :       Returns a hash whose keys are the ENV values, and whose values are the
#         corresponding ENV names.
#
#     ::keys
# :       Returns an array of all names.
#
#     ::rassoc
# :       Returns the name and value of the first found entry that has the given
#         value.
#
#     ::reject
# :       Returns a hash of those entries not rejected by the block.
#
#     ::select, ::filter
# :       Returns a hash of name/value pairs selected by the block.
#
#     ::slice
# :       Returns a hash of the given names and their corresponding values.
#
#     ::to_a
# :       Returns the entries as an array of 2-element Arrays.
#
#     ::to_h
# :       Returns a hash of entries selected by the block.
#
#     ::to_hash
# :       Returns a hash of all entries.
#
#     ::to_s
# :       Returns the string `'ENV'`.
#
#     ::values
# :       Returns all values as an array.
#
#     ::values_at
# :       Returns an array of the values for the given name.
#
#
#
# ### More Methods
#
#     ::dup
# :       Raises an exception.
#
#     ::freeze
# :       Raises an exception.
#
#     ::rehash
# :       Returns `nil`, without modifying ENV.
#
%a{annotate:rdoc:copy:ENV}
class ENVClass
  include Enumerable[[ String, String ]]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] -> value
  # -->
  # Returns the value for the environment variable `name` if it exists:
  #     ENV['foo'] = '0'
  #     ENV['foo'] # => "0"
  #
  # Returns `nil` if the named variable does not exist.
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.[]}
  def []: (String name) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.fetch(name)                  -> value
  #   - ENV.fetch(name, default)         -> value
  #   - ENV.fetch(name) { |name| block } -> value
  # -->
  # If `name` is the name of an environment variable, returns its value:
  #     ENV['foo'] = '0'
  #     ENV.fetch('foo') # => '0'
  #
  # Otherwise if a block is given (but not a default value), yields `name` to the
  # block and returns the block's return value:
  #     ENV.fetch('foo') { |name| :need_not_return_a_string } # => :need_not_return_a_string
  #
  # Otherwise if a default value is given (but not a block), returns the default
  # value:
  #     ENV.delete('foo')
  #     ENV.fetch('foo', :default_need_not_be_a_string) # => :default_need_not_be_a_string
  #
  # If the environment variable does not exist and both default and block are
  # given, issues a warning ("warning: block supersedes default value argument"),
  # yields `name` to the block, and returns the block's return value:
  #     ENV.fetch('foo', :default) { |name| :block_return } # => :block_return
  #
  # Raises KeyError if `name` is valid, but not found, and neither default value
  # nor block is given:
  #     ENV.fetch('foo') # Raises KeyError (key not found: "foo")
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.fetch}
  def fetch: (String name) -> String
           | [X] (String name, X default) -> (String | X)
           | [X] (String name) { (String) -> X } -> (String | X)

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] = value      -> value
  #   - ENV.store(name, value) -> value
  # -->
  # ENV.store is an alias for ENV.[]=.
  #
  # Creates, updates, or deletes the named environment variable, returning the
  # value. Both `name` and `value` may be instances of String. See [Valid Names
  # and Values](#class-ENV-label-Valid+Names+and+Values).
  #
  # *   If the named environment variable does not exist:
  #     *   If `value` is `nil`, does nothing.
  #             ENV.clear
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #     *   If `value` is not `nil`, creates the environment variable with `name`
  #         and `value`:
  #             # Create 'foo' using ENV.[]=.
  #             ENV['foo'] = '0' # => '0'
  #             ENV['foo'] # => '0'
  #             # Create 'bar' using ENV.store.
  #             ENV.store('bar', '1') # => '1'
  #             ENV['bar'] # => '1'
  #
  #
  # *   If the named environment variable exists:
  #     *   If `value` is not `nil`, updates the environment variable with value
  #         `value`:
  #             # Update 'foo' using ENV.[]=.
  #             ENV['foo'] = '2' # => '2'
  #             ENV['foo'] # => '2'
  #             # Update 'bar' using ENV.store.
  #             ENV.store('bar', '3') # => '3'
  #             ENV['bar'] # => '3'
  #
  #     *   If `value` is `nil`, deletes the environment variable:
  #             # Delete 'foo' using ENV.[]=.
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             # Delete 'bar' using ENV.store.
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #
  #
  # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.[]=}
  def []=: (String name, String? value) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] = value      -> value
  #   - ENV.store(name, value) -> value
  # -->
  # ENV.store is an alias for ENV.[]=.
  #
  # Creates, updates, or deletes the named environment variable, returning the
  # value. Both `name` and `value` may be instances of String. See [Valid Names
  # and Values](#class-ENV-label-Valid+Names+and+Values).
  #
  # *   If the named environment variable does not exist:
  #     *   If `value` is `nil`, does nothing.
  #             ENV.clear
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #     *   If `value` is not `nil`, creates the environment variable with `name`
  #         and `value`:
  #             # Create 'foo' using ENV.[]=.
  #             ENV['foo'] = '0' # => '0'
  #             ENV['foo'] # => '0'
  #             # Create 'bar' using ENV.store.
  #             ENV.store('bar', '1') # => '1'
  #             ENV['bar'] # => '1'
  #
  #
  # *   If the named environment variable exists:
  #     *   If `value` is not `nil`, updates the environment variable with value
  #         `value`:
  #             # Update 'foo' using ENV.[]=.
  #             ENV['foo'] = '2' # => '2'
  #             ENV['foo'] # => '2'
  #             # Update 'bar' using ENV.store.
  #             ENV.store('bar', '3') # => '3'
  #             ENV['bar'] # => '3'
  #
  #     *   If `value` is `nil`, deletes the environment variable:
  #             # Delete 'foo' using ENV.[]=.
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             # Delete 'bar' using ENV.store.
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #
  #
  # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.store}
  alias store []=

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each      { |name, value| block } -> ENV
  #   - ENV.each                              -> an_enumerator
  #   - ENV.each_pair { |name, value| block } -> ENV
  #   - ENV.each_pair                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array:
  #     h = {}
  #     ENV.each_pair { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     h = {}
  #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
  #     e.each { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.each}
  def each: () -> ::Enumerator[[ String, String ], self]
          | () { ([ String, String ]) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each      { |name, value| block } -> ENV
  #   - ENV.each                              -> an_enumerator
  #   - ENV.each_pair { |name, value| block } -> ENV
  #   - ENV.each_pair                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array:
  #     h = {}
  #     ENV.each_pair { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     h = {}
  #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
  #     e.each { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.each_pair}
  def each_pair: () -> ::Enumerator[[ String, String ], self]
               | () { ([ String, String ]) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each_key { |name| block } -> ENV
  #   - ENV.each_key                  -> an_enumerator
  # -->
  # Yields each environment variable name:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     names = []
  #     ENV.each_key { |name| names.push(name) } # => ENV
  #     names # => ["bar", "foo"]
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.each_key # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_key>
  #     names = []
  #     e.each { |name| names.push(name) } # => ENV
  #     names # => ["bar", "foo"]
  #
  %a{annotate:rdoc:copy:ENV.each_key}
  def each_key: () -> ::Enumerator[[ String ], self]
              | () { (String name) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each_value { |value| block } -> ENV
  #   - ENV.each_value                   -> an_enumerator
  # -->
  # Yields each environment variable value:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     values = []
  #     ENV.each_value { |value| values.push(value) } # => ENV
  #     values # => ["1", "0"]
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.each_value # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_value>
  #     values = []
  #     e.each { |value| values.push(value) } # => ENV
  #     values # => ["1", "0"]
  #
  %a{annotate:rdoc:copy:ENV.each_value}
  def each_value: () -> ::Enumerator[[ String ], self]
                | () { (String value) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.delete(name)                           -> value
  #   - ENV.delete(name) { |name| block }          -> value
  #   - ENV.delete(missing_name)                   -> nil
  #   - ENV.delete(missing_name) { |name| block }  -> block_value
  # -->
  # Deletes the environment variable with `name` if it exists and returns its
  # value:
  #     ENV['foo'] = '0'
  #     ENV.delete('foo') # => '0'
  #
  # If a block is not given and the named environment variable does not exist,
  # returns `nil`.
  #
  # If a block given and the environment variable does not exist, yields `name` to
  # the block and returns the value of the block:
  #     ENV.delete('foo') { |name| name * 2 } # => "foofoo"
  #
  # If a block given and the environment variable exists, deletes the environment
  # variable and returns its value (ignoring the block):
  #     ENV['foo'] = '0'
  #     ENV.delete('foo') { |name| raise 'ignored' } # => "0"
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.delete}
  def delete: (String name) -> String?
            | (String name) { (String) -> String } -> String

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.delete_if { |name, value| block } -> ENV
  #   - ENV.delete_if                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns a truthy value,
  # and returning ENV (regardless of whether any deletions):
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.delete_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:delete_if!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #
  %a{annotate:rdoc:copy:ENV.delete_if}
  def delete_if: () -> ::Enumerator[[ String, String ], self]
               | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.keep_if { |name, value| block } -> ENV
  #   - ENV.keep_if                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns `false` or
  # `nil`, and returning ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.keep_if { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.keep_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:keep_if>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.keep_if}
  def keep_if: () -> ::Enumerator[[ String, String ], self]
             | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.slice(*names) -> hash of name/value pairs
  # -->
  # Returns a Hash of the given ENV names and their corresponding values:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2', 'bat' => '3')
  #     ENV.slice('foo', 'baz') # => {"foo"=>"0", "baz"=>"2"}
  #     ENV.slice('baz', 'foo') # => {"baz"=>"2", "foo"=>"0"}
  #
  # Raises an exception if any of the `names` is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.slice('foo', 'bar', :bat) # Raises TypeError (no implicit conversion of Symbol into String)
  #
  %a{annotate:rdoc:copy:ENV.slice}
  def slice: (*String names) -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.except(*keys) -> a_hash
  # -->
  # Returns a hash except the given keys from ENV and their values.
  #
  #     ENV                       #=> {"LANG"=>"en_US.UTF-8", "TERM"=>"xterm-256color", "HOME"=>"/Users/rhc"}
  #     ENV.except("TERM","HOME") #=> {"LANG"=>"en_US.UTF-8"}
  #
  %a{annotate:rdoc:copy:ENV.except}
  def except: (*String names) -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.clear -> ENV
  # -->
  # Removes every environment variable; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.size # => 2
  #     ENV.clear # => ENV
  #     ENV.size # => 0
  #
  %a{annotate:rdoc:copy:ENV.clear}
  def clear: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.reject { |name, value| block } -> hash of name/value pairs
  #   - ENV.reject                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array.
  # Returns a Hash whose items are determined by the block. When the block returns
  # a truthy value, the name/value pair is added to the return Hash; otherwise the
  # pair is ignored:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.reject { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.reject
  #     e.each { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.reject}
  def reject: () -> ::Enumerator[[ String, String ], self]
            | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.reject! { |name, value| block } -> ENV or nil
  #   - ENV.reject!                         -> an_enumerator
  # -->
  # Similar to ENV.delete_if, but returns `nil` if no changes were made.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns a truthy value,
  # and returning ENV (if any deletions) or `nil` (if not):
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.reject! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     ENV.reject! { |name, value| name.start_with?('b') } # => nil
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.reject! # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:reject!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     e.each { |name, value| name.start_with?('b') } # => nil
  #
  %a{annotate:rdoc:copy:ENV.reject!}
  def reject!: () -> ::Enumerator[[ String, String ], self?]
             | () { (String name, String value) -> boolish } -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select { |name, value| block } -> hash of name/value pairs
  #   - ENV.select                         -> an_enumerator
  #   - ENV.filter { |name, value| block } -> hash of name/value pairs
  #   - ENV.filter                         -> an_enumerator
  # -->
  # ENV.filter is an alias for ENV.select.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # returning a Hash of the names and values for which the block returns a truthy
  # value:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.select}
  def select: () -> ::Enumerator[[ String, String ], ::Hash[String, String]]
            | () { (String name, String value) -> boolish } -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select { |name, value| block } -> hash of name/value pairs
  #   - ENV.select                         -> an_enumerator
  #   - ENV.filter { |name, value| block } -> hash of name/value pairs
  #   - ENV.filter                         -> an_enumerator
  # -->
  # ENV.filter is an alias for ENV.select.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # returning a Hash of the names and values for which the block returns a truthy
  # value:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.filter}
  alias filter select

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select! { |name, value| block } -> ENV or nil
  #   - ENV.select!                         -> an_enumerator
  #   - ENV.filter! { |name, value| block } -> ENV or nil
  #   - ENV.filter!                         -> an_enumerator
  # -->
  # ENV.filter! is an alias for ENV.select!.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each entry for which the block returns `false` or `nil`, and
  # returning ENV if any deletions made, or `nil` otherwise:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.select! { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter! { |name, value| true } # => nil
  #
  # Returns an Enumerator if no block given:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  %a{annotate:rdoc:copy:ENV.select!}
  def select!: () -> ::Enumerator[[ String, String ], self?]
             | () { (String name, String value) -> boolish } -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select! { |name, value| block } -> ENV or nil
  #   - ENV.select!                         -> an_enumerator
  #   - ENV.filter! { |name, value| block } -> ENV or nil
  #   - ENV.filter!                         -> an_enumerator
  # -->
  # ENV.filter! is an alias for ENV.select!.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each entry for which the block returns `false` or `nil`, and
  # returning ENV if any deletions made, or `nil` otherwise:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.select! { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter! { |name, value| true } # => nil
  #
  # Returns an Enumerator if no block given:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  %a{annotate:rdoc:copy:ENV.filter!}
  alias filter! select!

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.shift -> [name, value] or nil
  # -->
  # Removes the first environment variable from ENV and returns a 2-element Array
  # containing its name and value:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_hash # => {'bar' => '1', 'foo' => '0'}
  #     ENV.shift # => ['bar', '1']
  #     ENV.to_hash # => {'foo' => '0'}
  #
  # Exactly which environment variable is "first" is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if the environment is empty.
  #
  %a{annotate:rdoc:copy:ENV.shift}
  def shift: () -> [ String, String ]?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.invert -> hash of value/name pairs
  # -->
  # Returns a Hash whose keys are the ENV values, and whose values are the
  # corresponding ENV names:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.invert # => {"1"=>"bar", "0"=>"foo"}
  #
  # For a duplicate ENV value, overwrites the hash entry:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.invert # => {"0"=>"foo"}
  #
  # Note that the order of the ENV processing is OS-dependent, which means that
  # the order of overwriting is also OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  %a{annotate:rdoc:copy:ENV.invert}
  def invert: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.replace(hash) -> ENV
  # -->
  # Replaces the entire content of the environment variables with the name/value
  # pairs in the given `hash`; returns ENV.
  #
  # Replaces the content of ENV with the given pairs:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.replace('foo' => '0', :bar => '1') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV.replace('foo' => '0', 'bar' => 1) # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.replace}
  def replace: (Hash[String, String]) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.update(hash)                                     -> ENV
  #   - ENV.update(hash) { |name, env_val, hash_val| block } -> ENV
  #   - ENV.merge!(hash)                                     -> ENV
  #   - ENV.merge!(hash) { |name, env_val, hash_val| block } -> ENV
  # -->
  # ENV.update is an alias for ENV.merge!.
  #
  # Adds to ENV each key/value pair in the given `hash`; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
  #
  # Deletes the ENV entry for a hash value that is `nil`:
  #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
  #
  # For an already-existing name, if no block given, overwrites the ENV value:
  #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
  #
  # For an already-existing name, if block given, yields the name, its ENV value,
  # and its hash value; the block's return value becomes the new name:
  #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values));
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV # => {"bar"=>"1", "foo"=>"6"}
  #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "foo"=>"7"}
  #
  # Raises an exception if the block returns an invalid name: (see [Invalid Names
  # and Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
  #
  # Note that for the exceptions above, hash pairs preceding an invalid name or
  # value are processed normally; those following are ignored.
  #
  %a{annotate:rdoc:copy:ENV.update}
  def update: (Hash[String, String?]) -> self
            | (Hash[String, String?]) { (String name, String env_val, String? hash_val) -> String } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.update(hash)                                     -> ENV
  #   - ENV.update(hash) { |name, env_val, hash_val| block } -> ENV
  #   - ENV.merge!(hash)                                     -> ENV
  #   - ENV.merge!(hash) { |name, env_val, hash_val| block } -> ENV
  # -->
  # ENV.update is an alias for ENV.merge!.
  #
  # Adds to ENV each key/value pair in the given `hash`; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
  #
  # Deletes the ENV entry for a hash value that is `nil`:
  #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
  #
  # For an already-existing name, if no block given, overwrites the ENV value:
  #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
  #
  # For an already-existing name, if block given, yields the name, its ENV value,
  # and its hash value; the block's return value becomes the new name:
  #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values));
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV # => {"bar"=>"1", "foo"=>"6"}
  #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "foo"=>"7"}
  #
  # Raises an exception if the block returns an invalid name: (see [Invalid Names
  # and Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
  #
  # Note that for the exceptions above, hash pairs preceding an invalid name or
  # value are processed normally; those following are ignored.
  #
  %a{annotate:rdoc:copy:ENV.merge!}
  alias merge! update

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.rehash -> nil
  # -->
  # (Provided for compatibility with Hash.)
  #
  # Does not modify ENV; returns `nil`.
  #
  %a{annotate:rdoc:copy:ENV.rehash}
  def rehash: () -> nil

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_a -> array of 2-element arrays
  # -->
  # Returns the contents of ENV as an Array of 2-element Arrays, each of which is
  # a name/value pair:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_a # => [["bar", "1"], ["foo", "0"]]
  #
  %a{annotate:rdoc:copy:ENV.to_a}
  def to_a: () -> ::Array[[ String, String ]]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_s -> "ENV"
  # -->
  # Returns String 'ENV':
  #     ENV.to_s # => "ENV"
  #
  %a{annotate:rdoc:copy:ENV.to_s}
  def to_s: () -> "ENV"

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.key(value) -> name or nil
  # -->
  # Returns the name of the first environment variable with `value`, if it exists:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.key('0') # => "foo"
  #
  # The order in which environment variables are examined is OS-dependent. See
  # [About Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if there is no such value.
  #
  # Raises an exception if `value` is invalid:
  #     ENV.key(Object.new) # raises TypeError (no implicit conversion of Object into String)
  #
  # See [Invalid Names and Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.key}
  def key: (String value) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.length -> an_integer
  #   - ENV.size   -> an_integer
  # -->
  # Returns the count of environment variables:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.length # => 2
  #     ENV.size # => 2
  #
  %a{annotate:rdoc:copy:ENV.size}
  def size: () -> Integer

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.length -> an_integer
  #   - ENV.size   -> an_integer
  # -->
  # Returns the count of environment variables:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.length # => 2
  #     ENV.size # => 2
  #
  %a{annotate:rdoc:copy:ENV.length}
  alias length size

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.empty? -> true or false
  # -->
  # Returns `true` when there are no environment variables, `false` otherwise:
  #     ENV.clear
  #     ENV.empty? # => true
  #     ENV['foo'] = '0'
  #     ENV.empty? # => false
  #
  %a{annotate:rdoc:copy:ENV.empty?}
  def empty?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.keys -> array of names
  # -->
  # Returns all variable names in an Array:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.keys # => ['bar', 'foo']
  #
  # The order of the names is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns the empty Array if ENV is empty.
  #
  %a{annotate:rdoc:copy:ENV.keys}
  def keys: () -> ::Array[String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.values -> array of values
  # -->
  # Returns all environment variable values in an Array:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.values # => ['1', '0']
  #
  # The order of the values is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns the empty Array if ENV is empty.
  #
  %a{annotate:rdoc:copy:ENV.values}
  def values: () -> ::Array[String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.values_at(*names) -> array of values
  # -->
  # Returns an Array containing the environment variable values associated with
  # the given names:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.values_at('foo', 'baz') # => ["0", "2"]
  #
  # Returns `nil` in the Array for each name that is not an ENV name:
  #     ENV.values_at('foo', 'bat', 'bar', 'bam') # => ["0", nil, "1", nil]
  #
  # Returns an empty Array if no names given.
  #
  # Raises an exception if any name is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.values_at}
  def values_at: (*String names) -> ::Array[String?]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.include?}
  def include?: (String name) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.member?}
  alias member? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.has_key?}
  alias has_key? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.value?(value)     -> true or false
  #   - ENV.has_value?(value) -> true or false
  # -->
  # Returns `true` if `value` is the value for some environment variable name,
  # `false` otherwise:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.value?('0') # => true
  #     ENV.has_value?('0') # => true
  #     ENV.value?('2') # => false
  #     ENV.has_value?('2') # => false
  #
  %a{annotate:rdoc:copy:ENV.has_value?}
  def has_value?: (String value) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.value?(value)     -> true or false
  #   - ENV.has_value?(value) -> true or false
  # -->
  # Returns `true` if `value` is the value for some environment variable name,
  # `false` otherwise:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.value?('0') # => true
  #     ENV.has_value?('0') # => true
  #     ENV.value?('2') # => false
  #     ENV.has_value?('2') # => false
  #
  %a{annotate:rdoc:copy:ENV.value?}
  alias value? has_value?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.key?}
  alias key? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_hash -> hash of name/value pairs
  # -->
  # Returns a Hash containing all name/value pairs from ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.to_hash}
  def to_hash: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.assoc(name) -> [name, value] or nil
  # -->
  # Returns a 2-element Array containing the name and value of the environment
  # variable for `name` if it exists:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.assoc('foo') # => ['foo', '0']
  #
  # Returns `nil` if `name` is a valid String and there is no such environment
  # variable.
  #
  # Returns `nil` if `name` is the empty String or is a String containing
  # character `'='`.
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.assoc("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.assoc("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.assoc(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.assoc}
  def assoc: (String name) -> [ String, String ]?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.rassoc(value) -> [name, value] or nil
  # -->
  # Returns a 2-element Array containing the name and value of the **first**
  # **found** environment variable that has value `value`, if one exists:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.rassoc('0') # => ["bar", "0"]
  #
  # The order in which environment variables are examined is OS-dependent. See
  # [About Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if there is no such environment variable.
  #
  %a{annotate:rdoc:copy:ENV.rassoc}
  def rassoc: (String value) -> [ String, String ]?
end

# <!-- rdoc-file=hash.c -->
# ENV is a Hash-like accessor for environment variables.
#
# See ENV (the class) for more details.
#
ENV: ENVClass

interface _ToI
  def to_i: () -> Integer
end

interface _ToInt
  def to_int: () -> Integer
end

interface _ToR
  def to_r: () -> Rational
end

interface _ToS
  def to_s: () -> String
end

interface _ToStr
  def to_str: () -> String
end

interface _ToHash[K, V]
  def to_hash: () -> Hash[K, V]
end

interface _ToProc
  def to_proc: () -> untyped
end

interface _ToPath
  def to_path: () -> String
end

interface _Each[out A]
  def each: () { (A) -> void } -> void
end

interface _Reader
  def read: (?int? length, ?string outbuf) -> String?
end

interface _ReaderPartial
  def readpartial: (int maxlen, ?string outbuf) -> String
end

interface _Writer
  # Writes the +data+ string. Returns the number of bytes written
  def write: (*_ToS data) -> Integer
end

interface _Rewindable
  # Positions the stream to the beginning of input, resetting `lineno` to zero.
  #
  def rewind: () -> Integer
end

interface _ToIO
  def to_io: () -> IO
end

interface _Exception
  def exception: () -> Exception
               | (String arg0) -> Exception
end

type int = Integer | _ToInt
type real = Integer | Float | Rational

type string = String | _ToStr
type encoding = Encoding | string

type io = IO | _ToIO

# `boolish` is a type for documentation.
# It means the value of this type is only for testing a condition.
# Unlike `bool` type, it doesn't require the value is one of `true` or `false`.
# Any Ruby object can have `boolish` type.
#
type boolish = top

# <!-- rdoc-file=string.c -->
# Symbol objects represent named identifiers inside the Ruby interpreter.
#
# You can create a Symbol object explicitly with:
#
# *   A [symbol literal](doc/syntax/literals_rdoc.html#label-Symbol+Literals).
#
#
# The same Symbol object will be created for a given name or string for the
# duration of a program's execution, regardless of the context or meaning of
# that name. Thus if `Fred` is a constant in one context, a method in another,
# and a class in a third, the Symbol `:Fred` will be the same object in all
# three contexts.
#
#     module One
#       class Fred
#       end
#       $f1 = :Fred
#     end
#     module Two
#       Fred = 1
#       $f2 = :Fred
#     end
#     def Fred()
#     end
#     $f3 = :Fred
#     $f1.object_id   #=> 2514190
#     $f2.object_id   #=> 2514190
#     $f3.object_id   #=> 2514190
#
# Constant, method, and variable names are returned as symbols:
#
#     module One
#       Two = 2
#       def three; 3 end
#       @four = 4
#       @@five = 5
#       $six = 6
#     end
#     seven = 7
#
#     One.constants
#     # => [:Two]
#     One.instance_methods(true)
#     # => [:three]
#     One.instance_variables
#     # => [:@four]
#     One.class_variables
#     # => [:@@five]
#     global_variables.grep(/six/)
#     # => [:$six]
#     local_variables
#     # => [:seven]
#
# Symbol objects are different from String objects in that Symbol objects
# represent identifiers, while String objects represent text or data.
#
# ## What's Here
#
# First, what's elsewhere. Class Symbol:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Symbol provides methods that are useful for:
#
# *   [Querying](#class-Symbol-label-Methods+for+Querying)
# *   [Comparing](#class-Symbol-label-Methods+for+Comparing)
# *   [Converting](#class-Symbol-label-Methods+for+Converting)
#
#
# ### Methods for Querying
#
#     ::all_symbols
# :       Returns an array of the symbols currently in Ruby's symbol table.
#
#     [#=~](#method-i-3D~)
# :       Returns the index of the first substring in symbol that matches a
#         given Regexp or other object; returns `nil` if no match is found.
#
#     #[], #slice
# :       Returns a substring of symbol determined by a given index,
#         start/length, or range, or string.
#
#     #empty?
# :       Returns `true` if `self.length` is zero; `false` otherwise.
#
#     #encoding
# :       Returns the Encoding object that represents the encoding of symbol.
#
#     #end_with?
# :       Returns `true` if symbol ends with any of the given strings.
#
#     #match
# :       Returns a MatchData object if symbol matches a given Regexp; `nil`
#         otherwise.
#
#     #match?
# :       Returns `true` if symbol matches a given Regexp; `false` otherwise.
#
#     #length, #size
# :       Returns the number of characters in symbol.
#
#     #start_with?
# :       Returns `true` if symbol starts with any of the given strings.
#
#
#
# ### Methods for Comparing
#
#     [#<=>](#method-i-3C-3D-3E)
# :       Returns -1, 0, or 1 as a given symbol is smaller than, equal to, or
#         larger than symbol.
#
#     [#==, #===](#method-i-3D-3D)
# :       Returns `true` if a given symbol has the same content and encoding.
#
#     #casecmp
# :       Ignoring case, returns -1, 0, or 1 as a given symbol is smaller than,
#         equal to, or larger than symbol.
#
#     #casecmp?
# :       Returns `true` if symbol is equal to a given symbol after Unicode case
#         folding; `false` otherwise.
#
#
#
# ### Methods for Converting
#
#     #capitalize
# :       Returns symbol with the first character upcased and all other
#         characters downcased.
#
#     #downcase
# :       Returns symbol with all characters downcased.
#
#     #inspect
# :       Returns the string representation of `self` as a symbol literal.
#
#     #name
# :       Returns the frozen string corresponding to symbol.
#
#     #succ, #next
# :       Returns the symbol that is the successor to symbol.
#
#     #swapcase
# :       Returns symbol with all upcase characters downcased and all downcase
#         characters upcased.
#
#     #to_proc
# :       Returns a Proc object which responds to the method named by symbol.
#
#     #to_s, #id2name
# :       Returns the string corresponding to `self`.
#
#     #to_sym, #intern
# :       Returns `self`.
#
#     #upcase
# :       Returns symbol with all characters upcased.
#
class Symbol
  include Comparable

  # <!--
  #   rdoc-file=string.c
  #   - Symbol.all_symbols    => array
  # -->
  # Returns an array of all the symbols currently in Ruby's symbol table.
  #
  #     Symbol.all_symbols.size    #=> 903
  #     Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink,
  #                                     :chown, :EOFError, :$;, :String,
  #                                     :LOCK_SH, :"setuid?", :$<,
  #                                     :default_proc, :compact, :extend,
  #                                     :Tms, :getwd, :$=, :ThreadGroup,
  #                                     :wait2, :$>]
  #
  def self.all_symbols: () -> ::Array[Symbol]

  public

  # <!--
  #   rdoc-file=string.c
  #   - symbol <=> other_symbol       -> -1, 0, +1, or nil
  # -->
  # Compares `symbol` with `other_symbol` after calling #to_s on each of the
  # symbols. Returns -1, 0, +1, or `nil` depending on whether `symbol` is less
  # than, equal to, or greater than `other_symbol`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  # See String#<=> for more information.
  #
  def <=>: (Symbol other) -> Integer
         | (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - sym == obj   -> true or false
  # -->
  # Equality---If *sym* and *obj* are exactly the same symbol, returns `true`.
  #
  def ==: (untyped obj) -> bool

  # <!-- rdoc-file=string.c -->
  # Equality---If *sym* and *obj* are exactly the same symbol, returns `true`.
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym =~ obj   -> integer or nil
  # -->
  # Returns `sym.to_s =~ obj`.
  #
  def =~: (untyped obj) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - sym[idx]      -> char
  #   - sym[b, n]     -> string
  #   - sym.slice(idx)      -> char
  #   - sym.slice(b, n)     -> string
  # -->
  # Returns `sym.to_s[]`.
  #
  def []: (int index) -> String?
        | (int start, int length) -> String?
        | (Range[Integer?] range) -> String?
        | (Regexp regexp) -> String?
        | (Regexp regexp, int | String capture) -> String?
        | (String match_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.capitalize.to_sym`.
  #
  # See String#capitalize.
  #
  def capitalize: () -> Symbol
                | (:ascii | :lithuanian | :turkic) -> Symbol
                | (:lithuanian, :turkic) -> Symbol
                | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(other_symbol) -> -1, 0, 1, or nil
  # -->
  # Case-insensitive version of [Symbol#<=>](#method-i-3C-3D-3E):
  #
  #     :aBcDeF.casecmp(:abcde)   # => 1
  #     :aBcDeF.casecmp(:abcdef)  # => 0
  #     :aBcDeF.casecmp(:abcdefg) # => -1
  #     :abcdef.casecmp(:ABCDEF)  # => 0
  #
  # Returns `nil` if the two symbols have incompatible encodings, or if
  # `other_symbol` is not a symbol:
  #
  #     sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
  #     other_sym = :"\u{c4 d6 dc}"
  #     sym.casecmp(other_sym) # => nil
  #     :foo.casecmp(2)        # => nil
  #
  # Currently, case-insensitivity only works on characters A-Z/a-z, not all of
  # Unicode. This is different from Symbol#casecmp?.
  #
  # Related: Symbol#casecmp?.
  #
  def casecmp: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(other_symbol) -> true, false, or nil
  # -->
  # Returns `true` if `sym` and `other_symbol` are equal after Unicode case
  # folding, `false` if they are not equal:
  #
  #     :aBcDeF.casecmp?(:abcde)                  # => false
  #     :aBcDeF.casecmp?(:abcdef)                 # => true
  #     :aBcDeF.casecmp?(:abcdefg)                # => false
  #     :abcdef.casecmp?(:ABCDEF)                 # => true
  #     :"\u{e4 f6 fc}".casecmp?(:"\u{c4 d6 dc}") #=> true
  #
  # Returns `nil` if the two symbols have incompatible encodings, or if
  # `other_symbol` is not a symbol:
  #
  #     sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
  #     other_sym = :"\u{c4 d6 dc}"
  #     sym.casecmp?(other_sym) # => nil
  #     :foo.casecmp?(2)        # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: Symbol#casecmp.
  #
  def casecmp?: (untyped other) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.downcase.to_sym`.
  #
  # See String#downcase.
  #
  # Related: Symbol#upcase.
  #
  def downcase: () -> Symbol
              | (:ascii | :fold | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.empty?   -> true or false
  # -->
  # Returns whether *sym* is :"" or not.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of *sym*.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - sym.end_with?([suffixes]+)   -> true or false
  # -->
  # Returns true if `sym` ends with one of the `suffixes` given.
  #
  #     :hello.end_with?("ello")               #=> true
  #
  #     # returns true if one of the +suffixes+ matches.
  #     :hello.end_with?("heaven", "ello")     #=> true
  #     :hello.end_with?("heaven", "paradise") #=> false
  #
  def end_with?: (*string suffixes) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns the name or string corresponding to *sym*.
  #
  #     :fred.id2name   #=> "fred"
  #     :ginger.to_s    #=> "ginger"
  #
  # Note that this string is not frozen (unlike the symbol itself). To get a
  # frozen string, use #name.
  #
  def id2name: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - sym.inspect    -> string
  # -->
  # Returns the representation of *sym* as a symbol literal.
  #
  #     :fred.inspect   #=> ":fred"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - sym.to_sym   -> sym
  #   - sym.intern   -> sym
  # -->
  # In general, `to_sym` returns the Symbol corresponding to an object. As *sym*
  # is already a symbol, `self` is returned in this case.
  #
  def intern: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.length   -> integer
  #   - sym.size     -> integer
  # -->
  # Same as `sym.to_s.length`.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - sym.match(pattern)        -> matchdata or nil
  #   - sym.match(pattern, pos)   -> matchdata or nil
  # -->
  # Returns `sym.to_s.match`.
  #
  def match: (Regexp | string pattern, ?int pos) -> MatchData?
           | (Regexp | string pattern, ?int pos) { (MatchData) -> void } -> untyped

  # <!--
  #   rdoc-file=string.c
  #   - sym.match?(pattern)        -> true or false
  #   - sym.match?(pattern, pos)   -> true or false
  # -->
  # Returns `sym.to_s.match?`.
  #
  def match?: (Regexp | string pattern, ?int pos) -> bool

  # <!-- rdoc-file=string.c -->
  # Same as `sym.to_s.succ.intern`.
  #
  def next: () -> Symbol

  # <!-- rdoc-file=string.c -->
  # Same as `sym.to_s.length`.
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Returns `sym.to_s[]`.
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - sym.start_with?([prefixes]+)   -> true or false
  # -->
  # Returns true if `sym` starts with one of the `prefixes` given. Each of the
  # `prefixes` should be a String or a Regexp.
  #
  #     :hello.start_with?("hell")               #=> true
  #     :hello.start_with?(/H/i)                 #=> true
  #
  #     # returns true if one of the prefixes matches.
  #     :hello.start_with?("heaven", "hell")     #=> true
  #     :hello.start_with?("heaven", "paradise") #=> false
  #
  def start_with?: (*string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym.succ
  # -->
  # Same as `sym.to_s.succ.intern`.
  #
  alias succ next

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.swapcase.to_sym`.
  #
  # See String#swapcase.
  #
  def swapcase: () -> Symbol
              | (:ascii | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.to_proc
  # -->
  # Returns a *Proc* object which responds to the given method by *sym*.
  #
  #     (1..3).collect(&:to_s)  #=> ["1", "2", "3"]
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=string.c
  #   - sym.id2name   -> string
  #   - sym.to_s      -> string
  # -->
  # Returns the name or string corresponding to *sym*.
  #
  #     :fred.id2name   #=> "fred"
  #     :ginger.to_s    #=> "ginger"
  #
  # Note that this string is not frozen (unlike the symbol itself). To get a
  # frozen string, use #name.
  #
  alias to_s id2name

  # <!-- rdoc-file=string.c -->
  # In general, `to_sym` returns the Symbol corresponding to an object. As *sym*
  # is already a symbol, `self` is returned in this case.
  #
  alias to_sym intern

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.upcase.to_sym`.
  #
  # See String#upcase.
  #
  def upcase: () -> Symbol
            | (:ascii | :lithuanian | :turkic) -> Symbol
            | (:lithuanian, :turkic) -> Symbol
            | (:turkic, :lithuanian) -> Symbol

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=file.c -->
# FileTest implements file test operations similar to those used in File::Stat.
# It exists as a standalone module, and its methods are also insinuated into the
# File class. (Note that this is not done by inclusion: the interpreter cheats).
#
module FileTest
  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a block device.
  #
  # *file_name* can be an IO object.
  #
  def self?.blockdev?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a character device.
  #
  # *file_name* can be an IO object.
  #
  def self?.chardev?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def self?.directory?: (String | IO file_name) -> bool

  # <!-- rdoc-file=file.c -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self?.empty?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self?.executable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self?.executable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self?.exist?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self?.file?: (String | IO file) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self?.grpowned?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self?.identical?: (String | IO file_1, String | IO file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self?.owned?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a pipe.
  #
  # *file_name* can be an IO object.
  #
  def self?.pipe?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self?.readable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self?.readable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setgid?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setuid?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self?.size: (String | IO file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self?.size?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a socket.
  #
  # *file_name* can be an IO object.
  #
  def self?.socket?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.sticky?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a symbolic link.
  #
  def self?.symlink?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self?.world_readable?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self?.world_writable?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self?.writable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self?.writable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self?.zero?: (String | IO file_name) -> bool
end

# The Exception object set by Kernel#raise.
$!: Exception | nil

# The array contains the module names loaded by require.
$": Array[String]

# The process number of the Ruby running this script. Same as Process.pid.
$$: Integer

# The string matched by the last successful match.
$&: String | nil

# The string to the right of the last successful match.
$': String | nil

# The same as ARGV.
$*: Array[String]

# The highest group matched by the last successful match.
$+: String | nil

# The output field separator for Kernel#print and Array#join. Non-nil $, will be deprecated.
$,: String | nil

# The input record separator, newline by default.
$-0: String | nil

# The default separator for String#split. Non-nil $; will be deprecated.
$-F: Regexp | String | nil

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$-I: Array[String]

$-W: 0 | 1 | 2

# True if option <tt>-a</tt> is set. Read-only variable.
$-a: bool

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output.
$-d: bool

# In in-place-edit mode, this variable holds the extension, otherwise +nil+.
$-i: String?

# True if option <tt>-l</tt> is set. Read-only variable.
$-l: bool

# True if option <tt>-p</tt> is set. Read-only variable.
$-p: bool

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-v: bool | nil

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-w: bool | nil

# The current input line number of the last file that was read.
$.: Integer

# The input record separator, newline by default. Aliased to $-0.
$/: String | nil

# Contains the name of the script being executed. May be assignable.
$0: String

# The Nth group of the last successful match. May be > 1.
$1: String | nil

# The Nth group of the last successful match. May be > 1.
$2: String | nil

# The Nth group of the last successful match. May be > 1.
$3: String | nil

# The Nth group of the last successful match. May be > 1.
$4: String | nil

# The Nth group of the last successful match. May be > 1.
$5: String | nil

# The Nth group of the last successful match. May be > 1.
$6: String | nil

# The Nth group of the last successful match. May be > 1.
$7: String | nil

# The Nth group of the last successful match. May be > 1.
$8: String | nil

# The Nth group of the last successful match. May be > 1.
$9: String | nil

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$:: Array[String]

# The default separator for String#split. Non-nil $; will be deprecated. Aliased to $-F.
$;: Regexp | String | nil

# The same as ARGF.
$<: IO

# This variable is no longer effective. Deprecated.
$=: bool

# The default output stream for Kernel#print and Kernel#printf. $stdout by default.
$>: IO

# The status of the last executed child process (thread-local).
$?: Process::Status | nil

# The same as <code>$!.backtrace</code>.
$@: Array[String] | nil

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output. Aliased to $-d.
$DEBUG: bool

# Current input filename from ARGF. Same as ARGF.filename.
$FILENAME: String

# The array contains the module names loaded by require.
$LOADED_FEATURES: Array[String]

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require. Aliased to $: and $-I.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$LOAD_PATH: Array[String] & _LoadPathAPI

interface _LoadPathAPI
  def resolve_feature_path: (String) -> [:rb | :so, String]?
end

# Contains the name of the script being executed. May be assignable.
$PROGRAM_NAME: String

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn. Aliased to $-v and $-w.
$VERBOSE: bool | nil

# The output record separator for Kernel#print and IO#write. Default is +nil+.
$\: String | nil

# The last input line of string by gets or readline.
$_: String | nil

# The string to the left of the last successful match.
$`: String | nil

# The current standard error output.
$stderr: IO

# The current standard input.
$stdin: IO

# The current standard output.
$stdout: IO

# The information about the last match in the current scope (thread-local and frame-local).
$~: MatchData | nil

# <!-- rdoc-file=range.c -->
# A Range object represents a collection of values that are between given begin
# and end values.
#
# You can create an Range object explicitly with:
#
# *   A [range literal](doc/syntax/literals_rdoc.html#label-Range+Literals):
#
#         # Ranges that use '..' to include the given end value.
#         (1..4).to_a      # => [1, 2, 3, 4]
#         ('a'..'d').to_a  # => ["a", "b", "c", "d"]
#         # Ranges that use '...' to exclude the given end value.
#         (1...4).to_a     # => [1, 2, 3]
#         ('a'...'d').to_a # => ["a", "b", "c"]
#
#
# A range may be created using method Range.new:
#
#     # Ranges that by default include the given end value.
#     Range.new(1, 4).to_a     # => [1, 2, 3, 4]
#     Range.new('a', 'd').to_a # => ["a", "b", "c", "d"]
#     # Ranges that use third argument +exclude_end+ to exclude the given end value.
#     Range.new(1, 4, true).to_a     # => [1, 2, 3]
#     Range.new('a', 'd', true).to_a # => ["a", "b", "c"]
#
# ## Beginless Ranges
#
# A *beginless* *range* has a definite end value, but a `nil` begin value. Such
# a range includes all values up to the end value.
#
#     r = (..4)               # => nil..4
#     r.begin                 # => nil
#     r.include?(-50)         # => true
#     r.include?(4)           # => true
#
#     r = (...4)              # => nil...4
#     r.include?(4)           # => false
#
#     Range.new(nil, 4)       # => nil..4
#     Range.new(nil, 4, true) # => nil...4
#
# A beginless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     r = (..2) # => nil...2
#     a[r]      # => [1, 2]
#
# Method `each` for a beginless range raises an exception.
#
# ## Endless Ranges
#
# An *endless* *range* has a definite begin value, but a `nil` end value. Such a
# range includes all values from the begin value.
#
#     r = (1..)         # => 1..
#     r.end             # => nil
#     r.include?(50)    # => true
#
#     Range.new(1, nil) # => 1..
#
# The literal for  an endless range may be written with either two dots or
# three. The range has the same elements, either way. But note that the two are
# not equal:
#
#     r0 = (1..)           # => 1..
#     r1 = (1...)          # => 1...
#     r0.begin == r1.begin # => true
#     r0.end == r1.end     # => true
#     r0 == r1             # => false
#
# An endless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     r = (2..) # => 2..
#     a[r]      # => [3, 4]
#
# Method `each` for an endless range calls the given block indefinitely:
#
#     a = []
#     r = (1..)
#     r.each do |i|
#       a.push(i) if i.even?
#       break if i > 10
#     end
#     a # => [2, 4, 6, 8, 10]
#
# ## Ranges and Other Classes
#
# An object may be put into a range if its class implements instance method
# `<=>`. Ruby core classes that do so include Array, Complex, File::Stat, Float,
# Integer, Kernel, Module, Numeric, Rational, String, Symbol, and Time.
#
# Example:
#
#     t0 = Time.now         # => 2021-09-19 09:22:48.4854986 -0500
#     t1 = Time.now         # => 2021-09-19 09:22:56.0365079 -0500
#     t2 = Time.now         # => 2021-09-19 09:23:08.5263283 -0500
#     (t0..t2).include?(t1) # => true
#     (t0..t1).include?(t2) # => false
#
# A range can be iterated over only if its elements implement instance method
# `succ`. Ruby core classes that do so include Integer, String, and Symbol (but
# not the other classes mentioned above).
#
# Iterator methods include:
#
# *   In Range itself: #each, #step, and #%
# *   Included from module Enumerable: #each_entry, #each_with_index,
#     #each_with_object, #each_slice, #each_cons, and #reverse_each.
#
#
# Example:
#
#     a = []
#     (1..4).each {|i| a.push(i) }
#     a # => [1, 2, 3, 4]
#
# ## Ranges and User-Defined Classes
#
# A user-defined class that is to be used in a range must implement instance
# `<=>`; see [Integer#<=>](Integer.html#label-method-i-3C-3D-3E). To make
# iteration available, it must also implement instance method `succ`; see
# Integer#succ.
#
# The class below implements both `<=>` and `succ`, and so can be used both to
# construct ranges and to iterate over them. Note that the Comparable module is
# included so the `==` method is defined in terms of `<=>`.
#
#     # Represent a string of 'X' characters.
#     class Xs
#       include Comparable
#       attr_accessor :length
#       def initialize(n)
#         @length = n
#       end
#       def succ
#         Xs.new(@length + 1)
#       end
#       def <=>(other)
#         @length <=> other.length
#       end
#       def to_s
#         sprintf "%2d #{inspect}", @length
#       end
#       def inspect
#         'X' * @length
#       end
#     end
#
#     r = Xs.new(3)..Xs.new(6) #=> XXX..XXXXXX
#     r.to_a                   #=> [XXX, XXXX, XXXXX, XXXXXX]
#     r.include?(Xs.new(5))    #=> true
#     r.include?(Xs.new(7))    #=> false
#
# ## What's Here
#
# First, what's elsewhere. Class Range:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Range provides methods that are useful for:
#
# *   [Creating a Range](#class-Range-label-Methods+for+Creating+a+Range)
# *   [Querying](#class-Range-label-Methods+for+Querying)
# *   [Comparing](#class-Range-label-Methods+for+Comparing)
# *   [Iterating](#class-Range-label-Methods+for+Iterating)
# *   [Converting](#class-Range-label-Methods+for+Converting)
#
#
# ### Methods for Creating a Range
#
#     ::new
# :       Returns a new range.
#
#
#
# ### Methods for Querying
#
#     #begin
# :       Returns the begin value given for `self`.
#
#     #bsearch
# :       Returns an element from `self` selected by a binary search.
#
#     #count
# :       Returns a count of elements in `self`.
#
#     #end
# :       Returns the end value given for `self`.
#
#     #exclude_end?
# :       Returns whether the end object is excluded.
#
#     #first
# :       Returns the first elements of `self`.
#
#     #hash
# :       Returns the integer hash code.
#
#     #last
# :       Returns the last elements of `self`.
#
#     #max
# :       Returns the maximum values in `self`.
#
#     #min
# :       Returns the minimum values in `self`.
#
#     #minmax
# :       Returns the minimum and maximum values in `self`.
#
#     #size
# :       Returns the count of elements in `self`.
#
#
#
# ### Methods for Comparing
#
#     [#==](#method-i-3D-3D)
# :       Returns whether a given object is equal to `self` (uses #==).
#
#     #===
# :       Returns whether the given object is between the begin and end values.
#
#     #cover?
# :       Returns whether a given object is within `self`.
#
#     #eql?
# :       Returns whether a given object is equal to `self` (uses #eql?).
#
#     #include? (aliased as #member?)
# :       Returns whether a given object is an element of `self`.
#
#
#
# ### Methods for Iterating
#
#     #%
# :       Requires argument `n`; calls the block with each `n`-th element of
#         `self`.
#
#     #each
# :       Calls the block with each element of `self`.
#
#     #step
# :       Takes optional argument `n` (defaults to 1); calls the block with each
#         `n`-th element of `self`.
#
#
#
# ### Methods for Converting
#
#     #inspect
# :       Returns a string representation of `self` (uses #inspect).
#
#     #to_a (aliased as #entries)
# :       Returns elements of `self` in an array.
#
#     #to_s
# :       Returns a string representation of `self` (uses #to_s).
#
class Range[out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin == self.begin`.
  # *   `other.end == self.end`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r == (1..5)                # => true
  #     r = Range.new(1, 5)
  #     r == 'foo'                 # => false
  #     r == (2..5)                # => false
  #     r == (1..4)                # => false
  #     r == (1...5)               # => false
  #     r == Range.new(1, 5, true) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#eql?.
  #
  def ==: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self === object ->  true or false
  # -->
  # Returns `true` if `object` is between `self.begin` and `self.end`. `false`
  # otherwise:
  #
  #     (1..4) === 2       # => true
  #     (1..4) === 5       # => false
  #     (1..4) === 'a'     # => false
  #     (1..4) === 4       # => true
  #     (1...4) === 4      # => false
  #     ('a'..'d') === 'c' # => true
  #     ('a'..'d') === 'e' # => false
  #
  # A case statement uses method `===`, and so:
  #
  #     case 79
  #     when (1..50)
  #       "low"
  #     when (51..75)
  #       "medium"
  #     when (76..100)
  #       "high"
  #     end # => "high"
  #
  #     case "2.6.5"
  #     when ..."2.4"
  #       "EOL"
  #     when "2.4"..."2.5"
  #       "maintenance"
  #     when "2.5"..."3.0"
  #       "stable"
  #     when "3.1"..
  #       "upcoming"
  #     end # => "stable"
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self.begin -> object
  # -->
  # Returns the object that defines the beginning of `self`.
  #
  #     (1..4).begin # => 1
  #     (..2).begin  # => nil
  #
  # Related: Range#first, Range#end.
  #
  def begin: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - bsearch {|obj| block }  -> value
  # -->
  # Returns an element from `self` selected by a binary search.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=range.c
  #   - cover?(object) -> true or false
  #   - cover?(range) -> true or false
  # -->
  # Returns `true` if the given argument is within `self`, `false` otherwise.
  #
  # With non-range argument `object`, evaluates with `<=` and `<`.
  #
  # For range `self` with included end value (`#exclude_end? == false`), evaluates
  # thus:
  #
  #     self.begin <= object <= self.end
  #
  # Examples:
  #
  #     r = (1..4)
  #     r.cover?(1)     # => true
  #     r.cover?(4)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(5)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'..'d')
  #     r.cover?('a')     # => true
  #     r.cover?('d')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('e')     # => false
  #     r.cover?(0)       # => false
  #
  # For range `r` with excluded end value (`#exclude_end? == true`), evaluates
  # thus:
  #
  #     r.begin <= object < r.end
  #
  # Examples:
  #
  #     r = (1...4)
  #     r.cover?(1)     # => true
  #     r.cover?(3)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(4)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'...'d')
  #     r.cover?('a')     # => true
  #     r.cover?('c')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('d')     # => false
  #     r.cover?(0)       # => false
  #
  # With range argument `range`, compares the first and last elements of `self`
  # and `range`:
  #
  #     r = (1..4)
  #     r.cover?(1..4)     # => true
  #     r.cover?(0..4)     # => false
  #     r.cover?(1..5)     # => false
  #     r.cover?('a'..'d') # => false
  #
  #     r = (1...4)
  #     r.cover?(1..3)     # => true
  #     r.cover?(1..4)     # => false
  #
  # If begin and end are numeric, #cover? behaves like #include?
  #
  #     (1..3).cover?(1.5) # => true
  #     (1..3).include?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').cover?('cc')   # => true
  #     ('a'..'d').include?('cc') # => false
  #
  # Returns `false` if either:
  #
  # *   The begin value of `self` is larger than its end value.
  # *   An internal call to `<=>` returns `nil`; that is, the operands are not
  #     comparable.
  #
  #
  # Related: Range#include?.
  #
  def cover?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - each {|element| ... } -> self
  #   - each                  -> an_enumerator
  # -->
  # With a block given, passes each element of `self` to the block:
  #
  #     a = []
  #     (1..4).each {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  # Raises an exception unless `self.first.respond_to?(:succ)`.
  #
  # With no block given, returns an enumerator.
  #
  def each: () { (Elem arg0) -> untyped } -> self
          | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=range.c
  #   - self.end -> object
  # -->
  # Returns the object that defines the end of `self`.
  #
  #     (1..4).end  # => 4
  #     (1...4).end # => 4
  #     (1..).end   # => nil
  #
  # Related: Range#begin, Range#last.
  #
  def end: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - exclude_end? -> true or false
  # -->
  # Returns `true` if `self` excludes its end value; `false` otherwise:
  #
  #     Range.new(2, 5).exclude_end?       # => false
  #     Range.new(2, 5, true).exclude_end? # => true
  #     (2..5).exclude_end?                # => false
  #     (2...5).exclude_end?               # => true
  #
  def exclude_end?: () -> bool

  # <!--
  #   rdoc-file=range.c
  #   - first -> object
  #   - first(n) -> array
  # -->
  # With no argument, returns the first element of `self`, if it exists:
  #
  #     (1..4).first     # => 1
  #     ('a'..'d').first # => "a"
  #
  # With non-negative integer argument `n` given, returns the first `n` elements
  # in an array:
  #
  #     (1..10).first(3) # => [1, 2, 3]
  #     (1..10).first(0) # => []
  #     (1..4).first(50) # => [1, 2, 3, 4]
  #
  # Raises an exception if there is no first element:
  #
  #     (..4).first # Raises RangeError
  #
  def first: () -> Elem
           | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. Two range objects `r0` and `r1`
  # have the same hash value if and only if `r0.eql?(r1)`.
  #
  # Related: Range#eql?, Object#hash.
  #
  def hash: () -> Integer

  # <!-- rdoc-file=range.c -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  # Range#member? is an alias for Range#include?.
  #
  def include?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - Range.new(begin, end, exclude_end = false) -> new_range
  # -->
  # Returns a new range based on the given objects `begin` and `end`. Optional
  # argument `exclude_end` determines whether object `end` is included as the last
  # object in the range:
  #
  #     Range.new(2, 5).to_a            # => [2, 3, 4, 5]
  #     Range.new(2, 5, true).to_a      # => [2, 3, 4]
  #     Range.new('a', 'd').to_a        # => ["a", "b", "c", "d"]
  #     Range.new('a', 'd', true).to_a  # => ["a", "b", "c"]
  #
  def initialize: (Elem from, Elem to, ?boolish exclude_end) -> void

  # <!--
  #   rdoc-file=range.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`, including `begin.inspect` and
  # `end.inspect`:
  #
  #     (1..4).inspect  # => "1..4"
  #     (1...4).inspect # => "1...4"
  #     (1..).inspect   # => "1.."
  #     (..4).inspect   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#to_s.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - last -> object
  #   - last(n) -> array
  # -->
  # With no argument, returns the last element of `self`, if it exists:
  #
  #     (1..4).last     # => 4
  #     ('a'..'d').last # => "d"
  #
  # Note that `last` with no argument returns the end element of `self` even if
  # #exclude_end? is `true`:
  #
  #     (1...4).last     # => 4
  #     ('a'...'d').last # => "d"
  #
  # With non-negative integer argument `n` given, returns the last `n` elements in
  # an array:
  #
  #     (1..10).last(3) # => [8, 9, 10]
  #     (1..10).last(0) # => []
  #     (1..4).last(50) # => [1, 2, 3, 4]
  #
  # Note that `last` with argument does not return the end element of `self` if
  # #exclude_end? it `true`:
  #
  #     (1...4).last(3)     # => [1, 2, 3]
  #     ('a'...'d').last(3) # => ["a", "b", "c"]
  #
  # Raises an exception if there is no last element:
  #
  #     (1..).last # Raises RangeError
  #
  def last: () -> Elem
          | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - max -> object
  #   - max(n) -> array
  #   - max {|a, b| ... } -> object
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the maximum value in `self`, using method `<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the maximum-valued element of
  # `self`.
  #
  #     (1..4).max     # => 4
  #     ('a'..'d').max # => "d"
  #     (-4..-1).max   # => -1
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` maximum-valued elements of `self` in an array:
  #
  #     (1..4).max(2)     # => [4, 3]
  #     ('a'..'d').max(2) # => ["d", "c"]
  #     (-4..-1).max(2)   # => [-1, -2]
  #     (1..4).max(50)    # => [4, 3, 2, 1]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far maximum value and the next element of
  #     `self`.
  #
  #
  # To illustrate:
  #
  #     (1..4).max {|a, b| p [a, b]; a <=> b } # => 4
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 2]
  #     [4, 3]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).max {|a, b| -(a <=> b) } # => 1
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).max(2) {|a, b| -(a <=> b) }  # => [1, 2]
  #     (1..4).max(50) {|a, b| -(a <=> b) } # => [1, 2, 3, 4]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).max(0)                      # => []
  #     (1..4).max(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).max                         # => nil
  #         (4..1).max(2)                      # => []
  #         (4..1).max {|a, b| -(a <=> b) }    # => nil
  #         (4..1).max(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).max                          # => nil
  #         (1...1).max(2)                       # => []
  #         (1...1).max  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).max(2)  {|a, b| -(a <=> b) } # => []
  #
  #
  # Raises an exception if either:
  #
  # *   `self` is a endless range: `(1..)`.
  # *   A block is given and `self` is a beginless range.
  #
  #
  # Related: Range#min, Range#minmax.
  #
  def max: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - min -> object
  #   - min(n) -> array
  #   - min {|a, b| ... } -> object
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the minimum value in `self`, using method `<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the minimum-valued element of
  # `self`.
  #
  #     (1..4).min     # => 1
  #     ('a'..'d').min # => "a"
  #     (-4..-1).min   # => -4
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` minimum-valued elements of `self` in an array:
  #
  #     (1..4).min(2)     # => [1, 2]
  #     ('a'..'d').min(2) # => ["a", "b"]
  #     (-4..-1).min(2)   # => [-4, -3]
  #     (1..4).min(50)    # => [1, 2, 3, 4]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far minimum value and the next element of
  #     `self`.
  #
  #
  # To illustrate:
  #
  #     (1..4).min {|a, b| p [a, b]; a <=> b } # => 1
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 1]
  #     [4, 1]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).min {|a, b| -(a <=> b) } # => 4
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).min(2) {|a, b| -(a <=> b) }  # => [4, 3]
  #     (1..4).min(50) {|a, b| -(a <=> b) } # => [4, 3, 2, 1]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).min(0)                      # => []
  #     (1..4).min(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).min                         # => nil
  #         (4..1).min(2)                      # => []
  #         (4..1).min {|a, b| -(a <=> b) }    # => nil
  #         (4..1).min(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).min                          # => nil
  #         (1...1).min(2)                       # => []
  #         (1...1).min  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).min(2)  {|a, b| -(a <=> b) } # => []
  #
  #
  # Raises an exception if either:
  #
  # *   `self` is a beginless range: `(..4)`.
  # *   A block is given and `self` is an endless range.
  #
  #
  # Related: Range#max, Range#minmax.
  #
  def min: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - size -> non_negative_integer or Infinity or nil
  # -->
  # Returns the count of elements in `self` if both begin and end values are
  # numeric; otherwise, returns `nil`:
  #
  #     (1..4).size      # => 4
  #     (1...4).size     # => 3
  #     (1..).size       # => Infinity
  #     ('a'..'z').size  #=> nil
  #
  # Related: Range#count.
  #
  def size: () -> Integer?
          | () -> Float?

  # <!--
  #   rdoc-file=range.c
  #   - step(n = 1) {|element| ... } -> self
  #   - step(n = 1)                  -> enumerator
  # -->
  # Iterates over the elements of `self`.
  #
  # With a block given and no argument, calls the block each element of the range;
  # returns `self`:
  #
  #     a = []
  #     (1..5).step {|element| a.push(element) } # => 1..5
  #     a # => [1, 2, 3, 4, 5]
  #     a = []
  #     ('a'..'e').step {|element| a.push(element) } # => "a".."e"
  #     a # => ["a", "b", "c", "d", "e"]
  #
  # With a block given and a positive integer argument `n` given, calls the block
  # with element `0`, element `n`, element `2n`, and so on:
  #
  #     a = []
  #     (1..5).step(2) {|element| a.push(element) } # => 1..5
  #     a # => [1, 3, 5]
  #     a = []
  #     ('a'..'e').step(2) {|element| a.push(element) } # => "a".."e"
  #     a # => ["a", "c", "e"]
  #
  # With no block given, returns an enumerator, which will be of class
  # Enumerator::ArithmeticSequence if `self` is numeric; otherwise of class
  # Enumerator:
  #
  #     e = (1..5).step(2) # => ((1..5).step(2))
  #     e.class            # => Enumerator::ArithmeticSequence
  #     ('a'..'e').step # => #<Enumerator: ...>
  #
  # Related: Range#%.
  #
  def step: (?Integer n) { (Elem arg0) -> untyped } -> self
          | (?Integer n) -> ::Enumerator[Elem, void]

  # <!--
  #   rdoc-file=range.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`, including `begin.to_s` and
  # `end.to_s`:
  #
  #     (1..4).to_s  # => "1..4"
  #     (1...4).to_s # => "1...4"
  #     (1..).to_s   # => "1.."
  #     (..4).to_s   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#inspect.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin eql? self.begin`.
  # *   `other.end eql? self.end`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r.eql?(1..5)                  # => true
  #     r = Range.new(1, 5)
  #     r.eql?('foo')                 # => false
  #     r.eql?(2..5)                  # => false
  #     r.eql?(1..4)                  # => false
  #     r.eql?(1...5)                 # => false
  #     r.eql?(Range.new(1, 5, true)) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#==.
  #
  def eql?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - include?(object) -> true or false
  # -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  # Range#member? is an alias for Range#include?.
  #
  def member?: (untyped obj) -> bool
end

# <!-- rdoc-file=proc.c -->
# Objects of class Binding encapsulate the execution context at some particular
# place in the code and retain this context for future use. The variables,
# methods, value of `self`, and possibly an iterator block that can be accessed
# in this context are all retained. Binding objects can be created using
# Kernel#binding, and are made available to the callback of
# Kernel#set_trace_func and instances of TracePoint.
#
# These binding objects can be passed as the second argument of the Kernel#eval
# method, establishing an environment for the evaluation.
#
#     class Demo
#       def initialize(n)
#         @secret = n
#       end
#       def get_binding
#         binding
#       end
#     end
#
#     k1 = Demo.new(99)
#     b1 = k1.get_binding
#     k2 = Demo.new(-3)
#     b2 = k2.get_binding
#
#     eval("@secret", b1)   #=> 99
#     eval("@secret", b2)   #=> -3
#     eval("@secret")       #=> nil
#
# Binding objects have no class-specific methods.
#
class Binding
  public

  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - binding.eval(string [, filename [,lineno]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*, in the *binding*'s context.  If
  # the optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     b.eval("param")   #=> "hello"
  #
  def eval: (String arg0, ?String filename, ?Integer lineno) -> untyped

  # <!--
  #   rdoc-file=lib/irb.rb
  #   - irb()
  # -->
  # Opens an IRB session where `binding.irb` is called which allows for
  # interactive debugging. You can call any methods or variables available in the
  # current scope, and mutate state if you need to.
  #
  # Given a Ruby file called `potato.rb` containing the following code:
  #
  #     class Potato
  #       def initialize
  #         @cooked = false
  #         binding.irb
  #         puts "Cooked potato: #{@cooked}"
  #       end
  #     end
  #
  #     Potato.new
  #
  # Running `ruby potato.rb` will open an IRB session where `binding.irb` is
  # called, and you will see the following:
  #
  #     $ ruby potato.rb
  #
  #     From: potato.rb @ line 4 :
  #
  #         1: class Potato
  #         2:   def initialize
  #         3:     @cooked = false
  #      => 4:     binding.irb
  #         5:     puts "Cooked potato: #{@cooked}"
  #         6:   end
  #         7: end
  #         8:
  #         9: Potato.new
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0>
  #
  # You can type any valid Ruby code and it will be evaluated in the current
  # context. This allows you to debug without having to run your code repeatedly:
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0> @cooked
  #     => false
  #     irb(#<Potato:0x00007feea1916670>):002:0> self.class
  #     => Potato
  #     irb(#<Potato:0x00007feea1916670>):003:0> caller.first
  #     => ".../2.5.1/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'"
  #     irb(#<Potato:0x00007feea1916670>):004:0> @cooked = true
  #     => true
  #
  # You can exit the IRB session with the `exit` command. Note that exiting will
  # resume execution where `binding.irb` had paused it, as you can see from the
  # output printed to standard output in this example:
  #
  #     irb(#<Potato:0x00007feea1916670>):005:0> exit
  #     Cooked potato: true
  #
  # See IRB@IRB+Usage for more information.
  #
  def irb: () -> void

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_defined?(symbol) -> obj
  # -->
  # Returns `true` if a local variable `symbol` exists.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_defined?(:a) #=> true
  #       binding.local_variable_defined?(:b) #=> false
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("defined?(#{symbol}) == 'local-variable'")
  #
  def local_variable_defined?: (String | Symbol symbol) -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_get(symbol) -> obj
  # -->
  # Returns the value of the local variable `symbol`.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_get(:a) #=> 1
  #       binding.local_variable_get(:b) #=> NameError
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("#{symbol}")
  #
  def local_variable_get: (String | Symbol symbol) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_set(symbol, obj) -> obj
  # -->
  # Set local variable named `symbol` as `obj`.
  #
  #     def foo
  #       a = 1
  #       bind = binding
  #       bind.local_variable_set(:a, 2) # set existing local variable `a'
  #       bind.local_variable_set(:b, 3) # create new local variable `b'
  #                                      # `b' exists only in binding
  #
  #       p bind.local_variable_get(:a)  #=> 2
  #       p bind.local_variable_get(:b)  #=> 3
  #       p a                            #=> 2
  #       p b                            #=> NameError
  #     end
  #
  # This method behaves similarly to the following code:
  #
  #     binding.eval("#{symbol} = #{obj}")
  #
  # if `obj` can be dumped in Ruby code.
  #
  def local_variable_set: [U] (String | Symbol symbol, U obj) -> U

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variables -> Array
  # -->
  # Returns the names of the binding's local variables as symbols.
  #
  #     def foo
  #       a = 1
  #       2.times do |n|
  #         binding.local_variables #=> [:a, :n]
  #       end
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("local_variables")
  #
  def local_variables: () -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - binding.receiver    -> object
  # -->
  # Returns the bound receiver of the binding object.
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number of the binding object.
  #
  def source_location: () -> [ String, Integer ]
end

# <!-- rdoc-file=enum.c -->
# ## What's Here
#
# Module Enumerable provides methods that are useful to a collection class for:
# *   [Querying](#module-Enumerable-label-Methods+for+Querying)
# *   [Fetching](#module-Enumerable-label-Methods+for+Fetching)
# *   [Searching](#module-Enumerable-label-Methods+for+Searching)
# *   [Sorting](#module-Enumerable-label-Methods+for+Sorting)
# *   [Iterating](#module-Enumerable-label-Methods+for+Iterating)
# *   [And more....](#module-Enumerable-label-Other+Methods)
#
#
# ### Methods for Querying
#
# These methods return information about the Enumerable other than the elements
# themselves:
#
# #include?, #member?
# :   Returns `true` if self == object, `false` otherwise.
# #all?
# :   Returns `true` if all elements meet a specified criterion; `false`
#     otherwise.
# #any?
# :   Returns `true` if any element meets a specified criterion; `false`
#     otherwise.
# #none?
# :   Returns `true` if no element meets a specified criterion; `false`
#     otherwise.
# #one?
# :   Returns `true` if exactly one element meets a specified criterion; `false`
#     otherwise.
# #count
# :   Returns the count of elements, based on an argument or block criterion, if
#     given.
# #tally
# :   Returns a new Hash containing the counts of occurrences of each element.
#
#
# ### Methods for Fetching
#
# These methods return entries from the Enumerable, without modifying it:
#
# *Leading, trailing, or all elements*:
# #entries, #to_a
# :   Returns all elements.
# #first
# :   Returns the first element or leading elements.
# #take
# :   Returns a specified number of leading elements.
# #drop
# :   Returns a specified number of trailing elements.
# #take_while
# :   Returns leading elements as specified by the given block.
# #drop_while
# :   Returns trailing elements as specified by the given block.
#
#
# *Minimum and maximum value elements*:
# #min
# :   Returns the elements whose values are smallest among the elements, as
#     determined by `<=>` or a given block.
# #max
# :   Returns the elements whose values are largest among the elements, as
#     determined by `<=>` or a given block.
# #minmax
# :   Returns a 2-element Array containing the smallest and largest elements.
# #min_by
# :   Returns the smallest element, as determined by the given block.
# #max_by
# :   Returns the largest element, as determined by the given block.
# #minmax_by
# :   Returns the smallest and largest elements, as determined by the given
#     block.
#
#
# *Groups, slices, and partitions*:
# #group_by
# :   Returns a Hash that partitions the elements into groups.
# #partition
# :   Returns elements partitioned into two new Arrays, as determined by the
#     given block.
# #slice_after
# :   Returns a new Enumerator whose entries are a partition of `self`, based
#     either on a given `object` or a given block.
# #slice_before
# :   Returns a new Enumerator whose entries are a partition of `self`, based
#     either on a given `object` or a given block.
# #slice_when
# :   Returns a new Enumerator whose entries are a partition of `self` based on
#     the given block.
# #chunk
# :   Returns elements organized into chunks as specified by the given block.
# #chunk_while
# :   Returns elements organized into chunks as specified by the given block.
#
#
# ### Methods for Searching and Filtering
#
# These methods return elements that meet a specified criterion.
#
# #find, #detect
# :   Returns an element selected by the block.
# #find_all, #filter, #select
# :   Returns elements selected by the block.
# #find_index
# :   Returns the index of an element selected by a given object or block.
# #reject
# :   Returns elements not rejected by the block.
# #uniq
# :   Returns elements that are not duplicates.
#
#
# ### Methods for Sorting
#
# These methods return elements in sorted order.
#
# #sort
# :   Returns the elements, sorted by `<=>` or the given block.
# #sort_by
# :   Returns the elements, sorted by the given block.
#
#
# ### Methods for Iterating
#
# #each_entry
# :   Calls the block with each successive element (slightly different from
#     #each).
# #each_with_index
# :   Calls the block with each successive element and its index.
# #each_with_object
# :   Calls the block with each successive element and a given object.
# #each_slice
# :   Calls the block with successive non-overlapping slices.
# #each_cons
# :   Calls the block with successive overlapping slices. (different from
#     #each_slice).
# #reverse_each
# :   Calls the block with each successive element, in reverse order.
#
#
# ### Other Methods
#
# #map, #collect
# :   Returns objects returned by the block.
# #filter_map
# :   Returns truthy objects returned by the block.
# #flat_map, #collect_concat
# :   Returns flattened objects returned by the block.
# #grep
# :   Returns elements selected by a given object or objects returned by a given
#     block.
# #grep_v
# :   Returns elements selected by a given object or objects returned by a given
#     block.
# #reduce, #inject
# :   Returns the object formed by combining all elements.
# #sum
# :   Returns the sum of the elements, using method +++.
# #zip
# :   Combines each element with elements from other enumerables; returns the
#     n-tuples or calls the block with each.
# #cycle
# :   Calls the block with each element, cycling repeatedly.
#
#
# ## Usage
#
# To use module Enumerable in a collection class:
#
# *   Include it:
#
#         include Enumerable
#
# *   Implement method `#each` which must yield successive elements of the
#     collection. The method will be called by almost any Enumerable method.
#
#
# Example:
#
#     class Foo
#       include Enumerable
#       def each
#         yield 1
#         yield 1, 2
#         yield
#       end
#     end
#     Foo.new.each_entry{ |element| p element }
#
# Output:
#
#     1
#     [1, 2]
#     nil
#
# ## Enumerable in Ruby Core Classes
# Some Ruby classes include Enumerable:
# *   Array
# *   Dir
# *   Hash
# *   IO
# *   Range
# *   Set
# *   Struct
#
# Virtually all methods in Enumerable call method `#each` in the including
# class:
# *   `Hash#each` yields the next key-value pair as a 2-element Array.
# *   `Struct#each` yields the next name-value pair as a 2-element Array.
# *   For the other classes above, `#each` yields the next object from the
#     collection.
#
#
# ## About the Examples
# The example code snippets for the Enumerable methods:
# *   Always show the use of one or more Array-like classes (often Array
#     itself).
# *   Sometimes show the use of a Hash-like class. For some methods, though, the
#     usage would not make sense, and so it is not shown.  Example: #tally would
#     find exactly one of each Hash entry.
#
module Enumerable[unchecked out Elem] : _Each[Elem]
  # <!--
  #   rdoc-file=enum.c
  #   - all?                  -> true or false
  #   - all?(pattern)         -> true or false
  #   - all? {|element| ... } -> true or false
  # -->
  # Returns whether every element meets a given criterion.
  #
  # With no argument and no block, returns whether every element is truthy:
  #
  #     (1..4).all?           # => true
  #     %w[a b c d].all?      # => true
  #     [1, 2, nil].all?      # => false
  #     ['a','b', false].all? # => false
  #     [].all?               # => true
  #
  # With argument `pattern` and no block, returns whether for each element
  # `element`, `pattern === element`:
  #
  #     (1..4).all?(Integer)                 # => true
  #     (1..4).all?(Numeric)                 # => true
  #     (1..4).all?(Float)                   # => false
  #     %w[bar baz bat bam].all?(/ba/)       # => true
  #     %w[bar baz bat bam].all?(/bar/)      # => false
  #     %w[bar baz bat bam].all?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.all?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.all?(Hash)  # => false
  #     [].all?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for every
  # element:
  #
  #     (1..4).all? {|element| element < 5 }                    # => true
  #     (1..4).all? {|element| element < 4 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 3 } # => true
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 2 } # => false
  #
  # Related: #any?, #none? #one?.
  #
  def all?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - any?                  -> true or false
  #   - any?(pattern)         -> true or false
  #   - any? {|element| ... } -> true or false
  # -->
  # Returns whether any element meets a given criterion.
  #
  # With no argument and no block, returns whether any element is truthy:
  #
  #     (1..4).any?          # => true
  #     %w[a b c d].any?     # => true
  #     [1, false, nil].any? # => true
  #     [].any?              # => false
  #
  # With argument `pattern` and no block, returns whether for any element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].any?(Integer)        # => true
  #     [nil, false, 0].any?(Numeric)        # => true
  #     [nil, false, 0].any?(Float)          # => false
  #     %w[bar baz bat bam].any?(/m/)        # => true
  #     %w[bar baz bat bam].any?(/foo/)      # => false
  #     %w[bar baz bat bam].any?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.any?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.any?(Hash)  # => false
  #     [].any?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for any
  # element:
  #
  #     (1..4).any? {|element| element < 2 }                    # => true
  #     (1..4).any? {|element| element < 1 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 1 } # => true
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 0 } # => false
  #
  # Related: #all?, #none?, #one?.
  #
  def any?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - map {|element| ... } -> array
  #   - map -> enumerator
  # -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def collect: [U] () { (Elem arg0) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def collect_concat: [U] () { (Elem) -> (::Array[U] | U) } -> ::Array[U]
                    | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - compact -> array
  # -->
  # Returns an array of all non-`nil` elements:
  #
  #     a = [nil, 0, nil, 'a', false, nil, false, nil, 'a', nil, 0, nil]
  #     a.compact # => [0, "a", false, false, "a", 0]
  #
  def compact: () -> Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - count -> integer
  #   - count(object) -> integer
  #   - count {|element| ... } -> integer
  # -->
  # Returns the count of elements, based on an argument or block criterion, if
  # given.
  #
  # With no argument and no block given, returns the number of elements:
  #
  #     [0, 1, 2].count                # => 3
  #     {foo: 0, bar: 1, baz: 2}.count # => 3
  #
  # With argument `object` given, returns the number of elements that are `==` to
  # `object`:
  #
  #     [0, 1, 2, 1].count(1)           # => 2
  #
  # With a block given, calls the block with each element and returns the number
  # of elements for which the block returns a truthy value:
  #
  #     [0, 1, 2, 3].count {|element| element < 2}              # => 2
  #     {foo: 0, bar: 1, baz: 2}.count {|key, value| value < 2} # => 2
  #
  def count: () -> Integer
           | (Elem) -> Integer
           | () { (Elem) -> boolish } -> Integer

  # <!--
  #   rdoc-file=enum.c
  #   - cycle(n = nil) {|element| ...} ->  nil
  #   - cycle(n = nil)                 ->  enumerator
  # -->
  # When called with positive integer argument `n` and a block, calls the block
  # with each element, then does so again, until it has done so `n` times; returns
  # `nil`:
  #
  #     a = []
  #     (1..4).cycle(3) {|element| a.push(element) } # => nil
  #     a # => [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
  #     a = []
  #     ('a'..'d').cycle(2) {|element| a.push(element) }
  #     a # => ["a", "b", "c", "d", "a", "b", "c", "d"]
  #     a = []
  #     {foo: 0, bar: 1, baz: 2}.cycle(2) {|element| a.push(element) }
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2], [:foo, 0], [:bar, 1], [:baz, 2]]
  #
  # If count is zero or negative, does not call the block.
  #
  # When called with a block and `n` is `nil`, cycles forever.
  #
  # When no block is given, returns an Enumerator.
  #
  def cycle: (?Integer n) { (Elem arg0) -> untyped } -> NilClass
           | (?Integer n) -> ::Enumerator[Elem, NilClass]

  # <!-- rdoc-file=enum.c -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def detect: (?Proc ifnone) { (Elem) -> boolish } -> Elem?
            | (?Proc ifnone) -> ::Enumerator[Elem, Elem?]

  # <!--
  #   rdoc-file=enum.c
  #   - drop(n) -> array
  # -->
  # For positive integer `n`, returns an array containing all but the first `n`
  # elements:
  #
  #     r = (1..4)
  #     r.drop(3)  # => [4]
  #     r.drop(2)  # => [3, 4]
  #     r.drop(1)  # => [2, 3, 4]
  #     r.drop(0)  # => [1, 2, 3, 4]
  #     r.drop(50) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.drop(2) # => [[:baz, 2], [:bat, 3]]
  #
  def drop: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - drop_while {|element| ... } -> array
  #   - drop_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements after that point:
  #
  #     (1..4).drop_while{|i| i < 3 } # => [3, 4]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     a = h.drop_while{|element| key, value = *element; value < 2 }
  #     a # => [[:baz, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  def drop_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - each_cons(n) { ... } ->  self
  #   - each_cons(n)         ->  enumerator
  # -->
  # Calls the block with each successive overlapped `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..5).each_cons(3) {|element| a.push(element) }
  #     a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
  #
  #     a = []
  #     h = {foo: 0,  bar: 1, baz: 2, bam: 3}
  #     h.each_cons(2) {|element| a.push(element) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:bar, 1], [:baz, 2]], [[:baz, 2], [:bam, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_cons: (Integer n) { (::Array[Elem]) -> void } -> self
               | (Integer n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_index(*args) {|element, i| ..... } -> self
  #   - each_with_index(*args)                       -> enumerator
  # -->
  # With a block given, calls the block with each element and its index; returns
  # `self`:
  #
  #     h = {}
  #     (1..4).each_with_index {|element, i| h[element] = i } # => 1..4
  #     h # => {1=>0, 2=>1, 3=>2, 4=>3}
  #
  #     h = {}
  #     %w[a b c d].each_with_index {|element, i| h[element] = i }
  #     # => ["a", "b", "c", "d"]
  #     h # => {"a"=>0, "b"=>1, "c"=>2, "d"=>3}
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_with_index {|element, i| a.push([i, element]) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[0, [:foo, 0]], [1, [:bar, 1]], [2, [:baz, 2]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_index: () { (Elem, Integer index) -> untyped } -> self
                     | () -> ::Enumerator[[ Elem, Integer ], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_object(object) { |(*args), memo_object| ... }  ->  object
  #   - each_with_object(object)                                 ->  enumerator
  # -->
  # Calls the block once for each element, passing both the element and the given
  # object:
  #
  #     (1..4).each_with_object([]) {|i, a| a.push(i**2) } # => [1, 4, 9, 16]
  #     h.each_with_object({}) {|element, h| k, v = *element; h[v] = k }
  #     # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                      | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  # Enumerable#entries is an alias for Enumerable#to_a.
  #
  def entries: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - select {|element| ... } -> array
  #   - select -> enumerator
  # -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  def find_all: () { (Elem) -> boolish } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias select find_all

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias filter find_all

  # <!--
  #   rdoc-file=enum.c
  #   - find_index(object) -> integer or nil
  #   - find_index {|element| ... } -> integer or nil
  #   - find_index -> enumerator
  # -->
  # Returns the index of the first element that meets a specified criterion, or
  # `nil` if no such element is found.
  #
  # With argument `object` given, returns the index of the first element that is
  # `==` `object`:
  #
  #     ['a', 'b', 'c', 'b'].find_index('b') # => 1
  #
  # With a block given, calls the block with successive elements; returns the
  # first element for which the block returns a truthy value:
  #
  #     ['a', 'b', 'c', 'b'].find_index {|element| element.start_with?('b') } # => 1
  #     {foo: 0, bar: 1, baz: 2}.find_index {|key, value| value > 1 }         # => 2
  #
  # With no argument and no block given, returns an Enumerator.
  #
  def find_index: (untyped value) -> Integer?
                | () { (Elem) -> boolish } -> Integer?
                | () -> ::Enumerator[Elem, Integer?]

  # <!--
  #   rdoc-file=enum.c
  #   - first    -> element or nil
  #   - first(n) -> array
  # -->
  # Returns the first element or elements.
  #
  # With no argument, returns the first element, or `nil` if there is none:
  #
  #     (1..4).first                   # => 1
  #     %w[a b c].first                # => "a"
  #     {foo: 1, bar: 1, baz: 2}.first # => [:foo, 1]
  #     [].first                       # => nil
  #
  # With integer argument `n`, returns an array containing the first `n` elements
  # that exist:
  #
  #     (1..4).first(2)                   # => [1, 2]
  #     %w[a b c d].first(3)              # => ["a", "b", "c"]
  #     %w[a b c d].first(50)             # => ["a", "b", "c", "d"]
  #     {foo: 1, bar: 1, baz: 2}.first(2) # => [[:foo, 1], [:bar, 1]]
  #     [].first(2)                       # => []
  #
  def first: () -> Elem?
           | (_ToInt n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - grep(pattern) -> array
  #   - grep(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based elements of `self` that match the given
  # pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `true`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/)                   # => ["bar", "car"]
  #     (1..10).grep(3..8)             # => [3, 4, 5, 6, 7, 8]
  #     ['a', 'b', 0, 1].grep(Integer) # => [0, 1]
  #
  # With a block given, calls the block with each matching element and returns an
  # array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/) {|element| element.upcase } # => ["BAR", "CAR"]
  #
  # Related: #grep_v.
  #
  def grep: (untyped arg0) -> ::Array[Elem]
          | [U] (untyped arg0) { (Elem arg0) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - grep_v(pattern) -> array
  #   - grep_v(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based on elements of `self` that *don't* match the
  # given pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `false`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/)                   # => ["foo", "moo"]
  #     (1..10).grep_v(3..8)             # => [1, 2, 9, 10]
  #     ['a', 'b', 0, 1].grep_v(Integer) # => ["a", "b"]
  #
  # With a block given, calls the block with each non-matching element and returns
  # an array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/) {|element| element.upcase } # => ["FOO", "MOO"]
  #
  # Related: #grep.
  #
  def grep_v: (untyped) -> ::Array[Elem]
            | [U] (untyped) { (Elem) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - group_by {|element| ... } -> hash
  #   - group_by                  -> enumerator
  # -->
  # With a block given returns a hash:
  #
  # *   Each key is a return value from the block.
  # *   Each value is an array of those elements for which the block returned that
  #     key.
  #
  #
  # Examples:
  #
  #     g = (1..6).group_by {|i| i%3 }
  #     g # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]}
  #     h = {foo: 0, bar: 1, baz: 0, bat: 1}
  #     g = h.group_by {|key, value| value }
  #     g # => {0=>[[:foo, 0], [:baz, 0]], 1=>[[:bar, 1], [:bat, 1]]}
  #
  # With no block given, returns an Enumerator.
  #
  def group_by: [U] () { (Elem arg0) -> U } -> ::Hash[U, ::Array[Elem]]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  # Enumerable#member? is an alias for Enumerable#include?.
  #
  def include?: (Elem arg0) -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - inject(symbol) -> object
  #   - inject(initial_operand, symbol) -> object
  #   - inject {|memo, operand| ... } -> object
  #   - inject(initial_operand) {|memo, operand| ... } -> object
  # -->
  # Returns an object formed from operands via either:
  #
  # *   A method named by `symbol`.
  # *   A block to which each operand is passed.
  #
  #
  # With method-name argument `symbol`, combines operands using the method:
  #
  #     # Sum, without initial_operand.
  #     (1..4).inject(:+)     # => 10
  #     # Sum, with initial_operand.
  #     (1..4).inject(10, :+) # => 20
  #
  # With a block, passes each operand to the block:
  #
  #     # Sum of squares, without initial_operand.
  #     (1..4).inject {|sum, n| sum + n*n }    # => 30
  #     # Sum of squares, with initial_operand.
  #     (1..4).inject(2) {|sum, n| sum + n*n } # => 32
  #
  # **Operands**
  #
  # If argument `initial_operand` is not given, the operands for `inject` are
  # simply the elements of `self`. Example calls and their operands:
  #
  #     `(1..4).inject(:+)`
  # :       `[1, 2, 3, 4]`.
  #
  #     `(1...4).inject(:+)`
  # :       `[1, 2, 3]`.
  #
  #     `('a'..'d').inject(:+)`
  # :       `['a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject(:+)`
  # :       `['a', 'b', 'c']`.
  #
  #
  #
  # Examples with first operand (which is `self.first`) of various types:
  #
  #     # Integer.
  #     (1..4).inject(:+)                # => 10
  #     # Float.
  #     [1.0, 2, 3, 4].inject(:+)        # => 10.0
  #     # Character.
  #     ('a'..'d').inject(:+)            # => "abcd"
  #     # Complex.
  #     [Complex(1, 2), 3, 4].inject(:+) # => (8+2i)
  #
  # If argument `initial_operand` is given, the operands for `inject` are that
  # value plus the elements of `self`. Example calls their operands:
  #
  #     `(1..4).inject(10, :+)`
  # :       `[10, 1, 2, 3, 4]`.
  #
  #     `(1...4).inject(10, :+)`
  # :       `[10, 1, 2, 3]`.
  #
  #     `('a'..'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c']`.
  #
  #
  #
  # Examples with `initial_operand` of various types:
  #
  #     # Integer.
  #     (1..4).inject(2, :+)               # => 12
  #     # Float.
  #     (1..4).inject(2.0, :+)             # => 12.0
  #     # String.
  #     ('a'..'d').inject('foo', :+)       # => "fooabcd"
  #     # Array.
  #     %w[a b c].inject(['x'], :push)     # => ["x", "a", "b", "c"]
  #     # Complex.
  #     (1..4).inject(Complex(2, 2), :+)   # => (12+2i)
  #
  # **Combination by Given \Method**
  #
  # If the method-name argument `symbol` is given, the operands are combined by
  # that method:
  #
  # *   The first and second operands are combined.
  # *   That result is combined with the third operand.
  # *   That result is combined with the fourth operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the result of the last combination.
  #
  # This call to `inject` computes the sum of the operands:
  #
  #     (1..4).inject(:+) # => 10
  #
  # Examples with various methods:
  #
  #     # Integer addition.
  #     (1..4).inject(:+)                # => 10
  #     # Integer multiplication.
  #     (1..4).inject(:*)                # => 24
  #     # Character range concatenation.
  #     ('a'..'d').inject('', :+)        # => "abcd"
  #     # String array concatenation.
  #     %w[foo bar baz].inject('', :+)   # => "foobarbaz"
  #     # Hash update.
  #     h = [{foo: 0, bar: 1}, {baz: 2}, {bat: 3}].inject(:update)
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #     # Hash conversion to nested arrays.
  #     h = {foo: 0, bar: 1}.inject([], :push)
  #     h # => [[:foo, 0], [:bar, 1]]
  #
  # **Combination by Given Block**
  #
  # If a block is given, the operands are passed to the block:
  #
  # *   The first call passes the first and second operands.
  # *   The second call passes the result of the first call, along with the third
  #     operand.
  # *   The third call passes the result of the second call, along with the fourth
  #     operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the return value from the last block call.
  #
  # This call to `inject` gives a block that writes the memo and element, and also
  # sums the elements:
  #
  #     (1..4).inject do |memo, element|
  #       p "Memo: #{memo}; element: #{element}"
  #       memo + element
  #     end # => 10
  #
  # Output:
  #
  #     "Memo: 1; element: 2"
  #     "Memo: 3; element: 3"
  #     "Memo: 6; element: 4"
  #
  # Enumerable#reduce is an alias for Enumerable#inject.
  #
  def inject: (untyped init, Symbol method) -> untyped
            | (Symbol method) -> untyped
            | [A] (A initial) { (A, Elem) -> A } -> A
            | () { (Elem, Elem) -> Elem } -> Elem

  # <!--
  #   rdoc-file=enum.c
  #   - max                  -> element
  #   - max(n)               -> array
  #   - max {|a, b| ... }    -> element
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the maximum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the maximum element, using the
  # elements' own method `<=>` for comparison:
  #
  #     (1..4).max                   # => 4
  #     (-4..-1).max                 # => -1
  #     %w[d c b a].max              # => "d"
  #     {foo: 0, bar: 1, baz: 2}.max # => [:foo, 0]
  #     [].max                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` maximum elements that exist:
  #
  #     (1..4).max(2)                   # => [4, 3]
  #     (-4..-1).max(2)                # => [-1, -2]
  #     %w[d c b a].max(2)              # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.max(2) # => [[:foo, 0], [:baz, 2]]
  #     [].max(2)                       # => []
  #
  # With a block given, the block determines the maximum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # With a block given and no argument, returns the maximum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].max {|a, b| a.size <=> b.size } # => "xxxx"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max {|pair1, pair2| pair1[1] <=> pair2[1] }     # => [:baz, 2]
  #     [].max {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` maximum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].max(2) {|a, b| a.size <=> b.size } # => ["xxxx", "xxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].max(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min, #minmax, #max_by.
  #
  def max: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - max_by {|element| ... }    -> element
  #   - max_by(n) {|element| ... } -> array
  #   - max_by                     -> enumerator
  #   - max_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the maximum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the maximum value:
  #
  #     (1..4).max_by {|element| -element }                    # => 1
  #     %w[a b c d].max_by {|element| -element.ord }           # => "a"
  #     {foo: 0, bar: 1, baz: 2}.max_by {|key, value| -value } # => [:foo, 0]
  #     [].max_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns maximum values:
  #
  #     (1..4).max_by(2) {|element| -element }
  #     # => [1, 2]
  #     %w[a b c d].max_by(2) {|element| -element.ord }
  #     # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.max_by(2) {|key, value| -value }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].max_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max, #minmax, #min_by.
  #
  def max_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min                  -> element
  #   - min(n)               -> array
  #   - min {|a, b| ... }    -> element
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the minimum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum element, using the
  # elements' own method `<=>` for comparison:
  #
  #     (1..4).min                   # => 1
  #     (-4..-1).min                 # => -4
  #     %w[d c b a].min              # => "a"
  #     {foo: 0, bar: 1, baz: 2}.min # => [:bar, 1]
  #     [].min                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` minimum elements that exist:
  #
  #     (1..4).min(2)                   # => [1, 2]
  #     (-4..-1).min(2)                 # => [-4, -3]
  #     %w[d c b a].min(2)              # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.min(2) # => [[:bar, 1], [:baz, 2]]
  #     [].min(2)                       # => []
  #
  # With a block given, the block determines the minimum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # With a block given and no argument, returns the minimum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].min {|a, b| a.size <=> b.size } # => "x"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min {|pair1, pair2| pair1[1] <=> pair2[1] } # => [:foo, 0]
  #     [].min {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` minimum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].min(2) {|a, b| a.size <=> b.size } # => ["x", "xx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].min(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min_by, #minmax, #max.
  #
  def min: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min_by {|element| ... }    -> element
  #   - min_by(n) {|element| ... } -> array
  #   - min_by                     -> enumerator
  #   - min_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the minimum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the minimum value:
  #
  #     (1..4).min_by {|element| -element }                    # => 4
  #     %w[a b c d].min_by {|element| -element.ord }           # => "d"
  #     {foo: 0, bar: 1, baz: 2}.min_by {|key, value| -value } # => [:baz, 2]
  #     [].min_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns minimum values:
  #
  #     (1..4).min_by(2) {|element| -element }
  #     # => [4, 3]
  #     %w[a b c d].min_by(2) {|element| -element.ord }
  #     # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.min_by(2) {|key, value| -value }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].min_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #min, #minmax, #max_by.
  #
  def min_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax               -> [minimum, maximum]
  #   - minmax {|a, b| ... } -> [minimum, maximum]
  # -->
  # Returns a 2-element array containing the minimum and maximum elements
  # according to a given criterion. The ordering of equal elements is
  # indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum and maximum elements, using
  # the elements' own method `<=>` for comparison:
  #
  #     (1..4).minmax                   # => [1, 4]
  #     (-4..-1).minmax                 # => [-4, -1]
  #     %w[d c b a].minmax              # => ["a", "d"]
  #     {foo: 0, bar: 1, baz: 2}.minmax # => [[:bar, 1], [:foo, 0]]
  #     [].minmax                       # => [nil, nil]
  #
  # With a block given, returns the minimum and maximum elements as determined by
  # the block:
  #
  #     %w[xxx x xxxx xx].minmax {|a, b| a.size <=> b.size } # => ["x", "xxxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.minmax {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:baz, 2]]
  #     [].minmax {|a, b| a <=> b }                          # => [nil, nil]
  #
  # Related: #min, #max, #minmax_by.
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem arg0, Elem arg1) -> Integer } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax_by {|element| ... } -> [minimum, maximum]
  #   - minmax_by                  -> enumerator
  # -->
  # Returns a 2-element array containing the elements for which the block returns
  # minimum and maximum values:
  #
  #     (1..4).minmax_by {|element| -element }
  #     # => [4, 1]
  #     %w[a b c d].minmax_by {|element| -element.ord }
  #     # => ["d", "a"]
  #     {foo: 0, bar: 1, baz: 2}.minmax_by {|key, value| -value }
  #     # => [[:baz, 2], [:foo, 0]]
  #     [].minmax_by {|element| -element }
  #     # => [nil, nil]
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max_by, #minmax, #min_by.
  #
  def minmax_by: () -> [ Elem?, Elem? ]
               | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - none?                  -> true or false
  #   - none?(pattern)         -> true or false
  #   - none? {|element| ... } -> true or false
  # -->
  # Returns whether no element meets a given criterion.
  #
  # With no argument and no block, returns whether no element is truthy:
  #
  #     (1..4).none?           # => false
  #     [nil, false].none?     # => true
  #     {foo: 0}.none?         # => false
  #     {foo: 0, bar: 1}.none? # => false
  #     [].none?               # => true
  #
  # With argument `pattern` and no block, returns whether for no element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 1.1].none?(Integer)      # => true
  #     %w[bar baz bat bam].none?(/m/)        # => false
  #     %w[bar baz bat bam].none?(/foo/)      # => true
  #     %w[bar baz bat bam].none?('ba')       # => true
  #     {foo: 0, bar: 1, baz: 2}.none?(Hash)  # => true
  #     {foo: 0}.none?(Array)                 # => false
  #     [].none?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for no
  # element:
  #
  #     (1..4).none? {|element| element < 1 }                     # => true
  #     (1..4).none? {|element| element < 2 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 0 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 1 } # => false
  #
  # Related: #one?, #all?, #any?.
  #
  def none?: () -> bool
           | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - one?                  -> true or false
  #   - one?(pattern)         -> true or false
  #   - one? {|element| ... } -> true or false
  # -->
  # Returns whether exactly one element meets a given criterion.
  #
  # With no argument and no block, returns whether exactly one element is truthy:
  #
  #     (1..1).one?           # => true
  #     [1, nil, false].one?  # => true
  #     (1..4).one?           # => false
  #     {foo: 0}.one?         # => true
  #     {foo: 0, bar: 1}.one? # => false
  #     [].one?               # => false
  #
  # With argument `pattern` and no block, returns whether for exactly one element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].one?(Integer)        # => true
  #     [nil, false, 0].one?(Numeric)        # => true
  #     [nil, false, 0].one?(Float)          # => false
  #     %w[bar baz bat bam].one?(/m/)        # => true
  #     %w[bar baz bat bam].one?(/foo/)      # => false
  #     %w[bar baz bat bam].one?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.one?(Array) # => false
  #     {foo: 0}.one?(Array)                 # => true
  #     [].one?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for
  # exactly one element:
  #
  #     (1..4).one? {|element| element < 2 }                     # => true
  #     (1..4).one? {|element| element < 1 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 1 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 2 } # => false
  #
  # Related: #none?, #all?, #any?.
  #
  def one?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - partition {|element| ... } -> [true_array, false_array]
  #   - partition -> enumerator
  # -->
  # With a block given, returns an array of two arrays:
  #
  # *   The first having those elements for which the block returns a truthy
  #     value.
  # *   The other having all other elements.
  #
  #
  # Examples:
  #
  #     p = (1..4).partition {|i| i.even? }
  #     p # => [[2, 4], [1, 3]]
  #     p = ('a'..'d').partition {|c| c < 'c' }
  #     p # => [["a", "b"], ["c", "d"]]
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     p = h.partition {|key, value| key.start_with?('b') }
  #     p # => [[[:bar, 1], [:baz, 2], [:bat, 3]], [[:foo, 0]]]
  #     p = h.partition {|key, value| value < 2 }
  #     p # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  # Related: Enumerable#group_by.
  #
  def partition: () { (Elem) -> boolish } -> [ ::Array[Elem], ::Array[Elem] ]
               | () -> ::Enumerator[Elem, [ ::Array[Elem], ::Array[Elem] ]]

  # <!--
  #   rdoc-file=enum.c
  #   - reject {|element| ... } -> array
  #   - reject -> enumerator
  # -->
  # Returns an array of objects rejected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns `nil` or `false`:
  #
  #     (0..9).reject {|i| i * 2 if i.even? }                             # => [1, 3, 5, 7, 9]
  #     {foo: 0, bar: 1, baz: 2}.reject {|key, value| key if value.odd? } # => {:foo=>0, :baz=>2}
  #
  # When no block given, returns an Enumerator.
  #
  # Related: #select.
  #
  def reject: () { (Elem) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - reverse_each(*args) {|element| ... } ->  self
  #   - reverse_each(*args)                  ->  enumerator
  # -->
  # With a block given, calls the block with each element, but in reverse order;
  # returns `self`:
  #
  #     a = []
  #     (1..4).reverse_each {|element| a.push(-element) } # => 1..4
  #     a # => [-4, -3, -2, -1]
  #
  #     a = []
  #     %w[a b c d].reverse_each {|element| a.push(element) }
  #     # => ["a", "b", "c", "d"]
  #     a # => ["d", "c", "b", "a"]
  #
  #     a = []
  #     h.reverse_each {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:baz, 2], [:bar, 1], [:foo, 0]]
  #
  # With no block given, returns an Enumerator.
  #
  def reverse_each: () { (Elem arg0) -> untyped } -> void
                  | () -> ::Enumerator[Elem, void]

  # <!--
  #   rdoc-file=enum.c
  #   - sort               -> array
  #   - sort {|a, b| ... } -> array
  # -->
  # Returns an array containing the sorted elements of `self`. The ordering of
  # equal elements is indeterminate and may be unstable.
  #
  # With no block given, the sort compares using the elements' own method `<=>`:
  #
  #     %w[b c a d].sort              # => ["a", "b", "c", "d"]
  #     {foo: 0, bar: 1, baz: 2}.sort # => [[:bar, 1], [:baz, 2], [:foo, 0]]
  #
  # With a block given, comparisons in the block determine the ordering. The block
  # is called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # Examples:
  #
  #     a = %w[b c a d]
  #     a.sort {|a, b| b <=> a } # => ["d", "c", "b", "a"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.sort {|a, b| b <=> a } # => [[:foo, 0], [:baz, 2], [:bar, 1]]
  #
  # See also #sort_by. It implements a Schwartzian transform which is useful when
  # key computation or comparison is expensive.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sort_by {|element| ... } -> array
  #   - sort_by                  -> enumerator
  # -->
  # With a block given, returns an array of elements of `self`, sorted according
  # to the value returned by the block for each element. The ordering of equal
  # elements is indeterminate and may be unstable.
  #
  # Examples:
  #
  #     a = %w[xx xxx x xxxx]
  #     a.sort_by {|s| s.size }        # => ["x", "xx", "xxx", "xxxx"]
  #     a.sort_by {|s| -s.size }       # => ["xxxx", "xxx", "xx", "x"]
  #     h = {foo: 2, bar: 1, baz: 0}
  #     h.sort_by{|key, value| value } # => [[:baz, 0], [:bar, 1], [:foo, 2]]
  #     h.sort_by{|key, value| key }   # => [[:bar, 1], [:baz, 0], [:foo, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  # The current implementation of #sort_by generates an array of tuples containing
  # the original collection element and the mapped value. This makes #sort_by
  # fairly expensive when the keysets are simple.
  #
  #     require 'benchmark'
  #
  #     a = (1..100000).map { rand(100000) }
  #
  #     Benchmark.bm(10) do |b|
  #       b.report("Sort")    { a.sort }
  #       b.report("Sort by") { a.sort_by { |a| a } }
  #     end
  #
  # *produces:*
  #
  #     user     system      total        real
  #     Sort        0.180000   0.000000   0.180000 (  0.175469)
  #     Sort by     1.980000   0.040000   2.020000 (  2.013586)
  #
  # However, consider the case where comparing the keys is a non-trivial
  # operation. The following code sorts some files on modification time using the
  # basic #sort method.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This sort is inefficient: it generates two new File objects during every
  # comparison. A slightly better technique is to use the Kernel#test method to
  # generate the modification times directly.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b|
  #       test(?M, a) <=> test(?M, b)
  #     }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This still generates many unnecessary Time objects. A more efficient technique
  # is to cache the sort keys (modification times in this case) before the sort.
  # Perl users often call this approach a Schwartzian transform, after Randal
  # Schwartz. We construct a temporary array, where each element is an array
  # containing our sort key along with the filename. We sort this array, and then
  # extract the filename from the result.
  #
  #     sorted = Dir["*"].collect { |f|
  #        [test(?M, f), f]
  #     }.sort.collect { |f| f[1] }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This is exactly what #sort_by does internally.
  #
  #     sorted = Dir["*"].sort_by { |f| test(?M, f) }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # To produce the reverse of a specific order, the following can be used:
  #
  #     ary.sort_by { ... }.reverse!
  #
  def sort_by: () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]
             | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - take(n) -> array
  # -->
  # For non-negative integer `n`, returns the first `n` elements:
  #
  #     r = (1..4)
  #     r.take(2) # => [1, 2]
  #     r.take(0) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.take(2) # => [[:foo, 0], [:bar, 1]]
  #
  def take: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - take_while {|element| ... } -> array
  #   - take_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements up to that point:
  #
  #     (1..4).take_while{|i| i < 3 } # => [1, 2]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.take_while{|element| key, value = *element; value < 2 }
  #     # => [[:foo, 0], [:bar, 1]]
  #
  # With no block given, returns an Enumerator.
  #
  def take_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - to_h -> hash
  #   - to_h {|element| ... }  -> hash
  # -->
  # When `self` consists of 2-element arrays, returns a hash each of whose entries
  # is the key-value pair formed from one of those arrays:
  #
  #     [[:foo, 0], [:bar, 1], [:baz, 2]].to_h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When a block is given, the block is called with each element of `self`; the
  # block should return a 2-element array which becomes a key-value pair in the
  # returned hash:
  #
  #     (0..3).to_h {|i| [i, i ** 2]} # => {0=>0, 1=>1, 2=>4, 3=>9}
  #
  # Raises an exception if an element of `self` is not a 2-element array, and a
  # block is not passed.
  #
  def to_h: () -> ::Hash[untyped, untyped]
          | [T, U] () { (Elem) -> [ T, U ] } -> ::Hash[T, U]

  # <!--
  #   rdoc-file=enum.c
  #   - each_slice(n) { ... }  ->  self
  #   - each_slice(n)          ->  enumerator
  # -->
  # Calls the block with each successive disjoint `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..10).each_slice(3) {|tuple| a.push(tuple) }
  #     a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3, bam: 4}
  #     h.each_slice(2) {|tuple| a.push(tuple) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]], [[:bam, 4]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_slice: (Integer n) { (::Array[Elem]) -> void } -> self
                | (Integer n) -> ::Enumerator[::Array[Elem], self]

  interface _NotFound[T]
    def call: () -> T
  end

  # <!--
  #   rdoc-file=enum.c
  #   - find(if_none_proc = nil) {|element| ... } -> object or nil
  #   - find(if_none_proc = nil) -> enumerator
  # -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def find: () { (Elem) -> boolish } -> Elem?
          | () -> ::Enumerator[Elem, Elem?]
          | [T] (_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
          | [T] (_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  # <!--
  #   rdoc-file=enum.c
  #   - flat_map {|element| ... } -> array
  #   - flat_map -> enumerator
  # -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def flat_map: [U] () { (Elem) -> (Array[U] | U) } -> Array[U]
              | () -> ::Enumerator[Elem, Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def map: [U] () { (Elem arg0) -> U } -> ::Array[U]
         | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - include?(object) -> true or false
  # -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  # Enumerable#member? is an alias for Enumerable#include?.
  #
  def member?: (Elem arg0) -> bool

  # <!-- rdoc-file=enum.c -->
  # Returns an object formed from operands via either:
  #
  # *   A method named by `symbol`.
  # *   A block to which each operand is passed.
  #
  #
  # With method-name argument `symbol`, combines operands using the method:
  #
  #     # Sum, without initial_operand.
  #     (1..4).inject(:+)     # => 10
  #     # Sum, with initial_operand.
  #     (1..4).inject(10, :+) # => 20
  #
  # With a block, passes each operand to the block:
  #
  #     # Sum of squares, without initial_operand.
  #     (1..4).inject {|sum, n| sum + n*n }    # => 30
  #     # Sum of squares, with initial_operand.
  #     (1..4).inject(2) {|sum, n| sum + n*n } # => 32
  #
  # **Operands**
  #
  # If argument `initial_operand` is not given, the operands for `inject` are
  # simply the elements of `self`. Example calls and their operands:
  #
  #     `(1..4).inject(:+)`
  # :       `[1, 2, 3, 4]`.
  #
  #     `(1...4).inject(:+)`
  # :       `[1, 2, 3]`.
  #
  #     `('a'..'d').inject(:+)`
  # :       `['a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject(:+)`
  # :       `['a', 'b', 'c']`.
  #
  #
  #
  # Examples with first operand (which is `self.first`) of various types:
  #
  #     # Integer.
  #     (1..4).inject(:+)                # => 10
  #     # Float.
  #     [1.0, 2, 3, 4].inject(:+)        # => 10.0
  #     # Character.
  #     ('a'..'d').inject(:+)            # => "abcd"
  #     # Complex.
  #     [Complex(1, 2), 3, 4].inject(:+) # => (8+2i)
  #
  # If argument `initial_operand` is given, the operands for `inject` are that
  # value plus the elements of `self`. Example calls their operands:
  #
  #     `(1..4).inject(10, :+)`
  # :       `[10, 1, 2, 3, 4]`.
  #
  #     `(1...4).inject(10, :+)`
  # :       `[10, 1, 2, 3]`.
  #
  #     `('a'..'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c']`.
  #
  #
  #
  # Examples with `initial_operand` of various types:
  #
  #     # Integer.
  #     (1..4).inject(2, :+)               # => 12
  #     # Float.
  #     (1..4).inject(2.0, :+)             # => 12.0
  #     # String.
  #     ('a'..'d').inject('foo', :+)       # => "fooabcd"
  #     # Array.
  #     %w[a b c].inject(['x'], :push)     # => ["x", "a", "b", "c"]
  #     # Complex.
  #     (1..4).inject(Complex(2, 2), :+)   # => (12+2i)
  #
  # **Combination by Given \Method**
  #
  # If the method-name argument `symbol` is given, the operands are combined by
  # that method:
  #
  # *   The first and second operands are combined.
  # *   That result is combined with the third operand.
  # *   That result is combined with the fourth operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the result of the last combination.
  #
  # This call to `inject` computes the sum of the operands:
  #
  #     (1..4).inject(:+) # => 10
  #
  # Examples with various methods:
  #
  #     # Integer addition.
  #     (1..4).inject(:+)                # => 10
  #     # Integer multiplication.
  #     (1..4).inject(:*)                # => 24
  #     # Character range concatenation.
  #     ('a'..'d').inject('', :+)        # => "abcd"
  #     # String array concatenation.
  #     %w[foo bar baz].inject('', :+)   # => "foobarbaz"
  #     # Hash update.
  #     h = [{foo: 0, bar: 1}, {baz: 2}, {bat: 3}].inject(:update)
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #     # Hash conversion to nested arrays.
  #     h = {foo: 0, bar: 1}.inject([], :push)
  #     h # => [[:foo, 0], [:bar, 1]]
  #
  # **Combination by Given Block**
  #
  # If a block is given, the operands are passed to the block:
  #
  # *   The first call passes the first and second operands.
  # *   The second call passes the result of the first call, along with the third
  #     operand.
  # *   The third call passes the result of the second call, along with the fourth
  #     operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the return value from the last block call.
  #
  # This call to `inject` gives a block that writes the memo and element, and also
  # sums the elements:
  #
  #     (1..4).inject do |memo, element|
  #       p "Memo: #{memo}; element: #{element}"
  #       memo + element
  #     end # => 10
  #
  # Output:
  #
  #     "Memo: 1; element: 2"
  #     "Memo: 3; element: 3"
  #     "Memo: 6; element: 4"
  #
  # Enumerable#reduce is an alias for Enumerable#inject.
  #
  alias reduce inject

  # <!--
  #   rdoc-file=enum.c
  #   - to_a -> array
  # -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  # Enumerable#entries is an alias for Enumerable#to_a.
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.lazy -> lazy_enumerator
  # -->
  # Returns an Enumerator::Lazy, which redefines most Enumerable methods to
  # postpone enumeration and enumerate values only on an as-needed basis.
  #
  # ### Example
  #
  # The following program finds pythagorean triples:
  #
  #     def pythagorean_triples
  #       (1..Float::INFINITY).lazy.flat_map {|z|
  #         (1..z).flat_map {|x|
  #           (x..z).select {|y|
  #             x**2 + y**2 == z**2
  #           }.map {|y|
  #             [x, y, z]
  #           }
  #         }
  #       }
  #     end
  #     # show first ten pythagorean triples
  #     p pythagorean_triples.take(10).force # take is lazy, so force is needed
  #     p pythagorean_triples.first(10)      # first is eager
  #     # show pythagorean triples less than 100
  #     p pythagorean_triples.take_while { |*, z| z < 100 }.force
  #
  def lazy: () -> Enumerator::Lazy[Elem, void]

  # <!--
  #   rdoc-file=enum.c
  #   - uniq                  -> array
  #   - uniq {|element| ... } -> array
  # -->
  # With no block, returns a new array containing only unique elements; the array
  # has no two elements `e0` and `e1` such that `e0.eql?(e1)`:
  #
  #     %w[a b c c b a a b c].uniq       # => ["a", "b", "c"]
  #     [0, 1, 2, 2, 1, 0, 0, 1, 2].uniq # => [0, 1, 2]
  #
  # With a block, returns a new array containing only for which the block returns
  # a unique value:
  #
  #     a = [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
  #     a.uniq {|i| i.even? ? i : 0 } # => [0, 2, 4]
  #     a = %w[a b c d e e d c b a a b c d e]
  #     a.uniq {|c| c < 'c' }         # => ["a", "c"]
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sum(initial_value = 0)                  -> number
  #   - sum(initial_value = 0) {|element| ... } -> object
  # -->
  # With no block given, returns the sum of `initial_value` and the elements:
  #
  #     (1..100).sum          # => 5050
  #     (1..100).sum(1)       # => 5051
  #     ('a'..'d').sum('foo') # => "fooabcd"
  #
  # Generally, the sum is computed using methods `+` and `each`; for performance
  # optimizations, those methods may not be used, and so any redefinition of those
  # methods may not have effect here.
  #
  # One such optimization: When possible, computes using Gauss's summation formula
  # *n(n+1)/2*:
  #
  #     100 * (100 + 1) / 2 # => 5050
  #
  # With a block given, calls the block with each element; returns the sum of
  # `initial_value` and the block return values:
  #
  #     (1..4).sum {|i| i*i }                        # => 30
  #     (1..4).sum(100) {|i| i*i }                   # => 130
  #     h = {a: 0, b: 1, c: 2, d: 3, e: 4, f: 5}
  #     h.sum {|key, value| value.odd? ? value : 0 } # => 9
  #     ('a'..'f').sum('x') {|c| c < 'd' ? c : '' }  # => "xabc"
  #
  def sum: () -> (Elem | Integer)
         | [T] () { (Elem arg0) -> T } -> (Integer | T)
         | [T] (?T arg0) -> (Elem | T)
         | [U] (?U arg0) { (Elem arg0) -> U } -> U

  # <!--
  #   rdoc-file=enum.c
  #   - filter_map {|element| ... } -> array
  #   - filter_map -> enumerator
  # -->
  # Returns an array containing truthy elements returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # containing each truthy value returned by the block:
  #
  #     (0..9).filter_map {|i| i * 2 if i.even? }                              # => [0, 4, 8, 12, 16]
  #     {foo: 0, bar: 1, baz: 2}.filter_map {|key, value| key if value.even? } # => [:foo, :baz]
  #
  # When no block given, returns an Enumerator.
  #
  def filter_map: [U] () { (Elem elem) -> (nil | false | U) } -> ::Array[U]
                | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.chain(*enums) -> enumerator
  # -->
  # Returns an enumerator object generated from this enumerator and given
  # enumerables.
  #
  #     e = (1..3).chain([4, 5])
  #     e.to_a #=> [1, 2, 3, 4, 5]
  #
  def chain: (*self enumerables) -> ::Enumerator::Chain[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - tally -> new_hash
  #   - tally(hash) -> hash
  # -->
  # Returns a hash containing the counts of equal elements:
  #
  # *   Each key is an element of `self`.
  # *   Each value is the number elements equal to that key.
  #
  #
  # With no argument:
  #
  #     %w[a b c b c a c b].tally # => {"a"=>2, "b"=>3, "c"=>3}
  #
  # With a hash argument, that hash is used for the tally (instead of a new hash),
  # and is returned; this may be useful for accumulating tallies across multiple
  # enumerables:
  #
  #     hash = {}
  #     hash = %w[a c d b c a].tally(hash)
  #     hash # => {"a"=>2, "c"=>2, "d"=>1, "b"=>1}
  #     hash = %w[b a z].tally(hash)
  #     hash # => {"a"=>3, "c"=>2, "d"=>1, "b"=>2, "z"=>1}
  #     hash = %w[b a m].tally(hash)
  #     hash # => {"a"=>4, "c"=>2, "d"=>1, "b"=>3, "z"=>1, "m"=> 1}
  #
  def tally: (?Hash[Elem, Integer] hash) -> ::Hash[Elem, Integer]

  # <!--
  #   rdoc-file=enum.c
  #   - each_entry(*args) {|element| ... } -> self
  #   - each_entry(*args)                  -> enumerator
  # -->
  # Calls the given block with each element, converting multiple values from yield
  # to an array; returns `self`:
  #
  #     a = []
  #     (1..4).each_entry {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz:2}
  #     h.each_entry {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  #     class Foo
  #       include Enumerable
  #       def each
  #         yield 1
  #         yield 1, 2
  #         yield
  #       end
  #     end
  #     Foo.new.each_entry {|yielded| p yielded }
  #
  # Output:
  #
  #     1
  #     [1, 2]
  #     nil
  #
  # With no block given, returns an Enumerator.
  #
  def each_entry: () -> ::Enumerator[Elem, self]
                | () { (Elem arg0) -> untyped } -> self

  # <!--
  #   rdoc-file=enum.c
  #   - zip(*other_enums) -> array
  #   - zip(*other_enums) {|array| ... } -> nil
  # -->
  # With no block given, returns a new array `new_array` of size self.size whose
  # elements are arrays. Each nested array `new_array[n]` is of size
  # `other_enums.size+1`, and contains:
  #
  # *   The `n`-th element of self.
  # *   The `n`-th element of each of the `other_enums`.
  #
  #
  # If all `other_enums` and self are the same size, all elements are included in
  # the result, and there is no `nil`-filling:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  #     f = {foo: 0, bar: 1, baz: 2}
  #     g = {goo: 3, gar: 4, gaz: 5}
  #     h = {hoo: 6, har: 7, haz: 8}
  #     d = f.zip(g, h)
  #     d # => [
  #       #      [[:foo, 0], [:goo, 3], [:hoo, 6]],
  #       #      [[:bar, 1], [:gar, 4], [:har, 7]],
  #       #      [[:baz, 2], [:gaz, 5], [:haz, 8]]
  #       #    ]
  #
  # If any enumerable in other_enums is smaller than self, fills to `self.size`
  # with `nil`:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
  #
  # If any enumerable in other_enums is larger than self, its trailing elements
  # are ignored:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # When a block is given, calls the block with each of the sub-arrays (formed as
  # above); returns nil:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| p sub_array} # => nil
  #
  # Output:
  #
  #     [:a0, :b0, :c0]
  #     [:a1, :b1, :c1]
  #     [:a2, :b2, :c2]
  #     [:a3, :b3, :c3]
  #
  def zip: [Elem2] (::Enumerable[Elem2] enum) -> ::Array[[ Elem, Elem2 | nil ]]
         | [U, Elem2] (::Enumerable[Elem2]) { ([ Elem, Elem2 | nil ]) -> U } -> nil

  # <!--
  #   rdoc-file=enum.c
  #   - chunk {|array| ... } -> enumerator
  # -->
  # Each element in the returned enumerator is a 2-element array consisting of:
  #
  # *   A value returned by the block.
  # *   An array ("chunk") containing the element for which that value was
  #     returned, and all following elements for which the block returned the same
  #     value:
  #
  #
  # So that:
  #
  # *   Each block return value that is different from its predecessor begins a
  #     new chunk.
  # *   Each block return value that is the same as its predecessor continues the
  #     same chunk.
  #
  #
  # Example:
  #
  #     e = (0..10).chunk {|i| (i / 3).floor } # => #<Enumerator: ...>
  #     # The enumerator elements.
  #     e.next # => [0, [0, 1, 2]]
  #     e.next # => [1, [3, 4, 5]]
  #     e.next # => [2, [6, 7, 8]]
  #     e.next # => [3, [9, 10]]
  #
  # Method `chunk` is especially useful for an enumerable that is already sorted.
  # This example counts words for each initial letter in a large array of words:
  #
  #     # Get sorted words from a web page.
  #     url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
  #     words = URI::open(url).readlines
  #     # Make chunks, one for each letter.
  #     e = words.chunk {|word| word.upcase[0] } # => #<Enumerator: ...>
  #     # Display 'A' through 'F'.
  #     e.each {|c, words| p [c, words.length]; break if c == 'F' }
  #
  # Output:
  #
  #     ["A", 17096]
  #     ["B", 11070]
  #     ["C", 19901]
  #     ["D", 10896]
  #     ["E", 8736]
  #     ["F", 6860]
  #
  # You can use the special symbol `:_alone` to force an element into its own
  # separate chuck:
  #
  #     a = [0, 0, 1, 1]
  #     e = a.chunk{|i| i.even? ? :_alone : true }
  #     e.to_a # => [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]
  #
  # For example, you can put each line that contains a URL into its own chunk:
  #
  #     pattern = /http/
  #     open(filename) { |f|
  #       f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
  #         pp lines
  #       }
  #     }
  #
  # You can use the special symbol `:_separator` or `nil` to force an element to
  # be ignored (not included in any chunk):
  #
  #     a = [0, 0, -1, 1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1, 1]]]
  #
  # Note that the separator does end the chunk:
  #
  #     a = [0, 0, -1, 1, -1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1]], [true, [1]]]
  #
  # For example, the sequence of hyphens in svn log can be eliminated as follows:
  #
  #     sep = "-"*72 + "\n"
  #     IO.popen("svn log README") { |f|
  #       f.chunk { |line|
  #         line != sep || nil
  #       }.each { |_, lines|
  #         pp lines
  #       }
  #     }
  #     #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Update the portability section.\n",
  #     #    "\n"]
  #     #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Add a note about default C flags.\n",
  #     #    "\n"]
  #     #   ...
  #
  # Paragraphs separated by empty lines can be parsed as follows:
  #
  #     File.foreach("README").chunk { |line|
  #       /\A\s*\z/ !~ line || nil
  #     }.each { |_, lines|
  #       pp lines
  #     }
  #
  def chunk: [U] () { (Elem elt) -> U } -> ::Enumerator[[ U, ::Array[Elem] ], void]
           | () -> ::Enumerator[Elem, ::Enumerator[[ untyped, ::Array[Elem] ], void]]

  # <!--
  #   rdoc-file=enum.c
  #   - chunk_while {|element, next_element| ... } -> enumerator
  # -->
  # The returned Enumerator uses the block to partition elements into arrays
  # ("chunks"); it calls the block with each element and its successor; begins a
  # new chunk if and only if the block returns a truthy value:
  #
  # Example:
  #
  #     a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
  #     e = a.chunk_while {|i, j| j == i + 1 }
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1, 2]
  #     [4]
  #     [9, 10, 11, 12]
  #     [15, 16]
  #     [19, 20, 21]
  #
  def chunk_while: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_when {|element, next_element| ... } -> enumerator
  # -->
  # The returned enumerator uses the block to partition elements into arrays
  # ("slices"); it calls the block with each element and its successor; begins a
  # new slice if and only if the block returns a truthy value:
  #
  #     a = [0, 1, 2, 4, 5, 6, 8, 9]
  #     e = a.slice_when {|i, j| j != i + 1 }
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [0, 1, 2]
  #     [4, 5, 6]
  #     [8, 9]
  #
  def slice_when: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_after(pattern)       -> enumerator
  #   - slice_after {|array| ... } -> enumerator
  # -->
  # With argument `pattern`, returns an enumerator that uses the pattern to
  # partition elements into arrays ("slices"). An element ends the current slice
  # if `element === pattern`:
  #
  #     a = %w[foo bar fop for baz fob fog bam foy]
  #     e = a.slice_after(/ba/) # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     ["foo", "bar"]
  #     ["fop", "for", "baz"]
  #     ["fob", "fog", "bam"]
  #     ["foy"]
  #
  # With a block, returns an enumerator that uses the block to partition elements
  # into arrays. An element ends the current slice if its block return is a truthy
  # value:
  #
  #     e = (1..20).slice_after {|i| i % 4 == 2 } # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1, 2]
  #     [3, 4, 5, 6]
  #     [7, 8, 9, 10]
  #     [11, 12, 13, 14]
  #     [15, 16, 17, 18]
  #     [19, 20]
  #
  # Other methods of the Enumerator class and Enumerable module, such as `map`,
  # etc., are also usable.
  #
  # For example, continuation lines (lines end with backslash) can be concatenated
  # as follows:
  #
  #     lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
  #     e = lines.slice_after(/(?<!\\)\n\z/)
  #     p e.to_a
  #     #=> [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
  #     p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
  #     #=>["foo\n", "barbaz\n", "\n", "qux\n"]
  #
  def slice_after: (untyped pattern) -> ::Enumerator[::Array[Elem], void]
                 | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_before(pattern)       -> enumerator
  #   - slice_before {|array| ... } -> enumerator
  # -->
  # With argument `pattern`, returns an enumerator that uses the pattern to
  # partition elements into arrays ("slices"). An element begins a new slice if
  # `element === pattern` (or if it is the first element).
  #
  #     a = %w[foo bar fop for baz fob fog bam foy]
  #     e = a.slice_before(/ba/) # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     ["foo"]
  #     ["bar", "fop", "for"]
  #     ["baz", "fob", "fog"]
  #     ["bam", "foy"]
  #
  # With a block, returns an enumerator that uses the block to partition elements
  # into arrays. An element begins a new slice if its block return is a truthy
  # value (or if it is the first element):
  #
  #     e = (1..20).slice_before {|i| i % 4 == 2 } # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1]
  #     [2, 3, 4, 5]
  #     [6, 7, 8, 9]
  #     [10, 11, 12, 13]
  #     [14, 15, 16, 17]
  #     [18, 19, 20]
  #
  # Other methods of the Enumerator class and Enumerable module, such as `to_a`,
  # `map`, etc., are also usable.
  #
  # For example, iteration over ChangeLog entries can be implemented as follows:
  #
  #     # iterate over ChangeLog entries.
  #     open("ChangeLog") { |f|
  #       f.slice_before(/\A\S/).each { |e| pp e }
  #     }
  #
  #     # same as above.  block is used instead of pattern argument.
  #     open("ChangeLog") { |f|
  #       f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
  #     }
  #
  # "svn proplist -R" produces multiline output for each file. They can be chunked
  # as follows:
  #
  #     IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
  #       f.lines.slice_before(/\AProp/).each { |lines| p lines }
  #     }
  #     #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
  #     #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
  #     #   ...
  #
  # If the block needs to maintain state over multiple elements, local variables
  # can be used. For example, three or more consecutive increasing numbers can be
  # squashed as follows (see `chunk_while` for a better way):
  #
  #     a = [0, 2, 3, 4, 6, 7, 9]
  #     prev = a[0]
  #     p a.slice_before { |e|
  #       prev, prev2 = e, prev
  #       prev2 + 1 != e
  #     }.map { |es|
  #       es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
  #     }.join(",")
  #     #=> "0,2-4,6,7,9"
  #
  # However local variables should be used carefully if the result enumerator is
  # enumerated twice or more. The local variables should be initialized for each
  # enumeration. Enumerator.new can be used to do it.
  #
  #     # Word wrapping.  This assumes all characters have same width.
  #     def wordwrap(words, maxwidth)
  #       Enumerator.new {|y|
  #         # cols is initialized in Enumerator.new.
  #         cols = 0
  #         words.slice_before { |w|
  #           cols += 1 if cols != 0
  #           cols += w.length
  #           if maxwidth < cols
  #             cols = w.length
  #             true
  #           else
  #             false
  #           end
  #         }.each {|ws| y.yield ws }
  #       }
  #     end
  #     text = (1..20).to_a.join(" ")
  #     enum = wordwrap(text.split(/\s+/), 10)
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # first enumeration.
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
  #     puts "-"*10
  #     #=> ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #
  # mbox contains series of mails which start with Unix From line. So each mail
  # can be extracted by slice before Unix From line.
  #
  #     # parse mbox
  #     open("mbox") { |f|
  #       f.slice_before { |line|
  #         line.start_with? "From "
  #       }.each { |mail|
  #         unix_from = mail.shift
  #         i = mail.index("\n")
  #         header = mail[0...i]
  #         body = mail[(i+1)..-1]
  #         body.pop if body.last == "\n"
  #         fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
  #         p unix_from
  #         pp fields
  #         pp body
  #       }
  #     }
  #
  #     # split mails in mbox (slice before Unix From line after an empty line)
  #     open("mbox") { |f|
  #       emp = true
  #       f.slice_before { |line|
  #         prevemp = emp
  #         emp = line == "\n"
  #         prevemp && line.start_with?("From ")
  #       }.each { |mail|
  #         mail.pop if mail.last == "\n"
  #         pp mail
  #       }
  #     }
  #
  def slice_before: (untyped pattern) -> ::Enumerator[::Array[Elem], void]
                  | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem], void]
end

# <!-- rdoc-file=error.c -->
# Ruby exception objects are subclasses of Exception.  However, operating
# systems typically report errors using plain integers. Module Errno is created
# dynamically to map these operating system errors to Ruby classes, with each
# error number generating its own subclass of SystemCallError.  As the subclass
# is created in module Errno, its name will start `Errno::`.
#
# The names of the `Errno::` classes depend on the environment in which Ruby
# runs. On a typical Unix or Windows platform, there are Errno classes such as
# Errno::EACCES, Errno::EAGAIN, Errno::EINTR, and so on.
#
# The integer operating system error number corresponding to a particular error
# is available as the class constant `Errno::`*error*`::Errno`.
#
#     Errno::EACCES::Errno   #=> 13
#     Errno::EAGAIN::Errno   #=> 11
#     Errno::EINTR::Errno    #=> 4
#
# The full list of operating system errors on your particular platform are
# available as the constants of Errno.
#
#     Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...
#
module Errno
end

class Errno::E2BIG < SystemCallError
end

Errno::E2BIG::Errno: Integer

class Errno::EACCES < SystemCallError
end

Errno::EACCES::Errno: Integer

class Errno::EADDRINUSE < SystemCallError
end

Errno::EADDRINUSE::Errno: Integer

class Errno::EADDRNOTAVAIL < SystemCallError
end

Errno::EADDRNOTAVAIL::Errno: Integer

class Errno::EADV < SystemCallError
end

Errno::EADV::Errno: Integer

class Errno::EAFNOSUPPORT < SystemCallError
end

Errno::EAFNOSUPPORT::Errno: Integer

class Errno::EAGAIN < SystemCallError
end

Errno::EAGAIN::Errno: Integer

class Errno::EALREADY < SystemCallError
end

Errno::EALREADY::Errno: Integer

class Errno::EAUTH < SystemCallError
end

Errno::EAUTH::Errno: Integer

class Errno::EBADE < SystemCallError
end

Errno::EBADE::Errno: Integer

class Errno::EBADF < SystemCallError
end

Errno::EBADF::Errno: Integer

class Errno::EBADFD < SystemCallError
end

Errno::EBADFD::Errno: Integer

class Errno::EBADMSG < SystemCallError
end

Errno::EBADMSG::Errno: Integer

class Errno::EBADR < SystemCallError
end

Errno::EBADR::Errno: Integer

class Errno::EBADRPC < SystemCallError
end

Errno::EBADRPC::Errno: Integer

class Errno::EBADRQC < SystemCallError
end

Errno::EBADRQC::Errno: Integer

class Errno::EBADSLT < SystemCallError
end

Errno::EBADSLT::Errno: Integer

class Errno::EBFONT < SystemCallError
end

Errno::EBFONT::Errno: Integer

class Errno::EBUSY < SystemCallError
end

Errno::EBUSY::Errno: Integer

class Errno::ECANCELED < SystemCallError
end

Errno::ECANCELED::Errno: Integer

class Errno::ECAPMODE < SystemCallError
end

Errno::ECAPMODE::Errno: Integer

class Errno::ECHILD < SystemCallError
end

Errno::ECHILD::Errno: Integer

class Errno::ECHRNG < SystemCallError
end

Errno::ECHRNG::Errno: Integer

class Errno::ECOMM < SystemCallError
end

Errno::ECOMM::Errno: Integer

# Client sent TCP reset (RST) before server has accepted the connection
# requested by client.
#
class Errno::ECONNABORTED < SystemCallError
end

Errno::ECONNABORTED::Errno: Integer

class Errno::ECONNREFUSED < SystemCallError
end

Errno::ECONNREFUSED::Errno: Integer

# Remote host reset the connection request.
#
class Errno::ECONNRESET < SystemCallError
end

Errno::ECONNRESET::Errno: Integer

class Errno::EDEADLK < SystemCallError
end

Errno::EDEADLK::Errno: Integer

class Errno::EDEADLOCK < SystemCallError
end

Errno::EDEADLOCK::Errno: Integer

class Errno::EDESTADDRREQ < SystemCallError
end

Errno::EDESTADDRREQ::Errno: Integer

class Errno::EDOM < SystemCallError
end

Errno::EDOM::Errno: Integer

class Errno::EDOOFUS < SystemCallError
end

Errno::EDOOFUS::Errno: Integer

class Errno::EDOTDOT < SystemCallError
end

Errno::EDOTDOT::Errno: Integer

class Errno::EDQUOT < SystemCallError
end

Errno::EDQUOT::Errno: Integer

class Errno::EEXIST < SystemCallError
end

Errno::EEXIST::Errno: Integer

class Errno::EFAULT < SystemCallError
end

Errno::EFAULT::Errno: Integer

class Errno::EFBIG < SystemCallError
end

Errno::EFBIG::Errno: Integer

class Errno::EFTYPE < SystemCallError
end

Errno::EFTYPE::Errno: Integer

class Errno::EHOSTDOWN < SystemCallError
end

Errno::EHOSTDOWN::Errno: Integer

class Errno::EHOSTUNREACH < SystemCallError
end

Errno::EHOSTUNREACH::Errno: Integer

class Errno::EHWPOISON < SystemCallError
end

Errno::EHWPOISON::Errno: Integer

class Errno::EIDRM < SystemCallError
end

Errno::EIDRM::Errno: Integer

class Errno::EILSEQ < SystemCallError
end

Errno::EILSEQ::Errno: Integer

class Errno::EINPROGRESS < SystemCallError
end

Errno::EINPROGRESS::Errno: Integer

class Errno::EINTR < SystemCallError
end

Errno::EINTR::Errno: Integer

class Errno::EINVAL < SystemCallError
end

Errno::EINVAL::Errno: Integer

class Errno::EIO < SystemCallError
end

Errno::EIO::Errno: Integer

class Errno::EIPSEC < SystemCallError
end

Errno::EIPSEC::Errno: Integer

class Errno::EISCONN < SystemCallError
end

Errno::EISCONN::Errno: Integer

class Errno::EISDIR < SystemCallError
end

Errno::EISDIR::Errno: Integer

class Errno::EISNAM < SystemCallError
end

Errno::EISNAM::Errno: Integer

class Errno::EKEYEXPIRED < SystemCallError
end

Errno::EKEYEXPIRED::Errno: Integer

class Errno::EKEYREJECTED < SystemCallError
end

Errno::EKEYREJECTED::Errno: Integer

class Errno::EKEYREVOKED < SystemCallError
end

Errno::EKEYREVOKED::Errno: Integer

class Errno::EL2HLT < SystemCallError
end

Errno::EL2HLT::Errno: Integer

class Errno::EL2NSYNC < SystemCallError
end

Errno::EL2NSYNC::Errno: Integer

class Errno::EL3HLT < SystemCallError
end

Errno::EL3HLT::Errno: Integer

class Errno::EL3RST < SystemCallError
end

Errno::EL3RST::Errno: Integer

class Errno::ELIBACC < SystemCallError
end

Errno::ELIBACC::Errno: Integer

class Errno::ELIBBAD < SystemCallError
end

Errno::ELIBBAD::Errno: Integer

class Errno::ELIBEXEC < SystemCallError
end

Errno::ELIBEXEC::Errno: Integer

class Errno::ELIBMAX < SystemCallError
end

Errno::ELIBMAX::Errno: Integer

class Errno::ELIBSCN < SystemCallError
end

Errno::ELIBSCN::Errno: Integer

class Errno::ELNRNG < SystemCallError
end

Errno::ELNRNG::Errno: Integer

class Errno::ELOOP < SystemCallError
end

Errno::ELOOP::Errno: Integer

class Errno::EMEDIUMTYPE < SystemCallError
end

Errno::EMEDIUMTYPE::Errno: Integer

class Errno::EMFILE < SystemCallError
end

Errno::EMFILE::Errno: Integer

class Errno::EMLINK < SystemCallError
end

Errno::EMLINK::Errno: Integer

class Errno::EMSGSIZE < SystemCallError
end

Errno::EMSGSIZE::Errno: Integer

class Errno::EMULTIHOP < SystemCallError
end

Errno::EMULTIHOP::Errno: Integer

class Errno::ENAMETOOLONG < SystemCallError
end

Errno::ENAMETOOLONG::Errno: Integer

class Errno::ENAVAIL < SystemCallError
end

Errno::ENAVAIL::Errno: Integer

class Errno::ENEEDAUTH < SystemCallError
end

Errno::ENEEDAUTH::Errno: Integer

class Errno::ENETDOWN < SystemCallError
end

Errno::ENETDOWN::Errno: Integer

class Errno::ENETRESET < SystemCallError
end

Errno::ENETRESET::Errno: Integer

class Errno::ENETUNREACH < SystemCallError
end

Errno::ENETUNREACH::Errno: Integer

class Errno::ENFILE < SystemCallError
end

Errno::ENFILE::Errno: Integer

class Errno::ENOANO < SystemCallError
end

Errno::ENOANO::Errno: Integer

class Errno::ENOATTR < SystemCallError
end

Errno::ENOATTR::Errno: Integer

class Errno::ENOBUFS < SystemCallError
end

Errno::ENOBUFS::Errno: Integer

class Errno::ENOCSI < SystemCallError
end

Errno::ENOCSI::Errno: Integer

class Errno::ENODATA < SystemCallError
end

Errno::ENODATA::Errno: Integer

class Errno::ENODEV < SystemCallError
end

Errno::ENODEV::Errno: Integer

class Errno::ENOENT < SystemCallError
end

Errno::ENOENT::Errno: Integer

class Errno::ENOEXEC < SystemCallError
end

Errno::ENOEXEC::Errno: Integer

class Errno::ENOKEY < SystemCallError
end

Errno::ENOKEY::Errno: Integer

class Errno::ENOLCK < SystemCallError
end

Errno::ENOLCK::Errno: Integer

class Errno::ENOLINK < SystemCallError
end

Errno::ENOLINK::Errno: Integer

class Errno::ENOMEDIUM < SystemCallError
end

Errno::ENOMEDIUM::Errno: Integer

class Errno::ENOMEM < SystemCallError
end

Errno::ENOMEM::Errno: Integer

class Errno::ENOMSG < SystemCallError
end

Errno::ENOMSG::Errno: Integer

class Errno::ENONET < SystemCallError
end

Errno::ENONET::Errno: Integer

class Errno::ENOPKG < SystemCallError
end

Errno::ENOPKG::Errno: Integer

class Errno::ENOPROTOOPT < SystemCallError
end

Errno::ENOPROTOOPT::Errno: Integer

class Errno::ENOSPC < SystemCallError
end

Errno::ENOSPC::Errno: Integer

class Errno::ENOSR < SystemCallError
end

Errno::ENOSR::Errno: Integer

class Errno::ENOSTR < SystemCallError
end

Errno::ENOSTR::Errno: Integer

class Errno::ENOSYS < SystemCallError
end

Errno::ENOSYS::Errno: Integer

class Errno::ENOTBLK < SystemCallError
end

Errno::ENOTBLK::Errno: Integer

class Errno::ENOTCAPABLE < SystemCallError
end

Errno::ENOTCAPABLE::Errno: Integer

class Errno::ENOTCONN < SystemCallError
end

Errno::ENOTCONN::Errno: Integer

class Errno::ENOTDIR < SystemCallError
end

Errno::ENOTDIR::Errno: Integer

class Errno::ENOTEMPTY < SystemCallError
end

Errno::ENOTEMPTY::Errno: Integer

class Errno::ENOTNAM < SystemCallError
end

Errno::ENOTNAM::Errno: Integer

class Errno::ENOTRECOVERABLE < SystemCallError
end

Errno::ENOTRECOVERABLE::Errno: Integer

class Errno::ENOTSOCK < SystemCallError
end

Errno::ENOTSOCK::Errno: Integer

class Errno::ENOTSUP < SystemCallError
end

Errno::ENOTSUP::Errno: Integer

class Errno::ENOTTY < SystemCallError
end

Errno::ENOTTY::Errno: Integer

class Errno::ENOTUNIQ < SystemCallError
end

Errno::ENOTUNIQ::Errno: Integer

class Errno::ENXIO < SystemCallError
end

Errno::ENXIO::Errno: Integer

class Errno::EOPNOTSUPP < SystemCallError
end

Errno::EOPNOTSUPP::Errno: Integer

class Errno::EOVERFLOW < SystemCallError
end

Errno::EOVERFLOW::Errno: Integer

class Errno::EOWNERDEAD < SystemCallError
end

Errno::EOWNERDEAD::Errno: Integer

class Errno::EPERM < SystemCallError
end

Errno::EPERM::Errno: Integer

class Errno::EPFNOSUPPORT < SystemCallError
end

Errno::EPFNOSUPPORT::Errno: Integer

class Errno::EPIPE < SystemCallError
end

Errno::EPIPE::Errno: Integer

class Errno::EPROCLIM < SystemCallError
end

Errno::EPROCLIM::Errno: Integer

class Errno::EPROCUNAVAIL < SystemCallError
end

Errno::EPROCUNAVAIL::Errno: Integer

class Errno::EPROGMISMATCH < SystemCallError
end

Errno::EPROGMISMATCH::Errno: Integer

class Errno::EPROGUNAVAIL < SystemCallError
end

Errno::EPROGUNAVAIL::Errno: Integer

# Protocol error.
#
class Errno::EPROTO < SystemCallError
end

Errno::EPROTO::Errno: Integer

class Errno::EPROTONOSUPPORT < SystemCallError
end

Errno::EPROTONOSUPPORT::Errno: Integer

class Errno::EPROTOTYPE < SystemCallError
end

Errno::EPROTOTYPE::Errno: Integer

class Errno::ERANGE < SystemCallError
end

Errno::ERANGE::Errno: Integer

class Errno::EREMCHG < SystemCallError
end

Errno::EREMCHG::Errno: Integer

class Errno::EREMOTE < SystemCallError
end

Errno::EREMOTE::Errno: Integer

class Errno::EREMOTEIO < SystemCallError
end

Errno::EREMOTEIO::Errno: Integer

class Errno::ERESTART < SystemCallError
end

Errno::ERESTART::Errno: Integer

class Errno::ERFKILL < SystemCallError
end

Errno::ERFKILL::Errno: Integer

class Errno::EROFS < SystemCallError
end

Errno::EROFS::Errno: Integer

class Errno::ERPCMISMATCH < SystemCallError
end

Errno::ERPCMISMATCH::Errno: Integer

class Errno::ESHUTDOWN < SystemCallError
end

Errno::ESHUTDOWN::Errno: Integer

class Errno::ESOCKTNOSUPPORT < SystemCallError
end

Errno::ESOCKTNOSUPPORT::Errno: Integer

class Errno::ESPIPE < SystemCallError
end

Errno::ESPIPE::Errno: Integer

class Errno::ESRCH < SystemCallError
end

Errno::ESRCH::Errno: Integer

class Errno::ESRMNT < SystemCallError
end

Errno::ESRMNT::Errno: Integer

class Errno::ESTALE < SystemCallError
end

Errno::ESTALE::Errno: Integer

class Errno::ESTRPIPE < SystemCallError
end

Errno::ESTRPIPE::Errno: Integer

class Errno::ETIME < SystemCallError
end

Errno::ETIME::Errno: Integer

class Errno::ETIMEDOUT < SystemCallError
end

Errno::ETIMEDOUT::Errno: Integer

class Errno::ETOOMANYREFS < SystemCallError
end

Errno::ETOOMANYREFS::Errno: Integer

class Errno::ETXTBSY < SystemCallError
end

Errno::ETXTBSY::Errno: Integer

class Errno::EUCLEAN < SystemCallError
end

Errno::EUCLEAN::Errno: Integer

class Errno::EUNATCH < SystemCallError
end

Errno::EUNATCH::Errno: Integer

class Errno::EUSERS < SystemCallError
end

Errno::EUSERS::Errno: Integer

class Errno::EWOULDBLOCK < SystemCallError
end

Errno::EWOULDBLOCK::Errno: Integer

class Errno::EXDEV < SystemCallError
end

Errno::EXDEV::Errno: Integer

class Errno::EXFULL < SystemCallError
end

Errno::EXFULL::Errno: Integer

# <!-- rdoc-file=dir.rb -->
# Objects of class Dir are directory streams representing directories in the
# underlying file system. They provide a variety of ways to list directories and
# their contents. See also File.
#
# The directory used in these examples contains the two regular files
# (`config.h` and `main.rb`), the parent directory (`..`), and the directory
# itself (`.`).
#
# ## What's Here
#
# First, what's elsewhere. Class Dir:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Dir provides methods that are useful for:
#
# *   [Reading](#class-Dir-label-Reading)
# *   [Setting](#class-Dir-label-Setting)
# *   [Querying](#class-Dir-label-Querying)
# *   [Iterating](#class-Dir-label-Iterating)
# *   [Other](#class-Dir-label-Other)
#
#
# ### Reading
#
#     #close
# :       Closes the directory stream for `self`.
#
#     #pos=
# :       Sets the position in the directory stream for `self`.
#
#     #read
# :       Reads and returns the next entry in the directory stream for `self`.
#
#     #rewind
# :       Sets the position in the directory stream for `self` to the first
#         entry.
#
#     #seek
# :       Sets the position in the directory stream for `self` the entry at the
#         given offset.
#
#
#
# ### Setting
#
#     ::chdir
# :       Changes the working directory of the current process to the given
#         directory.
#
#     ::chroot
# :       Changes the file-system root for the current process to the given
#         directory.
#
#
#
# ### Querying
#
#     ::[]
# :       Same as ::glob without the ability to pass flags.
#
#     ::children
# :       Returns an array of names of the children (both files and directories)
#         of the given directory, but not including `.` or `..`.
#
#     ::empty?
# :       Returns whether the given path is an empty directory.
#
#     ::entries
# :       Returns an array of names of the children (both files and directories)
#         of the given directory, including `.` and `..`.
#
#     ::exist?
# :       Returns whether the given path is a directory.
#
#     ::getwd (aliased as #pwd)
# :       Returns the path to the current working directory.
#
#     ::glob
# :       Returns an array of file paths matching the given pattern and flags.
#
#     ::home
# :       Returns the home directory path for a given user or the current user.
#
#     #children
# :       Returns an array of names of the children (both files and directories)
#         of `self`, but not including `.` or `..`.
#
#     #fileno
# :       Returns the integer file descriptor for `self`.
#
#     #path (aliased as #to_path)
# :       Returns the path used to create `self`.
#
#     #tell (aliased as #pos)
# :       Returns the integer position in the directory stream for `self`.
#
#
#
# ### Iterating
#
#     ::each_child
# :       Calls the given block with each entry in the given directory, but not
#         including `.` or `..`.
#
#     ::foreach
# :       Calls the given block with each entryin the given directory, including
#         `.` and `..`.
#
#     #each
# :       Calls the given block with each entry in `self`, including `.` and
#         `..`.
#
#     #each_child
# :       Calls the given block with each entry in `self`, but not including `.`
#         or `..`.
#
#
#
# ### Other
#
#     ::mkdir
# :       Creates a directory at the given path, with optional permissions.
#
#     ::new
# :       Returns a new Dir for the given path, with optional encoding.
#
#     ::open
# :       Same as ::new, but if a block is given, yields the Dir to the block,
#         closing it upon block exit.
#
#     ::unlink (aliased as ::delete and ::rmdir)
# :       Removes the given directory.
#
#     #inspect
# :       Returns a string description of `self`.
#
class Dir
  include Enumerable[String]

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.new( string ) -> aDir
  #   - Dir.new( string, encoding: enc ) -> aDir
  # -->
  # Returns a new directory object for the named directory.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  def initialize: (string, ?encoding: encoding | nil) -> void

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir[ string [, string ...] [, base: path] [, sort: true] ] -> array
  # -->
  # Equivalent to calling `Dir.glob([`*string,...*`], 0)`.
  #
  def self.[]: (*string patterns, ?base: string) ?{ (String path) -> void } -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chdir( [ string] ) -> 0
  #   - Dir.chdir( [ string] ) {| path | block }  -> anObject
  # -->
  # Changes the current working directory of the process to the given string. When
  # called without an argument, changes the directory to the value of the
  # environment variable `HOME`, or `LOGDIR`. SystemCallError (probably
  # Errno::ENOENT) if the target directory does not exist.
  #
  # If a block is given, it is passed the name of the new current directory, and
  # the block is executed with that as the current directory. The original working
  # directory is restored when the block exits. The return value of `chdir` is the
  # value of the block. `chdir` blocks can be nested, but in a multi-threaded
  # program an error will be raised if a thread attempts to open a `chdir` block
  # while another thread has one open or a call to `chdir` without a block occurs
  # inside a block passed to `chdir` (even in the same thread).
  #
  #     Dir.chdir("/var/spool/mail")
  #     puts Dir.pwd
  #     Dir.chdir("/tmp") do
  #       puts Dir.pwd
  #       Dir.chdir("/usr") do
  #         puts Dir.pwd
  #       end
  #       puts Dir.pwd
  #     end
  #     puts Dir.pwd
  #
  # *produces:*
  #
  #     /var/spool/mail
  #     /tmp
  #     /usr
  #     /tmp
  #     /var/spool/mail
  #
  def self.chdir: (?string) -> void
                | [U] (?string) { (String) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.children( dirname )                -> array
  #   - Dir.children( dirname, encoding: enc ) -> array
  # -->
  # Returns an array containing all of the filenames except for "." and ".." in
  # the given directory. Will raise a SystemCallError if the named directory
  # doesn't exist.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  #     Dir.children("testdir")   #=> ["config.h", "main.rb"]
  #
  def self.children: (string dirname, ?encoding: string | Encoding | nil enc) -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chroot( string ) -> 0
  # -->
  # Changes this process's idea of the file system root. Only a privileged process
  # may make this call. Not available on all platforms. On Unix systems, see
  # `chroot(2)` for more information.
  #
  def self.chroot: (string) -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  def self.delete: (string) -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.each_child( dirname ) {| filename | block }                 -> nil
  #   - Dir.each_child( dirname, encoding: enc ) {| filename | block }  -> nil
  #   - Dir.each_child( dirname )                                       -> an_enumerator
  #   - Dir.each_child( dirname, encoding: enc )                        -> an_enumerator
  # -->
  # Calls the block once for each entry except for "." and ".." in the named
  # directory, passing the filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     Dir.each_child("testdir") {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got config.h
  #     Got main.rb
  #
  def self.each_child: (string dirname, ?encoding: string | Encoding | nil enc) -> Enumerator[String, void]
                     | (string dirname, ?encoding: string | Encoding | nil enc) { (String filename) -> void } -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.empty?(path_name)  ->  true or false
  # -->
  # Returns `true` if the named file is an empty directory, `false` if it is not a
  # directory or non-empty.
  #
  def self.empty?: (string path_name) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.entries( dirname )                -> array
  #   - Dir.entries( dirname, encoding: enc ) -> array
  # -->
  # Returns an array containing all of the filenames in the given directory. Will
  # raise a SystemCallError if the named directory doesn't exist.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  #     Dir.entries("testdir")   #=> [".", "..", "config.h", "main.rb"]
  #
  def self.entries: (string dirname, ?encoding: encoding | nil enc) -> ::Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.exist?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, `false` otherwise.
  #
  def self.exist?: (string file) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.foreach( dirname ) {| filename | block }                 -> nil
  #   - Dir.foreach( dirname, encoding: enc ) {| filename | block }  -> nil
  #   - Dir.foreach( dirname )                                       -> an_enumerator
  #   - Dir.foreach( dirname, encoding: enc )                        -> an_enumerator
  # -->
  # Calls the block once for each entry in the named directory, passing the
  # filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     Dir.foreach("testdir") {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got .
  #     Got ..
  #     Got config.h
  #     Got main.rb
  #
  alias self.foreach self.each_child

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.getwd -> string
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory of this process as a string.
  #
  #     Dir.chdir("/tmp")   #=> 0
  #     Dir.getwd           #=> "/tmp"
  #     Dir.pwd             #=> "/tmp"
  #
  def self.getwd: () -> String

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.glob( pattern, [flags], [base: path] [, sort: true] )                       -> array
  #   - Dir.glob( pattern, [flags], [base: path] [, sort: true] ) { |filename| block }  -> nil
  # -->
  # Expands `pattern`, which is a pattern string or an Array of pattern strings,
  # and returns an array containing the matching filenames. If a block is given,
  # calls the block once for each matching filename, passing the filename as a
  # parameter to the block.
  #
  # The optional `base` keyword argument specifies the base directory for
  # interpreting relative pathnames instead of the current working directory. As
  # the results are not prefixed with the base directory name in this case, you
  # will need to prepend the base directory name if you want real paths.
  #
  # The results which matched single wildcard or character set are sorted in
  # binary ascending order, unless `false` is given as the optional `sort` keyword
  # argument.  The order of an Array of pattern strings and braces are preserved.
  #
  # Note that the pattern is not a regexp, it's closer to a shell glob. See
  # File::fnmatch for the meaning of the `flags` parameter. Case sensitivity
  # depends on your system (`File::FNM_CASEFOLD` is ignored).
  #
  # `*`
  # :   Matches any file. Can be restricted by other values in the glob.
  #     Equivalent to `/.*/mx` in regexp.
  #
  #     `*`
  # :       Matches all files
  #     `c*`
  # :       Matches all files beginning with `c`
  #     `*c`
  # :       Matches all files ending with `c`
  #     `*c*`
  # :       Match all files that have `c` in them (including at the beginning or
  #         end).
  #
  #
  #     Note, this will not match Unix-like hidden files (dotfiles).  In order to
  #     include those in the match results, you must use the File::FNM_DOTMATCH
  #     flag or something like `"{*,.*}"`.
  #
  # `**`
  # :   Matches directories recursively if followed by `/`.  If this path segment
  #     contains any other characters, it is the same as the usual `*`.
  #
  # `?`
  # :   Matches any one character. Equivalent to `/.{1}/` in regexp.
  #
  # `[set]`
  # :   Matches any one character in `set`.  Behaves exactly like character sets
  #     in Regexp, including set negation (`[^a-z]`).
  #
  # `{p,q}`
  # :   Matches either literal `p` or literal `q`. Equivalent to pattern
  #     alternation in regexp.
  #
  #     Matching literals may be more than one character in length.  More than two
  #     literals may be specified.
  #
  # `\`
  # :   Escapes the next metacharacter.
  #
  #     Note that this means you cannot use backslash on windows as part of a
  #     glob, i.e.  `Dir["c:\\foo*"]` will not work, use `Dir["c:/foo*"]` instead.
  #
  #
  # Examples:
  #
  #     Dir["config.?"]                     #=> ["config.h"]
  #     Dir.glob("config.?")                #=> ["config.h"]
  #     Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]
  #     Dir.glob("*.[^r]*")                 #=> ["config.h"]
  #     Dir.glob("*.{rb,h}")                #=> ["main.rb", "config.h"]
  #     Dir.glob("*")                       #=> ["config.h", "main.rb"]
  #     Dir.glob("*", File::FNM_DOTMATCH)   #=> [".", "..", "config.h", "main.rb"]
  #     Dir.glob(["*.rb", "*.h"])           #=> ["main.rb", "config.h"]
  #
  #     Dir.glob("**/*.rb")                 #=> ["main.rb",
  #                                         #    "lib/song.rb",
  #                                         #    "lib/song/karaoke.rb"]
  #
  #     Dir.glob("**/*.rb", base: "lib")    #=> ["song.rb",
  #                                         #    "song/karaoke.rb"]
  #
  #     Dir.glob("**/lib")                  #=> ["lib"]
  #
  #     Dir.glob("**/lib/**/*.rb")          #=> ["lib/song.rb",
  #                                         #    "lib/song/karaoke.rb"]
  #
  #     Dir.glob("**/lib/*.rb")             #=> ["lib/song.rb"]
  #
  def self.glob: (string | ::Array[string] pattern, ?Integer flags, ?base: string) -> ::Array[String]
               | (string | ::Array[string] pattern, ?Integer flags, ?base: string) { (String) -> void } -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.home()       -> "/home/me"
  #   - Dir.home("root") -> "/root"
  # -->
  # Returns the home directory of the current user or the named user if given.
  #
  def self.home: (?string user) -> String

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.mkdir( string [, integer] ) -> 0
  # -->
  # Makes a new directory named by *string*, with permissions specified by the
  # optional parameter *anInteger*. The permissions may be modified by the value
  # of File::umask, and are ignored on NT. Raises a SystemCallError if the
  # directory cannot be created. See also the discussion of permissions in the
  # class documentation for File.
  #
  #     Dir.mkdir(File.join(Dir.home, ".foo"), 0700) #=> 0
  #
  def self.mkdir: (string, ?Integer permissions) -> void

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.open( string ) -> aDir
  #   - Dir.open( string, encoding: enc ) -> aDir
  #   - Dir.open( string ) {| aDir | block } -> anObject
  #   - Dir.open( string, encoding: enc ) {| aDir | block } -> anObject
  # -->
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  # With no block, `open` is a synonym for Dir::new. If a block is present, it is
  # passed *aDir* as a parameter. The directory is closed at the end of the block,
  # and Dir::open returns the value of the block.
  #
  def self.open: (string, ?encoding: encoding | nil) -> Dir
               | [U] (string, ?encoding: encoding | nil) { (Dir) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.getwd -> string
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory of this process as a string.
  #
  #     Dir.chdir("/tmp")   #=> 0
  #     Dir.getwd           #=> "/tmp"
  #     Dir.pwd             #=> "/tmp"
  #
  def self.pwd: () -> String

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  alias self.rmdir self.delete

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  alias self.unlink self.delete

  public

  # <!--
  #   rdoc-file=dir.c
  #   - dir.children  -> array
  # -->
  # Returns an array containing all of the filenames except for "." and ".." in
  # this directory.
  #
  #     d = Dir.new("testdir")
  #     d.children   #=> ["config.h", "main.rb"]
  #
  def children: () -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.close -> nil
  # -->
  # Closes the directory stream. Calling this method on closed Dir object is
  # ignored since Ruby 2.3.
  #
  #     d = Dir.new("testdir")
  #     d.close   #=> nil
  #
  def close: () -> void

  # <!--
  #   rdoc-file=dir.c
  #   - dir.each { |filename| block }  -> dir
  #   - dir.each                       -> an_enumerator
  # -->
  # Calls the block once for each entry in this directory, passing the filename of
  # each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     d = Dir.new("testdir")
  #     d.each  {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got .
  #     Got ..
  #     Got config.h
  #     Got main.rb
  #
  def each: () { (String) -> void } -> self
          | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.each_child {| filename | block }  -> dir
  #   - dir.each_child                        -> an_enumerator
  # -->
  # Calls the block once for each entry except for "." and ".." in this directory,
  # passing the filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     d = Dir.new("testdir")
  #     d.each_child  {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got config.h
  #     Got main.rb
  #
  def each_child: () { (String) -> void } -> self
                | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.fileno -> integer
  # -->
  # Returns the file descriptor used in *dir*.
  #
  #     d = Dir.new("..")
  #     d.fileno   #=> 8
  #
  # This method uses dirfd() function defined by POSIX 2008. NotImplementedError
  # is raised on other platforms, such as Windows, which doesn't provide the
  # function.
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.inspect -> string
  # -->
  # Return a string describing this Dir object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=dir.c
  #   - dir.path -> string or nil
  #   - dir.to_path -> string or nil
  # -->
  # Returns the path parameter passed to *dir*'s constructor.
  #
  #     d = Dir.new("..")
  #     d.path   #=> ".."
  #
  def path: () -> String?

  # <!-- rdoc-file=dir.c -->
  # Returns the current position in *dir*. See also Dir#seek.
  #
  #     d = Dir.new("testdir")
  #     d.tell   #=> 0
  #     d.read   #=> "."
  #     d.tell   #=> 12
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.pos = integer  -> integer
  # -->
  # Synonym for Dir#seek, but returns the position parameter.
  #
  #     d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
  #     d.read                   #=> "."
  #     i = d.pos                #=> 12
  #     d.read                   #=> ".."
  #     d.pos = i                #=> 12
  #     d.read                   #=> ".."
  #
  def pos=: (Integer pos) -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.read -> string or nil
  # -->
  # Reads the next entry from *dir* and returns it as a string. Returns `nil` at
  # the end of the stream.
  #
  #     d = Dir.new("testdir")
  #     d.read   #=> "."
  #     d.read   #=> ".."
  #     d.read   #=> "config.h"
  #
  def read: () -> String?

  # <!--
  #   rdoc-file=dir.c
  #   - dir.rewind -> dir
  # -->
  # Repositions *dir* to the first entry.
  #
  #     d = Dir.new("testdir")
  #     d.read     #=> "."
  #     d.rewind   #=> #<Dir:0x401b3fb0>
  #     d.read     #=> "."
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=dir.c
  #   - dir.seek( integer ) -> dir
  # -->
  # Seeks to a particular location in *dir*. *integer* must be a value returned by
  # Dir#tell.
  #
  #     d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
  #     d.read                   #=> "."
  #     i = d.tell               #=> 12
  #     d.read                   #=> ".."
  #     d.seek(i)                #=> #<Dir:0x401b3c40>
  #     d.read                   #=> ".."
  #
  def seek: (Integer) -> self

  # <!--
  #   rdoc-file=dir.c
  #   - dir.pos -> integer
  #   - dir.tell -> integer
  # -->
  # Returns the current position in *dir*. See also Dir#seek.
  #
  #     d = Dir.new("testdir")
  #     d.tell   #=> 0
  #     d.read   #=> "."
  #     d.tell   #=> 12
  #
  def tell: () -> Integer

  # <!-- rdoc-file=dir.c -->
  # Returns the path parameter passed to *dir*'s constructor.
  #
  #     d = Dir.new("..")
  #     d.path   #=> ".."
  #
  alias to_path path
end

# <!-- rdoc-file=object.c -->
# A Module is a collection of methods and constants. The methods in a module may
# be instance methods or module methods. Instance methods appear as methods in a
# class when the module is included, module methods do not. Conversely, module
# methods may be called without creating an encapsulating object, while instance
# methods may not. (See Module#module_function.)
#
# In the descriptions that follow, the parameter *sym* refers to a symbol, which
# is either a quoted string or a Symbol (such as `:name`).
#
#     module Mod
#       include Math
#       CONST = 1
#       def meth
#         #  ...
#       end
#     end
#     Mod.class              #=> Module
#     Mod.constants          #=> [:CONST, :PI, :E]
#     Mod.instance_methods   #=> [:meth]
#
class Module < Object
  # <!--
  #   rdoc-file=eval.c
  #   - Module.constants   -> array
  #   - Module.constants(inherited)   -> array
  # -->
  # In the first form, returns an array of the names of all constants accessible
  # from the point of call. This list includes the names of all modules and
  # classes defined in the global scope.
  #
  #     Module.constants.first(4)
  #        # => [:ARGF, :ARGV, :ArgumentError, :Array]
  #
  #     Module.constants.include?(:SEEK_SET)   # => false
  #
  #     class IO
  #       Module.constants.include?(:SEEK_SET) # => true
  #     end
  #
  # The second form calls the instance method `constants`.
  #
  def self.constants: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=eval.c
  #   - Module.nesting    -> array
  # -->
  # Returns the list of `Modules` nested at the point of call.
  #
  #     module M1
  #       module M2
  #         $a = Module.nesting
  #       end
  #     end
  #     $a           #=> [M1::M2, M1]
  #     $a[0].name   #=> "M1::M2"
  #
  def self.nesting: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - used_modules -> array
  # -->
  # Returns an array of all modules used in the current scope. The ordering of
  # modules in the resulting array is not defined.
  #
  #     module A
  #       refine Object do
  #       end
  #     end
  #
  #     module B
  #       refine Object do
  #       end
  #     end
  #
  #     using A
  #     using B
  #     p Module.used_modules
  #
  # *produces:*
  #
  #     [B, A]
  #
  def self.used_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=object.c
  #   - mod < other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other*. Returns `nil` if there's no
  # relationship between the two. (Think of the relationship in terms of the class
  # definition: "class A < B" implies "A < B".)
  #
  def <: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod <= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other* or is the same as *other*.
  # Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "A < B".)
  #
  def <=: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - module <=> other_module   -> -1, 0, +1, or nil
  # -->
  # Comparison---Returns -1, 0, +1 or nil depending on whether `module` includes
  # `other_module`, they are the same, or if `module` is included by
  # `other_module`.
  #
  # Returns `nil` if `module` has no relationship with `other_module`, if
  # `other_module` is not a module, or if the two values are incomparable.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod === obj    -> true or false
  # -->
  # Case Equality---Returns `true` if *obj* is an instance of *mod* or an instance
  # of one of *mod*'s descendants. Of limited use for modules, but can be used in
  # `case` statements to classify objects by class.
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod > other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*. Returns `nil` if there's no
  # relationship between the two. (Think of the relationship in terms of the class
  # definition: "class A < B" implies "B > A".)
  #
  def >: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod >= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*, or the two modules are the
  # same. Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "B > A".)
  #
  def >=: (Module other) -> bool?

  # <!--
  #   rdoc-file=vm_method.c
  #   - alias_method(new_name, old_name)   -> symbol
  # -->
  # Makes *new_name* a new copy of the method *old_name*. This can be used to
  # retain access to methods that are overridden.
  #
  #     module Mod
  #       alias_method :orig_exit, :exit #=> :orig_exit
  #       def exit(code=0)
  #         puts "Exiting with code #{code}"
  #         orig_exit(code)
  #       end
  #     end
  #     include Mod
  #     exit(99)
  #
  # *produces:*
  #
  #     Exiting with code 99
  #
  def alias_method: (::Symbol | ::String new_name, ::Symbol | ::String old_name) -> ::Symbol

  # <!--
  #   rdoc-file=object.c
  #   - mod.ancestors -> array
  # -->
  # Returns a list of modules included/prepended in *mod* (including *mod*
  # itself).
  #
  #     module Mod
  #       include Math
  #       include Comparable
  #       prepend Enumerable
  #     end
  #
  #     Mod.ancestors        #=> [Enumerable, Mod, Comparable, Math]
  #     Math.ancestors       #=> [Math]
  #     Enumerable.ancestors #=> [Enumerable]
  #
  def ancestors: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - append_features(mod)   -> mod
  # -->
  # When this module is included in another, Ruby calls #append_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to add the constants, methods, and module variables of this
  # module to *mod* if this module has not already been added to *mod* or one of
  # its ancestors. See also Module#include.
  #
  def append_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - attr_accessor(symbol, ...)    -> array
  #   - attr_accessor(string, ...)    -> array
  # -->
  # Defines a named attribute for this module, where the name is
  # *symbol.*`id2name`, creating an instance variable (`@name`) and a
  # corresponding access method to read it. Also creates a method called `name=`
  # to set the attribute. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  #     module Mod
  #       attr_accessor(:one, :two) #=> [:one, :one=, :two, :two=]
  #     end
  #     Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]
  #
  def attr_accessor: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=object.c
  #   - attr_reader(symbol, ...)  -> array
  #   - attr(symbol, ...)         -> array
  #   - attr_reader(string, ...)  -> array
  #   - attr(string, ...)         -> array
  # -->
  # Creates instance variables and corresponding methods that return the value of
  # each instance variable. Equivalent to calling ```attr`*:name*'' on each name
  # in turn. String arguments are converted to symbols. Returns an array of
  # defined method names as symbols.
  #
  def attr_reader: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=object.c
  #   - attr_writer(symbol, ...)    -> array
  #   - attr_writer(string, ...)    -> array
  # -->
  # Creates an accessor method to allow assignment to the attribute
  # *symbol*`.id2name`. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  def attr_writer: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload(module, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *module* (which may be a String or a symbol) is accessed in the namespace of
  # *mod*.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A::B.doit            # autoloads "b"
  #
  def autoload: (Symbol _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload` in the
  # namespace of *mod* or one of its ancestors.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A.autoload?(:B)            #=> "b"
  #
  # If `inherit` is false, the lookup only checks the autoloads in the receiver:
  #
  #     class A
  #       autoload :CONST, "const.rb"
  #     end
  #
  #     class B < A
  #     end
  #
  #     B.autoload?(:CONST)          #=> "const.rb", found in A (ancestor)
  #     B.autoload?(:CONST, false)   #=> nil, not found in B itself
  #
  def autoload?: (Symbol name, ?boolish inherit) -> String?

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def class_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                | [U] () { (self m) -> U } -> U

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def class_exec: (*untyped args) { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_defined?(symbol)    -> true or false
  #   - obj.class_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given class variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_defined?(:@@foo)    #=> true
  #     Fred.class_variable_defined?(:@@bar)    #=> false
  #
  def class_variable_defined?: (Symbol | String arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variable_get(symbol)    -> obj
  #   - mod.class_variable_get(string)    -> obj
  # -->
  # Returns the value of the given class variable (or throws a NameError
  # exception). The `@@` part of the variable name should be included for regular
  # class variables. String arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_get(:@@foo)     #=> 99
  #
  def class_variable_get: (Symbol | String arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_set(symbol, obj)    -> obj
  #   - obj.class_variable_set(string, obj)    -> obj
  # -->
  # Sets the class variable named by *symbol* to the given object. If the class
  # variable name is passed as a string, that string is converted to a symbol.
  #
  #     class Fred
  #       @@foo = 99
  #       def foo
  #         @@foo
  #       end
  #     end
  #     Fred.class_variable_set(:@@foo, 101)     #=> 101
  #     Fred.new.foo                             #=> 101
  #
  def class_variable_set: (Symbol | String arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variables(inherit=true)    -> array
  # -->
  # Returns an array of the names of class variables in *mod*. This includes the
  # names of class variables in any included modules, unless the *inherit*
  # parameter is set to `false`.
  #
  #     class One
  #       @@var1 = 1
  #     end
  #     class Two < One
  #       @@var2 = 2
  #     end
  #     One.class_variables          #=> [:@@var1]
  #     Two.class_variables          #=> [:@@var2, :@@var1]
  #     Two.class_variables(false)   #=> [:@@var2]
  #
  def class_variables: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_defined?(sym, inherit=true)   -> true or false
  #   - mod.const_defined?(str, inherit=true)   -> true or false
  # -->
  # Says whether *mod* or its ancestors have a constant with the given name:
  #
  #     Float.const_defined?(:EPSILON)      #=> true, found in Float itself
  #     Float.const_defined?("String")      #=> true, found in Object (ancestor)
  #     BasicObject.const_defined?(:Hash)   #=> false
  #
  # If *mod* is a `Module`, additionally `Object` and its ancestors are checked:
  #
  #     Math.const_defined?(:String)   #=> true, found in Object
  #
  # In each of the checked classes or modules, if the constant is not present but
  # there is an autoload for it, `true` is returned directly without autoloading:
  #
  #     module Admin
  #       autoload :User, 'admin/user'
  #     end
  #     Admin.const_defined?(:User)   #=> true
  #
  # If the constant is not found the callback `const_missing` is **not** called
  # and the method returns `false`.
  #
  # If `inherit` is false, the lookup only checks the constants in the receiver:
  #
  #     IO.const_defined?(:SYNC)          #=> true, found in File::Constants (ancestor)
  #     IO.const_defined?(:SYNC, false)   #=> false, not found in IO itself
  #
  # In this case, the same logic for autoloading applies.
  #
  # If the argument is not a valid constant name a `NameError` is raised with the
  # message "wrong constant name *name*":
  #
  #     Hash.const_defined? 'foobar'   #=> NameError: wrong constant name foobar
  #
  def const_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_get(sym, inherit=true)    -> obj
  #   - mod.const_get(str, inherit=true)    -> obj
  # -->
  # Checks for a constant with the given name in *mod*. If `inherit` is set, the
  # lookup will also search the ancestors (and `Object` if *mod* is a `Module`).
  #
  # The value of the constant is returned if a definition is found, otherwise a
  # `NameError` is raised.
  #
  #     Math.const_get(:PI)   #=> 3.14159265358979
  #
  # This method will recursively look up constant names if a namespaced class name
  # is provided.  For example:
  #
  #     module Foo; class Bar; end end
  #     Object.const_get 'Foo::Bar'
  #
  # The `inherit` flag is respected on each lookup.  For example:
  #
  #     module Foo
  #       class Bar
  #         VAL = 10
  #       end
  #
  #       class Baz < Bar; end
  #     end
  #
  #     Object.const_get 'Foo::Baz::VAL'         # => 10
  #     Object.const_get 'Foo::Baz::VAL', false  # => NameError
  #
  # If the argument is not a valid constant name a `NameError` will be raised with
  # a warning "wrong constant name".
  #
  #     Object.const_get 'foobar' #=> NameError: wrong constant name foobar
  #
  def const_get: (Symbol | String name, ?boolish inherit) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_missing(sym)    -> obj
  # -->
  # Invoked when a reference is made to an undefined constant in *mod*. It is
  # passed a symbol for the undefined constant, and returns a value to be used for
  # that constant. The following code is an example of the same:
  #
  #     def Foo.const_missing(name)
  #       name # return the constant name as Symbol
  #     end
  #
  #     Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned
  #
  # In the next example when a reference is made to an undefined constant, it
  # attempts to load a file whose name is the lowercase version of the constant
  # (thus class `Fred` is assumed to be in file `fred.rb`).  If found, it returns
  # the loaded class. It therefore implements an autoload feature similar to
  # Kernel#autoload and Module#autoload.
  #
  #     def Object.const_missing(name)
  #       @looked_for ||= {}
  #       str_name = name.to_s
  #       raise "Class not found: #{name}" if @looked_for[str_name]
  #       @looked_for[str_name] = 1
  #       file = str_name.downcase
  #       require file
  #       klass = const_get(name)
  #       return klass if klass
  #       raise "Class not found: #{name}"
  #     end
  #
  def const_missing: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_set(sym, obj)    -> obj
  #   - mod.const_set(str, obj)    -> obj
  # -->
  # Sets the named constant to the given object, returning that object. Creates a
  # new constant if no constant with the given name previously existed.
  #
  #     Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714
  #     Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968
  #
  # If `sym` or `str` is not a valid constant name a `NameError` will be raised
  # with a warning "wrong constant name".
  #
  #     Object.const_set('foobar', 42) #=> NameError: wrong constant name foobar
  #
  def const_set: (Symbol | String arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_source_location(sym, inherit=true)   -> [String, Integer]
  #   - mod.const_source_location(str, inherit=true)   -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing the definition of
  # the constant specified. If the named constant is not found, `nil` is returned.
  # If the constant is found, but its source location can not be extracted
  # (constant is defined in C code), empty array is returned.
  #
  # *inherit* specifies whether to lookup in `mod.ancestors` (`true` by default).
  #
  #     # test.rb:
  #     class A         # line 1
  #       C1 = 1
  #       C2 = 2
  #     end
  #
  #     module M        # line 6
  #       C3 = 3
  #     end
  #
  #     class B < A     # line 10
  #       include M
  #       C4 = 4
  #     end
  #
  #     class A # continuation of A definition
  #       C2 = 8 # constant redefinition; warned yet allowed
  #     end
  #
  #     p B.const_source_location('C4')           # => ["test.rb", 12]
  #     p B.const_source_location('C3')           # => ["test.rb", 7]
  #     p B.const_source_location('C1')           # => ["test.rb", 2]
  #
  #     p B.const_source_location('C3', false)    # => nil  -- don't lookup in ancestors
  #
  #     p A.const_source_location('C2')           # => ["test.rb", 16] -- actual (last) definition place
  #
  #     p Object.const_source_location('B')       # => ["test.rb", 10] -- top-level constant could be looked through Object
  #     p Object.const_source_location('A')       # => ["test.rb", 1] -- class reopening is NOT considered new definition
  #
  #     p B.const_source_location('A')            # => ["test.rb", 1]  -- because Object is in ancestors
  #     p M.const_source_location('A')            # => ["test.rb", 1]  -- Object is not ancestor, but additionally checked for modules
  #
  #     p Object.const_source_location('A::C1')   # => ["test.rb", 2]  -- nesting is supported
  #     p Object.const_source_location('String')  # => []  -- constant is defined in C code
  #
  def const_source_location: (Symbol | String name, ?boolish inherit) -> ([ String, Integer ] | [ ] | nil)

  # <!--
  #   rdoc-file=object.c
  #   - mod.constants(inherit=true)    -> array
  # -->
  # Returns an array of the names of the constants accessible in *mod*. This
  # includes the names of constants in any included modules (example at start of
  # section), unless the *inherit* parameter is set to `false`.
  #
  # The implementation makes no guarantees about the order in which the constants
  # are yielded.
  #
  #     IO.constants.include?(:SYNC)        #=> true
  #     IO.constants(false).include?(:SYNC) #=> false
  #
  # Also see Module#const_defined?.
  #
  def constants: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - define_method(symbol, method)     -> symbol
  #   - define_method(symbol) { block }   -> symbol
  # -->
  # Defines an instance method in the receiver. The *method* parameter can be a
  # `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
  # is used as the method body. If a block or the *method* parameter has
  # parameters, they're used as method parameters. This block is evaluated using
  # #instance_eval.
  #
  #     class A
  #       def fred
  #         puts "In Fred"
  #       end
  #       def create_method(name, &block)
  #         self.class.define_method(name, &block)
  #       end
  #       define_method(:wilma) { puts "Charge it!" }
  #       define_method(:flint) {|name| puts "I'm #{name}!"}
  #     end
  #     class B < A
  #       define_method(:barney, instance_method(:fred))
  #     end
  #     a = B.new
  #     a.barney
  #     a.wilma
  #     a.flint('Dino')
  #     a.create_method(:betty) { p self }
  #     a.betty
  #
  # *produces:*
  #
  #     In Fred
  #     Charge it!
  #     I'm Dino!
  #     #<B:0x401b39e8>
  #
  def define_method: (Symbol | String arg0, ?Proc | Method | UnboundMethod arg1) -> Symbol
                   | (Symbol | String arg0) { () -> untyped } -> Symbol

  def eql?: (untyped other) -> bool

  def equal?: (untyped other) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - extend_object(obj)    -> obj
  # -->
  # Extends the specified object by adding this module's constants and methods
  # (which are added as singleton methods). This is the callback method used by
  # Object#extend.
  #
  #     module Picky
  #       def Picky.extend_object(o)
  #         if String === o
  #           puts "Can't add Picky to a String"
  #         else
  #           puts "Picky added to #{o.class}"
  #           super
  #         end
  #       end
  #     end
  #     (s = Array.new).extend Picky  # Call Object.extend
  #     (s = "quick brown fox").extend Picky
  #
  # *produces:*
  #
  #     Picky added to Array
  #     Can't add Picky to a String
  #
  def extend_object: (untyped arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - extended(othermod)
  # -->
  # The equivalent of `included`, but for extended modules.
  #
  #     module A
  #       def self.extended(mod)
  #         puts "#{self} extended in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       extend A
  #     end
  #      # => prints "A extended in Enumerable"
  #
  def extended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.freeze       -> mod
  # -->
  # Prevents further modifications to *mod*.
  #
  # This method returns self.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=eval.c
  #   - include(module, ...)    -> self
  # -->
  # Invokes Module.append_features on each parameter in reverse order.
  #
  def include: (*Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.include?(module)    -> true or false
  # -->
  # Returns `true` if *module* is included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module A
  #     end
  #     class B
  #       include A
  #     end
  #     class C < B
  #     end
  #     B.include?(A)   #=> true
  #     C.include?(A)   #=> true
  #     A.include?(A)   #=> false
  #
  def include?: (Module arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - included(othermod)
  # -->
  # Callback invoked whenever the receiver is included in another module or class.
  # This should be used in preference to `Module.append_features` if your code
  # wants to perform some action when a module is included in another.
  #
  #     module A
  #       def A.included(mod)
  #         puts "#{self} included in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       include A
  #     end
  #      # => prints "A included in Enumerable"
  #
  def included: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.included_modules -> array
  # -->
  # Returns the list of modules included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module Sub
  #     end
  #
  #     module Mixin
  #       prepend Sub
  #     end
  #
  #     module Outer
  #       include Mixin
  #     end
  #
  #     Mixin.included_modules   #=> [Sub]
  #     Outer.included_modules   #=> [Sub, Mixin]
  #
  def included_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=object.c
  #   - Module.new                  -> mod
  #   - Module.new {|mod| block }   -> mod
  # -->
  # Creates a new anonymous module. If a block is given, it is passed the module
  # object, and the block is evaluated in the context of this module like
  # #module_eval.
  #
  #     fred = Module.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #     a = "my string"
  #     a.extend(fred)   #=> "my string"
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the module to a constant (name starting uppercase) if you want to treat
  # it like a regular module.
  #
  def initialize: () -> Object
                | () { (Module arg0) -> untyped } -> void

  # <!--
  #   rdoc-file=proc.c
  #   - mod.instance_method(symbol)   -> unbound_method
  # -->
  # Returns an `UnboundMethod` representing the given instance method in *mod*.
  #
  #     class Interpreter
  #       def do_a() print "there, "; end
  #       def do_d() print "Hello ";  end
  #       def do_e() print "!\n";     end
  #       def do_v() print "Dave";    end
  #       Dispatcher = {
  #         "a" => instance_method(:do_a),
  #         "d" => instance_method(:do_d),
  #         "e" => instance_method(:do_e),
  #         "v" => instance_method(:do_v)
  #       }
  #       def interpret(string)
  #         string.each_char {|b| Dispatcher[b].bind(self).call }
  #       end
  #     end
  #
  #     interpreter = Interpreter.new
  #     interpreter.interpret('dave')
  #
  # *produces:*
  #
  #     Hello there, Dave!
  #
  def instance_method: (Symbol arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.instance_methods(include_super=true)   -> array
  # -->
  # Returns an array containing the names of the public and protected instance
  # methods in the receiver. For a module, these are the public and protected
  # methods; for a class, they are the instance (not singleton) methods. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       include A
  #       def method2()  end
  #     end
  #     class C < B
  #       def method3()  end
  #     end
  #
  #     A.instance_methods(false)                   #=> [:method1]
  #     B.instance_methods(false)                   #=> [:method2]
  #     B.instance_methods(true).include?(:method1) #=> true
  #     C.instance_methods(false)                   #=> [:method3]
  #     C.instance_methods.include?(:method2)       #=> true
  #
  def instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - method_added(method_name)
  # -->
  # Invoked as a callback whenever an instance method is added to the receiver.
  #
  #     module Chatty
  #       def self.method_added(method_name)
  #         puts "Adding #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #     end
  #
  # *produces:*
  #
  #     Adding :some_instance_method
  #
  def method_added: (Symbol meth) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named method is defined by *mod*.  If *inherit* is set,
  # the lookup will also search *mod*'s ancestors. Public and protected methods
  # are matched. String arguments are converted to symbols.
  #
  #     module A
  #       def method1()  end
  #       def protected_method1()  end
  #       protected :protected_method1
  #     end
  #     class B
  #       def method2()  end
  #       def private_method2()  end
  #       private :private_method2
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1              #=> true
  #     C.method_defined? "method1"             #=> true
  #     C.method_defined? "method2"             #=> true
  #     C.method_defined? "method2", true       #=> true
  #     C.method_defined? "method2", false      #=> false
  #     C.method_defined? "method3"             #=> true
  #     C.method_defined? "protected_method1"   #=> true
  #     C.method_defined? "method4"             #=> false
  #     C.method_defined? "private_method2"     #=> false
  #
  def method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - method_removed(method_name)
  # -->
  # Invoked as a callback whenever an instance method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def self.method_removed(method_name)
  #         puts "Removing #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #       class << self
  #         remove_method :some_class_method
  #       end
  #       remove_method :some_instance_method
  #     end
  #
  # *produces:*
  #
  #     Removing :some_instance_method
  #
  def method_removed: (Symbol method_name) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.class_eval(string [, filename [, lineno]])  -> obj
  #   - mod.class_eval {|mod| block }                   -> obj
  #   - mod.module_eval(string [, filename [, lineno]]) -> obj
  #   - mod.module_eval {|mod| block }                  -> obj
  # -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def module_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                 | [U] () { (self m) -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.module_exec(arg...) {|var...| block }       -> obj
  #   - mod.class_exec(arg...) {|var...| block }        -> obj
  # -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def module_exec: (*untyped args) { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - module_function                                -> nil
  #   - module_function(method_name)                   -> method_name
  #   - module_function(method_name, method_name, ...) -> array
  # -->
  # Creates module functions for the named methods. These functions may be called
  # with the module as a receiver, and also become available as instance methods
  # to classes that mix in the module. Module functions are copies of the
  # original, and so may be changed independently. The instance-method versions
  # are made private. If used with no arguments, subsequently defined methods
  # become module functions. String arguments are converted to symbols. If a
  # single argument is passed, it is returned. If no argument is passed, nil is
  # returned. If multiple arguments are passed, the arguments are returned as an
  # array.
  #
  #     module Mod
  #       def one
  #         "This is one"
  #       end
  #       module_function :one
  #     end
  #     class Cls
  #       include Mod
  #       def call_one
  #         one
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c = Cls.new
  #     c.call_one  #=> "This is one"
  #     module Mod
  #       def one
  #         "This is the new one"
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c.call_one  #=> "This is the new one"
  #
  def module_function: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.name    -> string
  # -->
  # Returns the name of the module *mod*.  Returns nil for anonymous modules.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - prepend(module, ...)    -> self
  # -->
  # Invokes Module.prepend_features on each parameter in reverse order.
  #
  def prepend: (*Module arg0) -> self

  # <!--
  #   rdoc-file=eval.c
  #   - prepend_features(mod)   -> mod
  # -->
  # When this module is prepended in another, Ruby calls #prepend_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to overlay the constants, methods, and module variables of
  # this module to *mod* if this module has not already been added to *mod* or one
  # of its ancestors. See also Module#prepend.
  #
  def prepend_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - prepended(othermod)
  # -->
  # The equivalent of `included`, but for prepended modules.
  #
  #     module A
  #       def self.prepended(mod)
  #         puts "#{self} prepended to #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       prepend A
  #     end
  #      # => prints "A prepended to Enumerable"
  #
  def prepended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - private                                -> nil
  #   - private(method_name)                   -> method_name
  #   - private(method_name, method_name, ...) -> array
  #   - private(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to private. With arguments, sets the named methods to have private
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  #     module Mod
  #       def a()  end
  #       def b()  end
  #       private
  #       def c()  end
  #       private :a
  #     end
  #     Mod.private_instance_methods   #=> [:a, :c]
  #
  # Note that to show a private method on RDoc, use `:doc:`.
  #
  def private: () -> nil
             | (Symbol method_name) -> Symbol
             | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
             | (string method_name) -> string
             | (string | Symbol, string | Symbol, *string | Symbol method_name) -> Array[string | Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_class_method(symbol, ...)   -> mod
  #   - mod.private_class_method(string, ...)   -> mod
  #   - mod.private_class_method(array)         -> mod
  # -->
  # Makes existing class methods private. Often used to hide the default
  # constructor `new`.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  #     class SimpleSingleton  # Not thread safe
  #       private_class_method :new
  #       def SimpleSingleton.create(*args, &block)
  #         @me = new(*args, &block) if ! @me
  #         @me
  #       end
  #     end
  #
  def private_class_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants private.
  #
  def private_constant: (*Symbol arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_instance_methods(include_super=true)    -> array
  # -->
  # Returns a list of the private instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module Mod
  #       def method1()  end
  #       private :method1
  #       def method2()  end
  #     end
  #     Mod.instance_methods           #=> [:method2]
  #     Mod.private_instance_methods   #=> [:method1]
  #
  def private_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.private_method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named private method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       private
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                   #=> true
  #     C.private_method_defined? "method1"          #=> false
  #     C.private_method_defined? "method2"          #=> true
  #     C.private_method_defined? "method2", true    #=> true
  #     C.private_method_defined? "method2", false   #=> false
  #     C.method_defined? "method2"                  #=> false
  #
  def private_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - protected                                -> nil
  #   - protected(method_name)                   -> method_name
  #   - protected(method_name, method_name, ...) -> array
  #   - protected(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to protected. With arguments, sets the named methods to have protected
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  # If a method has protected visibility, it is callable only where `self` of the
  # context is the same as the method. (method definition or instance_eval). This
  # behavior is different from Java's protected method. Usually `private` should
  # be used.
  #
  # Note that a protected method is slow because it can't use inline cache.
  #
  # To show a private method on RDoc, use `:doc:` instead of this.
  #
  def protected: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.protected_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the protected instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def protected_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.protected_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.protected_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named protected method is defined *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                    #=> true
  #     C.protected_method_defined? "method1"         #=> false
  #     C.protected_method_defined? "method2"         #=> true
  #     C.protected_method_defined? "method2", true   #=> true
  #     C.protected_method_defined? "method2", false  #=> false
  #     C.method_defined? "method2"                   #=> true
  #
  def protected_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - public                                -> nil
  #   - public(method_name)                   -> method_name
  #   - public(method_name, method_name, ...) -> array
  #   - public(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to public. With arguments, sets the named methods to have public
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  def public: () -> nil
            | (Symbol method_name) -> Symbol
            | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
            | (string method_name) -> string
            | (string | Symbol, string | Symbol, *string | Symbol method_name) -> Array[string | Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_class_method(symbol, ...)    -> mod
  #   - mod.public_class_method(string, ...)    -> mod
  #   - mod.public_class_method(array)          -> mod
  # -->
  # Makes a list of existing class methods public.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  def public_class_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants public.
  #
  def public_constant: (*Symbol arg0) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - mod.public_instance_method(symbol)   -> unbound_method
  # -->
  # Similar to *instance_method*, searches public method only.
  #
  def public_instance_method: (Symbol arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the public instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def public_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.public_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named public method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                 #=> true
  #     C.public_method_defined? "method1"         #=> true
  #     C.public_method_defined? "method1", true   #=> true
  #     C.public_method_defined? "method1", false  #=> true
  #     C.public_method_defined? "method2"         #=> false
  #     C.method_defined? "method2"                #=> true
  #
  def public_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - refine(mod) { block }   -> module
  # -->
  # Refine *mod* in the receiver.
  #
  # Returns a module, where refined methods are defined.
  #
  def refine: (Class arg0) { (untyped arg0) -> untyped } -> self

  # <!--
  #   rdoc-file=object.c
  #   - remove_class_variable(sym)    -> obj
  # -->
  # Removes the named class variable from the receiver, returning that variable's
  # value.
  #
  #     class Example
  #       @@var = 99
  #       puts remove_class_variable(:@@var)
  #       p(defined? @@var)
  #     end
  #
  # *produces:*
  #
  #     99
  #     nil
  #
  def remove_class_variable: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - remove_const(sym)   -> obj
  # -->
  # Removes the definition of the given constant, returning that constant's
  # previous value.  If that constant referred to a module, this will not change
  # that module's name and can lead to confusion.
  #
  def remove_const: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - remove_method(symbol)   -> self
  #   - remove_method(string)   -> self
  # -->
  # Removes the method identified by *symbol* from the current class. For an
  # example, see Module#undef_method. String arguments are converted to symbols.
  #
  def remove_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.singleton_class?    -> true or false
  # -->
  # Returns `true` if *mod* is a singleton class or `false` if it is an ordinary
  # class or module.
  #
  #     class C
  #     end
  #     C.singleton_class?                  #=> false
  #     C.singleton_class.singleton_class?  #=> true
  #
  def singleton_class?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.to_s   -> string
  # -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_method.c
  #   - undef_method(symbol)    -> self
  #   - undef_method(string)    -> self
  # -->
  # Prevents the current class from responding to calls to the named method.
  # Contrast this with `remove_method`, which deletes the method from the
  # particular class; Ruby will still search superclasses and mixed-in modules for
  # a possible receiver. String arguments are converted to symbols.
  #
  #     class Parent
  #       def hello
  #         puts "In parent"
  #       end
  #     end
  #     class Child < Parent
  #       def hello
  #         puts "In child"
  #       end
  #     end
  #
  #     c = Child.new
  #     c.hello
  #
  #     class Child
  #       remove_method :hello  # remove from child, still in parent
  #     end
  #     c.hello
  #
  #     class Child
  #       undef_method :hello   # prevent any calls to 'hello'
  #     end
  #     c.hello
  #
  # *produces:*
  #
  #     In child
  #     In parent
  #     prog.rb:23: undefined method `hello' for #<Child:0x401b3bb4> (NoMethodError)
  #
  def undef_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=eval.c
  #   - using(module)    -> self
  # -->
  # Import class refinements from *module* into the current class or module
  # definition.
  #
  def using: (Module arg0) -> self

  # <!-- rdoc-file=object.c -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - attr(name, ...) -> array
  #   - attr(name, true) -> array
  #   - attr(name, false) -> array
  # -->
  # The first form is equivalent to #attr_reader. The second form is equivalent to
  # `attr_accessor(name)` but deprecated. The last form is equivalent to
  # `attr_reader(name)` but deprecated. Returns an array of defined method names
  # as symbols.
  #
  def attr: (*Symbol | String arg0) -> NilClass
end

# <!-- rdoc-file=encoding.c -->
# An Encoding instance represents a character encoding usable in Ruby. It is
# defined as a constant under the Encoding namespace. It has a name and
# optionally, aliases:
#
#     Encoding::ISO_8859_1.name
#     #=> "ISO-8859-1"
#
#     Encoding::ISO_8859_1.names
#     #=> ["ISO-8859-1", "ISO8859-1"]
#
# Ruby methods dealing with encodings return or accept Encoding instances as
# arguments (when a method accepts an Encoding instance as an argument, it can
# be passed an Encoding name or alias instead).
#
#     "some string".encoding
#     #=> #<Encoding:UTF-8>
#
#     string = "some string".encode(Encoding::ISO_8859_1)
#     #=> "some string"
#     string.encoding
#     #=> #<Encoding:ISO-8859-1>
#
#     "some string".encode "ISO-8859-1"
#     #=> "some string"
#
# Encoding::ASCII_8BIT is a special encoding that is usually used for a byte
# string, not a character string. But as the name insists, its characters in the
# range of ASCII are considered as ASCII characters.  This is useful when you
# use ASCII-8BIT characters with other ASCII compatible characters.
#
# ## Changing an encoding
#
# The associated Encoding of a String can be changed in two different ways.
#
# First, it is possible to set the Encoding of a string to a new Encoding
# without changing the internal byte representation of the string, with
# String#force_encoding. This is how you can tell Ruby the correct encoding of a
# string.
#
#     string
#     #=> "R\xC3\xA9sum\xC3\xA9"
#     string.encoding
#     #=> #<Encoding:ISO-8859-1>
#     string.force_encoding(Encoding::UTF_8)
#     #=> "R\u00E9sum\u00E9"
#
# Second, it is possible to transcode a string, i.e. translate its internal byte
# representation to another encoding. Its associated encoding is also set to the
# other encoding. See String#encode for the various forms of transcoding, and
# the Encoding::Converter class for additional control over the transcoding
# process.
#
#     string
#     #=> "R\u00E9sum\u00E9"
#     string.encoding
#     #=> #<Encoding:UTF-8>
#     string = string.encode!(Encoding::ISO_8859_1)
#     #=> "R\xE9sum\xE9"
#     string.encoding
#     #=> #<Encoding::ISO-8859-1>
#
# ## Script encoding
#
# All Ruby script code has an associated Encoding which any String literal
# created in the source code will be associated to.
#
# The default script encoding is Encoding::UTF_8 after v2.0, but it can be
# changed by a magic comment on the first line of the source code file (or
# second line, if there is a shebang line on the first). The comment must
# contain the word `coding` or `encoding`, followed by a colon, space and the
# Encoding name or alias:
#
#     # encoding: UTF-8
#
#     "some string".encoding
#     #=> #<Encoding:UTF-8>
#
# The `__ENCODING__` keyword returns the script encoding of the file which the
# keyword is written:
#
#     # encoding: ISO-8859-1
#
#     __ENCODING__
#     #=> #<Encoding:ISO-8859-1>
#
# `ruby -K` will change the default locale encoding, but this is not
# recommended. Ruby source files should declare its script encoding by a magic
# comment even when they only depend on US-ASCII strings or regular expressions.
#
# ## Locale encoding
#
# The default encoding of the environment. Usually derived from locale.
#
# see Encoding.locale_charmap, Encoding.find('locale')
#
# ## Filesystem encoding
#
# The default encoding of strings from the filesystem of the environment. This
# is used for strings of file names or paths.
#
# see Encoding.find('filesystem')
#
# ## External encoding
#
# Each IO object has an external encoding which indicates the encoding that Ruby
# will use to read its data. By default Ruby sets the external encoding of an IO
# object to the default external encoding. The default external encoding is set
# by locale encoding or the interpreter `-E` option. Encoding.default_external
# returns the current value of the external encoding.
#
#     ENV["LANG"]
#     #=> "UTF-8"
#     Encoding.default_external
#     #=> #<Encoding:UTF-8>
#
#     $ ruby -E ISO-8859-1 -e "p Encoding.default_external"
#     #<Encoding:ISO-8859-1>
#
#     $ LANG=C ruby -e 'p Encoding.default_external'
#     #<Encoding:US-ASCII>
#
# The default external encoding may also be set through
# Encoding.default_external=, but you should not do this as strings created
# before and after the change will have inconsistent encodings.  Instead use
# `ruby -E` to invoke ruby with the correct external encoding.
#
# When you know that the actual encoding of the data of an IO object is not the
# default external encoding, you can reset its external encoding with
# IO#set_encoding or set it at IO object creation (see IO.new options).
#
# ## Internal encoding
#
# To process the data of an IO object which has an encoding different from its
# external encoding, you can set its internal encoding. Ruby will use this
# internal encoding to transcode the data when it is read from the IO object.
#
# Conversely, when data is written to the IO object it is transcoded from the
# internal encoding to the external encoding of the IO object.
#
# The internal encoding of an IO object can be set with IO#set_encoding or at IO
# object creation (see IO.new options).
#
# The internal encoding is optional and when not set, the Ruby default internal
# encoding is used. If not explicitly set this default internal encoding is
# `nil` meaning that by default, no transcoding occurs.
#
# The default internal encoding can be set with the interpreter option `-E`.
# Encoding.default_internal returns the current internal encoding.
#
#     $ ruby -e 'p Encoding.default_internal'
#     nil
#
#     $ ruby -E ISO-8859-1:UTF-8 -e "p [Encoding.default_external, \
#       Encoding.default_internal]"
#     [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]
#
# The default internal encoding may also be set through
# Encoding.default_internal=, but you should not do this as strings created
# before and after the change will have inconsistent encodings.  Instead use
# `ruby -E` to invoke ruby with the correct internal encoding.
#
# ## IO encoding example
#
# In the following example a UTF-8 encoded string "Ru00E9sumu00E9" is transcoded
# for output to ISO-8859-1 encoding, then read back in and transcoded to UTF-8:
#
#     string = "R\u00E9sum\u00E9"
#
#     open("transcoded.txt", "w:ISO-8859-1") do |io|
#       io.write(string)
#     end
#
#     puts "raw text:"
#     p File.binread("transcoded.txt")
#     puts
#
#     open("transcoded.txt", "r:ISO-8859-1:UTF-8") do |io|
#       puts "transcoded text:"
#       p io.read
#     end
#
# While writing the file, the internal encoding is not specified as it is only
# necessary for reading.  While reading the file both the internal and external
# encoding must be specified to obtain the correct result.
#
#     $ ruby t.rb
#     raw text:
#     "R\xE9sum\xE9"
#
#     transcoded text:
#     "R\u00E9sum\u00E9"
#
class Encoding < Object
  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.aliases -> {"alias1" => "orig1", "alias2" => "orig2", ...}
  # -->
  # Returns the hash of available encoding alias and original encoding name.
  #
  #     Encoding.aliases
  #     #=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII",
  #           "SJIS"=>"Windows-31J", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}
  #
  def self.aliases: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.compatible?(obj1, obj2) -> enc or nil
  # -->
  # Checks the compatibility of two objects.
  #
  # If the objects are both strings they are compatible when they are
  # concatenatable.  The encoding of the concatenated string will be returned if
  # they are compatible, nil if they are not.
  #
  #     Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")
  #     #=> #<Encoding:ISO-8859-1>
  #
  #     Encoding.compatible?(
  #       "\xa1".force_encoding("iso-8859-1"),
  #       "\xa1\xa1".force_encoding("euc-jp"))
  #     #=> nil
  #
  # If the objects are non-strings their encodings are compatible when they have
  # an encoding and:
  # *   Either encoding is US-ASCII compatible
  # *   One of the encodings is a 7-bit encoding
  #
  def self.compatible?: (untyped obj1, untyped obj2) -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external -> enc
  # -->
  # Returns default external encoding.
  #
  # The default external encoding is used by default for strings created from the
  # following locations:
  #
  # *   CSV
  # *   File data read from disk
  # *   SDBM
  # *   StringIO
  # *   Zlib::GzipReader
  # *   Zlib::GzipWriter
  # *   String#inspect
  # *   Regexp#inspect
  #
  #
  # While strings created from these locations will have this encoding, the
  # encoding may not be valid.  Be sure to check String#valid_encoding?.
  #
  # File data written to disk will be transcoded to the default external encoding
  # when written, if default_internal is not nil.
  #
  # The default external encoding is initialized by the -E option. If -E isn't
  # set, it is initialized to UTF-8 on Windows and the locale on other operating
  # systems.
  #
  def self.default_external: () -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external = enc
  # -->
  # Sets default external encoding.  You should not set Encoding::default_external
  # in ruby code as strings created before changing the value may have a different
  # encoding from strings created after the value was changed., instead you should
  # use `ruby -E` to invoke ruby with the correct default_external.
  #
  # See Encoding::default_external for information on how the default external
  # encoding is used.
  #
  def self.default_external=: (String arg0) -> String
                            | (Encoding arg0) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal -> enc
  # -->
  # Returns default internal encoding.  Strings will be transcoded to the default
  # internal encoding in the following places if the default internal encoding is
  # not nil:
  #
  # *   CSV
  # *   Etc.sysconfdir and Etc.systmpdir
  # *   File data read from disk
  # *   File names from Dir
  # *   Integer#chr
  # *   String#inspect and Regexp#inspect
  # *   Strings returned from Readline
  # *   Strings returned from SDBM
  # *   Time#zone
  # *   Values from ENV
  # *   Values in ARGV including $PROGRAM_NAME
  #
  #
  # Additionally String#encode and String#encode! use the default internal
  # encoding if no encoding is given.
  #
  # The script encoding (__ENCODING__), not default_internal, is used as the
  # encoding of created strings.
  #
  # Encoding::default_internal is initialized with -E option or nil otherwise.
  #
  def self.default_internal: () -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal = enc or nil
  # -->
  # Sets default internal encoding or removes default internal encoding when
  # passed nil.  You should not set Encoding::default_internal in ruby code as
  # strings created before changing the value may have a different encoding from
  # strings created after the change.  Instead you should use `ruby -E` to invoke
  # ruby with the correct default_internal.
  #
  # See Encoding::default_internal for information on how the default internal
  # encoding is used.
  #
  def self.default_internal=: (String arg0) -> String?
                            | (Encoding arg0) -> Encoding?
                            | (nil arg0) -> nil

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.find(string) -> enc
  # -->
  # Search the encoding with specified *name*. *name* should be a string.
  #
  #     Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>
  #
  # Names which this method accept are encoding names and aliases including
  # following special aliases
  #
  # "external"
  # :   default external encoding
  # "internal"
  # :   default internal encoding
  # "locale"
  # :   locale encoding
  # "filesystem"
  # :   filesystem encoding
  #
  #
  # An ArgumentError is raised when no encoding with *name*. Only
  # `Encoding.find("internal")` however returns nil when no encoding named
  # "internal", in other words, when Ruby has no default internal encoding.
  #
  def self.find: (String | Encoding arg0) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.list -> [enc1, enc2, ...]
  # -->
  # Returns the list of loaded encodings.
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:ISO-2022-JP (dummy)>]
  #
  #     Encoding.find("US-ASCII")
  #     #=> #<Encoding:US-ASCII>
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]
  #
  def self.list: () -> ::Array[Encoding]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.name_list -> ["enc1", "enc2", ...]
  # -->
  # Returns the list of available encoding names.
  #
  #     Encoding.name_list
  #     #=> ["US-ASCII", "ASCII-8BIT", "UTF-8",
  #           "ISO-8859-1", "Shift_JIS", "EUC-JP",
  #           "Windows-31J",
  #           "BINARY", "CP932", "eucJP"]
  #
  def self.name_list: () -> ::Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.ascii_compatible? -> true or false
  # -->
  # Returns whether ASCII-compatible or not.
  #
  #     Encoding::UTF_8.ascii_compatible?     #=> true
  #     Encoding::UTF_16BE.ascii_compatible?  #=> false
  #
  def ascii_compatible?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.dummy? -> true or false
  # -->
  # Returns true for dummy encodings. A dummy encoding is an encoding for which
  # character handling is not properly implemented. It is used for stateful
  # encodings.
  #
  #     Encoding::ISO_2022_JP.dummy?       #=> true
  #     Encoding::UTF_8.dummy?             #=> false
  #
  def dummy?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.inspect -> string
  # -->
  # Returns a string which represents the encoding for programmers.
  #
  #     Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"
  #     Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"
  #
  def inspect: () -> String

  # <!-- rdoc-file=encoding.c -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  def name: () -> String

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.names -> array
  # -->
  # Returns the list of name and aliases of the encoding.
  #
  #     Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J", "SJIS", "PCK"]
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.replicate(name) -> encoding
  # -->
  # Returns a replicated encoding of *enc* whose name is *name*. The new encoding
  # should have the same byte structure of *enc*. If *name* is used by another
  # encoding, raise ArgumentError.
  #
  def replicate: (String name) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.name -> string
  #   - enc.to_s -> string
  # -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  def to_s: () -> String
end

Encoding::ANSI_X3_4_1968: Encoding

Encoding::ASCII: Encoding

Encoding::ASCII_8BIT: Encoding

Encoding::BIG5: Encoding

Encoding::BIG5_HKSCS: Encoding

Encoding::BIG5_HKSCS_2008: Encoding

Encoding::BIG5_UAO: Encoding

Encoding::BINARY: Encoding

Encoding::Big5: Encoding

Encoding::Big5_HKSCS: Encoding

Encoding::Big5_HKSCS_2008: Encoding

Encoding::Big5_UAO: Encoding

Encoding::CESU_8: Encoding

Encoding::CP1250: Encoding

Encoding::CP1251: Encoding

Encoding::CP1252: Encoding

Encoding::CP1253: Encoding

Encoding::CP1254: Encoding

Encoding::CP1255: Encoding

Encoding::CP1256: Encoding

Encoding::CP1257: Encoding

Encoding::CP1258: Encoding

Encoding::CP437: Encoding

Encoding::CP50220: Encoding

Encoding::CP50221: Encoding

Encoding::CP51932: Encoding

Encoding::CP65000: Encoding

Encoding::CP65001: Encoding

Encoding::CP737: Encoding

Encoding::CP775: Encoding

Encoding::CP850: Encoding

Encoding::CP852: Encoding

Encoding::CP855: Encoding

Encoding::CP857: Encoding

Encoding::CP860: Encoding

Encoding::CP861: Encoding

Encoding::CP862: Encoding

Encoding::CP863: Encoding

Encoding::CP864: Encoding

Encoding::CP865: Encoding

Encoding::CP866: Encoding

Encoding::CP869: Encoding

Encoding::CP874: Encoding

Encoding::CP878: Encoding

Encoding::CP932: Encoding

Encoding::CP936: Encoding

Encoding::CP949: Encoding

Encoding::CP950: Encoding

Encoding::CP951: Encoding

Encoding::CSWINDOWS31J: Encoding

Encoding::CsWindows31J: Encoding

Encoding::EBCDIC_CP_US: Encoding

Encoding::EMACS_MULE: Encoding

Encoding::EUCCN: Encoding

Encoding::EUCJP: Encoding

Encoding::EUCJP_MS: Encoding

Encoding::EUCKR: Encoding

Encoding::EUCTW: Encoding

Encoding::EUC_CN: Encoding

Encoding::EUC_JISX0213: Encoding

Encoding::EUC_JIS_2004: Encoding

Encoding::EUC_JP: Encoding

Encoding::EUC_JP_MS: Encoding

Encoding::EUC_KR: Encoding

Encoding::EUC_TW: Encoding

Encoding::Emacs_Mule: Encoding

Encoding::EucCN: Encoding

Encoding::EucJP: Encoding

Encoding::EucJP_ms: Encoding

Encoding::EucKR: Encoding

Encoding::EucTW: Encoding

Encoding::GB12345: Encoding

Encoding::GB18030: Encoding

Encoding::GB1988: Encoding

Encoding::GB2312: Encoding

Encoding::GBK: Encoding

Encoding::IBM037: Encoding

Encoding::IBM437: Encoding

Encoding::IBM737: Encoding

Encoding::IBM775: Encoding

Encoding::IBM850: Encoding

Encoding::IBM852: Encoding

Encoding::IBM855: Encoding

Encoding::IBM857: Encoding

Encoding::IBM860: Encoding

Encoding::IBM861: Encoding

Encoding::IBM862: Encoding

Encoding::IBM863: Encoding

Encoding::IBM864: Encoding

Encoding::IBM865: Encoding

Encoding::IBM866: Encoding

Encoding::IBM869: Encoding

Encoding::ISO2022_JP: Encoding

Encoding::ISO2022_JP2: Encoding

Encoding::ISO8859_1: Encoding

Encoding::ISO8859_10: Encoding

Encoding::ISO8859_11: Encoding

Encoding::ISO8859_13: Encoding

Encoding::ISO8859_14: Encoding

Encoding::ISO8859_15: Encoding

Encoding::ISO8859_16: Encoding

Encoding::ISO8859_2: Encoding

Encoding::ISO8859_3: Encoding

Encoding::ISO8859_4: Encoding

Encoding::ISO8859_5: Encoding

Encoding::ISO8859_6: Encoding

Encoding::ISO8859_7: Encoding

Encoding::ISO8859_8: Encoding

Encoding::ISO8859_9: Encoding

Encoding::ISO_2022_JP: Encoding

Encoding::ISO_2022_JP_2: Encoding

Encoding::ISO_2022_JP_KDDI: Encoding

Encoding::ISO_8859_1: Encoding

Encoding::ISO_8859_10: Encoding

Encoding::ISO_8859_11: Encoding

Encoding::ISO_8859_13: Encoding

Encoding::ISO_8859_14: Encoding

Encoding::ISO_8859_15: Encoding

Encoding::ISO_8859_16: Encoding

Encoding::ISO_8859_2: Encoding

Encoding::ISO_8859_3: Encoding

Encoding::ISO_8859_4: Encoding

Encoding::ISO_8859_5: Encoding

Encoding::ISO_8859_6: Encoding

Encoding::ISO_8859_7: Encoding

Encoding::ISO_8859_8: Encoding

Encoding::ISO_8859_9: Encoding

Encoding::KOI8_R: Encoding

Encoding::KOI8_U: Encoding

Encoding::MACCENTEURO: Encoding

Encoding::MACCROATIAN: Encoding

Encoding::MACCYRILLIC: Encoding

Encoding::MACGREEK: Encoding

Encoding::MACICELAND: Encoding

Encoding::MACJAPAN: Encoding

Encoding::MACJAPANESE: Encoding

Encoding::MACROMAN: Encoding

Encoding::MACROMANIA: Encoding

Encoding::MACTHAI: Encoding

Encoding::MACTURKISH: Encoding

Encoding::MACUKRAINE: Encoding

Encoding::MacCentEuro: Encoding

Encoding::MacCroatian: Encoding

Encoding::MacCyrillic: Encoding

Encoding::MacGreek: Encoding

Encoding::MacIceland: Encoding

Encoding::MacJapan: Encoding

Encoding::MacJapanese: Encoding

Encoding::MacRoman: Encoding

Encoding::MacRomania: Encoding

Encoding::MacThai: Encoding

Encoding::MacTurkish: Encoding

Encoding::MacUkraine: Encoding

Encoding::PCK: Encoding

Encoding::SHIFT_JIS: Encoding

Encoding::SJIS: Encoding

Encoding::SJIS_DOCOMO: Encoding

Encoding::SJIS_DoCoMo: Encoding

Encoding::SJIS_KDDI: Encoding

Encoding::SJIS_SOFTBANK: Encoding

Encoding::SJIS_SoftBank: Encoding

Encoding::STATELESS_ISO_2022_JP: Encoding

Encoding::STATELESS_ISO_2022_JP_KDDI: Encoding

Encoding::Shift_JIS: Encoding

Encoding::Stateless_ISO_2022_JP: Encoding

Encoding::Stateless_ISO_2022_JP_KDDI: Encoding

Encoding::TIS_620: Encoding

Encoding::UCS_2BE: Encoding

Encoding::UCS_4BE: Encoding

Encoding::UCS_4LE: Encoding

Encoding::US_ASCII: Encoding

Encoding::UTF8_DOCOMO: Encoding

Encoding::UTF8_DoCoMo: Encoding

Encoding::UTF8_KDDI: Encoding

Encoding::UTF8_MAC: Encoding

Encoding::UTF8_SOFTBANK: Encoding

Encoding::UTF8_SoftBank: Encoding

Encoding::UTF_16: Encoding

Encoding::UTF_16BE: Encoding

Encoding::UTF_16LE: Encoding

Encoding::UTF_32: Encoding

Encoding::UTF_32BE: Encoding

Encoding::UTF_32LE: Encoding

Encoding::UTF_7: Encoding

Encoding::UTF_8: Encoding

Encoding::UTF_8_HFS: Encoding

Encoding::UTF_8_MAC: Encoding

Encoding::WINDOWS_1250: Encoding

Encoding::WINDOWS_1251: Encoding

Encoding::WINDOWS_1252: Encoding

Encoding::WINDOWS_1253: Encoding

Encoding::WINDOWS_1254: Encoding

Encoding::WINDOWS_1255: Encoding

Encoding::WINDOWS_1256: Encoding

Encoding::WINDOWS_1257: Encoding

Encoding::WINDOWS_1258: Encoding

Encoding::WINDOWS_31J: Encoding

Encoding::WINDOWS_874: Encoding

Encoding::Windows_1250: Encoding

Encoding::Windows_1251: Encoding

Encoding::Windows_1252: Encoding

Encoding::Windows_1253: Encoding

Encoding::Windows_1254: Encoding

Encoding::Windows_1255: Encoding

Encoding::Windows_1256: Encoding

Encoding::Windows_1257: Encoding

Encoding::Windows_1258: Encoding

Encoding::Windows_31J: Encoding

Encoding::Windows_874: Encoding

# <!-- rdoc-file=transcode.c -->
# Encoding conversion class.
#
class Encoding::Converter < Object
end

# <!-- rdoc-file=transcode.c -->
# AFTER_OUTPUT
#
# Stop converting after some output is complete but before all of the input was
# consumed.  See primitive_convert for an example.
#
Encoding::Converter::AFTER_OUTPUT: Integer

# <!-- rdoc-file=transcode.c -->
# CRLF_NEWLINE_DECORATOR
#
# Decorator for converting LF to CRLF
#
Encoding::Converter::CRLF_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# CR_NEWLINE_DECORATOR
#
# Decorator for converting LF to CR
#
Encoding::Converter::CR_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# INVALID_MASK
#
# Mask for invalid byte sequences
#
Encoding::Converter::INVALID_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# INVALID_REPLACE
#
# Replace invalid byte sequences
#
Encoding::Converter::INVALID_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# PARTIAL_INPUT
#
# Indicates the source may be part of a larger string.  See primitive_convert
# for an example.
#
Encoding::Converter::PARTIAL_INPUT: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_HEX_CHARREF
#
# Replace byte sequences that are undefined in the destination encoding with an
# XML hexadecimal character reference.  This is valid for XML conversion.
#
Encoding::Converter::UNDEF_HEX_CHARREF: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_MASK
#
# Mask for a valid character in the source encoding but no related character(s)
# in destination encoding.
#
Encoding::Converter::UNDEF_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_REPLACE
#
# Replace byte sequences that are undefined in the destination encoding.
#
Encoding::Converter::UNDEF_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# UNIVERSAL_NEWLINE_DECORATOR
#
# Decorator for converting CRLF and CR to LF
#
Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_ATTR_CONTENT_DECORATOR
#
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_CONTENT_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_ATTR_QUOTE_DECORATOR
#
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_QUOTE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_TEXT_DECORATOR
#
# Escape as XML CharData
#
Encoding::Converter::XML_TEXT_DECORATOR: Integer

# <!-- rdoc-file=error.c -->
# Raised by Encoding and String methods when the source encoding is incompatible
# with the target encoding.
#
class Encoding::CompatibilityError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by transcoding methods when a named encoding does not correspond with a
# known converter.
#
class Encoding::ConverterNotFoundError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by Encoding and String methods when the string being transcoded
# contains a byte invalid for the either the source or target encoding.
#
class Encoding::InvalidByteSequenceError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by Encoding and String methods when a transcoding operation fails.
#
class Encoding::UndefinedConversionError < EncodingError
end

# <!-- rdoc-file=math.c -->
# The Math module contains module functions for basic trigonometric and
# transcendental functions. See class Float for a list of constants that define
# Ruby's floating point accuracy.
#
# Domains and codomains are given only for real (not complex) numbers.
#
module Math
  # <!--
  #   rdoc-file=math.c
  #   - Math.acos(x)    -> Float
  # -->
  # Computes the arc cosine of `x`. Returns 0..PI.
  #
  # Domain: [-1, 1]
  #
  # Codomain: [0, PI]
  #
  #     Math.acos(0) == Math::PI/2  #=> true
  #
  def self.acos: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.acosh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic cosine of `x`.
  #
  # Domain: [1, INFINITY)
  #
  # Codomain: [0, INFINITY)
  #
  #     Math.acosh(1) #=> 0.0
  #
  def self.acosh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asin(x)    -> Float
  # -->
  # Computes the arc sine of `x`. Returns -PI/2..PI/2.
  #
  # Domain: [-1, -1]
  #
  # Codomain: [-PI/2, PI/2]
  #
  #     Math.asin(1) == Math::PI/2  #=> true
  #
  def self.asin: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asinh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic sine of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.asinh(1) #=> 0.881373587019543
  #
  def self.asinh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan(x)    -> Float
  # -->
  # Computes the arc tangent of `x`. Returns -PI/2..PI/2.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-PI/2, PI/2)
  #
  #     Math.atan(0) #=> 0.0
  #
  def self.atan: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan2(y, x)  -> Float
  # -->
  # Computes the arc tangent given `y` and `x`. Returns a Float in the range
  # -PI..PI. Return value is a angle in radians between the positive x-axis of
  # cartesian plane and the point given by the coordinates (`x`, `y`) on it.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-PI, PI]
  #
  #     Math.atan2(-0.0, -1.0) #=> -3.141592653589793
  #     Math.atan2(-1.0, -1.0) #=> -2.356194490192345
  #     Math.atan2(-1.0, 0.0)  #=> -1.5707963267948966
  #     Math.atan2(-1.0, 1.0)  #=> -0.7853981633974483
  #     Math.atan2(-0.0, 1.0)  #=> -0.0
  #     Math.atan2(0.0, 1.0)   #=> 0.0
  #     Math.atan2(1.0, 1.0)   #=> 0.7853981633974483
  #     Math.atan2(1.0, 0.0)   #=> 1.5707963267948966
  #     Math.atan2(1.0, -1.0)  #=> 2.356194490192345
  #     Math.atan2(0.0, -1.0)  #=> 3.141592653589793
  #     Math.atan2(INFINITY, INFINITY)   #=> 0.7853981633974483
  #     Math.atan2(INFINITY, -INFINITY)  #=> 2.356194490192345
  #     Math.atan2(-INFINITY, INFINITY)  #=> -0.7853981633974483
  #     Math.atan2(-INFINITY, -INFINITY) #=> -2.356194490192345
  #
  def self.atan2: (Numeric y, Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atanh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic tangent of `x`.
  #
  # Domain: (-1, 1)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.atanh(1) #=> Infinity
  #
  def self.atanh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cbrt(x)    -> Float
  # -->
  # Returns the cube root of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     -9.upto(9) {|x|
  #       p [x, Math.cbrt(x), Math.cbrt(x)**3]
  #     }
  #     #=> [-9, -2.0800838230519, -9.0]
  #     #   [-8, -2.0, -8.0]
  #     #   [-7, -1.91293118277239, -7.0]
  #     #   [-6, -1.81712059283214, -6.0]
  #     #   [-5, -1.7099759466767, -5.0]
  #     #   [-4, -1.5874010519682, -4.0]
  #     #   [-3, -1.44224957030741, -3.0]
  #     #   [-2, -1.25992104989487, -2.0]
  #     #   [-1, -1.0, -1.0]
  #     #   [0, 0.0, 0.0]
  #     #   [1, 1.0, 1.0]
  #     #   [2, 1.25992104989487, 2.0]
  #     #   [3, 1.44224957030741, 3.0]
  #     #   [4, 1.5874010519682, 4.0]
  #     #   [5, 1.7099759466767, 5.0]
  #     #   [6, 1.81712059283214, 6.0]
  #     #   [7, 1.91293118277239, 7.0]
  #     #   [8, 2.0, 8.0]
  #     #   [9, 2.0800838230519, 9.0]
  #
  def self.cbrt: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cos(x)    -> Float
  # -->
  # Computes the cosine of `x` (expressed in radians). Returns a Float in the
  # range -1.0..1.0.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-1, 1]
  #
  #     Math.cos(Math::PI) #=> -1.0
  #
  def self.cos: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cosh(x)    -> Float
  # -->
  # Computes the hyperbolic cosine of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [1, INFINITY)
  #
  #     Math.cosh(0) #=> 1.0
  #
  def self.cosh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erf(x)  -> Float
  # -->
  # Calculates the error function of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-1, 1)
  #
  #     Math.erf(0) #=> 0.0
  #
  def self.erf: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erfc(x)  -> Float
  # -->
  # Calculates the complementary error function of x.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (0, 2)
  #
  #     Math.erfc(0) #=> 1.0
  #
  def self.erfc: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.exp(x)    -> Float
  # -->
  # Returns e**x.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (0, INFINITY)
  #
  #     Math.exp(0)       #=> 1.0
  #     Math.exp(1)       #=> 2.718281828459045
  #     Math.exp(1.5)     #=> 4.4816890703380645
  #
  def self.exp: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.frexp(x)    -> [fraction, exponent]
  # -->
  # Returns a two-element array containing the normalized fraction (a Float) and
  # exponent (an Integer) of `x`.
  #
  #     fraction, exponent = Math.frexp(1234)   #=> [0.6025390625, 11]
  #     fraction * 2**exponent                  #=> 1234.0
  #
  def self.frexp: (Numeric x) -> [ Float, Integer ]

  # <!--
  #   rdoc-file=math.c
  #   - Math.gamma(x)  -> Float
  # -->
  # Calculates the gamma function of x.
  #
  # Note that gamma(n) is the same as fact(n-1) for integer n > 0. However
  # gamma(n) returns float and can be an approximation.
  #
  #     def fact(n) (1..n).inject(1) {|r,i| r*i } end
  #     1.upto(26) {|i| p [i, Math.gamma(i), fact(i-1)] }
  #     #=> [1, 1.0, 1]
  #     #   [2, 1.0, 1]
  #     #   [3, 2.0, 2]
  #     #   [4, 6.0, 6]
  #     #   [5, 24.0, 24]
  #     #   [6, 120.0, 120]
  #     #   [7, 720.0, 720]
  #     #   [8, 5040.0, 5040]
  #     #   [9, 40320.0, 40320]
  #     #   [10, 362880.0, 362880]
  #     #   [11, 3628800.0, 3628800]
  #     #   [12, 39916800.0, 39916800]
  #     #   [13, 479001600.0, 479001600]
  #     #   [14, 6227020800.0, 6227020800]
  #     #   [15, 87178291200.0, 87178291200]
  #     #   [16, 1307674368000.0, 1307674368000]
  #     #   [17, 20922789888000.0, 20922789888000]
  #     #   [18, 355687428096000.0, 355687428096000]
  #     #   [19, 6.402373705728e+15, 6402373705728000]
  #     #   [20, 1.21645100408832e+17, 121645100408832000]
  #     #   [21, 2.43290200817664e+18, 2432902008176640000]
  #     #   [22, 5.109094217170944e+19, 51090942171709440000]
  #     #   [23, 1.1240007277776077e+21, 1124000727777607680000]
  #     #   [24, 2.5852016738885062e+22, 25852016738884976640000]
  #     #   [25, 6.204484017332391e+23, 620448401733239439360000]
  #     #   [26, 1.5511210043330954e+25, 15511210043330985984000000]
  #
  def self.gamma: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.hypot(x, y)    -> Float
  # -->
  # Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle with
  # sides `x` and `y`.
  #
  #     Math.hypot(3, 4)   #=> 5.0
  #
  def self.hypot: (Numeric x, Numeric y) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.ldexp(fraction, exponent) -> float
  # -->
  # Returns the value of `fraction`*(2**`exponent`).
  #
  #     fraction, exponent = Math.frexp(1234)
  #     Math.ldexp(fraction, exponent)   #=> 1234.0
  #
  def self.ldexp: (Numeric fraction, Numeric exponent) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.lgamma(x)  -> [float, -1 or 1]
  # -->
  # Calculates the logarithmic gamma of `x` and the sign of gamma of `x`.
  #
  # Math.lgamma(x) is the same as
  #     [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]
  #
  # but avoids overflow by Math.gamma(x) for large x.
  #
  #     Math.lgamma(0) #=> [Infinity, 1]
  #
  def self.lgamma: (Numeric x) -> [ Float, Integer ]

  # <!--
  #   rdoc-file=math.c
  #   - Math.log(x)          -> Float
  #   - Math.log(x, base)    -> Float
  # -->
  # Returns the logarithm of `x`. If additional second argument is given, it will
  # be the base of logarithm. Otherwise it is `e` (for the natural logarithm).
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log(0)          #=> -Infinity
  #     Math.log(1)          #=> 0.0
  #     Math.log(Math::E)    #=> 1.0
  #     Math.log(Math::E**3) #=> 3.0
  #     Math.log(12, 3)      #=> 2.2618595071429146
  #
  def self.log: (Numeric x, ?Numeric base) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log10(x)    -> Float
  # -->
  # Returns the base 10 logarithm of `x`.
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log10(1)       #=> 0.0
  #     Math.log10(10)      #=> 1.0
  #     Math.log10(10**100) #=> 100.0
  #
  def self.log10: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log2(x)    -> Float
  # -->
  # Returns the base 2 logarithm of `x`.
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log2(1)      #=> 0.0
  #     Math.log2(2)      #=> 1.0
  #     Math.log2(32768)  #=> 15.0
  #     Math.log2(65536)  #=> 16.0
  #
  def self.log2: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sin(x)    -> Float
  # -->
  # Computes the sine of `x` (expressed in radians). Returns a Float in the range
  # -1.0..1.0.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-1, 1]
  #
  #     Math.sin(Math::PI/2) #=> 1.0
  #
  def self.sin: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sinh(x)    -> Float
  # -->
  # Computes the hyperbolic sine of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.sinh(0) #=> 0.0
  #
  def self.sinh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sqrt(x)    -> Float
  # -->
  # Returns the non-negative square root of `x`.
  #
  # Domain: [0, INFINITY)
  #
  # Codomain:[0, INFINITY)
  #
  #     0.upto(10) {|x|
  #       p [x, Math.sqrt(x), Math.sqrt(x)**2]
  #     }
  #     #=> [0, 0.0, 0.0]
  #     #   [1, 1.0, 1.0]
  #     #   [2, 1.4142135623731, 2.0]
  #     #   [3, 1.73205080756888, 3.0]
  #     #   [4, 2.0, 4.0]
  #     #   [5, 2.23606797749979, 5.0]
  #     #   [6, 2.44948974278318, 6.0]
  #     #   [7, 2.64575131106459, 7.0]
  #     #   [8, 2.82842712474619, 8.0]
  #     #   [9, 3.0, 9.0]
  #     #   [10, 3.16227766016838, 10.0]
  #
  # Note that the limited precision of floating point arithmetic might lead to
  # surprising results:
  #
  #     Math.sqrt(10**46).to_i  #=> 99999999999999991611392 (!)
  #
  # See also BigDecimal#sqrt and Integer.sqrt.
  #
  def self.sqrt: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tan(x)    -> Float
  # -->
  # Computes the tangent of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.tan(0) #=> 0.0
  #
  def self.tan: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tanh(x)    -> Float
  # -->
  # Computes the hyperbolic tangent of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-1, 1)
  #
  #     Math.tanh(0) #=> 0.0
  #
  def self.tanh: (Numeric x) -> Float
end

# <!-- rdoc-file=math.c -->
# Definition of the mathematical constant E for Euler's number (e) as a Float
# number.
#
Math::E: Float

# <!-- rdoc-file=math.c -->
# Definition of the mathematical constant PI as a Float number.
#
Math::PI: Float

# <!-- rdoc-file=math.c -->
# Raised when a mathematical function is evaluated outside of its domain of
# definition.
#
# For example, since `cos` returns values in the range -1..1, its inverse
# function `acos` is only defined on that interval:
#
#     Math.acos(42)
#
# *produces:*
#
#     Math::DomainError: Numerical argument is out of domain - "acos"
#
class Math::DomainError < StandardError
end

# <!-- rdoc-file=cont.c -->
# Fibers are primitives for implementing light weight cooperative concurrency in
# Ruby. Basically they are a means of creating code blocks that can be paused
# and resumed, much like threads. The main difference is that they are never
# preempted and that the scheduling must be done by the programmer and not the
# VM.
#
# As opposed to other stackless light weight concurrency models, each fiber
# comes with a stack.  This enables the fiber to be paused from deeply nested
# function calls within the fiber block.  See the ruby(1) manpage to configure
# the size of the fiber stack(s).
#
# When a fiber is created it will not run automatically. Rather it must be
# explicitly asked to run using the Fiber#resume method. The code running inside
# the fiber can give up control by calling Fiber.yield in which case it yields
# control back to caller (the caller of the Fiber#resume).
#
# Upon yielding or termination the Fiber returns the value of the last executed
# expression
#
# For instance:
#
#     fiber = Fiber.new do
#       Fiber.yield 1
#       2
#     end
#
#     puts fiber.resume
#     puts fiber.resume
#     puts fiber.resume
#
# *produces*
#
#     1
#     2
#     FiberError: dead fiber called
#
# The Fiber#resume method accepts an arbitrary number of parameters, if it is
# the first call to #resume then they will be passed as block arguments.
# Otherwise they will be the return value of the call to Fiber.yield
#
# Example:
#
#     fiber = Fiber.new do |first|
#       second = Fiber.yield first + 2
#     end
#
#     puts fiber.resume 10
#     puts fiber.resume 1_000_000
#     puts fiber.resume "The fiber will be dead before I can cause trouble"
#
# *produces*
#
#     12
#     1000000
#     FiberError: dead fiber called
#
# ## Non-blocking Fibers
#
# The concept of *non-blocking fiber* was introduced in Ruby 3.0. A non-blocking
# fiber, when reaching a operation that would normally block the fiber (like
# `sleep`, or wait for another process or I/O) will yield control to other
# fibers and allow the *scheduler* to handle blocking and waking up (resuming)
# this fiber when it can proceed.
#
# For a Fiber to behave as non-blocking, it need to be created in Fiber.new with
# `blocking: false` (which is the default), and Fiber.scheduler should be set
# with Fiber.set_scheduler. If Fiber.scheduler is not set in the current thread,
# blocking and non-blocking fibers' behavior is identical.
#
# Ruby doesn't provide a scheduler class: it is expected to be implemented by
# the user and correspond to Fiber::SchedulerInterface.
#
# There is also Fiber.schedule method, which is expected to immediately perform
# the given block in a non-blocking manner. Its actual implementation is up to
# the scheduler.
#
class Fiber < Object
  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.yield(args, ...) -> obj
  # -->
  # Yields control back to the context that resumed the fiber, passing along any
  # arguments that were passed to it. The fiber will resume processing at this
  # point when #resume is called next. Any arguments passed to the next #resume
  # will be the value that this Fiber.yield expression evaluates to.
  #
  def self.yield: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.new(blocking: false) { |*args| ... } -> fiber
  # -->
  # Creates new Fiber. Initially, the fiber is not running and can be resumed with
  # #resume. Arguments to the first #resume call will be passed to the block:
  #
  #     f = Fiber.new do |initial|
  #        current = initial
  #        loop do
  #          puts "current: #{current.inspect}"
  #          current = Fiber.yield
  #        end
  #     end
  #     f.resume(100)     # prints: current: 100
  #     f.resume(1, 2, 3) # prints: current: [1, 2, 3]
  #     f.resume          # prints: current: nil
  #     # ... and so on ...
  #
  # If `blocking: false` is passed to `Fiber.new`, *and* current thread has a
  # Fiber.scheduler defined, the Fiber becomes non-blocking (see "Non-blocking
  # Fibers" section in class docs).
  #
  def initialize: () { () -> untyped } -> void

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.resume(args, ...) -> obj
  # -->
  # Resumes the fiber from the point at which the last Fiber.yield was called, or
  # starts running it if it is the first call to #resume. Arguments passed to
  # resume will be the value of the Fiber.yield expression or will be passed as
  # block parameters to the fiber's block if this is the first #resume.
  #
  # Alternatively, when resume is called it evaluates to the arguments passed to
  # the next Fiber.yield statement inside the fiber's block or to the block value
  # if it runs to completion without any Fiber.yield
  #
  def resume: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.raise                                 -> obj
  #   - fiber.raise(string)                         -> obj
  #   - fiber.raise(exception [, string [, array]]) -> obj
  # -->
  # Raises an exception in the fiber at the point at which the last `Fiber.yield`
  # was called. If the fiber has not been started or has already run to
  # completion, raises `FiberError`. If the fiber is yielding, it is resumed. If
  # it is transferring, it is transferred into. But if it is resuming, raises
  # `FiberError`.
  #
  # With no arguments, raises a `RuntimeError`. With a single `String` argument,
  # raises a `RuntimeError` with the string as a message.  Otherwise, the first
  # parameter should be the name of an `Exception` class (or an object that
  # returns an `Exception` object when sent an `exception` message). The optional
  # second parameter sets the message associated with the exception, and the third
  # parameter is an array of callback information. Exceptions are caught by the
  # `rescue` clause of `begin...end` blocks.
  #
  def raise: () -> untyped
           | (string message) -> untyped
           | (_Exception exception, ?string message, ?Array[String] backtrace) -> untyped
end

# <!-- rdoc-file=gc.c -->
# The ObjectSpace module contains a number of routines that interact with the
# garbage collection facility and allow you to traverse all living objects with
# an iterator.
#
# ObjectSpace also provides support for object finalizers, procs that will be
# called when a specific object is about to be destroyed by garbage collection.
# See the documentation for `ObjectSpace.define_finalizer` for important
# information on how to use this method correctly.
#
#     a = "A"
#     b = "B"
#
#     ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
#     ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })
#
#     a = nil
#     b = nil
#
# *produces:*
#
#     Finalizer two on 537763470
#     Finalizer one on 537763480
#
%a{annotate:rdoc:source:from=gc.c}
module ObjectSpace
  # <!--
  #   rdoc-file=gc.c
  #   - _id2ref(p1)
  # -->
  #
  def self._id2ref: (Integer id) -> untyped

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.count_objects([result_hash]) -> hash
  # -->
  # Counts all objects grouped by type.
  #
  # It returns a hash, such as:
  #     {
  #       :TOTAL=>10000,
  #       :FREE=>3011,
  #       :T_OBJECT=>6,
  #       :T_CLASS=>404,
  #       # ...
  #     }
  #
  # The contents of the returned hash are implementation specific. It may be
  # changed in future.
  #
  # The keys starting with `:T_` means live objects. For example, `:T_ARRAY` is
  # the number of arrays. `:FREE` means object slots which is not used now.
  # `:TOTAL` means sum of above.
  #
  # If the optional argument `result_hash` is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  #     h = {}
  #     ObjectSpace.count_objects(h)
  #     puts h
  #     # => { :TOTAL=>10000, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249 }
  #
  # This method is only expected to work on C Ruby.
  #
  def self.count_objects: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.define_finalizer(obj, aProc=proc())
  # -->
  # Adds *aProc* as a finalizer, to be called after *obj* was destroyed. The
  # object ID of the *obj* will be passed as an argument to *aProc*. If *aProc* is
  # a lambda or method, make sure it can be called with a single argument.
  #
  # The return value is an array `[0, aProc]`.
  #
  # The two recommended patterns are to either create the finaliser proc in a
  # non-instance method where it can safely capture the needed state, or to use a
  # custom callable object that stores the needed state explicitly as instance
  # variables.
  #
  #     class Foo
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, self.class.create_finalizer(data_needed_for_finalization))
  #       end
  #
  #       def self.create_finalizer(data_needed_for_finalization)
  #         proc {
  #           puts "finalizing #{data_needed_for_finalization}"
  #         }
  #       end
  #     end
  #
  #     class Bar
  #      class Remover
  #         def initialize(data_needed_for_finalization)
  #           @data_needed_for_finalization = data_needed_for_finalization
  #         end
  #
  #         def call(id)
  #           puts "finalizing #{@data_needed_for_finalization}"
  #         end
  #       end
  #
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, Remover.new(data_needed_for_finalization))
  #       end
  #     end
  #
  # Note that if your finalizer references the object to be finalized it will
  # never be run on GC, although it will still be run at exit. You will get a
  # warning if you capture the object to be finalized as the receiver of the
  # finalizer.
  #
  #     class CapturesSelf
  #       def initialize(name)
  #         ObjectSpace.define_finalizer(self, proc {
  #           # this finalizer will only be run on exit
  #           puts "finalizing #{name}"
  #         })
  #       end
  #     end
  #
  # Also note that finalization can be unpredictable and is never guaranteed to be
  # run except on exit.
  #
  def self.define_finalizer: (untyped obj, ^(Integer id) -> void aProc) -> [ Integer, Proc ]
                           | (untyped obj) { (Integer id) -> void } -> [ Integer, Proc ]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.each_object([module]) {|obj| ... } -> integer
  #   - ObjectSpace.each_object([module])              -> an_enumerator
  # -->
  # Calls the block once for each living, nonimmediate object in this Ruby
  # process. If *module* is specified, calls the block for only those classes or
  # modules that match (or are a subclass of) *module*. Returns the number of
  # objects found. Immediate objects (`Fixnum`s, `Symbol`s `true`, `false`, and
  # `nil`) are never returned. In the example below, #each_object returns both the
  # numbers we defined and several constants defined in the Math module.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     a = 102.7
  #     b = 95       # Won't be returned
  #     c = 12345678987654321
  #     count = ObjectSpace.each_object(Numeric) {|x| p x }
  #     puts "Total count: #{count}"
  #
  # *produces:*
  #
  #     12345678987654321
  #     102.7
  #     2.71828182845905
  #     3.14159265358979
  #     2.22044604925031e-16
  #     1.7976931348623157e+308
  #     2.2250738585072e-308
  #     Total count: 7
  #
  def self.each_object: (?Module `module`) -> Enumerator[untyped, Integer]
                      | (?Module `module`) { (untyped obj) -> void } -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def self.garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.undefine_finalizer(obj)
  # -->
  # Removes all finalizers for *obj*.
  #
  def self.undefine_finalizer: [X] (X obj) -> X

  private

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void
end

# <!-- rdoc-file=object.c -->
# Classes in Ruby are first-class objects---each is an instance of class Class.
#
# Typically, you create a new class by using:
#
#     class Name
#      # some code describing the class behavior
#     end
#
# When a new class is created, an object of type Class is initialized and
# assigned to a global constant (Name in this case).
#
# When `Name.new` is called to create a new object, the #new method in Class is
# run by default. This can be demonstrated by overriding #new in Class:
#
#     class Class
#       alias old_new new
#       def new(*args)
#         print "Creating a new ", self.name, "\n"
#         old_new(*args)
#       end
#     end
#
#     class Name
#     end
#
#     n = Name.new
#
# *produces:*
#
#     Creating a new Name
#
# Classes, modules, and objects are interrelated. In the diagram that follows,
# the vertical arrows represent inheritance, and the parentheses metaclasses.
# All metaclasses are instances of the class `Class'.
#                              +---------+             +-...
#                              |         |             |
#              BasicObject-----|-->(BasicObject)-------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#               Object---------|----->(Object)---------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#                  +-------+   |         +--------+    |
#                  |       |   |         |        |    |
#                  |    Module-|---------|--->(Module)-|-...
#                  |       ^   |         |        ^    |
#                  |       |   |         |        |    |
#                  |     Class-|---------|---->(Class)-|-...
#                  |       ^   |         |        ^    |
#                  |       +---+         |        +----+
#                  |                     |
#     obj--->OtherClass---------->(OtherClass)-----------...
#
%a{annotate:rdoc:source:from=object.c}
class Class < Module
  # <!--
  #   rdoc-file=object.c
  #   - Class.new(super_class=Object)               -> a_class
  #   - Class.new(super_class=Object) { |mod| ... } -> a_class
  # -->
  # Creates a new anonymous (unnamed) class with the given superclass (or Object
  # if no parameter is given). You can give a class a name by assigning the class
  # object to a constant.
  #
  # If a block is given, it is passed the class object, and the block is evaluated
  # in the context of this class like #class_eval.
  #
  #     fred = Class.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #
  #     a = fred.new     #=> #<#<Class:0x100381890>:0x100376b98>
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the class to a constant (name starting uppercase) if you want to treat
  # it like a regular class.
  #
  def initialize: (?Class superclass) ?{ (Class newclass) -> void } -> void

  # <!--
  #   rdoc-file=object.c
  #   - class.allocate()   ->   obj
  # -->
  # Allocates space for a new object of *class*'s class and does not call
  # initialize on the new instance. The returned object must be an instance of
  # *class*.
  #
  #     klass = Class.new do
  #       def initialize(*args)
  #         @initialized = true
  #       end
  #
  #       def initialized?
  #         @initialized || false
  #       end
  #     end
  #
  #     klass.allocate.initialized? #=> false
  #
  def allocate: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - inherited(subclass)
  # -->
  # Callback invoked whenever a subclass of the current class is created.
  #
  # Example:
  #
  #     class Foo
  #       def self.inherited(subclass)
  #         puts "New subclass: #{subclass}"
  #       end
  #     end
  #
  #     class Bar < Foo
  #     end
  #
  #     class Baz < Bar
  #     end
  #
  # *produces:*
  #
  #     New subclass: Bar
  #     New subclass: Baz
  #
  def inherited: (Class arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - class.new(args, ...)    ->  obj
  # -->
  # Calls #allocate to create a new object of *class*'s class, then invokes that
  # object's #initialize method, passing it *args*.  This is the method that ends
  # up getting called whenever an object is constructed using `.new`.
  #
  def new: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - subclasses -> array
  # -->
  # Returns an array of classes where the receiver is the direct superclass of the
  # class, excluding singleton classes. The order of the returned array is not
  # defined.
  #
  #     class A; end
  #     class B < A; end
  #     class C < B; end
  #     class D < A; end
  #
  #     A.subclasses        #=> [D, B]
  #     B.subclasses        #=> [C]
  #     C.subclasses        #=> []
  #
  def subclasses: () -> Array[Class]

  # <!--
  #   rdoc-file=object.c
  #   - class.superclass -> a_super_class or nil
  # -->
  # Returns the superclass of *class*, or `nil`.
  #
  #     File.superclass          #=> IO
  #     IO.superclass            #=> Object
  #     Object.superclass        #=> BasicObject
  #     class Foo; end
  #     class Bar < Foo; end
  #     Bar.superclass           #=> Foo
  #
  # Returns nil when the given class does not have a parent class:
  #
  #     BasicObject.superclass   #=> nil
  #
  def superclass: () -> Class?
end

# <!-- rdoc-file=io.c -->
# The IO class is the basis for all input and output in Ruby. An I/O stream may
# be *duplexed* (that is, bidirectional), and so may use more than one native
# operating system stream.
#
# Many of the examples in this section use the File class, the only standard
# subclass of IO. The two classes are closely associated.  Like the File class,
# the Socket library subclasses from IO (such as TCPSocket or UDPSocket).
#
# The Kernel#open method can create an IO (or File) object for these types of
# arguments:
#
# *   A plain string represents a filename suitable for the underlying operating
#     system.
#
# *   A string starting with `"|"` indicates a subprocess. The remainder of the
#     string following the `"|"` is invoked as a process with appropriate
#     input/output channels connected to it.
#
# *   A string equal to `"|-"` will create another Ruby instance as a
#     subprocess.
#
#
# The IO may be opened with different file modes (read-only, write-only) and
# encodings for proper conversion.  See IO.new for these options.  See
# Kernel#open for details of the various command formats described above.
#
# IO.popen, the Open3 library, or  Process#spawn may also be used to communicate
# with subprocesses through an IO.
#
# Ruby will convert pathnames between different operating system conventions if
# possible.  For instance, on a Windows system the filename
# `"/gumby/ruby/test.rb"` will be opened as `"\gumby\ruby\test.rb"`.  When
# specifying a Windows-style filename in a Ruby string, remember to escape the
# backslashes:
#
#     "C:\\gumby\\ruby\\test.rb"
#
# Our examples here will use the Unix-style forward slashes; File::ALT_SEPARATOR
# can be used to get the platform-specific separator character.
#
# The global constant ARGF (also accessible as `$<`) provides an IO-like stream
# which allows access to all files mentioned on the command line (or STDIN if no
# files are mentioned). ARGF#path and its alias ARGF#filename are provided to
# access the name of the file currently being read.
#
# ## io/console
#
# The io/console extension provides methods for interacting with the console.
# The console can be accessed from IO.console or the standard input/output/error
# IO objects.
#
# Requiring io/console adds the following methods:
#
# *   IO::console
# *   IO#raw
# *   IO#raw!
# *   IO#cooked
# *   IO#cooked!
# *   IO#getch
# *   IO#echo=
# *   IO#echo?
# *   IO#noecho
# *   IO#winsize
# *   IO#winsize=
# *   IO#iflush
# *   IO#ioflush
# *   IO#oflush
#
#
# Example:
#
#     require 'io/console'
#     rows, columns = $stdout.winsize
#     puts "Your screen is #{columns} wide and #{rows} tall"
#
# ## Example Files
#
# Many examples here use these filenames and their corresponding files:
#
# *   `t.txt`: A text-only file that is assumed to exist via:
#
#         text = <<~EOT
#           This is line one.
#           This is the second line.
#           This is the third line.
#         EOT
#         File.write('t.txt', text)
#
# *   `t.dat`: A data file that is assumed to exist via:
#
#         data = "\u9990\u9991\u9992\u9993\u9994"
#         f = File.open('t.dat', 'wb:UTF-16')
#         f.write(data)
#         f.close
#
# *   `t.rus`: A Russian-language text file that is assumed to exist via:
#
#         File.write('t.rus', "\u{442 435 441 442}")
#
# *   `t.tmp`: A file that is assumed *not* to exist.
#
#
# ## Modes
#
# A number of IO method calls must or may specify a *mode* for the stream; the
# mode determines how stream is to be accessible, including:
#
# *   Whether the stream is to be read-only, write-only, or read-write.
# *   Whether the stream is positioned at its beginning or its end.
# *   Whether the stream treats data as text-only or binary.
# *   The external and internal encodings.
#
#
# ### Mode Specified as an Integer
#
# When `mode` is an integer it must be one or more (combined by bitwise OR (`|`)
# of the modes defined in File::Constants:
#
# *   `File::RDONLY`: Open for reading only.
# *   `File::WRONLY`: Open for writing only.
# *   `File::RDWR`: Open for reading and writing.
# *   `File::APPEND`: Open for appending only.
# *   `File::CREAT`: Create file if it does not exist.
# *   `File::EXCL`: Raise an exception if `File::CREAT` is given and the file
#     exists.
#
#
# Examples:
#
#     File.new('t.txt', File::RDONLY)
#     File.new('t.tmp', File::RDWR | File::CREAT | File::EXCL)
#
# Note: Method IO#set_encoding does not allow the mode to be specified as an
# integer.
#
# ### Mode Specified As a String
#
# When `mode` is a string it must begin with one of the following:
#
# *   `'r'`: Read-only stream, positioned at the beginning; the stream cannot be
#     changed to writable.
# *   `'w'`: Write-only stream, positioned at the beginning; the stream cannot
#     be changed to readable.
# *   `'a'`: Write-only stream, positioned at the end; every write appends to
#     the end; the stream cannot be changed to readable.
# *   `'r+'`: Read-write stream, positioned at the beginning.
# *   `'w+'`: Read-write stream, positioned at the end.
# *   `'a+'`: Read-write stream, positioned at the end.
#
#
# For a writable file stream (that is, any except read-only), the file is
# truncated to zero if it exists, and is created if it does not exist.
#
# Examples:
#
#     File.open('t.txt', 'r')
#     File.open('t.tmp', 'w')
#
# Either of the following may be suffixed to any of the above:
#
# *   `'t'`: Text data; sets the default external encoding to `Encoding::UTF_8`;
#     on Windows, enables conversion between EOL and CRLF.
# *   `'b'`: Binary data; sets the default external encoding to
#     `Encoding::ASCII_8BIT`; on Windows, suppresses conversion between EOL and
#     CRLF.
#
#
# If neither is given, the stream defaults to text data.
#
# Examples:
#
#     File.open('t.txt', 'rt')
#     File.open('t.dat', 'rb')
#
# The following may be suffixed to any writable mode above:
#
# *   `'x'`: Creates the file if it does not exist; raises an exception if the
#     file exists.
#
#
# Example:
#
#     File.open('t.tmp', 'wx')
#
# Finally, the mode string may specify encodings -- either external encoding
# only or both external and internal encodings -- by appending one or both
# encoding names, separated by colons:
#
#     f = File.new('t.dat', 'rb')
#     f.external_encoding # => #<Encoding:ASCII-8BIT>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => #<Encoding:UTF-16>
#
# The numerous encoding names are available in array Encoding.name_list:
#
#     Encoding.name_list.size    # => 175
#     Encoding.name_list.take(3) # => ["ASCII-8BIT", "UTF-8", "US-ASCII"]
#
# ## Encodings
#
# When the external encoding is set, strings read are tagged by that encoding
# when reading, and strings written are converted to that encoding when writing.
#
# When both external and internal encodings are set, strings read are converted
# from external to internal encoding, and strings written are converted from
# internal to external encoding. For further details about transcoding input and
# output, see Encoding.
#
# If the external encoding is `'BOM|UTF-8'`, `'BOM|UTF-16LE'` or
# `'BOM|UTF16-BE'`, Ruby checks for a Unicode BOM in the input document to help
# determine the encoding.  For UTF-16 encodings the file open mode must be
# binary. If the BOM is found, it is stripped and the external encoding from the
# BOM is used.
#
# Note that the BOM-style encoding option is case insensitive, so 'bom|utf-8' is
# also valid.)
#
# ## Open Options
#
# A number of IO methods accept an optional parameter `opts`, which determines
# how a new stream is to be opened:
#
# *   `:mode`: Stream mode.
# *   `:flags`: Integer file open flags; If `mode` is also given, the two are
#     bitwise-ORed.
# *   `:external_encoding`: External encoding for the stream.
# *   `:internal_encoding`: Internal encoding for the stream. `'-'` is a synonym
#     for the default internal encoding. If the value is `nil` no conversion
#     occurs.
# *   `:encoding`: Specifies external and internal encodings as
#     `'extern:intern'`.
# *   `:textmode`: If a truthy value, specifies the mode as text-only, binary
#     otherwise.
# *   `:binmode`: If a truthy value, specifies the mode as binary, text-only
#     otherwise.
# *   `:autoclose`: If a truthy value, specifies that the `fd` will close when
#     the stream closes; otherwise it remains open.
#
#
# Also available are the options offered in String#encode, which may control
# conversion between external internal encoding.
#
# ## Getline Options
#
# A number of IO methods accept optional keyword arguments that determine how a
# stream is to be treated:
#
# *   `:chomp`: If `true`, line separators are omitted; default is  `false`.
#
#
# ## Position
#
# An IO stream has a *position*, which is the non-negative integer offset (in
# bytes) in the stream where the next read or write will occur.
#
# Note that a text stream may have multi-byte characters, so a text stream whose
# position is `n` (*bytes*) may not have `n` *characters* preceding the current
# position -- there may be fewer.
#
# A new stream is initially positioned:
#
# *   At the beginning (position `0`) if its mode is `'r'`, `'w'`, or `'r+'`.
# *   At the end (position `self.size`) if its mode is `'a'`, `'w+'`, or `'a+'`.
#
#
# Methods to query the position:
#
# *   IO#tell and its alias IO#pos return the position for an open stream.
# *   IO#eof? and its alias IO#eof return whether the position is at the end of
#     a readable stream.
#
#
# Reading from a stream usually changes its position:
#
#     f = File.open('t.txt')
#     f.tell     # => 0
#     f.readline # => "This is line one.\n"
#     f.tell     # => 19
#     f.readline # => "This is the second line.\n"
#     f.tell     # => 45
#     f.eof?     # => false
#     f.readline # => "Here's the third line.\n"
#     f.eof?     # => true
#
# Writing to a stream usually changes its position:
#
#     f = File.open('t.tmp', 'w')
#     f.tell         # => 0
#     f.write('foo') # => 3
#     f.tell         # => 3
#     f.write('bar') # => 3
#     f.tell         # => 6
#
# Iterating over a stream usually changes its position:
#
#     f = File.open('t.txt')
#     f.each do |line|
#       p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
#     end
#
# Output:
#
#     "position=19 eof?=false line=This is line one.\n"
#     "position=45 eof?=false line=This is the second line.\n"
#     "position=70 eof?=true line=This is the third line.\n"
#
# The position may also be changed by certain other methods:
#
# *   IO#pos= and IO#seek change the position to a specified offset.
# *   IO#rewind changes the position to the beginning.
#
#
# ## Line Number
#
# A readable IO stream has a *line* *number*, which is the non-negative integer
# line number in the stream where the next read will occur.
#
# A new stream is initially has line number `0`.
#
# Method IO#lineno returns the line number.
#
# Reading lines from a stream usually changes its line number:
#
#     f = File.open('t.txt', 'r')
#     f.lineno   # => 0
#     f.readline # => "This is line one.\n"
#     f.lineno   # => 1
#     f.readline # => "This is the second line.\n"
#     f.lineno   # => 2
#     f.readline # => "Here's the third line.\n"
#     f.lineno   # => 3
#     f.eof?     # => true
#
# Iterating over lines in a stream usually changes its line number:
#
#     f = File.open('t.txt')
#     f.each_line do |line|
#       p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
#     end
#
# Output:
#
#     "position=19 eof?=false line=This is line one.\n"
#     "position=45 eof?=false line=This is the second line.\n"
#     "position=70 eof?=true line=This is the third line.\n"
#
# ## What's Here
#
# First, what's elsewhere. Class IO:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class IO provides methods that are useful for:
#
# *   [Creating](#class-IO-label-Creating)
# *   [Reading](#class-IO-label-Reading)
# *   [Writing](#class-IO-label-Writing)
# *   [Positioning](#class-IO-label-Positioning)
# *   [Iterating](#class-IO-label-Iterating)
# *   [Settings](#class-IO-label-Settings)
# *   [Querying](#class-IO-label-Querying)
# *   [Buffering](#class-IO-label-Buffering)
# *   [Low-Level Access](#class-IO-label-Low-Level+Access)
# *   [Other](#class-IO-label-Other)
#
#
# ### Creating
#
#     ::new (aliased as ::for_fd)
# :       Creates and returns a new IO object for the given integer file
#         descriptor.
#
#     ::open
# :       Creates a new IO object.
#
#     ::pipe
# :       Creates a connected pair of reader and writer IO objects.
#
#     ::popen
# :       Creates an IO object to interact with a subprocess.
#
#     ::select
# :       Selects which given IO instances are ready for reading,
#
#     writing, or have pending exceptions.
#
#
# ### Reading
#
#     ::binread
# :       Returns a binary string with all or a subset of bytes from the given
#         file.
#
#     ::read
# :       Returns a string with all or a subset of bytes from the given file.
#
#     ::readlines
# :       Returns an array of strings, which are the lines from the given file.
#
#     #getbyte
# :       Returns the next 8-bit byte read from `self` as an integer.
#
#     #getc
# :       Returns the next character read from `self` as a string.
#
#     #gets
# :       Returns the line read from `self`.
#
#     #pread
# :       Returns all or the next *n* bytes read from `self`, not updating the
#         receiver's offset.
#
#     #read
# :       Returns all remaining or the next *n* bytes read from `self` for a
#         given *n*.
#
#     #read_nonblock
# :       the next *n* bytes read from `self` for a given *n*, in non-block
#         mode.
#
#     #readbyte
# :       Returns the next byte read from `self`; same as #getbyte, but raises
#         an exception on end-of-file.
#
#     #readchar
# :       Returns the next character read from `self`; same as #getc, but raises
#         an exception on end-of-file.
#
#     #readline
# :       Returns the next line read from `self`; same as #getline, but raises
#         an exception of end-of-file.
#
#     #readlines
# :       Returns an array of all lines read read from `self`.
#
#     #readpartial
# :       Returns up to the given number of bytes from `self`.
#
#
#
# ### Writing
#
#     ::binwrite
# :       Writes the given string to the file at the given filepath, in binary
#         mode.
#
#     ::write
# :       Writes the given string to `self`.
#
#     [:<<](#method-i-3C-3C)
# :       Appends the given string to `self`.
#
#     #print
# :       Prints last read line or given objects to `self`.
#
#     #printf
# :       Writes to `self` based on the given format string and objects.
#
#     #putc
# :       Writes a character to `self`.
#
#     #puts
# :       Writes lines to `self`, making sure line ends with a newline.
#
#     #pwrite
# :       Writes the given string at the given offset, not updating the
#         receiver's offset.
#
#     #write
# :       Writes one or more given strings to `self`.
#
#     #write_nonblock
# :       Writes one or more given strings to `self` in non-blocking mode.
#
#
#
# ### Positioning
#
#     #lineno
# :       Returns the current line number in `self`.
#
#     #lineno=
# :       Sets the line number is `self`.
#
#     #pos (aliased as #tell)
# :       Returns the current byte offset in `self`.
#
#     #pos=
# :       Sets the byte offset in `self`.
#
#     #reopen
# :       Reassociates `self` with a new or existing IO stream.
#
#     #rewind
# :       Positions `self` to the beginning of input.
#
#     #seek
# :       Sets the offset for `self` relative to given position.
#
#
#
# ### Iterating
#
#     ::foreach
# :       Yields each line of given file to the block.
#
#     #each (aliased as #each_line)
# :       Calls the given block with each successive line in `self`.
#
#     #each_byte
# :       Calls the given block with each successive byte in `self` as an
#         integer.
#
#     #each_char
# :       Calls the given block with each successive character in `self` as a
#         string.
#
#     #each_codepoint
# :       Calls the given block with each successive codepoint in `self` as an
#         integer.
#
#
#
# ### Settings
#
#     #autoclose=
# :       Sets whether `self` auto-closes.
#
#     #binmode
# :       Sets `self` to binary mode.
#
#     #close
# :       Closes `self`.
#
#     #close_on_exec=
# :       Sets the close-on-exec flag.
#
#     #close_read
# :       Closes `self` for reading.
#
#     #close_write
# :       Closes `self` for writing.
#
#     #set_encoding
# :       Sets the encoding for `self`.
#
#     #set_encoding_by_bom
# :       Sets the encoding for `self`, based on its Unicode byte-order-mark.
#
#     #sync=
# :       Sets the sync-mode to the given value.
#
#
#
# ### Querying
#
#     #autoclose?
# :       Returns whether `self` auto-closes.
#
#     #binmode?
# :       Returns whether `self` is in binary mode.
#
#     #close_on_exec?
# :       Returns the close-on-exec flag for `self`.
#
#     #closed?
# :       Returns whether `self` is closed.
#
#     #eof? (aliased as #eof)
# :       Returns whether `self` is at end-of-file.
#
#     #external_encoding
# :       Returns the external encoding object for `self`.
#
#     #fileno (aliased as #to_i)
# :       Returns the integer file descriptor for `self`
#
#     #internal_encoding
# :       Returns the internal encoding object for `self`.
#
#     #pid
# :       Returns the process ID of a child process associated with `self`, if
#         `self` was created by ::popen.
#
#     #stat
# :       Returns the File::Stat object containing status information for
#         `self`.
#
#     #sync
# :       Returns whether `self` is in sync-mode.
#
#     #tty (aliased as #isatty)
# :       Returns whether `self` is a terminal.
#
#
#
# ### Buffering
#
#     #fdatasync
# :       Immediately writes all buffered data in `self` to disk.
#
#     #flush
# :       Flushes any buffered data within `self` to the underlying operating
#         system.
#
#     #fsync
# :       Immediately writes all buffered data and attributes in `self` to disk.
#
#     #ungetbyte
# :       Prepends buffer for `self` with given integer byte or string.
#
#     #ungetc
# :       Prepends buffer for `self` with given string.
#
#
#
# ### Low-Level Access
#
#     ::sysopen
# :       Opens the file given by its path, returning the integer file
#         descriptor.
#
#     #advise
# :       Announces the intention to access data from `self` in a specific way.
#
#     #fcntl
# :       Passes a low-level command to the file specified by the given file
#         descriptor.
#
#     #ioctl
# :       Passes a low-level command to the device specified by the given file
#         descriptor.
#
#     #sysread
# :       Returns up to the next *n* bytes read from self using a low-level
#         read.
#
#     #sysseek
# :       Sets the offset for `self`.
#
#     #syswrite
# :       Writes the given string to `self` using a low-level write.
#
#
#
# ### Other
#
#     ::copy_stream
# :       Copies data from a source to a destination, each of which is a
#         filepath or an IO-like object.
#
#     ::try_convert
# :       Returns a new IO object resulting from converting the given object.
#
#     #inspect
# :       Returns the string representation of `self`.
#
%a{annotate:rdoc:source:from=io.c}
class IO < Object
  include File::Constants

  include Enumerable[String]

  # <!--
  #   rdoc-file=io.c
  #   - self << object -> self
  # -->
  # Writes the given `object` to `self`, which must be opened for writing (see
  # [Modes](#class-IO-label-Modes)); returns `self`; if `object` is not a string,
  # it is converted via method `to_s`:
  #
  #     $stdout << 'Hello' << ', ' << 'World!' << "\n"
  #     $stdout << 'foo' << :bar << 2 << "\n"
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  def <<: (_ToS obj) -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.advise(advice, offset=0, len=0) -> nil
  # -->
  # Announce an intention to access data from the current file in a specific
  # pattern. On platforms that do not support the *posix_fadvise(2)* system call,
  # this method is a no-op.
  #
  # *advice* is one of the following symbols:
  #
  # :normal
  # :   No advice to give; the default assumption for an open file.
  # :sequential
  # :   The data will be accessed sequentially with lower offsets read before
  #     higher ones.
  # :random
  # :   The data will be accessed in random order.
  # :willneed
  # :   The data will be accessed in the near future.
  # :dontneed
  # :   The data will not be accessed in the near future.
  # :noreuse
  # :   The data will only be accessed once.
  #
  #
  # The semantics of a piece of advice are platform-dependent. See *man 2
  # posix_fadvise* for details.
  #
  # "data" means the region of the current file that begins at *offset* and
  # extends for *len* bytes. If *len* is 0, the region ends at the last byte of
  # the file. By default, both *offset* and *len* are 0, meaning that the advice
  # applies to the entire file.
  #
  # If an error occurs, one of the following exceptions will be raised:
  #
  # IOError
  # :   The IO stream is closed.
  # Errno::EBADF
  # :   The file descriptor of the current file is invalid.
  # Errno::EINVAL
  # :   An invalid value for *advice* was given.
  # Errno::ESPIPE
  # :   The file descriptor of the current file refers to a FIFO or pipe. (Linux
  #     raises Errno::EINVAL in this case).
  # TypeError
  # :   Either *advice* was not a Symbol, or one of the other arguments was not an
  #     Integer.
  # RangeError
  # :   One of the arguments given was too big/small.
  #
  # This list is not exhaustive; other Errno
  # :   exceptions are also possible.
  #
  def advise: (:normal | :sequential | :random | :willneed | :dontneed | :noreuse advise, ?Integer offset, ?Integer len) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - io.autoclose = bool    -> true or false
  # -->
  # Sets auto-close flag.
  #
  #     f = open("/dev/null")
  #     IO.for_fd(f.fileno)
  #     # ...
  #     f.gets # may cause Errno::EBADF
  #
  #     f = open("/dev/null")
  #     IO.for_fd(f.fileno).autoclose = false
  #     # ...
  #     f.gets # won't cause Errno::EBADF
  #
  def autoclose=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.autoclose?   -> true or false
  # -->
  # Returns `true` if the underlying file descriptor of *ios* will be closed
  # automatically at its finalization, otherwise `false`.
  #
  def autoclose?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.binmode    -> ios
  # -->
  # Puts *ios* into binary mode. Once a stream is in binary mode, it cannot be
  # reset to nonbinary mode.
  #
  # *   newline conversion disabled
  # *   encoding conversion disabled
  # *   content is treated as ASCII-8BIT
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.binmode?    -> true or false
  # -->
  # Returns `true` if *ios* is binmode.
  #
  def binmode?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.close   -> nil
  # -->
  # Closes *ios* and flushes any pending writes to the operating system. The
  # stream is unavailable for any further data operations; an IOError is raised if
  # such an attempt is made. I/O streams are automatically closed when they are
  # claimed by the garbage collector.
  #
  # If *ios* is opened by IO.popen, #close sets `$?`.
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_on_exec = bool    -> true or false
  # -->
  # Sets a close-on-exec flag.
  #
  #     f = open("/dev/null")
  #     f.close_on_exec = true
  #     system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No such file or directory
  #     f.closed?                #=> false
  #
  # Ruby sets close-on-exec flags of all file descriptors by default since Ruby
  # 2.0.0. So you don't need to set by yourself. Also, unsetting a close-on-exec
  # flag can cause file descriptor leak if another thread use fork() and exec()
  # (via system() method for example). If you really needs file descriptor
  # inheritance to child process, use spawn()'s argument such as fd=>fd.
  #
  def close_on_exec=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_on_exec?   -> true or false
  # -->
  # Returns `true` if *ios* will be closed on exec.
  #
  #     f = open("/dev/null")
  #     f.close_on_exec?                 #=> false
  #     f.close_on_exec = true
  #     f.close_on_exec?                 #=> true
  #     f.close_on_exec = false
  #     f.close_on_exec?                 #=> false
  #
  def close_on_exec?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_read    -> nil
  # -->
  # Closes the read end of a duplex I/O stream (i.e., one that contains both a
  # read and a write stream, such as a pipe). Will raise an IOError if the stream
  # is not duplexed.
  #
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_read
  #     f.readlines
  #
  # *produces:*
  #
  #     prog.rb:3:in `readlines': not opened for reading (IOError)
  #      from prog.rb:3
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close_read: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_write   -> nil
  # -->
  # Closes the write end of a duplex I/O stream (i.e., one that contains both a
  # read and a write stream, such as a pipe). Will raise an IOError if the stream
  # is not duplexed.
  #
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_write
  #     f.print "nowhere"
  #
  # *produces:*
  #
  #     prog.rb:3:in `write': not opened for writing (IOError)
  #      from prog.rb:3:in `print'
  #      from prog.rb:3
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close_write: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.closed?    -> true or false
  # -->
  # Returns `true` if *ios* is completely closed (for duplex streams, both reader
  # and writer), `false` otherwise.
  #
  #     f = File.new("testfile")
  #     f.close         #=> nil
  #     f.closed?       #=> true
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_write   #=> nil
  #     f.closed?       #=> false
  #     f.close_read    #=> nil
  #     f.closed?       #=> true
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.each(sep=$/ [, getline_args])          {|line| block } -> ios
  #   - ios.each(limit [, getline_args])           {|line| block } -> ios
  #   - ios.each(sep, limit [, getline_args])      {|line| block } -> ios
  #   - ios.each(...)                             -> an_enumerator
  #   - ios.each_line(sep=$/ [, getline_args])     {|line| block } -> ios
  #   - ios.each_line(limit [, getline_args])      {|line| block } -> ios
  #   - ios.each_line(sep, limit [, getline_args]) {|line| block } -> ios
  #   - ios.each_line(...)                        -> an_enumerator
  # -->
  # Executes the block for every line in *ios*, where lines are separated by
  # *sep*. *ios* must be opened for reading or an IOError will be raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each {|line| puts "#{f.lineno}: #{line}" }
  #
  # *produces:*
  #
  #     1: This is line one
  #     2: This is line two
  #     3: This is line three
  #     4: And so on...
  #
  # See IO.readlines for details about getline_args.
  #
  def each: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
          | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_byte {|byte| block }  -> ios
  #   - ios.each_byte                  -> an_enumerator
  # -->
  # Calls the given block once for each byte (0..255) in *ios*, passing the byte
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     checksum = 0
  #     f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>
  #     checksum                           #=> 12
  #
  def each_byte: () { (Integer arg0) -> untyped } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_char {|c| block }  -> ios
  #   - ios.each_char               -> an_enumerator
  # -->
  # Calls the given block once for each character in *ios*, passing the character
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each_char {|c| print c, ' ' }   #=> #<File:testfile>
  #
  def each_char: () { (String arg0) -> untyped } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_codepoint {|c| block }  -> ios
  #   - ios.each_codepoint               -> an_enumerator
  # -->
  # Passes the Integer ordinal of each character in *ios*, passing the codepoint
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  def each_codepoint: () { (Integer arg0) -> untyped } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - eof -> true or false
  # -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](#class-IO-label-Mode).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  # I#eof? is an alias for IO#eof.
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.fcntl(integer_cmd, arg)    -> integer
  # -->
  # Provides a mechanism for issuing low-level commands to control or query
  # file-oriented I/O streams. Arguments and results are platform dependent. If
  # *arg* is a number, its value is passed directly. If it is a string, it is
  # interpreted as a binary sequence of bytes (Array#pack might be a useful way to
  # build this string). On Unix platforms, see `fcntl(2)` for details.  Not
  # implemented on all platforms.
  #
  def fcntl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - fdatasync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's: `fdatasync(2)`, if supported, otherwise via `fsync(2)`, if
  # supported; otherwise raises an exception.
  #
  def fdatasync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - fileno -> integer
  # -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #
  # IO#to_i is an alias for IO#fileno.
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - flush -> self
  # -->
  # Flushes data buffered in `self` to the operating system (but does not
  # necessarily flush data buffered in the operating system):
  #
  #     $stdout.print 'no newline' # Not necessarily flushed.
  #     $stdout.flush              # Flushed.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - fsync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's `fsync(2)`.
  #
  # Note this difference:
  #
  # *   IO#sync=: Ensures that data is flushed from the stream's internal buffers,
  #     but does not guarantee that the operating system actually writes the data
  #     to disk.
  # *   IO#fsync: Ensures both that data is flushed from internal buffers, and
  #     that data is written to disk.
  #
  #
  # Raises an exception if the operating system does not support `fsync(2)`.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - ios.getbyte   -> integer or nil
  # -->
  # Gets the next 8-bit byte (0..255) from *ios*. Returns `nil` if called at end
  # of file.
  #
  #     f = File.new("testfile")
  #     f.getbyte   #=> 84
  #     f.getbyte   #=> 104
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - ios.getc   -> string or nil
  # -->
  # Reads a one-character string from *ios*. Returns `nil` if called at end of
  # file.
  #
  #     f = File.new("testfile")
  #     f.getc   #=> "h"
  #     f.getc   #=> "e"
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep = $/, **getline_opts)   -> string or nil
  #   - gets(limit, **getline_opts)      -> string or nil
  #   - gets(sep, limit, **getline_opts) -> string or nil
  # -->
  # Reads and returns data from the stream; assigns the return value to `$_`.
  #
  # With no arguments given, returns the next line as determined by line separator
  # `$/`, or `nil` if none:
  #
  #     f = File.open('t.txt')
  #     f.gets # => "This is line one.\n"
  #     $_     # => "This is line one.\n"
  #     f.gets # => "This is the second line.\n"
  #     f.gets # => "This is the third line.\n"
  #     f.gets # => nil
  #
  # With string argument `sep` given, but not argument `limit`, returns the next
  # line as determined by line separator `sep`, or `nil` if none:
  #
  #     f = File.open('t.txt')
  #     f.gets(' is') # => "This is"
  #     f.gets(' is') # => " line one.\nThis is"
  #     f.gets(' is') # => " the second line.\nThis is"
  #     f.gets(' is') # => " the third line.\n"
  #     f.gets(' is') # => nil
  #
  # Note two special values for `sep`:
  #
  # *   `nil`: The entire stream is read and returned.
  # *   `''` (empty string): The next "paragraph" is read and returned, the
  #     paragraph separator being two successive line separators.
  #
  #
  # With integer argument `limit` given, returns up to `limit+1` bytes:
  #
  #     # Text with 1-byte characters.
  #     File.open('t.txt') {|f| f.gets(1) } # => "T"
  #     File.open('t.txt') {|f| f.gets(2) } # => "Th"
  #     File.open('t.txt') {|f| f.gets(3) } # => "Thi"
  #     File.open('t.txt') {|f| f.gets(4) } # => "This"
  #     # No more than one line.
  #     File.open('t.txt') {|f| f.gets(17) } # => "This is line one."
  #     File.open('t.txt') {|f| f.gets(18) } # => "This is line one.\n"
  #     File.open('t.txt') {|f| f.gets(19) } # => "This is line one.\n"
  #
  #     # Text with 2-byte characters, which will not be split.
  #     File.open('t.rus') {|f| f.gets(1).size } # => 1
  #     File.open('t.rus') {|f| f.gets(2).size } # => 1
  #     File.open('t.rus') {|f| f.gets(3).size } # => 2
  #     File.open('t.rus') {|f| f.gets(4).size } # => 2
  #
  # With arguments `sep` and `limit`, combines the two behaviors above:
  #
  # *   Returns the next line as determined by line separator `sep`, or `nil` if
  #     none.
  # *   But returns no more than `limit+1` bytes.
  #
  #
  # For all forms above, trailing optional keyword arguments may be given; see
  # [Getline Options](#class-IO-label-Getline+Options):
  #
  #     f = File.open('t.txt')
  #     # Chomp the lines.
  #     f.gets(chomp: true) # => "This is line one."
  #     f.gets(chomp: true) # => "This is the second line."
  #     f.gets(chomp: true) # => "This is the third line."
  #     f.gets(chomp: true) # => nil
  #
  def gets: (?String sep, ?Integer limit) -> String?

  # <!--
  #   rdoc-file=io.c
  #   - IO.new(fd [, mode] [, opt])   -> io
  # -->
  # Returns a new IO object (a stream) for the given integer file descriptor `fd`
  # and `mode` string.  `opt` may be used to specify parts of `mode` in a more
  # readable fashion.  See also IO.sysopen and IO.for_fd.
  #
  # IO.new is called by various File and IO opening methods such as IO::open,
  # Kernel#open, and File::open.
  #
  # ### Open Mode
  #
  # When `mode` is an integer it must be combination of the modes defined in
  # File::Constants (`File::RDONLY`, `File::WRONLY|File::CREAT`). See the open(2)
  # man page for more information.
  #
  # When `mode` is a string it must be in one of the following forms:
  #
  #     fmode
  #     fmode ":" ext_enc
  #     fmode ":" ext_enc ":" int_enc
  #     fmode ":" "BOM|UTF-*"
  #
  # `fmode` is an IO open mode string, `ext_enc` is the external encoding for the
  # IO and `int_enc` is the internal encoding.
  #
  # #### IO Open Mode
  #
  # Ruby allows the following open modes:
  #
  #     "r"  Read-only, starts at beginning of file  (default mode).
  #
  #     "r+" Read-write, starts at beginning of file.
  #
  #     "w"  Write-only, truncates existing file
  #          to zero length or creates a new file for writing.
  #
  #     "w+" Read-write, truncates existing file to zero length
  #          or creates a new file for reading and writing.
  #
  #     "a"  Write-only, each write call appends data at end of file.
  #          Creates a new file for writing if file does not exist.
  #
  #     "a+" Read-write, each write call appends data at end of file.
  #          Creates a new file for reading and writing if file does
  #          not exist.
  #
  # The following modes must be used separately, and along with one or more of the
  # modes seen above.
  #
  #     "b"  Binary file mode
  #          Suppresses EOL <-> CRLF conversion on Windows. And
  #          sets external encoding to ASCII-8BIT unless explicitly
  #          specified.
  #
  #     "t"  Text file mode
  #
  # The exclusive access mode ("x") can be used together with "w" to ensure the
  # file is created. Errno::EEXIST is raised when it already exists. It may not be
  # supported with all kinds of streams (e.g. pipes).
  #
  # When the open mode of original IO is read only, the mode cannot be changed to
  # be writable.  Similarly, the open mode cannot be changed from write only to
  # readable.
  #
  # When such a change is attempted the error is raised in different locations
  # according to the platform.
  #
  # ### IO Encoding
  #
  # When `ext_enc` is specified, strings read will be tagged by the encoding when
  # reading, and strings output will be converted to the specified encoding when
  # writing.
  #
  # When `ext_enc` and `int_enc` are specified read strings will be converted from
  # `ext_enc` to `int_enc` upon input, and written strings will be converted from
  # `int_enc` to `ext_enc` upon output.  See Encoding for further details of
  # transcoding on input and output.
  #
  # If "BOM|UTF-8", "BOM|UTF-16LE" or "BOM|UTF16-BE" are used, Ruby checks for a
  # Unicode BOM in the input document to help determine the encoding.  For UTF-16
  # encodings the file open mode must be binary.  When present, the BOM is
  # stripped and the external encoding from the BOM is used.  When the BOM is
  # missing the given Unicode encoding is used as `ext_enc`.  (The BOM-set
  # encoding option is case insensitive, so "bom|utf-8" is also valid.)
  #
  # ### Options
  #
  # `opt` can be used instead of `mode` for improved readability.  The following
  # keys are supported:
  #
  # :mode
  # :   Same as `mode` parameter
  #
  # :flags
  # :   Specifies file open flags as integer. If `mode` parameter is given, this
  #     parameter will be bitwise-ORed.
  #
  # :external_encoding
  # :   External encoding for the IO.
  #
  # :internal_encoding
  # :   Internal encoding for the IO.  "-" is a synonym for the default internal
  #     encoding.
  #
  #     If the value is `nil` no conversion occurs.
  #
  # :encoding
  # :   Specifies external and internal encodings as "extern:intern".
  #
  # :textmode
  # :   If the value is truth value, same as "t" in argument `mode`.
  #
  # :binmode
  # :   If the value is truth value, same as "b" in argument `mode`.
  #
  # :autoclose
  # :   If the value is `false`, the `fd` will be kept open after this IO instance
  #     gets finalized.
  #
  #
  # Also, `opt` can have same keys in String#encode for controlling conversion
  # between the external encoding and the internal encoding.
  #
  # ### Example 1
  #
  #     fd = IO.sysopen("/dev/tty", "w")
  #     a = IO.new(fd,"w")
  #     $stderr.puts "Hello"
  #     a.puts "World"
  #
  # Produces:
  #
  #     Hello
  #     World
  #
  # ### Example 2
  #
  #     require 'fcntl'
  #
  #     fd = STDERR.fcntl(Fcntl::F_DUPFD)
  #     io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
  #     io.puts "Hello, World!"
  #
  #     fd = STDERR.fcntl(Fcntl::F_DUPFD)
  #     io = IO.new(fd, mode: 'w', cr_newline: true,
  #                 external_encoding: Encoding::UTF_16LE)
  #     io.puts "Hello, World!"
  #
  # Both of above print "Hello, World!" in UTF-16LE to standard error output with
  # converting EOL generated by #puts to CR.
  #
  def initialize: (Integer fd, ?Integer mode, ?Integer opt) -> void

  # <!--
  #   rdoc-file=io.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     f = File.open('t.txt')
  #     f.inspect # => "#<File:t.txt>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=io.c
  #   - io.internal_encoding   -> encoding
  # -->
  # Returns the Encoding of the internal string if conversion is specified.
  # Otherwise returns `nil`.
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=io.c
  #   - ios.ioctl(integer_cmd, arg)    -> integer
  # -->
  # Provides a mechanism for issuing low-level commands to control or query I/O
  # devices. Arguments and results are platform dependent. If *arg* is a number,
  # its value is passed directly. If it is a string, it is interpreted as a binary
  # sequence of bytes. On Unix platforms, see `ioctl(2)` for details. Not
  # implemented on all platforms.
  #
  def ioctl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.isatty   -> true or false
  #   - ios.tty?     -> true or false
  # -->
  # Returns `true` if *ios* is associated with a terminal device (tty), `false`
  # otherwise.
  #
  #     File.new("testfile").isatty   #=> false
  #     File.new("/dev/tty").isatty   #=> true
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.lineno    -> integer
  # -->
  # Returns the current line number in *ios*.  The stream must be opened for
  # reading. #lineno counts the number of times #gets is called rather than the
  # number of newlines encountered.  The two values will differ if #gets is called
  # with a separator other than newline.
  #
  # Methods that use `$/` like #each, #lines and #readline will also increment
  # #lineno.
  #
  # See also the `$.` variable.
  #
  #     f = File.new("testfile")
  #     f.lineno   #=> 0
  #     f.gets     #=> "This is line one\n"
  #     f.lineno   #=> 1
  #     f.gets     #=> "This is line two\n"
  #     f.lineno   #=> 2
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.lineno = integer    -> integer
  # -->
  # Manually sets the current line number to the given value. `$.` is updated only
  # on the next read.
  #
  #     f = File.new("testfile")
  #     f.gets                     #=> "This is line one\n"
  #     $.                         #=> 1
  #     f.lineno = 1000
  #     f.lineno                   #=> 1000
  #     $.                         #=> 1         # lineno of last read
  #     f.gets                     #=> "This is line two\n"
  #     $.                         #=> 1001      # lineno of last read
  #
  def lineno=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - pid -> integer or nil
  # -->
  # Returns the process ID of a child process associated with the stream, which
  # will have been set by IO#popen, or `nil` if the stream was not created by
  # IO#popen:
  #
  #     pipe = IO.popen("-")
  #     if pipe
  #       $stderr.puts "In parent, child pid is #{pipe.pid}"
  #     else
  #       $stderr.puts "In child, pid is #{$$}"
  #     end
  #
  # Output:
  #
  #     In child, pid is 26209
  #     In parent, child pid is 26209
  #
  def pid: () -> Integer

  # <!-- rdoc-file=io.c -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](#class-IO-label-Position)):
  #
  #     f = File.new('t.txt')
  #     f.tell     # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #
  # Related: IO#pos=, IO#seek.
  #
  # IO#pos is an alias for IO#tell.
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - pos = new_position -> new_position
  # -->
  # Seeks to the given `new_position` (in bytes); see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.pos = 20 # => 20
  #     f.tell     # => 20
  #
  # Related: IO#seek, IO#tell.
  #
  def pos=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.print               -> nil
  #   - ios.print(obj, ...)     -> nil
  # -->
  # Writes the given object(s) to *ios*. Returns `nil`.
  #
  # The stream must be opened for writing. Each given object that isn't a string
  # will be converted by calling its `to_s` method. When called without arguments,
  # prints the contents of `$_`.
  #
  # If the output field separator (`$,`) is not `nil`, it is inserted between
  # objects. If the output record separator (`$\`) is not `nil`, it is appended to
  # the output.
  #
  #     $stdout.print("This is ", 100, " percent.\n")
  #
  # *produces:*
  #
  #     This is 100 percent.
  #
  def print: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.printf(format_string [, obj, ...])   -> nil
  # -->
  # Formats and writes to *ios*, converting parameters under control of the format
  # string. See Kernel#sprintf for details.
  #
  def printf: (String format_string, *untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.putc(obj)    -> obj
  # -->
  # If *obj* is Numeric, write the character whose code is the least-significant
  # byte of *obj*.  If *obj* is String, write the first character of *obj* to
  # *ios*.  Otherwise, raise TypeError.
  #
  #     $stdout.putc "A"
  #     $stdout.putc 65
  #
  # *produces:*
  #
  #     AA
  #
  def putc: (Numeric | String arg0) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.puts(obj, ...)    -> nil
  # -->
  # Writes the given object(s) to *ios*. Writes a newline after any that do not
  # already end with a newline sequence. Returns `nil`.
  #
  # The stream must be opened for writing. If called with an array argument,
  # writes each element on a new line. Each given object that isn't a string or
  # array will be converted by calling its `to_s` method. If called without
  # arguments, outputs a single newline.
  #
  #     $stdout.puts("this", "is", ["a", "test"])
  #
  # *produces:*
  #
  #     this
  #     is
  #     a
  #     test
  #
  # Note that `puts` always uses newlines and is not affected by the output record
  # separator (`$\`).
  #
  def puts: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - read(maxlen = nil)             -> string or nil
  #   - read(maxlen = nil, out_string) -> out_string or nil
  # -->
  # Reads bytes from the stream (in binary mode):
  #
  # *   If `maxlen` is `nil`, reads all bytes.
  # *   Otherwise reads `maxlen` bytes, if available.
  # *   Otherwise reads all bytes.
  #
  #
  # Returns a string (either a new string or the given `out_string`) containing
  # the bytes read. The encoding of the string depends on both `maxLen` and
  # `out_string`:
  #
  # *   `maxlen` is `nil`: uses internal encoding of `self` (regardless of whether
  #     `out_string` was given).
  # *   `maxlen` not `nil`:
  #
  #     *   `out_string` given: encoding of `out_string` not modified.
  #     *   `out_string` not given: ASCII-8BIT is used.
  #
  #
  #
  # **Without Argument `out_string`**
  #
  # When argument `out_string` is omitted, the returned value is a new string:
  #
  #     f = File.new('t.txt')
  #     f.read
  #     # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     f.rewind
  #     f.read(40)      # => "This is line one.\r\nThis is the second li"
  #     f.read(40)      # => "ne.\r\nThis is the third line.\r\n"
  #     f.read(40)      # => nil
  #
  # If `maxlen` is zero, returns an empty string.
  #
  # ** With Argument `out_string`**
  #
  # When argument `out_string` is given, the returned value is `out_string`, whose
  # content is replaced:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'      # => "foo"
  #     f.read(nil, s) # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     s              # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     f.rewind
  #     s = 'bar'
  #     f.read(40, s)  # => "This is line one.\r\nThis is the second li"
  #     s              # => "This is line one.\r\nThis is the second li"
  #     s = 'baz'
  #     f.read(40, s)  # => "ne.\r\nThis is the third line.\r\n"
  #     s              # => "ne.\r\nThis is the third line.\r\n"
  #     s = 'bat'
  #     f.read(40, s)  # => nil
  #     s              # => ""
  #
  # Note that this method behaves like the fread() function in C. This means it
  # retries to invoke read(2) system calls to read data with the specified maxlen
  # (or until EOF).
  #
  # This behavior is preserved even if the stream is in non-blocking mode. (This
  # method is non-blocking-flag insensitive as other methods.)
  #
  # If you need the behavior like a single read(2) system call, consider
  # #readpartial, #read_nonblock, and #sysread.
  #
  def read: (?int? length, ?string outbuf) -> String?

  # <!--
  #   rdoc-file=io.rb
  #   - ios.read_nonblock(maxlen [, options])              -> string
  #   - ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf
  # -->
  # Reads at most *maxlen* bytes from *ios* using the read(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # If the optional *outbuf* argument is present, it must reference a String,
  # which will receive the data. The *outbuf* will contain only the received data
  # after the method call even if it is not empty at the beginning.
  #
  # read_nonblock just calls the read(2) system call. It causes all errors the
  # read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller
  # should care such errors.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying read_nonblock.
  #
  # read_nonblock causes EOFError on EOF.
  #
  # On some platforms, such as Windows, non-blocking mode is not supported on IO
  # objects other than sockets. In such cases, Errno::EBADF will be raised.
  #
  # If the read byte buffer is not empty, read_nonblock reads from the buffer like
  # readpartial. In this case, the read(2) system call is not called.
  #
  # When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock
  # should not be called until io is readable for avoiding busy loop. This can be
  # done as follows.
  #
  #     # emulates blocking read (readpartial).
  #     begin
  #       result = io.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io])
  #       retry
  #     end
  #
  # Although IO#read_nonblock doesn't raise IO::WaitWritable.
  # OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. If IO and SSL
  # should be used polymorphically, IO::WaitWritable should be rescued too. See
  # the document of OpenSSL::Buffering#read_nonblock for sample code.
  #
  # Note that this method is identical to readpartial except the non-blocking flag
  # is set.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # read_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead. At EOF, it will return nil instead of raising
  # EOFError.
  #
  def read_nonblock: (int len, ?string buf, ?exception: true) -> String
                   | (int len, ?string buf, exception: false) -> (String | :wait_readable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - ios.readbyte   -> integer
  # -->
  # Reads a byte as with IO#getbyte, but raises an EOFError on end of file.
  #
  def readbyte: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.readchar   -> string
  # -->
  # Reads a one-character string from *ios*. Raises an EOFError on end of file.
  #
  #     f = File.new("testfile")
  #     f.readchar   #=> "h"
  #     f.readchar   #=> "e"
  #
  def readchar: () -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.readline(sep=$/ [, getline_args])     -> string
  #   - ios.readline(limit [, getline_args])      -> string
  #   - ios.readline(sep, limit [, getline_args]) -> string
  # -->
  # Reads a line as with IO#gets, but raises an EOFError on end of file.
  #
  def readline: (?String sep, ?Integer limit) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.readlines(sep=$/ [, getline_args])     -> array
  #   - ios.readlines(limit [, getline_args])      -> array
  #   - ios.readlines(sep, limit [, getline_args]) -> array
  # -->
  # Reads all of the lines in *ios*, and returns them in an array. Lines are
  # separated by the optional *sep*. If *sep* is `nil`, the rest of the stream is
  # returned as a single record. If the first argument is an integer, or an
  # optional second argument is given, the returning string would not be longer
  # than the given value in bytes. The stream must be opened for reading or an
  # IOError will be raised.
  #
  #     f = File.new("testfile")
  #     f.readlines[0]   #=> "This is line one\n"
  #
  #     f = File.new("testfile", chomp: true)
  #     f.readlines[0]   #=> "This is line one"
  #
  # See IO.readlines for details about getline_args.
  #
  def readlines: (?String sep, ?Integer limit) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - readpartial(maxlen)             -> string
  #   - readpartial(maxlen, out_string) -> out_string
  # -->
  # Reads up to `maxlen` bytes from the stream; returns a string (either a new
  # string or the given `out_string`). Its encoding is:
  #
  # *   The unchanged encoding of `out_string`, if `out_string` is given.
  # *   ASCII-8BIT, otherwise.
  #
  # *   Contains `maxlen` bytes from the stream, if available.
  # *   Otherwise contains all available bytes, if any available.
  # *   Otherwise is an empty string.
  #
  #
  # With the single non-negative integer argument `maxlen` given, returns a new
  # string:
  #
  #     f = File.new('t.txt')
  #     f.readpartial(30) # => "This is line one.\nThis is the"
  #     f.readpartial(30) # => " second line.\nThis is the thi"
  #     f.readpartial(30) # => "rd line.\n"
  #     f.eof             # => true
  #     f.readpartial(30) # Raises EOFError.
  #
  # With both argument `maxlen` and string argument `out_string` given, returns
  # modified `out_string`:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'
  #     f.readpartial(30, s) # => "This is line one.\nThis is the"
  #     s = 'bar'
  #     f.readpartial(0, s)  # => ""
  #
  # This method is useful for a stream such as a pipe, a socket, or a tty. It
  # blocks only when no data is immediately available. This means that it blocks
  # only when *all* of the following are true:
  #
  # *   The byte buffer in the stream is empty.
  # *   The content of the stream is empty.
  # *   The stream is not at EOF.
  #
  #
  # When blocked, the method waits for either more data or EOF on the stream:
  #
  # *   If more data is read, the method returns the data.
  # *   If EOF is reached, the method raises EOFError.
  #
  #
  # When not blocked, the method responds immediately:
  #
  # *   Returns data from the buffer if there is any.
  # *   Otherwise returns data from the stream if there is any.
  # *   Otherwise raises EOFError if the stream has reached EOF.
  #
  #
  # Note that this method is similar to sysread. The differences are:
  #
  # *   If the byte buffer is not empty, read from the byte buffer instead of
  #     "sysread for buffered IO (IOError)".
  # *   It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial
  #     meets EWOULDBLOCK and EINTR by read system call, readpartial retries the
  #     system call.
  #
  #
  # The latter means that readpartial is non-blocking-flag insensitive. It blocks
  # on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking
  # mode.
  #
  # Examples:
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc".
  #     r.readpartial(4096)      # => "abc"      ""                ""
  #     r.readpartial(4096)      # (Blocks because buffer and pipe are empty.)
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc"
  #     w.close                  #               ""                "abc" EOF
  #     r.readpartial(4096)      # => "abc"      ""                 EOF
  #     r.readpartial(4096)      # raises EOFError
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << "abc\ndef\n"        #               ""                "abc\ndef\n"
  #     r.gets                   # => "abc\n"    "def\n"           ""
  #     w << "ghi\n"             #               "def\n"           "ghi\n"
  #     r.readpartial(4096)      # => "def\n"    ""                "ghi\n"
  #     r.readpartial(4096)      # => "ghi\n"    ""                ""
  #
  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.reopen(other_IO)             -> ios
  #   - ios.reopen(path, mode [, opt])   -> ios
  # -->
  # Reassociates *ios* with the I/O stream given in *other_IO* or to a new stream
  # opened on *path*. This may dynamically change the actual class of this stream.
  # The `mode` and `opt` parameters accept the same values as IO.open.
  #
  #     f1 = File.new("testfile")
  #     f2 = File.new("testfile")
  #     f2.readlines[0]   #=> "This is line one\n"
  #     f2.reopen(f1)     #=> #<File:testfile>
  #     f2.readlines[0]   #=> "This is line one\n"
  #
  def reopen: (IO other_IO_or_path) -> IO
            | (String other_IO_or_path, ?String mode_str) -> IO

  # <!--
  #   rdoc-file=io.c
  #   - rewind -> 0
  # -->
  # Repositions the stream to its beginning, setting both the position and the
  # line number to zero; see [Position](#class-IO-label-Position) and [Line
  # Number](#class-IO-label-Line+Number):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #     f.lineno   # => 1
  #     f.rewind   # => 0
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #
  # Note that this method cannot be used with streams such as pipes, ttys, and
  # sockets.
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - seek(offset, whence = IO::SEEK_SET) -> 0
  # -->
  # Seeks to the position given by integer `offset` (see
  # [Position](#class-IO-label-Position)) and constant `whence`, which is one of:
  #
  # *   `:CUR` or `IO::SEEK_CUR`: Repositions the stream to its current position
  #     plus the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :CUR)  # => 0
  #         f.tell            # => 20
  #         f.seek(-10, :CUR) # => 0
  #         f.tell            # => 10
  #
  # *   `:END` or `IO::SEEK_END`: Repositions the stream to its end plus the given
  #     `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(0, :END)   # => 0  # Repositions to stream end.
  #         f.tell            # => 70
  #         f.seek(-20, :END) # => 0
  #         f.tell            # => 50
  #         f.seek(-40, :END) # => 0
  #         f.tell            # => 30
  #
  # *   `:SET` or `IO:SEEK_SET`: Repositions the stream to the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :SET) # => 0
  #         f.tell           # => 20
  #         f.seek(40, :SET) # => 0
  #         f.tell           # => 40
  #
  #
  # Related: IO#pos=, IO#tell.
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - io.set_encoding(ext_enc)                -> io
  #   - io.set_encoding("ext_enc:int_enc")      -> io
  #   - io.set_encoding(ext_enc, int_enc)       -> io
  #   - io.set_encoding("ext_enc:int_enc", opt) -> io
  #   - io.set_encoding(ext_enc, int_enc, opt)  -> io
  # -->
  # If single argument is specified, read string from io is tagged with the
  # encoding specified.  If encoding is a colon separated two encoding names
  # "A:B", the read string is converted from encoding A (external encoding) to
  # encoding B (internal encoding), then tagged with B.  If two arguments are
  # specified, those must be encoding objects or encoding names, and the first one
  # is the external encoding, and the second one is the internal encoding. If the
  # external encoding and the internal encoding is specified, optional hash
  # argument specify the conversion option.
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.set_encoding_by_bom   -> encoding or nil
  # -->
  # Checks if `ios` starts with a BOM, and then consumes it and sets the external
  # encoding.  Returns the result encoding if found, or nil.  If `ios` is not
  # binmode or its encoding has been set already, an exception will be raised.
  #
  #     File.write("bom.txt", "\u{FEFF}abc")
  #     ios = File.open("bom.txt", "rb")
  #     ios.set_encoding_by_bom    #=>  #<Encoding:UTF-8>
  #
  #     File.write("nobom.txt", "abc")
  #     ios = File.open("nobom.txt", "rb")
  #     ios.set_encoding_by_bom    #=>  nil
  #
  def set_encoding_by_bom: () -> Encoding?

  # <!--
  #   rdoc-file=file.c
  #   - ios.stat    -> stat
  # -->
  # Returns status information for *ios* as an object of type File::Stat.
  #
  #     f = File.new("testfile")
  #     s = f.stat
  #     "%o" % s.mode   #=> "100644"
  #     s.blksize       #=> 4096
  #     s.atime         #=> Wed Apr 09 08:53:54 CDT 2003
  #
  def stat: () -> File::Stat

  # <!--
  #   rdoc-file=io.c
  #   - sync -> true or false
  # -->
  # Returns the current sync mode of the stream. When sync mode is true, all
  # output is immediately flushed to the underlying operating system and is not
  # buffered by Ruby internally. See also #fsync.
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - sync = boolean -> boolean
  # -->
  # Sets the *sync* *mode* for the stream to the given value; returns the given
  # value.
  #
  # Values for the sync mode:
  #
  # *   `true`: All output is immediately flushed to the underlying operating
  #     system and is not buffered internally.
  # *   `false`: Output may be buffered internally.
  #
  #
  # Example;
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #
  # Related: IO#fsync.
  #
  def sync=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.sysread(maxlen[, outbuf])    -> string
  # -->
  # Reads *maxlen* bytes from *ios* using a low-level read and returns them as a
  # string.  Do not mix with other methods that read from *ios* or you may get
  # unpredictable results.
  #
  # If the optional *outbuf* argument is present, it must reference a String,
  # which will receive the data. The *outbuf* will contain only the received data
  # after the method call even if it is not empty at the beginning.
  #
  # Raises SystemCallError on error and EOFError at end of file.
  #
  #     f = File.new("testfile")
  #     f.sysread(16)   #=> "This is line one"
  #
  def sysread: (Integer maxlen, String outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.sysseek(offset, whence=IO::SEEK_SET)   -> integer
  # -->
  # Seeks to a given *offset* in the stream according to the value of *whence*
  # (see IO#seek for values of *whence*). Returns the new offset into the file.
  #
  #     f = File.new("testfile")
  #     f.sysseek(-13, IO::SEEK_END)   #=> 53
  #     f.sysread(10)                  #=> "And so on."
  #
  def sysseek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.syswrite(string)   -> integer
  # -->
  # Writes the given string to *ios* using a low-level write. Returns the number
  # of bytes written. Do not mix with other methods that write to *ios* or you may
  # get unpredictable results. Raises SystemCallError on error.
  #
  #     f = File.new("out", "w")
  #     f.syswrite("ABCDEF")   #=> 6
  #
  def syswrite: (_ToS arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - tell -> integer
  # -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](#class-IO-label-Position)):
  #
  #     f = File.new('t.txt')
  #     f.tell     # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #
  # Related: IO#pos=, IO#seek.
  #
  # IO#pos is an alias for IO#tell.
  #
  def tell: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - to_io -> self
  # -->
  # Returns `self`.
  #
  def to_io: () -> self

  # <!-- rdoc-file=io.c -->
  # Returns `true` if *ios* is associated with a terminal device (tty), `false`
  # otherwise.
  #
  #     File.new("testfile").isatty   #=> false
  #     File.new("/dev/tty").isatty   #=> true
  #
  def tty?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.ungetbyte(string)   -> nil
  #   - ios.ungetbyte(integer)  -> nil
  # -->
  # Pushes back bytes (passed as a parameter) onto *ios*, such that a subsequent
  # buffered read will return it. It is only guaranteed to support a single byte,
  # and only if ungetbyte or ungetc has not already been called on *ios* since the
  # previous read of at least a single byte from *ios*. However, it can support
  # additional bytes if there is space in the internal buffer to allow for it.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     b = f.getbyte              #=> 0x38
  #     f.ungetbyte(b)             #=> nil
  #     f.getbyte                  #=> 0x38
  #
  # If given an integer, only uses the lower 8 bits of the integer as the byte to
  # push.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetbyte(0x102)         #=> nil
  #     f.getbyte                  #=> 0x2
  #
  # Calling this method prepends to the existing buffer, even if the method has
  # already been called previously:
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetbyte("ab")          #=> nil
  #     f.ungetbyte("cd")          #=> nil
  #     f.read(5)                  #=> "cdab8"
  #
  # Has no effect with unbuffered reads (such as IO#sysread).
  #
  def ungetbyte: (String | Integer arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.ungetc(integer)  -> nil
  #   - ios.ungetc(string)   -> nil
  # -->
  # Pushes back characters (passed as a parameter) onto *ios*, such that a
  # subsequent buffered read will return it. It is only guaranteed to support a
  # single byte, and only if ungetbyte or ungetc has not already been called on
  # *ios* since the previous read of at least a single byte from *ios*. However,
  # it can support additional bytes if there is space in the internal buffer to
  # allow for it.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     c = f.getc                 #=> "8"
  #     f.ungetc(c)                #=> nil
  #     f.getc                     #=> "8"
  #
  # If given an integer, the integer must represent a valid codepoint in the
  # external encoding of *ios*.
  #
  # Calling this method prepends to the existing buffer, even if the method has
  # already been called previously:
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetc("ab")             #=> nil
  #     f.ungetc("cd")             #=> nil
  #     f.read(5)                  #=> "cdab8"
  #
  # Has no effect with unbuffered reads (such as IO#sysread).
  #
  def ungetc: (String arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - write(*objects) -> integer
  # -->
  # Writes each of the given `objects` to `self`, which must be opened for writing
  # (see [Modes](#class-IO-label-Modes)); returns the total number bytes written;
  # each of `objects` that is not a string is converted via method `to_s`:
  #
  #     $stdout.write('Hello', ', ', 'World!', "\n") # => 14
  #     $stdout.write('foo', :bar, 2, "\n")          # => 8
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  def write: (*_ToS string) -> Integer

  # <!--
  #   rdoc-file=io.rb
  #   - ios.write_nonblock(string)   -> integer
  #   - ios.write_nonblock(string [, options])   -> integer
  # -->
  # Writes the given string to *ios* using the write(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # It returns the number of bytes written.
  #
  # write_nonblock just calls the write(2) system call. It causes all errors the
  # write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result
  # may also be smaller than string.length (partial write). The caller should care
  # such errors and partial write.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for
  # retrying write_nonblock.
  #
  #     # Creates a pipe.
  #     r, w = IO.pipe
  #
  #     # write_nonblock writes only 65536 bytes and return 65536.
  #     # (The pipe size is 65536 bytes on this environment.)
  #     s = "a" * 100000
  #     p w.write_nonblock(s)     #=> 65536
  #
  #     # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
  #     p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)
  #
  # If the write buffer is not empty, it is flushed at first.
  #
  # When write_nonblock raises an exception kind of IO::WaitWritable,
  # write_nonblock should not be called until io is writable for avoiding busy
  # loop. This can be done as follows.
  #
  #     begin
  #       result = io.write_nonblock(string)
  #     rescue IO::WaitWritable, Errno::EINTR
  #       IO.select(nil, [io])
  #       retry
  #     end
  #
  # Note that this doesn't guarantee to write all data in string. The length
  # written is reported as result and it should be checked later.
  #
  # On some platforms such as Windows, write_nonblock is not supported according
  # to the kind of the IO object. In such cases, write_nonblock raises
  # `Errno::EBADF`.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # write_nonblock should not raise an IO::WaitWritable exception, but return the
  # symbol `:wait_writable` instead.
  #
  def write_nonblock: (_ToS s, ?exception: true) -> Integer
                    | (_ToS s, exception: false) -> (Integer | :wait_writable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - IO.binread(name, [length [, offset]])   -> string
  #   - File.binread(name, [length [, offset]]) -> string
  # -->
  # Opens the file, optionally seeks to the given *offset*, then returns *length*
  # bytes (defaulting to the rest of the file). #binread ensures the file is
  # closed before returning.  The open mode would be `"rb:ASCII-8BIT"`.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.binread to disable the behavior of
  # subprocess invocation.
  #
  #     File.binread("testfile")           #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #     File.binread("testfile", 20)       #=> "This is line one\nThi"
  #     File.binread("testfile", 20, 10)   #=> "ne one\nThis is line "
  #     IO.binread("| cat testfile")       #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.binread: (String name, ?Integer length, ?Integer offset) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.binwrite(name, string, [offset])               -> integer
  #   - IO.binwrite(name, string, [offset], open_args)    -> integer
  #   - File.binwrite(name, string, [offset])             -> integer
  #   - File.binwrite(name, string, [offset], open_args)  -> integer
  # -->
  # Same as IO.write except opening the file in binary mode and ASCII-8BIT
  # encoding (`"wb:ASCII-8BIT"`).
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.binwrite to disable the behavior of
  # subprocess invocation.
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.binwrite: (String name, _ToS string, ?Integer offset, ?mode: String mode) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.copy_stream(src, dst)
  #   - IO.copy_stream(src, dst, copy_length)
  #   - IO.copy_stream(src, dst, copy_length, src_offset)
  # -->
  # IO.copy_stream copies *src* to *dst*. *src* and *dst* is either a filename or
  # an IO-like object. IO-like object for *src* should have #readpartial or #read
  # method.  IO-like object for *dst* should have #write method. (Specialized
  # mechanisms, such as sendfile system call, may be used on appropriate
  # situation.)
  #
  # This method returns the number of bytes copied.
  #
  # If optional arguments are not given, the start position of the copy is the
  # beginning of the filename or the current file offset of the IO. The end
  # position of the copy is the end of file.
  #
  # If *copy_length* is given, No more than *copy_length* bytes are copied.
  #
  # If *src_offset* is given, it specifies the start position of the copy.
  #
  # When *src_offset* is specified and *src* is an IO, IO.copy_stream doesn't move
  # the current file offset.
  #
  def self.copy_stream: (String | _Reader | _ReaderPartial src, String | _Writer dst, ?Integer copy_length, ?Integer src_offset) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.popen([env,] cmd, mode="r" [, opt])               -> io
  #   - IO.popen([env,] cmd, mode="r" [, opt]) {|io| block } -> obj
  # -->
  # Runs the specified command as a subprocess; the subprocess's standard input
  # and output will be connected to the returned IO object.
  #
  # The PID of the started process can be obtained by IO#pid method.
  #
  # *cmd* is a string or an array as follows.
  #
  #     cmd:
  #       "-"                                      : fork
  #       commandline                              : command line string which is passed to a shell
  #       [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
  #       [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
  #     (env and opts are optional.)
  #
  # If *cmd* is a `String` ```-`'', then a new instance of Ruby is started as the
  # subprocess.
  #
  # If *cmd* is an `Array` of `String`, then it will be used as the subprocess's
  # `argv` bypassing a shell. The array can contain a hash at first for
  # environments and a hash at last for options similar to #spawn.
  #
  # The default mode for the new file object is ``r'', but *mode* may be set to
  # any of the modes listed in the description for class IO. The last argument
  # *opt* qualifies *mode*.
  #
  #     # set IO encoding
  #     IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|
  #       euc_jp_string = nkf_io.read
  #     }
  #
  #     # merge standard output and standard error using
  #     # spawn option.  See the document of Kernel.spawn.
  #     IO.popen(["ls", "/", :err=>[:child, :out]]) {|ls_io|
  #       ls_result_with_error = ls_io.read
  #     }
  #
  #     # spawn options can be mixed with IO options
  #     IO.popen(["ls", "/"], :err=>[:child, :out]) {|ls_io|
  #       ls_result_with_error = ls_io.read
  #     }
  #
  # Raises exceptions which IO.pipe and Kernel.spawn raise.
  #
  # If a block is given, Ruby will run the command as a child connected to Ruby
  # with a pipe. Ruby's end of the pipe will be passed as a parameter to the
  # block. At the end of block, Ruby closes the pipe and sets `$?`. In this case
  # IO.popen returns the value of the block.
  #
  # If a block is given with a *cmd* of ```-`'', the block will be run in two
  # separate processes: once in the parent, and once in a child. The parent
  # process will be passed the pipe object as a parameter to the block, the child
  # version of the block will be passed `nil`, and the child's standard in and
  # standard out will be connected to the parent through the pipe. Not available
  # on all platforms.
  #
  #     f = IO.popen("uname")
  #     p f.readlines
  #     f.close
  #     puts "Parent is #{Process.pid}"
  #     IO.popen("date") {|f| puts f.gets }
  #     IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}
  #     p $?
  #     IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|
  #       f.puts "bar"; f.close_write; puts f.gets
  #     }
  #
  # *produces:*
  #
  #     ["Linux\n"]
  #     Parent is 21346
  #     Thu Jan 15 22:41:19 JST 2009
  #     21346 is here, f is #<IO:fd 3>
  #     21352 is here, f is nil
  #     #<Process::Status: pid 21352 exit 0>
  #     <foo>bar;zot;
  #
  def self.popen: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - IO.read(name, [length [, offset]] [, opt])   -> string
  #   - File.read(name, [length [, offset]] [, opt]) -> string
  # -->
  # Opens the file, optionally seeks to the given `offset`, then returns `length`
  # bytes (defaulting to the rest of the file).  #read ensures the file is closed
  # before returning.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.read to disable the behavior of subprocess
  # invocation.
  #
  # ### Options
  #
  # The options hash accepts the following keys:
  #
  # :encoding
  # :   string or encoding
  #
  #     Specifies the encoding of the read string.  `:encoding` will be ignored if
  #     `length` is specified.  See Encoding.aliases for possible encodings.
  #
  # :mode
  # :   string or integer
  #
  #     Specifies the *mode* argument for open().  It must start with an "r",
  #     otherwise it will cause an error. See IO.new for the list of possible
  #     modes.
  #
  # :open_args
  # :   array
  #
  #     Specifies arguments for open() as an array.  This key can not be used in
  #     combination with either `:encoding` or `:mode`.
  #
  #
  # Examples:
  #
  #     File.read("testfile")            #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #     File.read("testfile", 20)        #=> "This is line one\nThi"
  #     File.read("testfile", 20, 10)    #=> "ne one\nThis is line "
  #     File.read("binfile", mode: "rb") #=> "\xF7\x00\x00\x0E\x12"
  #     IO.read("|ls -a")                #=> ".\n..\n"...
  #
  def self.read: (String name, ?Integer length, ?Integer offset, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.readlines(name, sep=$/ [, getline_args, open_args])     -> array
  #   - IO.readlines(name, limit [, getline_args, open_args])      -> array
  #   - IO.readlines(name, sep, limit [, getline_args, open_args]) -> array
  #   - File.readlines(name, sep=$/ [, getline_args, open_args])     -> array
  #   - File.readlines(name, limit [, getline_args, open_args])      -> array
  #   - File.readlines(name, sep, limit [, getline_args, open_args]) -> array
  # -->
  # Reads the entire file specified by *name* as individual lines, and returns
  # those lines in an array. Lines are separated by *sep*.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.readlines to disable the behavior of
  # subprocess invocation.
  #
  #     a = File.readlines("testfile")
  #     a[0]   #=> "This is line one\n"
  #
  #     b = File.readlines("testfile", chomp: true)
  #     b[0]   #=> "This is line one"
  #
  #     IO.readlines("|ls -a")     #=> [".\n", "..\n", ...]
  #
  # If the last argument is a hash, it's the keyword argument to open.
  #
  # ### Options for getline
  #
  # The options hash accepts the following keys:
  #
  # :chomp
  # :   When the optional `chomp` keyword argument has a true value, `\n`, `\r`,
  #     and `\r\n` will be removed from the end of each line.
  #
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.readlines: (String name, ?String sep, ?Integer limit, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode, ?chomp: boolish) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil
  # -->
  # Calls select(2) system call. It monitors given arrays of IO objects, waits
  # until one or more of IO objects are ready for reading, are ready for writing,
  # and have pending exceptions respectively, and returns an array that contains
  # arrays of those IO objects.  It will return `nil` if optional *timeout* value
  # is given and no IO object is ready in *timeout* seconds.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after nonblocking methods such as
  # #read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
  # extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
  # caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
  # should wait for reading.  If IO::WaitWritable is raised, the caller should
  # wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of nonblocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of nonblocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process. See
  # select(2) manual on GNU/Linux system.
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # ### Parameters
  # read_array
  # :   an array of IO objects that wait until ready for read
  # write_array
  # :   an array of IO objects that wait until ready for write
  # error_array
  # :   an array of IO objects that wait for exceptions
  # timeout
  # :   a numeric value in second
  #
  #
  # ### Example
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # *produces:*
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self.select: [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array) -> [ Array[X], Array[Y], Array[Z] ]
                 | [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array, Numeric? timeout) -> [ Array[X], Array[Y], Array[Z] ]?

  # <!--
  #   rdoc-file=io.c
  #   - IO.sysopen(path, [mode, [perm]])  -> integer
  # -->
  # Opens the given path, returning the underlying file descriptor as a Integer.
  #
  #     IO.sysopen("testfile")   #=> 3
  #
  def self.sysopen: (String path, ?String mode, ?String perm) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.try_convert(object) -> new_io or nil
  # -->
  # Attempts to convert `object` into an IO object via method `to_io`; returns the
  # new IO object if successful, or `nil` otherwise:
  #
  #     IO.try_convert(STDOUT)   # => #<IO:<STDOUT>>
  #     IO.try_convert(ARGF)     # => #<IO:<STDIN>>
  #     IO.try_convert('STDOUT') # => nil
  #
  def self.try_convert: (untyped arg0) -> IO?

  # <!--
  #   rdoc-file=io.c
  #   - IO.write(name, string [, offset])           -> integer
  #   - IO.write(name, string [, offset] [, opt])   -> integer
  #   - File.write(name, string [, offset])         -> integer
  #   - File.write(name, string [, offset] [, opt]) -> integer
  # -->
  # Opens the file, optionally seeks to the given *offset*, writes *string*, then
  # returns the length written.  #write ensures the file is closed before
  # returning.  If *offset* is not given in write mode, the file is truncated.
  # Otherwise, it is not truncated.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.write to disable the behavior of subprocess
  # invocation.
  #
  #     File.write("testfile", "0123456789", 20)  #=> 10
  #     # File could contain:  "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"
  #     File.write("testfile", "0123456789")      #=> 10
  #     # File would now read: "0123456789"
  #     IO.write("|tr a-z A-Z", "abc")            #=> 3
  #     # Prints "ABC" to the standard output
  #
  # If the last argument is a hash, it specifies options for the internal open().
  # It accepts the following keys:
  #
  # :encoding
  # :   string or encoding
  #
  #     Specifies the encoding of the read string. See Encoding.aliases for
  #     possible encodings.
  #
  # :mode
  # :   string or integer
  #
  #     Specifies the *mode* argument for open().  It must start with "w", "a", or
  #     "r+", otherwise it will cause an error. See IO.new for the list of
  #     possible modes.
  #
  # :perm
  # :   integer
  #
  #     Specifies the *perm* argument for open().
  #
  # :open_args
  # :   array
  #
  #     Specifies arguments for open() as an array. This key can not be used in
  #     combination with other keys.
  #
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.write: (String name, _ToS arg0, ?Integer offset, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.for_fd(fd, mode [, opt])    -> io
  # -->
  # Synonym for IO.new.
  #
  def self.for_fd: (int fd, ?string | int mode, **untyped opt) -> instance

  # <!--
  #   rdoc-file=io.c
  #   - IO.open(fd, mode="r" [, opt])                -> io
  #   - IO.open(fd, mode="r" [, opt]) {|io| block }  -> obj
  # -->
  # With no associated block, IO.open is a synonym for IO.new.  If the optional
  # code block is given, it will be passed `io` as an argument, and the IO object
  # will automatically be closed when the block terminates. In this instance,
  # IO.open returns the value of the block.
  #
  # See IO.new for a description of the `fd`, `mode` and `opt` parameters.
  #
  alias self.open self.for_fd

  # <!--
  #   rdoc-file=io.c
  #   - IO.open(fd, mode="r" [, opt])                -> io
  #   - IO.open(fd, mode="r" [, opt]) {|io| block }  -> obj
  # -->
  # With no associated block, IO.open is a synonym for IO.new.  If the optional
  # code block is given, it will be passed `io` as an argument, and the IO object
  # will automatically be closed when the block terminates. In this instance,
  # IO.open returns the value of the block.
  #
  # See IO.new for a description of the `fd`, `mode` and `opt` parameters.
  #
  def self.open: [A] (int fd, ?string | int mode, **untyped opt) { (instance) -> A } -> A
               | ...

  def bytes: () { (Integer arg0) -> untyped } -> self
           | () -> ::Enumerator[Integer, self]

  def chars: () { (String arg0) -> untyped } -> self
           | () -> ::Enumerator[String, self]

  def codepoints: () { (Integer arg0) -> untyped } -> self
                | () -> ::Enumerator[Integer, self]

  # <!-- rdoc-file=io.c -->
  # Executes the block for every line in *ios*, where lines are separated by
  # *sep*. *ios* must be opened for reading or an IOError will be raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each {|line| puts "#{f.lineno}: #{line}" }
  #
  # *produces:*
  #
  #     1: This is line one
  #     2: This is line two
  #     3: This is line three
  #     4: And so on...
  #
  # See IO.readlines for details about getline_args.
  #
  def each_line: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
               | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!-- rdoc-file=io.c -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](#class-IO-label-Mode).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  # I#eof? is an alias for IO#eof.
  #
  def eof?: () -> bool

  def lines: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
           | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!-- rdoc-file=io.c -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #
  # IO#to_i is an alias for IO#fileno.
  #
  def to_i: () -> Integer
end

IO::APPEND: Integer

IO::BINARY: Integer

IO::CREAT: Integer

IO::DIRECT: Integer

IO::DSYNC: Integer

IO::EXCL: Integer

IO::FNM_CASEFOLD: Integer

IO::FNM_DOTMATCH: Integer

IO::FNM_EXTGLOB: Integer

IO::FNM_NOESCAPE: Integer

IO::FNM_PATHNAME: Integer

IO::FNM_SHORTNAME: Integer

IO::FNM_SYSCASE: Integer

IO::LOCK_EX: Integer

IO::LOCK_NB: Integer

IO::LOCK_SH: Integer

IO::LOCK_UN: Integer

IO::NOATIME: Integer

IO::NOCTTY: Integer

IO::NOFOLLOW: Integer

IO::NONBLOCK: Integer

IO::NULL: String

IO::RDONLY: Integer

IO::RDWR: Integer

IO::RSYNC: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the current position
#
IO::SEEK_CUR: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next location containing data
#
IO::SEEK_DATA: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the end
#
IO::SEEK_END: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next hole
#
IO::SEEK_HOLE: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the beginning
#
IO::SEEK_SET: Integer

IO::SHARE_DELETE: Integer

IO::SYNC: Integer

IO::TMPFILE: Integer

IO::TRUNC: Integer

IO::WRONLY: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EAGAIN. see IO.select.
#
class IO::EAGAINWaitReadable < Errno::EAGAIN
  include IO::WaitReadable
end

IO::EAGAINWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EAGAIN. see IO.select.
#
class IO::EAGAINWaitWritable < Errno::EAGAIN
  include IO::WaitWritable
end

IO::EAGAINWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitReadable < Errno::EINPROGRESS
  include IO::WaitReadable
end

IO::EINPROGRESSWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitWritable < Errno::EINPROGRESS
  include IO::WaitWritable
end

IO::EINPROGRESSWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading. see IO.select.
#
module IO::WaitReadable
end

# <!-- rdoc-file=io.c -->
# exception to wait for writing. see IO.select.
#
module IO::WaitWritable
end

# <!-- rdoc-file=numeric.c -->
# Numeric is the class from which all higher-level numeric classes should
# inherit.
#
# Numeric allows instantiation of heap-allocated objects. Other core numeric
# classes such as Integer are implemented as immediates, which means that each
# Integer is a single immutable object which is always passed by value.
#
#     a = 1
#     1.object_id == a.object_id   #=> true
#
# There can only ever be one instance of the integer `1`, for example. Ruby
# ensures this by preventing instantiation. If duplication is attempted, the
# same instance is returned.
#
#     Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
#     1.dup                            #=> 1
#     1.object_id == 1.dup.object_id   #=> true
#
# For this reason, Numeric should be used when defining other numeric classes.
#
# Classes which inherit from Numeric must implement `coerce`, which returns a
# two-member Array containing an object that has been coerced into an instance
# of the new class and `self` (see #coerce).
#
# Inheriting classes should also implement arithmetic operator methods (`+`,
# `-`, `*` and `/`) and the `<=>` operator (see Comparable). These methods may
# rely on `coerce` to ensure interoperability with instances of other numeric
# classes.
#
#     class Tally < Numeric
#       def initialize(string)
#         @string = string
#       end
#
#       def to_s
#         @string
#       end
#
#       def to_i
#         @string.size
#       end
#
#       def coerce(other)
#         [self.class.new('|' * other.to_i), self]
#       end
#
#       def <=>(other)
#         to_i <=> other.to_i
#       end
#
#       def +(other)
#         self.class.new('|' * (to_i + other.to_i))
#       end
#
#       def -(other)
#         self.class.new('|' * (to_i - other.to_i))
#       end
#
#       def *(other)
#         self.class.new('|' * (to_i * other.to_i))
#       end
#
#       def /(other)
#         self.class.new('|' * (to_i / other.to_i))
#       end
#     end
#
#     tally = Tally.new('||')
#     puts tally * 2            #=> "||||"
#     puts tally > 1            #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class Numeric:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Numeric provides methods for:
#
# *   [Querying](#class-Numeric-label-Querying)
# *   [Comparing](#class-Numeric-label-Comparing)
# *   [Converting](#class-Numeric-label-Converting)
# *   [Other](#class-Numeric-label-Other)
#
#
# ### Querying
#
#     #finite?
# :       Returns true unless `self` is infinite or not a number.
#
#     #infinite?
# :       Returns -1, `nil` or +1, depending on whether `self` is
#         `-Infinity<tt>, finite, or <tt>+Infinity`.
#
#     #integer?
# :       Returns whether `self` is an integer.
#
#     #negative?
# :       Returns whether `self` is negative.
#
#     #nonzero?
# :       Returns whether `self` is not zero.
#
#     #positive?
# :       Returns whether `self` is positive.
#
#     #real?
# :       Returns whether `self` is a real value.
#
#     #zero?
# :       Returns whether `self` is zero.
#
#
#
# ### Comparing
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns:
#
#     *   -1 if  `self` is less than the given value.
#     *   0 if `self` is equal to the given value.
#     *   1 if `self` is greater than the given value.
#     *   `nil` if `self` and the given value are not comparable.
#
#     #eql?
# :       Returns whether `self` and the given value have the same value and
#         type.
#
#
#
# ### Converting
#
#     #% (aliased as #modulo)
# :       Returns the remainder of `self` divided by the given value.
#
#     #-@
# :       Returns the value of `self`, negated.
#
#     #abs (aliased as #magnitude)
# :       Returns the absolute value of `self`.
#
#     #abs2
# :       Returns the square of `self`.
#
#     #angle (aliased as #arg and #phase)
# :       Returns 0 if `self` is positive, Math::PI otherwise.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`, to a
#         given precision.
#
#     #coerce
# :       Returns array `[coerced_self, coerced_other]` for the given other
#         value.
#
#     #conj (aliased as #conjugate)
# :       Returns the complex conjugate of `self`.
#
#     #denominator
# :       Returns the denominator (always positive) of the Rational
#         representation of `self`.
#
#     #div
# :       Returns the value of `self` divided by the given value and converted
#         to an integer.
#
#     #divmod
# :       Returns array `[quotient, modulus]` resulting from dividing `self` the
#         given divisor.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given divisor.
#
#     #floor
# :       Returns the largest number less than or equal to `self`, to a given
#         precision.
#
#     #i
# :       Returns the Complex object `Complex(0, self)`. the given value.
#
#     #imaginary (aliased as #imag)
# :       Returns the imaginary part of the `self`.
#
#     #numerator
# :       Returns the numerator of the Rational representation of `self`; has
#         the same sign as `self`.
#
#     #polar
# :       Returns the array `[self.abs, self.arg]`.
#
#     #quo
# :       Returns the value of `self` divided by the given value.
#
#     #real
# :       Returns the real part of `self`.
#
#     #rect (aliased as #rectangular)
# :       Returns the array `[self, 0]`.
#
#     #remainder
# :       Returns `self-arg*(self/arg).truncate` for the given `arg`.
#
#     #round
# :       Returns the value of `self` rounded to the nearest value for the given
#         a precision.
#
#     #to_c
# :       Returns the Complex representation of `self`.
#
#     #to_int
# :       Returns the Integer representation of `self`, truncating if necessary.
#
#     #truncate
# :       Returns `self` truncated (toward zero) to a given precision.
#
#
#
# ### Other
#
#     #clone
# :       Returns `self`; does not allow freezing.
#
#     #dup (aliased as #+@)
# :       Returns `self`.
#
#     #step
# :       Invokes the given block with the sequence of specified numbers.
#
class Numeric
  include Comparable

  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_numeric
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     c % n
  #     c-n*(c/n).floor
  #     c.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  # Numeric#modulo is an alias for Numeric#%.
  #
  def %: (Numeric) -> Numeric

  # Performs addition: the class of the resulting object depends on the class of
  # `numeric`.
  #
  def +: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - +self -> self
  # -->
  # Returns `self`.
  #
  def +@: () -> Numeric

  # Performs subtraction: the class of the resulting object depends on the class
  # of `numeric`.
  #
  def -: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - -self -> numeric
  # -->
  # Unary Minus---Returns the receiver, negated.
  #
  def -@: () -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other -> zero or nil
  # -->
  # Returns zero if `self` is the same as `other`, `nil` otherwise.
  #
  # No subclass in the Ruby Core or Standard Library uses this implementation.
  #
  def <=>: (Numeric other) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - abs -> numeric
  # -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  # Numeric#magnitude is an alias for Numeric#abs.
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.abs2  ->  real
  # -->
  # Returns square of self.
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  def angle: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.arg    ->  0 or float
  #   - num.angle  ->  0 or float
  #   - num.phase  ->  0 or float
  # -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(digits = 0) -> integer or float
  # -->
  # Returns the smallest number that is greater than or equal to `self` with a
  # precision of `digits` decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#ceil.
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing two numeric elements, formed from the two
  # operands `self` and `other`, of a common compatible type.
  #
  # Of the Core and Standard Library classes, Integer, Rational, and Complex use
  # this implementation.
  #
  # Examples:
  #
  #     i = 2                    # => 2
  #     i.coerce(3)              # => [3, 2]
  #     i.coerce(3.0)            # => [3.0, 2.0]
  #     i.coerce(Rational(1, 2)) # => [0.5, 2.0]
  #     i.coerce(Complex(3, 4))  # Raises RangeError.
  #
  #     r = Rational(5, 2)       # => (5/2)
  #     r.coerce(2)              # => [(2/1), (5/2)]
  #     r.coerce(2.0)            # => [2.0, 2.5]
  #     r.coerce(Rational(2, 3)) # => [(2/3), (5/2)]
  #     r.coerce(Complex(3, 4))  # => [(3+4i), ((5/2)+0i)]
  #
  #     c = Complex(2, 3)        # => (2+3i)
  #     c.coerce(2)              # => [(2+0i), (2+3i)]
  #     c.coerce(2.0)            # => [(2.0+0i), (2+3i)]
  #     c.coerce(Rational(1, 2)) # => [((1/2)+0i), (2+3i)]
  #     c.coerce(Complex(3, 4))  # => [(3+4i), (2+3i)]
  #
  # Raises an exception if any type conversion fails.
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  # <!-- rdoc-file=complex.c -->
  # Returns self.
  #
  def conj: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.conj       ->  self
  #   - num.conjugate  ->  self
  # -->
  # Returns self.
  #
  def conjugate: () -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - num.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - div(other) -> integer
  # -->
  # Returns the quotient `self/other` as an integer (via `floor`), using method
  # `/` in the derived class of `self`. (Numeric itself does not define method
  # `/`.)
  #
  # Of the Core and Standard Library classes, Float, Rational, and Complex use
  # this implementation.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor                  # Quotient
  #     r = self % other                        # Remainder
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # Examples:
  #
  #     Rational(11, 1).divmod(4)               # => [2, (3/1)]
  #     Rational(11, 1).divmod(-4)              # => [-3, (-1/1)]
  #     Rational(-11, 1).divmod(4)              # => [-3, (1/1)]
  #     Rational(-11, 1).divmod(-4)             # => [2, (-3/1)]
  #
  #     Rational(12, 1).divmod(4)               # => [3, (0/1)]
  #     Rational(12, 1).divmod(-4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(-4)             # => [3, (0/1)]
  #
  #     Rational(13, 1).divmod(4.0)             # => [3, 1.0]
  #     Rational(13, 1).divmod(Rational(4, 11)) # => [35, (3/11)]
  #
  def divmod: (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `self` and `other` are the same type and have equal values.
  #
  # Of the Core and Standard Library classes, only Integer, Rational, and Complex
  # use this implementation.
  #
  # Examples:
  #
  #     1.eql?(1)              # => true
  #     1.eql?(1.0)            # => false
  #     1.eql?(Rational(1, 1)) # => false
  #     1.eql?(Complex(1, 0))  # => false
  #
  # Method `eql?` is different from +==+ in that `eql?` requires matching types,
  # while +==+ does not.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(other) -> float
  # -->
  # Returns the quotient `self/other` as a float, using method `/` in the derived
  # class of `self`. (Numeric itself does not define method `/`.)
  #
  # Of the Core and Standard Library classes, only BigDecimal uses this
  # implementation.
  #
  def fdiv: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.finite?  ->  true or false
  # -->
  # Returns `true` if `num` is a finite number, otherwise returns `false`.
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(digits = 0) -> integer or float
  # -->
  # Returns the largest number that is less than or equal to `self` with a
  # precision of `digits` decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#floor.
  #
  def floor: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - i -> complex
  # -->
  # Returns `Complex(0, self)`:
  #
  #     2.i              # => (0+2i)
  #     -2.i             # => (0-2i)
  #     2.0.i            # => (0+2.0i)
  #     Rational(1, 2).i # => (0+(1/2)*i)
  #     Complex(3, 4).i  # Raises NoMethodError.
  #
  def i: () -> Complex

  # <!-- rdoc-file=complex.c -->
  # Returns zero.
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.imag       ->  0
  #   - num.imaginary  ->  0
  # -->
  # Returns zero.
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.infinite?  ->  -1, 1, or nil
  # -->
  # Returns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
  # or `+Infinity`.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.integer?  ->  true or false
  # -->
  # Returns `true` if `num` is an Integer.
  #
  #     1.0.integer?   #=> false
  #     1.integer?     #=> true
  #
  def integer?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  # Numeric#magnitude is an alias for Numeric#abs.
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     c % n
  #     c-n*(c/n).floor
  #     c.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  # Numeric#modulo is an alias for Numeric#%.
  #
  def modulo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - negative? -> true or false
  # -->
  # Returns `true` if `self` is less than 0, `false` otherwise.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - nonzero?  ->  self or nil
  # -->
  # Returns `self` if `self` is not a zero value, `nil` otherwise; uses method
  # `zero?` for the evaluation.
  #
  # The returned `self` allows the method to be chained:
  #
  #     a = %w[z Bb bB bb BB a aA Aa AA A]
  #     a.sort {|a, b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #     # => ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  # Of the Core and Standard Library classes, Integer, Float, Rational, and
  # Complex use this implementation.
  #
  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - num.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  def numerator: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - num.polar  ->  array
  # -->
  # Returns an array; [num.abs, num.arg].
  #
  def polar: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - positive? -> true or false
  # -->
  # Returns `true` if `self` is greater than 0, `false` otherwise.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - num.quo(int_or_rat)   ->  rat
  #   - num.quo(flo)          ->  flo
  # -->
  # Returns the most exact division (rational for integers, float for floats).
  #
  def quo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.real  ->  self
  # -->
  # Returns self.
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.real?  ->  true or false
  # -->
  # Returns `true` if `num` is a real number (i.e. not Complex).
  #
  def real?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns an array; [num, 0].
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - num.rect  ->  array
  #   - num.rectangular  ->  array
  # -->
  # Returns an array; [num, 0].
  #
  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Of the Core and Standard Library classes, only Float and Rational use this
  # implementation.
  #
  # Examples:
  #
  #     11.0.remainder(4)              # => 3.0
  #     11.0.remainder(-4)             # => 3.0
  #     -11.0.remainder(4)             # => -3.0
  #     -11.0.remainder(-4)            # => -3.0
  #
  #     12.0.remainder(4)              # => 0.0
  #     12.0.remainder(-4)             # => 0.0
  #     -12.0.remainder(4)             # => -0.0
  #     -12.0.remainder(-4)            # => -0.0
  #
  #     13.0.remainder(4.0)            # => 1.0
  #     13.0.remainder(Rational(4, 1)) # => 1.0
  #
  #     Rational(13, 1).remainder(4)   # => (1/1)
  #     Rational(13, 1).remainder(-4)  # => (1/1)
  #     Rational(-13, 1).remainder(4)  # => (-1/1)
  #     Rational(-13, 1).remainder(-4) # => (-1/1)
  #
  def remainder: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(digits = 0) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `digits`
  # decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#round.
  #
  def round: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - step(to = nil, by = 1) {|n| ... } ->  self
  #   - step(to = nil, by = 1)            ->  enumerator
  #   - step(to = nil, by: 1) {|n| ... }  ->  self
  #   - step(to = nil, by: 1)             ->  enumerator
  #   - step(by: 1, to: ) {|n| ... }      ->  self
  #   - step(by: 1, to: )                 ->  enumerator
  #   - step(by: , to: nil) {|n| ... }    ->  self
  #   - step(by: , to: nil)               ->  enumerator
  # -->
  # Generates a sequence of numbers; with a block given, traverses the sequence.
  #
  #     Of the Core and Standard Library classes,
  #     Integer, Float, and Rational use this implementation.
  #
  #     A quick example:
  #
  #       squares = []
  #       1.step(by: 2, to: 10) {|i| squares.push(i*i) }
  #       squares # => [1, 9, 25, 49, 81]
  #
  #     The generated sequence:
  #
  #     - Begins with +self+.
  #     - Continues at intervals of +step+ (which may not be zero).
  #     - Ends with the last number that is within or equal to +limit+;
  #       that is, less than or equal to +limit+ if +step+ is positive,
  #       greater than or equal to +limit+ if +step+ is negative.
  #       If +limit+ is not given, the sequence is of infinite length.
  #
  #     If a block is given, calls the block with each number in the sequence;
  #     returns +self+.  If no block is given, returns an Enumerator::ArithmeticSequence.
  #
  #     <b>Keyword Arguments</b>
  #
  #     With keyword arguments +by+ and +to+,
  #     their values (or defaults) determine the step and limit:
  #
  #       # Both keywords given.
  #       squares = []
  #       4.step(by: 2, to: 10) {|i| squares.push(i*i) }    # => 4
  #       squares # => [16, 36, 64, 100]
  #       cubes = []
  #       3.step(by: -1.5, to: -3) {|i| cubes.push(i*i*i) } # => 3
  #       cubes   # => [27.0, 3.375, 0.0, -3.375, -27.0]
  #       squares = []
  #       1.2.step(by: 0.2, to: 2.0) {|f| squares.push(f*f) }
  #       squares # => [1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #       squares = []
  #       Rational(6/5).step(by: 0.2, to: 2.0) {|r| squares.push(r*r) }
  #       squares # => [1.0, 1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #       # Only keyword to given.
  #       squares = []
  #       4.step(to: 10) {|i| squares.push(i*i) }           # => 4
  #       squares # => [16, 25, 36, 49, 64, 81, 100]
  #       # Only by given.
  #
  #       # Only keyword by given
  #       squares = []
  #       4.step(by:2) {|i| squares.push(i*i); break if i > 10 }
  #       squares # => [16, 36, 64, 100, 144]
  #
  #       # No block given.
  #       e = 3.step(by: -1.5, to: -3) # => (3.step(by: -1.5, to: -3))
  #       e.class                      # => Enumerator::ArithmeticSequence
  #
  #     <b>Positional Arguments</b>
  #
  #     With optional positional arguments +limit+ and +step+,
  #     their values (or defaults) determine the step and limit:
  #
  #       squares = []
  #       4.step(10, 2) {|i| squares.push(i*i) }    # => 4
  #       squares # => [16, 36, 64, 100]
  #       squares = []
  #       4.step(10) {|i| squares.push(i*i) }
  #       squares # => [16, 25, 36, 49, 64, 81, 100]
  #       squares = []
  #       4.step {|i| squares.push(i*i); break if i > 10 }  # => nil
  #       squares # => [16, 25, 36, 49, 64, 81, 100, 121]
  #
  # **Implementation Notes**
  #
  #     If all the arguments are integers, the loop operates using an integer
  #     counter.
  #
  #     If any of the arguments are floating point numbers, all are converted
  #     to floats, and the loop is executed
  #     <i>floor(n + n*Float::EPSILON) + 1</i> times,
  #     where <i>n = (limit - self)/step</i>.
  #
  def step: (?Numeric limit, ?Numeric step) { (Numeric) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Numeric, self]
          | (?by: Numeric, ?to: Numeric) { (Numeric) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Numeric, self]

  # <!--
  #   rdoc-file=complex.c
  #   - num.to_c  ->  complex
  # -->
  # Returns the value as a complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_int -> integer
  # -->
  # Returns `self` as an integer; converts using method `to_i` in the derived
  # class.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  # Examples:
  #
  #     Rational(1, 2).to_int # => 0
  #     Rational(2, 1).to_int # => 2
  #     Complex(2, 0).to_int  # => 2
  #     Complex(2, 1)         # Raises RangeError (non-zero imaginary part)
  #
  def to_int: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(digits = 0) -> integer or float
  # -->
  # Returns `self` truncated (toward zero) to a precision of `digits` decimal
  # digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#truncate.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - zero? -> true or false
  # -->
  # Returns `true` if `zero` has a zero value, `false` otherwise.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - clone(freeze: true) -> self
  # -->
  # Returns `self`.
  #
  # Raises an exception if the value for `freeze` is neither `true` nor `nil`.
  #
  # Related: Numeric#dup.
  #
  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=re.c -->
# A Regexp holds a regular expression, used to match a pattern against strings.
# Regexps are created using the `/.../` and `%r{...}` literals, and by the
# Regexp::new constructor.
#
# You can create a Regexp object explicitly with:
#
# *   A [regexp literal](doc/syntax/literals_rdoc.html#label-Regexp+Literals).
#
#
# Regular expressions (*regexp*s) are patterns which describe the contents of a
# string. They're used for testing whether a string contains a given pattern, or
# extracting the portions that match. They are created with the `/`*pat*`/` and
# `%r{`*pat*`}` literals or the `Regexp.new` constructor.
#
# A regexp is usually delimited with forward slashes (`/`). For example:
#
#     /hay/ =~ 'haystack'   #=> 0
#     /y/.match('haystack') #=> #<MatchData "y">
#
# If a string contains the pattern it is said to *match*. A literal string
# matches itself.
#
# Here 'haystack' does not contain the pattern 'needle', so it doesn't match:
#
#     /needle/.match('haystack') #=> nil
#
# Here 'haystack' contains the pattern 'hay', so it matches:
#
#     /hay/.match('haystack')    #=> #<MatchData "hay">
#
# Specifically, `/st/` requires that the string contains the letter *s* followed
# by the letter *t*, so it matches *haystack*, also.
#
# ## `=~` and Regexp#match
#
# Pattern matching may be achieved by using `=~` operator or Regexp#match
# method.
#
# ### `=~` operator
#
# `=~` is Ruby's basic pattern-matching operator.  When one operand is a regular
# expression and the other is a string then the regular expression is used as a
# pattern to match against the string.  (This operator is equivalently defined
# by Regexp and String so the order of String and Regexp do not matter. Other
# classes may have different implementations of `=~`.)  If a match is found, the
# operator returns index of first match in string, otherwise it returns `nil`.
#
#     /hay/ =~ 'haystack'   #=> 0
#     'haystack' =~ /hay/   #=> 0
#     /a/   =~ 'haystack'   #=> 1
#     /u/   =~ 'haystack'   #=> nil
#
# Using `=~` operator with a String and Regexp the `$~` global variable is set
# after a successful match.  `$~` holds a MatchData object. Regexp.last_match is
# equivalent to `$~`.
#
# ### Regexp#match method
#
# The #match method returns a MatchData object:
#
#     /st/.match('haystack')   #=> #<MatchData "st">
#
# ## Metacharacters and Escapes
#
# The following are *metacharacters* `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`,
# `+`, `*`. They have a specific meaning when appearing in a pattern. To match
# them literally they must be backslash-escaped. To match a backslash literally,
# backslash-escape it: `\\\`.
#
#     /1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=> #<MatchData "1 + 2 = 3?">
#     /a\\\\b/.match('a\\\\b')                    #=> #<MatchData "a\\b">
#
# Patterns behave like double-quoted strings and can contain the same backslash
# escapes (the meaning of `\s` is different, however, see
# [below](#label-Character+Classes)).
#
#     /\s\u{6771 4eac 90fd}/.match("Go to ")
#         #=> #<MatchData " ">
#
# Arbitrary Ruby expressions can be embedded into patterns with the `#{...}`
# construct.
#
#     place = ""
#     /#{place}/.match("Go to ")
#         #=> #<MatchData "">
#
# ## Character Classes
#
# A *character class* is delimited with square brackets (`[`, `]`) and lists
# characters that may appear at that point in the match. `/[ab]/` means *a* or
# *b*, as opposed to `/ab/` which means *a* followed by *b*.
#
#     /W[aeiou]rd/.match("Word") #=> #<MatchData "Word">
#
# Within a character class the hyphen (`-`) is a metacharacter denoting an
# inclusive range of characters. `[abcd]` is equivalent to `[a-d]`. A range can
# be followed by another range, so `[abcdwxyz]` is equivalent to `[a-dw-z]`. The
# order in which ranges or individual characters appear inside a character class
# is irrelevant.
#
#     /[0-9a-f]/.match('9f') #=> #<MatchData "9">
#     /[9f]/.match('9f')     #=> #<MatchData "9">
#
# If the first character of a character class is a caret (`^`) the class is
# inverted: it matches any character *except* those named.
#
#     /[^a-eg-z]/.match('f') #=> #<MatchData "f">
#
# A character class may contain another character class. By itself this isn't
# useful because `[a-z[0-9]]` describes the same set as `[a-z0-9]`. However,
# character classes also support the `&&` operator which performs set
# intersection on its arguments. The two can be combined as follows:
#
#     /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))
#
# This is equivalent to:
#
#     /[abh-w]/
#
# The following metacharacters also behave like character classes:
#
# *   `/./` - Any character except a newline.
# *   `/./m` - Any character (the `m` modifier enables multiline mode)
# *   `/\w/` - A word character (`[a-zA-Z0-9_]`)
# *   `/\W/` - A non-word character (`[^a-zA-Z0-9_]`). Please take a look at
#     [Bug #4044](https://bugs.ruby-lang.org/issues/4044) if using `/\W/` with
#     the `/i` modifier.
# *   `/\d/` - A digit character (`[0-9]`)
# *   `/\D/` - A non-digit character (`[^0-9]`)
# *   `/\h/` - A hexdigit character (`[0-9a-fA-F]`)
# *   `/\H/` - A non-hexdigit character (`[^0-9a-fA-F]`)
# *   `/\s/` - A whitespace character: `/[ \t\r\n\f\v]/`
# *   `/\S/` - A non-whitespace character: `/[^ \t\r\n\f\v]/`
# *   `/\R/` - A linebreak: `\n`, `\v`, `\f`, `\r` `\u0085` (NEXT LINE),
#     `\u2028` (LINE SEPARATOR), `\u2029` (PARAGRAPH SEPARATOR) or `\r\n`.
#
#
# POSIX *bracket expressions* are also similar to character classes. They
# provide a portable alternative to the above, with the added benefit that they
# encompass non-ASCII characters. For instance, `/\d/` matches only the ASCII
# decimal digits (0-9); whereas `/[[:digit:]]/` matches any character in the
# Unicode *Nd* category.
#
# *   `/[[:alnum:]]/` - Alphabetic and numeric character
# *   `/[[:alpha:]]/` - Alphabetic character
# *   `/[[:blank:]]/` - Space or tab
# *   `/[[:cntrl:]]/` - Control character
# *   `/[[:digit:]]/` - Digit
# *   `/[[:graph:]]/` - Non-blank character (excludes spaces, control
#     characters, and similar)
# *   `/[[:lower:]]/` - Lowercase alphabetical character
# *   `/[[:print:]]/` - Like [:graph:], but includes the space character
# *   `/[[:punct:]]/` - Punctuation character
# *   `/[[:space:]]/` - Whitespace character (`[:blank:]`, newline, carriage
#     return, etc.)
# *   `/[[:upper:]]/` - Uppercase alphabetical
# *   `/[[:xdigit:]]/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
#
#
# Ruby also supports the following non-POSIX character classes:
#
# *   `/[[:word:]]/` - A character in one of the following Unicode general
#     categories *Letter*, *Mark*, *Number*, *Connector_Punctuation*
# *   `/[[:ascii:]]/` - A character in the ASCII character set
#
#         # U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"
#         /[[:digit:]]/.match("\u06F2")    #=> #<MatchData "\u{06F2}">
#         /[[:upper:]][[:lower:]]/.match("Hello") #=> #<MatchData "He">
#         /[[:xdigit:]][[:xdigit:]]/.match("A6")  #=> #<MatchData "A6">
#
#
# ## Repetition
#
# The constructs described so far match a single character. They can be followed
# by a repetition metacharacter to specify how many times they need to occur.
# Such metacharacters are called *quantifiers*.
#
# *   `*` - Zero or more times
# *   `+` - One or more times
# *   `?` - Zero or one times (optional)
# *   `{`*n*`}` - Exactly *n* times
# *   `{`*n*`,}` - *n* or more times
# *   `{,`*m*`}` - *m* or less times
# *   `{`*n*`,`*m*`}` - At least *n* and at most *m* times
#
#
# At least one uppercase character ('H'), at least one lowercase character
# ('e'), two 'l' characters, then one 'o':
#
#     "Hello".match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=> #<MatchData "Hello">
#
# ### Greedy match
#
# Repetition is *greedy* by default: as many occurrences as possible are matched
# while still allowing the overall match to succeed. By contrast, *lazy*
# matching makes the minimal amount of matches necessary for overall success.
# Most greedy metacharacters can be made lazy by following them with `?`. For
# the `{n}` pattern, because it specifies an exact number of characters to match
# and not a variable number of characters, the `?` metacharacter instead makes
# the repeated pattern optional.
#
# Both patterns below match the string. The first uses a greedy quantifier so
# '.+' matches '<a><b>'; the second uses a lazy quantifier so '.+?' matches
# '<a>':
#
#     /<.+>/.match("<a><b>")  #=> #<MatchData "<a><b>">
#     /<.+?>/.match("<a><b>") #=> #<MatchData "<a>">
#
# ### Possessive match
#
# A quantifier followed by `+` matches *possessively*: once it has matched it
# does not backtrack. They behave like greedy quantifiers, but having matched
# they refuse to "give up" their match even if this jeopardises the overall
# match.
#
#     /<.*><.+>/.match("<a><b>") #=> #<MatchData "<a><b>">
#     /<.*+><.+>/.match("<a><b>") #=> nil
#     /<.*><.++>/.match("<a><b>") #=> nil
#
# ## Capturing
#
# Parentheses can be used for *capturing*. The text enclosed by the *n*th group
# of parentheses can be subsequently referred to with *n*. Within a pattern use
# the *backreference* `\n` (e.g. `\1`); outside of the pattern use
# `MatchData[n]` (e.g. `MatchData[1]`).
#
# In this example, `'at'` is captured by the first group of parentheses, then
# referred to later with `\1`:
#
#     /[csh](..) [csh]\1 in/.match("The cat sat in the hat")
#         #=> #<MatchData "cat sat in" 1:"at">
#
# Regexp#match returns a MatchData object which makes the captured text
# available with its #[] method:
#
#     /[csh](..) [csh]\1 in/.match("The cat sat in the hat")[1] #=> 'at'
#
# While Ruby supports an arbitrary number of numbered captured groups, only
# groups 1-9 are supported using the `\n` backreference syntax.
#
# Ruby also supports `\0` as a special backreference, which references the
# entire matched string.  This is also available at `MatchData[0]`.  Note that
# the `\0` backreference cannot be used inside the regexp, as backreferences can
# only be used after the end of the capture group, and the `\0` backreference
# uses the implicit capture group of the entire match.  However, you can use
# this backreference when doing substitution:
#
#     "The cat sat in the hat".gsub(/[csh]at/, '\0s')
#       # => "The cats sats in the hats"
#
# ### Named captures
#
# Capture groups can be referred to by name when defined with the
# `(?<`*name*`>)` or `(?'`*name*`')` constructs.
#
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")
#         #=> #<MatchData "$3.67" dollars:"3" cents:"67">
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")[:dollars] #=> "3"
#
# Named groups can be backreferenced with `\k<`*name*`>`, where *name* is the
# group name.
#
#     /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
#         #=> #<MatchData "ototo" vowel:"o">
#
# **Note**: A regexp can't use named backreferences and numbered backreferences
# simultaneously. Also, if a named capture is used in a regexp, then parentheses
# used for grouping which would otherwise result in a unnamed capture are
# treated as non-capturing.
#
#     /(\w)(\w)/.match("ab").captures # => ["a", "b"]
#     /(\w)(\w)/.match("ab").named_captures # => {}
#
#     /(?<c>\w)(\w)/.match("ab").captures # => ["a"]
#     /(?<c>\w)(\w)/.match("ab").named_captures # => {"c"=>"a"}
#
# When named capture groups are used with a literal regexp on the left-hand side
# of an expression and the `=~` operator, the captured text is also assigned to
# local variables with corresponding names.
#
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" #=> 0
#     dollars #=> "3"
#
# ## Grouping
#
# Parentheses also *group* the terms they enclose, allowing them to be
# quantified as one *atomic* whole.
#
# The pattern below matches a vowel followed by 2 word characters:
#
#     /[aeiou]\w{2}/.match("Caenorhabditis elegans") #=> #<MatchData "aen">
#
# Whereas the following pattern matches a vowel followed by a word character,
# twice, i.e. `[aeiou]\w[aeiou]\w`: 'enor'.
#
#     /([aeiou]\w){2}/.match("Caenorhabditis elegans")
#         #=> #<MatchData "enor" 1:"or">
#
# The `(?:`...`)` construct provides grouping without capturing. That is, it
# combines the terms it contains into an atomic whole without creating a
# backreference. This benefits performance at the slight expense of readability.
#
# The first group of parentheses captures 'n' and the second 'ti'. The second
# group is referred to later with the backreference `\2`:
#
#     /I(n)ves(ti)ga\2ons/.match("Investigations")
#         #=> #<MatchData "Investigations" 1:"n" 2:"ti">
#
# The first group of parentheses is now made non-capturing with '?:', so it
# still matches 'n', but doesn't create the backreference. Thus, the
# backreference `\1` now refers to 'ti'.
#
#     /I(?:n)ves(ti)ga\1ons/.match("Investigations")
#         #=> #<MatchData "Investigations" 1:"ti">
#
# ### Atomic Grouping
#
# Grouping can be made *atomic* with `(?>`*pat*`)`. This causes the
# subexpression *pat* to be matched independently of the rest of the expression
# such that what it matches becomes fixed for the remainder of the match, unless
# the entire subexpression must be abandoned and subsequently revisited. In this
# way *pat* is treated as a non-divisible whole. Atomic grouping is typically
# used to optimise patterns so as to prevent the regular expression engine from
# backtracking needlessly.
#
# The `"` in the pattern below matches the first character of the string, then
# `.*` matches *Quote"*. This causes the overall match to fail, so the text
# matched by `.*` is backtracked by one position, which leaves the final
# character of the string available to match `"`
#
#     /".*"/.match('"Quote"')     #=> #<MatchData "\"Quote\"">
#
# If `.*` is grouped atomically, it refuses to backtrack *Quote"*, even though
# this means that the overall match fails
#
#     /"(?>.*)"/.match('"Quote"') #=> nil
#
# ## Subexpression Calls
#
# The `\g<`*name*`>` syntax matches the previous subexpression named *name*,
# which can be a group name or number, again. This differs from backreferences
# in that it re-executes the group rather than simply trying to re-match the
# same text.
#
# This pattern matches a *(* character and assigns it to the `paren` group,
# tries to call that the `paren` sub-expression again but fails, then matches a
# literal *)*:
#
#     /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'
#
#     /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' #=> 0
#     # ^1
#     #      ^2
#     #           ^3
#     #                 ^4
#     #      ^5
#     #           ^6
#     #                      ^7
#     #                       ^8
#     #                       ^9
#     #                           ^10
#
# 1.  Matches at the beginning of the string, i.e. before the first character.
# 2.  Enters a named capture group called `paren`
# 3.  Matches a literal *(*, the first character in the string
# 4.  Calls the `paren` group again, i.e. recurses back to the second step
# 5.  Re-enters the `paren` group
# 6.  Matches a literal *(*, the second character in the string
# 7.  Try to call `paren` a third time, but fail because doing so would prevent
#     an overall successful match
# 8.  Match a literal *)*, the third character in the string. Marks the end of
#     the second recursive call
# 9.  Match a literal *)*, the fourth character in the string
# 10. Match the end of the string
#
#
# ## Alternation
#
# The vertical bar metacharacter (`|`) combines several expressions into a
# single one that matches any of the expressions. Each expression is an
# *alternative*.
#
#     /\w(and|or)\w/.match("Feliformia") #=> #<MatchData "form" 1:"or">
#     /\w(and|or)\w/.match("furandi")    #=> #<MatchData "randi" 1:"and">
#     /\w(and|or)\w/.match("dissemblance") #=> nil
#
# ## Character Properties
#
# The `\p{}` construct matches characters with the named property, much like
# POSIX bracket classes.
#
# *   `/\p{Alnum}/` - Alphabetic and numeric character
# *   `/\p{Alpha}/` - Alphabetic character
# *   `/\p{Blank}/` - Space or tab
# *   `/\p{Cntrl}/` - Control character
# *   `/\p{Digit}/` - Digit
# *   `/\p{Graph}/` - Non-blank character (excludes spaces, control characters,
#     and similar)
# *   `/\p{Lower}/` - Lowercase alphabetical character
# *   `/\p{Print}/` - Like `\p{Graph}`, but includes the space character
# *   `/\p{Punct}/` - Punctuation character
# *   `/\p{Space}/` - Whitespace character (`[:blank:]`, newline, carriage
#     return, etc.)
# *   `/\p{Upper}/` - Uppercase alphabetical
# *   `/\p{XDigit}/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
# *   `/\p{Word}/` - A member of one of the following Unicode general category
#     *Letter*, *Mark*, *Number*, *Connector_Punctuation*
# *   `/\p{ASCII}/` - A character in the ASCII character set
# *   `/\p{Any}/` - Any Unicode character (including unassigned characters)
# *   `/\p{Assigned}/` - An assigned character
#
#
# A Unicode character's *General Category* value can also be matched with
# `\p{`*Ab*`}` where *Ab* is the category's abbreviation as described below:
#
# *   `/\p{L}/` - 'Letter'
# *   `/\p{Ll}/` - 'Letter: Lowercase'
# *   `/\p{Lm}/` - 'Letter: Mark'
# *   `/\p{Lo}/` - 'Letter: Other'
# *   `/\p{Lt}/` - 'Letter: Titlecase'
# *   `/\p{Lu}/` - 'Letter: Uppercase
# *   `/\p{Lo}/` - 'Letter: Other'
# *   `/\p{M}/` - 'Mark'
# *   `/\p{Mn}/` - 'Mark: Nonspacing'
# *   `/\p{Mc}/` - 'Mark: Spacing Combining'
# *   `/\p{Me}/` - 'Mark: Enclosing'
# *   `/\p{N}/` - 'Number'
# *   `/\p{Nd}/` - 'Number: Decimal Digit'
# *   `/\p{Nl}/` - 'Number: Letter'
# *   `/\p{No}/` - 'Number: Other'
# *   `/\p{P}/` - 'Punctuation'
# *   `/\p{Pc}/` - 'Punctuation: Connector'
# *   `/\p{Pd}/` - 'Punctuation: Dash'
# *   `/\p{Ps}/` - 'Punctuation: Open'
# *   `/\p{Pe}/` - 'Punctuation: Close'
# *   `/\p{Pi}/` - 'Punctuation: Initial Quote'
# *   `/\p{Pf}/` - 'Punctuation: Final Quote'
# *   `/\p{Po}/` - 'Punctuation: Other'
# *   `/\p{S}/` - 'Symbol'
# *   `/\p{Sm}/` - 'Symbol: Math'
# *   `/\p{Sc}/` - 'Symbol: Currency'
# *   `/\p{Sc}/` - 'Symbol: Currency'
# *   `/\p{Sk}/` - 'Symbol: Modifier'
# *   `/\p{So}/` - 'Symbol: Other'
# *   `/\p{Z}/` - 'Separator'
# *   `/\p{Zs}/` - 'Separator: Space'
# *   `/\p{Zl}/` - 'Separator: Line'
# *   `/\p{Zp}/` - 'Separator: Paragraph'
# *   `/\p{C}/` - 'Other'
# *   `/\p{Cc}/` - 'Other: Control'
# *   `/\p{Cf}/` - 'Other: Format'
# *   `/\p{Cn}/` - 'Other: Not Assigned'
# *   `/\p{Co}/` - 'Other: Private Use'
# *   `/\p{Cs}/` - 'Other: Surrogate'
#
#
# Lastly, `\p{}` matches a character's Unicode *script*. The following scripts
# are supported: *Arabic*, *Armenian*, *Balinese*, *Bengali*, *Bopomofo*,
# *Braille*, *Buginese*, *Buhid*, *Canadian_Aboriginal*, *Carian*, *Cham*,
# *Cherokee*, *Common*, *Coptic*, *Cuneiform*, *Cypriot*, *Cyrillic*, *Deseret*,
# *Devanagari*, *Ethiopic*, *Georgian*, *Glagolitic*, *Gothic*, *Greek*,
# *Gujarati*, *Gurmukhi*, *Han*, *Hangul*, *Hanunoo*, *Hebrew*, *Hiragana*,
# *Inherited*, *Kannada*, *Katakana*, *Kayah_Li*, *Kharoshthi*, *Khmer*, *Lao*,
# *Latin*, *Lepcha*, *Limbu*, *Linear_B*, *Lycian*, *Lydian*, *Malayalam*,
# *Mongolian*, *Myanmar*, *New_Tai_Lue*, *Nko*, *Ogham*, *Ol_Chiki*,
# *Old_Italic*, *Old_Persian*, *Oriya*, *Osmanya*, *Phags_Pa*, *Phoenician*,
# *Rejang*, *Runic*, *Saurashtra*, *Shavian*, *Sinhala*, *Sundanese*,
# *Syloti_Nagri*, *Syriac*, *Tagalog*, *Tagbanwa*, *Tai_Le*, *Tamil*, *Telugu*,
# *Thaana*, *Thai*, *Tibetan*, *Tifinagh*, *Ugaritic*, *Vai*, and *Yi*.
#
# Unicode codepoint U+06E9 is named "ARABIC PLACE OF SAJDAH" and belongs to the
# Arabic script:
#
#     /\p{Arabic}/.match("\u06E9") #=> #<MatchData "\u06E9">
#
# All character properties can be inverted by prefixing their name with a caret
# (`^`).
#
# Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so this
# match succeeds:
#
#     /\p{^Ll}/.match("A") #=> #<MatchData "A">
#
# ## Anchors
#
# Anchors are metacharacter that match the zero-width positions between
# characters, *anchoring* the match to a specific position.
#
# *   `^` - Matches beginning of line
# *   `$` - Matches end of line
# *   `\A` - Matches beginning of string.
# *   `\Z` - Matches end of string. If string ends with a newline, it matches
#     just before newline
# *   `\z` - Matches end of string
# *   `\G` - Matches first matching position:
#
#     In methods like `String#gsub` and `String#scan`, it changes on each
#     iteration. It initially matches the beginning of subject, and in each
#     following iteration it matches where the last match finished.
#
#         "    a b c".gsub(/ /, '_')    #=> "____a_b_c"
#         "    a b c".gsub(/\G /, '_')  #=> "____a b c"
#
#     In methods like `Regexp#match` and `String#match` that take an (optional)
#     offset, it matches where the search begins.
#
#         "hello, world".match(/,/, 3)    #=> #<MatchData ",">
#         "hello, world".match(/\G,/, 3)  #=> nil
#
# *   `\b` - Matches word boundaries when outside brackets; backspace (0x08)
#     when inside brackets
# *   `\B` - Matches non-word boundaries
# *   `(?=`*pat*`)` - *Positive lookahead* assertion: ensures that the following
#     characters match *pat*, but doesn't include those characters in the
#     matched text
# *   `(?!`*pat*`)` - *Negative lookahead* assertion: ensures that the following
#     characters do not match *pat*, but doesn't include those characters in the
#     matched text
# *   `(?<=`*pat*`)` - *Positive lookbehind* assertion: ensures that the
#     preceding characters match *pat*, but doesn't include those characters in
#     the matched text
# *   `(?<!`*pat*`)` - *Negative lookbehind* assertion: ensures that the
#     preceding characters do not match *pat*, but doesn't include those
#     characters in the matched text
# *   `\K` - Uses an positive lookbehind of the content preceding `\K` in the
#     regexp.  For example, the following two regexps are almost equivalent:
#
#         /ab\Kc/
#         /(?<=ab)c/
#
#     As are the following two regexps:
#
#         /(a)\K(b)\Kc/
#         /(?<=(?<=(a))(b))c/
#
#
# If a pattern isn't anchored it can begin at any point in the string:
#
#     /real/.match("surrealist") #=> #<MatchData "real">
#
# Anchoring the pattern to the beginning of the string forces the match to start
# there. 'real' doesn't occur at the beginning of the string, so now the match
# fails:
#
#     /\Areal/.match("surrealist") #=> nil
#
# The match below fails because although 'Demand' contains 'and', the pattern
# does not occur at a word boundary.
#
#     /\band/.match("Demand")
#
# Whereas in the following example 'and' has been anchored to a non-word
# boundary so instead of matching the first 'and' it matches from the fourth
# letter of 'demand' instead:
#
#     /\Band.+/.match("Supply and demand curve") #=> #<MatchData "and curve">
#
# The pattern below uses positive lookahead and positive lookbehind to match
# text appearing in  tags without including the tags in the match:
#
#     /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>")
#         #=> #<MatchData "bold">
#
# ## Options
#
# The end delimiter for a regexp can be followed by one or more single-letter
# options which control how the pattern can match.
#
# *   `/pat/i` - Ignore case
# *   `/pat/m` - Treat a newline as a character matched by `.`
# *   `/pat/x` - Ignore whitespace and comments in the pattern
# *   `/pat/o` - Perform `#{}` interpolation only once
#
#
# `i`, `m`, and `x` can also be applied on the subexpression level with the
# `(?`*on*`-`*off*`)` construct, which enables options *on*, and disables
# options *off* for the expression enclosed by the parentheses:
#
#     /a(?i:b)c/.match('aBc')   #=> #<MatchData "aBc">
#     /a(?-i:b)c/i.match('ABC') #=> nil
#
# Additionally, these options can also be toggled for the remainder of the
# pattern:
#
#     /a(?i)bc/.match('abC') #=> #<MatchData "abC">
#
# Options may also be used with `Regexp.new`:
#
#     Regexp.new("abc", Regexp::IGNORECASE)                     #=> /abc/i
#     Regexp.new("abc", Regexp::MULTILINE)                      #=> /abc/m
#     Regexp.new("abc # Comment", Regexp::EXTENDED)             #=> /abc # Comment/x
#     Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) #=> /abc/mi
#
# ## Free-Spacing Mode and Comments
#
# As mentioned above, the `x` option enables *free-spacing* mode. Literal white
# space inside the pattern is ignored, and the octothorpe (`#`) character
# introduces a comment until the end of the line. This allows the components of
# the pattern to be organized in a potentially more readable fashion.
#
# A contrived pattern to match a number with optional decimal places:
#
#     float_pat = /\A
#         [[:digit:]]+ # 1 or more digits before the decimal point
#         (\.          # Decimal point
#             [[:digit:]]+ # 1 or more digits after the decimal point
#         )? # The decimal point and following digits are optional
#     \Z/x
#     float_pat.match('3.14') #=> #<MatchData "3.14" 1:".14">
#
# There are a number of strategies for matching whitespace:
#
# *   Use a pattern such as `\s` or `\p{Space}`.
# *   Use escaped whitespace such as `\ `, i.e. a space preceded by a backslash.
# *   Use a character class such as `[ ]`.
#
#
# Comments can be included in a non-`x` pattern with the `(?#`*comment*`)`
# construct, where *comment* is arbitrary text ignored by the regexp engine.
#
# Comments in regexp literals cannot include unescaped terminator characters.
#
# ## Encoding
#
# Regular expressions are assumed to use the source encoding. This can be
# overridden with one of the following modifiers.
#
# *   `/`*pat*`/u` - UTF-8
# *   `/`*pat*`/e` - EUC-JP
# *   `/`*pat*`/s` - Windows-31J
# *   `/`*pat*`/n` - ASCII-8BIT
#
#
# A regexp can be matched against a string when they either share an encoding,
# or the regexp's encoding is *US-ASCII* and the string's encoding is
# ASCII-compatible.
#
# If a match between incompatible encodings is attempted an
# `Encoding::CompatibilityError` exception is raised.
#
# The `Regexp#fixed_encoding?` predicate indicates whether the regexp has a
# *fixed* encoding, that is one incompatible with ASCII. A regexp's encoding can
# be explicitly fixed by supplying `Regexp::FIXEDENCODING` as the second
# argument of `Regexp.new`:
#
#     r = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
#     r =~ "a\u3042"
#        # raises Encoding::CompatibilityError: incompatible encoding regexp match
#        #         (ISO-8859-1 regexp with UTF-8 string)
#
# ## Special global variables
#
# Pattern matching sets some global variables :
# *   `$~` is equivalent to Regexp.last_match;
# *   `$&` contains the complete matched text;
# *   `$`` contains string before match;
# *   `$'` contains string after match;
# *   `$1`, `$2` and so on contain text matching first, second, etc capture
#     group;
# *   `$+` contains last capture group.
#
#
# Example:
#
#     m = /s(\w{2}).*(c)/.match('haystack') #=> #<MatchData "stac" 1:"ta" 2:"c">
#     $~                                    #=> #<MatchData "stac" 1:"ta" 2:"c">
#     Regexp.last_match                     #=> #<MatchData "stac" 1:"ta" 2:"c">
#
#     $&      #=> "stac"
#             # same as m[0]
#     $`      #=> "hay"
#             # same as m.pre_match
#     $'      #=> "k"
#             # same as m.post_match
#     $1      #=> "ta"
#             # same as m[1]
#     $2      #=> "c"
#             # same as m[2]
#     $3      #=> nil
#             # no third group in pattern
#     $+      #=> "c"
#             # same as m[-1]
#
# These global variables are thread-local and method-local variables.
#
# ## Performance
#
# Certain pathological combinations of constructs can lead to abysmally bad
# performance.
#
# Consider a string of 25 *a*s, a *d*, 4 *a*s, and a *c*.
#
#     s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
#     #=> "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"
#
# The following patterns match instantly as you would expect:
#
#     /(b|a)/ =~ s #=> 0
#     /(b|a+)/ =~ s #=> 0
#     /(b|a+)*/ =~ s #=> 0
#
# However, the following pattern takes appreciably longer:
#
#     /(b|a+)*c/ =~ s #=> 26
#
# This happens because an atom in the regexp is quantified by both an immediate
# `+` and an enclosing `*` with nothing to differentiate which is in control of
# any particular character. The nondeterminism that results produces
# super-linear performance. (Consult *Mastering Regular Expressions* (3rd ed.),
# pp 222, by *Jeffery Friedl*, for an in-depth analysis). This particular case
# can be fixed by use of atomic grouping, which prevents the unnecessary
# backtracking:
#
#     (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)
#        #=> 24.702736882
#     (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start)
#        #=> 0.000166571
#
# A similar case is typified by the following example, which takes approximately
# 60 seconds to execute for me:
#
# Match a string of 29 *a*s against a pattern of 29 optional *a*s followed by 29
# mandatory *a*s:
#
#     Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29
#
# The 29 optional *a*s match the string, but this prevents the 29 mandatory *a*s
# that follow from matching. Ruby must then backtrack repeatedly so as to
# satisfy as many of the optional matches as it can while still matching the
# mandatory 29. It is plain to us that none of the optional matches can succeed,
# but this fact unfortunately eludes Ruby.
#
# The best way to improve performance is to significantly reduce the amount of
# backtracking needed.  For this case, instead of individually matching 29
# optional *a*s, a range of optional *a*s can be matched all at once with
# *a{0,29}*:
#
#     Regexp.new('a{0,29}' + 'a' * 29) =~ 'a' * 29
#
class Regexp
  # <!--
  #   rdoc-file=re.c
  #   - Regexp.new(string, [options])       -> regexp
  #   - Regexp.new(regexp)                  -> regexp
  #   - Regexp.compile(string, [options])   -> regexp
  #   - Regexp.compile(regexp)              -> regexp
  # -->
  # Constructs a new regular expression from `pattern`, which can be either a
  # String or a Regexp (in which case that regexp's options are propagated), and
  # new options may not be specified (a change as of Ruby 1.8).
  #
  # If `options` is an Integer, it should be one or more of the constants
  # Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, *or*-ed together.
  #  Otherwise, if `options` is not `nil` or `false`, the regexp will be case
  # insensitive.
  #
  #     r1 = Regexp.new('^a-z+:\\s+\w+') #=> /^a-z+:\s+\w+/
  #     r2 = Regexp.new('cat', true)     #=> /cat/i
  #     r3 = Regexp.new(r2)              #=> /cat/i
  #     r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=> /dog/ix
  #
  def initialize: (String string, ?untyped options, ?String kcode) -> Object
                | (Regexp regexp) -> void

  # <!--
  #   rdoc-file=re.c
  #   - compile(*args)
  # -->
  # Alias for Regexp.new
  #
  def self.compile: (String string, ?untyped options, ?String kcode) -> Regexp
                  | (Regexp regexp) -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(str)   -> string
  #   - Regexp.quote(str)    -> string
  # -->
  # Escapes any characters that would have special meaning in a regular
  # expression. Returns a new escaped string with the same or compatible encoding.
  # For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.
  #
  #     Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.
  #
  def self.escape: (String | Symbol str) -> String

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.last_match           -> matchdata
  #   - Regexp.last_match(n)        -> str
  # -->
  # The first form returns the MatchData object generated by the last successful
  # pattern match.  Equivalent to reading the special global variable `$~` (see
  # Special global variables in Regexp for details).
  #
  # The second form returns the *n*th field in this MatchData object. *n* can be a
  # string or symbol to reference a named capture.
  #
  # Note that the last_match is local to the thread and method scope of the method
  # that did the pattern match.
  #
  #     /c(.)t/ =~ 'cat'        #=> 0
  #     Regexp.last_match       #=> #<MatchData "cat" 1:"a">
  #     Regexp.last_match(0)    #=> "cat"
  #     Regexp.last_match(1)    #=> "a"
  #     Regexp.last_match(2)    #=> nil
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "var = val"
  #     Regexp.last_match       #=> #<MatchData "var = val" lhs:"var" rhs:"val">
  #     Regexp.last_match(:lhs) #=> "var"
  #     Regexp.last_match(:rhs) #=> "val"
  #
  def self.last_match: () -> MatchData?
                     | (Integer n) -> String?
                     | (Symbol | String n) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(str)   -> string
  #   - Regexp.quote(str)    -> string
  # -->
  # Escapes any characters that would have special meaning in a regular
  # expression. Returns a new escaped string with the same or compatible encoding.
  # For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.
  #
  #     Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.
  #
  def self.quote: (String | Symbol str) -> String

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.try_convert(obj) -> re or nil
  # -->
  # Try to convert *obj* into a Regexp, using to_regexp method. Returns converted
  # regexp or nil if *obj* cannot be converted for any reason.
  #
  #     Regexp.try_convert(/re/)         #=> /re/
  #     Regexp.try_convert("re")         #=> nil
  #
  #     o = Object.new
  #     Regexp.try_convert(o)            #=> nil
  #     def o.to_regexp() /foo/ end
  #     Regexp.try_convert(o)            #=> /foo/
  #
  def self.try_convert: (untyped obj) -> Regexp?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.union(pat1, pat2, ...)            -> new_regexp
  #   - Regexp.union(pats_ary)                   -> new_regexp
  # -->
  # Return a Regexp object that is the union of the given *pattern*s, i.e., will
  # match any of its parts. The *pattern*s can be Regexp objects, in which case
  # their options will be preserved, or Strings. If no patterns are given, returns
  # `/(?!)/`.  The behavior is unspecified if any given *pattern* contains
  # capture.
  #
  #     Regexp.union                         #=> /(?!)/
  #     Regexp.union("penzance")             #=> /penzance/
  #     Regexp.union("a+b*c")                #=> /a\+b\*c/
  #     Regexp.union("skiing", "sledding")   #=> /skiing|sledding/
  #     Regexp.union(["skiing", "sledding"]) #=> /skiing|sledding/
  #     Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/
  #
  # Note: the arguments for ::union will try to be converted into a regular
  # expression literal via #to_regexp.
  #
  def self.union: () -> Regexp
                | (String | Regexp pat1, *String | Regexp pat2) -> Regexp
                | (::Array[String | Regexp]) -> Regexp

  public

  # <!-- rdoc-file=re.c -->
  # Equality---Two regexps are equal if their patterns are identical, they have
  # the same character set code, and their `casefold?` values are the same.
  #
  #     /abc/  == /abc/x   #=> false
  #     /abc/  == /abc/i   #=> false
  #     /abc/  == /abc/u   #=> false
  #     /abc/u == /abc/n   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp === str   -> true or false
  # -->
  # Case Equality---Used in case statements.
  #
  #     a = "HELLO"
  #     case a
  #     when /\A[a-z]*\z/; print "Lower case\n"
  #     when /\A[A-Z]*\z/; print "Upper case\n"
  #     else;              print "Mixed case\n"
  #     end
  #     #=> "Upper case"
  #
  # Following a regular expression literal with the #=== operator allows you to
  # compare against a String.
  #
  #     /^[a-z]*$/ === "HELLO" #=> false
  #     /^[A-Z]*$/ === "HELLO" #=> true
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp =~ str    -> integer or nil
  # -->
  # Match---Matches *rxp* against *str*.
  #
  #     /at/ =~ "input data"   #=> 7
  #     /ax/ =~ "input data"   #=> nil
  #
  # If `=~` is used with a regexp literal with named captures, captured strings
  # (or nil) is assigned to local variables named by the capture names.
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = y  "
  #     p lhs    #=> "x"
  #     p rhs    #=> "y"
  #
  # If it is not matched, nil is assigned for the variables.
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = "
  #     p lhs    #=> nil
  #     p rhs    #=> nil
  #
  # This assignment is implemented in the Ruby parser. The parser detects
  # 'regexp-literal =~ expression' for the assignment. The regexp must be a
  # literal without interpolation and placed at left hand side.
  #
  # The assignment does not occur if the regexp is not a literal.
  #
  #     re = /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
  #     re =~ "  x = y  "
  #     p lhs    # undefined local variable
  #     p rhs    # undefined local variable
  #
  # A regexp interpolation, `#{}`, also disables the assignment.
  #
  #     rhs_pat = /(?<rhs>\w+)/
  #     /(?<lhs>\w+)\s*=\s*#{rhs_pat}/ =~ "x = y"
  #     p lhs    # undefined local variable
  #
  # The assignment does not occur if the regexp is placed at the right hand side.
  #
  #     "  x = y  " =~ /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
  #     p lhs, rhs # undefined local variable
  #
  def =~: (String? str) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - rxp.casefold?   -> true or false
  # -->
  # Returns the value of the case-insensitive flag.
  #
  #     /a/.casefold?           #=> false
  #     /a/i.casefold?          #=> true
  #     /(?i:a)/.casefold?      #=> false
  #
  def casefold?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=re.c
  #   - rxp == other_rxp      -> true or false
  #   - rxp.eql?(other_rxp)   -> true or false
  # -->
  # Equality---Two regexps are equal if their patterns are identical, they have
  # the same character set code, and their `casefold?` values are the same.
  #
  #     /abc/  == /abc/x   #=> false
  #     /abc/  == /abc/i   #=> false
  #     /abc/  == /abc/u   #=> false
  #     /abc/u == /abc/n   #=> false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.fixed_encoding?   -> true or false
  # -->
  # Returns false if rxp is applicable to a string with any ASCII compatible
  # encoding. Returns true otherwise.
  #
  #     r = /a/
  #     r.fixed_encoding?                               #=> false
  #     r =~ "\u{6666} a"                               #=> 2
  #     r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2
  #     r =~ "abc".force_encoding("euc-jp")             #=> 0
  #
  #     r = /a/u
  #     r.fixed_encoding?                               #=> true
  #     r.encoding                                      #=> #<Encoding:UTF-8>
  #     r =~ "\u{6666} a"                               #=> 2
  #     r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
  #     r =~ "abc".force_encoding("euc-jp")             #=> 0
  #
  #     r = /\u{6666}/
  #     r.fixed_encoding?                               #=> true
  #     r.encoding                                      #=> #<Encoding:UTF-8>
  #     r =~ "\u{6666} a"                               #=> 0
  #     r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
  #     r =~ "abc".force_encoding("euc-jp")             #=> nil
  #
  def fixed_encoding?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.hash   -> integer
  # -->
  # Produce a hash based on the text and options of this regular expression.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - rxp.inspect   -> string
  # -->
  # Produce a nicely formatted string-version of *rxp*. Perhaps surprisingly,
  # `#inspect` actually produces the more natural version of the string than
  # `#to_s`.
  #
  #     /ab+c/ix.inspect        #=> "/ab+c/ix"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - rxp.match(str, pos=0)                   -> matchdata or nil
  #   - rxp.match(str, pos=0) {|match| block }  -> obj
  # -->
  # Returns a MatchData object describing the match, or `nil` if there was no
  # match. This is equivalent to retrieving the value of the special variable `$~`
  # following a normal match.  If the second parameter is present, it specifies
  # the position in the string to begin the search.
  #
  #     /(.)(.)(.)/.match("abc")[2]   #=> "b"
  #     /(.)(.)/.match("abc", 1)[2]   #=> "c"
  #
  # If a block is given, invoke the block with MatchData if match succeed, so that
  # you can write
  #
  #     /M(.*)/.match("Matz") do |m|
  #       puts m[0]
  #       puts m[1]
  #     end
  #
  # instead of
  #
  #     if m = /M(.*)/.match("Matz")
  #       puts m[0]
  #       puts m[1]
  #     end
  #
  # The return value is a value from block execution in this case.
  #
  def match: (String? | Symbol | _ToStr str, ?Integer pos) -> MatchData?
           | [T] (String? | Symbol | _ToStr str, ?Integer pos) { (MatchData) -> T } -> T?

  # <!--
  #   rdoc-file=re.c
  #   - rxp.match?(str)          -> true or false
  #   - rxp.match?(str, pos=0)   -> true or false
  # -->
  # Returns `true` or `false` to indicate whether the regexp is matched or not
  # without updating $~ and other related variables. If the second parameter is
  # present, it specifies the position in the string to begin the search.
  #
  #     /R.../.match?("Ruby")    #=> true
  #     /R.../.match?("Ruby", 1) #=> false
  #     /P.../.match?("Ruby")    #=> false
  #     $&                       #=> nil
  #
  def match?: (String? | Symbol | _ToStr str, ?Integer pos) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.named_captures  -> hash
  # -->
  # Returns a hash representing information about named captures of *rxp*.
  #
  # A key of the hash is a name of the named captures. A value of the hash is an
  # array which is list of indexes of corresponding named captures.
  #
  #     /(?<foo>.)(?<bar>.)/.named_captures
  #     #=> {"foo"=>[1], "bar"=>[2]}
  #
  #     /(?<foo>.)(?<foo>.)/.named_captures
  #     #=> {"foo"=>[1, 2]}
  #
  # If there are no named captures, an empty hash is returned.
  #
  #     /(.)(.)/.named_captures
  #     #=> {}
  #
  def named_captures: () -> ::Hash[String, ::Array[Integer]]

  # <!--
  #   rdoc-file=re.c
  #   - rxp.names   -> [name1, name2, ...]
  # -->
  # Returns a list of names of captures as an array of strings.
  #
  #     /(?<foo>.)(?<bar>.)(?<baz>.)/.names
  #     #=> ["foo", "bar", "baz"]
  #
  #     /(?<foo>.)(?<foo>.)/.names
  #     #=> ["foo"]
  #
  #     /(.)(.)/.names
  #     #=> []
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - rxp.options   -> integer
  # -->
  # Returns the set of bits corresponding to the options used when creating this
  # Regexp (see Regexp::new for details. Note that additional bits may be set in
  # the returned options: these are used internally by the regular expression
  # code. These extra bits are ignored if the options are passed to Regexp::new.
  #
  #     Regexp::IGNORECASE                  #=> 1
  #     Regexp::EXTENDED                    #=> 2
  #     Regexp::MULTILINE                   #=> 4
  #
  #     /cat/.options                       #=> 0
  #     /cat/ix.options                     #=> 3
  #     Regexp.new('cat', true).options     #=> 1
  #     /\xa1\xa2/e.options                 #=> 16
  #
  #     r = /cat/ix
  #     Regexp.new(r.source, r.options)     #=> /cat/ix
  #
  def options: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - rxp.source   -> str
  # -->
  # Returns the original string of the pattern.
  #
  #     /ab+c/ix.source #=> "ab+c"
  #
  # Note that escape sequences are retained as is.
  #
  #     /\x20\+/.source  #=> "\\x20\\+"
  #
  def source: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - rxp.to_s   -> str
  # -->
  # Returns a string containing the regular expression and its options (using the
  # `(?opts:source)` notation. This string can be fed back in to Regexp::new to a
  # regular expression with the same semantics as the original. (However,
  # `Regexp#==` may not return true when comparing the two, as the source of the
  # regular expression itself may differ, as the example shows).  Regexp#inspect
  # produces a generally more readable version of *rxp*.
  #
  #     r1 = /ab+c/ix           #=> /ab+c/ix
  #     s1 = r1.to_s            #=> "(?ix-m:ab+c)"
  #     r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/
  #     r1 == r2                #=> false
  #     r1.source               #=> "ab+c"
  #     r2.source               #=> "(?ix-m:ab+c)"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - ~ rxp   -> integer or nil
  # -->
  # Match---Matches *rxp* against the contents of `$_`. Equivalent to *`rxp* =~
  # $_`.
  #
  #     $_ = "input data"
  #     ~ /at/   #=> 7
  #
  def ~: () -> Integer?

  private

  def initialize_copy: (self object) -> self
end

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::EXTENDED: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::FIXEDENCODING: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::IGNORECASE: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::MULTILINE: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::NOENCODING: Integer

# <!-- rdoc-file=object.c -->
# Object is the default root of all Ruby objects.  Object inherits from
# BasicObject which allows creating alternate object hierarchies.  Methods on
# Object are available to all classes unless explicitly overridden.
#
# Object mixes in the Kernel module, making the built-in kernel functions
# globally accessible.  Although the instance methods of Object are defined by
# the Kernel module, we have chosen to document them here for clarity.
#
# When referencing constants in classes inheriting from Object you do not need
# to use the full namespace.  For example, referencing `File` inside `YourClass`
# will find the top-level File class.
#
# In the descriptions of Object's methods, the parameter *symbol* refers to a
# symbol, which is either a quoted string or a Symbol (such as `:name`).
#
# ## What's Here
#
# First, what's elsewhere. Class Object:
#
# *   Inherits from [class
#     BasicObject](BasicObject.html#class-BasicObject-label-What-27s+Here).
# *   Includes [module Kernel](Kernel.html#module-Kernel-label-What-27s+Here).
#
#
# Here, class Object provides methods for:
#
# *   [Querying](#class-Object-label-Querying)
# *   [Instance Variables](#class-Object-label-Instance+Variables)
# *   [Other](#class-Object-label-Other)
#
#
# ### Querying
#
#     [!~](#method-i-21~)
# :       Returns `true` if `self` does not match the given object, otherwise
#         `false`.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns 0 if `self` and the given object `object` are the same object,
#         or if `self == object`; otherwise returns `nil`.
#
#     #===
# :       Implements case equality, effectively the same as calling #==.
#
#     #eql?
# :       Implements hash equality, effectively the same as calling #==.
#
#     #kind_of? (aliased as #is_a?)
# :       Returns whether given argument is an ancestor of the singleton class
#         of `self`.
#
#     #instance_of?
# :       Returns whether `self` is an instance of the given class.
#
#     #instance_variable_defined?
# :       Returns whether the given instance variable is defined in `self`.
#
#     #method
# :       Returns the Method object for the given method in `self`.
#
#     #methods
# :       Returns an array of symbol names of public and protected methods in
#         `self`.
#
#     #nil?
# :       Returns `false`. (Only `nil` responds `true` to method `nil?`.)
#
#     #object_id
# :       Returns an integer corresponding to `self` that is unique for the
#         current process
#
#     #private_methods
# :       Returns an array of the symbol names of the private methods in `self`.
#
#     #protected_methods
# :       Returns an array of the symbol names of the protected methods in
#         `self`.
#
#     #public_method
# :       Returns the Method object for the given public method in `self`.
#
#     #public_methods
# :       Returns an array of the symbol names of the public methods in `self`.
#
#     #respond_to?
# :       Returns whether `self` responds to the given method.
#
#     #singleton_class
# :       Returns the singleton class of `self`.
#
#     #singleton_method
# :       Returns the Method object for the given singleton method in `self`.
#
#     #singleton_methods
# :       Returns an array of the symbol names of the singleton methods in
#         `self`.
#
#
#     #define_singleton_method
# :       Defines a singleton method in `self` for the given symbol method-name
#         and block or proc.
#
#     #extend
# :       Includes the given modules in the singleton class of `self`.
#
#     #public_send
# :       Calls the given public method in `self` with the given argument.
#
#     #send
# :       Calls the given method in `self` with the given argument.
#
#
#
# ### Instance Variables
#
#     #instance_variable_get
# :       Returns the value of the given instance variable in `self`, or `nil`
#         if the instance variable is not set.
#
#     #instance_variable_set
# :       Sets the value of the given instance variable in `self` to the given
#         object.
#
#     #instance_variables
# :       Returns an array of the symbol names of the instance variables in
#         `self`.
#
#     #remove_instance_variable
# :       Removes the named instance variable from `self`.
#
#
#
# ### Other
#
#     #clone
# :       Returns a shallow copy of `self`, including singleton class and frozen
#         state.
#
#     #define_singleton_method
# :       Defines a singleton method in `self` for the given symbol method-name
#         and block or proc.
#
#     #display
# :       Prints `self` to the given IO stream or `$stdout`.
#
#     #dup
# :       Returns a shallow unfrozen copy of `self`.
#
#     #enum_for (aliased as #to_enum)
# :       Returns an Enumerator for `self` using the using the given method,
#         arguments, and block.
#
#     #extend
# :       Includes the given modules in the singleton class of `self`.
#
#     #freeze
# :       Prevents further modifications to `self`.
#
#     #hash
# :       Returns the integer hash value for `self`.
#
#     #inspect
# :       Returns a human-readable  string representation of `self`.
#
#     #itself
# :       Returns `self`.
#
#     #public_send
# :       Calls the given public method in `self` with the given argument.
#
#     #send
# :       Calls the given method in `self` with the given argument.
#
#     #to_s
# :       Returns a string representation of `self`.
#
class Object < BasicObject
  include Kernel

  # <!--
  #   rdoc-file=object.c
  #   - obj !~ other  -> true or false
  # -->
  # Returns true if two objects do not match (using the *=~* method), otherwise
  # false.
  #
  def !~: (untyped) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj <=> other -> 0 or nil
  # -->
  # Returns 0 if `obj` and `other` are the same object or `obj == other`,
  # otherwise nil.
  #
  # The #<=> is used by various methods to compare objects, for example
  # Enumerable#sort, Enumerable#max etc.
  #
  # Your implementation of #<=> should return one of the following values: -1, 0,
  # 1 or nil. -1 means self is smaller than other. 0 means self is equal to other.
  # 1 means self is bigger than other. Nil means the two values could not be
  # compared.
  #
  # When you define #<=>, you can include Comparable to gain the methods #<=, #<,
  # #==, #>=, #> and #between?.
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj =~ other  -> nil
  # -->
  # This method is deprecated.
  #
  # This is not only useless but also troublesome because it may hide a type
  # error.
  #
  def =~: (untyped) -> bool

  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as `class` is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> untyped

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `clone` copies the frozen (unless :freeze
  # keyword argument is given with a false value) and tainted state of *obj*. See
  # also the discussion under `Object#dup`.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool?) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - define_singleton_method(symbol, method) -> symbol
  #   - define_singleton_method(symbol) { block } -> symbol
  # -->
  # Defines a singleton method in the receiver. The *method* parameter can be a
  # `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
  # is used as the method body. If a block or a method has parameters, they're
  # used as method parameters.
  #
  #     class A
  #       class << self
  #         def class_name
  #           to_s
  #         end
  #       end
  #     end
  #     A.define_singleton_method(:who_am_i) do
  #       "I am: #{class_name}"
  #     end
  #     A.who_am_i   # ==> "I am: A"
  #
  #     guy = "Bob"
  #     guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
  #     guy.hello    #=>  "Bob: Hello there!"
  #
  #     chris = "Chris"
  #     chris.define_singleton_method(:greet) {|greeting| "#{greeting}, I'm Chris!" }
  #     chris.greet("Hi") #=> "Hi, I'm Chris!"
  #
  def define_singleton_method: (Symbol, Method | UnboundMethod) -> Symbol
                             | (Symbol) { (*untyped) -> untyped } -> Symbol

  # <!--
  #   rdoc-file=io.c
  #   - obj.display(port=$>)    -> nil
  # -->
  # Prints *obj* on the given port (default `$>`). Equivalent to:
  #
  #     def display(port=$>)
  #       port.write self
  #       nil
  #     end
  #
  # For example:
  #
  #     1.display
  #     "cat".display
  #     [ 4, 5, 6 ].display
  #     puts
  #
  # *produces:*
  #
  #     1cat[4, 5, 6]
  #
  def display: (?_Writeable port) -> void

  # <!--
  #   rdoc-file=object.c
  #   - obj.dup -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, #clone and #dup may have different semantics in descendant
  # classes. While #clone is used to duplicate an object, including its internal
  # state, #dup typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401be280>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401c1084>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401c1084>
  #
  def dup: () -> self

  # <!-- rdoc-file=enumerator.c -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  def enum_for: (Symbol method, *untyped args) ?{ (*untyped args) -> Integer } -> Enumerator[untyped, untyped]
              | () ?{ () -> Integer } -> Enumerator[untyped, self]

  # <!--
  #   rdoc-file=enumerator.c
  #   - obj.to_enum(method = :each, *args)                 -> enum
  #   - obj.enum_for(method = :each, *args)                -> enum
  #   - obj.to_enum(method = :each, *args) {|*args| block} -> enum
  #   - obj.enum_for(method = :each, *args){|*args| block} -> enum
  # -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  alias to_enum enum_for

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - obj.extend(module, ...)    -> obj
  # -->
  # Adds to *obj* the instance methods from each module given as a parameter.
  #
  #     module Mod
  #       def hello
  #         "Hello from Mod.\n"
  #       end
  #     end
  #
  #     class Klass
  #       def hello
  #         "Hello from Klass.\n"
  #       end
  #     end
  #
  #     k = Klass.new
  #     k.hello         #=> "Hello from Klass.\n"
  #     k.extend(Mod)   #=> #<Klass:0x401b3bc8>
  #     k.hello         #=> "Hello from Mod.\n"
  #
  def extend: (*Module) -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.freeze    -> obj
  # -->
  # Prevents further modifications to *obj*. A FrozenError will be raised if
  # modification is attempted. There is no way to unfreeze a frozen object. See
  # also Object#frozen?.
  #
  # This method returns self.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze
  #     a << "z"
  #
  # *produces:*
  #
  #     prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
  #      from prog.rb:3
  #
  # Objects of the following classes are always frozen: Integer, Float, Symbol.
  #
  def freeze: () -> self

  # Returns the freeze status of *obj*.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze    #=> ["a", "b", "c"]
  #     a.frozen?   #=> true
  #
  def frozen?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.hash    -> integer
  # -->
  # Generates an Integer hash value for this object.  This function must have the
  # property that `a.eql?(b)` implies `a.hash == b.hash`.
  #
  # The hash value is used along with #eql? by the Hash class to determine if two
  # objects reference the same hash key.  Any hash value that exceeds the capacity
  # of an Integer will be truncated before being used.
  #
  # The hash value for an object may not be identical across invocations or
  # implementations of Ruby.  If you need a stable identifier across Ruby
  # invocations and implementations you will need to generate one with a custom
  # method.
  #
  # Certain core classes such as Integer use built-in hash calculations and do not
  # call the #hash method when used as a hash key.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.inspect   -> string
  # -->
  # Returns a string containing a human-readable representation of *obj*. The
  # default #inspect shows the object's class name, an encoding of its memory
  # address, and a list of the instance variables and their values (by calling
  # #inspect on each of them).  User defined classes should override this method
  # to provide a better representation of *obj*.  When overriding this method, it
  # should return a string whose encoding is compatible with the default external
  # encoding.
  #
  #     [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
  #     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
  #
  #     class Foo
  #     end
  #     Foo.new.inspect                  #=> "#<Foo:0x0300c868>"
  #
  #     class Bar
  #       def initialize
  #         @bar = 1
  #       end
  #     end
  #     Bar.new.inspect                  #=> "#<Bar:0x0300c868 @bar=1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_of?(class)    -> true or false
  # -->
  # Returns `true` if *obj* is an instance of the given class. See also
  # Object#kind_of?.
  #
  #     class A;     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.instance_of? A   #=> false
  #     b.instance_of? B   #=> true
  #     b.instance_of? C   #=> false
  #
  def instance_of?: (Module) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_defined?(symbol)    -> true or false
  #   - obj.instance_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given instance variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_defined?(:@a)    #=> true
  #     fred.instance_variable_defined?("@b")   #=> true
  #     fred.instance_variable_defined?("@c")   #=> false
  #
  def instance_variable_defined?: (String | Symbol var) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_get(symbol)    -> obj
  #   - obj.instance_variable_get(string)    -> obj
  # -->
  # Returns the value of the given instance variable, or nil if the instance
  # variable is not set. The `@` part of the variable name should be included for
  # regular instance variables. Throws a NameError exception if the supplied
  # symbol is not valid as an instance variable name. String arguments are
  # converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_get(:@a)    #=> "cat"
  #     fred.instance_variable_get("@b")   #=> 99
  #
  def instance_variable_get: (String | Symbol var) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_set(symbol, obj)    -> obj
  #   - obj.instance_variable_set(string, obj)    -> obj
  # -->
  # Sets the instance variable named by *symbol* to the given object. This may
  # circumvent the encapsulation intended by the author of the class, so it should
  # be used with care. The variable does not have to exist prior to this call. If
  # the instance variable name is passed as a string, that string is converted to
  # a symbol.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_set(:@a, 'dog')   #=> "dog"
  #     fred.instance_variable_set(:@c, 'cat')   #=> "cat"
  #     fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"
  #
  def instance_variable_set: [X] (String | Symbol var, X value) -> X

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variables    -> array
  # -->
  # Returns an array of instance variable names for the receiver. Note that simply
  # defining an accessor does not create the corresponding instance variable.
  #
  #     class Fred
  #       attr_accessor :a1
  #       def initialize
  #         @iv = 3
  #       end
  #     end
  #     Fred.new.instance_variables   #=> [:@iv]
  #
  def instance_variables: () -> Array[Symbol]

  # <!-- rdoc-file=object.c -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  def is_a?: (Module) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.is_a?(class)       -> true or false
  #   - obj.kind_of?(class)    -> true or false
  # -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  alias kind_of? is_a?

  # <!--
  #   rdoc-file=object.c
  #   - obj.itself    -> obj
  # -->
  # Returns the receiver.
  #
  #     string = "my string"
  #     string.itself.object_id == string.object_id   #=> true
  #
  def itself: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - obj.method(sym)    -> method
  # -->
  # Looks up the named method as a receiver in *obj*, returning a Method object
  # (or raising NameError). The Method object acts as a closure in *obj*'s object
  # instance, so instance variables and the value of `self` remain available.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     m = k.method(:hello)
  #     m.call   #=> "Hello, @iv = 99"
  #
  #     l = Demo.new('Fred')
  #     m = l.method("hello")
  #     m.call   #=> "Hello, @iv = Fred"
  #
  # Note that Method implements `to_proc` method, which means it can be used with
  # iterators.
  #
  #     [ 1, 2, 3 ].each(&method(:puts)) # => prints 3 lines to stdout
  #
  #     out = File.open('test.txt', 'w')
  #     [ 1, 2, 3 ].each(&out.method(:puts)) # => prints 3 lines to file
  #
  #     require 'date'
  #     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
  #     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
  #
  def method: (String | Symbol name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.methods(regular=true)    -> array
  # -->
  # Returns a list of the names of public and protected methods of *obj*. This
  # will include all the methods accessible in *obj*'s ancestors. If the optional
  # parameter is `false`, it returns an array of *obj*'s public and protected
  # singleton methods, the array will not include methods in modules included in
  # *obj*.
  #
  #     class Klass
  #       def klass_method()
  #       end
  #     end
  #     k = Klass.new
  #     k.methods[0..9]    #=> [:klass_method, :nil?, :===,
  #                        #    :==~, :!, :eql?
  #                        #    :hash, :<=>, :class, :singleton_class]
  #     k.methods.length   #=> 56
  #
  #     k.methods(false)   #=> []
  #     def k.singleton_method; end
  #     k.methods(false)   #=> [:singleton_method]
  #
  #     module M123; def m123; end end
  #     k.extend M123
  #     k.methods(false)   #=> [:singleton_method]
  #
  def methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.nil?               -> true or false
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  #     Object.new.nil?   #=> false
  #     nil.nil?          #=> true
  #
  def nil?: () -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  def object_id: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.private_methods(all=true)   -> array
  # -->
  # Returns the list of private methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def private_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.protected_methods(all=true)   -> array
  # -->
  # Returns the list of protected methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def protected_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - obj.public_method(sym)    -> method
  # -->
  # Similar to *method*, searches public method only.
  #
  def public_method: (name name) -> Method

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.public_send(symbol [, args...])  -> obj
  #   - obj.public_send(string [, args...])  -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # Unlike send, public_send calls public methods only. When the method is
  # identified by a string, the string is converted to a symbol.
  #
  #     1.public_send(:puts, "hello")  # causes NoMethodError
  #
  def public_send: (name name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.remove_instance_variable(symbol)    -> obj
  #   - obj.remove_instance_variable(string)    -> obj
  # -->
  # Removes the named instance variable from *obj*, returning that variable's
  # value. String arguments are converted to symbols.
  #
  #     class Dummy
  #       attr_reader :var
  #       def initialize
  #         @var = 99
  #       end
  #       def remove
  #         remove_instance_variable(:@var)
  #       end
  #     end
  #     d = Dummy.new
  #     d.var      #=> 99
  #     d.remove   #=> 99
  #     d.var      #=> nil
  #
  def remove_instance_variable: (name name) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to?(symbol, include_all=false) -> true or false
  #   - obj.respond_to?(string, include_all=false) -> true or false
  # -->
  # Returns `true` if *obj* responds to the given method.  Private and protected
  # methods are included in the search only if the optional second parameter
  # evaluates to `true`.
  #
  # If the method is not implemented, as Process.fork on Windows, File.lchmod on
  # GNU/Linux, etc., false is returned.
  #
  # If the method is not defined, `respond_to_missing?` method is called and the
  # result is returned.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  def respond_to?: (name name, ?boolish include_all) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  def send: (name name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_class    -> class
  # -->
  # Returns the singleton class of *obj*.  This method creates a new singleton
  # class if *obj* does not have one.
  #
  # If *obj* is `nil`, `true`, or `false`, it returns NilClass, TrueClass, or
  # FalseClass, respectively. If *obj* is an Integer, a Float or a Symbol, it
  # raises a TypeError.
  #
  #     Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
  #     String.singleton_class      #=> #<Class:String>
  #     nil.singleton_class         #=> NilClass
  #
  def singleton_class: () -> Class

  # <!--
  #   rdoc-file=proc.c
  #   - obj.singleton_method(sym)    -> method
  # -->
  # Similar to *method*, searches singleton method only.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     def k.hi
  #       "Hi, @iv = #{@iv}"
  #     end
  #     m = k.singleton_method(:hi)
  #     m.call   #=> "Hi, @iv = 99"
  #     m = k.singleton_method(:hello) #=> NameError
  #
  def singleton_method: (name name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_methods(all=true)    -> array
  # -->
  # Returns an array of the names of singleton methods for *obj*. If the optional
  # *all* parameter is true, the list will include methods in modules included in
  # *obj*. Only public and protected singleton methods are returned.
  #
  #     module Other
  #       def three() end
  #     end
  #
  #     class Single
  #       def Single.four() end
  #     end
  #
  #     a = Single.new
  #
  #     def a.one()
  #     end
  #
  #     class << a
  #       include Other
  #       def two()
  #       end
  #     end
  #
  #     Single.singleton_methods    #=> [:four]
  #     a.singleton_methods(false)  #=> [:two, :one]
  #     a.singleton_methods         #=> [:two, :one, :three]
  #
  def singleton_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.taint -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  def taint: () -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.untrust -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  alias untrust taint

  # <!--
  #   rdoc-file=object.c
  #   - obj.tainted?    -> false
  # -->
  # Returns false.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def tainted?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.untrusted?    -> false
  # -->
  # Returns false.  This method is deprecated and will be removed in Ruby 3.2.
  #
  alias untrusted? tainted?

  # Yields self to the block, and then returns self. The primary purpose of this
  # method is to "tap into" a method chain, in order to perform operations on
  # intermediate results within the chain.
  #
  #     (1..10)                  .tap {|x| puts "original: #{x}" }
  #       .to_a                  .tap {|x| puts "array:    #{x}" }
  #       .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
  #       .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }
  #
  def tap: () { (self) -> void } -> self

  # Yields self to the block and returns the result of the block.
  #
  #     3.next.then {|x| x**x }.to_s             #=> "256"
  #     "my string".yield_self {|s| s.upcase }   #=> "MY STRING"
  #
  # Good usage for `yield_self` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments).
  #       yield_self {|url| open(url).read }.
  #       yield_self {|response| JSON.parse(response) }
  #
  # When called without block, the method returns `Enumerator`, which can be used,
  # for example, for conditional circuit-breaking:
  #
  #     # meets condition, no-op
  #     1.yield_self.detect(&:odd?)            # => 1
  #     # does not meet condition, drop value
  #     2.yield_self.detect(&:odd?)            # => nil
  #
  def yield_self: [X] () { (self) -> X } -> X
                | () -> Enumerator[self, untyped]

  # <!--
  #   rdoc-file=object.c
  #   - obj.to_s    -> string
  # -->
  # Returns a string representing *obj*. The default #to_s prints the object's
  # class and an encoding of the object id. As a special case, the top-level
  # object that is the initial execution context of Ruby programs returns
  # ``main''.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.untaint    -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  def untaint: () -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.trust    -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  alias trust untaint

  # Yields self to the block and returns the result of the block.
  #
  #     3.next.then {|x| x**x }.to_s             #=> "256"
  #     "my string".yield_self {|s| s.upcase }   #=> "MY STRING"
  #
  # Good usage for `yield_self` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments).
  #       yield_self {|url| open(url).read }.
  #       yield_self {|response| JSON.parse(response) }
  #
  # When called without block, the method returns `Enumerator`, which can be used,
  # for example, for conditional circuit-breaking:
  #
  #     # meets condition, no-op
  #     1.yield_self.detect(&:odd?)            # => 1
  #     # does not meet condition, drop value
  #     2.yield_self.detect(&:odd?)            # => nil
  #
  alias then yield_self
end

interface _Writeable
  def write: (untyped) -> void
end

type Object::name = Symbol | String

# <!-- rdoc-file=re.c -->
# MatchData encapsulates the result of matching a Regexp against string. It is
# returned by Regexp#match and String#match, and also stored in a global
# variable returned by Regexp.last_match.
#
# Usage:
#
#     url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
#     m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
#     m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
#     m.regexp                    # => /(\d\.?)+/
#     # entire matched substring:
#     m[0]                        # => "2.5.0"
#
#     # Working with unnamed captures
#     m = url.match(%r{([^/]+)/([^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
#     # Working with named captures
#     m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
#     m[:version]                 # => "2.5.0"
#     m.values_at(:version, :module)
#                                 # => ["2.5.0", "MatchData"]
#     # Numerical indexes are working, too
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
# ## Global variables equivalence
#
# Parts of last MatchData (returned by Regexp.last_match) are also aliased as
# global variables:
#
# *   `$~` is Regexp.last_match;
# *   `$&` is Regexp.last_match`[ 0 ]`;
# *   `$1`, `$2`, and so on are Regexp.last_match`[ i ]` (captures by number);
# *   `$`` is Regexp.last_match`.pre_match`;
# *   `$'` is Regexp.last_match`.post_match`;
# *   `$+` is Regexp.last_match`[ -1 ]` (the last capture).
#
#
# See also "Special global variables" section in Regexp documentation.
#
class MatchData
  public

  # <!-- rdoc-file=re.c -->
  # Equality---Two matchdata are equal if their target strings, patterns, and
  # matched positions are identical.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - mtch[i]               -> str or nil
  #   - mtch[start, length]   -> array
  #   - mtch[range]           -> array
  #   - mtch[name]            -> str or nil
  # -->
  # Match Reference -- MatchData acts as an array, and may be accessed using the
  # normal array indexing techniques.  `mtch[0]` is equivalent to the special
  # variable `$&`, and returns the entire matched string.  `mtch[1]`, `mtch[2]`,
  # and so on return the values of the matched backreferences (portions of the
  # pattern between parentheses).
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m          #=> #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       #=> "HX1138"
  #     m[1, 2]    #=> ["H", "X"]
  #     m[1..3]    #=> ["H", "X", "113"]
  #     m[-3, 2]   #=> ["X", "113"]
  #
  #     m = /(?<foo>a+)b/.match("ccaaab")
  #     m          #=> #<MatchData "aaab" foo:"aaa">
  #     m["foo"]   #=> "aaa"
  #     m[:foo]    #=> "aaa"
  #
  def []: (Integer idx) -> String?
        | (Integer start, Integer length) -> ::Array[String?]
        | (::Range[Integer] range) -> ::Array[String?]
        | (String | Symbol name) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.begin(n)   -> integer
  # -->
  # Returns the offset of the start of the *n*th element of the match array in the
  # string. *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.begin(0)       #=> 1
  #     m.begin(2)       #=> 2
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.begin(:foo)  #=> 0
  #     p m.begin(:bar)  #=> 2
  #
  def begin: (Integer | String | Symbol n_or_name) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.captures   -> array
  # -->
  # Returns the array of captures; equivalent to `mtch.to_a[1..-1]`.
  #
  #     f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures
  #     f1    #=> "H"
  #     f2    #=> "X"
  #     f3    #=> "113"
  #     f4    #=> "8"
  #
  def captures: () -> ::Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.end(n)   -> integer
  # -->
  # Returns the offset of the character immediately following the end of the *n*th
  # element of the match array in the string. *n* can be a string or symbol to
  # reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.end(0)         #=> 7
  #     m.end(2)         #=> 3
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.end(:foo)    #=> 1
  #     p m.end(:bar)    #=> 3
  #
  def end: (Integer | String | Symbol n_or_name) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch == mtch2   -> true or false
  #   - mtch.eql?(mtch2)   -> true or false
  # -->
  # Equality---Two matchdata are equal if their target strings, patterns, and
  # matched positions are identical.
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - mtch.hash   -> integer
  # -->
  # Produce a hash based on the target string, regexp and matched positions of
  # this matchdata.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.inspect   -> str
  # -->
  # Returns a printable version of *mtch*.
  #
  #     puts /.$/.match("foo").inspect
  #     #=> #<MatchData "o">
  #
  #     puts /(.)(.)(.)/.match("foo").inspect
  #     #=> #<MatchData "foo" 1:"f" 2:"o" 3:"o">
  #
  #     puts /(.)(.)?(.)/.match("fo").inspect
  #     #=> #<MatchData "fo" 1:"f" 2:nil 3:"o">
  #
  #     puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").inspect
  #     #=> #<MatchData "hog" foo:"h" bar:"o" baz:"g">
  #
  def inspect: () -> String

  # <!-- rdoc-file=re.c -->
  # Returns the number of elements in the match array.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.length   #=> 5
  #     m.size     #=> 5
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.named_captures -> hash
  # -->
  # Returns a Hash using named capture.
  #
  # A key of the hash is a name of the named captures. A value of the hash is a
  # string of last successful capture of corresponding group.
  #
  #     m = /(?<a>.)(?<b>.)/.match("01")
  #     m.named_captures #=> {"a" => "0", "b" => "1"}
  #
  #     m = /(?<a>.)(?<b>.)?/.match("0")
  #     m.named_captures #=> {"a" => "0", "b" => nil}
  #
  #     m = /(?<a>.)(?<a>.)/.match("01")
  #     m.named_captures #=> {"a" => "1"}
  #
  #     m = /(?<a>x)|(?<a>y)/.match("x")
  #     m.named_captures #=> {"a" => "x"}
  #
  def named_captures: () -> ::Hash[String, String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.names   -> [name1, name2, ...]
  # -->
  # Returns a list of names of captures as an array of strings. This is the same
  # as mtch.regexp.names.
  #
  #     /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").names
  #     #=> ["foo", "bar", "baz"]
  #
  #     m = /(?<x>.)(?<y>.)?/.match("a") #=> #<MatchData "a" x:"a" y:nil>
  #     m.names                          #=> ["x", "y"]
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.match(n)   -> string or nil
  # -->
  # Returns the captured substring corresponding to the argument. *n* can be a
  # string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     m.match(0)       #=> "HX1138"
  #     m.match(4)       #=> "8"
  #     m.match(5)       #=> nil
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     m.match(:foo)    #=> "h"
  #     m.match(:bar)    #=> "ge"
  #
  def match: (int | String | Symbol) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.match_length(n)   -> array
  # -->
  # Returns the length of the captured substring corresponding to the argument.
  # *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     m.match_length(0)       #=> 6
  #     m.match_length(4)       #=> 1
  #     m.match_length(5)       #=> nil
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     m.match_length(:foo)    #=> 1
  #     m.match_length(:bar)    #=> 2
  #
  def match_length: (int | String | Symbol) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.offset(n)   -> array
  # -->
  # Returns a two-element array containing the beginning and ending offsets of the
  # *n*th match. *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.offset(0)      #=> [1, 7]
  #     m.offset(4)      #=> [6, 7]
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.offset(:foo) #=> [0, 1]
  #     p m.offset(:bar) #=> [2, 3]
  #
  def offset: (Integer | Symbol | String n_or_name) -> ([ Integer, Integer ] | [ nil, nil ])

  # <!--
  #   rdoc-file=re.c
  #   - mtch.post_match   -> str
  # -->
  # Returns the portion of the original string after the current match. Equivalent
  # to the special variable `$'`.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     m.post_match   #=> ": The Movie"
  #
  def post_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.pre_match   -> str
  # -->
  # Returns the portion of the original string before the current match.
  # Equivalent to the special variable `$``.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.pre_match   #=> "T"
  #
  def pre_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.regexp   -> regexp
  # -->
  # Returns the regexp.
  #
  #     m = /a.*b/.match("abc")
  #     m.regexp #=> /a.*b/
  #
  def regexp: () -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - mtch.length   -> integer
  #   - mtch.size     -> integer
  # -->
  # Returns the number of elements in the match array.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.length   #=> 5
  #     m.size     #=> 5
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.string   -> str
  # -->
  # Returns a frozen copy of the string passed in to `match`.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.string   #=> "THX1138."
  #
  def string: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.to_a   -> anArray
  # -->
  # Returns the array of matches.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.to_a   #=> ["HX1138", "H", "X", "113", "8"]
  #
  # Because `to_a` is called when expanding `*`*variable*, there's a useful
  # assignment shortcut for extracting matched fields. This is slightly slower
  # than accessing the fields directly (as an intermediate array is generated).
  #
  #     all,f1,f2,f3 = * /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     all   #=> "HX1138"
  #     f1    #=> "H"
  #     f2    #=> "X"
  #     f3    #=> "113"
  #
  def to_a: () -> ::Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.to_s   -> str
  # -->
  # Returns the entire matched string.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.to_s   #=> "HX1138"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.values_at(index, ...)   -> array
  # -->
  # Uses each *index* to access the matching values, returning an array of the
  # corresponding matches.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     m.to_a               #=> ["HX1138", "H", "X", "113", "8"]
  #     m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]
  #     m.values_at(1..2, -1)   #=> ["H", "X", "8"]
  #
  #     m = /(?<a>\d+) *(?<op>[+\-*\/]) *(?<b>\d+)/.match("1 + 2")
  #     m.to_a               #=> ["1 + 2", "1", "+", "2"]
  #     m.values_at(:a, :b, :op) #=> ["1", "2", "+"]
  #
  def values_at: (*Integer | Symbol | String n_or_name) -> ::Array[String?]

  private

  def initialize_copy: (self object) -> void
end

# <!-- rdoc-file=io.c -->
# ARGF is a stream designed for use in scripts that process files given as
# command-line arguments or passed in via STDIN.
#
# See ARGF (the class) for more details.
#
::ARGF: Object

# <!-- rdoc-file=ruby.c -->
# ARGV contains the command line arguments used to run ruby.
#
# A library like OptionParser can be used to process command-line arguments.
#
::ARGV: Array[String]

::CROSS_COMPILING: NilClass

::FALSE: FalseClass

::NIL: NilClass

# <!-- rdoc-file=version.c -->
# The copyright string for ruby
#
::RUBY_COPYRIGHT: String

# <!-- rdoc-file=version.c -->
# The full ruby version string, like `ruby -v` prints
#
::RUBY_DESCRIPTION: String

# <!-- rdoc-file=version.c -->
# The engine or interpreter this ruby uses.
#
::RUBY_ENGINE: String

# <!-- rdoc-file=version.c -->
# The version of the engine or interpreter this ruby uses.
#
::RUBY_ENGINE_VERSION: String

# <!-- rdoc-file=version.c -->
# The patchlevel for this ruby.  If this is a development build of ruby the
# patchlevel will be -1
#
::RUBY_PATCHLEVEL: Integer

# <!-- rdoc-file=version.c -->
# The platform for this ruby
#
::RUBY_PLATFORM: String

# <!-- rdoc-file=version.c -->
# The date this ruby was released
#
::RUBY_RELEASE_DATE: String

# <!-- rdoc-file=version.c -->
# The GIT commit hash for this ruby.
#
::RUBY_REVISION: Integer

# <!-- rdoc-file=version.c -->
# The running version of ruby
#
::RUBY_VERSION: String

# <!-- rdoc-file=io.c -->
# Holds the original stderr
#
::STDERR: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdin
#
::STDIN: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdout
#
::STDOUT: IO

# <!-- rdoc-file=vm.c -->
# The Binding of the top level scope
#
::TOPLEVEL_BINDING: Binding

::TRUE: TrueClass

# <!-- rdoc-file=trace_point.rb -->
# Document-class: TracePoint
#
# A class that provides the functionality of Kernel#set_trace_func in a nice
# Object-Oriented API.
#
# ## Example
#
# We can use TracePoint to gather information specifically for exceptions:
#
#     trace = TracePoint.new(:raise) do |tp|
#         p [tp.lineno, tp.event, tp.raised_exception]
#     end
#     #=> #<TracePoint:disabled>
#
#     trace.enable
#     #=> false
#
#     0 / 0
#     #=> [5, :raise, #<ZeroDivisionError: divided by 0>]
#
# ## Events
#
# If you don't specify the type of events you want to listen for, TracePoint
# will include all available events.
#
# **Note** do not depend on current event set, as this list is subject to
# change. Instead, it is recommended you specify the type of events you want to
# use.
#
# To filter what is traced, you can pass any of the following as `events`:
#
# `:line`
# :   execute an expression or statement on a new line
# `:class`
# :   start a class or module definition
# `:end`
# :   finish a class or module definition
# `:call`
# :   call a Ruby method
# `:return`
# :   return from a Ruby method
# `:c_call`
# :   call a C-language routine
# `:c_return`
# :   return from a C-language routine
# `:raise`
# :   raise an exception
# `:b_call`
# :   event hook at block entry
# `:b_return`
# :   event hook at block ending
# `:a_call`
# :   event hook at all calls (`call`, `b_call`, and `c_call`)
# `:a_return`
# :   event hook at all returns (`return`, `b_return`, and `c_return`)
# `:thread_begin`
# :   event hook at thread beginning
# `:thread_end`
# :   event hook at thread ending
# `:fiber_switch`
# :   event hook at fiber switch
# `:script_compiled`
# :   new Ruby code compiled (with `eval`, `load` or `require`)
#
class TracePoint < Object
  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.new(*events) { |obj| block }         -> obj
  # -->
  # Returns a new TracePoint object, not enabled by default.
  #
  # Next, in order to activate the trace, you must use TracePoint#enable
  #
  #     trace = TracePoint.new(:call) do |tp|
  #         p [tp.lineno, tp.defined_class, tp.method_id, tp.event]
  #     end
  #     #=> #<TracePoint:disabled>
  #
  #     trace.enable
  #     #=> false
  #
  #     puts "Hello, TracePoint!"
  #     # ...
  #     # [48, IRB::Notifier::AbstractNotifier, :printf, :call]
  #     # ...
  #
  # When you want to deactivate the trace, you must use TracePoint#disable
  #
  #     trace.disable
  #
  # See TracePoint@Events for possible events and more information.
  #
  # A block must be given, otherwise an ArgumentError is raised.
  #
  # If the trace method isn't included in the given events filter, a RuntimeError
  # is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #         p tp.raised_exception
  #     end
  #     #=> RuntimeError: 'raised_exception' not supported by this event
  #
  # If the trace method is called outside block, a RuntimeError is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #       $tp = tp
  #     end
  #     $tp.lineno #=> access from outside (RuntimeError)
  #
  # Access from other threads is also forbidden.
  #
  def initialize: (*Symbol events) { (TracePoint tp) -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.allow_reentry
  # -->
  # In general, while a TracePoint callback is running, other registered callbacks
  # are not called to avoid confusion by reentrance. This method allows the
  # reentrance in a given block. This method should be used carefully, otherwise
  # the callback can be easily called infinitely.
  #
  # If this method is called when the reentrance is already allowed, it raises a
  # RuntimeError.
  #
  def self.allow_reentry: () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.stat -> obj
  # -->
  # Returns internal information of TracePoint.
  #
  # The contents of the returned value are implementation specific. It may be
  # changed in future.
  #
  # This method is only for debugging TracePoint itself.
  #
  def self.stat: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.trace(*events) { |obj| block }        -> obj
  # -->
  # A convenience method for TracePoint.new, that activates the trace
  # automatically.
  #
  #     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] }
  #     #=> #<TracePoint:enabled>
  #
  #     trace.enabled? #=> true
  #
  def self.trace: (*Symbol events) { (TracePoint tp) -> void } -> TracePoint

  # <!--
  #   rdoc-file=trace_point.rb
  #   - binding()
  # -->
  # Return the generated binding object from event.
  #
  # Note that for `c_call` and `c_return` events, the binding returned is the
  # binding of the nearest Ruby method calling the C method, since C methods
  # themselves do not have bindings.
  #
  def binding: () -> Binding

  # <!--
  #   rdoc-file=trace_point.rb
  #   - callee_id()
  # -->
  # Return the called name of the method being called
  #
  def callee_id: () -> Symbol

  # <!--
  #   rdoc-file=trace_point.rb
  #   - defined_class()
  # -->
  # Return class or module of the method being called.
  #
  #     class C; def foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> C
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # If method is defined by a module, then that module is returned.
  #
  #     module M; def foo; end; end
  #     class C; include M; end;
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> M
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # **Note:** #defined_class returns singleton class.
  #
  # 6th block parameter of Kernel#set_trace_func passes original class of attached
  # by singleton class.
  #
  # **This is a difference between Kernel#set_trace_func and TracePoint.**
  #
  #     class C; def self.foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> #<Class:C>
  #     end.enable do
  #       C.foo
  #     end
  #
  def defined_class: () -> Module

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.disable               -> true or false
  #   - trace.disable { block } -> obj
  # -->
  # Deactivates the trace
  #
  # Return true if trace was enabled. Return false if trace was disabled.
  #
  #     trace.enabled?      #=> true
  #     trace.disable       #=> true (previous status)
  #     trace.enabled?      #=> false
  #     trace.disable       #=> false
  #
  # If a block is given, the trace will only be disable within the scope of the
  # block.
  #
  #     trace.enabled?
  #     #=> true
  #
  #     trace.disable do
  #         trace.enabled?
  #         # only disabled for this block
  #     end
  #
  #     trace.enabled?
  #     #=> true
  #
  # Note: You cannot access event hooks within the block.
  #
  #     trace.disable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def disable: () -> bool
             | () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enable(target: nil, target_line: nil, target_thread: nil)    -> true or false
  #   - trace.enable(target: nil, target_line: nil, target_thread: nil) { block }  -> obj
  # -->
  # Activates the trace.
  #
  # Returns `true` if trace was enabled. Returns `false` if trace was disabled.
  #
  #     trace.enabled?  #=> false
  #     trace.enable    #=> false (previous state)
  #                     #   trace is enabled
  #     trace.enabled?  #=> true
  #     trace.enable    #=> true (previous state)
  #                     #   trace is still enabled
  #
  # If a block is given, the trace will only be enabled within the scope of the
  # block.
  #
  #     trace.enabled?
  #     #=> false
  #
  #     trace.enable do
  #       trace.enabled?
  #       # only enabled for this block
  #     end
  #
  #     trace.enabled?
  #     #=> false
  #
  # `target`, `target_line` and `target_thread` parameters are used to limit
  # tracing only to specified code objects. `target` should be a code object for
  # which RubyVM::InstructionSequence.of will return an instruction sequence.
  #
  #     t = TracePoint.new(:line) { |tp| p tp }
  #
  #     def m1
  #       p 1
  #     end
  #
  #     def m2
  #       p 2
  #     end
  #
  #     t.enable(target: method(:m1))
  #
  #     m1
  #     # prints #<TracePoint:line test.rb:4 in `m1'>
  #     m2
  #     # prints nothing
  #
  # Note: You cannot access event hooks within the `enable` block.
  #
  #     trace.enable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def enable: () -> bool
            | () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enabled?          -> true or false
  # -->
  # The current status of the trace
  #
  def enabled?: () -> bool

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.inspect  -> string
  # -->
  # Return a string containing a human-readable TracePoint status.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - lineno()
  # -->
  # Line number of the event
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=trace_point.rb
  #   - method_id()
  # -->
  # Return the name at the definition of the method being called
  #
  def method_id: () -> Symbol

  # <!--
  #   rdoc-file=trace_point.rb
  #   - path()
  # -->
  # Path of the file being run
  #
  def path: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - raised_exception()
  # -->
  # Value from exception raised on the `:raise` event
  #
  def raised_exception: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - return_value()
  # -->
  # Return value from `:return`, `c_return`, and `b_return` event
  #
  def return_value: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - self()
  # -->
  # Return the trace object during event
  #
  # Same as the following, except it returns the correct object (the method
  # receiver) for `c_call` and `c_return` events:
  #
  #     trace.binding.eval('self')
  #
  def self: () -> Binding
end

# <!-- rdoc-file=object.c -->
# The global value `true` is the only instance of class TrueClass and represents
# a logically true value in boolean expressions. The class provides operators
# allowing `true` to be used in logical expressions.
#
class TrueClass
  public

  def !: () -> false

  # <!--
  #   rdoc-file=object.c
  #   - true & obj    -> true or false
  # -->
  # And---Returns `false` if *obj* is `nil` or `false`, `true` otherwise.
  #
  def &: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (true) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - true ^ obj   -> !obj
  # -->
  # Exclusive Or---Returns `true` if *obj* is `nil` or `false`, `false` otherwise.
  #
  def ^: (nil) -> true
       | (false) -> true
       | (untyped obj) -> false

  # <!-- rdoc-file=object.c -->
  # The string representation of `true` is "true".
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - true.to_s   ->  "true"
  # -->
  # The string representation of `true` is "true".
  #
  def to_s: () -> "true"

  # <!--
  #   rdoc-file=object.c
  #   - true | obj   -> true
  # -->
  # Or---Returns `true`. As *obj* is an argument to a method call, it is always
  # evaluated; there is no short-circuit evaluation in this case.
  #
  #     true |  puts("or")
  #     true || puts("logical or")
  #
  # *produces:*
  #
  #     or
  #
  def |: (untyped obj) -> true

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=process.c -->
# The module contains several groups of functionality for handling OS processes:
#
# *   Low-level property introspection and management of the current process,
#     like Process.argv0, Process.pid;
# *   Low-level introspection of other processes, like Process.getpgid,
#     Process.getpriority;
# *   Management of the current process: Process.abort, Process.exit,
#     Process.daemon, etc. (for convenience, most of those are also available as
#     global functions and module functions of Kernel);
# *   Creation and management of child processes: Process.fork, Process.spawn,
#     and related methods;
# *   Management of low-level system clock: Process.times and
#     Process.clock_gettime, which could be important for proper benchmarking
#     and other elapsed time measurement tasks.
#
module Process
  # <!--
  #   rdoc-file=process.c
  #   - Process._fork   -> integer
  # -->
  # An internal API for fork. Do not call this method directly. Currently, this is
  # called via Kernel#fork, Process.fork, and IO.popen with `"-"`.
  #
  # This method is not for casual code but for application monitoring libraries.
  # You can add custom code before and after fork events by overriding this
  # method.
  #
  def self._fork: () -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.argv0  -> frozen_string
  # -->
  # Returns the name of the script being executed.  The value is not affected by
  # assigning a new value to $0.
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to get the script name.
  #
  def self.argv0: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_getres(clock_id [, unit])   -> number
  # -->
  # Returns an estimate of the resolution of a `clock_id` using the POSIX
  # `clock_getres()` function.
  #
  # Note the reported resolution is often inaccurate on most platforms due to
  # underlying bugs for this function and therefore the reported resolution often
  # differs from the actual resolution of the clock in practice. Inaccurate
  # reported resolutions have been observed for various clocks including
  # CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW when using Linux, macOS, BSD or AIX
  # platforms, when using ARM processors, or when using virtualization.
  #
  # `clock_id` specifies a kind of clock. See the document of
  # `Process.clock_gettime` for details. `clock_id` can be a symbol as for
  # `Process.clock_gettime`.
  #
  # If the given `clock_id` is not supported, Errno::EINVAL is raised.
  #
  # `unit` specifies the type of the return value. `Process.clock_getres` accepts
  # `unit` as `Process.clock_gettime`. The default value, `:float_second`, is also
  # the same as `Process.clock_gettime`.
  #
  # `Process.clock_getres` also accepts `:hertz` as `unit`. `:hertz` means the
  # reciprocal of `:float_second`.
  #
  # `:hertz` can be used to obtain the exact value of the clock ticks per second
  # for the times() function and CLOCKS_PER_SEC for the clock() function.
  #
  # `Process.clock_getres(:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
  # the clock ticks per second.
  #
  # `Process.clock_getres(:CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
  # CLOCKS_PER_SEC.
  #
  #     p Process.clock_getres(Process::CLOCK_MONOTONIC)
  #     #=> 1.0e-09
  #
  def self.clock_getres: (Symbol | Integer clock_id, ?Symbol unit) -> (Float | Integer)

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_gettime(clock_id [, unit])   -> number
  # -->
  # Returns a time returned by POSIX clock_gettime() function.
  #
  #     p Process.clock_gettime(Process::CLOCK_MONOTONIC)
  #     #=> 896053.968060096
  #
  # `clock_id` specifies a kind of clock. It is specified as a constant which
  # begins with `Process::CLOCK_` such as Process::CLOCK_REALTIME and
  # Process::CLOCK_MONOTONIC.
  #
  # The supported constants depends on OS and version. Ruby provides following
  # types of `clock_id` if available.
  #
  # CLOCK_REALTIME
  # :   SUSv2 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 2.1, macOS
  #     10.12, Windows-8/Server-2012
  # CLOCK_MONOTONIC
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 3.4, macOS
  #     10.12, Windows-2000
  # CLOCK_PROCESS_CPUTIME_ID
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 9.3, OpenBSD 5.4, macOS 10.12
  # CLOCK_THREAD_CPUTIME_ID
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 7.1, OpenBSD 5.4, macOS 10.12
  # CLOCK_VIRTUAL
  # :   FreeBSD 3.0, OpenBSD 2.1
  # CLOCK_PROF
  # :   FreeBSD 3.0, OpenBSD 2.1
  # CLOCK_REALTIME_FAST
  # :   FreeBSD 8.1
  # CLOCK_REALTIME_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_REALTIME_COARSE
  # :   Linux 2.6.32
  # CLOCK_REALTIME_ALARM
  # :   Linux 3.0
  # CLOCK_MONOTONIC_FAST
  # :   FreeBSD 8.1
  # CLOCK_MONOTONIC_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_MONOTONIC_COARSE
  # :   Linux 2.6.32
  # CLOCK_MONOTONIC_RAW
  # :   Linux 2.6.28, macOS 10.12
  # CLOCK_MONOTONIC_RAW_APPROX
  # :   macOS 10.12
  # CLOCK_BOOTTIME
  # :   Linux 2.6.39
  # CLOCK_BOOTTIME_ALARM
  # :   Linux 3.0
  # CLOCK_UPTIME
  # :   FreeBSD 7.0, OpenBSD 5.5
  # CLOCK_UPTIME_FAST
  # :   FreeBSD 8.1
  # CLOCK_UPTIME_RAW
  # :   macOS 10.12
  # CLOCK_UPTIME_RAW_APPROX
  # :   macOS 10.12
  # CLOCK_UPTIME_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_SECOND
  # :   FreeBSD 8.1
  # CLOCK_TAI
  # :   Linux 3.10
  #
  #
  # Note that SUS stands for Single Unix Specification. SUS contains POSIX and
  # clock_gettime is defined in the POSIX part. SUS defines CLOCK_REALTIME
  # mandatory but CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID and
  # CLOCK_THREAD_CPUTIME_ID are optional.
  #
  # Also, several symbols are accepted as `clock_id`. There are emulations for
  # clock_gettime().
  #
  # For example, Process::CLOCK_REALTIME is defined as
  # `:GETTIMEOFDAY_BASED_CLOCK_REALTIME` when clock_gettime() is not available.
  #
  # Emulations for `CLOCK_REALTIME`:
  # :GETTIMEOFDAY_BASED_CLOCK_REALTIME
  # :   Use gettimeofday() defined by SUS. (SUSv4 obsoleted it, though.) The
  #     resolution is 1 microsecond.
  # :TIME_BASED_CLOCK_REALTIME
  # :   Use time() defined by ISO C. The resolution is 1 second.
  #
  #
  # Emulations for `CLOCK_MONOTONIC`:
  # :MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC
  # :   Use mach_absolute_time(), available on Darwin. The resolution is CPU
  #     dependent.
  # :TIMES_BASED_CLOCK_MONOTONIC
  # :   Use the result value of times() defined by POSIX. POSIX defines it as
  #     "times() shall return the elapsed real time, in clock ticks, since an
  #     arbitrary point in the past (for example, system start-up time)". For
  #     example, GNU/Linux returns a value based on jiffies and it is monotonic.
  #     However, 4.4BSD uses gettimeofday() and it is not monotonic. (FreeBSD uses
  #     clock_gettime(CLOCK_MONOTONIC) instead, though.) The resolution is the
  #     clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
  #     (The clock ticks per second is defined by HZ macro in older systems.) If
  #     it is 100 and clock_t is 32 bits integer type, the resolution is 10
  #     millisecond and cannot represent over 497 days.
  #
  #
  # Emulations for `CLOCK_PROCESS_CPUTIME_ID`:
  # :GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use getrusage() defined by SUS. getrusage() is used with RUSAGE_SELF to
  #     obtain the time only for the calling process (excluding the time for child
  #     processes). The result is addition of user time (ru_utime) and system time
  #     (ru_stime). The resolution is 1 microsecond.
  # :TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use times() defined by POSIX. The result is addition of user time
  #     (tms_utime) and system time (tms_stime). tms_cutime and tms_cstime are
  #     ignored to exclude the time for child processes. The resolution is the
  #     clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
  #     (The clock ticks per second is defined by HZ macro in older systems.) If
  #     it is 100, the resolution is 10 millisecond.
  # :CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use clock() defined by ISO C. The resolution is 1/CLOCKS_PER_SEC.
  #     CLOCKS_PER_SEC is the C-level macro defined by time.h. SUS defines
  #     CLOCKS_PER_SEC is 1000000. Non-Unix systems may define it a different
  #     value, though. If CLOCKS_PER_SEC is 1000000 as SUS, the resolution is 1
  #     microsecond. If CLOCKS_PER_SEC is 1000000 and clock_t is 32 bits integer
  #     type, it cannot represent over 72 minutes.
  #
  #
  # If the given `clock_id` is not supported, Errno::EINVAL is raised.
  #
  # `unit` specifies a type of the return value.
  #
  # :float_second
  # :   number of seconds as a float (default)
  # :float_millisecond
  # :   number of milliseconds as a float
  # :float_microsecond
  # :   number of microseconds as a float
  # :second
  # :   number of seconds as an integer
  # :millisecond
  # :   number of milliseconds as an integer
  # :microsecond
  # :   number of microseconds as an integer
  # :nanosecond
  # :   number of nanoseconds as an integer
  #
  #
  # The underlying function, clock_gettime(), returns a number of nanoseconds.
  # Float object (IEEE 754 double) is not enough to represent the return value for
  # CLOCK_REALTIME. If the exact nanoseconds value is required, use `:nanoseconds`
  # as the `unit`.
  #
  # The origin (zero) of the returned value varies. For example, system start up
  # time, process start up time, the Epoch, etc.
  #
  # The origin in CLOCK_REALTIME is defined as the Epoch (1970-01-01 00:00:00
  # UTC). But some systems count leap seconds and others doesn't. So the result
  # can be interpreted differently across systems. Time.now is recommended over
  # CLOCK_REALTIME.
  #
  def self.clock_gettime: (Symbol | Integer clock_id) -> Float
                        | (Symbol | Integer clock_id, :float_second | :float_millisecond | :float_microsecond unit) -> Float
                        | (Symbol | Integer clock_id, :second | :millisecond | :microsecond | :nanosecond unit) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.daemon()                        -> 0
  #   - Process.daemon(nochdir=nil,noclose=nil) -> 0
  # -->
  # Detach the process from controlling terminal and run in the background as
  # system daemon.  Unless the argument nochdir is true (i.e. non false), it
  # changes the current working directory to the root ("/"). Unless the argument
  # noclose is true, daemon() will redirect standard input, standard output and
  # standard error to /dev/null. Return zero on success, or raise one of Errno::*.
  #
  def self.daemon: (?untyped nochdir, ?untyped noclose) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.detach(pid)   -> thread
  # -->
  # Some operating systems retain the status of terminated child processes until
  # the parent collects that status (normally using some variant of `wait()`). If
  # the parent never collects this status, the child stays around as a *zombie*
  # process. Process::detach prevents this by setting up a separate Ruby thread
  # whose sole job is to reap the status of the process *pid* when it terminates.
  # Use #detach only when you do not intend to explicitly wait for the child to
  # terminate.
  #
  # The waiting thread returns the exit status of the detached process when it
  # terminates, so you can use Thread#join to know the result.  If specified *pid*
  # is not a valid child process ID, the thread returns `nil` immediately.
  #
  # The waiting thread has #pid method which returns the pid.
  #
  # In this first example, we don't reap the first child process, so it appears as
  # a zombie in the process status display.
  #
  #     p1 = fork { sleep 0.1 }
  #     p2 = fork { sleep 0.2 }
  #     Process.waitpid(p2)
  #     sleep 2
  #     system("ps -ho pid,state -p #{p1}")
  #
  # *produces:*
  #
  #     27389 Z
  #
  # In the next example, Process::detach is used to reap the child automatically.
  #
  #     p1 = fork { sleep 0.1 }
  #     p2 = fork { sleep 0.2 }
  #     Process.detach(p1)
  #     Process.waitpid(p2)
  #     sleep 2
  #     system("ps -ho pid,state -p #{p1}")
  #
  # *(produces no output)*
  #
  def self.detach: (Integer pid) -> Thread

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid          -> integer
  #   - Process::GID.eid      -> integer
  #   - Process::Sys.geteid   -> integer
  # -->
  # Returns the effective group ID for this process. Not available on all
  # platforms.
  #
  #     Process.egid   #=> 500
  #
  def self.egid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid = integer   -> integer
  # -->
  # Sets the effective group ID for this process. Not available on all platforms.
  #
  def self.egid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.euid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid= user
  # -->
  # Sets the effective user ID for this process. Not available on all platforms.
  #
  def self.euid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgid(pid)   -> integer
  # -->
  # Returns the process group ID for the given process id. Not available on all
  # platforms.
  #
  #     Process.getpgid(Process.ppid())   #=> 25527
  #
  def self.getpgid: (Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgrp   -> integer
  # -->
  # Returns the process group ID for this process. Not available on all platforms.
  #
  #     Process.getpgid(0)   #=> 25527
  #     Process.getpgrp      #=> 25527
  #
  def self.getpgrp: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpriority(kind, integer)   -> integer
  # -->
  # Gets the scheduling priority for specified process, process group, or user.
  # *kind* indicates the kind of entity to find: one of Process::PRIO_PGRP,
  # Process::PRIO_USER, or Process::PRIO_PROCESS. *integer* is an id indicating
  # the particular process, process group, or user (an id of 0 means *current*).
  # Lower priorities are more favorable for scheduling. Not available on all
  # platforms.
  #
  #     Process.getpriority(Process::PRIO_USER, 0)      #=> 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19
  #
  def self.getpriority: (Integer kind, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getrlimit(resource)   -> [cur_limit, max_limit]
  # -->
  # Gets the resource limit of the process. *cur_limit* means current (soft) limit
  # and *max_limit* means maximum (hard) limit.
  #
  # *resource* indicates the kind of resource to limit. It is specified as a
  # symbol such as `:CORE`, a string such as `"CORE"` or a constant such as
  # Process::RLIMIT_CORE. See Process.setrlimit for details.
  #
  # *cur_limit* and *max_limit* may be Process::RLIM_INFINITY,
  # Process::RLIM_SAVED_MAX or Process::RLIM_SAVED_CUR. See Process.setrlimit and
  # the system getrlimit(2) manual for details.
  #
  def self.getrlimit: (Symbol | String | Integer resource) -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.getsid()      -> integer
  #   - Process.getsid(pid)   -> integer
  # -->
  # Returns the session ID for the given process id. If not given, return current
  # process sid. Not available on all platforms.
  #
  #     Process.getsid()                #=> 27422
  #     Process.getsid(0)               #=> 27422
  #     Process.getsid(Process.pid())   #=> 27422
  #
  def self.getsid: (?Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.gid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid= integer   -> integer
  # -->
  # Sets the group ID for this process.
  #
  def self.gid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups   -> array
  # -->
  # Get an Array of the group IDs in the supplemental group access list for this
  # process.
  #
  #     Process.groups   #=> [27, 6, 10, 11]
  #
  # Note that this method is just a wrapper of getgroups(2). This means that the
  # following characteristics of the result completely depend on your system:
  #
  # *   the result is sorted
  # *   the result includes effective GIDs
  # *   the result does not include duplicated GIDs
  #
  #
  # You can make sure to get a sorted unique GID list of the current process by
  # this expression:
  #
  #     Process.groups.uniq.sort
  #
  def self.groups: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups= array   -> array
  # -->
  # Set the supplemental group access list to the given Array of group IDs.
  #
  #     Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]
  #     Process.groups   #=> [27, 6, 10, 11]
  #
  def self.groups=: (::Array[Integer] arg0) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.initgroups(username, gid)   -> array
  # -->
  # Initializes the supplemental group access list by reading the system group
  # database and using all groups of which the given user is a member. The group
  # with the specified *gid* is also added to the list. Returns the resulting
  # Array of the gids of all the groups in the supplementary group access list.
  # Not available on all platforms.
  #
  #     Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.initgroups( "mgranger", 30 )   #=> [30, 6, 10, 11]
  #     Process.groups   #=> [30, 6, 10, 11]
  #
  def self.initgroups: (String username, Integer gid) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.kill(signal, pid, ...)    -> integer
  # -->
  # Sends the given signal to the specified process id(s) if *pid* is positive. If
  # *pid* is zero, *signal* is sent to all processes whose group ID is equal to
  # the group ID of the process. If *pid* is negative, results are dependent on
  # the operating system. *signal* may be an integer signal number or a POSIX
  # signal name (either with or without a `SIG` prefix). If *signal* is negative
  # (or starts with a minus sign), kills process groups instead of processes. Not
  # all signals are available on all platforms. The keys and values of Signal.list
  # are known signal names and numbers, respectively.
  #
  #     pid = fork do
  #        Signal.trap("HUP") { puts "Ouch!"; exit }
  #        # ... do some work ...
  #     end
  #     # ...
  #     Process.kill("HUP", pid)
  #     Process.wait
  #
  # *produces:*
  #
  #     Ouch!
  #
  # If *signal* is an integer but wrong for signal, Errno::EINVAL or RangeError
  # will be raised.  Otherwise unless *signal* is a String or a Symbol, and a
  # known signal name, ArgumentError will be raised.
  #
  # Also, Errno::ESRCH or RangeError for invalid *pid*, Errno::EPERM when failed
  # because of no privilege, will be raised.  In these cases, signals may have
  # been sent to preceding processes.
  #
  def self.kill: (Integer | Symbol | String signal, *Integer pids) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups   -> integer
  # -->
  # Returns the maximum number of gids allowed in the supplemental group access
  # list.
  #
  #     Process.maxgroups   #=> 32
  #
  def self.maxgroups: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups= integer   -> integer
  # -->
  # Sets the maximum number of gids allowed in the supplemental group access list.
  #
  def self.maxgroups=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.pid   -> integer
  # -->
  # Returns the process id of this process. Not available on all platforms.
  #
  #     Process.pid   #=> 27415
  #
  def self.pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.ppid   -> integer
  # -->
  # Returns the process id of the parent of this process. Returns untrustworthy
  # value on Win32/64. Not available on all platforms.
  #
  #     puts "I am #{Process.pid}"
  #     Process.fork { puts "Dad is #{Process.ppid}" }
  #
  # *produces:*
  #
  #     I am 27417
  #     Dad is 27417
  #
  def self.ppid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpgid(pid, integer)   -> 0
  # -->
  # Sets the process group ID of *pid* (0 indicates this process) to *integer*.
  # Not available on all platforms.
  #
  def self.setpgid: (Integer pid, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpriority(kind, integer, priority)   -> 0
  # -->
  # See Process.getpriority.
  #
  #     Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0
  #     Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0
  #     Process.getpriority(Process::PRIO_USER, 0)          #=> 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19
  #
  def self.setpriority: (Integer kind, Integer arg0, Integer priority) -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.setproctitle(string)  -> string
  # -->
  # Sets the process title that appears on the ps(1) command.  Not necessarily
  # effective on all platforms.  No exception will be raised regardless of the
  # result, nor will NotImplementedError be raised even if the platform does not
  # support the feature.
  #
  # Calling this method does not affect the value of $0.
  #
  #     Process.setproctitle('myapp: worker #%d' % worker_id)
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to change the process title.
  #
  def self.setproctitle: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.setrlimit(resource, cur_limit, max_limit)        -> nil
  #   - Process.setrlimit(resource, cur_limit)                   -> nil
  # -->
  # Sets the resource limit of the process. *cur_limit* means current (soft) limit
  # and *max_limit* means maximum (hard) limit.
  #
  # If *max_limit* is not given, *cur_limit* is used.
  #
  # *resource* indicates the kind of resource to limit. It should be a symbol such
  # as `:CORE`, a string such as `"CORE"` or a constant such as
  # Process::RLIMIT_CORE. The available resources are OS dependent. Ruby may
  # support following resources.
  #
  # AS
  # :   total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but
  #     4.4BSD-Lite)
  # CORE
  # :   core size (bytes) (SUSv3)
  # CPU
  # :   CPU time (seconds) (SUSv3)
  # DATA
  # :   data segment (bytes) (SUSv3)
  # FSIZE
  # :   file size (bytes) (SUSv3)
  # MEMLOCK
  # :   total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)
  # MSGQUEUE
  # :   allocation for POSIX message queues (bytes) (GNU/Linux)
  # NICE
  # :   ceiling on process's nice(2) value (number) (GNU/Linux)
  # NOFILE
  # :   file descriptors (number) (SUSv3)
  # NPROC
  # :   number of processes for the user (number) (4.4BSD, GNU/Linux)
  # RSS
  # :   resident memory size (bytes) (4.2BSD, GNU/Linux)
  # RTPRIO
  # :   ceiling on the process's real-time priority (number) (GNU/Linux)
  # RTTIME
  # :   CPU time for real-time process (us) (GNU/Linux)
  # SBSIZE
  # :   all socket buffers (bytes) (NetBSD, FreeBSD)
  # SIGPENDING
  # :   number of queued signals allowed (signals) (GNU/Linux)
  # STACK
  # :   stack size (bytes) (SUSv3)
  #
  #
  # *cur_limit* and *max_limit* may be `:INFINITY`, `"INFINITY"` or
  # Process::RLIM_INFINITY, which means that the resource is not limited. They may
  # be Process::RLIM_SAVED_MAX, Process::RLIM_SAVED_CUR and corresponding symbols
  # and strings too. See system setrlimit(2) manual for details.
  #
  # The following example raises the soft limit of core size to the hard limit to
  # try to make core dump possible.
  #
  #     Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])
  #
  def self.setrlimit: (Symbol | String | Integer resource, Integer cur_limit, ?Integer max_limit) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process.setsid   -> integer
  # -->
  # Establishes this process as a new session and process group leader, with no
  # controlling tty. Returns the session id. Not available on all platforms.
  #
  #     Process.setsid   #=> 27422
  #
  def self.setsid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.times   -> aProcessTms
  # -->
  # Returns a `Tms` structure (see Process::Tms) that contains user and system CPU
  # times for this process, and also for children processes.
  #
  #     t = Process.times
  #     [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]
  #
  def self.times: () -> Process::Tms

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.uid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid= user   -> numeric
  # -->
  # Sets the (user) user ID for this process. Not available on all platforms.
  #
  def self.uid=: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait()                     -> integer
  #   - Process.wait(pid=-1, flags=0)      -> integer
  #   - Process.waitpid(pid=-1, flags=0)   -> integer
  # -->
  # Waits for a child process to exit, returns its process id, and sets `$?` to a
  # Process::Status object containing information on that process. Which child it
  # waits on depends on the value of *pid*:
  #
  # > 0
  # :   Waits for the child whose process ID equals *pid*.
  #
  # 0
  # :   Waits for any child whose process group ID equals that of the calling
  #     process.
  #
  # -1
  # :   Waits for any child process (the default if no *pid* is given).
  #
  # < -1
  # :   Waits for any child whose process group ID equals the absolute value of
  #     *pid*.
  #
  #
  # The *flags* argument may be a logical or of the flag values Process::WNOHANG
  # (do not block if no child available) or Process::WUNTRACED (return stopped
  # children that haven't been reported). Not all flags are available on all
  # platforms, but a flag value of zero will work on all platforms.
  #
  # Calling this method raises a SystemCallError if there are no child processes.
  # Not available on all platforms.
  #
  #     include Process
  #     fork { exit 99 }                 #=> 27429
  #     wait                             #=> 27429
  #     $?.exitstatus                    #=> 99
  #
  #     pid = fork { sleep 3 }           #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, Process::WNOHANG)   #=> nil
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, 0)                  #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:19 +0900
  #
  def self.wait: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid=-1, flags=0)      -> [pid, status]
  #   - Process.waitpid2(pid=-1, flags=0)   -> [pid, status]
  # -->
  # Waits for a child process to exit (see Process::waitpid for exact semantics)
  # and returns an array containing the process id and the exit status (a
  # Process::Status object) of that child. Raises a SystemCallError if there are
  # no child processes.
  #
  #     Process.fork { exit 99 }   #=> 27437
  #     pid, status = Process.wait2
  #     pid                        #=> 27437
  #     status.exitstatus          #=> 99
  #
  def self.wait2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.waitall   -> [ [pid1,status1], ...]
  # -->
  # Waits for all children, returning an array of *pid*/*status* pairs (where
  # *status* is a Process::Status object).
  #
  #     fork { sleep 0.2; exit 2 }   #=> 27432
  #     fork { sleep 0.1; exit 1 }   #=> 27433
  #     fork {            exit 0 }   #=> 27434
  #     p Process.waitall
  #
  # *produces*:
  #
  #     [[30982, #<Process::Status: pid 30982 exit 0>],
  #      [30979, #<Process::Status: pid 30979 exit 1>],
  #      [30976, #<Process::Status: pid 30976 exit 2>]]
  #
  def self.waitall: () -> ::Array[[ Integer, Process::Status ]]

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait()                     -> integer
  #   - Process.wait(pid=-1, flags=0)      -> integer
  #   - Process.waitpid(pid=-1, flags=0)   -> integer
  # -->
  # Waits for a child process to exit, returns its process id, and sets `$?` to a
  # Process::Status object containing information on that process. Which child it
  # waits on depends on the value of *pid*:
  #
  # > 0
  # :   Waits for the child whose process ID equals *pid*.
  #
  # 0
  # :   Waits for any child whose process group ID equals that of the calling
  #     process.
  #
  # -1
  # :   Waits for any child process (the default if no *pid* is given).
  #
  # < -1
  # :   Waits for any child whose process group ID equals the absolute value of
  #     *pid*.
  #
  #
  # The *flags* argument may be a logical or of the flag values Process::WNOHANG
  # (do not block if no child available) or Process::WUNTRACED (return stopped
  # children that haven't been reported). Not all flags are available on all
  # platforms, but a flag value of zero will work on all platforms.
  #
  # Calling this method raises a SystemCallError if there are no child processes.
  # Not available on all platforms.
  #
  #     include Process
  #     fork { exit 99 }                 #=> 27429
  #     wait                             #=> 27429
  #     $?.exitstatus                    #=> 99
  #
  #     pid = fork { sleep 3 }           #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, Process::WNOHANG)   #=> nil
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, 0)                  #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:19 +0900
  #
  def self.waitpid: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid=-1, flags=0)      -> [pid, status]
  #   - Process.waitpid2(pid=-1, flags=0)   -> [pid, status]
  # -->
  # Waits for a child process to exit (see Process::waitpid for exact semantics)
  # and returns an array containing the process id and the exit status (a
  # Process::Status object) of that child. Raises a SystemCallError if there are
  # no child processes.
  #
  #     Process.fork { exit 99 }   #=> 27437
  #     pid, status = Process.wait2
  #     pid                        #=> 27437
  #     status.exitstatus          #=> 99
  #
  def self.waitpid2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]
end

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_RAW: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_PROCESS_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_THREAD_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PGRP: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PROCESS: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_USER: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's virtual memory (address space) in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_AS: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the core file.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CORE: Integer

# <!-- rdoc-file=process.c -->
# CPU time limit in seconds.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CPU: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's data segment.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_DATA: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of files that the process may create.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_FSIZE: Integer

# <!-- rdoc-file=process.c -->
# Maximum number of bytes of memory that may be locked into RAM.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MEMLOCK: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit on the number of bytes that can be allocated for POSIX
# message queues for the real user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MSGQUEUE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling to which the process's nice value can be raised.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NICE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a value one greater than the maximum file descriptor number that can
# be opened by this process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NOFILE: Integer

# <!-- rdoc-file=process.c -->
# The maximum number of processes that can be created for the real user ID of
# the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NPROC: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit (in pages) of the process's resident set.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RSS: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling on the real-time priority that may be set for this
# process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTPRIO: Integer

# <!-- rdoc-file=process.c -->
# Specifies limit on CPU time this process scheduled under a real-time
# scheduling policy can consume.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTTIME: Integer

# <!-- rdoc-file=process.c -->
# Specifies a limit on the number of signals that may be queued for the real
# user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_SIGPENDING: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the stack, in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_STACK: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_INFINITY: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_CUR: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_MAX: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WNOHANG: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WUNTRACED: Integer

# <!-- rdoc-file=process.c -->
# The Process::GID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved group IDs.
#
module Process::GID
  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.change_privilege(group)   -> integer
  # -->
  # Change the current process's real and effective group ID to that specified by
  # *group*. Returns the new group ID. Not available on all platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.change_privilege(33)    #=> 33
  #     [Process.gid, Process.egid]          #=> [33, 33]
  #
  def self.change_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid          -> integer
  #   - Process::GID.eid      -> integer
  #   - Process::Sys.geteid   -> integer
  # -->
  # Returns the effective group ID for this process. Not available on all
  # platforms.
  #
  #     Process.egid   #=> 500
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.from_name(name)   -> gid
  # -->
  # Get the group ID by the *name*. If the group is not found, `ArgumentError`
  # will be raised.
  #
  #     Process::GID.from_name("wheel") #=> 0
  #     Process::GID.from_name("nosuchgroup") #=> can't find group for nosuchgroup (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.grant_privilege(group)    -> integer
  #   - Process::GID.eid = group               -> integer
  # -->
  # Set the effective group ID, and if possible, the saved group ID of the process
  # to the given *group*. Returns the new effective group ID. Not available on all
  # platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.grant_privilege(31)     #=> 33
  #     [Process.gid, Process.egid]          #=> [0, 33]
  #
  def self.grant_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchange   -> integer
  # -->
  # Exchange real and effective group IDs and return the new effective group ID.
  # Not available on all platforms.
  #
  #     [Process.gid, Process.egid]   #=> [0, 33]
  #     Process::GID.re_exchange      #=> 0
  #     [Process.gid, Process.egid]   #=> [33, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective group IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved group ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.switch              -> integer
  #   - Process::GID.switch {|| block}   -> object
  # -->
  # Switch the effective and real group IDs of the current process. If a *block*
  # is given, the group IDs will be switched back after the block is executed.
  # Returns the new effective group ID if called without a block, and the return
  # value of the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer group) -> Integer
end

# <!-- rdoc-file=process.c -->
# Process::Status encapsulates the information on the status of a running or
# terminated system process. The built-in variable `$?` is either `nil` or a
# Process::Status object.
#
#     fork { exit 99 }   #=> 26557
#     Process.wait       #=> 26557
#     $?.class           #=> Process::Status
#     $?.to_i            #=> 25344
#     $? >> 8            #=> 99
#     $?.stopped?        #=> false
#     $?.exited?         #=> true
#     $?.exitstatus      #=> 99
#
# Posix systems record information on processes using a 16-bit integer.  The
# lower bits record the process status (stopped, exited, signaled) and the upper
# bits possibly contain additional information (for example the program's return
# code in the case of exited processes). Pre Ruby 1.8, these bits were exposed
# directly to the Ruby program. Ruby now encapsulates these in a Process::Status
# object. To maximize compatibility, however, these objects retain a
# bit-oriented interface. In the descriptions that follow, when we talk about
# the integer value of *stat*, we're referring to this 16 bit value.
#
class Process::Status < Object
  # <!--
  #   rdoc-file=process.c
  #   - stat & num   -> integer
  # -->
  # Logical AND of the bits in *stat* with *num*.
  #
  #     fork { exit 0x37 }
  #     Process.wait
  #     sprintf('%04x', $?.to_i)       #=> "3700"
  #     sprintf('%04x', $? & 0x1e00)   #=> "1600"
  #
  def &: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat == other   -> true or false
  # -->
  # Returns `true` if the integer value of *stat* equals *other*.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat >> num   -> integer
  # -->
  # Shift the bits in *stat* right *num* places.
  #
  #     fork { exit 99 }   #=> 26563
  #     Process.wait       #=> 26563
  #     $?.to_i            #=> 25344
  #     $? >> 8            #=> 99
  #
  def >>: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.coredump?   -> true or false
  # -->
  # Returns `true` if *stat* generated a coredump when it terminated. Not
  # available on all platforms.
  #
  def coredump?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.exited?   -> true or false
  # -->
  # Returns `true` if *stat* exited normally (for example using an `exit()` call
  # or finishing the program).
  #
  def exited?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.exitstatus   -> integer or nil
  # -->
  # Returns the least significant eight bits of the return code of *stat*. Only
  # available if #exited? is `true`.
  #
  #     fork { }           #=> 26572
  #     Process.wait       #=> 26572
  #     $?.exited?         #=> true
  #     $?.exitstatus      #=> 0
  #
  #     fork { exit 99 }   #=> 26573
  #     Process.wait       #=> 26573
  #     $?.exited?         #=> true
  #     $?.exitstatus      #=> 99
  #
  def exitstatus: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.inspect   -> string
  # -->
  # Override the inspection method.
  #
  #     system("false")
  #     p $?.inspect #=> "#<Process::Status: pid 12861 exit 1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - stat.pid   -> integer
  # -->
  # Returns the process ID that this status object represents.
  #
  #     fork { exit }   #=> 26569
  #     Process.wait    #=> 26569
  #     $?.pid          #=> 26569
  #
  def pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.signaled?   -> true or false
  # -->
  # Returns `true` if *stat* terminated because of an uncaught signal.
  #
  def signaled?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.stopped?   -> true or false
  # -->
  # Returns `true` if this process is stopped. This is only returned if the
  # corresponding #wait call had the Process::WUNTRACED flag set.
  #
  def stopped?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.stopsig   -> integer or nil
  # -->
  # Returns the number of the signal that caused *stat* to stop (or `nil` if self
  # is not stopped).
  #
  def stopsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.success?   -> true, false or nil
  # -->
  # Returns `true` if *stat* is successful, `false` if not. Returns `nil` if
  # #exited? is not `true`.
  #
  def success?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.termsig   -> integer or nil
  # -->
  # Returns the number of the signal that caused *stat* to terminate (or `nil` if
  # self was not terminated by an uncaught signal).
  #
  def termsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.to_i     -> integer
  # -->
  # Returns the bits in *stat* as an Integer. Poking around in these bits is
  # platform dependent.
  #
  #     fork { exit 0xab }         #=> 26566
  #     Process.wait               #=> 26566
  #     sprintf('%04x', $?.to_i)   #=> "ab00"
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.to_s   -> string
  # -->
  # Show pid and exit status as a string.
  #
  #     system("false")
  #     p $?.to_s         #=> "pid 12766 exit 1"
  #
  def to_s: () -> String
end

# <!-- rdoc-file=process.c -->
# The Process::Sys module contains UID and GID functions which provide direct
# bindings to the system calls of the same names instead of the more-portable
# versions of the same functionality found in the Process, Process::UID, and
# Process::GID modules.
#
module Process::Sys
  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.geteuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.getgid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.getuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.issetugid   -> true or false
  # -->
  # Returns `true` if the process was created as a result of an execve(2) system
  # call which had either of the setuid or setgid bits set (and extra privileges
  # were given as a result) or if it has changed any of its real, effective or
  # saved user or group IDs since it began execution.
  #
  def self.issetugid: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setegid(group)   -> nil
  # -->
  # Set the effective group ID of the calling process to *group*.  Not available
  # on all platforms.
  #
  def self.setegid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.seteuid(user)   -> nil
  # -->
  # Set the effective user ID of the calling process to *user*.  Not available on
  # all platforms.
  #
  def self.seteuid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setgid(group)   -> nil
  # -->
  # Set the group ID of the current process to *group*. Not available on all
  # platforms.
  #
  def self.setgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setregid(rid, eid)   -> nil
  # -->
  # Sets the (group) real and/or effective group IDs of the current process to
  # *rid* and *eid*, respectively. A value of `-1` for either means to leave that
  # ID unchanged. Not available on all platforms.
  #
  def self.setregid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresgid(rid, eid, sid)   -> nil
  # -->
  # Sets the (group) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresgid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresuid(rid, eid, sid)   -> nil
  # -->
  # Sets the (user) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresuid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setreuid(rid, eid)   -> nil
  # -->
  # Sets the (user) real and/or effective user IDs of the current process to *rid*
  # and *eid*, respectively. A value of `-1` for either means to leave that ID
  # unchanged. Not available on all platforms.
  #
  def self.setreuid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setrgid(group)   -> nil
  # -->
  # Set the real group ID of the calling process to *group*. Not available on all
  # platforms.
  #
  def self.setrgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setruid(user)   -> nil
  # -->
  # Set the real user ID of the calling process to *user*. Not available on all
  # platforms.
  #
  def self.setruid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setuid(user)   -> nil
  # -->
  # Set the user ID of the current process to *user*. Not available on all
  # platforms.
  #
  def self.setuid: (Integer user) -> nil
end

# <!-- rdoc-file=process.c -->
# The Process::UID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved user IDs.
#
module Process::UID
  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.change_privilege(user)   -> integer
  # -->
  # Change the current process's real and effective user ID to that specified by
  # *user*. Returns the new user ID. Not available on all platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.change_privilege(31)    #=> 31
  #     [Process.uid, Process.euid]          #=> [31, 31]
  #
  def self.change_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.from_name(name)   -> uid
  # -->
  # Get the user ID by the *name*. If the user is not found, `ArgumentError` will
  # be raised.
  #
  #     Process::UID.from_name("root") #=> 0
  #     Process::UID.from_name("nosuchuser") #=> can't find user for nosuchuser (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.grant_privilege(user)   -> integer
  #   - Process::UID.eid= user               -> integer
  # -->
  # Set the effective user ID, and if possible, the saved user ID of the process
  # to the given *user*. Returns the new effective user ID. Not available on all
  # platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.grant_privilege(31)     #=> 31
  #     [Process.uid, Process.euid]          #=> [0, 31]
  #
  def self.grant_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchange   -> integer
  # -->
  # Exchange real and effective user IDs and return the new effective user ID. Not
  # available on all platforms.
  #
  #     [Process.uid, Process.euid]   #=> [0, 31]
  #     Process::UID.re_exchange      #=> 0
  #     [Process.uid, Process.euid]   #=> [31, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective user IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved user ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.switch              -> integer
  #   - Process::UID.switch {|| block}   -> object
  # -->
  # Switch the effective and real user IDs of the current process. If a *block* is
  # given, the user IDs will be switched back after the block is executed. Returns
  # the new effective user ID if called without a block, and the return value of
  # the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer user) -> Integer
end

class Process::Tms < Struct[Float]
end

class Process::Waiter < Thread
  def pid: () -> Integer
end

# <!-- rdoc-file=struct.c -->
# Class Struct provides a convenient way to create a simple class that can store
# and fetch values.
#
# This example creates a subclass of `Struct`, `Struct::Customer`; the first
# argument, a string, is the name of the subclass; the other arguments, symbols,
# determine the *members* of the new subclass.
#
#     Customer = Struct.new('Customer', :name, :address, :zip)
#     Customer.name       # => "Struct::Customer"
#     Customer.class      # => Class
#     Customer.superclass # => Struct
#
# Corresponding to each member are two methods, a writer and a reader, that
# store and fetch values:
#
#     methods = Customer.instance_methods false
#     methods # => [:zip, :address=, :zip=, :address, :name, :name=]
#
# An instance of the subclass may be created, and its members assigned values,
# via method `::new`:
#
#     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
#     joe # => #<struct Struct::Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=12345>
#
# The member values may be managed thus:
#
#     joe.name    # => "Joe Smith"
#     joe.name = 'Joseph Smith'
#     joe.name    # => "Joseph Smith"
#
# And thus; note that member name may be expressed as either a string or a
# symbol:
#
#     joe[:name]  # => "Joseph Smith"
#     joe[:name] = 'Joseph Smith, Jr.'
#     joe['name'] # => "Joseph Smith, Jr."
#
# See Struct::new.
#
# ## What's Here
#
# First, what's elsewhere. Class Struct:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Struct provides methods that are useful for:
#
# *   [Creating a Struct
#     Subclass](#class-Struct-label-Methods+for+Creating+a+Struct+Subclass)
# *   [Querying](#class-Struct-label-Methods+for+Querying)
# *   [Comparing](#class-Struct-label-Methods+for+Comparing)
# *   [Fetching](#class-Struct-label-Methods+for+Fetching)
# *   [Assigning](#class-Struct-label-Methods+for+Assigning)
# *   [Iterating](#class-Struct-label-Methods+for+Iterating)
# *   [Converting](#class-Struct-label-Methods+for+Converting)
#
#
# ### Methods for Creating a Struct Subclass
#
# ::new
# :   Returns a new subclass of Struct.
#
#
# ### Methods for Querying
#
# #hash
# :   Returns the integer hash code.
# #length, #size
# :   Returns the number of members.
#
#
# ### Methods for Comparing
#
# [#==](#method-i-3D-3D)
# :   Returns whether a given object is equal to `self`, using `==` to compare
#     member values.
# #eql?
# :   Returns whether a given object is equal to `self`, using `eql?` to compare
#     member values.
#
#
# ### Methods for Fetching
#
# #[]
# :   Returns the value associated with a given member name.
# #to_a, #values, #deconstruct
# :   Returns the member values in `self` as an array.
# #deconstruct_keys
# :   Returns a hash of the name/value pairs for given member names.
# #dig
# :   Returns the object in nested objects that is specified by a given member
#     name and additional arguments.
# #members
# :   Returns an array of the member names.
# #select, #filter
# :   Returns an array of member values from `self`, as selected by the given
#     block.
# #values_at
# :   Returns an array containing values for given member names.
#
#
# ### Methods for Assigning
#
# #[]=
# :   Assigns a given value to a given member name.
#
#
# ### Methods for Iterating
#
# #each
# :   Calls a given block with each member name.
# #each_pair
# :   Calls a given block with each member name/value pair.
#
#
# ### Methods for Converting
#
# #inspect, #to_s
# :   Returns a string representation of `self`.
# #to_h
# :   Returns a hash of the member name/value pairs in `self`.
#
class Struct[Elem] < Object
  include Enumerable[Elem?]

  type attribute_name = Symbol | String

  # <!--
  #   rdoc-file=struct.c
  #   - Struct.new(*member_names, keyword_init: false){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct.new(class_name, *member_names, keyword_init: false){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct_subclass.new(*member_names) -> Struct_subclass_instance
  #   - Struct_subclass.new(**member_names) -> Struct_subclass_instance
  # -->
  # `Struct.new` returns a new subclass of `Struct`.  The new subclass:
  #
  # *   May be anonymous, or may have the name given by `class_name`.
  # *   May have members as given by `member_names`.
  # *   May have initialization via ordinary arguments (the default) or via
  #     keyword arguments (if `keyword_init: true` is given).
  #
  #
  # The new subclass has its own method `::new`; thus:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     f = Foo.new(0, 1)                   # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **\Class Name**
  #
  # With string argument `class_name`, returns a new subclass of `Struct` named
  # `Struct::*class_name`*:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     Foo.name                            # => "Struct::Foo"
  #     Foo.superclass                      # => Struct
  #
  # Without string argument `class_name`, returns a new anonymous subclass of
  # `Struct`:
  #
  #     Struct.new(:foo, :bar).name # => nil
  #
  # **Block**
  #
  # With a block given, the created subclass is yielded to the block:
  #
  #     Customer = Struct.new('Customer', :name, :address) do |new_class|
  #       p "The new subclass is #{new_class}"
  #       def greeting
  #         "Hello #{name} at #{address}"
  #       end
  #     end           # => Struct::Customer
  #     dave = Customer.new('Dave', '123 Main')
  #     dave # =>     #<struct Struct::Customer name="Dave", address="123 Main">
  #     dave.greeting # => "Hello Dave at 123 Main"
  #
  # Output, from `Struct.new`:
  #
  #     "The new subclass is Struct::Customer"
  #
  # **Member Names**
  #
  # Symbol arguments `member_names` determines the members of the new subclass:
  #
  #     Struct.new(:foo, :bar).members        # => [:foo, :bar]
  #     Struct.new('Foo', :foo, :bar).members # => [:foo, :bar]
  #
  # The new subclass has instance methods corresponding to `member_names`:
  #
  #     Foo = Struct.new('Foo', :foo, :bar)
  #     Foo.instance_methods(false) # => [:foo, :bar, :foo=, :bar=]
  #     f = Foo.new                 # => #<struct Struct::Foo foo=nil, bar=nil>
  #     f.foo                       # => nil
  #     f.foo = 0                   # => 0
  #     f.bar                       # => nil
  #     f.bar = 1                   # => 1
  #     f                           # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **Singleton Methods**
  #
  # A subclass returned by Struct.new has these singleton methods:
  #
  # *   Method `::new ` creates an instance of the subclass:
  #
  #         Foo.new          # => #<struct Struct::Foo foo=nil, bar=nil>
  #         Foo.new(0)       # => #<struct Struct::Foo foo=0, bar=nil>
  #         Foo.new(0, 1)    # => #<struct Struct::Foo foo=0, bar=1>
  #         Foo.new(0, 1, 2) # Raises ArgumentError: struct size differs
  #
  #     Method `::[]` is an alias for method `::new`.
  #
  # *   Method `:inspect` returns a string representation of the subclass:
  #
  #         Foo.inspect
  #         # => "Struct::Foo"
  #
  # *   Method `::members` returns an array of the member names:
  #
  #         Foo.members # => [:foo, :bar]
  #
  #
  # **Keyword Argument**
  #
  # By default, the arguments for initializing an instance of the new subclass are
  # ordinary arguments (not keyword arguments). With optional keyword argument
  # `keyword_init: true`, the new subclass is initialized with keyword arguments:
  #
  #     # Without keyword_init: true.
  #     Foo = Struct.new('Foo', :foo, :bar)
  #     Foo                     # => Struct::Foo
  #     Foo.new(0, 1)           # => #<struct Struct::Foo foo=0, bar=1>
  #     # With keyword_init: true.
  #     Bar = Struct.new(:foo, :bar, keyword_init: true)
  #     Bar # =>                # => Bar(keyword_init: true)
  #     Bar.new(bar: 1, foo: 0) # => #<struct Bar foo=0, bar=1>
  #
  def initialize: (attribute_name, *attribute_name, ?keyword_init: boolish) ?{ () -> void } -> void

  # <!--
  #   rdoc-file=struct.c
  #   - each {|value| ... } -> self
  #   - each -> enumerator
  # -->
  # Calls the given block with the value of each member; returns `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.each {|value| p value }
  #
  # Output:
  #
  #     "Joe Smith"
  #     "123 Maple, Anytown NC"
  #     12345
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #each_pair.
  #
  def each: () -> ::Enumerator[Elem?, self]
          | () { (Elem? item) -> void } -> self

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::members -> array_of_symbols
  # -->
  # Returns the member names of the Struct descendant as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     Customer.members # => [:name, :address, :zip]
  #
  def self.members: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::keyword_init? -> true or falsy value
  # -->
  # Returns `true` if the class was initialized with `keyword_init: true`.
  # Otherwise returns `nil` or `false`.
  #
  # Examples:
  #     Foo = Struct.new(:a)
  #     Foo.keyword_init? # => nil
  #     Bar = Struct.new(:a, keyword_init: true)
  #     Bar.keyword_init? # => true
  #     Baz = Struct.new(:a, keyword_init: false)
  #     Baz.keyword_init? # => false
  #
  def self.keyword_init?: () -> (true | false | nil)
end

# <!-- rdoc-file=timev.rb -->
# Time is an abstraction of dates and times. Time is stored internally as the
# number of seconds with subsecond since the *Epoch*, 1970-01-01 00:00:00 UTC.
#
# The Time class treats GMT (Greenwich Mean Time) and UTC (Coordinated Universal
# Time) as equivalent. GMT is the older way of referring to these baseline times
# but persists in the names of calls on POSIX systems.
#
# Note: A Time object uses the resolution available on your system clock.
#
# All times may have subsecond. Be aware of this fact when comparing times with
# each other -- times that are apparently equal when displayed may be different
# when compared. (Since Ruby 2.7.0, Time#inspect shows subsecond but Time#to_s
# still doesn't show subsecond.)
#
# ## Examples
#
# All of these examples were done using the EST timezone which is GMT-5.
#
# ### Creating a New Time Instance
#
# You can create a new instance of Time with Time.new. This will use the current
# system time. Time.now is an alias for this. You can also pass parts of the
# time to Time.new such as year, month, minute, etc. When you want to construct
# a time this way you must pass at least a year. If you pass the year with
# nothing else time will default to January 1 of that year at 00:00:00 with the
# current system timezone. Here are some examples:
#
#     Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
#     Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
#     Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500
#
# You can pass a UTC offset:
#
#     Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200
#
# Or a timezone object:
#
#     zone = timezone("Europe/Athens")      # Eastern European Time, UTC+2
#     Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200
#
# You can also use Time.local and Time.utc to infer local and UTC timezones
# instead of using the current system setting.
#
# You can also create a new time using Time.at which takes the number of seconds
# (with subsecond) since the [Unix
# Epoch](https://en.wikipedia.org/wiki/Unix_time).
#
#     Time.at(628232400) #=> 1989-11-28 00:00:00 -0500
#
# ### Working with an Instance of Time
#
# Once you have an instance of Time there is a multitude of things you can do
# with it. Below are some examples. For all of the following examples, we will
# work on the assumption that you have done the following:
#
#     t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")
#
# Was that a monday?
#
#     t.monday? #=> false
#
# What year was that again?
#
#     t.year #=> 1993
#
# Was it daylight savings at the time?
#
#     t.dst? #=> false
#
# What's the day a year later?
#
#     t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900
#
# How many seconds was that since the Unix Epoch?
#
#     t.to_i #=> 730522800
#
# You can also do standard functions like compare two times.
#
#     t1 = Time.new(2010)
#     t2 = Time.new(2011)
#
#     t1 == t2 #=> false
#     t1 == t1 #=> true
#     t1 <  t2 #=> true
#     t1 >  t2 #=> false
#
#     Time.new(2010,10,31).between?(t1, t2) #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class Time:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Time provides methods that are useful for:
#
# *   [Creating \Time objects](#class-Time-label-Methods+for+Creating).
# *   [Fetching \Time values](#class-Time-label-Methods+for+Fetching).
# *   [Querying a \Time object](#class-Time-label-Methods+for+Querying).
# *   [Comparing \Time objects](#class-Time-label-Methods+for+Comparing).
# *   [Converting a \Time object](#class-Time-label-Methods+for+Converting).
# *   [Rounding a \Time](#class-Time-label-Methods+for+Rounding).
#
#
# ### Methods for Creating
#
# *   ::new: Returns a new time from specified arguments (year, month, etc.),
#     including an optional timezone value.
# *   ::local (aliased as ::mktime): Same as ::new, except the timezone is the
#     local timezone.
# *   ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC.
# *   ::at: Returns a new time based on seconds since epoch.
# *   ::now: Returns a new time based on the current system time.
# *   #+ (plus): Returns a new time increased by the given number of seconds.
# *   [-](#method-i-2D) (minus): Returns a new time
#         decreased by the given number of seconds.
#
#
# ### Methods for Fetching
#
# *   #year: Returns the year of the time.
# *   #month (aliased as #mon): Returns the month of the time.
# *   #mday (aliased as #day): Returns the day of the month.
# *   #hour: Returns the hours value for the time.
# *   #min: Returns the minutes value for the time.
# *   #sec: Returns the seconds value for the time.
# *   #usec (aliased as #tv_usec): Returns the number of microseconds in the
#     subseconds value of the time.
# *   #nsec (aliased as #tv_nsec: Returns the number of nanoseconds in the
#     subsecond part of the time.
# *   #subsec: Returns the subseconds value for the time.
# *   #wday: Returns the integer weekday value of the time (0 == Sunday).
# *   #yday: Returns the integer yearday value of the time (1 == January 1).
# *   #hash: Returns the integer hash value for the time.
# *   #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset in
#     seconds between time and UTC.
# *   #to_f: Returns the float number of seconds since epoch for the time.
# *   #to_i (aliased as #tv_sec): Returns the integer number of seconds since
#     epoch for the time.
# *   #to_r: Returns the Rational number of seconds since epoch for the time.
# *   #zone: Returns a string representation of the timezone of the time.
#
#
# ### Methods for Querying
#
# *   #utc? (aliased as #gmt?): Returns whether the time is UTC.
# *   #dst? (aliased as #isdst): Returns whether the time is DST (daylight
#     saving time).
# *   #sunday?: Returns whether the time is a Sunday.
# *   #monday?: Returns whether the time is a Monday.
# *   #tuesday?: Returns whether the time is a Tuesday.
# *   #wednesday?: Returns whether the time is a Wednesday.
# *   #thursday?: Returns whether the time is a Thursday.
# *   #friday?: Returns whether time is a Friday.
# *   #saturday?: Returns whether the time is a Saturday.
#
#
# ### Methods for Comparing
#
# *   [#<=>](#method-i-3C-3D-3E): Compares `self` to another time.
# *   #eql?: Returns whether the time is equal to another time.
#
#
# ### Methods for Converting
#
# *   #asctime (aliased as #ctime): Returns the time as a string.
# *   #inspect: Returns the time in detail as a string.
# *   #strftime: Returns the time as a string, according to a given format.
# *   #to_a: Returns a 10-element array of values from the time.
# *   #to_s: Returns a string representation of the time.
# *   #getutc (aliased as #getgm): Returns a new time converted to UTC.
# *   #getlocal: Returns a new time converted to local time.
# *   #utc (aliased as #gmtime): Converts time to UTC in place.
# *   #localtime: Converts time to local time in place.
#
#
# ### Methods for Rounding
#
# *   #round:Returns a new time with subseconds rounded.
# *   #ceil: Returns a new time with subseconds raised to a ceiling.
# *   #floor: Returns a new time with subseconds lowered to a floor.
#
#
# ## Timezone Argument
#
# A timezone argument must have `local_to_utc` and `utc_to_local` methods, and
# may have `name`, `abbr`, and `dst?` methods.
#
# The `local_to_utc` method should convert a Time-like object from the timezone
# to UTC, and `utc_to_local` is the opposite.  The result also should be a Time
# or Time-like object (not necessary to be the same class).  The #zone of the
# result is just ignored. Time-like argument to these methods is similar to a
# Time object in UTC without subsecond; it has attribute readers for the parts,
# e.g. #year, #month, and so on, and epoch time readers, #to_i.  The subsecond
# attributes are fixed as 0, and #utc_offset, #zone, #isdst, and their aliases
# are same as a Time object in UTC. Also #to_time, #+, and #- methods are
# defined.
#
# The `name` method is used for marshaling. If this method is not defined on a
# timezone object, Time objects using that timezone object can not be dumped by
# Marshal.
#
# The `abbr` method is used by '%Z' in #strftime.
#
# The `dst?` method is called with a `Time` value and should return whether the
# `Time` value is in daylight savings time in the zone.
#
# ### Auto Conversion to Timezone
#
# At loading marshaled data, a timezone name will be converted to a timezone
# object by `find_timezone` class method, if the method is defined.
#
# Similarly, that class method will be called when a timezone argument does not
# have the necessary methods mentioned above.
#
class Time < Object
  include Comparable

  # <!--
  #   rdoc-file=timev.rb
  #   - at(time, subsec = false, unit = :microsecond, in: nil)
  # -->
  # *Time*
  #
  # This form accepts a Time object `time` and optional keyword argument `in`:
  #
  #     Time.at(Time.new)               # => 2021-04-26 08:52:31.6023486 -0500
  #     Time.at(Time.new, in: '+09:00') # => 2021-04-26 22:52:31.6023486 +0900
  #
  # *Seconds*
  #
  # This form accepts a numeric number of seconds `sec` and optional keyword
  # argument `in`:
  #
  #     Time.at(946702800)               # => 1999-12-31 23:00:00 -0600
  #     Time.at(946702800, in: '+09:00') # => 2000-01-01 14:00:00 +0900
  #
  # *Seconds with Subseconds and Units*
  #
  # This form accepts an integer number of seconds `sec_i`, a numeric number of
  # milliseconds `msec`, a symbol argument for the subsecond unit type (defaulting
  # to :usec), and an optional keyword argument `in`:
  #
  #     Time.at(946702800, 500, :millisecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500, :millisecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000)                             # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, :usec)                      # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, :microsecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, in: '+09:00')               # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000, :usec, in: '+09:00')        # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000, :microsecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000000, :nsec)                     # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000000, :nanosecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000000, :nsec, in: '+09:00')       # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000000, :nanosecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #
  # Parameters:
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `msec` is the number of milliseconds (Integer, Float, or Rational) in the
  #     range `0..1000`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  # *   `nsec` is the number of nanoseconds (Integer, Float, or Rational) in the
  #     range `0..1000000000`.
  # *   `in: zone`: a timezone *zone*, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  def self.at: (Time, ?in: String | Integer | nil) -> Time
             | (Numeric, ?in: String | Integer | nil) -> Time
             | (Integer sec_i, Numeric msec, subsec_unit msec, ?in: String | Integer | nil) -> Time

  type subsec_unit = :msec | :millisecond | :usec | :microsecond | :nsec | :nanosecond

  # Creates a Time object based on given values, interpreted as UTC (GMT). The
  # year must be specified. Other values default to the minimum value for that
  # field (and may be `nil` or omitted). Months may be specified by numbers from 1
  # to 12, or by the three-letter English month names. Hours are specified on a
  # 24-hour clock (0..23). Raises an ArgumentError if any values are out of range.
  # Will also accept ten arguments in the order output by Time#to_a.
  #
  # `sec_with_frac` and `usec_with_frac` can have a fractional part.
  #
  #     Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
  #     Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #
  def self.gm: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.local(year, month=1, day=1, hour=0, min=0, sec_i=0, usec=0) -> new_time
  #   - Time.local(sec, min, hour, day, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Returns a new Time object based the on given arguments; its timezone is the
  # local timezone.
  #
  # In the first form (up to seven arguments), argument `year` is required.
  #
  #     Time.local(2000)                   # => 2000-01-01 00:00:00 -0600
  #     Time.local(0, 1, 2, 3, 4, 5, 6.5)  # => 0000-01-02 03:04:05.0000065 -0600
  #
  # In the second form, all ten arguments are required, though the last four are
  # ignored. This form is useful for creating a time from a 10-element array such
  # as those returned by #to_a.
  #
  #     array = Time.now.to_a
  #     p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
  #     array[5] = 2000
  #     Time.local(*array)  # => 2000-04-24 13:26:57 -0500
  #
  # Parameters:
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  #
  #
  # Alias: Time.mktime.
  #
  # Related: Time.utc.
  #
  def self.local: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=timev.rb
  #   - now(in: nil)
  # -->
  # Creates a new Time object from the current system time. This is the same as
  # Time.new without arguments.
  #
  #     Time.now               # => 2009-06-24 12:39:54 +0900
  #     Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400
  #
  # Parameter:
  # *   `in: zone`: a timezone *zone*, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  def self.now: (?in: String | Integer | nil) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.utc(year, month=1, day=1, hour=0, min=0, sec_i=0, usec=0) -> new_time
  #   - Time.utc(sec_i, min, hour, day, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Returns a new Time object based the on given arguments; its timezone is UTC.
  #
  # In the first form (up to seven arguments), argument `year` is required.
  #
  #     Time.utc(2000)                  # => 2000-01-01 00:00:00 UTC
  #     Time.utc(0, 1, 2, 3, 4, 5, 6.5) # => 0000-01-02 03:04:05.0000065 UTC
  #
  # In the second form, all ten arguments are required, though the last four are
  # ignored. This form is useful for creating a time from a 10-element array such
  # as is returned by #to_a.
  #
  #     array = Time.now.to_a
  #     p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
  #     array[5] = 2000
  #     Time.utc(*array) # => 2000-04-24 13:26:57 UTC
  #
  # Parameters:
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  #
  #
  # Alias: Time.gm.
  #
  # Related: Time.local.
  #
  def self.utc: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time + numeric -> time
  # -->
  # Adds some number of seconds (possibly including subsecond) to *time* and
  # returns that value as a new Time object.
  #
  #     t = Time.now         #=> 2020-07-20 22:14:43.170490982 +0900
  #     t + (60 * 60 * 24)   #=> 2020-07-21 22:14:43.170490982 +0900
  #
  def +: (Numeric arg0) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time - other_time -> float
  #   - time - numeric    -> time
  # -->
  # Returns a difference in seconds as a Float between *time* and `other_time`, or
  # subtracts the given number of seconds in `numeric` from *time*.
  #
  #     t = Time.now       #=> 2020-07-20 22:15:49.302766336 +0900
  #     t2 = t + 2592000   #=> 2020-08-19 22:15:49.302766336 +0900
  #     t2 - t             #=> 2592000.0
  #     t2 - 2592000       #=> 2020-07-20 22:15:49.302766336 +0900
  #
  def -: (Time arg0) -> Float
       | (Numeric arg0) -> Time

  def <: (Time arg0) -> bool

  def <=: (Time arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time <=> other_time -> -1, 0, +1, or nil
  # -->
  # Compares `time` with `other_time`.
  #
  # -1, 0, +1 or nil depending on whether `time` is less than, equal to, or
  # greater than `other_time`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  #     t = Time.now       #=> 2007-11-19 08:12:12 -0600
  #     t2 = t + 2592000   #=> 2007-12-19 08:12:12 -0600
  #     t <=> t2           #=> -1
  #     t2 <=> t           #=> 1
  #
  #     t = Time.now       #=> 2007-11-19 08:13:38 -0600
  #     t2 = t + 0.1       #=> 2007-11-19 08:13:38 -0600
  #     t.nsec             #=> 98222999
  #     t2.nsec            #=> 198222999
  #     t <=> t2           #=> -1
  #     t2 <=> t           #=> 1
  #     t <=> t            #=> 0
  #
  def <=>: (Time other) -> Integer
         | (untyped other) -> Integer?

  def >: (Time arg0) -> bool

  def >=: (Time arg0) -> bool

  # <!-- rdoc-file=time.c -->
  # Returns a canonical string representation of *time*.
  #
  #     Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
  #     Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"
  #
  def asctime: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.asctime -> string
  #   - time.ctime   -> string
  # -->
  # Returns a canonical string representation of *time*.
  #
  #     Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
  #     Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"
  #
  def ctime: () -> String

  # <!-- rdoc-file=time.c -->
  # Returns the day of the month (1..31) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:03 -0600
  #     t.day          #=> 19
  #     t.mday         #=> 19
  #
  def day: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns `true` if *time* occurs during Daylight Saving Time in its time zone.
  #
  #     # CST6CDT:
  #       Time.local(2000, 1, 1).zone    #=> "CST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "CDT"
  #       Time.local(2000, 7, 1).isdst   #=> true
  #       Time.local(2000, 7, 1).dst?    #=> true
  #
  #     # Asia/Tokyo:
  #       Time.local(2000, 1, 1).zone    #=> "JST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "JST"
  #       Time.local(2000, 7, 1).isdst   #=> false
  #       Time.local(2000, 7, 1).dst?    #=> false
  #
  def dst?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.eql?(other_time)
  # -->
  # Returns `true` if *time* and `other_time` are both Time objects with the same
  # seconds (including subsecond) from the Epoch.
  #
  def eql?: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.friday? -> true or false
  # -->
  # Returns `true` if *time* represents Friday.
  #
  #     t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600
  #     t.friday?                        #=> true
  #
  def friday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.getgm  -> new_time
  #   - time.getutc -> new_time
  # -->
  # Returns a new Time object representing *time* in UTC.
  #
  #     t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #     t.gmt?                             #=> false
  #     y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
  #     y.gmt?                             #=> true
  #     t == y                             #=> true
  #
  def getgm: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.getlocal -> new_time
  #   - time.getlocal(utc_offset) -> new_time
  #   - time.getlocal(timezone) -> new_time
  # -->
  # Returns a new Time object representing *time* in local time (using the local
  # time zone in effect for this process).
  #
  # If `utc_offset` is given, it is used instead of the local time. `utc_offset`
  # can be given as a human-readable string (eg. `"+09:00"`) or as a number of
  # seconds (eg. `32400`).
  #
  #     t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                          #=> true
  #
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.utc?                          #=> false
  #     t == l                          #=> true
  #
  #     j = t.getlocal("+09:00")        #=> 2000-01-02 05:15:01 +0900
  #     j.utc?                          #=> false
  #     t == j                          #=> true
  #
  #     k = t.getlocal(9*60*60)         #=> 2000-01-02 05:15:01 +0900
  #     k.utc?                          #=> false
  #     t == k                          #=> true
  #
  def getlocal: (?Integer utc_offset) -> Time

  # <!-- rdoc-file=time.c -->
  # Returns a new Time object representing *time* in UTC.
  #
  #     t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #     t.gmt?                             #=> false
  #     y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
  #     y.gmt?                             #=> true
  #     t == y                             #=> true
  #
  def getutc: () -> Time

  # <!-- rdoc-file=time.c -->
  # Returns `true` if *time* represents a time in UTC (GMT).
  #
  #     t = Time.now                        #=> 2007-11-19 08:15:23 -0600
  #     t.utc?                              #=> false
  #     t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                              #=> true
  #
  #     t = Time.now                        #=> 2007-11-19 08:16:03 -0600
  #     t.gmt?                              #=> false
  #     t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
  #     t.gmt?                              #=> true
  #
  def gmt?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def gmt_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.gmtime    -> time
  #   - time.utc       -> time
  # -->
  # Converts *time* to UTC (GMT), modifying the receiver.
  #
  #     t = Time.now   #=> 2007-11-19 08:18:31 -0600
  #     t.gmt?         #=> false
  #     t.gmtime       #=> 2007-11-19 14:18:31 UTC
  #     t.gmt?         #=> true
  #
  #     t = Time.now   #=> 2007-11-19 08:18:51 -0600
  #     t.utc?         #=> false
  #     t.utc          #=> 2007-11-19 14:18:51 UTC
  #     t.utc?         #=> true
  #
  def gmtime: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.hash   -> integer
  # -->
  # Returns a hash code for this Time object.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.hour -> integer
  # -->
  # Returns the hour of the day (0..23) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:26:20 -0600
  #     t.hour         #=> 8
  #
  def hour: () -> Integer

  # <!--
  #   rdoc-file=timev.rb
  #   - new(year = (now = true), mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil)
  # -->
  # Returns a new Time object based on the given arguments.
  #
  # With no positional arguments, returns the value of Time.now:
  #
  #     Time.new                                       # => 2021-04-24 17:27:46.0512465 -0500
  #
  # Otherwise, returns a new Time object based on the given parameters:
  #
  #     Time.new(2000)                                 # => 2000-01-01 00:00:00 -0600
  #     Time.new(2000, 12, 31, 23, 59, 59.5)           # => 2000-12-31 23:59:59.5 -0600
  #     Time.new(2000, 12, 31, 23, 59, 59.5, '+09:00') # => 2000-12-31 23:59:59.5 +0900
  #
  # Parameters:
  #
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `sec` is the number of seconds (Integer, Float, or Rational) in the range
  #     `0..60`.
  # *   `zone`: a timezone, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  # *   `in: zone`: a timezone *zone*, which may be as above.
  #
  def initialize: (?Integer? year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, ?String | Integer | nil) -> void
                | (?Integer? year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, in: String | Integer | nil) -> void

  # <!--
  #   rdoc-file=time.c
  #   - time.inspect -> string
  # -->
  # Returns a detailed string representing *time*. Unlike to_s, preserves
  # subsecond in the representation for easier debugging.
  #
  #     t = Time.now
  #     t.inspect                             #=> "2012-11-10 18:16:12.261257655 +0100"
  #     t.strftime "%Y-%m-%d %H:%M:%S.%N %z"  #=> "2012-11-10 18:16:12.261257655 +0100"
  #
  #     t.utc.inspect                          #=> "2012-11-10 17:16:12.261257655 UTC"
  #     t.strftime "%Y-%m-%d %H:%M:%S.%N UTC"  #=> "2012-11-10 17:16:12.261257655 UTC"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.isdst -> true or false
  #   - time.dst?  -> true or false
  # -->
  # Returns `true` if *time* occurs during Daylight Saving Time in its time zone.
  #
  #     # CST6CDT:
  #       Time.local(2000, 1, 1).zone    #=> "CST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "CDT"
  #       Time.local(2000, 7, 1).isdst   #=> true
  #       Time.local(2000, 7, 1).dst?    #=> true
  #
  #     # Asia/Tokyo:
  #       Time.local(2000, 1, 1).zone    #=> "JST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "JST"
  #       Time.local(2000, 7, 1).isdst   #=> false
  #       Time.local(2000, 7, 1).dst?    #=> false
  #
  def isdst: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.localtime -> time
  #   - time.localtime(utc_offset) -> time
  # -->
  # Converts *time* to local time (using the local time zone in effect at the
  # creation time of *time*) modifying the receiver.
  #
  # If `utc_offset` is given, it is used instead of the local time.
  #
  #     t = Time.utc(2000, "jan", 1, 20, 15, 1) #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                                  #=> true
  #
  #     t.localtime                             #=> 2000-01-01 14:15:01 -0600
  #     t.utc?                                  #=> false
  #
  #     t.localtime("+09:00")                   #=> 2000-01-02 05:15:01 +0900
  #     t.utc?                                  #=> false
  #
  # If `utc_offset` is not given and *time* is local time, just returns the
  # receiver.
  #
  def localtime: (?String utc_offset) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.day  -> integer
  #   - time.mday -> integer
  # -->
  # Returns the day of the month (1..31) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:03 -0600
  #     t.day          #=> 19
  #     t.mday         #=> 19
  #
  def mday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.min -> integer
  # -->
  # Returns the minute of the hour (0..59) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:25:51 -0600
  #     t.min          #=> 25
  #
  def min: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.mon   -> integer
  #   - time.month -> integer
  # -->
  # Returns the month of the year (1..12) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:30 -0600
  #     t.mon          #=> 11
  #     t.month        #=> 11
  #
  def mon: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.monday? -> true or false
  # -->
  # Returns `true` if *time* represents Monday.
  #
  #     t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500
  #     t.monday?                        #=> true
  #
  def monday?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the number of nanoseconds for the subsecond part of *time*. The result
  # is a non-negative integer less than 10**9.
  #
  #     t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
  #     t.nsec              #=> 963933942
  #
  # If *time* has fraction of nanosecond (such as picoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.nsec              #=> 666777888
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def nsec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.round([ndigits])   -> new_time
  # -->
  # Rounds subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.123456789r)
  #     t                       #=> 2010-03-30 05:43:25.123456789 UTC
  #     t.round                 #=> 2010-03-30 05:43:25 UTC
  #     t.round(0)              #=> 2010-03-30 05:43:25 UTC
  #     t.round(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.round(2)              #=> 2010-03-30 05:43:25.12 UTC
  #     t.round(3)              #=> 2010-03-30 05:43:25.123 UTC
  #     t.round(4)              #=> 2010-03-30 05:43:25.1235 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).round         #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.49).round        #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.5).round         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.4).round         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.49).round        #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.5).round         #=> 2000-01-01 00:00:01 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)     #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.123456789).round(4).iso8601(6)  #=> 1999-12-31 23:59:59.1235 UTC
  #
  def round: (?Integer arg0) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.saturday? -> true or false
  # -->
  # Returns `true` if *time* represents Saturday.
  #
  #     t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500
  #     t.saturday?                      #=> true
  #
  def saturday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.sec -> integer
  # -->
  # Returns the second of the minute (0..60) for *time*.
  #
  # **Note:** Seconds range from zero to 60 to allow the system to inject leap
  # seconds. See https://en.wikipedia.org/wiki/Leap_second for further details.
  #
  #     t = Time.now   #=> 2007-11-19 08:25:02 -0600
  #     t.sec          #=> 2
  #
  def sec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.strftime( string ) -> string
  # -->
  # Formats *time* according to the directives in the given format string.
  #
  # The directives begin with a percent (%) character. Any text not listed as a
  # directive will be passed through to the output string.
  #
  # The directive consists of a percent (%) character, zero or more flags,
  # optional minimum field width, optional modifier and a conversion specifier as
  # follows:
  #
  #     %<flags><width><modifier><conversion>
  #
  # Flags:
  #     -  don't pad a numerical output
  #     _  use spaces for padding
  #     0  use zeros for padding
  #     ^  upcase the result string
  #     #  change case
  #     :  use colons for %z
  #
  # The minimum field width specifies the minimum width.
  #
  # The modifiers are "E" and "O". They are ignored.
  #
  # Format directives:
  #
  #     Date (Year, Month, Day):
  #       %Y - Year with century if provided, will pad result at least 4 digits.
  #               -0001, 0000, 1995, 2009, 14292, etc.
  #       %C - year / 100 (rounded down such as 20 in 2009)
  #       %y - year % 100 (00..99)
  #
  #       %m - Month of the year, zero-padded (01..12)
  #               %_m  blank-padded ( 1..12)
  #               %-m  no-padded (1..12)
  #       %B - The full month name (``January'')
  #               %^B  uppercased (``JANUARY'')
  #       %b - The abbreviated month name (``Jan'')
  #               %^b  uppercased (``JAN'')
  #       %h - Equivalent to %b
  #
  #       %d - Day of the month, zero-padded (01..31)
  #               %-d  no-padded (1..31)
  #       %e - Day of the month, blank-padded ( 1..31)
  #
  #       %j - Day of the year (001..366)
  #
  #     Time (Hour, Minute, Second, Subsecond):
  #       %H - Hour of the day, 24-hour clock, zero-padded (00..23)
  #       %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
  #       %I - Hour of the day, 12-hour clock, zero-padded (01..12)
  #       %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
  #       %P - Meridian indicator, lowercase (``am'' or ``pm'')
  #       %p - Meridian indicator, uppercase (``AM'' or ``PM'')
  #
  #       %M - Minute of the hour (00..59)
  #
  #       %S - Second of the minute (00..60)
  #
  #       %L - Millisecond of the second (000..999)
  #            The digits under millisecond are truncated to not produce 1000.
  #       %N - Fractional seconds digits, default is 9 digits (nanosecond)
  #               %3N  millisecond (3 digits)
  #               %6N  microsecond (6 digits)
  #               %9N  nanosecond (9 digits)
  #               %12N picosecond (12 digits)
  #               %15N femtosecond (15 digits)
  #               %18N attosecond (18 digits)
  #               %21N zeptosecond (21 digits)
  #               %24N yoctosecond (24 digits)
  #            The digits under the specified length are truncated to avoid
  #            carry up.
  #
  #     Time zone:
  #       %z - Time zone as hour and minute offset from UTC (e.g. +0900)
  #               %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
  #               %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
  #       %Z - Abbreviated time zone name or similar information.  (OS dependent)
  #
  #     Weekday:
  #       %A - The full weekday name (``Sunday'')
  #               %^A  uppercased (``SUNDAY'')
  #       %a - The abbreviated name (``Sun'')
  #               %^a  uppercased (``SUN'')
  #       %u - Day of the week (Monday is 1, 1..7)
  #       %w - Day of the week (Sunday is 0, 0..6)
  #
  #     ISO 8601 week-based year and week number:
  #     The first week of YYYY starts with a Monday and includes YYYY-01-04.
  #     The days in the year before the first week are in the last week of
  #     the previous year.
  #       %G - The week-based year
  #       %g - The last 2 digits of the week-based year (00..99)
  #       %V - Week number of the week-based year (01..53)
  #
  #     Week number:
  #     The first week of YYYY that starts with a Sunday or Monday (according to %U
  #     or %W). The days in the year before the first week are in week 0.
  #       %U - Week number of the year. The week starts with Sunday. (00..53)
  #       %W - Week number of the year. The week starts with Monday. (00..53)
  #
  #     Seconds since the Epoch:
  #       %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #
  #     Literal string:
  #       %n - Newline character (\n)
  #       %t - Tab character (\t)
  #       %% - Literal ``%'' character
  #
  #     Combination:
  #       %c - date and time (%a %b %e %T %Y)
  #       %D - Date (%m/%d/%y)
  #       %F - The ISO 8601 date format (%Y-%m-%d)
  #       %v - VMS date (%e-%^b-%4Y)
  #       %x - Same as %D
  #       %X - Same as %T
  #       %r - 12-hour time (%I:%M:%S %p)
  #       %R - 24-hour time (%H:%M)
  #       %T - 24-hour time (%H:%M:%S)
  #
  # This method is similar to strftime() function defined in ISO C and POSIX.
  #
  # While all directives are locale independent since Ruby 1.9, %Z is platform
  # dependent. So, the result may differ even if the same format string is used in
  # other systems such as C.
  #
  # %z is recommended over %Z. %Z doesn't identify the timezone. For example,
  # "CST" is used at America/Chicago (-06:00), America/Havana (-05:00),
  # Asia/Harbin (+08:00), Australia/Darwin (+09:30) and Australia/Adelaide
  # (+10:30). Also, %Z is highly dependent on the operating system. For example,
  # it may generate a non ASCII string on Japanese Windows, i.e. the result can be
  # different to "JST". So the numeric time zone offset, %z, is recommended.
  #
  # Examples:
  #
  #     t = Time.new(2007,11,19,8,37,48,"-06:00") #=> 2007-11-19 08:37:48 -0600
  #     t.strftime("Printed on %m/%d/%Y")         #=> "Printed on 11/19/2007"
  #     t.strftime("at %I:%M %p")                 #=> "at 08:37 AM"
  #
  # Various ISO 8601 formats:
  #     %Y%m%d           => 20071119                  Calendar date (basic)
  #     %F               => 2007-11-19                Calendar date (extended)
  #     %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
  #     %Y               => 2007                      Calendar date, reduced accuracy, specific year
  #     %C               => 20                        Calendar date, reduced accuracy, specific century
  #     %Y%j             => 2007323                   Ordinal date (basic)
  #     %Y-%j            => 2007-323                  Ordinal date (extended)
  #     %GW%V%u          => 2007W471                  Week date (basic)
  #     %G-W%V-%u        => 2007-W47-1                Week date (extended)
  #     %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
  #     %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
  #     %H%M%S           => 083748                    Local time (basic)
  #     %T               => 08:37:48                  Local time (extended)
  #     %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
  #     %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
  #     %H               => 08                        Local time, reduced accuracy, specific hour
  #     %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
  #     %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
  #     %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
  #     %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
  #     %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
  #     %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
  #     %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
  #     %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
  #     %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
  #     %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
  #     %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
  #     %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
  #     %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
  #     %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
  #     %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
  #     %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
  #     %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
  #     %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)
  #
  def strftime: (String arg0) -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.subsec    -> number
  # -->
  # Returns the subsecond for *time*.
  #
  # The return value can be a rational number.
  #
  #     t = Time.now        #=> 2020-07-20 15:40:26.867462289 +0900
  #     t.subsec            #=> (867462289/1000000000)
  #
  #     t = Time.now        #=> 2020-07-20 15:40:50.313828595 +0900
  #     t.subsec            #=> (62765719/200000000)
  #
  #     t = Time.new(2000,1,1,2,3,4) #=> 2000-01-01 02:03:04 +0900
  #     t.subsec                     #=> 0
  #
  #     Time.new(2000,1,1,0,0,1/3r,"UTC").subsec #=> (1/3)
  #
  def subsec: () -> Numeric

  # <!--
  #   rdoc-file=time.c
  #   - time.sunday? -> true or false
  # -->
  # Returns `true` if *time* represents Sunday.
  #
  #     t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600
  #     t.sunday?                        #=> true
  #
  def sunday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.thursday? -> true or false
  # -->
  # Returns `true` if *time* represents Thursday.
  #
  #     t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600
  #     t.thursday?                      #=> true
  #
  def thursday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.to_a -> array
  # -->
  # Returns a ten-element *array* of values for *time*:
  #
  #     [sec, min, hour, day, month, year, wday, yday, isdst, zone]
  #
  # See the individual methods for an explanation of the valid ranges of each
  # value. The ten elements can be passed directly to Time.utc or Time.local to
  # create a new Time object.
  #
  #     t = Time.now     #=> 2007-11-19 08:36:01 -0600
  #     now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, "CST"]
  #
  def to_a: () -> [ Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, bool, String ]

  # <!--
  #   rdoc-file=time.c
  #   - time.to_f -> float
  # -->
  # Returns the value of *time* as a floating point number of seconds since the
  # Epoch. The return value approximate the exact value in the Time object because
  # floating point numbers cannot represent all rational numbers exactly.
  #
  #     t = Time.now        #=> 2020-07-20 22:00:29.38740268 +0900
  #     t.to_f              #=> 1595250029.3874028
  #     t.to_i              #=> 1595250029
  #
  # Note that IEEE 754 double is not accurate enough to represent the exact number
  # of nanoseconds since the Epoch. (IEEE 754 double has 53bit mantissa. So it can
  # represent exact number of nanoseconds only in `2 ** 53 / 1_000_000_000 / 60 /
  # 60 / 24 = 104.2` days.) When Ruby uses a nanosecond-resolution clock function,
  # such as `clock_gettime` of POSIX, to obtain the current time, Time#to_f can
  # lose information of a Time object created with `Time.now`.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=time.c
  #   - time.to_i   -> int
  #   - time.tv_sec -> int
  # -->
  # Returns the value of *time* as an integer number of seconds since the Epoch.
  #
  # If *time* contains subsecond, they are truncated.
  #
  #     t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
  #     t.to_i              #=> 1595263289
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.to_r -> a_rational
  # -->
  # Returns the value of *time* as a rational number of seconds since the Epoch.
  #
  #     t = Time.now      #=> 2020-07-20 22:03:45.212167333 +0900
  #     t.to_r            #=> (1595250225212167333/1000000000)
  #
  # This method is intended to be used to get an accurate value representing the
  # seconds (including subsecond) since the Epoch.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=time.c
  #   - time.to_s    -> string
  # -->
  # Returns a string representing *time*. Equivalent to calling #strftime with the
  # appropriate format string.
  #
  #     t = Time.now
  #     t.to_s                              #=> "2012-11-10 18:16:12 +0100"
  #     t.strftime "%Y-%m-%d %H:%M:%S %z"   #=> "2012-11-10 18:16:12 +0100"
  #
  #     t.utc.to_s                          #=> "2012-11-10 17:16:12 UTC"
  #     t.strftime "%Y-%m-%d %H:%M:%S UTC"  #=> "2012-11-10 17:16:12 UTC"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.tuesday? -> true or false
  # -->
  # Returns `true` if *time* represents Tuesday.
  #
  #     t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600
  #     t.tuesday?                       #=> true
  #
  def tuesday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.nsec    -> int
  #   - time.tv_nsec -> int
  # -->
  # Returns the number of nanoseconds for the subsecond part of *time*. The result
  # is a non-negative integer less than 10**9.
  #
  #     t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
  #     t.nsec              #=> 963933942
  #
  # If *time* has fraction of nanosecond (such as picoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.nsec              #=> 666777888
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def tv_nsec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Returns the value of *time* as an integer number of seconds since the Epoch.
  #
  # If *time* contains subsecond, they are truncated.
  #
  #     t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
  #     t.to_i              #=> 1595263289
  #
  def tv_sec: () -> Numeric

  # <!--
  #   rdoc-file=time.c
  #   - time.usec    -> int
  #   - time.tv_usec -> int
  # -->
  # Returns the number of microseconds for the subsecond part of *time*. The
  # result is a non-negative integer less than 10**6.
  #
  #     t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
  #     t.usec              #=> 459785
  #
  # If *time* has fraction of microsecond (such as nanoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.usec              #=> 666777
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def tv_usec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Returns the number of microseconds for the subsecond part of *time*. The
  # result is a non-negative integer less than 10**6.
  #
  #     t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
  #     t.usec              #=> 459785
  #
  # If *time* has fraction of microsecond (such as nanoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.usec              #=> 666777
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def usec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Converts *time* to UTC (GMT), modifying the receiver.
  #
  #     t = Time.now   #=> 2007-11-19 08:18:31 -0600
  #     t.gmt?         #=> false
  #     t.gmtime       #=> 2007-11-19 14:18:31 UTC
  #     t.gmt?         #=> true
  #
  #     t = Time.now   #=> 2007-11-19 08:18:51 -0600
  #     t.utc?         #=> false
  #     t.utc          #=> 2007-11-19 14:18:51 UTC
  #     t.utc?         #=> true
  #
  def utc: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.utc? -> true or false
  #   - time.gmt? -> true or false
  # -->
  # Returns `true` if *time* represents a time in UTC (GMT).
  #
  #     t = Time.now                        #=> 2007-11-19 08:15:23 -0600
  #     t.utc?                              #=> false
  #     t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                              #=> true
  #
  #     t = Time.now                        #=> 2007-11-19 08:16:03 -0600
  #     t.gmt?                              #=> false
  #     t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
  #     t.gmt?                              #=> true
  #
  def utc?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def utc_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.wday -> integer
  # -->
  # Returns an integer representing the day of the week, 0..6, with Sunday == 0.
  #
  #     t = Time.now   #=> 2007-11-20 02:35:35 -0600
  #     t.wday         #=> 2
  #     t.sunday?      #=> false
  #     t.monday?      #=> false
  #     t.tuesday?     #=> true
  #     t.wednesday?   #=> false
  #     t.thursday?    #=> false
  #     t.friday?      #=> false
  #     t.saturday?    #=> false
  #
  def wday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.wednesday? -> true or false
  # -->
  # Returns `true` if *time* represents Wednesday.
  #
  #     t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600
  #     t.wednesday?                     #=> true
  #
  def wednesday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.yday -> integer
  # -->
  # Returns an integer representing the day of the year, 1..366.
  #
  #     t = Time.now   #=> 2007-11-19 08:32:31 -0600
  #     t.yday         #=> 323
  #
  def yday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.year -> integer
  # -->
  # Returns the year for *time* (including the century).
  #
  #     t = Time.now   #=> 2007-11-19 08:27:51 -0600
  #     t.year         #=> 2007
  #
  def year: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.zone -> string or timezone
  # -->
  # Returns the name of the time zone used for *time*. As of Ruby 1.8, returns
  # ``UTC'' rather than ``GMT'' for UTC times.
  #
  #     t = Time.gm(2000, "jan", 1, 20, 15, 1)
  #     t.zone   #=> "UTC"
  #     t = Time.local(2000, "jan", 1, 20, 15, 1)
  #     t.zone   #=> "CST"
  #
  def zone: () -> String

  # Same as Time::gm, but interprets the values in the local time zone.
  #
  #     Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #
  def self.mktime: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.gmt_offset -> integer
  #   - time.gmtoff     -> integer
  #   - time.utc_offset -> integer
  # -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def gmtoff: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns the month of the year (1..12) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:30 -0600
  #     t.mon          #=> 11
  #     t.month        #=> 11
  #
  def month: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.floor([ndigits])   -> new_time
  # -->
  # Floors subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.123456789r)
  #     t                       #=> 2010-03-30 05:43:25.123456789 UTC
  #     t.floor                 #=> 2010-03-30 05:43:25 UTC
  #     t.floor(0)              #=> 2010-03-30 05:43:25 UTC
  #     t.floor(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.floor(2)              #=> 2010-03-30 05:43:25.12 UTC
  #     t.floor(3)              #=> 2010-03-30 05:43:25.123 UTC
  #     t.floor(4)              #=> 2010-03-30 05:43:25.1234 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).floor    #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.9).floor    #=> 1999-12-31 23:59:59 UTC
  #     (t + 1.4).floor    #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.9).floor    #=> 2000-01-01 00:00:00 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.123456789).floor(4)  #=> 1999-12-31 23:59:59.1234 UTC
  #
  def floor: (?Integer ndigits) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.ceil([ndigits])   -> new_time
  # -->
  # Ceils subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.0123456789r)
  #     t                      #=> 2010-03-30 05:43:25 123456789/10000000000 UTC
  #     t.ceil                 #=> 2010-03-30 05:43:26 UTC
  #     t.ceil(0)              #=> 2010-03-30 05:43:26 UTC
  #     t.ceil(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.ceil(2)              #=> 2010-03-30 05:43:25.02 UTC
  #     t.ceil(3)              #=> 2010-03-30 05:43:25.013 UTC
  #     t.ceil(4)              #=> 2010-03-30 05:43:25.0124 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).ceil         #=> 2000-01-01 00:00:00 UTC
  #     (t + 0.9).ceil         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.4).ceil         #=> 2000-01-01 00:00:01 UTC
  #     (t + 1.9).ceil         #=> 2000-01-01 00:00:01 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.123456789).ceil(4)  #=> 1999-12-31 23:59:59.1235 UTC
  #
  def ceil: (?Integer ndigits) -> Time
end

Time::RFC2822_DAY_NAME: Array[String]

Time::RFC2822_MONTH_NAME: Array[String]

# <!-- rdoc-file=random.c -->
# Random provides an interface to Ruby's pseudo-random number generator, or
# PRNG.  The PRNG produces a deterministic sequence of bits which approximate
# true randomness. The sequence may be represented by integers, floats, or
# binary strings.
#
# The generator may be initialized with either a system-generated or
# user-supplied seed value by using Random.srand.
#
# The class method Random.rand provides the base functionality of Kernel.rand
# along with better handling of floating point values. These are both interfaces
# to the Ruby system PRNG.
#
# Random.new will create a new PRNG with a state independent of the Ruby system
# PRNG, allowing multiple generators with different seed values or sequence
# positions to exist simultaneously. Random objects can be marshaled, allowing
# sequences to be saved and resumed.
#
# PRNGs are currently implemented as a modified Mersenne Twister with a period
# of 2**19937-1.  As this algorithm is *not* for cryptographical use, you must
# use SecureRandom for security purpose, instead of this PRNG.
#
class Random < Object
  include Random::Formatter

  # <!--
  #   rdoc-file=random.c
  #   - prng1 == prng2 -> true or false
  # -->
  # Returns true if the two generators have the same internal state, otherwise
  # false.  Equivalent generators will return the same sequence of pseudo-random
  # numbers.  Two generators will generally have the same state only if they were
  # initialized with the same seed
  #
  #     Random.new == Random.new             # => false
  #     Random.new(1234) == Random.new(1234) # => true
  #
  # and have the same invocation history.
  #
  #     prng1 = Random.new(1234)
  #     prng2 = Random.new(1234)
  #     prng1 == prng2 # => true
  #
  #     prng1.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => false
  #
  #     prng2.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => true
  #
  def ==: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=random.c
  #   - prng.bytes(size) -> string
  # -->
  # Returns a random binary string containing `size` bytes.
  #
  #     random_string = Random.new.bytes(10) # => "\xD7:R\xAB?\x83\xCE\xFAkO"
  #     random_string.size                   # => 10
  #
  def bytes: (Integer size) -> String

  # <!--
  #   rdoc-file=random.c
  #   - Random.new(seed = Random.new_seed) -> prng
  # -->
  # Creates a new PRNG using `seed` to set the initial state. If `seed` is
  # omitted, the generator is initialized with Random.new_seed.
  #
  # See Random.srand for more information on the use of seed values.
  #
  def initialize: (?Integer seed) -> void

  # <!--
  #   rdoc-file=random.c
  #   - prng.rand -> float
  #   - prng.rand(max) -> number
  #   - prng.rand(range) -> number
  # -->
  # When `max` is an Integer, `rand` returns a random integer greater than or
  # equal to zero and less than `max`. Unlike Kernel.rand, when `max` is a
  # negative integer or zero, `rand` raises an ArgumentError.
  #
  #     prng = Random.new
  #     prng.rand(100)       # => 42
  #
  # When `max` is a Float, `rand` returns a random floating point number between
  # 0.0 and `max`, including 0.0 and excluding `max`.
  #
  #     prng.rand(1.5)       # => 1.4600282860034115
  #
  # When `range` is a Range, `rand` returns a random number where
  # `range.member?(number) == true`.
  #
  #     prng.rand(5..9)      # => one of [5, 6, 7, 8, 9]
  #     prng.rand(5...9)     # => one of [5, 6, 7, 8]
  #     prng.rand(5.0..9.0)  # => between 5.0 and 9.0, including 9.0
  #     prng.rand(5.0...9.0) # => between 5.0 and 9.0, excluding 9.0
  #
  # Both the beginning and ending values of the range must respond to subtract
  # (`-`) and add (`+`)methods, or rand will raise an ArgumentError.
  #
  def rand: () -> Float
          | (Integer | ::Range[Integer] max) -> Integer
          | (Float | ::Range[Float] max) -> Float

  # <!--
  #   rdoc-file=random.c
  #   - prng.seed -> integer
  # -->
  # Returns the seed value used to initialize the generator. This may be used to
  # initialize another generator with the same state at a later time, causing it
  # to produce the same sequence of numbers.
  #
  #     prng1 = Random.new(1234)
  #     prng1.seed       #=> 1234
  #     prng1.rand(100)  #=> 47
  #
  #     prng2 = Random.new(prng1.seed)
  #     prng2.rand(100)  #=> 47
  #
  def seed: () -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.new_seed -> integer
  # -->
  # Returns an arbitrary seed value. This is used by Random.new when no seed value
  # is specified as an argument.
  #
  #     Random.new_seed  #=> 115032730400174366788466674494640623225
  #
  def self.new_seed: () -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.rand -> float
  #   - Random.rand(max) -> number
  #   - Random.rand(range) -> number
  # -->
  # Returns a random number using the Ruby system PRNG.
  #
  # See also Random#rand.
  #
  def self.rand: () -> Float
               | (Integer | ::Range[Integer] max) -> Integer
               | (Float | ::Range[Float] max) -> Float

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self.srand: (?Integer number) -> Integer
end

Random::DEFAULT: Random

# <!-- rdoc-file=lib/random/formatter.rb -->
# ## Random number formatter.
#
# Formats generated random numbers in many manners.
#
# ### Examples
#
# Generate random hexadecimal strings:
#
#     require 'random/formatter'
#
#     prng.hex(10) #=> "52750b30ffbc7de3b362"
#     prng.hex(10) #=> "92b15d6c8dc4beb5f559"
#     prng.hex(13) #=> "39b290146bea6ce975c37cfc23"
#
# Generate random base64 strings:
#
#     prng.base64(10) #=> "EcmTPZwWRAozdA=="
#     prng.base64(10) #=> "KO1nIU+p9DKxGg=="
#     prng.base64(12) #=> "7kJSM/MzBJI+75j8"
#
# Generate random binary strings:
#
#     prng.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
#     prng.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"
#
# Generate alphanumeric strings:
#
#     prng.alphanumeric(10) #=> "S8baxMJnPl"
#     prng.alphanumeric(10) #=> "aOxAg8BAJe"
#
# Generate UUIDs:
#
#     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
#     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
#
# <!-- rdoc-file=random.c -->
# Generate a random number in the given range as Random does
#
#     prng.random_number       #=> 0.5816771641321361
#     prng.random_number(1000) #=> 485
#     prng.random_number(1..6) #=> 3
#     prng.rand                #=> 0.5816771641321361
#     prng.rand(1000)          #=> 485
#     prng.rand(1..6)          #=> 3
#
module Random::Formatter
  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - base64(n=nil)
  # -->
  # Random::Formatter#base64 generates a random base64 string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the result string is about 4/3 of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The result may contain A-Z, a-z, 0-9, "+", "/" and "=".
  #
  #     require 'random/formatter'
  #
  #     prng.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="
  #     prng.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="
  #
  # See RFC 3548 for the definition of base64.
  #
  def base64: (?Integer? n) -> String

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - hex(n=nil)
  # -->
  # Random::Formatter#hex generates a random hexadecimal string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the resulting hexadecimal string is twice of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The result may contain 0-9 and a-f.
  #
  #     require 'random/formatter'
  #
  #     prng.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"
  #     prng.hex #=> "91dc3bfb4de5b11d029d376634589b61"
  #
  def hex: (?Integer? n) -> String

  # <!-- rdoc-file=random.c -->
  # Generates formatted random number from raw random bytes. See Random#rand.
  #
  def rand: () -> Float
          | (?Float? n) -> Float
          | (?Integer? n) -> Integer
          | (?Numeric? n) -> Numeric
          | (?::Range[Float]? n) -> Float
          | (?::Range[Integer]? n) -> Integer
          | (?::Range[Numeric]? n) -> Numeric

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - random_bytes(n=nil)
  # -->
  # Random::Formatter#random_bytes generates a random binary string.
  #
  # The argument *n* specifies the length of the result string.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in future.
  #
  # The result may contain any byte: "x00" - "xff".
  #
  #     require 'random/formatter'
  #
  #     prng.random_bytes #=> "\xD8\\\xE0\xF4\r\xB2\xFC*WM\xFF\x83\x18\xF45\xB6"
  #     prng.random_bytes #=> "m\xDC\xFC/\a\x00Uf\xB2\xB2P\xBD\xFF6S\x97"
  #
  def random_bytes: (?Integer? n) -> String

  # <!--
  #   rdoc-file=random.c
  #   - prng.random_number        -> float
  #   - prng.random_number(max)   -> number
  #   - prng.random_number(range) -> number
  #   - prng.rand                 -> float
  #   - prng.rand(max)            -> number
  #   - prng.rand(range)          -> number
  # -->
  # Generates formatted random number from raw random bytes. See Random#rand.
  #
  def random_number: () -> Float
                   | (?Float? n) -> Float
                   | (?Integer? n) -> Integer
                   | (?Numeric? n) -> Numeric
                   | (?::Range[Float]? n) -> Float
                   | (?::Range[Integer]? n) -> Integer
                   | (?::Range[Numeric]? n) -> Numeric

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - urlsafe_base64(n=nil, padding=false)
  # -->
  # Random::Formatter#urlsafe_base64 generates a random URL-safe base64 string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the result string is about 4/3 of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The boolean argument *padding* specifies the padding. If it is false or nil,
  # padding is not generated. Otherwise padding is generated. By default, padding
  # is not generated because "=" may be used as a URL delimiter.
  #
  # The result may contain A-Z, a-z, 0-9, "-" and "_". "=" is also used if
  # *padding* is true.
  #
  #     require 'random/formatter'
  #
  #     prng.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"
  #     prng.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"
  #
  #     prng.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="
  #     prng.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="
  #
  # See RFC 3548 for the definition of URL-safe base64.
  #
  def urlsafe_base64: (?Integer? n, ?boolish padding) -> String

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - uuid()
  # -->
  # Random::Formatter#uuid generates a random v4 UUID (Universally Unique
  # IDentifier).
  #
  #     require 'random/formatter'
  #
  #     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
  #     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
  #     prng.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"
  #
  # The version 4 UUID is purely random (except the version). It doesn't contain
  # meaningful information such as MAC addresses, timestamps, etc.
  #
  # The result contains 122 random bits (15.25 random bytes).
  #
  # See RFC 4122 for details of UUID.
  #
  def uuid: () -> String
end

# <!-- rdoc-file=object.c -->
# The global value `false` is the only instance of class FalseClass and
# represents a logically false value in boolean expressions. The class provides
# operators allowing `false` to participate correctly in logical expressions.
#
class FalseClass
  public

  def !: () -> true

  # <!--
  #   rdoc-file=object.c
  #   - false & obj   -> false
  #   - nil & obj     -> false
  # -->
  # And---Returns `false`. *obj* is always evaluated as it is the argument to a
  # method call---there is no short-circuit evaluation in this case.
  #
  def &: (untyped obj) -> false

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (false) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - false ^ obj    -> true or false
  #   - nil   ^ obj    -> true or false
  # -->
  # Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
  # returns `true`.
  #
  def ^: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  # <!-- rdoc-file=object.c -->
  # The string representation of `false` is "false".
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - false.to_s   ->  "false"
  # -->
  # The string representation of `false` is "false".
  #
  def to_s: () -> "false"

  # <!--
  #   rdoc-file=object.c
  #   - false | obj   ->   true or false
  #   - nil   | obj   ->   true or false
  # -->
  # Or---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.
  #
  def |: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=rbconfig.rb -->
# The module storing Ruby interpreter configurations on building.
#
# This file was created by mkconfig.rb when ruby was built.  It contains build
# information for ruby which is used e.g. by mkmf to build compatible native
# extensions.  Any changes made to this file will be lost the next time ruby is
# built.
#
module RbConfig
  # <!--
  #   rdoc-file=rbconfig.rb
  #   - RbConfig.expand(val)         -> string
  #   - RbConfig.expand(val, config) -> string
  # -->
  # expands variable with given `val` value.
  #
  #     RbConfig.expand("$(bindir)") # => /home/foobar/all-ruby/ruby19x/bin
  #
  def self.expand: (String val, ?Hash[String, String] config) -> String

  def self.fire_update!: (String key, String val, ?Hash[String, String] mkconf, ?Hash[String, String] conf) -> Array[String]?

  def self.ruby: () -> String
end

# <!-- rdoc-file=rbconfig.rb -->
# The hash configurations stored.
#
RbConfig::CONFIG: Hash[String, String]

# <!-- rdoc-file=rbconfig.rb -->
# DESTDIR on make install.
#
RbConfig::DESTDIR: String

# <!-- rdoc-file=rbconfig.rb -->
# Almost same with CONFIG. MAKEFILE_CONFIG has other variable reference like
# below.
#
#     MAKEFILE_CONFIG["bindir"] = "$(exec_prefix)/bin"
#
# The values of this constant is used for creating Makefile.
#
#     require 'rbconfig'
#
#     print <<-END_OF_MAKEFILE
#     prefix = #{RbConfig::MAKEFILE_CONFIG['prefix']}
#     exec_prefix = #{RbConfig::MAKEFILE_CONFIG['exec_prefix']}
#     bindir = #{RbConfig::MAKEFILE_CONFIG['bindir']}
#     END_OF_MAKEFILE
#
#     => prefix = /usr/local
#        exec_prefix = $(prefix)
#        bindir = $(exec_prefix)/bin  MAKEFILE_CONFIG = {}
#
# RbConfig.expand is used for resolving references like above in rbconfig.
#
#     require 'rbconfig'
#     p RbConfig.expand(RbConfig::MAKEFILE_CONFIG["bindir"])
#     # => "/usr/local/bin"
#
RbConfig::MAKEFILE_CONFIG: Hash[String, String]

# <!-- rdoc-file=rbconfig.rb -->
# Ruby installed directory.
#
RbConfig::TOPDIR: String

# <!-- rdoc-file=signal.c -->
# Many operating systems allow signals to be sent to running processes. Some
# signals have a defined effect on the process, while others may be trapped at
# the code level and acted upon. For example, your process may trap the USR1
# signal and use it to toggle debugging, and may use TERM to initiate a
# controlled shutdown.
#
#     pid = fork do
#       Signal.trap("USR1") do
#         $debug = !$debug
#         puts "Debug now: #$debug"
#       end
#       Signal.trap("TERM") do
#         puts "Terminating..."
#         shutdown()
#       end
#       # . . . do some work . . .
#     end
#
#     Process.detach(pid)
#
#     # Controlling program:
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("TERM", pid)
#
# produces:
#      Debug now: true
#      Debug now: false
#     Terminating...
#
# The list of available signal names and their interpretation is system
# dependent. Signal delivery semantics may also vary between systems; in
# particular signal delivery may not always be reliable.
#
module Signal
  # <!--
  #   rdoc-file=signal.c
  #   - Signal.list -> a_hash
  # -->
  # Returns a list of signal names mapped to the corresponding underlying signal
  # numbers.
  #
  #     Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4, "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11, "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19, "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22, "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28, "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}
  #
  def self.list: () -> ::Hash[String, Integer]

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.signame(signo)  ->  string or nil
  # -->
  # Convert signal number to signal name. Returns `nil` if the signo is an invalid
  # signal number.
  #
  #     Signal.trap("INT") { |signo| puts Signal.signame(signo) }
  #     Process.kill("INT", 0)
  #
  # *produces:*
  #
  #     INT
  #
  def self.signame: (Integer arg0) -> String?

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.trap( signal, command ) -> obj
  #   - Signal.trap( signal ) {| | block } -> obj
  # -->
  # Specifies the handling of signals. The first parameter is a signal name (a
  # string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The
  # characters ``SIG'' may be omitted from the signal name. The command or block
  # specifies code to be run when the signal is raised. If the command is the
  # string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command
  # is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler will be invoked. If
  # the command is ``EXIT'', the script will be terminated by the signal. If the
  # command is ``SYSTEM_DEFAULT'', the operating system's default handler will be
  # invoked. Otherwise, the given command or block will be run. The special signal
  # name ``EXIT'' or signal number zero will be invoked just prior to program
  # termination. trap returns the previous handler for the given signal.
  #
  #     Signal.trap(0, proc { puts "Terminating: #{$$}" })
  #     Signal.trap("CLD")  { puts "Child died" }
  #     fork && Process.wait
  #
  # produces:
  #     Terminating: 27461
  #     Child died
  #     Terminating: 27460
  #
  def self.trap: (Integer | String | Symbol signal, ?untyped command) -> (String | Proc)
               | (Integer | String | Symbol signal) { (Integer arg0) -> untyped } -> (String | Proc)
end

# <!-- rdoc-file=class.c -->
# Refinement is a class of the `self` (current context) inside `refine`
# statement. It allows to import methods from other modules, see
# #import_methods.
#
class Refinement < Module
  private

  # <!--
  #   rdoc-file=class.c
  #   - import_methods(module, ...)    -> self
  # -->
  # Imports methods from modules. Unlike Module#include, Refinement#import_methods
  # copies methods and adds them into the refinement, so the refinement is
  # activated in the imported methods.
  #
  # Note that due to method copying, only methods defined in Ruby code can be
  # imported.
  #
  #     module StrUtils
  #       def indent(level)
  #         ' ' * level + self
  #       end
  #     end
  #
  #     module M
  #       refine String do
  #         import_methods StrUtils
  #       end
  #     end
  #
  #     using M
  #     "foo".indent(3)
  #     #=> "   foo"
  #
  #     module M
  #       refine String do
  #         import_methods Enumerable
  #         # Can't import method which is not defined with Ruby code: Enumerable#drop
  #       end
  #     end
  #
  def import_methods: (*Module) -> self
end

# <!-- rdoc-file=numeric.c -->
# An Integer object represents an integer value.
#
# You can create an Integer object explicitly with:
#
# *   An [integer
#     literal](doc/syntax/literals_rdoc.html#label-Integer+Literals).
#
#
# You can convert certain objects to Integers with:
#
# *   Method [Integer](Kernel.html#method-i-Integer).
#
#
# An attempt to add a singleton method to an instance of this class causes an
# exception to be raised.
#
# ## What's Here
#
# First, what's elsewhere. Class Integer:
#
# *   Inherits from [class
#     Numeric](Numeric.html#class-Numeric-label-What-27s+Here).
#
#
# Here, class Integer provides methods for:
#
# *   [Querying](#class-Integer-label-Querying)
# *   [Comparing](#class-Integer-label-Comparing)
# *   [Converting](#class-Integer-label-Converting)
# *   [Other](#class-Integer-label-Other)
#
#
# ### Querying
#
#     #allbits?
# :       Returns whether all bits in `self` are set.
#
#     #anybits?
# :       Returns whether any bits in `self` are set.
#
#     #nobits?
# :       Returns whether no bits in `self` are set.
#
#
#
# ### Comparing
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given value.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given value.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns a number indicating whether `self` is less than, equal to, or
#         greater than the given value.
#
#     [==](#method-i-3D-3D) (aliased as #===)
# :       Returns whether `self` is equal to the given value.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than the given value.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than or equal to the given value.
#
#
#
# ### Converting
#
#     ::sqrt
# :       Returns the integer square root of the given value.
#
#     ::try_convert
# :       Returns the given value converted to an Integer.
#
#     #% (aliased as #modulo)
# :       Returns `self` modulo the given value.
#
#     [&](#method-i-26)
# :       Returns the bitwise AND of `self` and the given value.
#
#     #*
# :       Returns the product of `self` and the given value.
#
#     [**](#method-i-2A-2A)
# :       Returns the value of `self` raised to the power of the given value.
#
#     #+
# :       Returns the sum of `self` and the given value.
#
#     #-
# :       Returns the difference of `self` and the given value.
#
#     [/](#method-i-2F)
# :       Returns the quotient of `self` and the given value.
#
#     #<<
# :       Returns the value of `self` after a leftward bit-shift.
#
#     #>>
# :       Returns the value of `self` after a rightward bit-shift.
#
#     #[]
# :       Returns a slice of bits from `self`.
#
#     [^](#method-i-5E)
# :       Returns the bitwise EXCLUSIVE OR of `self` and the given value.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`.
#
#     #chr
# :       Returns a 1-character string containing the character represented by
#         the value of `self`.
#
#     #digits
# :       Returns an array of integers representing the base-radix digits of
#         `self`.
#
#     #div
# :       Returns the integer result of dividing `self` by the given value.
#
#     #divmod
# :       Returns a 2-element array containing the quotient and remainder
#         results of dividing `self` by the given value.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given value.
#
#     #floor
# :       Returns the greatest number smaller than or equal to `self`.
#
#     #pow
# :       Returns the modular exponentiation of `self`.
#
#     #pred
# :       Returns the integer predecessor of `self`.
#
#     #remainder
# :       Returns the remainder after dividing `self` by the given value.
#
#     #round
# :       Returns `self` rounded to the nearest value with the given precision.
#
#     #succ (aliased as #next)
# :       Returns the integer successor of `self`.
#
#     #to_f
# :       Returns `self` converted to a Float.
#
#     #to_s (aliased as #inspect)
# :       Returns a string containing the place-value representation of `self`
#         in the given radix.
#
#     #truncate
# :       Returns `self` truncated to the given precision.
#
#     [/](#method-i-7C)
# :       Returns the bitwise OR of `self` and the given value.
#
#
#
# ### Other
#
#     #downto
# :       Calls the given block with each integer value from `self` down to the
#         given value.
#
#     #times
# :       Calls the given block `self` times with each integer in `(0..self-1)`.
#
#     #upto
# :       Calls the given block with each integer value from `self` up to the
#         given value.
#
class Integer < Numeric
  # <!--
  #   rdoc-file=numeric.c
  #   - Integer.sqrt(numeric) -> integer
  # -->
  # Returns the integer square root of the non-negative integer `n`, which is the
  # largest non-negative integer less than or equal to the square root of
  # `numeric`.
  #
  #     Integer.sqrt(0)       # => 0
  #     Integer.sqrt(1)       # => 1
  #     Integer.sqrt(24)      # => 4
  #     Integer.sqrt(25)      # => 5
  #     Integer.sqrt(10**400) # => 10**200
  #
  # If `numeric` is not an Integer, it is converted to an Integer:
  #
  #     Integer.sqrt(Complex(4, 0))  # => 2
  #     Integer.sqrt(Rational(4, 1)) # => 2
  #     Integer.sqrt(4.0)            # => 2
  #     Integer.sqrt(3.14159)        # => 1
  #
  # This method is equivalent to `Math.sqrt(numeric).floor`, except that the
  # result of the latter code may differ from the true value due to the limited
  # precision of floating point arithmetic.
  #
  #     Integer.sqrt(10**46)    # => 100000000000000000000000
  #     Math.sqrt(10**46).floor # => 99999999999999991611392
  #
  # Raises an exception if `numeric` is negative.
  #
  def self.sqrt: (int n) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - Integer.try_convert(object) -> object, integer, or nil
  # -->
  # If `object` is an Integer object, returns `object`.
  #     Integer.try_convert(1) # => 1
  #
  # Otherwise if `object` responds to `:to_int`, calls `object.to_int` and returns
  # the result.
  #     Integer.try_convert(1.25) # => 1
  #
  # Returns `nil` if `object` does not respond to `:to_int`
  #     Integer.try_convert([]) # => nil
  #
  # Raises an exception unless `object.to_int` returns an Integer object.
  #
  def self.try_convert: (int) -> Integer
                      | (untyped) -> Integer?

  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_number
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  # Integer#modulo is an alias for Integer#%.
  #
  def %: (Float) -> Float
       | (Rational) -> Rational
       | (Integer) -> Integer
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self & other ->  integer
  # -->
  # Bitwise AND; each bit in the result is 1 if both corresponding bits in `self`
  # and `other` are 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 & 0b0110) # => "0100"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#| (bitwise OR), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def &: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self * numeric -> numeric_result
  # -->
  # Performs multiplication:
  #
  #     4 * 2              # => 8
  #     4 * -2             # => -8
  #     -4 * 2             # => -8
  #     4 * 2.0            # => 8.0
  #     4 * Rational(1, 3) # => (4/3)
  #     4 * Complex(2, 0)  # => (8+0i)
  #
  def *: (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex
       | (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** numeric -> numeric_result
  # -->
  # Raises `self` to the power of `numeric`:
  #
  #     2 ** 3              # => 8
  #     2 ** -3             # => (1/8)
  #     -2 ** 3             # => -8
  #     -2 ** -3            # => (-1/8)
  #     2 ** 3.3            # => 9.849155306759329
  #     2 ** Rational(3, 1) # => (8/1)
  #     2 ** Complex(3, 0)  # => (8+0i)
  #
  def **: (Integer) -> Numeric
        | (Float) -> Numeric
        | (Rational) -> Numeric
        | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self + numeric -> numeric_result
  # -->
  # Performs addition:
  #
  #     2 + 2              # => 4
  #     -2 + 2             # => 0
  #     -2 + -2            # => -4
  #     2 + 2.0            # => 4.0
  #     2 + Rational(2, 1) # => (4/1)
  #     2 + Complex(2, 0)  # => (4+0i)
  #
  def +: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  def +@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self - numeric -> numeric_result
  # -->
  # Performs subtraction:
  #
  #     4 - 2              # => 2
  #     -4 - 2             # => -6
  #     -4 - -2            # => -2
  #     4 - 2.0            # => 2.0
  #     4 - Rational(2, 1) # => (2/1)
  #     4 - Complex(2, 0)  # => (2+0i)
  #
  def -: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - -int  ->  integer
  # -->
  # Returns `int`, negated.
  #
  def -@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self / numeric -> numeric_result
  # -->
  # Performs division; for integer `numeric`, truncates the result to an integer:
  #
  #      4 / 3              # => 1
  #      4 / -3             # => -2
  #      -4 / 3             # => -2
  #      -4 / -3            # => 1
  #
  #     For other +numeric+, returns non-integer result:
  #
  #      4 / 3.0            # => 1.3333333333333333
  #      4 / Rational(3, 1) # => (4/3)
  #      4 / Complex(3, 0)  # => ((4/3)+0i)
  #
  def /: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if the value of `self` is less than that of `other`:
  #
  #       1 < 0              # => false
  #       1 < 1              # => false
  #       1 < 2              # => true
  #       1 < 0.5            # => false
  #       1 < Rational(1, 2) # => false
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self << count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the left, or to the
  # right if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n << 1)  # => "111100000"
  #     "%08b" % (n << 3)  # => "11110000000"
  #     "%08b" % (n << -1) # => "01111000"
  #     "%08b" % (n << -3) # => "00011110"
  #
  # Related: Integer#>>.
  #
  def <<: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= real -> true or false
  # -->
  # Returns `true` if the value of `self` is less than or equal to that of
  # `other`:
  #
  #     1 <= 0              # => false
  #     1 <= 1              # => true
  #     1 <= 2              # => true
  #     1 <= 0.5            # => false
  #     1 <= Rational(1, 2) # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other  ->  -1, 0, +1, or nil
  # -->
  # Returns:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater then `other`.
  # *   `nil`, if `self` and `other` are incomparable.
  #
  #
  # Examples:
  #
  #     1 <=> 2              # => -1
  #     1 <=> 1              # => 0
  #     1 <=> 0              # => 1
  #     1 <=> 'foo'          # => nil
  #
  #     1 <=> 1.0            # => 0
  #     1 <=> Rational(1, 1) # => 0
  #     1 <=> Complex(1, 0)  # => 0
  #
  # This method is the basis for comparisons in module Comparable.
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  # Integer#=== is an alias for Integer#==.
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  # Integer#=== is an alias for Integer#==.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than that of `other`:
  #
  #       1 > 0              # => true
  #       1 > 1              # => false
  #       1 > 2              # => false
  #       1 > 0.5            # => true
  #       1 > Rational(1, 2) # => true
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= real -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than or equal to that of
  # `other`:
  #
  #     1 >= 0              # => true
  #     1 >= 1              # => true
  #     1 >= 2              # => false
  #     1 >= 0.5            # => true
  #     1 >= Rational(1, 2) # => true
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >> count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the right, or to the
  # left if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n >> 1)  # => "01111000"
  #     "%08b" % (n >> 3)  # => "00011110"
  #     "%08b" % (n >> -1) # => "111100000"
  #     "%08b" % (n >> -3) # => "11110000000"
  #
  # Related: Integer#<<.
  #
  def >>: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self[offset]    -> 0 or 1
  #   - self[offset, size] -> integer
  #   - self[range] -> integer
  # -->
  # Returns a slice of bits from `self`.
  #
  # With argument `offset`, returns the bit at the given offset, where offset 0
  # refers to the least significant bit:
  #
  #     n = 0b10 # => 2
  #     n[0]     # => 0
  #     n[1]     # => 1
  #     n[2]     # => 0
  #     n[3]     # => 0
  #
  # In principle, `n[i]` is equivalent to `(n >> i) & 1`. Thus, negative index
  # always returns zero:
  #
  #     255[-1] # => 0
  #
  # With arguments `offset` and `size`, returns `size` bits from `self`, beginning
  # at `offset` and including bits of greater significance:
  #
  #     n = 0b111000       # => 56
  #     "%010b" % n[0, 10] # => "0000111000"
  #     "%010b" % n[4, 10] # => "0000000011"
  #
  # With argument `range`, returns `range.size` bits from `self`, beginning at
  # `range.begin` and including bits of greater significance:
  #
  #     n = 0b111000      # => 56
  #     "%010b" % n[0..9] # => "0000111000"
  #     "%010b" % n[4..9] # => "0000000011"
  #
  # Raises an exception if the slice cannot be constructed.
  #
  def []: (int) -> Integer
        | (int i, int len) -> Integer
        | (Range[int]) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ^ other -> integer
  # -->
  # Bitwise EXCLUSIVE OR; each bit in the result is 1 if the corresponding bits in
  # `self` and `other` are different, 0 otherwise:
  #
  #     "%04b" % (0b0101 ^ 0b0110) # => "0011"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#| (bitwise OR).
  #
  def ^: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.abs        ->  integer
  #   - int.magnitude  ->  integer
  # -->
  # Returns the absolute value of `int`.
  #
  #     (-12345).abs   #=> 12345
  #     -12345.abs     #=> 12345
  #     12345.abs      #=> 12345
  #
  # Integer#magnitude is an alias for Integer#abs.
  #
  def abs: () -> Integer

  def abs2: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - allbits?(mask) -> true or false
  # -->
  # Returns `true` if all bits that are set (=1) in `mask` are also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b1010101  self
  #     0b1010100  mask
  #     0b1010100  self & mask
  #          true  self.allbits?(mask)
  #
  #     0b1010100  self
  #     0b1010101  mask
  #     0b1010100  self & mask
  #         false  self.allbits?(mask)
  #
  # Related: Integer#anybits?, Integer#nobits?.
  #
  def allbits?: (int mask) -> bool

  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - anybits?(mask) -> true or false
  # -->
  # Returns `true` if any bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b10000010  self
  #     0b11111111  mask
  #     0b10000010  self & mask
  #           true  self.anybits?(mask)
  #
  #     0b00000000  self
  #     0b11111111  mask
  #     0b00000000  self & mask
  #          false  self.anybits?(mask)
  #
  # Related: Integer#allbits?, Integer#nobits?.
  #
  def anybits?: (int mask) -> bool

  alias arg angle

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.bit_length  ->  integer
  # -->
  # Returns the number of bits of the value of `int`.
  #
  # "Number of bits" means the bit position of the highest bit which is different
  # from the sign bit (where the least significant bit has bit position 1). If
  # there is no such bit (zero or minus one), zero is returned.
  #
  # I.e. this method returns *ceil(log2(int < 0 ? -int : int+1))*.
  #
  #     (-2**1000-1).bit_length   #=> 1001
  #     (-2**1000).bit_length     #=> 1000
  #     (-2**1000+1).bit_length   #=> 1000
  #     (-2**12-1).bit_length     #=> 13
  #     (-2**12).bit_length       #=> 12
  #     (-2**12+1).bit_length     #=> 12
  #     -0x101.bit_length         #=> 9
  #     -0x100.bit_length         #=> 8
  #     -0xff.bit_length          #=> 8
  #     -2.bit_length             #=> 1
  #     -1.bit_length             #=> 0
  #     0.bit_length              #=> 0
  #     1.bit_length              #=> 1
  #     0xff.bit_length           #=> 8
  #     0x100.bit_length          #=> 9
  #     (2**12-1).bit_length      #=> 12
  #     (2**12).bit_length        #=> 13
  #     (2**12+1).bit_length      #=> 13
  #     (2**1000-1).bit_length    #=> 1000
  #     (2**1000).bit_length      #=> 1001
  #     (2**1000+1).bit_length    #=> 1001
  #
  # This method can be used to detect overflow in Array#pack as follows:
  #
  #     if n.bit_length < 32
  #       [n].pack("l") # no overflow
  #     else
  #       raise "overflow"
  #     end
  #
  def bit_length: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> integer
  # -->
  # Returns the smallest number greater than or equal to `self` with a precision
  # of `ndigits` decimal digits.
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros:
  #
  #     555.ceil(-1)  # => 560
  #     555.ceil(-2)  # => 600
  #     -555.ceil(-2) # => -500
  #     555.ceil(-3)  # => 1000
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.ceil     # => 555
  #     555.ceil(50) # => 555
  #
  # Related: Integer#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - chr           -> string
  #   - chr(encoding) -> string
  # -->
  # Returns a 1-character string containing the character represented by the value
  # of `self`, according to the given `encoding`.
  #
  #     65.chr                   # => "A"
  #     0..chr                   # => "\x00"
  #     255.chr                  # => "\xFF"
  #     string = 255.chr(Encoding::UTF_8)
  #     string.encoding          # => Encoding::UTF_8
  #
  # Raises an exception if `self` is negative.
  #
  # Related: Integer#ord.
  #
  def chr: (?encoding) -> String

  # <!--
  #   rdoc-file=bignum.c
  #   - big.coerce(numeric)  ->  array
  # -->
  # Returns an array with both a `numeric` and a `big` represented as Bignum
  # objects.
  #
  # This is achieved by converting `numeric` to a Bignum.
  #
  # A TypeError is raised if the `numeric` is not a Fixnum or Bignum type.
  #
  #     (0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=> [42, 4611686018427387904]
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Integer

  def conjugate: () -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.denominator  ->  1
  # -->
  # Returns 1.
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - digits(base = 10) -> array_of_integers
  # -->
  # Returns an array of integers representing the `base`-radix digits of `self`;
  # the first element of the array represents the least significant digit:
  #
  #     12345.digits      # => [5, 4, 3, 2, 1]
  #     12345.digits(7)   # => [4, 6, 6, 0, 5]
  #     12345.digits(100) # => [45, 23, 1]
  #
  # Raises an exception if `self` is negative or `base` is less than 2.
  #
  def digits: (?int base) -> ::Array[Integer]

  # <!--
  #   rdoc-file=numeric.c
  #   - div(numeric)  -> integer
  # -->
  # Performs integer division; returns the integer result of dividing `self` by
  # `numeric`:
  #
  #       4.div(3)      # => 1
  #       4.div(-3)      # => -2
  #       -4.div(3)      # => -2
  #       -4.div(-3)      # => 1
  #       4.div(3.0)      # => 1
  #       4.div(Rational(3, 1))      # => 1
  #
  #     Raises an exception if +numeric+ does not have method +div+.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor    # Quotient
  #     r = self % other          # Remainder
  #
  # Examples:
  #
  #     11.divmod(4)              # => [2, 3]
  #     11.divmod(-4)             # => [-3, -1]
  #     -11.divmod(4)             # => [-3, 1]
  #     -11.divmod(-4)            # => [2, -3]
  #
  #     12.divmod(4)              # => [3, 0]
  #     12.divmod(-4)             # => [-3, 0]
  #     -12.divmod(4)             # => [-3, 0]
  #     -12.divmod(-4)            # => [3, 0]
  #
  #     13.divmod(4.0)            # => [3, 1.0]
  #     13.divmod(Rational(4, 1)) # => [3, (1/1)]
  #
  def divmod: (Integer) -> [ Integer, Integer ]
            | (Float) -> [ Float, Float ]
            | (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - downto(limit) {|i| ... } -> self
  #   - downto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` down to `limit`;
  # returns `self`:
  #
  #     a = []
  #     10.downto(5) {|i| a << i }              # => 10
  #     a                                       # => [10, 9, 8, 7, 6, 5]
  #     a = []
  #     0.downto(-5) {|i| a << i }              # => 0
  #     a                                       # => [0, -1, -2, -3, -4, -5]
  #     4.downto(5) {|i| fail 'Cannot happen' } # => 4
  #
  # With no block given, returns an Enumerator.
  #
  def downto: (Integer limit) { (Integer) -> void } -> Integer
            | (Integer limit) -> ::Enumerator[Integer, self]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.even?  ->  true or false
  # -->
  # Returns `true` if `int` is an even number.
  #
  def even?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(numeric) -> float
  # -->
  # Returns the Float result of dividing `self` by `numeric`:
  #
  #     4.fdiv(2)      # => 2.0
  #     4.fdiv(-2)      # => -2.0
  #     -4.fdiv(2)      # => -2.0
  #     4.fdiv(2.0)      # => 2.0
  #     4.fdiv(Rational(3, 4))      # => 5.333333333333333
  #
  # Raises an exception if `numeric` cannot be converted to a Float.
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> integer
  # -->
  # Returns the largest number less than or equal to `self` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.floor(-1)  # => 550
  #     555.floor(-2)  # => 500
  #     -555.floor(-2) # => -600
  #     555.floor(-3)  # => 0
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.floor     # => 555
  #     555.floor(50) # => 555
  #
  # Related: Integer#ceil.
  #
  def floor: (?int digits) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcd(other_int)  ->  integer
  # -->
  # Returns the greatest common divisor of the two integers. The result is always
  # positive. 0.gcd(x) and x.gcd(0) return x.abs.
  #
  #     36.gcd(60)                  #=> 12
  #     2.gcd(2)                    #=> 2
  #     3.gcd(-7)                   #=> 1
  #     ((1<<31)-1).gcd((1<<61)-1)  #=> 1
  #
  def gcd: (Integer) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcdlcm(other_int)  ->  array
  # -->
  # Returns an array with the greatest common divisor and the least common
  # multiple of the two integers, [gcd, lcm].
  #
  #     36.gcdlcm(60)                  #=> [12, 180]
  #     2.gcdlcm(2)                    #=> [2, 2]
  #     3.gcdlcm(-7)                   #=> [1, 21]
  #     ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]
  #
  def gcdlcm: (Integer) -> [ Integer, Integer ]

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  # Integer#inspect is an alias for Integer#to_s.
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.integer?  ->  true
  # -->
  # Since `int` is already an Integer, this always returns `true`.
  #
  def integer?: () -> true

  # <!--
  #   rdoc-file=rational.c
  #   - int.lcm(other_int)  ->  integer
  # -->
  # Returns the least common multiple of the two integers. The result is always
  # positive. 0.lcm(x) and x.lcm(0) return zero.
  #
  #     36.lcm(60)                  #=> 180
  #     2.lcm(2)                    #=> 2
  #     3.lcm(-7)                   #=> 21
  #     ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297
  #
  def lcm: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  def magnitude: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  # Integer#modulo is an alias for Integer#%.
  #
  alias modulo %

  def negative?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Integer#next is an alias for Integer#succ.
  #
  # Related: Integer#pred (predecessor value).
  #
  def next: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - nobits?(mask) -> true or false
  # -->
  # Returns `true` if no bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b11110000  self
  #     0b00001111  mask
  #     0b00000000  self & mask
  #           true  self.nobits?(mask)
  #
  #     0b00000001  self
  #     0b11111111  mask
  #     0b00000001  self & mask
  #          false  self.nobits?(mask)
  #
  # Related: Integer#allbits?, Integer#anybits?.
  #
  def nobits?: (int mask) -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - int.numerator  ->  self
  # -->
  # Returns self.
  #
  def numerator: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.odd?  ->  true or false
  # -->
  # Returns `true` if `int` is an odd number.
  #
  def odd?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.ord  ->  self
  # -->
  # Returns the `int` itself.
  #
  #     97.ord   #=> 97
  #
  # This method is intended for compatibility to character literals in Ruby 1.9.
  #
  # For example, `?a.ord` returns 97 both in 1.8 and 1.9.
  #
  def ord: () -> Integer

  alias phase angle

  def polar: () -> [ Integer, Integer | Float ]

  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - integer.pow(numeric)           ->  numeric
  #   - integer.pow(integer, integer)  ->  integer
  # -->
  # Returns (modular) exponentiation as:
  #
  #     a.pow(b)     #=> same as a**b
  #     a.pow(b, m)  #=> same as (a**b) % m, but avoids huge temporary values
  #
  def pow: (Integer other, ?Integer modulo) -> Integer
         | (Float) -> Float
         | (Rational) -> Rational
         | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - pred -> next_integer
  # -->
  # Returns the predecessor of `self` (equivalent to `self - 1`):
  #
  #     1.pred  #=> 0
  #     -1.pred #=> -2
  #
  # Related: Integer#succ (successor value).
  #
  def pred: () -> Integer

  def quo: (Integer) -> Rational
         | (Float) -> Float
         | (Rational) -> Rational
         | (Complex) -> Complex
         | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - int.rationalize([eps])  ->  rational
  # -->
  # Returns the value as a rational.  The optional argument `eps` is always
  # ignored.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> self

  def real?: () -> true

  def rect: () -> [ Integer, Numeric ]

  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Examples:
  #
  #     11.remainder(4)              # => 3
  #     11.remainder(-4)             # => 3
  #     -11.remainder(4)             # => -3
  #     -11.remainder(-4)            # => -3
  #
  #     12.remainder(4)              # => 0
  #     12.remainder(-4)             # => 0
  #     -12.remainder(4)             # => 0
  #     -12.remainder(-4)            # => 0
  #
  #     13.remainder(4.0)            # => 1.0
  #     13.remainder(Rational(4, 1)) # => (1/1)
  #
  def remainder: (Integer) -> Integer
               | (Float) -> Float
               | (Rational) -> Rational
               | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits= 0, half: :up) -> integer
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.round(-1)      # => 560
  #     555.round(-2)      # => 600
  #     555.round(-3)      # => 1000
  #     -555.round(-2)     # => -600
  #     555.round(-4)      # => 0
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.round     # => 555
  #     555.round(1)  # => 555
  #     555.round(50) # => 555
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate  values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         25.round(-1, half: :up)      # => 30
  #         (-25).round(-1, half: :up)   # => -30
  #
  # *   `:down`: round toward zero:
  #
  #         25.round(-1, half: :down)    # => 20
  #         (-25).round(-1, half: :down) # => -20
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         25.round(-1, half: :even)    # => 20
  #         15.round(-1, half: :even)    # => 20
  #         (-25).round(-1, half: :even) # => -20
  #
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Integer#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.size  ->  int
  # -->
  # Document-method: Integer#size
  #
  # Returns the number of bytes in the machine representation of `int` (machine
  # dependent).
  #
  #     1.size               #=> 8
  #     -1.size              #=> 8
  #     2147483647.size      #=> 8
  #     (256**10 - 1).size   #=> 10
  #     (256**20 - 1).size   #=> 20
  #     (256**40 - 1).size   #=> 40
  #
  def size: () -> Integer

  def step: () { (Integer) -> void } -> void
          | (Numeric limit, ?Integer step) { (Integer) -> void } -> void
          | (Numeric limit, ?Numeric step) { (Numeric) -> void } -> void
          | (to: Numeric, ?by: Integer) { (Integer) -> void } -> void
          | (by: Numeric, ?to: Numeric) { (Numeric) -> void } -> void
          | () -> Enumerator[Integer, bot]
          | (Numeric limit, ?Integer step) -> Enumerator[Integer, void]
          | (Numeric limit, ?Numeric step) -> Enumerator[Numeric, void]
          | (to: Numeric, ?by: Integer) -> Enumerator[Integer, void]
          | (by: Numeric, ?to: Numeric) -> Enumerator[Numeric, void]

  # <!--
  #   rdoc-file=numeric.c
  #   - succ -> next_integer
  # -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Integer#next is an alias for Integer#succ.
  #
  # Related: Integer#pred (predecessor value).
  #
  def succ: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - times {|i| ... } -> self
  #   - times            -> enumerator
  # -->
  # Calls the given block `self` times with each integer in `(0..self-1)`:
  #
  #     a = []
  #     5.times {|i| a.push(i) } # => 5
  #     a                        # => [0, 1, 2, 3, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def times: () { (Integer) -> void } -> self
           | () -> ::Enumerator[Integer, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_f -> float
  # -->
  # Converts `self` to a Float:
  #
  #     1.to_f  # => 1.0
  #     -1.to_f # => -1.0
  #
  # If the value of `self` does not fit in a Float, the result is infinity:
  #
  #     (10**400).to_f  # => Infinity
  #     (-10**400).to_f # => -Infinity
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.to_i    ->  integer
  # -->
  # Since `int` is already an Integer, returns `self`.
  #
  # #to_int is an alias for #to_i.
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.to_int  ->  integer
  # -->
  # Since `int` is already an Integer, returns `self`.
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - int.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     1.to_r        #=> (1/1)
  #     (1<<64).to_r  #=> (18446744073709551616/1)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s(base = 10)  ->  string
  # -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  # Integer#inspect is an alias for Integer#to_s.
  #
  def to_s: () -> String
          | (2) -> String
          | (3) -> String
          | (4) -> String
          | (5) -> String
          | (6) -> String
          | (7) -> String
          | (8) -> String
          | (9) -> String
          | (10) -> String
          | (11) -> String
          | (12) -> String
          | (13) -> String
          | (14) -> String
          | (15) -> String
          | (16) -> String
          | (17) -> String
          | (18) -> String
          | (19) -> String
          | (20) -> String
          | (21) -> String
          | (22) -> String
          | (23) -> String
          | (24) -> String
          | (25) -> String
          | (26) -> String
          | (27) -> String
          | (28) -> String
          | (29) -> String
          | (30) -> String
          | (31) -> String
          | (32) -> String
          | (33) -> String
          | (34) -> String
          | (35) -> String
          | (36) -> String
          | (int base) -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.truncate(-1)  # => 550
  #     555.truncate(-2)  # => 500
  #     -555.truncate(-2) # => -500
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.truncate     # => 555
  #     555.truncate(50) # => 555
  #
  # Related: Integer#round.
  #
  def truncate: () -> Integer
              | (int ndigits) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - upto(limit) {|i| ... } -> self
  #   - upto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` up to `limit`;
  # returns `self`:
  #
  #     a = []
  #     5.upto(10) {|i| a << i }              # => 5
  #     a                                     # => [5, 6, 7, 8, 9, 10]
  #     a = []
  #     -5.upto(0) {|i| a << i }              # => -5
  #     a                                     # => [-5, -4, -3, -2, -1, 0]
  #     5.upto(4) {|i| fail 'Cannot happen' } # => 5
  #
  # With no block given, returns an Enumerator.
  #
  def upto: (Integer limit) { (Integer) -> void } -> Integer
          | (Integer limit) -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.zero? -> true or false
  # -->
  # Returns `true` if `int` has a zero value.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self | other -> integer
  # -->
  # Bitwise OR; each bit in the result is 1 if either corresponding bit in `self`
  # or `other` is 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 | 0b0110) # => "0111"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def |: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - ~int  ->  integer
  # -->
  # One's complement: returns a number where each bit is flipped.
  #
  # Inverts the bits in an Integer. As integers are conceptually of infinite
  # length, the result acts as if it had an infinite number of one bits to the
  # left. In hex representations, this is displayed as two periods to the left of
  # the digits.
  #
  #     sprintf("%X", ~0x1122334455)    #=> "..FEEDDCCBBAA"
  #
  def ~: () -> Integer
end

# <!-- rdoc-file=object.c -->
# The class of the singleton object `nil`.
#
class NilClass
  public

  # <!--
  #   rdoc-file=object.c
  #   - false & obj   -> false
  #   - nil & obj     -> false
  # -->
  # And---Returns `false`. *obj* is always evaluated as it is the argument to a
  # method call---there is no short-circuit evaluation in this case.
  #
  def &: (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (nil) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - nil =~ other  -> nil
  # -->
  # Dummy pattern matching -- always returns nil.
  #
  def =~: (untyped obj) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - false ^ obj    -> true or false
  #   - nil   ^ obj    -> true or false
  # -->
  # Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
  # returns `true`.
  #
  def ^: (nil) -> false
       | (false) -> false
       | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - nil.inspect  -> "nil"
  # -->
  # Always returns the string "nil".
  #
  def inspect: () -> "nil"

  # <!--
  #   rdoc-file=object.c
  #   - nil.nil?               -> true
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  def nil?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - nil.rationalize([eps])  ->  (0/1)
  # -->
  # Returns zero as a rational.  The optional argument `eps` is always ignored.
  #
  def rationalize: (?untyped eps) -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_a    -> []
  # -->
  # Always returns an empty array.
  #
  #     nil.to_a   #=> []
  #
  def to_a: () -> [ ]

  # <!--
  #   rdoc-file=complex.c
  #   - nil.to_c  ->  (0+0i)
  # -->
  # Returns zero as a complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_f    -> 0.0
  # -->
  # Always returns zero.
  #
  #     nil.to_f   #=> 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_h    -> {}
  # -->
  # Always returns an empty hash.
  #
  #     nil.to_h   #=> {}
  #
  def to_h: () -> ::Hash[untyped, untyped]

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_i -> 0
  # -->
  # Always returns zero.
  #
  #     nil.to_i   #=> 0
  #
  def to_i: () -> 0

  # <!--
  #   rdoc-file=rational.c
  #   - nil.to_r  ->  (0/1)
  # -->
  # Returns zero as a rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_s    -> ""
  # -->
  # Always returns the empty string.
  #
  def to_s: () -> ""

  # <!--
  #   rdoc-file=object.c
  #   - false | obj   ->   true or false
  #   - nil   | obj   ->   true or false
  # -->
  # Or---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.
  #
  def |: (nil) -> false
       | (false) -> false
       | (untyped obj) -> bool

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=error.c -->
# Raised when the arguments are wrong and there isn't a more specific Exception
# class.
#
# Ex: passing the wrong number of arguments
#
#     [1, 2, 3].first(4, 5)
#
# *raises the exception:*
#
#     ArgumentError: wrong number of arguments (given 2, expected 1)
#
# Ex: passing an argument that is not acceptable:
#
#     [1, 2, 3].first(-4)
#
# *raises the exception:*
#
#     ArgumentError: negative array size
#
class ArgumentError < StandardError
end

# <!-- rdoc-file=thread_sync.c -->
# The exception class which will be raised when pushing into a closed Queue.
# See Thread::Queue#close and Thread::SizedQueue#close.
#
class ClosedQueueError < StopIteration
end

# <!-- rdoc-file=error.c -->
# EncodingError is the base class for encoding errors.
#
class EncodingError < StandardError
end

# <!-- rdoc-file=io.c -->
# Raised by some IO operations when reaching the end of file. Many IO methods
# exist in two forms,
#
# one that returns `nil` when the end of file is reached, the other raises
# `EOFError`.
#
# `EOFError` is a subclass of `IOError`.
#
#     file = File.open("/etc/hosts")
#     file.read
#     file.gets     #=> nil
#     file.readline #=> EOFError: end of file reached
#
class EOFError < IOError
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to convert special float values (in particular
# `Infinity` or `NaN`) to numerical classes which don't support them.
#
#     Float::INFINITY.to_r   #=> FloatDomainError: Infinity
#
class FloatDomainError < RangeError
end

# <!-- rdoc-file=error.c -->
# Raised when there is an attempt to modify a frozen object.
#
#     [1, 2, 3].freeze << 4
#
# *raises the exception:*
#
#     FrozenError: can't modify frozen Array
#
class FrozenError[T] < RuntimeError
  # <!--
  #   rdoc-file=error.c
  #   - FrozenError.new(msg=nil, receiver: nil)  -> frozen_error
  # -->
  # Construct a new FrozenError exception. If given the *receiver* parameter may
  # subsequently be examined using the FrozenError#receiver method.
  #
  #     a = [].freeze
  #     raise FrozenError.new("can't modify frozen array", receiver: a)
  #
  def initialize: (?string? msg, ?receiver: T?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - frozen_error.receiver  -> object
  # -->
  # Return the receiver associated with this FrozenError exception.
  #
  def receiver: () -> T?
end

# <!-- rdoc-file=error.c -->
# Raised when the given index is invalid.
#
#     a = [:foo, :bar]
#     a.fetch(0)   #=> :foo
#     a[4]         #=> nil
#     a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2
#
class IndexError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the interrupt signal is received, typically because the user has
# pressed Control-C (on most posix platforms). As such, it is a subclass of
# `SignalException`.
#
#     begin
#       puts "Press ctrl-C when you get bored"
#       loop {}
#     rescue Interrupt => e
#       puts "Note: You will typically use Signal.trap instead."
#     end
#
# *produces:*
#
#     Press ctrl-C when you get bored
#
# *then waits until it is interrupted with Control-C and then prints:*
#
#     Note: You will typically use Signal.trap instead.
#
class Interrupt < SignalException
  def initialize: (?string) -> void
end

# <!-- rdoc-file=io.c -->
# Raised when an IO operation fails.
#
#     File.open("/etc/hosts") {|f| f << "example"}
#       #=> IOError: not opened for writing
#
#     File.open("/etc/hosts") {|f| f.close; f.read }
#       #=> IOError: closed stream
#
# Note that some IO failures raise `SystemCallError`s and these are not
# subclasses of IOError:
#
#     File.open("does/not/exist")
#       #=> Errno::ENOENT: No such file or directory - does/not/exist
#
class IOError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the specified key is not found. It is a subclass of IndexError.
#
#     h = {"foo" => :bar}
#     h.fetch("foo") #=> :bar
#     h.fetch("baz") #=> KeyError: key not found: "baz"
#
class KeyError[K, R] < IndexError
  # <!--
  #   rdoc-file=error.c
  #   - KeyError.new(message=nil, receiver: nil, key: nil) -> key_error
  # -->
  # Construct a new `KeyError` exception with the given message, receiver and key.
  #
  def initialize: (?string msg, ?receiver: R?, ?key: K?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - key_error.key  -> object
  # -->
  # Return the key caused this KeyError exception.
  #
  def key: () -> K?

  # <!--
  #   rdoc-file=error.c
  #   - key_error.receiver  -> object
  # -->
  # Return the receiver associated with this KeyError exception.
  #
  def receiver: () -> R?
end

# <!-- rdoc-file=error.c -->
# Raised when a file required (a Ruby script, extension library, ...) fails to
# load.
#
#     require 'this/file/does/not/exist'
#
# *raises the exception:*
#
#     LoadError: no such file to load -- this/file/does/not/exist
#
class LoadError < ScriptError
  # <!-- rdoc-file=error.c -->
  # the path failed to load
  #
  def path: () -> String?
end

# <!-- rdoc-file=proc.c -->
# Raised when Ruby can't yield as requested.
#
# A typical scenario is attempting to yield when no block is given:
#
#     def call_block
#       yield 42
#     end
#     call_block
#
# *raises the exception:*
#
#     LocalJumpError: no block given (yield)
#
# A more subtle example:
#
#     def get_me_a_return
#       Proc.new { return 42 }
#     end
#     get_me_a_return.call
#
# *raises the exception:*
#
#     LocalJumpError: unexpected return
#
class LocalJumpError < StandardError
  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.exit_value  -> obj
  # -->
  # Returns the exit value associated with this `LocalJumpError`.
  #
  def exit_value: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.reason   -> symbol
  # -->
  # The reason this block was terminated: :break, :redo, :retry, :next, :return,
  # or :noreason.
  #
  def reason: () -> Symbol
end

# <!-- rdoc-file=error.c -->
# Raised when a given name is invalid or undefined.
#
#     puts foo
#
# *raises the exception:*
#
#     NameError: undefined local variable or method `foo' for main:Object
#
# Since constant names must start with a capital:
#
#     Integer.const_set :answer, 42
#
# *raises the exception:*
#
#     NameError: wrong constant name answer
#
class NameError[T] < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - NameError.new(msg=nil, name=nil, receiver: nil)  -> name_error
  # -->
  # Construct a new NameError exception. If given the *name* parameter may
  # subsequently be examined using the NameError#name method. *receiver* parameter
  # allows to pass object in context of which the error happened. Example:
  #
  #     [1, 2, 3].method(:rject) # NameError with name "rject" and receiver: Array
  #     [1, 2, 3].singleton_method(:rject) # NameError with name "rject" and receiver: [1, 2, 3]
  #
  def initialize: (?string msg, ?String? name, ?receiver: T?) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - name_error.local_variables  ->  array
  # -->
  # Return a list of the local variable names defined where this NameError
  # exception was raised.
  #
  # Internal use only.
  #
  def local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=error.c
  #   - name_error.name    ->  string or nil
  # -->
  # Return the name associated with this NameError exception.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=error.c
  #   - name_error.receiver  -> object
  # -->
  # Return the receiver associated with this NameError exception.
  #
  def receiver: () -> T?
end

# <!-- rdoc-file=error.c -->
# Raised when memory allocation fails.
#
class NoMemoryError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a method is called on a receiver which doesn't have it defined and
# also fails to respond with `method_missing`.
#
#     "hello".to_ary
#
# *raises the exception:*
#
#     NoMethodError: undefined method `to_ary' for "hello":String
#
class NoMethodError[T] < NameError[T]
  # <!--
  #   rdoc-file=error.c
  #   - NoMethodError.new(msg=nil, name=nil, args=nil, private=false, receiver: nil)  -> no_method_error
  # -->
  # Construct a NoMethodError exception for a method of the given name called with
  # the given arguments. The name may be accessed using the `#name` method on the
  # resulting object, and the arguments using the `#args` method.
  #
  # If *private* argument were passed, it designates method was attempted to call
  # in private context, and can be accessed with `#private_call?` method.
  #
  # *receiver* argument stores an object whose method was called.
  #
  def initialize: (?string? msg, ?String? name, ?Array[untyped] args, ?boolish `private`, ?receiver: T?) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.args  -> obj
  # -->
  # Return the arguments passed in as the third parameter to the constructor.
  #
  def args: () -> Array[untyped]

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.private_call?  -> true or false
  # -->
  # Return true if the caused method was called as private.
  #
  def private_call?: () -> bool
end

# <!-- rdoc-file=error.c -->
# Raised when a feature is not implemented on the current platform. For example,
# methods depending on the `fsync` or `fork` system calls may raise this
# exception if the underlying operating system or Ruby runtime does not support
# them.
#
# Note that if `fork` raises a `NotImplementedError`, then `respond_to?(:fork)`
# returns `false`.
#
class NotImplementedError < ScriptError
end

# <!-- rdoc-file=error.c -->
# Raised when a given numerical value is out of range.
#
#     [1, 2, 3].drop(1 << 100)
#
# *raises the exception:*
#
#     RangeError: bignum too big to convert into `long'
#
class RangeError < StandardError
end

# <!-- rdoc-file=re.c -->
# Raised when given an invalid regexp expression.
#
#     Regexp.new("?")
#
# *raises the exception:*
#
#     RegexpError: target of repeat operator is not specified: /?/
#
class RegexpError < StandardError
end

# <!-- rdoc-file=error.c -->
# A generic error class raised when an invalid operation is attempted.
# Kernel#raise will raise a RuntimeError if no Exception class is specified.
#
#     raise "ouch"
#
# *raises the exception:*
#
#     RuntimeError: ouch
#
class RuntimeError < StandardError
end

# <!-- rdoc-file=error.c -->
# ScriptError is the superclass for errors raised when a script can not be
# executed because of a `LoadError`, `NotImplementedError` or a `SyntaxError`.
# Note these type of `ScriptErrors` are not `StandardError` and will not be
# rescued unless it is specified explicitly (or its ancestor `Exception`).
#
class ScriptError < Exception
end

# <!-- rdoc-file=error.c -->
# No longer used by internal code.
#
class SecurityError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a signal is received.
#
#     begin
#       Process.kill('HUP',Process.pid)
#       sleep # wait for receiver to handle signal sent by Process.kill
#     rescue SignalException => e
#       puts "received Exception #{e}"
#     end
#
# *produces:*
#
#     received Exception SIGHUP
#
class SignalException < Exception
  # <!--
  #   rdoc-file=signal.c
  #   - SignalException.new(sig_name)              ->  signal_exception
  #   - SignalException.new(sig_number [, name])   ->  signal_exception
  # -->
  # Construct a new SignalException object.  `sig_name` should be a known signal
  # name.
  #
  def initialize: (?string sig_name) -> void
                | (int sig_number, ?string sig_name) -> void

  public

  def signm: () -> String

  # <!--
  #   rdoc-file=signal.c
  #   - signal_exception.signo   ->  num
  # -->
  # Returns a signal number.
  #
  def signo: () -> Integer
end

# <!-- rdoc-file=error.c -->
# The most standard error types are subclasses of StandardError. A rescue clause
# without an explicit Exception class will rescue all StandardErrors (and only
# those).
#
#     def foo
#       raise "Oups"
#     end
#     foo rescue "Hello"   #=> "Hello"
#
# On the other hand:
#
#     require 'does/not/exist' rescue "Hi"
#
# *raises the exception:*
#
#     LoadError: no such file to load -- does/not/exist
#
class StandardError < Exception
end

# <!-- rdoc-file=enumerator.c -->
# Raised to stop the iteration, in particular by Enumerator#next. It is rescued
# by Kernel#loop.
#
#     loop do
#       puts "Hello"
#       raise StopIteration
#       puts "World"
#     end
#     puts "Done!"
#
# *produces:*
#
#     Hello
#     Done!
#
class StopIteration < IndexError
  # <!--
  #   rdoc-file=enumerator.c
  #   - result       -> value
  # -->
  # Returns the return value of the iterator.
  #
  #     o = Object.new
  #     def o.each
  #       yield 1
  #       yield 2
  #       yield 3
  #       100
  #     end
  #
  #     e = o.to_enum
  #
  #     puts e.next                   #=> 1
  #     puts e.next                   #=> 2
  #     puts e.next                   #=> 3
  #
  #     begin
  #       e.next
  #     rescue StopIteration => ex
  #       puts ex.result              #=> 100
  #     end
  #
  def result: () -> untyped
end

# <!-- rdoc-file=error.c -->
# Raised when encountering Ruby code with an invalid syntax.
#
#     eval("1+1=2")
#
# *raises the exception:*
#
#     SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end
#
class SyntaxError < ScriptError
  # <!--
  #   rdoc-file=error.c
  #   - SyntaxError.new([msg])  -> syntax_error
  # -->
  # Construct a SyntaxError exception.
  #
  def initialize: (?string msg) -> void
end

# <!-- rdoc-file=error.c -->
# SystemCallError is the base class for all low-level platform-dependent errors.
#
# The errors available on the current platform are subclasses of SystemCallError
# and are defined in the Errno module.
#
#     File.open("does/not/exist")
#
# *raises the exception:*
#
#     Errno::ENOENT: No such file or directory - does/not/exist
#
class SystemCallError < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - SystemCallError.new(msg, errno)  -> system_call_error_subclass
  # -->
  # If *errno* corresponds to a known system error code, constructs the
  # appropriate Errno class for that error, otherwise constructs a generic
  # SystemCallError object. The error number is subsequently available via the
  # #errno method.
  #
  def initialize: (string msg, Integer errno) -> SystemCallError

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error === other  -> true or false
  # -->
  # Return `true` if the receiver is a generic `SystemCallError`, or if the error
  # numbers `self` and *other* are the same.
  #
  def self.===: (untyped other) -> bool

  public

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error.errno   -> integer
  # -->
  # Return this SystemCallError's error number.
  #
  def errno: () -> Integer
end

# <!-- rdoc-file=error.c -->
# Raised by `exit` to initiate the termination of the script.
#
class SystemExit < Exception
  # <!--
  #   rdoc-file=error.c
  #   - SystemExit.new              -> system_exit
  #   - SystemExit.new(status)      -> system_exit
  #   - SystemExit.new(status, msg) -> system_exit
  #   - SystemExit.new(msg)         -> system_exit
  # -->
  # Create a new `SystemExit` exception with the given status and message. Status
  # is true, false, or an integer. If status is not given, true is used.
  #
  def initialize: () -> void
                | (string msg) -> void
                | (true | false | int status, ?string msg) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.status   -> integer
  # -->
  # Return the status value associated with this system exit.
  #
  def status: () -> Integer

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.success?  -> true or false
  # -->
  # Returns `true` if exiting successful, `false` if not.
  #
  def success?: () -> bool
end

# <!-- rdoc-file=proc.c -->
# Raised in case of a stack overflow.
#
#     def me_myself_and_i
#       me_myself_and_i
#     end
#     me_myself_and_i
#
# *raises the exception:*
#
#     SystemStackError: stack level too deep
#
class SystemStackError < Exception
end

# <!-- rdoc-file=thread.c -->
# Raised when an invalid operation is attempted on a thread.
#
# For example, when no other thread has been started:
#
#     Thread.stop
#
# This will raises the following exception:
#
#     ThreadError: stopping only thread
#     note: use sleep to stop forever
#
class ThreadError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when encountering an object that is not of the expected type.
#
#     [1, 2, 3].first("two")
#
# *raises the exception:*
#
#     TypeError: no implicit conversion of String into Integer
#
class TypeError < StandardError
end

# <!-- rdoc-file=vm_eval.c -->
# Raised when `throw` is called with a *tag* which does not have corresponding
# `catch` block.
#
#     throw "foo", "bar"
#
# *raises the exception:*
#
#     UncaughtThrowError: uncaught throw "foo"
#
class UncaughtThrowError < ArgumentError
  # <!--
  #   rdoc-file=vm_eval.c
  #   - new(*args)
  # -->
  # Document-class: UncaughtThrowError
  #
  # Raised when `throw` is called with a *tag* which does not have corresponding
  # `catch` block.
  #
  #     throw "foo", "bar"
  #
  # *raises the exception:*
  #
  #     UncaughtThrowError: uncaught throw "foo"
  #
  def initialize: (untyped tag, untyped value) -> void

  public

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.tag   -> obj
  # -->
  # Return the tag object which was called for.
  #
  def tag: () -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.to_s   ->  string
  # -->
  # Returns formatted message with the inspected tag.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.value   -> obj
  # -->
  # Return the return value which was called for.
  #
  def value: () -> untyped
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to divide an integer by 0.
#
#     42 / 0   #=> ZeroDivisionError: divided by 0
#
# Note that only division by an exact 0 will raise the exception:
#
#     42 /  0.0   #=> Float::INFINITY
#     42 / -0.0   #=> -Float::INFINITY
#     0  /  0.0   #=> NaN
#
class ZeroDivisionError < StandardError
end

# <!-- rdoc-file=cont.c -->
# Raised when an invalid operation is attempted on a Fiber, in particular when
# attempting to call/resume a dead fiber, attempting to yield from the root
# fiber, or calling a fiber across threads.
#
#     fiber = Fiber.new{}
#     fiber.resume #=> nil
#     fiber.resume #=> FiberError: dead fiber called
#
class FiberError < StandardError
end

# <!-- rdoc-file=vm.c -->
# Threads are the Ruby implementation for a concurrent programming model.
#
# Programs that require multiple threads of execution are a perfect candidate
# for Ruby's Thread class.
#
# For example, we can create a new thread separate from the main thread's
# execution using ::new.
#
#     thr = Thread.new { puts "What's the big deal" }
#
# Then we are able to pause the execution of the main thread and allow our new
# thread to finish, using #join:
#
#     thr.join #=> "What's the big deal"
#
# If we don't call `thr.join` before the main thread terminates, then all other
# threads including `thr` will be killed.
#
# Alternatively, you can use an array for handling multiple threads at once,
# like in the following example:
#
#     threads = []
#     threads << Thread.new { puts "What's the big deal" }
#     threads << Thread.new { 3.times { puts "Threads are fun!" } }
#
# After creating a few threads we wait for them all to finish consecutively.
#
#     threads.each { |thr| thr.join }
#
# To retrieve the last value of a thread, use #value
#
#     thr = Thread.new { sleep 1; "Useful value" }
#     thr.value #=> "Useful value"
#
# ### Thread initialization
#
# In order to create new threads, Ruby provides ::new, ::start, and ::fork. A
# block must be provided with each of these methods, otherwise a ThreadError
# will be raised.
#
# When subclassing the Thread class, the `initialize` method of your subclass
# will be ignored by ::start and ::fork. Otherwise, be sure to call super in
# your `initialize` method.
#
# ### Thread termination
#
# For terminating threads, Ruby provides a variety of ways to do this.
#
# The class method ::kill, is meant to exit a given thread:
#
#     thr = Thread.new { sleep }
#     Thread.kill(thr) # sends exit() to thr
#
# Alternatively, you can use the instance method #exit, or any of its aliases
# #kill or #terminate.
#
#     thr.exit
#
# ### Thread status
#
# Ruby provides a few instance methods for querying the state of a given thread.
# To get a string with the current thread's state use #status
#
#     thr = Thread.new { sleep }
#     thr.status # => "sleep"
#     thr.exit
#     thr.status # => false
#
# You can also use #alive? to tell if the thread is running or sleeping, and
# #stop? if the thread is dead or sleeping.
#
# ### Thread variables and scope
#
# Since threads are created with blocks, the same rules apply to other Ruby
# blocks for variable scope. Any local variables created within this block are
# accessible to only this thread.
#
# #### Fiber-local vs. Thread-local
#
# Each fiber has its own bucket for Thread#[] storage. When you set a new
# fiber-local it is only accessible within this Fiber. To illustrate:
#
#     Thread.new {
#       Thread.current[:foo] = "bar"
#       Fiber.new {
#         p Thread.current[:foo] # => nil
#       }.resume
#     }.join
#
# This example uses #[] for getting and #[]= for setting fiber-locals, you can
# also use #keys to list the fiber-locals for a given thread and #key? to check
# if a fiber-local exists.
#
# When it comes to thread-locals, they are accessible within the entire scope of
# the thread. Given the following example:
#
#     Thread.new{
#       Thread.current.thread_variable_set(:foo, 1)
#       p Thread.current.thread_variable_get(:foo) # => 1
#       Fiber.new{
#         Thread.current.thread_variable_set(:foo, 2)
#         p Thread.current.thread_variable_get(:foo) # => 2
#       }.resume
#       p Thread.current.thread_variable_get(:foo)   # => 2
#     }.join
#
# You can see that the thread-local `:foo` carried over into the fiber and was
# changed to `2` by the end of the thread.
#
# This example makes use of #thread_variable_set to create new thread-locals,
# and #thread_variable_get to reference them.
#
# There is also #thread_variables to list all thread-locals, and
# #thread_variable? to check if a given thread-local exists.
#
# ### Exception handling
#
# When an unhandled exception is raised inside a thread, it will terminate. By
# default, this exception will not propagate to other threads. The exception is
# stored and when another thread calls #value or #join, the exception will be
# re-raised in that thread.
#
#     t = Thread.new{ raise 'something went wrong' }
#     t.value #=> RuntimeError: something went wrong
#
# An exception can be raised from outside the thread using the Thread#raise
# instance method, which takes the same parameters as Kernel#raise.
#
# Setting Thread.abort_on_exception = true, Thread#abort_on_exception = true, or
# $DEBUG = true will cause a subsequent unhandled exception raised in a thread
# to be automatically re-raised in the main thread.
#
# With the addition of the class method ::handle_interrupt, you can now handle
# exceptions asynchronously with threads.
#
# ### Scheduling
#
# Ruby provides a few ways to support scheduling threads in your program.
#
# The first way is by using the class method ::stop, to put the current running
# thread to sleep and schedule the execution of another thread.
#
# Once a thread is asleep, you can use the instance method #wakeup to mark your
# thread as eligible for scheduling.
#
# You can also try ::pass, which attempts to pass execution to another thread
# but is dependent on the OS whether a running thread will switch or not. The
# same goes for #priority, which lets you hint to the thread scheduler which
# threads you want to take precedence when passing execution. This method is
# also dependent on the OS and may be ignored on some platforms.
#
class Thread < Object
  # <!--
  #   rdoc-file=thread.c
  #   - Thread.current   -> thread
  # -->
  # Returns the currently executing thread.
  #
  #     Thread.current   #=> #<Thread:0x401bdf4c run>
  #
  def self.current: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.main   -> thread
  # -->
  # Returns the main thread.
  #
  def self.main: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym]   -> obj or nil
  # -->
  # Attribute Reference---Returns the value of a fiber-local variable (current
  # thread's root fiber if not explicitly inside a Fiber), using either a symbol
  # or a string name. If the specified variable does not exist, returns `nil`.
  #
  #     [
  #       Thread.new { Thread.current["name"] = "A" },
  #       Thread.new { Thread.current[:name]  = "B" },
  #       Thread.new { Thread.current["name"] = "C" }
  #     ].each do |th|
  #       th.join
  #       puts "#{th.inspect}: #{th[:name]}"
  #     end
  #
  # This will produce:
  #
  #     #<Thread:0x00000002a54220 dead>: A
  #     #<Thread:0x00000002a541a8 dead>: B
  #     #<Thread:0x00000002a54130 dead>: C
  #
  # Thread#[] and Thread#[]= are not thread-local but fiber-local. This confusion
  # did not exist in Ruby 1.8 because fibers are only available since Ruby 1.9.
  # Ruby 1.9 chooses that the methods behaves fiber-local to save following idiom
  # for dynamic scope.
  #
  #     def meth(newvalue)
  #       begin
  #         oldvalue = Thread.current[:name]
  #         Thread.current[:name] = newvalue
  #         yield
  #       ensure
  #         Thread.current[:name] = oldvalue
  #       end
  #     end
  #
  # The idiom may not work as dynamic scope if the methods are thread-local and a
  # given block switches fiber.
  #
  #     f = Fiber.new {
  #       meth(1) {
  #         Fiber.yield
  #       }
  #     }
  #     meth(2) {
  #       f.resume
  #     }
  #     f.resume
  #     p Thread.current[:name]
  #     #=> nil if fiber-local
  #     #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)
  #
  # For thread-local variables, please see #thread_variable_get and
  # #thread_variable_set.
  #
  def []: (String | Symbol key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym] = obj   -> obj
  # -->
  # Attribute Assignment---Sets or creates the value of a fiber-local variable,
  # using either a symbol or a string.
  #
  # See also Thread#[].
  #
  # For thread-local variables, please see #thread_variable_set and
  # #thread_variable_get.
  #
  def []=: (String | Symbol key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.alive?   -> true or false
  # -->
  # Returns `true` if `thr` is running or sleeping.
  #
  #     thr = Thread.new { }
  #     thr.join                #=> #<Thread:0x401b3fb0 dead>
  #     Thread.current.alive?   #=> true
  #     thr.alive?              #=> false
  #
  # See also #stop? and #status.
  #
  def alive?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.exit        -> thr
  #   - thr.kill        -> thr
  #   - thr.terminate   -> thr
  # -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def kill: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``abort on exception'' condition for
  # this `thr`.
  #
  # The default is `false`.
  #
  # See also #abort_on_exception=.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception.
  #
  def abort_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if this `thr` is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # See also #abort_on_exception.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception=.
  #
  def abort_on_exception=: (boolish abort_on_exception) -> untyped

  # <!--
  #   rdoc-file=vm_trace.c
  #   - thr.add_trace_func(proc)    -> proc
  # -->
  # Adds *proc* as a handler for tracing.
  #
  # See Thread#set_trace_func and Kernel#set_trace_func.
  #
  def add_trace_func: (untyped proc) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace    -> array or nil
  # -->
  # Returns the current backtrace of the target thread.
  #
  def backtrace: (*untyped args) -> ::Array[untyped]

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace_locations(*args)   -> array or nil
  # -->
  # Returns the execution stack for the target thread---an array containing
  # backtrace location objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # This method behaves similarly to Kernel#caller_locations except it applies to
  # a specific thread.
  #
  def backtrace_locations: (*untyped args) -> ::Array[untyped]?

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def exit: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.fetch(sym)           -> obj
  #   - thr.fetch(sym) { }       -> obj
  #   - thr.fetch(sym, default)  -> obj
  # -->
  # Returns a fiber-local for the given key. If the key can't be found, there are
  # several options: With no other arguments, it will raise a KeyError exception;
  # if *default* is given, then that will be returned; if the optional code block
  # is specified, then that will be run and its result returned.  See Thread#[]
  # and Hash#fetch.
  #
  def fetch: (*untyped sym) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.group   -> thgrp or nil
  # -->
  # Returns the ThreadGroup which contains the given thread.
  #
  #     Thread.main.group   #=> #<ThreadGroup:0x4029d914>
  #
  def group: () -> ThreadGroup?

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.new { ... }                  -> thread
  #   - Thread.new(*args, &proc)            -> thread
  #   - Thread.new(*args) { |args| ... }    -> thread
  # -->
  # Creates a new thread executing the given block.
  #
  # Any `args` given to ::new will be passed to the block:
  #
  #     arr = []
  #     a, b, c = 1, 2, 3
  #     Thread.new(a,b,c) { |d,e,f| arr << d << e << f }.join
  #     arr #=> [1, 2, 3]
  #
  # A ThreadError exception is raised if ::new is called without a block.
  #
  # If you're going to subclass Thread, be sure to call super in your `initialize`
  # method, otherwise a ThreadError will be raised.
  #
  def initialize: (*untyped) { (*untyped) -> void } -> void

  # <!--
  #   rdoc-file=thread.c
  #   - thr.join          -> thr
  #   - thr.join(limit)   -> thr
  # -->
  # The calling thread will suspend execution and run this `thr`.
  #
  # Does not return until `thr` exits or until the given `limit` seconds have
  # passed.
  #
  # If the time limit expires, `nil` will be returned, otherwise `thr` is
  # returned.
  #
  # Any threads not joined will be killed when the main program exits.
  #
  # If `thr` had previously raised an exception and the ::abort_on_exception or
  # $DEBUG flags are not set, (so the exception has not yet been processed), it
  # will be processed at this time.
  #
  #     a = Thread.new { print "a"; sleep(10); print "b"; print "c" }
  #     x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }
  #     x.join # Let thread x finish, thread a will be killed on exit.
  #     #=> "axyz"
  #
  # The following example illustrates the `limit` parameter.
  #
  #     y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}
  #     puts "Waiting" until y.join(0.15)
  #
  # This will produce:
  #
  #     tick...
  #     Waiting
  #     tick...
  #     Waiting
  #     tick...
  #     tick...
  #
  def join: (*untyped limit) -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr.key?(sym)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a fiber-local
  # variable.
  #
  #     me = Thread.current
  #     me[:oliver] = "a"
  #     me.key?(:oliver)    #=> true
  #     me.key?(:stanley)   #=> false
  #
  def key?: (Symbol sym) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.keys   -> array
  # -->
  # Returns an array of the names of the fiber-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current[:cat] = 'meow'
  #       Thread.current["dog"] = 'woof'
  #     end
  #     thr.join   #=> #<Thread:0x401b3f10 dead>
  #     thr.keys   #=> [:dog, :cat]
  #
  def keys: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name   -> string
  # -->
  # show the name of the thread.
  #
  def name: () -> String

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name=(name)   -> string
  # -->
  # set given name to the ruby thread. On some platform, it may set the name to
  # pthread and/or kernel.
  #
  def name=: (untyped name) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.native_thread_id   -> integer
  # -->
  # Return the native thread ID which is used by the Ruby thread.
  #
  # The ID depends on the OS. (not POSIX thread ID returned by pthread_self(3))
  # *   On Linux it is TID returned by gettid(2).
  # *   On macOS it is the system-wide unique integral ID of thread returned by
  #     pthread_threadid_np(3).
  # *   On FreeBSD it is the unique integral ID of the thread returned by
  #     pthread_getthreadid_np(3).
  # *   On Windows it is the thread identifier returned by GetThreadId().
  # *   On other platforms, it raises NotImplementedError.
  #
  #
  # NOTE: If the thread is not associated yet or already deassociated with a
  # native thread, it returns *nil*. If the Ruby implementation uses M:N thread
  # model, the ID may change depending on the timing.
  #
  def native_thread_id: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - target_thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty for the target thread.
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # See ::pending_interrupt? for more information.
  #
  def pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority   -> integer
  # -->
  # Returns the priority of *thr*. Default is inherited from the current thread
  # which creating the new thread, or zero for the initial main thread;
  # higher-priority thread will run more frequently than lower-priority threads
  # (but lower-priority threads can also run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     Thread.current.priority   #=> 0
  #
  def priority: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority= integer   -> thr
  # -->
  # Sets the priority of *thr* to *integer*. Higher-priority threads will run more
  # frequently than lower-priority threads (but lower-priority threads can also
  # run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     count1 = count2 = 0
  #     a = Thread.new do
  #           loop { count1 += 1 }
  #         end
  #     a.priority = -1
  #
  #     b = Thread.new do
  #           loop { count2 += 1 }
  #         end
  #     b.priority = -2
  #     sleep 1   #=> 1
  #     count1    #=> 622504
  #     count2    #=> 5832
  #
  def priority=: (Integer priority) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``report on exception'' condition for
  # this `thr`.
  #
  # The default value when creating a Thread is the value of the global flag
  # Thread.report_on_exception.
  #
  # See also #report_on_exception=.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, a message is printed on $stderr if an exception kills this
  # `thr`.  See ::report_on_exception for details.
  #
  # See also #report_on_exception.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception=: (boolish report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.run   -> thr
  # -->
  # Wakes up `thr`, making it eligible for scheduling.
  #
  #     a = Thread.new { puts "a"; Thread.stop; puts "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     puts "Got here"
  #     a.run
  #     a.join
  #
  # This will produce:
  #
  #     a
  #     Got here
  #     c
  #
  # See also the instance method #wakeup.
  #
  def run: () -> Thread

  # Returns the safe level.
  #
  # This method is obsolete because $SAFE is a process global state. Simply
  # check $SAFE.
  def safe_level: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.status   -> string, false or nil
  # -->
  # Returns the status of `thr`.
  #
  # `"sleep"`
  # :   Returned if this thread is sleeping or waiting on I/O
  # `"run"`
  # :   When this thread is executing
  # `"aborting"`
  # :   If this thread is aborting
  # `false`
  # :   When this thread is terminated normally
  # `nil`
  # :   If terminated with an exception.
  #
  #
  #     a = Thread.new { raise("die now") }
  #     b = Thread.new { Thread.stop }
  #     c = Thread.new { Thread.exit }
  #     d = Thread.new { sleep }
  #     d.kill                  #=> #<Thread:0x401b3678 aborting>
  #     a.status                #=> nil
  #     b.status                #=> "sleep"
  #     c.status                #=> false
  #     d.status                #=> "aborting"
  #     Thread.current.status   #=> "run"
  #
  # See also the instance methods #alive? and #stop?
  #
  def status: () -> (String | bool)?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.stop?   -> true or false
  # -->
  # Returns `true` if `thr` is dead or sleeping.
  #
  #     a = Thread.new { Thread.stop }
  #     b = Thread.current
  #     a.stop?   #=> true
  #     b.stop?   #=> false
  #
  # See also #alive? and #status.
  #
  def stop?: () -> bool

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def terminate: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable?(key)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a thread-local
  # variable.
  #
  #     me = Thread.current
  #     me.thread_variable_set(:oliver, "a")
  #     me.thread_variable?(:oliver)    #=> true
  #     me.thread_variable?(:stanley)   #=> false
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variable?: (String | Symbol key) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_get(key)  -> obj or nil
  # -->
  # Returns the value of a thread local variable that has been set.  Note that
  # these are different than fiber local values.  For fiber local values, please
  # see Thread#[] and Thread#[]=.
  #
  # Thread local values are carried along with threads, and do not respect fibers.
  #  For example:
  #
  #     Thread.new {
  #       Thread.current.thread_variable_set("foo", "bar") # set a thread local
  #       Thread.current["foo"] = "bar"                    # set a fiber local
  #
  #       Fiber.new {
  #         Fiber.yield [
  #           Thread.current.thread_variable_get("foo"), # get the thread local
  #           Thread.current["foo"],                     # get the fiber local
  #         ]
  #       }.resume
  #     }.join.value # => ['bar', nil]
  #
  # The value "bar" is returned for the thread local, where nil is returned for
  # the fiber local.  The fiber is executed in the same thread, so the thread
  # local values are available.
  #
  def thread_variable_get: (untyped key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_set(key, value)
  # -->
  # Sets a thread local with `key` to `value`.  Note that these are local to
  # threads, and not to fibers.  Please see Thread#thread_variable_get and
  # Thread#[] for more information.
  #
  def thread_variable_set: (untyped key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variables   -> array
  # -->
  # Returns an array of the names of the thread-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current.thread_variable_set(:cat, 'meow')
  #       Thread.current.thread_variable_set("dog", 'woof')
  #     end
  #     thr.join               #=> #<Thread:0x401b3f10 dead>
  #     thr.thread_variables   #=> [:dog, :cat]
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.value   -> obj
  # -->
  # Waits for `thr` to complete, using #join, and returns its value or raises the
  # exception which terminated the thread.
  #
  #     a = Thread.new { 2 + 2 }
  #     a.value   #=> 4
  #
  #     b = Thread.new { raise 'something went wrong' }
  #     b.value   #=> RuntimeError: something went wrong
  #
  def value: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.wakeup   -> thr
  # -->
  # Marks a given thread as eligible for scheduling, however it may still remain
  # blocked on I/O.
  #
  # **Note:** This does not invoke the scheduler, see #run for more information.
  #
  #     c = Thread.new { Thread.stop; puts "hey!" }
  #     sleep 0.1 while c.status!='sleep'
  #     c.wakeup
  #     c.join
  #     #=> "hey!"
  #
  def wakeup: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception   -> true or false
  # -->
  # Returns the status of the global ``abort on exception'' condition.
  #
  # The default is `false`.
  #
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # Can also be specified by the global $DEBUG flag or command line option `-d`.
  #
  # See also ::abort_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception.
  #
  def self.abort_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread. Returns the new state.
  #
  #     Thread.abort_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "not reached"
  #
  # This will produce:
  #
  #     In new thread
  #     prog.rb:4: Exception from thread (RuntimeError)
  #      from prog.rb:2:in `initialize'
  #      from prog.rb:2:in `new'
  #      from prog.rb:2
  #
  # See also ::abort_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception=.
  #
  def self.abort_on_exception=: (untyped abort_on_exception) -> untyped

  # Wraps the block in a single, VM-global
  # [Mutex\#synchronize](https://ruby-doc.org/core-2.6.3/Mutex.html#method-i-synchronize)
  # , returning the value of the block. A thread executing inside the
  # exclusive section will only block other threads which also use the
  # [::exclusive](Thread.downloaded.ruby_doc#method-c-exclusive) mechanism.
  def self.exclusive: () { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.exit   -> thread
  # -->
  # Terminates the currently running thread and schedules another thread to be
  # run.
  #
  # If this thread is already marked to be killed, ::exit returns the Thread.
  #
  # If this is the main thread, or the last  thread, exit the process.
  #
  def self.exit: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.fork: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.handle_interrupt(hash) { ... } -> result of the block
  # -->
  # Changes asynchronous interrupt timing.
  #
  # *interrupt* means asynchronous event and corresponding procedure by
  # Thread#raise, Thread#kill, signal trap (not supported yet) and main thread
  # termination (if main thread terminates, then all other thread will be killed).
  #
  # The given `hash` has pairs like `ExceptionClass => :TimingSymbol`. Where the
  # ExceptionClass is the interrupt handled by the given block. The TimingSymbol
  # can be one of the following symbols:
  #
  # `:immediate`
  # :   Invoke interrupts immediately.
  # `:on_blocking`
  # :   Invoke interrupts while *BlockingOperation*.
  # `:never`
  # :   Never invoke all interrupts.
  #
  #
  # *BlockingOperation* means that the operation will block the calling thread,
  # such as read and write.  On CRuby implementation, *BlockingOperation* is any
  # operation executed without GVL.
  #
  # Masked asynchronous interrupts are delayed until they are enabled. This method
  # is similar to sigprocmask(3).
  #
  # ### NOTE
  #
  # Asynchronous interrupts are difficult to use.
  #
  # If you need to communicate between threads, please consider to use another way
  # such as Queue.
  #
  # Or use them with deep understanding about this method.
  #
  # ### Usage
  #
  # In this example, we can guard from Thread#raise exceptions.
  #
  # Using the `:never` TimingSymbol the RuntimeError exception will always be
  # ignored in the first block of the main thread. In the second
  # ::handle_interrupt block we can purposefully handle RuntimeError exceptions.
  #
  #     th = Thread.new do
  #       Thread.handle_interrupt(RuntimeError => :never) {
  #         begin
  #           # You can write resource allocation code safely.
  #           Thread.handle_interrupt(RuntimeError => :immediate) {
  #             # ...
  #           }
  #         ensure
  #           # You can write resource deallocation code safely.
  #         end
  #       }
  #     end
  #     Thread.pass
  #     # ...
  #     th.raise "stop"
  #
  # While we are ignoring the RuntimeError exception, it's safe to write our
  # resource allocation code. Then, the ensure block is where we can safely
  # deallocate your resources.
  #
  # #### Guarding from Timeout::Error
  #
  # In the next example, we will guard from the Timeout::Error exception. This
  # will help prevent from leaking resources when Timeout::Error exceptions occur
  # during normal ensure clause. For this example we use the help of the standard
  # library Timeout, from lib/timeout.rb
  #
  #     require 'timeout'
  #     Thread.handle_interrupt(Timeout::Error => :never) {
  #       timeout(10){
  #         # Timeout::Error doesn't occur here
  #         Thread.handle_interrupt(Timeout::Error => :on_blocking) {
  #           # possible to be killed by Timeout::Error
  #           # while blocking operation
  #         }
  #         # Timeout::Error doesn't occur here
  #       }
  #     }
  #
  # In the first part of the `timeout` block, we can rely on Timeout::Error being
  # ignored. Then in the `Timeout::Error => :on_blocking` block, any operation
  # that will block the calling thread is susceptible to a Timeout::Error
  # exception being raised.
  #
  # #### Stack control settings
  #
  # It's possible to stack multiple levels of ::handle_interrupt blocks in order
  # to control more than one ExceptionClass and TimingSymbol at a time.
  #
  #     Thread.handle_interrupt(FooError => :never) {
  #       Thread.handle_interrupt(BarError => :never) {
  #          # FooError and BarError are prohibited.
  #       }
  #     }
  #
  # #### Inheritance with ExceptionClass
  #
  # All exceptions inherited from the ExceptionClass parameter will be considered.
  #
  #     Thread.handle_interrupt(Exception => :never) {
  #       # all exceptions inherited from Exception are prohibited.
  #     }
  #
  # For handling all interrupts, use `Object` and not `Exception` as the
  # ExceptionClass, as kill/terminate interrupts are not handled by `Exception`.
  #
  def self.handle_interrupt: (untyped hash) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.kill(thread)   -> thread
  # -->
  # Causes the given `thread` to exit, see also Thread::exit.
  #
  #     count = 0
  #     a = Thread.new { loop { count += 1 } }
  #     sleep(0.1)       #=> 0
  #     Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>
  #     count            #=> 93947
  #     a.alive?         #=> false
  #
  def self.kill: (Thread thread) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.list   -> array
  # -->
  # Returns an array of Thread objects for all threads that are either runnable or
  # stopped.
  #
  #     Thread.new { sleep(200) }
  #     Thread.new { 1000000.times {|i| i*i } }
  #     Thread.new { Thread.stop }
  #     Thread.list.each {|t| p t}
  #
  # This will produce:
  #
  #     #<Thread:0x401b3e84 sleep>
  #     #<Thread:0x401b3f38 run>
  #     #<Thread:0x401b3fb0 sleep>
  #     #<Thread:0x401bdf4c run>
  #
  def self.list: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pass   -> nil
  # -->
  # Give the thread scheduler a hint to pass execution to another thread. A
  # running thread may or may not switch, it depends on OS and processor.
  #
  def self.pass: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty.
  #
  # Since Thread::handle_interrupt can be used to defer asynchronous events, this
  # method can be used to determine if there are any deferred events.
  #
  # If you find this method returns true, then you may finish `:never` blocks.
  #
  # For example, the following method processes deferred asynchronous events
  # immediately.
  #
  #     def Thread.kick_interrupt_immediately
  #       Thread.handle_interrupt(Object => :immediate) {
  #         Thread.pass
  #       }
  #     end
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # ### Usage
  #
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           if Thread.pending_interrupt?
  #             Thread.handle_interrupt(Object => :immediate){}
  #           end
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     th.raise # stop thread
  #
  # This example can also be written as the following, which you should use to
  # avoid asynchronous interrupts.
  #
  #     flag = true
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           break if flag == false
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     flag = false # stop thread
  #
  def self.pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception   -> true or false
  # -->
  # Returns the status of the global ``report on exception'' condition.
  #
  # The default is `true` since Ruby 2.5.
  #
  # All threads created when this flag is true will report a message on $stderr if
  # an exception kills the thread.
  #
  #     Thread.new { 1.times { raise } }
  #
  # will produce this output on $stderr:
  #
  #     #<Thread:...> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #             2: from -e:1:in `block in <main>'
  #             1: from -e:1:in `times'
  #
  # This is done to catch errors in threads early. In some cases, you might not
  # want this output. There are multiple ways to avoid the extra output:
  #
  # *   If the exception is not intended, the best is to fix the cause of the
  #     exception so it does not happen anymore.
  # *   If the exception is intended, it might be better to rescue it closer to
  #     where it is raised rather then let it kill the Thread.
  # *   If it is guaranteed the Thread will be joined with Thread#join or
  #     Thread#value, then it is safe to disable this report with
  #     `Thread.current.report_on_exception = false` when starting the Thread.
  #     However, this might handle the exception much later, or not at all if the
  #     Thread is never joined due to the parent thread being blocked, etc.
  #
  #
  # See also ::report_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception= boolean   -> true or false
  # -->
  # Returns the new state. When set to `true`, all threads created afterwards will
  # inherit the condition and report a message on $stderr if an exception kills a
  # thread:
  #
  #     Thread.report_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "In the main thread"
  #
  # This will produce:
  #
  #     In new thread
  #     #<Thread:...prog.rb:2> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #     prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)
  #     In the main thread
  #
  # See also ::report_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception=: (untyped report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.start: (*untyped args) { (*untyped) -> void } -> instance

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.stop   -> nil
  # -->
  # Stops execution of the current thread, putting it into a ``sleep'' state, and
  # schedules execution of another thread.
  #
  #     a = Thread.new { print "a"; Thread.stop; print "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     print "b"
  #     a.run
  #     a.join
  #     #=> "abc"
  #
  def self.stop: () -> untyped
end

# <!-- rdoc-file=vm_backtrace.c -->
# An internal representation of the backtrace. The user will never interact with
# objects of this class directly, but class methods can be used to get backtrace
# settings of the current session.
#
class Thread::Backtrace < Object
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - Threade::Backtrace::limit -> integer
  # -->
  # Returns maximum backtrace length set by `--backtrace-limit` command-line
  # option. The defalt is `-1` which means unlimited backtraces. If the value is
  # zero or positive, the error backtraces, produced by Exception#full_message,
  # are abbreviated and the extra lines are replaced by `... 3 levels... `
  #
  #     $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     - 1
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #         from -e:1:in `<main>'
  #
  #     $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     2
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #
  #     $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     0
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #          ... 9 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #          ... 9 levels...
  #
  def self.limit: () -> Integer
end

# <!-- rdoc-file=vm_backtrace.c -->
# An object representation of a stack frame, initialized by
# Kernel#caller_locations.
#
# For example:
#
#     # caller_locations.rb
#     def a(skip)
#       caller_locations(skip)
#     end
#     def b(skip)
#       a(skip)
#     end
#     def c(skip)
#       b(skip)
#     end
#
#     c(0..2).map do |call|
#       puts call.to_s
#     end
#
# Running `ruby caller_locations.rb` will produce:
#
#     caller_locations.rb:2:in `a'
#     caller_locations.rb:5:in `b'
#     caller_locations.rb:8:in `c'
#
# Here's another example with a slightly different result:
#
#     # foo.rb
#     class Foo
#       attr_accessor :locations
#       def initialize(skip)
#         @locations = caller_locations(skip)
#       end
#     end
#
#     Foo.new(0..2).locations.map do |call|
#       puts call.to_s
#     end
#
# Now run `ruby foo.rb` and you should see:
#
#     init.rb:4:in `initialize'
#     init.rb:8:in `new'
#     init.rb:8:in `<main>'
#
class Thread::Backtrace::Location
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - absolute_path()
  # -->
  # Returns the full file path of this frame.
  #
  # Same as #path, except that it will return absolute path even if the frame is
  # in the main script.
  #
  def absolute_path: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - base_label()
  # -->
  # Returns the base label of this frame.
  #
  # Usually same as #label, without decoration.
  #
  def base_label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - label()
  # -->
  # Returns the label of this frame.
  #
  # Usually consists of method, class, module, etc names with decoration.
  #
  # Consider the following example:
  #
  #     def foo
  #       puts caller_locations(0).first.label
  #
  #       1.times do
  #         puts caller_locations(0).first.label
  #
  #         1.times do
  #           puts caller_locations(0).first.label
  #         end
  #
  #       end
  #     end
  #
  # The result of calling `foo` is this:
  #
  #     label: foo
  #     label: block in foo
  #     label: block (2 levels) in foo
  #
  def label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - lineno()
  # -->
  # Returns the line number of this frame.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.lineno #=> 2
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - path()
  # -->
  # Returns the file name of this frame. This will generally be an absolute path,
  # unless the frame is in the main script, in which case it will be the script
  # location passed on the command line.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.path #=> caller_locations.rb
  #
  def path: () -> String?
end

# <!-- rdoc-file=thread_sync.c -->
# ConditionVariable objects augment class Mutex. Using condition variables, it
# is possible to suspend while in the middle of a critical section until a
# resource becomes available.
#
# Example:
#
#     mutex = Thread::Mutex.new
#     resource = Thread::ConditionVariable.new
#
#     a = Thread.new {
#        mutex.synchronize {
#          # Thread 'a' now needs the resource
#          resource.wait(mutex)
#          # 'a' can now have the resource
#        }
#     }
#
#     b = Thread.new {
#        mutex.synchronize {
#          # Thread 'b' has finished using the resource
#          resource.signal
#        }
#     }
#
class Thread::ConditionVariable < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - broadcast()
  # -->
  # Wakes up all threads waiting for this lock.
  #
  def broadcast: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - signal()
  # -->
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - wait(mutex, timeout=nil)
  # -->
  # Releases the lock held in `mutex` and waits; reacquires the lock on wakeup.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed,
  # even if no other thread doesn't signal.
  #
  # Returns the slept result on `mutex`.
  #
  def wait: (Thread::Mutex mutex, ?Integer timeout) -> self
end

# <!-- rdoc-file=thread_sync.c -->
# Thread::Mutex implements a simple semaphore that can be used to coordinate
# access to shared data from multiple concurrent threads.
#
# Example:
#
#     semaphore = Thread::Mutex.new
#
#     a = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
#     b = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
class Thread::Mutex < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.lock  -> self
  # -->
  # Attempts to grab the lock and waits if it isn't available. Raises
  # `ThreadError` if `mutex` was locked by the current thread.
  #
  def lock: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.locked?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by some thread.
  #
  def locked?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.owned?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by current thread.
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.synchronize { ... }    -> result of the block
  # -->
  # Obtains a lock, runs the block, and releases the lock when the block
  # completes.  See the example under Thread::Mutex.
  #
  def synchronize: [X] () { () -> X } -> X

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.try_lock  -> true or false
  # -->
  # Attempts to obtain the lock and returns immediately. Returns `true` if the
  # lock was granted.
  #
  def try_lock: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.unlock    -> self
  # -->
  # Releases the lock. Raises `ThreadError` if `mutex` wasn't locked by the
  # current thread.
  #
  def unlock: () -> self
end

# <!-- rdoc-file=thread_sync.c -->
# The Thread::Queue class implements multi-producer, multi-consumer queues.  It
# is especially useful in threaded programming when information must be
# exchanged safely between multiple threads. The Thread::Queue class implements
# all the required locking semantics.
#
# The class implements FIFO type of queue. In a FIFO queue, the first tasks
# added are the first retrieved.
#
# Example:
#
#     queue = Thread::Queue.new
#
#     producer = Thread.new do
#       5.times do |i|
#          sleep rand(i) # simulate expense
#          queue << i
#          puts "#{i} produced"
#       end
#     end
#
#     consumer = Thread.new do
#       5.times do |i|
#          value = queue.pop
#          sleep rand(i/2) # simulate expense
#          puts "consumed #{value}"
#       end
#     end
#
#     consumer.join
#
class Thread::Queue < Object
  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias << push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - clear()
  # -->
  # Removes all objects from the queue.
  #
  def clear: () -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - close
  # -->
  # Closes the queue. A closed queue cannot be re-opened.
  #
  # After the call to close completes, the following are true:
  #
  # *   `closed?` will return true
  #
  # *   `close` will be ignored.
  #
  # *   calling enq/push/<< will raise a `ClosedQueueError`.
  #
  # *   when `empty?` is false, calling deq/pop/shift will return an object from
  #     the queue as usual.
  # *   when `empty?` is true, deq(false) will not suspend the thread and will
  #     return nil. deq(true) will raise a `ThreadError`.
  #
  #
  # ClosedQueueError is inherited from StopIteration, so that you can break loop
  # block.
  #
  # Example:
  #
  #     q = Thread::Queue.new
  #     Thread.new{
  #       while e = q.deq # wait for nil to break loop
  #         # ...
  #       end
  #     }
  #     q.close
  #
  def close: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - closed?
  # -->
  # Returns `true` if the queue is closed.
  #
  def closed?: () -> bool

  # <!-- rdoc-file=thread_sync.c -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  alias deq pop

  # <!--
  #   rdoc-file=thread_sync.c
  #   - empty?
  # -->
  # Returns `true` if the queue is empty.
  #
  def empty?: () -> bool

  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - length
  #   - size
  # -->
  # Returns the length of the queue.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - num_waiting()
  # -->
  # Returns the number of threads waiting on the queue.
  #
  def num_waiting: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - pop(non_block=false)
  #   - deq(non_block=false)
  #   - shift(non_block=false)
  # -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  def pop: (?boolish non_block) -> untyped

  # <!--
  #   rdoc-file=thread_sync.c
  #   - push(object)
  #   - enq(object)
  #   - <<(object)
  # -->
  # Pushes the given `object` to the queue.
  #
  def push: (untyped obj) -> void

  # <!-- rdoc-file=thread_sync.c -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  alias shift pop

  # <!-- rdoc-file=thread_sync.c -->
  # Returns the length of the queue.
  #
  alias size length
end

# <!-- rdoc-file=thread_sync.c -->
# This class represents queues of specified size capacity.  The push operation
# may be blocked if the capacity is full.
#
# See Thread::Queue for an example of how a Thread::SizedQueue works.
#
class Thread::SizedQueue < Thread::Queue
  # <!-- rdoc-file=thread_sync.c -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  alias << push

  # <!-- rdoc-file=thread_sync.c -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - new(max)
  # -->
  # Creates a fixed-length queue with a maximum size of `max`.
  #
  def initialize: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max()
  # -->
  # Returns the maximum size of the queue.
  #
  def max: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max=(number)
  # -->
  # Sets the maximum size of the queue to the given `number`.
  #
  def max=: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - push(object, non_block=false)
  #   - enq(object, non_block=false)
  #   - <<(object)
  # -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  def push: (untyped obj, ?boolish non_block) -> void
end

ConditionVariable: singleton(Thread::ConditionVariable)

Mutex: singleton(Thread::Mutex)

Queue: singleton(Thread::Queue)

SizedQueue: singleton(Thread::SizedQueue)

# <!-- rdoc-file=proc.c -->
# Method objects are created by Object#method, and are associated with a
# particular object (not just with a class).  They may be used to invoke the
# method within the object, and as a block associated with an iterator.  They
# may also be unbound from one object (creating an UnboundMethod) and bound to
# another.
#
#     class Thing
#       def square(n)
#         n*n
#       end
#     end
#     thing = Thing.new
#     meth  = thing.method(:square)
#
#     meth.call(9)                 #=> 81
#     [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]
#
#     [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3
#
#     require 'date'
#     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
#     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
#
class Method < Object
  # <!--
  #   rdoc-file=proc.c
  #   - meth.to_proc    -> proc
  # -->
  # Returns a Proc object corresponding to this method.
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.call(args, ...)    -> obj
  # -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  def call: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth << g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls *g* with them then
  # calls this method with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f << g).call(2) #=> 16
  #
  def <<: (Proc g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias === call

  # <!--
  #   rdoc-file=proc.c
  #   - meth >> g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls this method with
  # them then calls *g* with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f >> g).call(2) #=> 8
  #
  def >>: (Proc g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias [] call

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> Method

  # <!--
  #   rdoc-file=proc.c
  #   - meth.curry        -> proc
  #   - meth.curry(arity) -> proc
  # -->
  # Returns a curried proc based on the method. When the proc is called with a
  # number of arguments that is lower than the method's arity, then another
  # curried proc is returned. Only when enough arguments have been supplied to
  # satisfy the method signature, will the method actually be called.
  #
  # The optional *arity* argument should be supplied when currying methods with
  # variable arguments to determine how many arguments are needed before the
  # method is called.
  #
  #     def foo(a,b,c)
  #       [a, b, c]
  #     end
  #
  #     proc  = self.method(:foo).curry
  #     proc2 = proc.call(1, 2)          #=> #<Proc>
  #     proc2.call(3)                    #=> [1,2,3]
  #
  #     def vararg(*args)
  #       args
  #     end
  #
  #     proc = self.method(:vararg).curry(4)
  #     proc2 = proc.call(:x)      #=> #<Proc>
  #     proc3 = proc2.call(:y, :z) #=> #<Proc>
  #     proc3.call(:a)             #=> [:x, :y, :z, :a]
  #
  def curry: (?Integer arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module that defines the method. See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> (Class | Module)

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> ::Array[[ :req | :opt | :rest | :keyreq | :key | :keyrest | :block, Symbol ] | [ :rest | :keyrest ]]

  # <!--
  #   rdoc-file=proc.c
  #   - meth.private? -> true or false
  # -->
  # Returns whether the method is private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.protected? -> true or false
  # -->
  # Returns whether the method is protected.
  #
  def protected?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.public? -> true or false
  # -->
  # Returns whether the method is public.
  #
  def public?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.receiver    -> object
  # -->
  # Returns the bound receiver of the method object.
  #
  #     (1..3).method(:map).receiver # => 1..3
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> Method?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.unbind    -> unbound_method
  # -->
  # Dissociates *meth* from its current receiver. The resulting UnboundMethod can
  # subsequently be bound to a new object of the same class (see UnboundMethod).
  #
  def unbind: () -> UnboundMethod
end

# <!-- rdoc-file=rational.c -->
# A rational number can be represented as a pair of integer numbers: a/b (b>0),
# where a is the numerator and b is the denominator. Integer a equals rational
# a/1 mathematically.
#
# You can create a Rational object explicitly with:
#
# *   A [rational
#     literal](doc/syntax/literals_rdoc.html#label-Rational+Literals).
#
#
# You can convert certain objects to Rationals with:
#
# *   Method [Rational](Kernel.html#method-i-Rational).
#
#
# Examples
#
#     Rational(1)      #=> (1/1)
#     Rational(2, 3)   #=> (2/3)
#     Rational(4, -6)  #=> (-2/3) # Reduced.
#     3.to_r           #=> (3/1)
#     2/3r             #=> (2/3)
#
# You can also create rational objects from floating-point numbers or strings.
#
#     Rational(0.3)    #=> (5404319552844595/18014398509481984)
#     Rational('0.3')  #=> (3/10)
#     Rational('2/3')  #=> (2/3)
#
#     0.3.to_r         #=> (5404319552844595/18014398509481984)
#     '0.3'.to_r       #=> (3/10)
#     '2/3'.to_r       #=> (2/3)
#     0.3.rationalize  #=> (3/10)
#
# A rational object is an exact number, which helps you to write programs
# without any rounding errors.
#
#     10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
#     10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)
#
# However, when an expression includes an inexact component (numerical value or
# operation), it will produce an inexact result.
#
#     Rational(10) / 3   #=> (10/3)
#     Rational(10) / 3.0 #=> 3.3333333333333335
#
#     Rational(-8) ** Rational(1, 3)
#                        #=> (1.0000000000000002+1.7320508075688772i)
#
class Rational < Numeric
  public

  def %: (Integer) -> Rational
       | (Float) -> Float
       | (Rational) -> Rational
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat * numeric  ->  numeric
  # -->
  # Performs multiplication.
  #
  #     Rational(2, 3)  * Rational(2, 3)   #=> (4/9)
  #     Rational(900)   * Rational(1)      #=> (900/1)
  #     Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)
  #     Rational(9, 8)  * 4                #=> (9/2)
  #     Rational(20, 9) * 9.8              #=> 21.77777777777778
  #
  def *: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat ** numeric  ->  numeric
  # -->
  # Performs exponentiation.
  #
  #     Rational(2)    ** Rational(3)     #=> (8/1)
  #     Rational(10)   ** -2              #=> (1/100)
  #     Rational(10)   ** -2.0            #=> 0.01
  #     Rational(-4)   ** Rational(1, 2)  #=> (0.0+2.0i)
  #     Rational(1, 2) ** 0               #=> (1/1)
  #     Rational(1, 2) ** 0.0             #=> 1.0
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat + numeric  ->  numeric
  # -->
  # Performs addition.
  #
  #     Rational(2, 3)  + Rational(2, 3)   #=> (4/3)
  #     Rational(900)   + Rational(1)      #=> (901/1)
  #     Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)
  #     Rational(9, 8)  + 4                #=> (41/8)
  #     Rational(20, 9) + 9.8              #=> 12.022222222222222
  #
  def +: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  def +@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat - numeric  ->  numeric
  # -->
  # Performs subtraction.
  #
  #     Rational(2, 3)  - Rational(2, 3)   #=> (0/1)
  #     Rational(900)   - Rational(1)      #=> (899/1)
  #     Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)
  #     Rational(9, 8)  - 4                #=> (-23/8)
  #     Rational(20, 9) - 9.8              #=> -7.577777777777778
  #
  def -: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - -rat  ->  rational
  # -->
  # Negates `rat`.
  #
  def -@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat / numeric     ->  numeric
  #   - rat.quo(numeric)  ->  numeric
  # -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def /: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rational <=> numeric  ->  -1, 0, +1, or nil
  # -->
  # Returns -1, 0, or +1 depending on whether `rational` is less than, equal to,
  # or greater than `numeric`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  #     Rational(2, 3) <=> Rational(2, 3)  #=> 0
  #     Rational(5)    <=> 5               #=> 0
  #     Rational(2, 3) <=> Rational(1, 3)  #=> 1
  #     Rational(1, 3) <=> 1               #=> -1
  #     Rational(1, 3) <=> 0.3             #=> 1
  #
  #     Rational(1, 3) <=> "0.3"           #=> nil
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat == object  ->  true or false
  # -->
  # Returns `true` if `rat` equals `object` numerically.
  #
  #     Rational(2, 3)  == Rational(2, 3)   #=> true
  #     Rational(5)     == 5                #=> true
  #     Rational(0)     == 0.0              #=> true
  #     Rational('1/3') == 0.33             #=> false
  #     Rational('1/2') == '1/2'            #=> false
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.abs        ->  rational
  #   - rat.magnitude  ->  rational
  # -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  # Rational#magnitude is an alias for Rational#abs.
  #
  def abs: () -> Rational

  def abs2: () -> Rational

  def angle: () -> (Integer | Float)

  alias arg angle

  # <!--
  #   rdoc-file=rational.c
  #   - rat.ceil([ndigits])  ->  integer or rational
  # -->
  # Returns the smallest number greater than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).ceil      #=> 3
  #     Rational(2, 3).ceil   #=> 1
  #     Rational(-3, 2).ceil  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').ceil(+1).to_f  #=> -123.4
  #     Rational('-123.456').ceil(-1)       #=> -120
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Rational)

  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Rational

  def conjugate: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  #     Rational(7).denominator             #=> 1
  #     Rational(7, 1).denominator          #=> 1
  #     Rational(9, -4).denominator         #=> 4
  #     Rational(-2, -10).denominator       #=> 5
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  def divmod: (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.fdiv(numeric)  ->  float
  # -->
  # Performs division and returns the value as a Float.
  #
  #     Rational(2, 3).fdiv(1)       #=> 0.6666666666666666
  #     Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333
  #     Rational(2).fdiv(3)          #=> 0.6666666666666666
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.floor([ndigits])  ->  integer or rational
  # -->
  # Returns the largest number less than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).floor      #=> 3
  #     Rational(2, 3).floor   #=> 0
  #     Rational(-3, 2).floor  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').floor(+1).to_f  #=> -123.5
  #     Rational('-123.456').floor(-1)       #=> -130
  #
  def floor: () -> Integer
           | (Integer digits) -> (Integer | Rational)

  # <!--
  #   rdoc-file=rational.c
  #   - hash()
  # -->
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Rational(2).inspect      #=> "(2/1)"
  #     Rational(-8, 6).inspect  #=> "(-4/3)"
  #     Rational('1/2').inspect  #=> "(1/2)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  # Rational#magnitude is an alias for Rational#abs.
  #
  alias magnitude abs

  def modulo: (Float) -> Float
            | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.negative?  ->  true or false
  # -->
  # Returns `true` if `rat` is less than 0.
  #
  def negative?: () -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  #     Rational(7).numerator        #=> 7
  #     Rational(7, 1).numerator     #=> 7
  #     Rational(9, -4).numerator    #=> -9
  #     Rational(-2, -10).numerator  #=> 1
  #
  def numerator: () -> Integer

  alias phase angle

  def polar: () -> [ Rational, Integer | Float ]

  # <!--
  #   rdoc-file=rational.c
  #   - rat.positive?  ->  true or false
  # -->
  # Returns `true` if `rat` is greater than 0.
  #
  def positive?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def quo: (Float) -> Float
         | (Complex) -> Complex
         | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.rationalize       ->  self
  #   - rat.rationalize(eps)  ->  rational
  # -->
  # Returns a simpler approximation of the value if the optional argument `eps` is
  # given (rat-|eps| <= result <= rat+|eps|), self otherwise.
  #
  #     r = Rational(5033165, 16777216)
  #     r.rationalize                    #=> (5033165/16777216)
  #     r.rationalize(Rational('0.01'))  #=> (3/10)
  #     r.rationalize(Rational('0.1'))   #=> (1/3)
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Rational

  def real?: () -> true

  def rect: () -> [ Rational, Numeric ]

  alias rectangular rect

  def remainder: (Float) -> Float
               | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.round([ndigits] [, half: mode])  ->  integer or rational
  # -->
  # Returns `rat` rounded to the nearest value with a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).round      #=> 3
  #     Rational(2, 3).round   #=> 1
  #     Rational(-3, 2).round  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').round(+1).to_f  #=> -123.5
  #     Rational('-123.456').round(-1)       #=> -120
  #
  # The optional `half` keyword argument is available similar to Float#round.
  #
  #     Rational(25, 100).round(1, half: :up)    #=> (3/10)
  #     Rational(25, 100).round(1, half: :down)  #=> (1/5)
  #     Rational(25, 100).round(1, half: :even)  #=> (1/5)
  #     Rational(35, 100).round(1, half: :up)    #=> (2/5)
  #     Rational(35, 100).round(1, half: :down)  #=> (3/10)
  #     Rational(35, 100).round(1, half: :even)  #=> (2/5)
  #     Rational(-25, 100).round(1, half: :up)   #=> (-3/10)
  #     Rational(-25, 100).round(1, half: :down) #=> (-1/5)
  #     Rational(-25, 100).round(1, half: :even) #=> (-1/5)
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (Integer digits, ?half: :up | :down | :even) -> (Integer | Rational)

  def step: (?Numeric limit, ?Numeric step) { (Rational) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Rational, self]
          | (?by: Numeric, ?to: Numeric) { (Rational) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Rational, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_f  ->  float
  # -->
  # Returns the value as a Float.
  #
  #     Rational(2).to_f      #=> 2.0
  #     Rational(9, 4).to_f   #=> 2.25
  #     Rational(-3, 4).to_f  #=> -0.75
  #     Rational(20, 3).to_f  #=> 6.666666666666667
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_i  ->  integer
  # -->
  # Returns the truncated value as an integer.
  #
  # Equivalent to Rational#truncate.
  #
  #     Rational(2, 3).to_i    #=> 0
  #     Rational(3).to_i       #=> 3
  #     Rational(300.6).to_i   #=> 300
  #     Rational(98, 71).to_i  #=> 1
  #     Rational(-31, 2).to_i  #=> -15
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_r  ->  self
  # -->
  # Returns self.
  #
  #     Rational(2).to_r      #=> (2/1)
  #     Rational(-8, 6).to_r  #=> (-4/3)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_s  ->  string
  # -->
  # Returns the value as a string.
  #
  #     Rational(2).to_s      #=> "2/1"
  #     Rational(-8, 6).to_s  #=> "-4/3"
  #     Rational('1/2').to_s  #=> "1/2"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=rational.c
  #   - rat.truncate([ndigits])  ->  integer or rational
  # -->
  # Returns `rat` truncated (toward zero) to a precision of `ndigits` decimal
  # digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).truncate      #=> 3
  #     Rational(2, 3).truncate   #=> 0
  #     Rational(-3, 2).truncate  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').truncate(+1).to_f  #=> -123.4
  #     Rational('-123.456').truncate(-1)       #=> -120
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Rational)

  def zero?: () -> bool
end

# <!-- rdoc-file=string.c -->
# A String object has an arbitrary sequence of bytes, typically representing
# text or binary data. A String object may be created using String::new or as
# literals.
#
# String objects differ from Symbol objects in that Symbol objects are designed
# to be used as identifiers, instead of text or data.
#
# You can create a String object explicitly with:
#
# *   A [string literal](doc/syntax/literals_rdoc.html#label-String+Literals).
# *   A [heredoc
#     literal](doc/syntax/literals_rdoc.html#label-Here+Document+Literals).
#
#
# You can convert certain objects to Strings with:
#
# *   Method [String](Kernel.html#method-i-String).
#
#
# Some String methods modify `self`. Typically, a method whose name ends with
# `!` modifies `self` and returns `self`; often a similarly named method
# (without the `!`) returns a new string.
#
# In general, if there exist both bang and non-bang version of method, the bang!
# mutates and the non-bang! does not. However, a method without a bang can also
# mutate, such as String#replace.
#
# ## Substitution Methods
#
# These methods perform substitutions:
#
# *   String#sub: One substitution (or none); returns a new string.
# *   String#sub!: One substitution (or none); returns `self`.
# *   String#gsub: Zero or more substitutions; returns a new string.
# *   String#gsub!: Zero or more substitutions; returns `self`.
#
#
# Each of these methods takes:
#
# *   A first argument, `pattern` (string or regexp), that specifies the
#     substring(s) to be replaced.
#
# *   Either of these:
#
#     *   A second argument, `replacement` (string or hash), that determines the
#         replacing string.
#     *   A block that will determine the replacing string.
#
#
#
# The examples in this section mostly use methods String#sub and String#gsub;
# the principles illustrated apply to all four substitution methods.
#
# **Argument `pattern`**
#
# Argument `pattern` is commonly a regular expression:
#
#     s = 'hello'
#     s.sub(/[aeiou]/, '*')  # => "h*llo"
#     s.gsub(/[aeiou]/, '*') # => "h*ll*"
#     s.gsub(/[aeiou]/, '')  # => "hll"
#     s.sub(/ell/, 'al')     # => "halo"
#     s.gsub(/xyzzy/, '*')   # => "hello"
#     'THX1138'.gsub(/\d+/, '00') # => "THX00"
#
# When `pattern` is a string, all its characters are treated as ordinary
# characters (not as regexp special characters):
#
#     'THX1138'.gsub('\d+', '00') # => "THX1138"
#
# **\String `replacement`**
#
# If `replacement` is a string, that string will determine the replacing string
# that is to be substituted for the matched text.
#
# Each of the examples above uses a simple string as the replacing string.
#
# String `replacement` may contain back-references to the pattern's captures:
#
# *   `\n` (*n* a non-negative integer) refers to `$n`.
# *   `\k<name>` refers to the named capture `name`.
#
#
# See regexp.rdoc for details.
#
# Note that within the string `replacement`, a character combination such as
# `$&` is treated as ordinary text, and not as a special match variable.
# However, you may refer to some special match variables using these
# combinations:
#
# *   `\&` and `\0` correspond to `$&`, which contains the complete matched
#     text.
# *   `\'` corresponds to `$'`, which contains string after match.
# *   `\`` corresponds to `$``, which contains string before match.
# *   `+` corresponds to `$+`, which contains last capture group.
#
#
# See regexp.rdoc for details.
#
# Note that `\\\` is interpreted as an escape, i.e., a single backslash.
#
# Note also that a string literal consumes backslashes. See [String
# Literals](doc/syntax/literals_rdoc.html#label-String+Literals) for details
# about string literals.
#
# A back-reference is typically preceded by an additional backslash. For
# example, if you want to write a back-reference `\&` in `replacement` with a
# double-quoted string literal, you need to write `"..\\\\&.."`.
#
# If you want to write a non-back-reference string `\&` in `replacement`, you
# need first to escape the backslash to prevent this method from interpreting it
# as a back-reference, and then you need to escape the backslashes again to
# prevent a string literal from consuming them: `"..\\\\\\\\&.."`.
#
# You may want to use the block form to avoid a lot of backslashes.
#
# **\Hash `replacement`**
#
# If argument `replacement` is a hash, and `pattern` matches one of its keys,
# the replacing string is the value for that key:
#
#     h = {'foo' => 'bar', 'baz' => 'bat'}
#     'food'.sub('foo', h) # => "bard"
#
# Note that a symbol key does not match:
#
#     h = {foo: 'bar', baz: 'bat'}
#     'food'.sub('foo', h) # => "d"
#
# **Block**
#
# In the block form, the current match string is passed to the block; the
# block's return value becomes the replacing string:
#
#      s = '@'
#     '1234'.gsub(/\d/) {|match| s.succ! } # => "ABCD"
#
# Special match variables such as `$1`, `$2`, `$``, `$&`, and `$'` are set
# appropriately.
#
# ## What's Here
#
# First, what's elsewhere. Class String:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class String provides methods that are useful for:
#
# *   [Creating a String](#class-String-label-Methods+for+Creating+a+String)
# *   [Frozen/Unfrozen
#     Strings](#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String)
# *   [Querying](#class-String-label-Methods+for+Querying)
# *   [Comparing](#class-String-label-Methods+for+Comparing)
# *   [Modifying a String](#class-String-label-Methods+for+Modifying+a+String)
# *   [Converting to New
#     String](#class-String-label-Methods+for+Converting+to+New+String)
# *   [Converting to
#     Non-String](#class-String-label-Methods+for+Converting+to+Non--5CString)
# *   [Iterating](#class-String-label-Methods+for+Iterating)
#
#
# ### Methods for Creating a String
#
#     ::new
# :       Returns a new string.
#
#     ::try_convert
# :       Returns a new string created from a given object.
#
#
#
# ### Methods for a Frozen/Unfrozen String
#
#     [#+string](#method-i-2B-40)
# :       Returns a string that is not frozen: `self`, if not frozen; `self.dup`
#         otherwise.
#
#     [#-string](#method-i-2D-40)
# :       Returns a string that is frozen: `self`, if already frozen;
#         `self.freeze` otherwise.
#
#     #freeze
# :       Freezes `self`, if not already frozen; returns `self`.
#
#
#
# ### Methods for Querying
#
# *Counts*
#
#     #length, #size
# :       Returns the count of characters (not bytes).
#
#     #empty?
# :       Returns `true` if `self.length` is zero; `false` otherwise.
#
#     #bytesize
# :       Returns the count of bytes.
#
#     #count
# :       Returns the count of substrings matching given strings.
#
#
#
# *Substrings*
#
#     [#=~](#method-i-3D~)
# :       Returns the index of the first substring that matches a given Regexp
#         or other object; returns `nil` if no match is found.
#
#     #index
# :       Returns the index of the *first* occurrence of a given substring;
#         returns `nil` if none found.
#
#     #rindex
# :       Returns the index of the *last* occurrence of a given substring;
#         returns `nil` if none found.
#
#     #include?
# :       Returns `true` if the string contains a given substring; `false`
#         otherwise.
#
#     #match
# :       Returns a MatchData object if the string matches a given Regexp; `nil`
#         otherwise.
#
#     #match?
# :       Returns `true` if the string matches a given Regexp; `false`
#         otherwise.
#
#     #start_with?
# :       Returns `true` if the string begins with any of the given substrings.
#
#     #end_with?
# :       Returns `true` if the string ends with any of the given substrings.
#
#
#
# *Encodings*
#
#     #encoding
# :       Returns the Encoding object that represents the encoding of the
#         string.
#
#     #unicode_normalized?
# :       Returns `true` if the string is in Unicode normalized form; `false`
#         otherwise.
#
#     #valid_encoding?
# :       Returns `true` if the string contains only characters that are valid
#         for its encoding.
#
#     #ascii_only?
# :       Returns `true` if the string has only ASCII characters; `false`
#         otherwise.
#
#
#
# *Other*
#
#     #sum
# :       Returns a basic checksum for the string: the sum of each byte.
#
#     #hash
# :       Returns the integer hash code.
#
#
#
# ### Methods for Comparing
#
#     [#==, #===](#method-i-3D-3D)
# :       Returns `true` if a given other string has the same content as `self`.
#
#     #eql?
# :       Returns `true` if the content is the same as the given other string.
#
#     [#<=>](#method-i-3C-3D-3E)
# :       Returns -1, 0, or 1 as a given other string is smaller than, equal to,
#         or larger than `self`.
#
#     #casecmp
# :       Ignoring case, returns -1, 0, or 1 as a given other string is smaller
#         than, equal to, or larger than `self`.
#
#     #casecmp?
# :       Returns `true` if the string is equal to a given string after Unicode
#         case folding; `false` otherwise.
#
#
#
# ### Methods for Modifying a String
#
# Each of these methods modifies `self`.
#
# *Insertion*
#
#     #insert
# :       Returns `self` with a given string inserted at a given offset.
#
#     #<<
# :       Returns `self` concatenated with a given string or integer.
#
#
#
# *Substitution*
#
#     #sub!
# :       Replaces the first substring that matches a given pattern with a given
#         replacement string; returns `self` if any changes, `nil` otherwise.
#
#     #gsub!
# :       Replaces each substring that matches a given pattern with a given
#         replacement string; returns `self` if any changes, `nil` otherwise.
#
#     #succ!, #next!
# :       Returns `self` modified to become its own successor.
#
#     #replace
# :       Returns `self` with its entire content replaced by a given string.
#
#     #reverse!
# :       Returns `self` with its characters in reverse order.
#
#     #setbyte
# :       Sets the byte at a given integer offset to a given value; returns the
#         argument.
#
#     #tr!
# :       Replaces specified characters in `self` with specified replacement
#         characters; returns `self` if any changes, `nil` otherwise.
#
#     #tr_s!
# :       Replaces specified characters in `self` with specified replacement
#         characters, removing duplicates from the substrings that were
#         modified; returns `self` if any changes, `nil` otherwise.
#
#
#
# *Casing*
#
#     #capitalize!
# :       Upcases the initial character and downcases all others; returns `self`
#         if any changes, `nil` otherwise.
#
#     #downcase!
# :       Downcases all characters; returns `self` if any changes, `nil`
#         otherwise.
#
#     #upcase!
# :       Upcases all characters; returns `self` if any changes, `nil`
#         otherwise.
#
#     #swapcase!
# :       Upcases each downcase character and downcases each upcase character;
#         returns `self` if any changes, `nil` otherwise.
#
#
#
# *Encoding*
#
#     #encode!
# :       Returns `self` with all characters transcoded from one given encoding
#         into another.
#
#     #unicode_normalize!
# :       Unicode-normalizes `self`; returns `self`.
#
#     #scrub!
# :       Replaces each invalid byte with a given character; returns `self`.
#
#     #force_encoding
# :       Changes the encoding to a given encoding; returns `self`.
#
#
#
# *Deletion*
#
#     #clear
# :       Removes all content, so that `self` is empty; returns `self`.
#
#     #slice!, #[]=
# :       Removes a substring determined by a given index, start/length, range,
#         regexp, or substring.
#
#     #squeeze!
# :       Removes contiguous duplicate characters; returns `self`.
#
#     #delete!
# :       Removes characters as determined by the intersection of substring
#         arguments.
#
#     #lstrip!
# :       Removes leading whitespace; returns `self` if any changes, `nil`
#         otherwise.
#
#     #rstrip!
# :       Removes trailing whitespace; returns `self` if any changes, `nil`
#         otherwise.
#
#     #strip!
# :       Removes leading and trailing whitespace; returns `self` if any
#         changes, `nil` otherwise.
#
#     #chomp!
# :       Removes trailing record separator, if found; returns `self` if any
#         changes, `nil` otherwise.
#
#     #chop!
# :       Removes trailing whitespace if found, otherwise removes the last
#         character; returns `self` if any changes, `nil` otherwise.
#
#
#
# ### Methods for Converting to New String
#
# Each of these methods returns a new String based on `self`, often just a
# modified copy of `self`.
#
# *Extension*
#
#     #*
# :       Returns the concatenation of multiple copies of `self`,
#
#     #+
# :       Returns the concatenation of `self` and a given other string.
#
#     #center
# :       Returns a copy of `self` centered between pad substring.
#
#     #concat
# :       Returns the concatenation of `self` with given other strings.
#
#     #prepend
# :       Returns the concatenation of a given other string with `self`.
#
#     #ljust
# :       Returns a copy of `self` of a given length, right-padded with a given
#         other string.
#
#     #rjust
# :       Returns a copy of `self` of a given length, left-padded with a given
#         other string.
#
#
#
# *Encoding*
#
#     #b
# :       Returns a copy of `self` with ASCII-8BIT encoding.
#
#     #scrub
# :       Returns a copy of `self` with each invalid byte replaced with a given
#         character.
#
#     #unicode_normalize
# :       Returns a copy of `self` with each character Unicode-normalized.
#
#     #encode
# :       Returns a copy of `self` with all characters transcoded from one given
#         encoding into another.
#
#
#
# *Substitution*
#
#     #dump
# :       Returns a copy of +self with all non-printing characters replaced by
#         xHH notation and all special characters escaped.
#
#     #undump
# :       Returns a copy of +self with all `\xNN` notation replace by `\uNNNN`
#         notation and all escaped characters unescaped.
#
#     #sub
# :       Returns a copy of `self` with the first substring matching a given
#         pattern replaced with a given replacement string;.
#
#     #gsub
# :       Returns a copy of `self` with each substring that matches a given
#         pattern replaced with a given replacement string.
#
#     #succ, #next
# :       Returns the string that is the successor to `self`.
#
#     #reverse
# :       Returns a copy of `self` with its characters in reverse order.
#
#     #tr
# :       Returns a copy of `self` with specified characters replaced with
#         specified replacement characters.
#
#     #tr_s
# :       Returns a copy of `self` with specified characters replaced with
#         specified replacement characters, removing duplicates from the
#         substrings that were modified.
#
#     #%
# :       Returns the string resulting from formatting a given object into
#         `self`
#
#
#
# *Casing*
#
#     #capitalize
# :       Returns a copy of `self` with the first character upcased and all
#         other characters downcased.
#
#     #downcase
# :       Returns a copy of `self` with all characters downcased.
#
#     #upcase
# :       Returns a copy of `self` with all characters upcased.
#
#     #swapcase
# :       Returns a copy of `self` with all upcase characters downcased and all
#         downcase characters upcased.
#
#
#
# *Deletion*
#
#     #delete
# :       Returns a copy of `self` with characters removed
#
#     #delete_prefix
# :       Returns a copy of `self` with a given prefix removed.
#
#     #delete_suffix
# :       Returns a copy of `self` with a given suffix removed.
#
#     #lstrip
# :       Returns a copy of `self` with leading whitespace removed.
#
#     #rstrip
# :       Returns a copy of `self` with trailing whitespace removed.
#
#     #strip
# :       Returns a copy of `self` with leading and trailing whitespace removed.
#
#     #chomp
# :       Returns a copy of `self` with a trailing record separator removed, if
#         found.
#
#     #chop
# :       Returns a copy of `self` with trailing whitespace or the last
#         character removed.
#
#     #squeeze
# :       Returns a copy of `self` with contiguous duplicate characters removed.
#
#     #[], #slice
# :       Returns a substring determined by a given index, start/length, or
#         range, or string.
#
#     #byteslice
# :       Returns a substring determined by a given index, start/length, or
#         range.
#
#     #chr
# :       Returns the first character.
#
#
#
# *Duplication*
#
#     #to_s, $to_str
# :       If `self` is a subclass of String, returns `self` copied into a
#         String; otherwise, returns `self`.
#
#
#
# ### Methods for Converting to Non-String
#
# Each of these methods converts the contents of `self` to a non-String.
#
# *Characters, Bytes, and Clusters*
#
#     #bytes
# :       Returns an array of the bytes in `self`.
#
#     #chars
# :       Returns an array of the characters in `self`.
#
#     #codepoints
# :       Returns an array of the integer ordinals in `self`.
#
#     #getbyte
# :       Returns an integer byte as determined by a given index.
#
#     #grapheme_clusters
# :       Returns an array of the grapheme clusters in `self`.
#
#
#
# *Splitting*
#
#     #lines
# :       Returns an array of the lines in `self`, as determined by a given
#         record separator.
#
#     #partition
# :       Returns a 3-element array determined by the first substring that
#         matches a given substring or regexp,
#
#     #rpartition
# :       Returns a 3-element array determined by the last substring that
#         matches a given substring or regexp,
#
#     #split
# :       Returns an array of substrings determined by a given delimiter --
#         regexp or string -- or, if a block given, passes those substrings to
#         the block.
#
#
#
# *Matching*
#
#     #scan
# :       Returns an array of substrings matching a given regexp or string, or,
#         if a block given, passes each matching substring to the  block.
#
#     #unpack
# :       Returns an array of substrings extracted from `self` according to a
#         given format.
#
#     #unpack1
# :       Returns the first substring extracted from `self` according to a given
#         format.
#
#
#
# *Numerics*
#
#     #hex
# :       Returns the integer value of the leading characters, interpreted as
#         hexadecimal digits.
#
#     #oct
# :       Returns the integer value of the leading characters, interpreted as
#         octal digits.
#
#     #ord
# :       Returns the integer ordinal of the first character in `self`.
#
#     #to_i
# :       Returns the integer value of leading characters, interpreted as an
#         integer.
#
#     #to_f
# :       Returns the floating-point value of leading characters, interpreted as
#         a floating-point number.
#
#
#
# *Strings and Symbols*
#
#     #inspect
# :       Returns copy of `self`, enclosed in double-quotes, with special
#         characters escaped.
#
#     #to_sym, #intern
# :       Returns the symbol corresponding to `self`.
#
#
#
# ### Methods for Iterating
#
#     #each_byte
# :       Calls the given block with each successive byte in `self`.
#
#     #each_char
# :       Calls the given block with each successive character in `self`.
#
#     #each_codepoint
# :       Calls the given block with each successive integer codepoint in
#         `self`.
#
#     #each_grapheme_cluster
# :       Calls the given block with each successive grapheme cluster in `self`.
#
#     #each_line
# :       Calls the given block with each successive line in `self`, as
#         determined by a given record separator.
#
#     #upto
# :       Calls the given block with each string value returned by successive
#         calls to #succ.
#
class String
  include Comparable

  # <!--
  #   rdoc-file=string.c
  #   - String.try_convert(object) -> object, new_string, or nil
  # -->
  # If `object` is a String object, returns `object`.
  #
  # Otherwise if `object` responds to `:to_str`, calls `object.to_str` and returns
  # the result.
  #
  # Returns `nil` if `object` does not respond to `:to_str`.
  #
  # Raises an exception unless `object.to_str` returns a String object.
  #
  def self.try_convert: (untyped obj) -> String?

  public

  # <!--
  #   rdoc-file=string.c
  #   - string % object -> new_string
  # -->
  # Returns the result of formatting `object` into the format specification `self`
  # (see Kernel#sprintf for formatting details):
  #
  #     "%05d" % 123 # => "00123"
  #
  # If `self` contains multiple substitutions, `object` must be an Array or Hash
  # containing the values to be substituted:
  #
  #     "%-5s: %016x" % [ "ID", self.object_id ] # => "ID   : 00002b054ec93168"
  #     "foo = %{foo}" % {foo: 'bar'} # => "foo = bar"
  #     "foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'} # => "foo = bar, baz = bat"
  #
  def %: (Hash[Symbol, untyped]) -> String
       | (Array[untyped]) -> String
       | (untyped arg) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string * integer -> new_string
  # -->
  # Returns a new String containing `integer` copies of `self`:
  #
  #     "Ho! " * 3 # => "Ho! Ho! Ho! "
  #     "Ho! " * 0 # => ""
  #
  def *: (int n) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string + other_string -> new_string
  # -->
  # Returns a new String containing `other_string` concatenated to `self`:
  #
  #     "Hello from " + self.to_s # => "Hello from main"
  #
  def +: (string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - +string -> new_string or self
  # -->
  # Returns `self` if `self` is not frozen.
  #
  # Otherwise. returns `self.dup`, which is not frozen.
  #
  def +@: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - -string -> frozen_string
  # -->
  # Returns a frozen, possibly pre-existing copy of the string.
  #
  # The returned String will be deduplicated as long as it does not have any
  # instance variables set on it.
  #
  def -@: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - string << object -> string
  # -->
  # Concatenates `object` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s << 'bar' # => "foobar"
  #     s          # => "foobar"
  #
  # If `object` is an Integer, the value is considered a codepoint and converted
  # to a character before concatenation:
  #
  #     s = 'foo'
  #     s << 33 # => "foo!"
  #
  # Related: String#concat, which takes multiple arguments.
  #
  def <<: (string | Integer str_or_codepoint) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string <=> other_string -> -1, 0, 1, or nil
  # -->
  # Compares `self` and `other_string`, returning:
  #
  # *   -1 if `other_string` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string` is smaller.
  # *   `nil` if the two are incomparable.
  #
  #
  # Examples:
  #
  #     'foo' <=> 'foo' # => 0
  #     'foo' <=> 'food' # => -1
  #     'food' <=> 'foo' # => 1
  #     'FOO' <=> 'foo' # => -1
  #     'foo' <=> 'FOO' # => 1
  #     'foo' <=> 1 # => nil
  #
  def <=>: (string other) -> Integer
         | (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - string == object -> true or false
  #   - string === object -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of String but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  def ==: (untyped obj) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of String but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - string =~ regexp -> integer or nil
  #   - string =~ object -> integer or nil
  # -->
  # Returns the Integer index of the first substring that matches the given
  # `regexp`, or `nil` if no match found:
  #
  #     'foo' =~ /f/ # => 0
  #     'foo' =~ /o/ # => 1
  #     'foo' =~ /x/ # => nil
  #
  # Note: also updates [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # If the given `object` is not a Regexp, returns the value returned by `object
  # =~ self`.
  #
  # Note that `string =~ regexp` is different from `regexp =~ string` (see
  # [Regexp#=~](https://ruby-doc.org/core-2.7.1/Regexp.html#method-i-3D-7E)):
  #
  #     number= nil
  #     "no. 9" =~ /(?<number>\d+)/
  #     number # => nil (not assigned)
  #     /(?<number>\d+)/ =~ "no. 9"
  #     number #=> "9"
  #
  def =~: (untyped obj) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - string[index] -> new_string or nil
  #   - string[start, length] -> new_string or nil
  #   - string[range] -> new_string or nil
  #   - string[regexp, capture = 0] -> new_string or nil
  #   - string[substring] -> new_string or nil
  # -->
  # Returns the substring of `self` specified by the arguments.
  #
  # When the single Integer argument `index` is given, returns the 1-character
  # substring found in `self` at offset `index`:
  #
  #     'bar'[2] # => "r"
  #
  # Counts backward from the end of `self` if `index` is negative:
  #
  #     'foo'[-3] # => "f"
  #
  # Returns `nil` if `index` is out of range:
  #
  #     'foo'[3] # => nil
  #     'foo'[-4] # => nil
  #
  # When the two Integer arguments  `start` and `length` are given, returns the
  # substring of the given `length` found in `self` at offset `start`:
  #
  #     'foo'[0, 2] # => "fo"
  #     'foo'[0, 0] # => ""
  #
  # Counts backward from the end of `self` if `start` is negative:
  #
  #     'foo'[-2, 2] # => "oo"
  #
  # Special case: returns a new empty String if `start` is equal to the length of
  # `self`:
  #
  #     'foo'[3, 2] # => ""
  #
  # Returns `nil` if `start` is out of range:
  #
  #     'foo'[4, 2] # => nil
  #     'foo'[-4, 2] # => nil
  #
  # Returns the trailing substring of `self` if `length` is large:
  #
  #     'foo'[1, 50] # => "oo"
  #
  # Returns `nil` if `length` is negative:
  #
  #     'foo'[0, -1] # => nil
  #
  # When the single Range argument `range` is given, derives `start` and `length`
  # values from the given `range`, and returns values as above:
  #
  # *   `'foo'[0..1]` is equivalent to `'foo'[0, 2]`.
  # *   `'foo'[0...1]` is equivalent to `'foo'[0, 1]`.
  #
  #
  # When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
  # returns the first matching substring found in `self`, or `nil` if none found:
  #
  #     'foo'[/o/] # => "o"
  #     'foo'[/x/] # => nil
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/] # => "ell"
  #     s[/[aeiou](.)\1/, 0] # => "ell"
  #
  # If argument `capture` is given and not `0`, it should be either an Integer
  # capture group index or a String or Symbol capture group name; the method call
  # returns only the specified capture (see [Regexp
  # Capturing](Regexp.html#class-Regexp-label-Capturing)):
  #
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/, 1] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel] # => "e"
  #
  # If an invalid capture group index is given, `nil` is returned.  If an invalid
  # capture group name is given, `IndexError` is raised.
  #
  # When the single String argument `substring` is given, returns the substring
  # from `self` if found, otherwise `nil`:
  #
  #     'foo'['oo'] # => "oo"
  #     'foo'['xx'] # => nil
  #
  # String#slice is an alias for String#[].
  #
  def []: (int index) -> String?
        | (int start, int length) -> String?
        | (Range[Integer] | Range[Integer?] range) -> String?
        | (Regexp regexp) -> String?
        | (Regexp regexp, int | String capture) -> String?
        | (String match_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str[integer] = new_str
  #   - str[integer, integer] = new_str
  #   - str[range] = aString
  #   - str[regexp] = new_str
  #   - str[regexp, integer] = new_str
  #   - str[regexp, name] = new_str
  #   - str[other_str] = new_str
  # -->
  # Element Assignment---Replaces some or all of the content of *str*. The portion
  # of the string affected is determined using the same criteria as String#[]. If
  # the replacement string is not the same length as the text it is replacing, the
  # string will be adjusted accordingly. If the regular expression or string is
  # used as the index doesn't match a position in the string, IndexError is
  # raised. If the regular expression form is used, the optional second Integer
  # allows you to specify which portion of the match to replace (effectively using
  # the MatchData indexing rules. The forms that take an Integer will raise an
  # IndexError if the value is out of range; the Range form will raise a
  # RangeError, and the Regexp and String will raise an IndexError on negative
  # match.
  #
  def []=: (int pos, String new_str) -> String
         | (int begin_pos, int end_pos, String new_str) -> String
         | (Range[Integer] | Range[Integer?] range, String new_str) -> String
         | (Regexp regexp, String new_str) -> String
         | (Regexp regexp, int capture, String new_str) -> String
         | (Regexp regexp, String name, String new_str) -> String
         | (String other_str, String new_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.ascii_only?  -> true or false
  # -->
  # Returns true for a string which has only ASCII characters.
  #
  #     "abc".force_encoding("UTF-8").ascii_only?          #=> true
  #     "abc\u{6666}".force_encoding("UTF-8").ascii_only?  #=> false
  #
  def ascii_only?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.b   -> str
  # -->
  # Returns a copied string whose encoding is ASCII-8BIT.
  #
  def b: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.bytes    -> an_array
  # -->
  # Returns an array of bytes in *str*.  This is a shorthand for
  # `str.each_byte.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_byte`.
  #
  def bytes: () -> Array[Integer]
           | () { (Integer byte) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - bytesize -> integer
  # -->
  # Returns the count  of bytes in `self`:
  #
  #     "\x80\u3042".bytesize # => 4
  #     "hello".bytesize # => 5
  #
  # Related: String#length.
  #
  def bytesize: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - byteslice(index, length = 1) -> string or nil
  #   - byteslice(range)             -> string or nil
  # -->
  # Returns a substring of `self`, or `nil` if the substring cannot be
  # constructed.
  #
  # With integer arguments `index` and `length` given, returns the substring
  # beginning at the given `index` of the given `length` (if possible), or `nil`
  # if `length` is negative or `index` falls outside of `self`:
  #
  #     s = '0123456789' # => "0123456789"
  #     s.byteslice(2)   # => "2"
  #     s.byteslice(200) # => nil
  #     s.byteslice(4, 3)  # => "456"
  #     s.byteslice(4, 30) # => "456789"
  #     s.byteslice(4, -1) # => nil
  #     s.byteslice(40, 2) # => nil
  #
  # In either case above, counts backwards from the end of `self` if `index` is
  # negative:
  #
  #     s = '0123456789'   # => "0123456789"
  #     s.byteslice(-4)    # => "6"
  #     s.byteslice(-4, 3) # => "678"
  #
  # With Range argument `range` given, returns `byteslice(range.begin,
  # range.size)`:
  #
  #     s = '0123456789'    # => "0123456789"
  #     s.byteslice(4..6)   # => "456"
  #     s.byteslice(-6..-4) # => "456"
  #     s.byteslice(5..2)   # => "" # range.size is zero.
  #     s.byteslice(40..42) # => nil
  #
  # In all cases, a returned string has the same encoding as `self`:
  #
  #     s.encoding              # => #<Encoding:UTF-8>
  #     s.byteslice(4).encoding # => #<Encoding:UTF-8>
  #
  def byteslice: (int start, ?int length) -> String?
               | (Range[Integer] | Range[Integer?] range) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> string
  # -->
  # Returns a string containing the characters in `self`; the first character is
  # upcased; the remaining characters are downcased:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize       # => "Hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#capitalize!.
  #
  def capitalize: () -> String
                | (:ascii | :lithuanian | :turkic) -> String
                | (:lithuanian, :turkic) -> String
                | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - capitalize!(*options) -> self or nil
  # -->
  # Upcases the first character in `self`; downcases the remaining characters;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize!      # => "Hello world!"
  #     s                  # => "Hello world!"
  #     s.capitalize!      # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#capitalize.
  #
  def capitalize!: () -> String?
                 | (:ascii | :lithuanian | :turkic) -> String?
                 | (:lithuanian, :turkic) -> String?
                 | (:turkic, :lithuanian) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(other_string) -> -1, 0, 1, or nil
  # -->
  # Compares `self.downcase` and `other_string.downcase`; returns:
  #
  # *   -1 if `other_string.downcase` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string.downcase` is smaller.
  # *   `nil` if the two are incomparable.
  #
  #
  # Examples:
  #
  #     'foo'.casecmp('foo') # => 0
  #     'foo'.casecmp('food') # => -1
  #     'food'.casecmp('foo') # => 1
  #     'FOO'.casecmp('foo') # => 0
  #     'foo'.casecmp('FOO') # => 0
  #     'foo'.casecmp(1) # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#casecmp?.
  #
  def casecmp: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(other_string) -> true, false, or nil
  # -->
  # Returns `true` if `self` and `other_string` are equal after Unicode case
  # folding, otherwise `false`:
  #
  #     'foo'.casecmp?('foo') # => true
  #     'foo'.casecmp?('food') # => false
  #     'food'.casecmp?('foo') # => false
  #     'FOO'.casecmp?('foo') # => true
  #     'foo'.casecmp?('FOO') # => true
  #
  # Returns `nil` if the two values are incomparable:
  #
  #     'foo'.casecmp?(1) # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#casecmp.
  #
  def casecmp?: (untyped other) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - str.center(width, padstr=' ')   -> new_str
  # -->
  # Centers `str` in `width`.  If `width` is greater than the length of `str`,
  # returns a new String of length `width` with `str` centered and padded with
  # `padstr`; otherwise, returns `str`.
  #
  #     "hello".center(4)         #=> "hello"
  #     "hello".center(20)        #=> "       hello        "
  #     "hello".center(20, '123') #=> "1231231hello12312312"
  #
  def center: (int width, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chars    -> an_array
  # -->
  # Returns an array of characters in *str*.  This is a shorthand for
  # `str.each_char.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_char`.
  #
  def chars: () -> Array[String]
           | () { (String char) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chomp(separator=$/)   -> new_str
  # -->
  # Returns a new String with the given record separator removed from the end of
  # *str* (if present). If `$/` has not been changed from the default Ruby record
  # separator, then `chomp` also removes carriage return characters (that is, it
  # will remove `\n`, `\r`, and `\r\n`). If `$/` is an empty string, it will
  # remove all trailing newlines from the string.
  #
  #     "hello".chomp                #=> "hello"
  #     "hello\n".chomp              #=> "hello"
  #     "hello\r\n".chomp            #=> "hello"
  #     "hello\n\r".chomp            #=> "hello\n"
  #     "hello\r".chomp              #=> "hello"
  #     "hello \n there".chomp       #=> "hello \n there"
  #     "hello".chomp("llo")         #=> "he"
  #     "hello\r\n\r\n".chomp('')    #=> "hello"
  #     "hello\r\n\r\r\n".chomp('')  #=> "hello\r\n\r"
  #
  def chomp: (?string separator) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chomp!(separator=$/)   -> str or nil
  # -->
  # Modifies *str* in place as described for String#chomp, returning *str*, or
  # `nil` if no modifications were made.
  #
  def chomp!: (?string separator) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.chop   -> new_str
  # -->
  # Returns a new String with the last character removed.  If the string ends with
  # `\r\n`, both characters are removed. Applying `chop` to an empty string
  # returns an empty string. String#chomp is often a safer alternative, as it
  # leaves the string unchanged if it doesn't end in a record separator.
  #
  #     "string\r\n".chop   #=> "string"
  #     "string\n\r".chop   #=> "string\n"
  #     "string\n".chop     #=> "string"
  #     "string".chop       #=> "strin"
  #     "x".chop.chop       #=> ""
  #
  def chop: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chop!   -> str or nil
  # -->
  # Processes *str* as for String#chop, returning *str*, or `nil` if *str* is the
  # empty string.  See also String#chomp!.
  #
  def chop!: () -> String?

  # <!--
  #   rdoc-file=string.c
  #   - chr -> string
  # -->
  # Returns a string containing the first character of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.chr     # => "f"
  #
  def chr: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - clear -> self
  # -->
  # Removes the contents of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.clear   # => ""
  #
  def clear: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.codepoints   -> an_array
  # -->
  # Returns an array of the Integer ordinals of the characters in *str*.  This is
  # a shorthand for `str.each_codepoint.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_codepoint`.
  #
  def codepoints: () -> ::Array[Integer]
                | () { (Integer codepoint) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - concat(*objects) -> string
  # -->
  # Concatenates each object in `objects` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.concat('bar', 'baz') # => "foobarbaz"
  #     s                      # => "foobarbaz"
  #
  # For each given object `object` that is an Integer, the value is considered a
  # codepoint and converted to a character before concatenation:
  #
  #     s = 'foo'
  #     s.concat(32, 'bar', 32, 'baz') # => "foo bar baz"
  #
  # Related: String#<<, which takes a single argument.
  #
  def concat: (*string | Integer str_or_codepoint) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.count([other_str]+)   -> integer
  # -->
  # Each `other_str` parameter defines a set of characters to count.  The
  # intersection of these sets defines the characters to count in `str`.  Any
  # `other_str` that starts with a caret `^` is negated.  The sequence `c1-c2`
  # means all characters between c1 and c2.  The backslash character `\` can be
  # used to escape `^` or `-` and is otherwise ignored unless it appears at the
  # end of a sequence or the end of a `other_str`.
  #
  #     a = "hello world"
  #     a.count "lo"                   #=> 5
  #     a.count "lo", "o"              #=> 2
  #     a.count "hello", "^l"          #=> 4
  #     a.count "ej-m"                 #=> 4
  #
  #     "hello^world".count "\\^aeiou" #=> 4
  #     "hello-world".count "a\\-eo"   #=> 4
  #
  #     c = "hello world\\r\\n"
  #     c.count "\\"                   #=> 2
  #     c.count "\\A"                  #=> 0
  #     c.count "X-\\w"                #=> 3
  #
  def count: (string other_str, *string other_strs) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.crypt(salt_str)   -> new_str
  # -->
  # Returns the string generated by calling `crypt(3)` standard library function
  # with `str` and `salt_str`, in this order, as its arguments.  Please do not use
  # this method any longer.  It is legacy; provided only for backward
  # compatibility with ruby scripts in earlier days.  It is bad to use in
  # contemporary programs for several reasons:
  #
  # *   Behaviour of C's `crypt(3)` depends on the OS it is run.  The generated
  #     string lacks data portability.
  #
  # *   On some OSes such as Mac OS, `crypt(3)` never fails (i.e. silently ends up
  #     in unexpected results).
  #
  # *   On some OSes such as Mac OS, `crypt(3)` is not thread safe.
  #
  # *   So-called "traditional" usage of `crypt(3)` is very very very weak.
  #     According to its manpage, Linux's traditional `crypt(3)` output has only
  #     2**56 variations; too easy to brute force today.  And this is the default
  #     behaviour.
  #
  # *   In order to make things robust some OSes implement so-called "modular"
  #     usage. To go through, you have to do a complex build-up of the `salt_str`
  #     parameter, by hand. Failure in generation of a proper salt string tends
  #     not to yield any errors; typos in parameters are normally not detectable.
  #
  #     *   For instance, in the following example, the second invocation of
  #         String#crypt is wrong; it has a typo in "round=" (lacks "s").  However
  #         the call does not fail and something unexpected is generated.
  #
  #             "foo".crypt("$5$rounds=1000$salt$") # OK, proper usage
  #             "foo".crypt("$5$round=1000$salt$")  # Typo not detected
  #
  #
  # *   Even in the "modular" mode, some hash functions are considered archaic and
  #     no longer recommended at all; for instance module `$1$` is officially
  #     abandoned by its author: see http://phk.freebsd.dk/sagas/md5crypt_eol/ .
  #     For another instance module `$3$` is considered completely broken: see the
  #     manpage of FreeBSD.
  #
  # *   On some OS such as Mac OS, there is no modular mode. Yet, as written
  #     above, `crypt(3)` on Mac OS never fails. This means even if you build up a
  #     proper salt string it generates a traditional DES hash anyways, and there
  #     is no way for you to be aware of.
  #
  #         "foo".crypt("$5$rounds=1000$salt$") # => "$5fNPQMxC5j6."
  #
  #
  # If for some reason you cannot migrate to other secure contemporary password
  # hashing algorithms, install the string-crypt gem and `require 'string/crypt'`
  # to continue using it.
  #
  def crypt: (string salt_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete([other_str]+)   -> new_str
  # -->
  # Returns a copy of *str* with all characters in the intersection of its
  # arguments deleted. Uses the same rules for building the set of characters as
  # String#count.
  #
  #     "hello".delete "l","lo"        #=> "heo"
  #     "hello".delete "lo"            #=> "he"
  #     "hello".delete "aeiou", "^e"   #=> "hell"
  #     "hello".delete "ej-m"          #=> "ho"
  #
  def delete: (string other_str, *string other_strs) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete!([other_str]+)   -> str or nil
  # -->
  # Performs a `delete` operation in place, returning *str*, or `nil` if *str* was
  # not modified.
  #
  def delete!: (string other_str, *string other_strs) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_prefix(prefix) -> new_str
  # -->
  # Returns a copy of *str* with leading `prefix` deleted.
  #
  #     "hello".delete_prefix("hel") #=> "lo"
  #     "hello".delete_prefix("llo") #=> "hello"
  #
  def delete_prefix: (string prefix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_prefix!(prefix) -> self or nil
  # -->
  # Deletes leading `prefix` from *str*, returning `nil` if no change was made.
  #
  #     "hello".delete_prefix!("hel") #=> "lo"
  #     "hello".delete_prefix!("llo") #=> nil
  #
  def delete_prefix!: (string prefix) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_suffix(suffix) -> new_str
  # -->
  # Returns a copy of *str* with trailing `suffix` deleted.
  #
  #     "hello".delete_suffix("llo") #=> "he"
  #     "hello".delete_suffix("hel") #=> "hello"
  #
  def delete_suffix: (string suffix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_suffix!(suffix) -> self or nil
  # -->
  # Deletes trailing `suffix` from *str*, returning `nil` if no change was made.
  #
  #     "hello".delete_suffix!("llo") #=> "he"
  #     "hello".delete_suffix!("hel") #=> nil
  #
  def delete_suffix!: (string suffix) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> string
  # -->
  # Returns a string containing the downcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase         # => "hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#downcase!, String#upcase, String#upcase!.
  #
  def downcase: () -> String
              | (:ascii | :fold | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - downcase!(*options) -> self or nil
  # -->
  # Downcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase!        # => "hello world!"
  #     s                  # => "hello world!"
  #     s.downcase!        # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#downcase, String#upcase, String#upcase!.
  #
  def downcase!: () -> String?
               | (:ascii | :fold | :lithuanian | :turkic) -> String?
               | (:lithuanian, :turkic) -> String?
               | (:turkic, :lithuanian) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - dump -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, with special
  # characters escaped, and with non-printing characters replaced by hexadecimal
  # notation:
  #
  #     "hello \n ''".dump    # => "\"hello \\n ''\""
  #     "\f\x00\xff\\\"".dump # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #
  # Related: String#undump (inverse of String#dump).
  #
  def dump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.each_byte {|integer| block }    -> str
  #   - str.each_byte                      -> an_enumerator
  # -->
  # Passes each byte in *str* to the given block, or returns an enumerator if no
  # block is given.
  #
  #     "hello".each_byte {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     104 101 108 108 111
  #
  def each_byte: () { (Integer byte) -> void } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_char {|cstr| block }    -> str
  #   - str.each_char                    -> an_enumerator
  # -->
  # Passes each character in *str* to the given block, or returns an enumerator if
  # no block is given.
  #
  #     "hello".each_char {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     h e l l o
  #
  def each_char: () { (String char) -> void } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_codepoint {|integer| block }    -> str
  #   - str.each_codepoint                       -> an_enumerator
  # -->
  # Passes the Integer ordinal of each character in *str*, also known as a
  # *codepoint* when applied to Unicode strings to the given block.  For encodings
  # other than UTF-8/UTF-16(BE|LE)/UTF-32(BE|LE), values are directly derived from
  # the binary representation of each character.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     "hello\u0639".each_codepoint {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     104 101 108 108 111 1593
  #
  def each_codepoint: () { (Integer codepoint) -> void } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_grapheme_cluster {|cstr| block }    -> str
  #   - str.each_grapheme_cluster                    -> an_enumerator
  # -->
  # Passes each grapheme cluster in *str* to the given block, or returns an
  # enumerator if no block is given. Unlike String#each_char, this enumerates by
  # grapheme clusters defined by Unicode Standard Annex #29
  # http://unicode.org/reports/tr29/
  #
  #     "a\u0300".each_char.to_a.size #=> 2
  #     "a\u0300".each_grapheme_cluster.to_a.size #=> 1
  #
  def each_grapheme_cluster: () { (String grapheme) -> void } -> self
                           | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_line(separator=$/, chomp: false) {|substr| block } -> str
  #   - str.each_line(separator=$/, chomp: false)                   -> an_enumerator
  # -->
  # Splits *str* using the supplied parameter as the record separator (`$/` by
  # default), passing each substring in turn to the supplied block.  If a
  # zero-length record separator is supplied, the string is split into paragraphs
  # delimited by multiple successive newlines.
  #
  # If `chomp` is `true`, `separator` will be removed from the end of each line.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     "hello\nworld".each_line {|s| p s}
  #     # prints:
  #     #   "hello\n"
  #     #   "world"
  #
  #     "hello\nworld".each_line('l') {|s| p s}
  #     # prints:
  #     #   "hel"
  #     #   "l"
  #     #   "o\nworl"
  #     #   "d"
  #
  #     "hello\n\n\nworld".each_line('') {|s| p s}
  #     # prints
  #     #   "hello\n\n"
  #     #   "world"
  #
  #     "hello\nworld".each_line(chomp: true) {|s| p s}
  #     # prints:
  #     #   "hello"
  #     #   "world"
  #
  #     "hello\nworld".each_line('l', chomp: true) {|s| p s}
  #     # prints:
  #     #   "he"
  #     #   ""
  #     #   "o\nwor"
  #     #   "d"
  #
  def each_line: (?string separator, ?chomp: boolish) { (String line) -> void } -> self
               | (?string separator, ?chomp: boolish) -> Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - empty? -> true or false
  # -->
  # Returns `true` if the length of `self` is zero, `false` otherwise:
  #
  #     "hello".empty? # => false
  #     " ".empty? # => false
  #     "".empty? # => true
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=transcode.c
  #   - str.encode(encoding, **options)   -> str
  #   - str.encode(dst_encoding, src_encoding, **options)   -> str
  #   - str.encode(**options)   -> str
  # -->
  # The first form returns a copy of `str` transcoded to encoding `encoding`. The
  # second form returns a copy of `str` transcoded from src_encoding to
  # dst_encoding. The last form returns a copy of `str` transcoded to
  # `Encoding.default_internal`.
  #
  # By default, the first and second form raise Encoding::UndefinedConversionError
  # for characters that are undefined in the destination encoding, and
  # Encoding::InvalidByteSequenceError for invalid byte sequences in the source
  # encoding. The last form by default does not raise exceptions but uses
  # replacement strings.
  #
  # The `options` keyword arguments give details for conversion. The arguments
  # are:
  #
  # :invalid
  # :   If the value is `:replace`, #encode replaces invalid byte sequences in
  #     `str` with the replacement character.  The default is to raise the
  #     Encoding::InvalidByteSequenceError exception
  # :undef
  # :   If the value is `:replace`, #encode replaces characters which are
  #     undefined in the destination encoding with the replacement character. The
  #     default is to raise the Encoding::UndefinedConversionError.
  # :replace
  # :   Sets the replacement string to the given value. The default replacement
  #     string is "uFFFD" for Unicode encoding forms, and "?" otherwise.
  # :fallback
  # :   Sets the replacement string by the given object for undefined character.
  #     The object should be a Hash, a Proc, a Method, or an object which has []
  #     method. Its key is an undefined character encoded in the source encoding
  #     of current transcoder. Its value can be any encoding until it can be
  #     converted into the destination encoding of the transcoder.
  # :xml
  # :   The value must be `:text` or `:attr`. If the value is `:text` #encode
  #     replaces undefined characters with their (upper-case hexadecimal) numeric
  #     character references. '&', '<', and '>' are converted to "&amp;", "&lt;",
  #     and "&gt;", respectively. If the value is `:attr`, #encode also quotes the
  #     replacement result (using '"'), and replaces '"' with "&quot;".
  # :cr_newline
  # :   Replaces LF ("n") with CR ("r") if value is true.
  # :crlf_newline
  # :   Replaces LF ("n") with CRLF ("r\n") if value is true.
  # :universal_newline
  # :   Replaces CRLF ("r\n") and CR ("r") with LF ("n") if value is true.
  #
  def encode: (?encoding encoding, ?encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - str.encode!(encoding, **options)   -> str
  #   - str.encode!(dst_encoding, src_encoding, **options)   -> str
  # -->
  # The first form transcodes the contents of *str* from str.encoding to
  # `encoding`. The second form transcodes the contents of *str* from src_encoding
  # to dst_encoding. The `options` keyword arguments give details for conversion.
  # See String#encode for details. Returns the string even if no changes were
  # made.
  #
  def encode!: (?encoding encoding, ?encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> self

  # <!--
  #   rdoc-file=string.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - str.end_with?([suffixes]+)   -> true or false
  # -->
  # Returns true if `str` ends with one of the `suffixes` given.
  #
  #     "hello".end_with?("ello")               #=> true
  #
  #     # returns true if one of the +suffixes+ matches.
  #     "hello".end_with?("heaven", "ello")     #=> true
  #     "hello".end_with?("heaven", "paradise") #=> false
  #
  def end_with?: (*string suffixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - eql?(object) -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s.eql?('foo') # => true
  #     s.eql?('food') # => false
  #     s.eql?('FOO') # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #
  #     "\u{e4 f6 fc}".encode("ISO-8859-1").eql?("\u{c4 d6 dc}") # => false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.force_encoding(encoding)   -> str
  # -->
  # Changes the encoding to `encoding` and returns self.
  #
  def force_encoding: (string | Encoding encoding) -> self

  # <!--
  #   rdoc-file=string.c
  #   - freeze()
  # -->
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - getbyte(index) -> integer
  # -->
  # Returns the byte at zero-based `index` as an integer:
  #
  #     s = 'abcde'  # => "abcde"
  #     s.getbyte(0) # => 97
  #     s.getbyte(1) # => 98
  #
  # Related: String#setbyte.
  #
  def getbyte: (int index) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - str.grapheme_clusters   -> an_array
  # -->
  # Returns an array of grapheme clusters in *str*.  This is a shorthand for
  # `str.each_grapheme_cluster.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_grapheme_cluster`.
  #
  def grapheme_clusters: () -> ::Array[::String]

  # <!--
  #   rdoc-file=string.c
  #   - gsub(pattern, replacement)   -> new_string
  #   - gsub(pattern) {|match| ... } -> new_string
  #   - gsub(pattern)                -> enumerator
  # -->
  # Returns a copy of `self` with all occurrences of the given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#sub!, String#gsub!.
  #
  def gsub: (Regexp | string pattern, string replacement) -> String
          | (Regexp | string pattern, Hash[String, String] hash) -> String
          | (Regexp | string pattern) { (String match) -> _ToS } -> String
          | (Regexp | string pattern) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - gsub!(pattern, replacement)   -> self or nil
  #   - gsub!(pattern) {|match| ... } -> self or nil
  #   - gsub!(pattern)                -> an_enumerator
  # -->
  # Performs the specified substring replacement(s) on `self`; returns `self` if
  # any replacement occurred, `nil` otherwise.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#gsub, String#sub!.
  #
  def gsub!: (Regexp | string pattern, string replacement) -> String?
           | (Regexp | string pattern, Hash[String, String] hash) -> String?
           | (Regexp | string pattern) { (String match) -> _ToS } -> String?
           | (Regexp | string pattern) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. The value is based on the length,
  # content and encoding of `self`.
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.hex   -> integer
  # -->
  # Treats leading characters from *str* as a string of hexadecimal digits (with
  # an optional sign and an optional `0x`) and returns the corresponding number.
  # Zero is returned on error.
  #
  #     "0x0a".hex     #=> 10
  #     "-1234".hex    #=> -4660
  #     "0".hex        #=> 0
  #     "wombat".hex   #=> 0
  #
  def hex: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - include? other_string -> true or false
  # -->
  # Returns `true` if `self` contains `other_string`, `false` otherwise:
  #
  #     s = 'foo'
  #     s.include?('f')    # => true
  #     s.include?('fo')   # => true
  #     s.include?('food') # => false
  #
  def include?: (string other_str) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - index(substring, offset = 0) -> integer or nil
  #   - index(regexp, offset = 0) -> integer or nil
  # -->
  # Returns the Integer index of the first occurrence of the given `substring`, or
  # `nil` if none found:
  #
  #     'foo'.index('f') # => 0
  #     'foo'.index('o') # => 1
  #     'foo'.index('oo') # => 1
  #     'foo'.index('ooo') # => nil
  #
  # Returns the Integer index of the first match for the given Regexp `regexp`, or
  # `nil` if none found:
  #
  #     'foo'.index(/f/) # => 0
  #     'foo'.index(/o/) # => 1
  #     'foo'.index(/oo/) # => 1
  #     'foo'.index(/ooo/) # => nil
  #
  # Integer argument `offset`, if given, specifies the position in the string to
  # begin the search:
  #
  #     'foo'.index('o', 1) # => 1
  #     'foo'.index('o', 2) # => 2
  #     'foo'.index('o', 3) # => nil
  #
  # If `offset` is negative, counts backward from the end of `self`:
  #
  #     'foo'.index('o', -1) # => 2
  #     'foo'.index('o', -2) # => 1
  #     'foo'.index('o', -3) # => 1
  #     'foo'.index('o', -4) # => nil
  #
  # Related: String#rindex.
  #
  def index: (Regexp | string substr_or_regexp, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - insert(index, other_string) -> self
  # -->
  # Inserts the given `other_string` into `self`; returns `self`.
  #
  # If the Integer `index` is positive, inserts `other_string` at offset `index`:
  #
  #     'foo'.insert(1, 'bar') # => "fbaroo"
  #
  # If the Integer `index` is negative, counts backward from the end of `self` and
  # inserts `other_string` at offset `index+1` (that is, *after* `self[index]`):
  #
  #     'foo'.insert(-2, 'bar') # => "fobaro"
  #
  def insert: (int index, string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - inspect -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, and with
  # special characters escaped:
  #
  #     s = "foo\tbar\tbaz\n"
  #     # => "foo\tbar\tbaz\n"
  #     s.inspect
  #     # => "\"foo\\tbar\\tbaz\\n\""
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.intern   -> symbol
  #   - str.to_sym   -> symbol
  # -->
  # Returns the Symbol corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  def intern: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - length -> integer
  # -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     "\x80\u3042".length # => 2
  #     "hello".length # => 5
  #
  # String#size is an alias for String#length.
  #
  # Related: String#bytesize.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.lines(separator=$/, chomp: false)  -> an_array
  # -->
  # Returns an array of lines in *str* split using the supplied record separator
  # (`$/` by default).  This is a shorthand for `str.each_line(separator,
  # getline_args).to_a`.
  #
  # If `chomp` is `true`, `separator` will be removed from the end of each line.
  #
  #     "hello\nworld\n".lines              #=> ["hello\n", "world\n"]
  #     "hello  world".lines(' ')           #=> ["hello ", " ", "world"]
  #     "hello\nworld\n".lines(chomp: true) #=> ["hello", "world"]
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_line`.
  #
  def lines: (?string separator, ?chomp: boolish) -> Array[String]

  # <!--
  #   rdoc-file=string.c
  #   - str.ljust(integer, padstr=' ')   -> new_str
  # -->
  # If *integer* is greater than the length of *str*, returns a new String of
  # length *integer* with *str* left justified and padded with *padstr*;
  # otherwise, returns *str*.
  #
  #     "hello".ljust(4)            #=> "hello"
  #     "hello".ljust(20)           #=> "hello               "
  #     "hello".ljust(20, '1234')   #=> "hello123412341234123"
  #
  def ljust: (int integer, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.lstrip   -> new_str
  # -->
  # Returns a copy of the receiver with leading whitespace removed. See also
  # String#rstrip and String#strip.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".lstrip   #=> "hello  "
  #     "hello".lstrip       #=> "hello"
  #
  def lstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.lstrip!   -> self or nil
  # -->
  # Removes leading whitespace from the receiver. Returns the altered receiver, or
  # `nil` if no change was made. See also String#rstrip! and String#strip!.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".lstrip!  #=> "hello  "
  #     "hello  ".lstrip!    #=> nil
  #     "hello".lstrip!      #=> nil
  #
  def lstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - match(pattern, offset = 0) -> matchdata or nil
  #   - match(pattern, offset = 0) {|matchdata| ... } -> object
  # -->
  # Returns a Matchdata object (or `nil`) based on `self` and the given `pattern`.
  #
  # Note: also updates [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # *   Computes `regexp` by converting `pattern` (if not already a Regexp).
  #         regexp = Regexp.new(pattern)
  #
  # *   Computes `matchdata`, which will be either a MatchData object or `nil`
  #     (see Regexp#match):
  #         matchdata = <tt>regexp.match(self)
  #
  #
  # With no block given, returns the computed `matchdata`:
  #
  #     'foo'.match('f') # => #<MatchData "f">
  #     'foo'.match('o') # => #<MatchData "o">
  #     'foo'.match('x') # => nil
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #
  #     'foo'.match('f', 1) # => nil
  #     'foo'.match('o', 1) # => #<MatchData "o">
  #
  # With a block given, calls the block with the computed `matchdata` and returns
  # the block's return value:
  #
  #     'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
  #     'foo'.match(/x/) {|matchdata| matchdata } # => nil
  #     'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil
  #
  def match: (Regexp | string pattern, ?int pos) -> MatchData?
           | [A] (Regexp | string pattern, ?int pos) { (MatchData) -> A } -> A

  # <!--
  #   rdoc-file=string.c
  #   - match?(pattern, offset = 0) -> true or false
  # -->
  # Returns `true` or `false` based on whether a match is found for `self` and
  # `pattern`.
  #
  # Note: does not update [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # Computes `regexp` by converting `pattern` (if not already a Regexp).
  #     regexp = Regexp.new(pattern)
  #
  # Returns `true` if `self+.match(regexp)` returns a Matchdata object, `false`
  # otherwise:
  #
  #     'foo'.match?(/o/) # => true
  #     'foo'.match?('o') # => true
  #     'foo'.match?(/x/) # => false
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #     'foo'.match?('f', 1) # => false
  #     'foo'.match?('o', 1) # => true
  #
  def match?: (Regexp | string pattern, ?int pos) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty String is a new empty String:
  #
  #     ''.succ # => ""
  #
  # String#next is an alias for String#succ.
  #
  def next: () -> String

  # <!-- rdoc-file=string.c -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  # String#next! is an alias for String#succ!.
  #
  def next!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.oct   -> integer
  # -->
  # Treats leading characters of *str* as a string of octal digits (with an
  # optional sign) and returns the corresponding number.  Returns 0 if the
  # conversion fails.
  #
  #     "123".oct       #=> 83
  #     "-377".oct      #=> -255
  #     "bad".oct       #=> 0
  #     "0377bad".oct   #=> 255
  #
  # If `str` starts with `0`, radix indicators are honored. See Kernel#Integer.
  #
  def oct: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.ord   -> integer
  # -->
  # Returns the Integer ordinal of a one-character string.
  #
  #     "a".ord         #=> 97
  #
  def ord: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.partition(sep)              -> [head, sep, tail]
  #   - str.partition(regexp)           -> [head, match, tail]
  # -->
  # Searches *sep* or pattern (*regexp*) in the string and returns the part before
  # it, the match, and the part after it. If it is not found, returns two empty
  # strings and *str*.
  #
  #     "hello".partition("l")         #=> ["he", "l", "lo"]
  #     "hello".partition("x")         #=> ["hello", "", ""]
  #     "hello".partition(/.l/)        #=> ["h", "el", "lo"]
  #
  def partition: (Regexp | string sep_or_regexp) -> [ String, String, String ]

  # <!--
  #   rdoc-file=string.c
  #   - prepend(*other_strings)  -> string
  # -->
  # Prepends each string in `other_strings` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.prepend('bar', 'baz') # => "barbazfoo"
  #     s                       # => "barbazfoo"
  #
  # Related: String#concat.
  #
  def prepend: (*string other_strs) -> String

  # <!-- rdoc-file=string.c -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  def replace: (string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - reverse -> string
  # -->
  # Returns a new string with the characters from `self` in reverse order.
  #
  #     'stressed'.reverse # => "desserts"
  #
  def reverse: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - reverse! -> self
  # -->
  # Returns `self` with its characters reversed:
  #
  #     s = 'stressed'
  #     s.reverse! # => "desserts"
  #     s          # => "desserts"
  #
  def reverse!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - rindex(substring, offset = self.length) -> integer or nil
  #   - rindex(regexp, offset = self.length) -> integer or nil
  # -->
  # Returns the Integer index of the *last* occurrence of the given `substring`,
  # or `nil` if none found:
  #
  #     'foo'.rindex('f') # => 0
  #     'foo'.rindex('o') # => 2
  #     'foo'.rindex('oo') # => 1
  #     'foo'.rindex('ooo') # => nil
  #
  # Returns the Integer index of the *last* match for the given Regexp `regexp`,
  # or `nil` if none found:
  #
  #     'foo'.rindex(/f/) # => 0
  #     'foo'.rindex(/o/) # => 2
  #     'foo'.rindex(/oo/) # => 1
  #     'foo'.rindex(/ooo/) # => nil
  #
  # The *last* match means starting at the possible last position, not the last of
  # longest matches.
  #
  #     'foo'.rindex(/o+/) # => 2
  #     $~ #=> #<MatchData "o">
  #
  # To get the last longest match, needs to combine with negative lookbehind.
  #
  #     'foo'.rindex(/(?<!o)o+/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Or String#index with negative lookforward.
  #
  #     'foo'.index(/o+(?!.*o)/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Integer argument `offset`, if given and non-negative, specifies the maximum
  # starting position in the
  #     string to _end_ the search:
  #
  #      'foo'.rindex('o', 0) # => nil
  #      'foo'.rindex('o', 1) # => 1
  #      'foo'.rindex('o', 2) # => 2
  #      'foo'.rindex('o', 3) # => 2
  #
  # If `offset` is a negative Integer, the maximum starting position in the string
  # to *end* the search is the sum of the string's length and `offset`:
  #
  #     'foo'.rindex('o', -1) # => 2
  #     'foo'.rindex('o', -2) # => 1
  #     'foo'.rindex('o', -3) # => nil
  #     'foo'.rindex('o', -4) # => nil
  #
  # Related: String#index.
  #
  def rindex: (string | Regexp substr_or_regexp, ?int pos) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - str.rjust(integer, padstr=' ')   -> new_str
  # -->
  # If *integer* is greater than the length of *str*, returns a new String of
  # length *integer* with *str* right justified and padded with *padstr*;
  # otherwise, returns *str*.
  #
  #     "hello".rjust(4)            #=> "hello"
  #     "hello".rjust(20)           #=> "               hello"
  #     "hello".rjust(20, '1234')   #=> "123412341234123hello"
  #
  def rjust: (int integer, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.rpartition(sep)             -> [head, sep, tail]
  #   - str.rpartition(regexp)          -> [head, match, tail]
  # -->
  # Searches *sep* or pattern (*regexp*) in the string from the end of the string,
  # and returns the part before it, the match, and the part after it. If it is not
  # found, returns two empty strings and *str*.
  #
  #     "hello".rpartition("l")         #=> ["hel", "l", "o"]
  #     "hello".rpartition("x")         #=> ["", "", "hello"]
  #     "hello".rpartition(/.l/)        #=> ["he", "ll", "o"]
  #
  # The match from the end means starting at the possible last position, not the
  # last of longest matches.
  #
  #     "hello".rpartition(/l+/)        #=> ["hel", "l", "o"]
  #
  # To partition at the last longest match, needs to combine with negative
  # lookbehind.
  #
  #     "hello".rpartition(/(?<!l)l+/)  #=> ["he", "ll", "o"]
  #
  # Or String#partition with negative lookforward.
  #
  #     "hello".partition(/l+(?!.*l)/)  #=> ["he", "ll", "o"]
  #
  def rpartition: (string | Regexp sep_or_regexp) -> [ String, String, String ]

  # <!--
  #   rdoc-file=string.c
  #   - str.rstrip   -> new_str
  # -->
  # Returns a copy of the receiver with trailing whitespace removed. See also
  # String#lstrip and String#strip.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".rstrip   #=> "  hello"
  #     "hello".rstrip       #=> "hello"
  #
  def rstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.rstrip!   -> self or nil
  # -->
  # Removes trailing whitespace from the receiver. Returns the altered receiver,
  # or `nil` if no change was made. See also String#lstrip! and String#strip!.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".rstrip!  #=> "  hello"
  #     "  hello".rstrip!    #=> nil
  #     "hello".rstrip!      #=> nil
  #
  def rstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - str.scan(pattern)                         -> array
  #   - str.scan(pattern) {|match, ...| block }   -> str
  # -->
  # Both forms iterate through *str*, matching the pattern (which may be a Regexp
  # or a String). For each match, a result is generated and either added to the
  # result array or passed to the block. If the pattern contains no groups, each
  # individual result consists of the matched string, `$&`.  If the pattern
  # contains groups, each individual result is itself an array containing one
  # entry per group.
  #
  #     a = "cruel world"
  #     a.scan(/\w+/)        #=> ["cruel", "world"]
  #     a.scan(/.../)        #=> ["cru", "el ", "wor"]
  #     a.scan(/(...)/)      #=> [["cru"], ["el "], ["wor"]]
  #     a.scan(/(..)(..)/)   #=> [["cr", "ue"], ["l ", "wo"]]
  #
  # And the block form:
  #
  #     a.scan(/\w+/) {|w| print "<<#{w}>> " }
  #     print "\n"
  #     a.scan(/(.)(.)/) {|x,y| print y, x }
  #     print "\n"
  #
  # *produces:*
  #
  #     <<cruel>> <<world>>
  #     rceu lowlr
  #
  def scan: (Regexp | string pattern) -> Array[String | Array[String]]
          | (Regexp | string pattern) { (String | Array[String]) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.scrub -> new_str
  #   - str.scrub(repl) -> new_str
  #   - str.scrub{|bytes|} -> new_str
  # -->
  # If the string is invalid byte sequence then replace invalid bytes with given
  # replacement character, else returns self. If block is given, replace invalid
  # bytes with returned value of the block.
  #
  #     "abc\u3042\x81".scrub #=> "abc\u3042\uFFFD"
  #     "abc\u3042\x81".scrub("*") #=> "abc\u3042*"
  #     "abc\u3042\xE3\x80".scrub{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"
  #
  def scrub: (?string repl) -> String
           | () { (String bytes) -> string } -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.scrub! -> str
  #   - str.scrub!(repl) -> str
  #   - str.scrub!{|bytes|} -> str
  # -->
  # If the string is invalid byte sequence then replace invalid bytes with given
  # replacement character, else returns self. If block is given, replace invalid
  # bytes with returned value of the block.
  #
  #     "abc\u3042\x81".scrub! #=> "abc\u3042\uFFFD"
  #     "abc\u3042\x81".scrub!("*") #=> "abc\u3042*"
  #     "abc\u3042\xE3\x80".scrub!{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"
  #
  def scrub!: (?string repl) -> self
            | () { (String bytes) -> string } -> self

  # <!--
  #   rdoc-file=string.c
  #   - setbyte(index, integer) -> integer
  # -->
  # Sets the byte at zero-based `index` to `integer`; returns `integer`:
  #
  #     s = 'abcde'      # => "abcde"
  #     s.setbyte(0, 98) # => 98
  #     s                # => "bbcde"
  #
  # Related: String#getbyte.
  #
  def setbyte: (int index, int integer) -> int

  # <!-- rdoc-file=string.c -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     "\x80\u3042".length # => 2
  #     "hello".length # => 5
  #
  # String#size is an alias for String#length.
  #
  # Related: String#bytesize.
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Returns the substring of `self` specified by the arguments.
  #
  # When the single Integer argument `index` is given, returns the 1-character
  # substring found in `self` at offset `index`:
  #
  #     'bar'[2] # => "r"
  #
  # Counts backward from the end of `self` if `index` is negative:
  #
  #     'foo'[-3] # => "f"
  #
  # Returns `nil` if `index` is out of range:
  #
  #     'foo'[3] # => nil
  #     'foo'[-4] # => nil
  #
  # When the two Integer arguments  `start` and `length` are given, returns the
  # substring of the given `length` found in `self` at offset `start`:
  #
  #     'foo'[0, 2] # => "fo"
  #     'foo'[0, 0] # => ""
  #
  # Counts backward from the end of `self` if `start` is negative:
  #
  #     'foo'[-2, 2] # => "oo"
  #
  # Special case: returns a new empty String if `start` is equal to the length of
  # `self`:
  #
  #     'foo'[3, 2] # => ""
  #
  # Returns `nil` if `start` is out of range:
  #
  #     'foo'[4, 2] # => nil
  #     'foo'[-4, 2] # => nil
  #
  # Returns the trailing substring of `self` if `length` is large:
  #
  #     'foo'[1, 50] # => "oo"
  #
  # Returns `nil` if `length` is negative:
  #
  #     'foo'[0, -1] # => nil
  #
  # When the single Range argument `range` is given, derives `start` and `length`
  # values from the given `range`, and returns values as above:
  #
  # *   `'foo'[0..1]` is equivalent to `'foo'[0, 2]`.
  # *   `'foo'[0...1]` is equivalent to `'foo'[0, 1]`.
  #
  #
  # When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
  # returns the first matching substring found in `self`, or `nil` if none found:
  #
  #     'foo'[/o/] # => "o"
  #     'foo'[/x/] # => nil
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/] # => "ell"
  #     s[/[aeiou](.)\1/, 0] # => "ell"
  #
  # If argument `capture` is given and not `0`, it should be either an Integer
  # capture group index or a String or Symbol capture group name; the method call
  # returns only the specified capture (see [Regexp
  # Capturing](Regexp.html#class-Regexp-label-Capturing)):
  #
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/, 1] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel] # => "e"
  #
  # If an invalid capture group index is given, `nil` is returned.  If an invalid
  # capture group name is given, `IndexError` is raised.
  #
  # When the single String argument `substring` is given, returns the substring
  # from `self` if found, otherwise `nil`:
  #
  #     'foo'['oo'] # => "oo"
  #     'foo'['xx'] # => nil
  #
  # String#slice is an alias for String#[].
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - slice!(index)               -> new_string or nil
  #   - slice!(start, length)       -> new_string or nil
  #   - slice!(range)               -> new_string or nil
  #   - slice!(regexp, capture = 0) -> new_string or nil
  #   - slice!(substring)           -> new_string or nil
  # -->
  # Removes the substring of `self` specified by the arguments; returns the
  # removed substring.
  #
  # See String#[] for details about the arguments that specify the substring.
  #
  # A few examples:
  #
  #     string = "This is a string"
  #     string.slice!(2)        #=> "i"
  #     string.slice!(3..6)     #=> " is "
  #     string.slice!(/s.*t/)   #=> "sa st"
  #     string.slice!("r")      #=> "r"
  #     string                  #=> "Thing"
  #
  def slice!: (int integer, ?int integer) -> String?
            | (Range[Integer] | Range[Integer?] range) -> String?
            | (Regexp regexp, ?int | String capture) -> String?
            | (String other_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.split(pattern=nil, [limit])                -> an_array
  #   - str.split(pattern=nil, [limit]) {|sub| block } -> str
  # -->
  # Divides *str* into substrings based on a delimiter, returning an array of
  # these substrings.
  #
  # If *pattern* is a String, then its contents are used as the delimiter when
  # splitting *str*. If *pattern* is a single space, *str* is split on whitespace,
  # with leading and trailing whitespace and runs of contiguous whitespace
  # characters ignored.
  #
  # If *pattern* is a Regexp, *str* is divided where the pattern matches. Whenever
  # the pattern matches a zero-length string, *str* is split into individual
  # characters. If *pattern* contains groups, the respective matches will be
  # returned in the array as well.
  #
  # If *pattern* is `nil`, the value of `$;` is used. If `$;` is `nil` (which is
  # the default), *str* is split on whitespace as if ' ' were specified.
  #
  # If the *limit* parameter is omitted, trailing null fields are suppressed. If
  # *limit* is a positive number, at most that number of split substrings will be
  # returned (captured groups will be returned as well, but are not counted
  # towards the limit). If *limit* is `1`, the entire string is returned as the
  # only entry in an array. If negative, there is no limit to the number of fields
  # returned, and trailing null fields are not suppressed.
  #
  # When the input `str` is empty an empty Array is returned as the string is
  # considered to have no fields to split.
  #
  #     " now's  the time ".split       #=> ["now's", "the", "time"]
  #     " now's  the time ".split(' ')  #=> ["now's", "the", "time"]
  #     " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]
  #     "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]
  #     "hello".split(//)               #=> ["h", "e", "l", "l", "o"]
  #     "hello".split(//, 3)            #=> ["h", "e", "llo"]
  #     "hi mom".split(%r{\s*})         #=> ["h", "i", "m", "o", "m"]
  #
  #     "mellow yellow".split("ello")   #=> ["m", "w y", "w"]
  #     "1,2,,3,4,,".split(',')         #=> ["1", "2", "", "3", "4"]
  #     "1,2,,3,4,,".split(',', 4)      #=> ["1", "2", "", "3,4,,"]
  #     "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]
  #
  #     "1:2:3".split(/(:)()()/, 2)     #=> ["1", ":", "", "", "2:3"]
  #
  #     "".split(',', -1)               #=> []
  #
  # If a block is given, invoke the block with each split substring.
  #
  def split: (?Regexp | string pattern, ?int limit) -> Array[String]
           | (?Regexp | string pattern, ?int limit) { (String) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.squeeze([other_str]*)    -> new_str
  # -->
  # Builds a set of characters from the *other_str* parameter(s) using the
  # procedure described for String#count. Returns a new string where runs of the
  # same character that occur in this set are replaced by a single character. If
  # no arguments are given, all runs of identical characters are replaced by a
  # single character.
  #
  #     "yellow moon".squeeze                  #=> "yelow mon"
  #     "  now   is  the".squeeze(" ")         #=> " now is the"
  #     "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
  #
  def squeeze: (*string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.squeeze!([other_str]*)   -> str or nil
  # -->
  # Squeezes *str* in place, returning either *str*, or `nil` if no changes were
  # made.
  #
  def squeeze!: (*string other_str) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - str.start_with?([prefixes]+)   -> true or false
  # -->
  # Returns true if `str` starts with one of the `prefixes` given. Each of the
  # `prefixes` should be a String or a Regexp.
  #
  #     "hello".start_with?("hell")               #=> true
  #     "hello".start_with?(/H/i)                 #=> true
  #
  #     # returns true if one of the prefixes matches.
  #     "hello".start_with?("heaven", "hell")     #=> true
  #     "hello".start_with?("heaven", "paradise") #=> false
  #
  def start_with?: (*string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.strip   -> new_str
  # -->
  # Returns a copy of the receiver with leading and trailing whitespace removed.
  #
  # Whitespace is defined as any of the following characters: null, horizontal
  # tab, line feed, vertical tab, form feed, carriage return, space.
  #
  #     "    hello    ".strip   #=> "hello"
  #     "\tgoodbye\r\n".strip   #=> "goodbye"
  #     "\x00\t\n\v\f\r ".strip #=> ""
  #     "hello".strip           #=> "hello"
  #
  def strip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.strip!   -> self or nil
  # -->
  # Removes leading and trailing whitespace from the receiver. Returns the altered
  # receiver, or `nil` if there was no change.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".strip!  #=> "hello"
  #     "hello".strip!      #=> nil
  #
  def strip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - sub(pattern, replacement)   -> new_string
  #   - sub(pattern) {|match| ... } -> new_string
  # -->
  # Returns a copy of `self` with only the first occurrence (not all occurrences)
  # of the given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Related: String#sub!, String#gsub, String#gsub!.
  #
  def sub: (Regexp | string pattern, string | Hash[String, String] replacement) -> String
         | (Regexp | string pattern) { (String match) -> _ToS } -> String

  # <!--
  #   rdoc-file=string.c
  #   - sub!(pattern, replacement)   -> self or nil
  #   - sub!(pattern) {|match| ... } -> self or nil
  # -->
  # Returns `self` with only the first occurrence (not all occurrences) of the
  # given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Related: String#sub, String#gsub, String#gsub!.
  #
  def sub!: (Regexp | string pattern, string | Hash[String, String] replacement) -> self?
          | (Regexp | string pattern) { (String match) -> _ToS } -> String?

  # <!--
  #   rdoc-file=string.c
  #   - succ -> new_str
  # -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty String is a new empty String:
  #
  #     ''.succ # => ""
  #
  # String#next is an alias for String#succ.
  #
  def succ: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - succ! -> self
  # -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  # String#next! is an alias for String#succ!.
  #
  def succ!: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.sum(n=16)   -> integer
  # -->
  # Returns a basic *n*-bit checksum of the characters in *str*, where *n* is the
  # optional Integer parameter, defaulting to 16. The result is simply the sum of
  # the binary value of each byte in *str* modulo `2**n - 1`. This is not a
  # particularly good checksum.
  #
  def sum: (?int n) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> string
  # -->
  # Returns a string containing the characters in `self`, with cases reversed;
  # each uppercase character is downcased; each lowercase character is upcased:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase         # => "hELLO wORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#swapcase!.
  #
  def swapcase: () -> String
              | (:ascii | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - swapcase!(*options) -> self or nil
  # -->
  # Upcases each lowercase character in `self`; downcases uppercase character;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase!        # => "hELLO wORLD!"
  #     s                  # => "Hello World!"
  #     ''.swapcase!       # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#swapcase.
  #
  def swapcase!: () -> self?
               | (:ascii | :lithuanian | :turkic) -> self?
               | (:lithuanian, :turkic) -> self?
               | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - str.to_c  ->  complex
  # -->
  # Returns a complex which denotes the string form.  The parser ignores leading
  # whitespaces and trailing garbage.  Any digit sequences can be separated by an
  # underscore.  Returns zero for null or garbage string.
  #
  #     '9'.to_c           #=> (9+0i)
  #     '2.5'.to_c         #=> (2.5+0i)
  #     '2.5/1'.to_c       #=> ((5/2)+0i)
  #     '-3/2'.to_c        #=> ((-3/2)+0i)
  #     '-i'.to_c          #=> (0-1i)
  #     '45i'.to_c         #=> (0+45i)
  #     '3-4i'.to_c        #=> (3-4i)
  #     '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)
  #     '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)
  #     '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)
  #     'ruby'.to_c        #=> (0+0i)
  #
  # See Kernel.Complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=string.c
  #   - to_f -> float
  # -->
  # Returns the result of interpreting leading characters in `self` as a Float:
  #
  #     '3.14159'.to_f  # => 3.14159
  #     '1.234e-2'.to_f # => 0.01234
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '3.14 (pi to two places)'.to_f # => 3.14
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_f # => 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=string.c
  #   - to_i(base = 10) -> integer
  # -->
  # Returns the result of interpreting leading characters in `self` as an integer
  # in the given `base` (which must be in (2..36)):
  #
  #     '123456'.to_i     # => 123456
  #     '123def'.to_i(16) # => 1195503
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '12.345'.to_i   # => 12
  #     '12345'.to_i(2) # => 1
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_i # => 0
  #     '2'.to_i(2)   # => 0
  #
  def to_i: (?int base) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - str.to_r  ->  rational
  # -->
  # Returns the result of interpreting leading characters in `str` as a rational.
  # Leading whitespace and extraneous characters past the end of a valid number
  # are ignored. Digit sequences can be separated by an underscore. If there is
  # not a valid number at the start of `str`, zero is returned.  This method never
  # raises an exception.
  #
  #     '  2  '.to_r       #=> (2/1)
  #     '300/2'.to_r       #=> (150/1)
  #     '-9.2'.to_r        #=> (-46/5)
  #     '-9.2e2'.to_r      #=> (-920/1)
  #     '1_234_567'.to_r   #=> (1234567/1)
  #     '21 June 09'.to_r  #=> (21/1)
  #     '21/06/09'.to_r    #=> (7/2)
  #     'BWV 1079'.to_r    #=> (0/1)
  #
  # NOTE: "0.3".to_r isn't the same as 0.3.to_r.  The former is equivalent to
  # "3/10".to_r, but the latter isn't so.
  #
  #     "0.3".to_r == 3/10r  #=> true
  #     0.3.to_r   == 3/10r  #=> false
  #
  # See also Kernel#Rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=string.c
  #   - to_s -> self or string
  # -->
  # Returns `self` if `self` is a String, or `self` converted to a String if
  # `self` is a subclass of String.
  #
  # String#to_str is an alias for String#to_s.
  #
  def to_s: () -> String

  # <!-- rdoc-file=string.c -->
  # Returns `self` if `self` is a String, or `self` converted to a String if
  # `self` is a subclass of String.
  #
  # String#to_str is an alias for String#to_s.
  #
  def to_str: () -> String

  # <!-- rdoc-file=string.c -->
  # Returns the Symbol corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  def to_sym: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - str.tr(from_str, to_str)   => new_str
  # -->
  # Returns a copy of `str` with the characters in `from_str` replaced by the
  # corresponding characters in `to_str`.  If `to_str` is shorter than `from_str`,
  # it is padded with its last character in order to maintain the correspondence.
  #
  #     "hello".tr('el', 'ip')      #=> "hippo"
  #     "hello".tr('aeiou', '*')    #=> "h*ll*"
  #     "hello".tr('aeiou', 'AA*')  #=> "hAll*"
  #
  # Both strings may use the `c1-c2` notation to denote ranges of characters, and
  # `from_str` may start with a `^`, which denotes all characters except those
  # listed.
  #
  #     "hello".tr('a-y', 'b-z')    #=> "ifmmp"
  #     "hello".tr('^aeiou', '*')   #=> "*e**o"
  #
  # The backslash character `\` can be used to escape `^` or `-` and is otherwise
  # ignored unless it appears at the end of a range or the end of the `from_str`
  # or `to_str`:
  #
  #     "hello^world".tr("\\^aeiou", "*") #=> "h*ll**w*rld"
  #     "hello-world".tr("a\\-eo", "*")   #=> "h*ll**w*rld"
  #
  #     "hello\r\nworld".tr("\r", "")   #=> "hello\nworld"
  #     "hello\r\nworld".tr("\\r", "")  #=> "hello\r\nwold"
  #     "hello\r\nworld".tr("\\\r", "") #=> "hello\nworld"
  #
  #     "X['\\b']".tr("X\\", "")   #=> "['b']"
  #     "X['\\b']".tr("X-\\]", "") #=> "'b'"
  #
  def tr: (string from_str, string to_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.tr!(from_str, to_str)   -> str or nil
  # -->
  # Translates *str* in place, using the same rules as String#tr. Returns *str*,
  # or `nil` if no changes were made.
  #
  def tr!: (string from_str, string to_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.tr_s(from_str, to_str)   -> new_str
  # -->
  # Processes a copy of *str* as described under String#tr, then removes duplicate
  # characters in regions that were affected by the translation.
  #
  #     "hello".tr_s('l', 'r')     #=> "hero"
  #     "hello".tr_s('el', '*')    #=> "h*o"
  #     "hello".tr_s('el', 'hx')   #=> "hhxo"
  #
  def tr_s: (string from_str, string to_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.tr_s!(from_str, to_str)   -> str or nil
  # -->
  # Performs String#tr_s processing on *str* in place, returning *str*, or `nil`
  # if no changes were made.
  #
  def tr_s!: (string from_str, string to_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - undump -> string
  # -->
  # Returns an unescaped version of `self`:
  #
  #     s_orig = "\f\x00\xff\\\""    # => "\f\u0000\xFF\\\""
  #     s_dumped = s_orig.dump       # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #     s_undumped = s_dumped.undump # => "\f\u0000\xFF\\\""
  #     s_undumped == s_orig         # => true
  #
  # Related: String#dump (inverse of String#undump).
  #
  def undump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalize(form=:nfc)
  # -->
  # Unicode Normalization---Returns a normalized form of `str`, using Unicode
  # normalizations NFC, NFD, NFKC, or NFKD. The normalization form used is
  # determined by `form`, which can be any of the four values `:nfc`, `:nfd`,
  # `:nfkc`, or `:nfkd`. The default is `:nfc`.
  #
  # If the string is not in a Unicode Encoding, then an Exception is raised. In
  # this context, 'Unicode Encoding' means any of UTF-8, UTF-16BE/LE, and
  # UTF-32BE/LE, as well as GB18030, UCS_2BE, and UCS_4BE. Anything other than
  # UTF-8 is implemented by converting to UTF-8, which makes it slower than UTF-8.
  #
  #     "a\u0300".unicode_normalize        #=> "\u00E0"
  #     "a\u0300".unicode_normalize(:nfc)  #=> "\u00E0"
  #     "\u00E0".unicode_normalize(:nfd)   #=> "a\u0300"
  #     "\xE0".force_encoding('ISO-8859-1').unicode_normalize(:nfd)
  #                                        #=> Encoding::CompatibilityError raised
  #
  def unicode_normalize: (?:nfc | :nfd | :nfkc | :nfkd) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalize!(form=:nfc)
  # -->
  # Destructive version of String#unicode_normalize, doing Unicode normalization
  # in place.
  #
  def unicode_normalize!: (?:nfc | :nfd | :nfkc | :nfkd) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalized?(form=:nfc)
  # -->
  # Checks whether `str` is in Unicode normalization form `form`, which can be any
  # of the four values `:nfc`, `:nfd`, `:nfkc`, or `:nfkd`. The default is `:nfc`.
  #
  # If the string is not in a Unicode Encoding, then an Exception is raised. For
  # details, see String#unicode_normalize.
  #
  #     "a\u0300".unicode_normalized?        #=> false
  #     "a\u0300".unicode_normalized?(:nfd)  #=> true
  #     "\u00E0".unicode_normalized?         #=> true
  #     "\u00E0".unicode_normalized?(:nfd)   #=> false
  #     "\xE0".force_encoding('ISO-8859-1').unicode_normalized?
  #                                          #=> Encoding::CompatibilityError raised
  #
  def unicode_normalized?: (?:nfc | :nfd | :nfkc | :nfkd) -> bool

  # <!--
  #   rdoc-file=pack.rb
  #   - str.unpack(format)    ->  anArray
  #   - str.unpack(format, offset: anInteger)    ->  anArray
  # -->
  # Decodes *str* (which may contain binary data) according to the format string,
  # returning an array of each value extracted. The format string consists of a
  # sequence of single-character directives, summarized in the table at the end of
  # this entry. Each directive may be followed by a number, indicating the number
  # of times to repeat with this directive. An asterisk (```*`'') will use up all
  # remaining elements. The directives `sSiIlL` may each be followed by an
  # underscore (```_`'') or exclamation mark (```!`'') to use the underlying
  # platform's native size for the specified type; otherwise, it uses a
  # platform-independent consistent size. Spaces are ignored in the format string.
  #
  # See also String#unpack1,  Array#pack.
  #
  #     "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
  #     "abc \0\0".unpack('a3a3')           #=> ["abc", " \000\000"]
  #     "abc \0abc \0".unpack('Z*Z*')       #=> ["abc ", "abc "]
  #     "aa".unpack('b8B8')                 #=> ["10000110", "01100001"]
  #     "aaa".unpack('h2H2c')               #=> ["16", "61", 97]
  #     "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]
  #     "now=20is".unpack('M*')             #=> ["now is"]
  #     "whole".unpack('xax2aX2aX1aX2a')    #=> ["h", "e", "l", "l", "o"]
  #
  # This table summarizes the various formats and the Ruby classes returned by
  # each.
  #
  #     Integer       |         |
  #     Directive     | Returns | Meaning
  #     ------------------------------------------------------------------
  #     C             | Integer | 8-bit unsigned (unsigned char)
  #     S             | Integer | 16-bit unsigned, native endian (uint16_t)
  #     L             | Integer | 32-bit unsigned, native endian (uint32_t)
  #     Q             | Integer | 64-bit unsigned, native endian (uint64_t)
  #     J             | Integer | pointer width unsigned, native endian (uintptr_t)
  #                   |         |
  #     c             | Integer | 8-bit signed (signed char)
  #     s             | Integer | 16-bit signed, native endian (int16_t)
  #     l             | Integer | 32-bit signed, native endian (int32_t)
  #     q             | Integer | 64-bit signed, native endian (int64_t)
  #     j             | Integer | pointer width signed, native endian (intptr_t)
  #                   |         |
  #     S_ S!         | Integer | unsigned short, native endian
  #     I I_ I!       | Integer | unsigned int, native endian
  #     L_ L!         | Integer | unsigned long, native endian
  #     Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #     J!            | Integer | uintptr_t, native endian (same with J)
  #                   |         |
  #     s_ s!         | Integer | signed short, native endian
  #     i i_ i!       | Integer | signed int, native endian
  #     l_ l!         | Integer | signed long, native endian
  #     q_ q!         | Integer | signed long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #     j!            | Integer | intptr_t, native endian (same with j)
  #                   |         |
  #     S> s> S!> s!> | Integer | same as the directives without ">" except
  #     L> l> L!> l!> |         | big endian
  #     I!> i!>       |         |
  #     Q> q> Q!> q!> |         | "S>" is the same as "n"
  #     J> j> J!> j!> |         | "L>" is the same as "N"
  #                   |         |
  #     S< s< S!< s!< | Integer | same as the directives without "<" except
  #     L< l< L!< l!< |         | little endian
  #     I!< i!<       |         |
  #     Q< q< Q!< q!< |         | "S<" is the same as "v"
  #     J< j< J!< j!< |         | "L<" is the same as "V"
  #                   |         |
  #     n             | Integer | 16-bit unsigned, network (big-endian) byte order
  #     N             | Integer | 32-bit unsigned, network (big-endian) byte order
  #     v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
  #     V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
  #                   |         |
  #     U             | Integer | UTF-8 character
  #     w             | Integer | BER-compressed integer (see Array#pack)
  #
  #     Float        |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     D d          | Float   | double-precision, native format
  #     F f          | Float   | single-precision, native format
  #     E            | Float   | double-precision, little-endian byte order
  #     e            | Float   | single-precision, little-endian byte order
  #     G            | Float   | double-precision, network (big-endian) byte order
  #     g            | Float   | single-precision, network (big-endian) byte order
  #
  #     String       |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     A            | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)
  #     a            | String  | arbitrary binary string
  #     Z            | String  | null-terminated string
  #     B            | String  | bit string (MSB first)
  #     b            | String  | bit string (LSB first)
  #     H            | String  | hex string (high nibble first)
  #     h            | String  | hex string (low nibble first)
  #     u            | String  | UU-encoded string
  #     M            | String  | quoted-printable, MIME encoding (see RFC2045)
  #     m            | String  | base64 encoded string (RFC 2045) (default)
  #                  |         | base64 encoded string (RFC 4648) if followed by 0
  #     P            | String  | pointer to a structure (fixed-length string)
  #     p            | String  | pointer to a null-terminated string
  #
  #     Misc.        |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     @            | ---     | skip to the offset given by the length argument
  #     X            | ---     | skip backward one byte
  #     x            | ---     | skip forward one byte
  #
  # The keyword *offset* can be given to start the decoding after skipping the
  # specified amount of bytes:
  #     "abc".unpack("C*") # => [97, 98, 99]
  #     "abc".unpack("C*", offset: 2) # => [99]
  #     "abc".unpack("C*", offset: 4) # => offset outside of string (ArgumentError)
  #
  # HISTORY
  #
  # *   J, J! j, and j! are available since Ruby 2.3.
  # *   Q_, Q!, q_, and q! are available since Ruby 2.1.
  # *   I!<, i!<, I!>, and i!> are available since Ruby 1.9.3.
  #
  def unpack: (String format, ?offset: Integer) -> Array[Integer | Float | String | nil]

  # <!--
  #   rdoc-file=pack.rb
  #   - str.unpack1(format)    ->  obj
  #   - str.unpack1(format, offset: anInteger)    ->  obj
  # -->
  # Decodes *str* (which may contain binary data) according to the format string,
  # returning the first value extracted.
  #
  # See also String#unpack, Array#pack.
  #
  # Contrast with String#unpack:
  #
  #     "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
  #     "abc \0\0abc \0\0".unpack1('A6Z6')  #=> "abc"
  #
  # In that case data would be lost but often it's the case that the array only
  # holds one value, especially when unpacking binary data. For instance:
  #
  #     "\xff\x00\x00\x00".unpack("l")         #=>  [255]
  #     "\xff\x00\x00\x00".unpack1("l")        #=>  255
  #
  # Thus unpack1 is convenient, makes clear the intention and signals the expected
  # return value to those reading the code.
  #
  # The keyword *offset* can be given to start the decoding after skipping the
  # specified amount of bytes:
  #     "abc".unpack1("C*") # => 97
  #     "abc".unpack1("C*", offset: 2) # => 99
  #     "abc".unpack1("C*", offset: 4) # => offset outside of string (ArgumentError)
  #
  def unpack1: (String format) -> (Integer | Float | String | nil)

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> string
  # -->
  # Returns a string containing the upcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase           # => "HELLO WORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#upcase!, String#downcase, String#downcase!.
  #
  def upcase: () -> String
            | (:ascii | :lithuanian | :turkic) -> String
            | (:lithuanian, :turkic) -> String
            | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - upcase!(*options) -> self or nil
  # -->
  # Upcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase!          # => "HELLO WORLD!"
  #     s                  # => "HELLO WORLD!"
  #     s.upcase!          # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#upcase, String#downcase, String#downcase!.
  #
  def upcase!: () -> self?
             | (:ascii | :lithuanian | :turkic) -> self?
             | (:lithuanian, :turkic) -> self?
             | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - upto(other_string, exclusive = false) {|string| ... } -> self
  #   - upto(other_string, exclusive = false) -> new_enumerator
  # -->
  # With a block given, calls the block with each String value returned by
  # successive calls to String#succ; the first value is `self`, the next is
  # `self.succ`, and so on; the sequence terminates when value `other_string` is
  # reached; returns `self`:
  #
  #     'a8'.upto('b6') {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5 b6
  #
  # If argument `exclusive` is given as a truthy object, the last value is
  # omitted:
  #
  #     'a8'.upto('b6', true) {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5
  #
  # If `other_string` would not be reached, does not call the block:
  #
  #     '25'.upto('5') {|s| fail s }
  #     'aa'.upto('a') {|s| fail s }
  #
  # With no block given, returns a new Enumerator:
  #
  #     'a8'.upto('b6') # => #<Enumerator: "a8":upto("b6")>
  #
  def upto: (string other_str, ?boolish exclusive) -> Enumerator[String, self]
          | (string other_str, ?boolish exclusive) { (String s) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.valid_encoding?  -> true or false
  # -->
  # Returns true for a string which is encoded correctly.
  #
  #     "\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true
  #     "\xc2".force_encoding("UTF-8").valid_encoding?      #=> false
  #     "\x80".force_encoding("UTF-8").valid_encoding?      #=> false
  #
  def valid_encoding?: () -> bool

  private

  # <!--
  #   rdoc-file=string.c
  #   - String.new(string = '') -> new_string
  #   - String.new(string = '', encoding: encoding) -> new_string
  #   - String.new(string = '', capacity: size) -> new_string
  # -->
  # Returns a new String that is a copy of `string`.
  #
  # With no arguments, returns the empty string with the Encoding `ASCII-8BIT`:
  #     s = String.new
  #     s # => ""
  #     s.encoding # => #<Encoding:ASCII-8BIT>
  #
  # With the single String argument `string`, returns a copy of `string` with the
  # same encoding as `string`:
  #     s = String.new("Que veut dire \u{e7}a?")
  #     s # => "Que veut dire \u{e7}a?"
  #     s.encoding # => #<Encoding:UTF-8>
  #
  # Literal strings like `""` or here-documents always use [script
  # encoding](Encoding.html#class-Encoding-label-Script+encoding), unlike
  # String.new.
  #
  # With keyword `encoding`, returns a copy of `str` with the specified encoding:
  #     s = String.new(encoding: 'ASCII')
  #     s.encoding # => #<Encoding:US-ASCII>
  #     s = String.new('foo', encoding: 'ASCII')
  #     s.encoding # => #<Encoding:US-ASCII>
  #
  # Note that these are equivalent:
  #     s0 = String.new('foo', encoding: 'ASCII')
  #     s1 = 'foo'.force_encoding('ASCII')
  #     s0.encoding == s1.encoding # => true
  #
  # With keyword `capacity`, returns a copy of `str`; the given `capacity` may set
  # the size of the internal buffer, which may affect performance:
  #     String.new(capacity: 1) # => ""
  #     String.new(capacity: 4096) # => ""
  #
  # The `string`, `encoding`, and `capacity` arguments may all be used together:
  #
  #     String.new('hello', encoding: 'UTF-8', capacity: 25)
  #
  def initialize: (?string str, ?encoding: encoding, ?capacity: int) -> void

  # <!--
  #   rdoc-file=string.c
  #   - replace(other_string) -> self
  # -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  alias initialize_copy replace
end

interface _ArefFromStringToString
  def []: (String) -> String
end

type String::encode_fallback = Hash[String, String] | Proc | Method | _ArefFromStringToString

# <!-- rdoc-file=proc.c -->
# A `Proc` object is an encapsulation of a block of code, which can be stored in
# a local variable, passed to a method or another Proc, and can be called. Proc
# is an essential concept in Ruby and a core of its functional programming
# features.
#
#     square = Proc.new {|x| x**2 }
#
#     square.call(3)  #=> 9
#     # shorthands:
#     square.(3)      #=> 9
#     square[3]       #=> 9
#
# Proc objects are *closures*, meaning they remember and can use the entire
# context in which they were created.
#
#     def gen_times(factor)
#       Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
#     end
#
#     times3 = gen_times(3)
#     times5 = gen_times(5)
#
#     times3.call(12)               #=> 36
#     times5.call(5)                #=> 25
#     times3.call(times5.call(4))   #=> 60
#
# ## Creation
#
# There are several methods to create a Proc
#
# *   Use the Proc class constructor:
#
#         proc1 = Proc.new {|x| x**2 }
#
# *   Use the Kernel#proc method as a shorthand of Proc.new:
#
#         proc2 = proc {|x| x**2 }
#
# *   Receiving a block of code into proc argument (note the `&`):
#
#         def make_proc(&block)
#           block
#         end
#
#         proc3 = make_proc {|x| x**2 }
#
# *   Construct a proc with lambda semantics using the Kernel#lambda method (see
#     below for explanations about lambdas):
#
#         lambda1 = lambda {|x| x**2 }
#
# *   Use the [Lambda proc
#     literal](doc/syntax/literals_rdoc.html#label-Lambda+Proc+Literals) syntax
#     (also constructs a proc with lambda semantics):
#
#         lambda2 = ->(x) { x**2 }
#
#
# ## Lambda and non-lambda semantics
#
# Procs are coming in two flavors: lambda and non-lambda (regular procs).
# Differences are:
#
# *   In lambdas, `return` and `break` means exit from this lambda;
# *   In non-lambda procs, `return` means exit from embracing method (and will
#     throw `LocalJumpError` if invoked outside the method);
# *   In non-lambda procs, `break` means exit from the method which the block
#     given for. (and will throw `LocalJumpError` if invoked after the method
#     returns);
# *   In lambdas, arguments are treated in the same way as in methods: strict,
#     with `ArgumentError` for mismatching argument number, and no additional
#     argument processing;
# *   Regular procs accept arguments more generously: missing arguments are
#     filled with `nil`, single Array arguments are deconstructed if the proc
#     has multiple arguments, and there is no error raised on extra arguments.
#
#
# Examples:
#
#     # +return+ in non-lambda proc, +b+, exits +m2+.
#     # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
#     #=> []
#
#     # +break+ in non-lambda proc, +b+, exits +m1+.
#     # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
#     #=> [:m2]
#
#     # +next+ in non-lambda proc, +b+, exits the block.
#     # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # Using +proc+ method changes the behavior as follows because
#     # The block is given for +proc+ method and embraced by +m2+.
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
#     #=> []
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
#     # break from proc-closure (LocalJumpError)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # +return+, +break+ and +next+ in the stubby lambda exits the block.
#     # (+lambda+ method behaves same.)
#     # (The block is given for stubby lambda syntax and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     p = proc {|x, y| "x=#{x}, y=#{y}" }
#     p.call(1, 2)      #=> "x=1, y=2"
#     p.call([1, 2])    #=> "x=1, y=2", array deconstructed
#     p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
#     p.call(1)         #=> "x=1, y=", nil substituted instead of error
#
#     l = lambda {|x, y| "x=#{x}, y=#{y}" }
#     l.call(1, 2)      #=> "x=1, y=2"
#     l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
#     l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
#     l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)
#
#     def test_return
#       -> { return 3 }.call      # just returns from lambda into method body
#       proc { return 4 }.call    # returns from method
#       return 5
#     end
#
#     test_return # => 4, return from proc
#
# Lambdas are useful as self-sufficient functions, in particular useful as
# arguments to higher-order functions, behaving exactly like Ruby methods.
#
# Procs are useful for implementing iterators:
#
#     def test
#       [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
#                                 #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# Inside `map`, the block of code is treated as a regular (non-lambda) proc,
# which means that the internal arrays will be deconstructed to pairs of
# arguments, and `return` will exit from the method `test`. That would not be
# possible with a stricter lambda.
#
# You can tell a lambda from a regular proc by using the #lambda? instance
# method.
#
# Lambda semantics is typically preserved during the proc lifetime, including
# `&`-deconstruction to a block of code:
#
#     p = proc {|x, y| x }
#     l = lambda {|x, y| x }
#     [[1, 2], [3, 4]].map(&p) #=> [1, 3]
#     [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)
#
# The only exception is dynamic method definition: even if defined by passing a
# non-lambda proc, methods still have normal semantics of argument checking.
#
#     class C
#       define_method(:e, &proc {})
#     end
#     C.new.e(1,2)       #=> ArgumentError
#     C.new.method(:e).to_proc.lambda?   #=> true
#
# This exception ensures that methods never have unusual argument passing
# conventions, and makes it easy to have wrappers defining methods that behave
# as usual.
#
#     class C
#       def self.def2(name, &body)
#         define_method(name, &body)
#       end
#
#       def2(:f) {}
#     end
#     C.new.f(1,2)       #=> ArgumentError
#
# The wrapper `def2` receives *body* as a non-lambda proc, yet defines a method
# which has normal semantics.
#
# ## Conversion of other objects to procs
#
# Any object that implements the `to_proc` method can be converted into a proc
# by the `&` operator, and therefore can be consumed by iterators.
#
#     class Greeter
#       def initialize(greeting)
#         @greeting = greeting
#       end
#
#       def to_proc
#         proc {|name| "#{@greeting}, #{name}!" }
#       end
#     end
#
#     hi = Greeter.new("Hi")
#     hey = Greeter.new("Hey")
#     ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
#     ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]
#
# Of the Ruby core classes, this method is implemented by Symbol, Method, and
# Hash.
#
#     :to_s.to_proc.call(1)           #=> "1"
#     [1, 2].map(&:to_s)              #=> ["1", "2"]
#
#     method(:puts).to_proc.call(1)   # prints 1
#     [1, 2].each(&method(:puts))     # prints 1, 2
#
#     {test: 1}.to_proc.call(:test)       #=> 1
#     %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]
#
# ## Orphaned Proc
#
# `return` and `break` in a block exit a method. If a Proc object is generated
# from the block and the Proc object survives until the method is returned,
# `return` and `break` cannot work. In such case, `return` and `break` raises
# LocalJumpError. A Proc object in such situation is called as orphaned Proc
# object.
#
# Note that the method to exit is different for `return` and `break`. There is a
# situation that orphaned for `break` but not orphaned for `return`.
#
#     def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
#     def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok
#
#     def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
#     def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError
#
#     def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
#     def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError
#
# Since `return` and `break` exits the block itself in lambdas, lambdas cannot
# be orphaned.
#
# ## Numbered parameters
#
# Numbered parameters are implicitly defined block parameters intended to
# simplify writing short blocks:
#
#     # Explicit parameter:
#     %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]
#
#     # Implicit parameter:
#     %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]
#
# Parameter names from `_1` to `_9` are supported:
#
#     [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
#     # => [120, 150, 180]
#
# Though, it is advised to resort to them wisely, probably limiting yourself to
# `_1` and `_2`, and to one-line blocks.
#
# Numbered parameters can't be used together with explicitly named ones:
#
#     [10, 20, 30].map { |x| _1**2 }
#     # SyntaxError (ordinary parameter is defined)
#
# To avoid conflicts, naming local variables or method arguments `_1`, `_2` and
# so on, causes a warning.
#
#     _1 = 'test'
#     # warning: `_1' is reserved as numbered parameter
#
# Using implicit numbered parameters affects block's arity:
#
#     p = proc { _1 + _2 }
#     l = lambda { _1 + _2 }
#     p.parameters     # => [[:opt, :_1], [:opt, :_2]]
#     p.arity          # => 2
#     l.parameters     # => [[:req, :_1], [:req, :_2]]
#     l.arity          # => 2
#
# Blocks with numbered parameters can't be nested:
#
#     %w[test me].each { _1.each_char { p _1 } }
#     # SyntaxError (numbered parameter is already used in outer block here)
#     # %w[test me].each { _1.each_char { p _1 } }
#     #                    ^~
#
# Numbered parameters were introduced in Ruby 2.7.
#
class Proc < Object
  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - prc.arity -> integer
  # -->
  # Returns the number of mandatory arguments. If the block is declared to take no
  # arguments, returns 0. If the block is known to take exactly n arguments,
  # returns n. If the block has optional arguments, returns -n-1, where n is the
  # number of mandatory arguments, with the exception for blocks that are not
  # lambdas and have only a finite number of optional arguments; in this latter
  # case, returns n. Keyword arguments will be considered as a single additional
  # argument, that argument being mandatory if any keyword argument is mandatory.
  # A #proc with no argument declarations is the same as a block declaring `||` as
  # its arguments.
  #
  #     proc {}.arity                  #=>  0
  #     proc { || }.arity              #=>  0
  #     proc { |a| }.arity             #=>  1
  #     proc { |a, b| }.arity          #=>  2
  #     proc { |a, b, c| }.arity       #=>  3
  #     proc { |*a| }.arity            #=> -1
  #     proc { |a, *b| }.arity         #=> -2
  #     proc { |a, *b, c| }.arity      #=> -3
  #     proc { |x:, y:, z:0| }.arity   #=>  1
  #     proc { |*a, x:, y:0| }.arity   #=> -2
  #
  #     proc   { |a=0| }.arity         #=>  0
  #     lambda { |a=0| }.arity         #=> -1
  #     proc   { |a=0, b| }.arity      #=>  1
  #     lambda { |a=0, b| }.arity      #=> -2
  #     proc   { |a=0, b=0| }.arity    #=>  0
  #     lambda { |a=0, b=0| }.arity    #=> -1
  #     proc   { |a, b=0| }.arity      #=>  1
  #     lambda { |a, b=0| }.arity      #=> -2
  #     proc   { |(a, b), c=0| }.arity #=>  1
  #     lambda { |(a, b), c=0| }.arity #=> -2
  #     proc   { |a, x:0, y:0| }.arity #=>  1
  #     lambda { |a, x:0, y:0| }.arity #=> -2
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - prc.binding    -> binding
  # -->
  # Returns the binding associated with *prc*.
  #
  #     def fred(param)
  #       proc {}
  #     end
  #
  #     b = fred(99)
  #     eval("param", b.binding)   #=> 99
  #
  def binding: () -> Binding

  # <!--
  #   rdoc-file=proc.c
  #   - prc.call(params,...)   -> obj
  #   - prc[params,...]        -> obj
  #   - prc.(params,...)       -> obj
  #   - prc.yield(params,...)  -> obj
  # -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  def call: (*untyped arg0) -> untyped

  # <!-- rdoc-file=proc.c -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  def []: (*untyped arg0) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - prc.curry         -> a_proc
  #   - prc.curry(arity)  -> a_proc
  # -->
  # Returns a curried proc. If the optional *arity* argument is given, it
  # determines the number of arguments. A curried proc receives some arguments. If
  # a sufficient number of arguments are supplied, it passes the supplied
  # arguments to the original proc and returns the result. Otherwise, returns
  # another curried proc that takes the rest of arguments.
  #
  #     b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 6
  #     p b.curry(5)[1][2][3][4][5]  #=> 6
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 6
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> wrong number of arguments (given 4, expected 3)
  #     p b.curry(5)                 #=> wrong number of arguments (given 5, expected 3)
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = proc { :foo }
  #     p b.curry[]                  #=> :foo
  #
  def curry: (?_ToInt arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - prc.hash   ->  integer
  # -->
  # Returns a hash value corresponding to proc body.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - Proc.new {|...| block } -> a_proc
  # -->
  # Creates a new Proc object, bound to the current context.
  #
  #     proc = Proc.new { "hello" }
  #     proc.call   #=> "hello"
  #
  # Raises ArgumentError if called without a block.
  #
  #     Proc.new    #=> ArgumentError
  #
  def initialize: () { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=proc.c
  #   - prc.lambda? -> true or false
  # -->
  # Returns `true` if a Proc object is lambda. `false` if non-lambda.
  #
  # The lambda-ness affects argument handling and the behavior of `return` and
  # `break`.
  #
  # A Proc object generated by `proc` ignores extra arguments.
  #
  #     proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]
  #
  # It provides `nil` for missing arguments.
  #
  #     proc {|a,b| [a,b] }.call(1)        #=> [1,nil]
  #
  # It expands a single array argument.
  #
  #     proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]
  #
  # A Proc object generated by `lambda` doesn't have such tricks.
  #
  #     lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError
  #
  # Proc#lambda? is a predicate for the tricks. It returns `true` if no tricks
  # apply.
  #
  #     lambda {}.lambda?            #=> true
  #     proc {}.lambda?              #=> false
  #
  # Proc.new is the same as `proc`.
  #
  #     Proc.new {}.lambda?          #=> false
  #
  # `lambda`, `proc` and Proc.new preserve the tricks of a Proc object given by
  # `&` argument.
  #
  #     lambda(&lambda {}).lambda?   #=> true
  #     proc(&lambda {}).lambda?     #=> true
  #     Proc.new(&lambda {}).lambda? #=> true
  #
  #     lambda(&proc {}).lambda?     #=> false
  #     proc(&proc {}).lambda?       #=> false
  #     Proc.new(&proc {}).lambda?   #=> false
  #
  # A Proc object generated by `&` argument has the tricks
  #
  #     def n(&b) b.lambda? end
  #     n {}                         #=> false
  #
  # The `&` argument preserves the tricks if a Proc object is given by `&`
  # argument.
  #
  #     n(&lambda {})                #=> true
  #     n(&proc {})                  #=> false
  #     n(&Proc.new {})              #=> false
  #
  # A Proc object converted from a method has no tricks.
  #
  #     def m() end
  #     method(:m).to_proc.lambda?   #=> true
  #
  #     n(&method(:m))               #=> true
  #     n(&method(:m).to_proc)       #=> true
  #
  # `define_method` is treated the same as method definition. The defined method
  # has no tricks.
  #
  #     class C
  #       define_method(:d) {}
  #     end
  #     C.new.d(1,2)       #=> ArgumentError
  #     C.new.method(:d).to_proc.lambda?   #=> true
  #
  # `define_method` always defines a method without the tricks, even if a
  # non-lambda Proc object is given. This is the only exception for which the
  # tricks are not preserved.
  #
  #     class C
  #       define_method(:e, &proc {})
  #     end
  #     C.new.e(1,2)       #=> ArgumentError
  #     C.new.method(:e).to_proc.lambda?   #=> true
  #
  # This exception ensures that methods never have tricks and makes it easy to
  # have wrappers to define methods that behave as usual.
  #
  #     class C
  #       def self.def2(name, &body)
  #         define_method(name, &body)
  #       end
  #
  #       def2(:f) {}
  #     end
  #     C.new.f(1,2)       #=> ArgumentError
  #
  # The wrapper *def2* defines a method which has no tricks.
  #
  def lambda?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - prc.parameters  -> array
  # -->
  # Returns the parameter information of this proc.
  #
  #     prc = lambda{|x, y=42, *other|}
  #     prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]
  #
  def parameters: () -> ::Array[[ Symbol, Symbol ]]

  # <!--
  #   rdoc-file=proc.c
  #   - prc.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this proc or `nil`
  # if this proc was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_proc -> proc
  # -->
  # Part of the protocol for converting objects to Proc objects. Instances of
  # class Proc simply return themselves.
  #
  def to_proc: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_s   -> string
  # -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  def to_s: () -> String

  # <!-- rdoc-file=proc.c -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  def inspect: () -> String
end

# <!-- rdoc-file=object.c -->
# The Kernel module is included by class Object, so its methods are available in
# every Ruby object.
#
# The Kernel instance methods are documented in class Object while the module
# methods are documented here.  These methods are called without a receiver and
# thus can be called in functional form:
#
#     sprintf "%.1f", 1.234 #=> "1.2"
#
# ## What's Here
#
# Module Kernel provides methods that are useful for:
#
# *   [Converting](#module-Kernel-label-Converting)
# *   [Querying](#module-Kernel-label-Querying)
# *   [Exiting](#module-Kernel-label-Exiting)
# *   [Exceptions](#module-Kernel-label-Exceptions)
# *   [IO](#module-Kernel-label-IO)
# *   [Procs](#module-Kernel-label-Procs)
# *   [Tracing](#module-Kernel-label-Tracing)
# *   [Subprocesses](#module-Kernel-label-Subprocesses)
# *   [Loading](#module-Kernel-label-Loading)
# *   [Yielding](#module-Kernel-label-Yielding)
# *   [Random Values](#module-Kernel-label-Random+Values)
# *   [Other](#module-Kernel-label-Other)
#
#
# ### Converting
#
#     [#Array](#method-i-Array)
# :       Returns an Array based on the given argument.
#
#     [#Complex](#method-i-Complex)
# :       Returns a Complex based on the given arguments.
#
#     [#Float](#method-i-Float)
# :       Returns a Float based on the given arguments.
#
#     [#Hash](#method-i-Hash)
# :       Returns a Hash based on the given argument.
#
#     [#Integer](#method-i-Integer)
# :       Returns an Integer based on the given arguments.
#
#     [#Rational](#method-i-Rational)
# :       Returns a Rational based on the given arguments.
#
#     [#String](#method-i-String)
# :       Returns a String based on the given argument.
#
#
#
# ### Querying
#
#     [#__callee__](#method-i-__callee__)
# :       Returns the called name of the current method as a symbol.
#
#     [#__dir__](#method-i-__dir__)
# :       Returns the path to the directory from which the current method is
#         called.
#
#     [#__method__](#method-i-__method__)
# :       Returns the name of the current method as a symbol.
#
#     #autoload?
# :       Returns the file to be loaded when the given module is referenced.
#
#     #binding
# :       Returns a Binding for the context at the point of call.
#
#     #block_given?
# :       Returns `true` if a block was passed to the calling method.
#
#     #caller
# :       Returns the current execution stack as an array of strings.
#
#     #caller_locations
# :       Returns the current execution stack as an array of
#         Thread::Backtrace::Location objects.
#
#     #class
# :       Returns the class of `self`.
#
#     #frozen?
# :       Returns whether `self` is frozen.
#
#     #global_variables
# :       Returns an array of global variables as symbols.
#
#     #local_variables
# :       Returns an array of local variables as symbols.
#
#     #test
# :       Performs specified tests on the given single file or pair of files.
#
#
#
# ### Exiting
#
#     #abort
# :       Exits the current process after printing the given arguments.
#
#     #at_exit
# :       Executes the given block when the process exits.
#
#     #exit
# :       Exits the current process after calling any registered `at_exit`
#         handlers.
#
#     #exit!
# :       Exits the current process without calling any registered `at_exit`
#         handlers.
#
#
#
# ### Exceptions
#
#     #catch
# :       Executes the given block, possibly catching a thrown object.
#
#     #raise (aliased as #fail)
# :       Raises an exception based on the given arguments.
#
#     #throw
# :       Returns from the active catch block waiting for the given tag.
#
#
#
# ### IO
#
#     #gets
# :       Returns and assigns to `$_` the next line from the current input.
#
#     #open
# :       Creates an IO object connected to the given stream, file, or
#         subprocess.
#
#     #p
# :       Prints the given objects' inspect output to the standard output.
#
#     #pp
# :       Prints the given objects in pretty form.
#
#     #print
# :       Prints the given objects to standard output without a newline.
#
#     #printf
# :       Prints the string resulting from applying the given format string to
#         any additional arguments.
#
#     #putc
# :       Equivalent to <tt.$stdout.putc(object)</tt> for the given object.
#
#     #puts
# :       Equivalent to `$stdout.puts(*objects)` for the given objects.
#
#     #readline
# :       Similar to #gets, but raises an exception at the end of file.
#
#     #readlines
# :       Returns an array of the remaining lines from the current input.
#
#     #select
# :       Same as IO.select.
#
#
#
# ### Procs
#
#     #lambda
# :       Returns a lambda proc for the given block.
#
#     #proc
# :       Returns a new Proc; equivalent to Proc.new.
#
#
#
# ### Tracing
#
#     #set_trace_func
# :       Sets the given proc as the handler for tracing, or disables tracing if
#         given `nil`.
#
#     #trace_var
# :       Starts tracing assignments to the given global variable.
#
#     #untrace_var
# :       Disables tracing of assignments to the given global variable.
#
#
#
# ### Subprocesses
#
#     #`cmd`
# :       Returns the standard output of running `cmd` in a subshell.
#
#     #exec
# :       Replaces current process with a new process.
#
#     #fork
# :       Forks the current process into two processes.
#
#     #spawn
# :       Executes the given command and returns its pid without waiting for
#         completion.
#
#     #system
# :       Executes the given command in a subshell.
#
#
#
# ### Loading
#
#     #autoload
# :       Registers the given file to be loaded when the given constant is first
#         referenced.
#
#     #load
# :       Loads the given Ruby file.
#
#     #require
# :       Loads the given Ruby file unless it has already been loaded.
#
#     #require_relative
# :       Loads the Ruby file path relative to the calling file, unless it has
#         already been loaded.
#
#
#
# ### Yielding
#
#     #tap
# :       Yields `self` to the given block; returns `self`.
#
#     #then (aliased as #yield_self)
# :       Yields `self` to the block and returns the result of the block.
#
#
#
# ### Random Values
#
#     #rand
# :       Returns a pseudo-random floating point number strictly between 0.0 and
#         1.0.
#
#     #srand
# :       Seeds the pseudo-random number generator with the given number.
#
#
#
# ### Other
#
#     #eval
# :       Evaluates the given string as Ruby code.
#
#     #loop
# :       Repeatedly executes the given block.
#
#     #sleep
# :       Suspends the current thread for the given number of seconds.
#
#     #sprintf (aliased as #format)
# :       Returns the string resulting from applying the given format string to
#         any additional arguments.
#
#     #syscall
# :       Runs an operating system call.
#
#     #trap
# :       Specifies the handling of system signals.
#
#     #warn
# :       Issue a warning based on the given messages and options.
#
%a{annotate:rdoc:source:from=object.c}
module Kernel : BasicObject
  private

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller(start=1, length=nil)  -> array or nil
  #   - caller(range)                -> array or nil
  # -->
  # Returns the current execution stack---an array containing strings in the form
  # `file:line` or `file:line: in `method'`.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  #     def a(skip)
  #       caller(skip)
  #     end
  #     def b(skip)
  #       a(skip)
  #     end
  #     def c(skip)
  #       b(skip)
  #     end
  #     c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
  #     c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
  #     c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
  #     c(3)   #=> ["prog:13:in `<main>'"]
  #     c(4)   #=> []
  #     c(5)   #=> nil
  #
  def self?.caller: (Integer start_or_range, ?Integer length) -> ::Array[String]?
                  | (::Range[Integer] start_or_range) -> ::Array[String]?
                  | () -> ::Array[String]

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller_locations(start=1, length=nil)    -> array or nil
  #   - caller_locations(range)                  -> array or nil
  # -->
  # Returns the current execution stack---an array containing backtrace location
  # objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  def self?.caller_locations: (?Integer start_or_range, ?Integer length) -> ::Array[Thread::Backtrace::Location]?
                            | (?::Range[Integer] start_or_range) -> ::Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=vm_eval.c
  #   - catch([tag]) {|tag| block }  -> obj
  # -->
  # `catch` executes its block. If `throw` is not called, the block executes
  # normally, and `catch` returns the value of the last expression evaluated.
  #
  #     catch(1) { 123 }            # => 123
  #
  # If `throw(tag2, val)` is called, Ruby searches up its stack for a `catch`
  # block whose `tag` has the same `object_id` as *tag2*. When found, the block
  # stops executing and returns *val* (or `nil` if no second argument was given to
  # `throw`).
  #
  #     catch(1) { throw(1, 456) }  # => 456
  #     catch(1) { throw(1) }       # => nil
  #
  # When `tag` is passed as the first argument, `catch` yields it as the parameter
  # of the block.
  #
  #     catch(1) {|x| x + 2 }       # => 3
  #
  # When no `tag` is given, `catch` yields a new unique object (as from
  # `Object.new`) as the block parameter. This object can then be used as the
  # argument to `throw`, and will match the correct `catch` block.
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_B, 123)
  #         puts "This puts is not reached"
  #       end
  #
  #       puts "This puts is displayed"
  #       456
  #     end
  #
  #     # => 456
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_A, 123)
  #         puts "This puts is still not reached"
  #       end
  #
  #       puts "Now this puts is also not reached"
  #       456
  #     end
  #
  #     # => 123
  #
  def self?.catch: [T] (T tag) { (T tag) -> untyped } -> untyped
                 | () { (Object tag) -> untyped } -> untyped

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.class    -> class
  # -->
  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as #class is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - eval(string [, binding [, filename [,lineno]]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*. If *binding* is given, which
  # must be a Binding object, the evaluation is performed in its context. If the
  # optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(str)
  #       return binding
  #     end
  #     str = "hello"
  #     eval "str + ' Fred'"                      #=> "hello Fred"
  #     eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
  #
  def self?.eval: (String arg0, ?Binding arg1, ?String filename, ?Integer lineno) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - block_given?   -> true or false
  # -->
  # Returns `true` if `yield` would execute a block in the current context. The
  # `iterator?` form is mildly deprecated.
  #
  #     def try
  #       if block_given?
  #         yield
  #       else
  #         "no block"
  #       end
  #     end
  #     try                  #=> "no block"
  #     try { "hello" }      #=> "hello"
  #     try do "hello" end   #=> "hello"
  #
  def self?.block_given?: () -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - local_variables    -> array
  # -->
  # Returns the names of the current local variables.
  #
  #     fred = 1
  #     for i in 1..10
  #        # ...
  #     end
  #     local_variables   #=> [:fred, :i]
  #
  def self?.local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self?.srand: (?Numeric number) -> Numeric

  # <!--
  #   rdoc-file=process.c
  #   - Kernel.fork  [{ block }]   -> integer or nil
  #   - Process.fork [{ block }]   -> integer or nil
  # -->
  # Creates a subprocess. If a block is specified, that block is run in the
  # subprocess, and the subprocess terminates with a status of zero. Otherwise,
  # the `fork` call returns twice, once in the parent, returning the process ID of
  # the child, and once in the child, returning *nil*. The child process can exit
  # using Kernel.exit! to avoid running any `at_exit` functions. The parent
  # process should use Process.wait to collect the termination statuses of its
  # children or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # The thread calling fork is the only thread in the created child process. fork
  # doesn't copy other threads.
  #
  # If fork is not usable, Process.respond_to?(:fork) returns false.
  #
  # Note that fork(2) is not available on some platforms like Windows and NetBSD
  # 4. Therefore you should use spawn() instead of fork().
  #
  def self?.fork: () -> Integer?
                | () { () -> untyped } -> Integer?

  def initialize_copy: (self object) -> self

  # <!--
  #   rdoc-file=object.c
  #   - Array(arg)    -> array
  # -->
  # Returns `arg` as an Array.
  #
  # First tries to call `to_ary` on `arg`, then `to_a`. If `arg` does not respond
  # to `to_ary` or `to_a`, returns an Array of length 1 containing `arg`.
  #
  # If `to_ary` or `to_a` returns something other than an Array, raises a
  # TypeError.
  #
  #     Array(["a", "b"])  #=> ["a", "b"]
  #     Array(1..5)        #=> [1, 2, 3, 4, 5]
  #     Array(key: :value) #=> [[:key, :value]]
  #     Array(nil)         #=> []
  #     Array(1)           #=> [1]
  #
  def self?.Array: (NilClass x) -> [ ]
                 | [T] (::Array[T] x) -> ::Array[T]
                 | [T] (::Range[T] x) -> ::Array[T]
                 | [T] (_Each[T] x) -> ::Array[T]
                 | [K, V] (::Hash[K, V] x) -> ::Array[[ K, V ]]
                 | [T] (T x) -> ::Array[T]

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(x[, y], exception: true)  ->  numeric or nil
  # -->
  # Returns x+i*y;
  #
  #     Complex(1, 2)    #=> (1+2i)
  #     Complex('1+2i')  #=> (1+2i)
  #     Complex(nil)     #=> TypeError
  #     Complex(1, nil)  #=> TypeError
  #
  #     Complex(1, nil, exception: false)  #=> nil
  #     Complex('1+2', exception: false)   #=> nil
  #
  # Syntax of string form:
  #
  #     string form = extra spaces , complex , extra spaces ;
  #     complex = real part | [ sign ] , imaginary part
  #             | real part , sign , imaginary part
  #             | rational , "@" , rational ;
  #     real part = rational ;
  #     imaginary part = imaginary unit | unsigned rational , imaginary unit ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     imaginary unit = "i" | "I" | "j" | "J" ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit };
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See String#to_c.
  #
  def self?.Complex: (Numeric | String x, ?Numeric | String y, ?exception: bool exception) -> Complex

  # <!--
  #   rdoc-file=kernel.rb
  #   - Float(arg, exception: true)    -> float or nil
  # -->
  # Returns *arg* converted to a float. Numeric types are converted directly, and
  # with exception to String and `nil` the rest are converted using *arg*`.to_f`.
  # Converting a String with invalid characters will result in a ArgumentError.
  # Converting `nil` generates a TypeError.  Exceptions can be suppressed by
  # passing `exception: false`.
  #
  #     Float(1)                 #=> 1.0
  #     Float("123.456")         #=> 123.456
  #     Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
  #     Float(nil)               #=> TypeError: can't convert nil into Float
  #     Float("123.0_badstring", exception: false)  #=> nil
  #
  def self?.Float: (Numeric | String x, ?exception: bool exception) -> Float

  # <!--
  #   rdoc-file=object.c
  #   - Hash(arg)    -> hash
  # -->
  # Converts *arg* to a Hash by calling *arg*`.to_hash`. Returns an empty Hash
  # when *arg* is `nil` or `[]`.
  #
  #     Hash([])          #=> {}
  #     Hash(nil)         #=> {}
  #     Hash(key: :value) #=> {:key => :value}
  #     Hash([1, 2, 3])   #=> TypeError
  #
  def self?.Hash: [K, V] (Object x) -> ::Hash[K, V]

  # <!--
  #   rdoc-file=object.c
  #   - Integer(arg, base=0, exception: true)    -> integer or nil
  # -->
  # Converts *arg* to an Integer. Numeric types are converted directly (with
  # floating point numbers being truncated).  *base* (0, or between 2 and 36) is a
  # base for integer string representation.  If *arg* is a String, when *base* is
  # omitted or equals zero, radix indicators (`0`, `0b`, and `0x`) are honored. In
  # any case, strings should consist only of one or more digits, except for that a
  # sign, one underscore between two digits, and leading/trailing spaces are
  # optional.  This behavior is different from that of String#to_i.  Non string
  # values will be converted by first trying `to_int`, then `to_i`.
  #
  # Passing `nil` raises a TypeError, while passing a String that does not conform
  # with numeric representation raises an ArgumentError. This behavior can be
  # altered by passing `exception: false`, in this case a not convertible value
  # will return `nil`.
  #
  #     Integer(123.999)    #=> 123
  #     Integer("0x1a")     #=> 26
  #     Integer(Time.new)   #=> 1204973019
  #     Integer("0930", 10) #=> 930
  #     Integer("111", 2)   #=> 7
  #     Integer(" +1_0 ")   #=> 10
  #     Integer(nil)        #=> TypeError: can't convert nil into Integer
  #     Integer("x")        #=> ArgumentError: invalid value for Integer(): "x"
  #
  #     Integer("x", exception: false)        #=> nil
  #
  def self?.Integer: (Numeric | String arg, ?exception: bool exception) -> Integer
                   | (String arg, ?Integer base, ?exception: bool exception) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - Rational(x, y, exception: true)  ->  rational or nil
  #   - Rational(arg, exception: true)   ->  rational or nil
  # -->
  # Returns `x/y` or `arg` as a Rational.
  #
  #     Rational(2, 3)   #=> (2/3)
  #     Rational(5)      #=> (5/1)
  #     Rational(0.5)    #=> (1/2)
  #     Rational(0.3)    #=> (5404319552844595/18014398509481984)
  #
  #     Rational("2/3")  #=> (2/3)
  #     Rational("0.3")  #=> (3/10)
  #
  #     Rational("10 cents")  #=> ArgumentError
  #     Rational(nil)         #=> TypeError
  #     Rational(1, nil)      #=> TypeError
  #
  #     Rational("10 cents", exception: false)  #=> nil
  #
  # Syntax of the string form:
  #
  #     string form = extra spaces , rational , extra spaces ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit } ;
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See also String#to_r.
  #
  def self?.Rational: (Numeric | String | Object x, ?Numeric | String y, ?exception: bool exception) -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - String(arg)   -> string
  # -->
  # Returns *arg* as a String.
  #
  # First tries to call its `to_str` method, then its `to_s` method.
  #
  #     String(self)        #=> "main"
  #     String(self.class)  #=> "Object"
  #     String(123456)      #=> "123456"
  #
  def self?.String: (_ToStr | _ToS x) -> String

  # <!--
  #   rdoc-file=eval.c
  #   - __callee__         -> symbol
  # -->
  # Returns the called name of the current method as a Symbol. If called outside
  # of a method, it returns `nil`.
  #
  def self?.__callee__: () -> Symbol?

  # <!--
  #   rdoc-file=eval.c
  #   - __dir__         -> string
  # -->
  # Returns the canonicalized absolute path of the directory of the file from
  # which this method is called. It means symlinks in the path is resolved. If
  # `__FILE__` is `nil`, it returns `nil`. The return value equals to
  # `File.dirname(File.realpath(__FILE__))`.
  #
  def self?.__dir__: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - __method__         -> symbol
  # -->
  # Returns the name at the definition of the current method as a Symbol. If
  # called outside of a method, it returns `nil`.
  #
  def self?.__method__: () -> Symbol?

  # <!--
  #   rdoc-file=io.c
  #   - `cmd`    -> string
  # -->
  # Returns the standard output of running *cmd* in a subshell. The built-in
  # syntax `%x{...}` uses this method. Sets `$?` to the process status.
  #
  #     `date`                   #=> "Wed Apr  9 08:56:30 CDT 2003\n"
  #     `ls testdir`.split[1]    #=> "main.rb"
  #     `echo oops && exit 99`   #=> "oops\n"
  #     $?.exitstatus            #=> 99
  #
  def self?.`: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - abort
  #   - Kernel::abort([msg])
  #   - Process.abort([msg])
  # -->
  # Terminate execution immediately, effectively by calling `Kernel.exit(false)`.
  # If *msg* is given, it is written to STDERR prior to terminating.
  #
  def self?.abort: (?String msg) -> bot

  # <!--
  #   rdoc-file=eval_jump.c
  #   - at_exit { block } -> proc
  # -->
  # Converts *block* to a `Proc` object (and therefore binds it at the point of
  # call) and registers it for execution when the program exits. If multiple
  # handlers are registered, they are executed in reverse order of registration.
  #
  #     def do_at_exit(str1)
  #       at_exit { print str1 }
  #     end
  #     at_exit { puts "cruel world" }
  #     do_at_exit("goodbye ")
  #     exit
  #
  # *produces:*
  #
  #     goodbye cruel world
  #
  def self?.at_exit: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=load.c
  #   - autoload(module, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *module* (which may be a String or a symbol) is accessed.
  #
  #     autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")
  #
  def self?.autoload: (String | Symbol _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload`.
  #
  #     autoload(:B, "b")
  #     autoload?(:B)            #=> "b"
  #
  def self?.autoload?: (Symbol | String name) -> String?

  # <!--
  #   rdoc-file=proc.c
  #   - binding -> a_binding
  # -->
  # Returns a `Binding` object, describing the variable and method bindings at the
  # point of call. This object can be used when calling `eval` to execute the
  # evaluated command in this environment. See also the description of class
  # `Binding`.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     eval("param", b)   #=> "hello"
  #
  def self?.binding: () -> Binding

  # <!--
  #   rdoc-file=process.c
  #   - exit(status=true)
  #   - Kernel::exit(status=true)
  #   - Process::exit(status=true)
  # -->
  # Initiates the termination of the Ruby script by raising the SystemExit
  # exception. This exception may be caught. The optional parameter is used to
  # return a status code to the invoking environment. `true` and `FALSE` of
  # *status* means success and failure respectively.  The interpretation of other
  # integer values are system dependent.
  #
  #     begin
  #       exit
  #       puts "never get here"
  #     rescue SystemExit
  #       puts "rescued a SystemExit exception"
  #     end
  #     puts "after begin block"
  #
  # *produces:*
  #
  #     rescued a SystemExit exception
  #     after begin block
  #
  # Just prior to termination, Ruby executes any `at_exit` functions (see
  # Kernel::at_exit) and runs any object finalizers (see
  # ObjectSpace::define_finalizer).
  #
  #     at_exit { puts "at_exit function" }
  #     ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
  #     exit
  #
  # *produces:*
  #
  #     at_exit function
  #     in finalizer
  #
  def self?.exit: () -> bot
                | (?Integer | TrueClass | FalseClass status) -> bot

  # <!--
  #   rdoc-file=process.c
  #   - Process.exit!(status=false)
  # -->
  # Exits the process immediately. No exit handlers are run. *status* is returned
  # to the underlying system as the exit status.
  #
  #     Process.exit!(true)
  #
  def self?.exit!: (Integer | TrueClass | FalseClass status) -> bot

  # <!-- rdoc-file=eval.c -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  def self?.fail: () -> bot
                | (String arg0) -> bot
                | (_Exception arg0, ?untyped arg1, ?::Array[String] arg2) -> bot

  # <!--
  #   rdoc-file=eval.c
  #   - raise
  #   - raise(string, cause: $!)
  #   - raise(exception [, string [, array]], cause: $!)
  #   - fail
  #   - fail(string, cause: $!)
  #   - fail(exception [, string [, array]], cause: $!)
  # -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  alias raise fail

  alias self.raise self.fail

  # <!-- rdoc-file=object.c -->
  # Returns the string resulting from applying *format_string* to any additional
  # arguments.  Within the format string, any characters other than format
  # sequences are copied to the result.
  #
  # The syntax of a format sequence is as follows.
  #
  #     %[flags][width][.precision]type
  #
  # A format sequence consists of a percent sign, followed by optional flags,
  # width, and precision indicators, then terminated with a field type character.
  # The field type controls how the corresponding `sprintf` argument is to be
  # interpreted, while the flags modify that interpretation.
  #
  # The field type characters are:
  #
  #     Field |  Integer Format
  #     ------+--------------------------------------------------------------
  #       b   | Convert argument as a binary number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..1'.
  #       B   | Equivalent to `b', but uses an uppercase 0B for prefix
  #           | in the alternative format by #.
  #       d   | Convert argument as a decimal number.
  #       i   | Identical to `d'.
  #       o   | Convert argument as an octal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..7'.
  #       u   | Identical to `d'.
  #       x   | Convert argument as a hexadecimal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..f' (representing an infinite string of
  #           | leading 'ff's).
  #       X   | Equivalent to `x', but uses uppercase letters.
  #
  #     Field |  Float Format
  #     ------+--------------------------------------------------------------
  #       e   | Convert floating point argument into exponential notation
  #           | with one digit before the decimal point as [-]d.dddddde[+-]dd.
  #           | The precision specifies the number of digits after the decimal
  #           | point (defaulting to six).
  #       E   | Equivalent to `e', but uses an uppercase E to indicate
  #           | the exponent.
  #       f   | Convert floating point argument as [-]ddd.dddddd,
  #           | where the precision specifies the number of digits after
  #           | the decimal point.
  #       g   | Convert a floating point number using exponential form
  #           | if the exponent is less than -4 or greater than or
  #           | equal to the precision, or in dd.dddd form otherwise.
  #           | The precision specifies the number of significant digits.
  #       G   | Equivalent to `g', but use an uppercase `E' in exponent form.
  #       a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
  #           | which is consisted from optional sign, "0x", fraction part
  #           | as hexadecimal, "p", and exponential part as decimal.
  #       A   | Equivalent to `a', but use uppercase `X' and `P'.
  #
  #     Field |  Other Format
  #     ------+--------------------------------------------------------------
  #       c   | Argument is the numeric code for a single character or
  #           | a single character string itself.
  #       p   | The valuing of argument.inspect.
  #       s   | Argument is a string to be substituted.  If the format
  #           | sequence contains a precision, at most that many characters
  #           | will be copied.
  #       %   | A percent sign itself will be displayed.  No argument taken.
  #
  # The flags modifies the behavior of the formats. The flag characters are:
  #
  #     Flag     | Applies to    | Meaning
  #     ---------+---------------+-----------------------------------------
  #     space    | bBdiouxX      | Leave a space at the start of
  #              | aAeEfgG       | non-negative numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     (digit)$ | all           | Specifies the absolute argument number
  #              |               | for this field.  Absolute and relative
  #              |               | argument numbers cannot be mixed in a
  #              |               | sprintf string.
  #     ---------+---------------+-----------------------------------------
  #      #       | bBoxX         | Use an alternative format.
  #              | aAeEfgG       | For the conversions `o', increase the precision
  #              |               | until the first digit will be `0' if
  #              |               | it is not formatted as complements.
  #              |               | For the conversions `x', `X', `b' and `B'
  #              |               | on non-zero, prefix the result with ``0x'',
  #              |               | ``0X'', ``0b'' and ``0B'', respectively.
  #              |               | For `a', `A', `e', `E', `f', `g', and 'G',
  #              |               | force a decimal point to be added,
  #              |               | even if no digits follow.
  #              |               | For `g' and 'G', do not remove trailing zeros.
  #     ---------+---------------+-----------------------------------------
  #     +        | bBdiouxX      | Add a leading plus sign to non-negative
  #              | aAeEfgG       | numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     -        | all           | Left-justify the result of this conversion.
  #     ---------+---------------+-----------------------------------------
  #     0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
  #              | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
  #              | (numeric fmt) | is used for negative numbers formatted as
  #              |               | complements.
  #     ---------+---------------+-----------------------------------------
  #     *        | all           | Use the next argument as the field width.
  #              |               | If negative, left-justify the result. If the
  #              |               | asterisk is followed by a number and a dollar
  #              |               | sign, use the indicated argument as the width.
  #
  # Examples of flags:
  #
  #     # `+' and space flag specifies the sign of non-negative numbers.
  #     sprintf("%d", 123)  #=> "123"
  #     sprintf("%+d", 123) #=> "+123"
  #     sprintf("% d", 123) #=> " 123"
  #
  #     # `#' flag for `o' increases number of digits to show `0'.
  #     # `+' and space flag changes format of negative numbers.
  #     sprintf("%o", 123)   #=> "173"
  #     sprintf("%#o", 123)  #=> "0173"
  #     sprintf("%+o", -123) #=> "-173"
  #     sprintf("%o", -123)  #=> "..7605"
  #     sprintf("%#o", -123) #=> "..7605"
  #
  #     # `#' flag for `x' add a prefix `0x' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%x", 123)   #=> "7b"
  #     sprintf("%#x", 123)  #=> "0x7b"
  #     sprintf("%+x", -123) #=> "-7b"
  #     sprintf("%x", -123)  #=> "..f85"
  #     sprintf("%#x", -123) #=> "0x..f85"
  #     sprintf("%#x", 0)    #=> "0"
  #
  #     # `#' for `X' uses the prefix `0X'.
  #     sprintf("%X", 123)  #=> "7B"
  #     sprintf("%#X", 123) #=> "0X7B"
  #
  #     # `#' flag for `b' add a prefix `0b' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%b", 123)   #=> "1111011"
  #     sprintf("%#b", 123)  #=> "0b1111011"
  #     sprintf("%+b", -123) #=> "-1111011"
  #     sprintf("%b", -123)  #=> "..10000101"
  #     sprintf("%#b", -123) #=> "0b..10000101"
  #     sprintf("%#b", 0)    #=> "0"
  #
  #     # `#' for `B' uses the prefix `0B'.
  #     sprintf("%B", 123)  #=> "1111011"
  #     sprintf("%#B", 123) #=> "0B1111011"
  #
  #     # `#' for `e' forces to show the decimal point.
  #     sprintf("%.0e", 1)  #=> "1e+00"
  #     sprintf("%#.0e", 1) #=> "1.e+00"
  #
  #     # `#' for `f' forces to show the decimal point.
  #     sprintf("%.0f", 1234)  #=> "1234"
  #     sprintf("%#.0f", 1234) #=> "1234."
  #
  #     # `#' for `g' forces to show the decimal point.
  #     # It also disables stripping lowest zeros.
  #     sprintf("%g", 123.4)   #=> "123.4"
  #     sprintf("%#g", 123.4)  #=> "123.400"
  #     sprintf("%g", 123456)  #=> "123456"
  #     sprintf("%#g", 123456) #=> "123456."
  #
  # The field width is an optional integer, followed optionally by a period and a
  # precision.  The width specifies the minimum number of characters that will be
  # written to the result for this field.
  #
  # Examples of width:
  #
  #     # padding is done by spaces,       width=20
  #     # 0 or radix-1.             <------------------>
  #     sprintf("%20d", 123)   #=> "                 123"
  #     sprintf("%+20d", 123)  #=> "                +123"
  #     sprintf("%020d", 123)  #=> "00000000000000000123"
  #     sprintf("%+020d", 123) #=> "+0000000000000000123"
  #     sprintf("% 020d", 123) #=> " 0000000000000000123"
  #     sprintf("%-20d", 123)  #=> "123                 "
  #     sprintf("%-+20d", 123) #=> "+123                "
  #     sprintf("%- 20d", 123) #=> " 123                "
  #     sprintf("%020x", -123) #=> "..ffffffffffffffff85"
  #
  # For numeric fields, the precision controls the number of decimal places
  # displayed.  For string fields, the precision determines the maximum number of
  # characters to be copied from the string.  (Thus, the format sequence `%10.10s`
  # will always contribute exactly ten characters to the result.)
  #
  # Examples of precisions:
  #
  #     # precision for `d', 'o', 'x' and 'b' is
  #     # minimum number of digits               <------>
  #     sprintf("%20.8d", 123)  #=> "            00000123"
  #     sprintf("%20.8o", 123)  #=> "            00000173"
  #     sprintf("%20.8x", 123)  #=> "            0000007b"
  #     sprintf("%20.8b", 123)  #=> "            01111011"
  #     sprintf("%20.8d", -123) #=> "           -00000123"
  #     sprintf("%20.8o", -123) #=> "            ..777605"
  #     sprintf("%20.8x", -123) #=> "            ..ffff85"
  #     sprintf("%20.8b", -11)  #=> "            ..110101"
  #
  #     # "0x" and "0b" for `#x' and `#b' is not counted for
  #     # precision but "0" for `#o' is counted.  <------>
  #     sprintf("%#20.8d", 123)  #=> "            00000123"
  #     sprintf("%#20.8o", 123)  #=> "            00000173"
  #     sprintf("%#20.8x", 123)  #=> "          0x0000007b"
  #     sprintf("%#20.8b", 123)  #=> "          0b01111011"
  #     sprintf("%#20.8d", -123) #=> "           -00000123"
  #     sprintf("%#20.8o", -123) #=> "            ..777605"
  #     sprintf("%#20.8x", -123) #=> "          0x..ffff85"
  #     sprintf("%#20.8b", -11)  #=> "          0b..110101"
  #
  #     # precision for `e' is number of
  #     # digits after the decimal point           <------>
  #     sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"
  #
  #     # precision for `f' is number of
  #     # digits after the decimal point               <------>
  #     sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"
  #
  #     # precision for `g' is number of
  #     # significant digits                          <------->
  #     sprintf("%20.8g", 1234.56789) #=> "           1234.5679"
  #
  #     #                                         <------->
  #     sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"
  #
  #     # precision for `s' is
  #     # maximum number of characters                    <------>
  #     sprintf("%20.8s", "string test") #=> "            string t"
  #
  # Examples:
  #
  #     sprintf("%d %04x", 123, 123)               #=> "123 007b"
  #     sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
  #     sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
  #     sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
  #     sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
  #     sprintf("%u", -123)                        #=> "-123"
  #
  # For more complex formatting, Ruby supports a reference by name. %<name>s style
  # uses format style, but %{name} style doesn't.
  #
  # Examples:
  #     sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
  #       #=> 1 : 2.000000
  #     sprintf("%{foo}f", { :foo => 1 })
  #       # => "1f"
  #
  def self?.format: (String format, *untyped args) -> String

  # <!--
  #   rdoc-file=object.c
  #   - format(format_string [, arguments...] )   -> string
  #   - sprintf(format_string [, arguments...] )  -> string
  # -->
  # Returns the string resulting from applying *format_string* to any additional
  # arguments.  Within the format string, any characters other than format
  # sequences are copied to the result.
  #
  # The syntax of a format sequence is as follows.
  #
  #     %[flags][width][.precision]type
  #
  # A format sequence consists of a percent sign, followed by optional flags,
  # width, and precision indicators, then terminated with a field type character.
  # The field type controls how the corresponding `sprintf` argument is to be
  # interpreted, while the flags modify that interpretation.
  #
  # The field type characters are:
  #
  #     Field |  Integer Format
  #     ------+--------------------------------------------------------------
  #       b   | Convert argument as a binary number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..1'.
  #       B   | Equivalent to `b', but uses an uppercase 0B for prefix
  #           | in the alternative format by #.
  #       d   | Convert argument as a decimal number.
  #       i   | Identical to `d'.
  #       o   | Convert argument as an octal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..7'.
  #       u   | Identical to `d'.
  #       x   | Convert argument as a hexadecimal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..f' (representing an infinite string of
  #           | leading 'ff's).
  #       X   | Equivalent to `x', but uses uppercase letters.
  #
  #     Field |  Float Format
  #     ------+--------------------------------------------------------------
  #       e   | Convert floating point argument into exponential notation
  #           | with one digit before the decimal point as [-]d.dddddde[+-]dd.
  #           | The precision specifies the number of digits after the decimal
  #           | point (defaulting to six).
  #       E   | Equivalent to `e', but uses an uppercase E to indicate
  #           | the exponent.
  #       f   | Convert floating point argument as [-]ddd.dddddd,
  #           | where the precision specifies the number of digits after
  #           | the decimal point.
  #       g   | Convert a floating point number using exponential form
  #           | if the exponent is less than -4 or greater than or
  #           | equal to the precision, or in dd.dddd form otherwise.
  #           | The precision specifies the number of significant digits.
  #       G   | Equivalent to `g', but use an uppercase `E' in exponent form.
  #       a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
  #           | which is consisted from optional sign, "0x", fraction part
  #           | as hexadecimal, "p", and exponential part as decimal.
  #       A   | Equivalent to `a', but use uppercase `X' and `P'.
  #
  #     Field |  Other Format
  #     ------+--------------------------------------------------------------
  #       c   | Argument is the numeric code for a single character or
  #           | a single character string itself.
  #       p   | The valuing of argument.inspect.
  #       s   | Argument is a string to be substituted.  If the format
  #           | sequence contains a precision, at most that many characters
  #           | will be copied.
  #       %   | A percent sign itself will be displayed.  No argument taken.
  #
  # The flags modifies the behavior of the formats. The flag characters are:
  #
  #     Flag     | Applies to    | Meaning
  #     ---------+---------------+-----------------------------------------
  #     space    | bBdiouxX      | Leave a space at the start of
  #              | aAeEfgG       | non-negative numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     (digit)$ | all           | Specifies the absolute argument number
  #              |               | for this field.  Absolute and relative
  #              |               | argument numbers cannot be mixed in a
  #              |               | sprintf string.
  #     ---------+---------------+-----------------------------------------
  #      #       | bBoxX         | Use an alternative format.
  #              | aAeEfgG       | For the conversions `o', increase the precision
  #              |               | until the first digit will be `0' if
  #              |               | it is not formatted as complements.
  #              |               | For the conversions `x', `X', `b' and `B'
  #              |               | on non-zero, prefix the result with ``0x'',
  #              |               | ``0X'', ``0b'' and ``0B'', respectively.
  #              |               | For `a', `A', `e', `E', `f', `g', and 'G',
  #              |               | force a decimal point to be added,
  #              |               | even if no digits follow.
  #              |               | For `g' and 'G', do not remove trailing zeros.
  #     ---------+---------------+-----------------------------------------
  #     +        | bBdiouxX      | Add a leading plus sign to non-negative
  #              | aAeEfgG       | numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     -        | all           | Left-justify the result of this conversion.
  #     ---------+---------------+-----------------------------------------
  #     0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
  #              | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
  #              | (numeric fmt) | is used for negative numbers formatted as
  #              |               | complements.
  #     ---------+---------------+-----------------------------------------
  #     *        | all           | Use the next argument as the field width.
  #              |               | If negative, left-justify the result. If the
  #              |               | asterisk is followed by a number and a dollar
  #              |               | sign, use the indicated argument as the width.
  #
  # Examples of flags:
  #
  #     # `+' and space flag specifies the sign of non-negative numbers.
  #     sprintf("%d", 123)  #=> "123"
  #     sprintf("%+d", 123) #=> "+123"
  #     sprintf("% d", 123) #=> " 123"
  #
  #     # `#' flag for `o' increases number of digits to show `0'.
  #     # `+' and space flag changes format of negative numbers.
  #     sprintf("%o", 123)   #=> "173"
  #     sprintf("%#o", 123)  #=> "0173"
  #     sprintf("%+o", -123) #=> "-173"
  #     sprintf("%o", -123)  #=> "..7605"
  #     sprintf("%#o", -123) #=> "..7605"
  #
  #     # `#' flag for `x' add a prefix `0x' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%x", 123)   #=> "7b"
  #     sprintf("%#x", 123)  #=> "0x7b"
  #     sprintf("%+x", -123) #=> "-7b"
  #     sprintf("%x", -123)  #=> "..f85"
  #     sprintf("%#x", -123) #=> "0x..f85"
  #     sprintf("%#x", 0)    #=> "0"
  #
  #     # `#' for `X' uses the prefix `0X'.
  #     sprintf("%X", 123)  #=> "7B"
  #     sprintf("%#X", 123) #=> "0X7B"
  #
  #     # `#' flag for `b' add a prefix `0b' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%b", 123)   #=> "1111011"
  #     sprintf("%#b", 123)  #=> "0b1111011"
  #     sprintf("%+b", -123) #=> "-1111011"
  #     sprintf("%b", -123)  #=> "..10000101"
  #     sprintf("%#b", -123) #=> "0b..10000101"
  #     sprintf("%#b", 0)    #=> "0"
  #
  #     # `#' for `B' uses the prefix `0B'.
  #     sprintf("%B", 123)  #=> "1111011"
  #     sprintf("%#B", 123) #=> "0B1111011"
  #
  #     # `#' for `e' forces to show the decimal point.
  #     sprintf("%.0e", 1)  #=> "1e+00"
  #     sprintf("%#.0e", 1) #=> "1.e+00"
  #
  #     # `#' for `f' forces to show the decimal point.
  #     sprintf("%.0f", 1234)  #=> "1234"
  #     sprintf("%#.0f", 1234) #=> "1234."
  #
  #     # `#' for `g' forces to show the decimal point.
  #     # It also disables stripping lowest zeros.
  #     sprintf("%g", 123.4)   #=> "123.4"
  #     sprintf("%#g", 123.4)  #=> "123.400"
  #     sprintf("%g", 123456)  #=> "123456"
  #     sprintf("%#g", 123456) #=> "123456."
  #
  # The field width is an optional integer, followed optionally by a period and a
  # precision.  The width specifies the minimum number of characters that will be
  # written to the result for this field.
  #
  # Examples of width:
  #
  #     # padding is done by spaces,       width=20
  #     # 0 or radix-1.             <------------------>
  #     sprintf("%20d", 123)   #=> "                 123"
  #     sprintf("%+20d", 123)  #=> "                +123"
  #     sprintf("%020d", 123)  #=> "00000000000000000123"
  #     sprintf("%+020d", 123) #=> "+0000000000000000123"
  #     sprintf("% 020d", 123) #=> " 0000000000000000123"
  #     sprintf("%-20d", 123)  #=> "123                 "
  #     sprintf("%-+20d", 123) #=> "+123                "
  #     sprintf("%- 20d", 123) #=> " 123                "
  #     sprintf("%020x", -123) #=> "..ffffffffffffffff85"
  #
  # For numeric fields, the precision controls the number of decimal places
  # displayed.  For string fields, the precision determines the maximum number of
  # characters to be copied from the string.  (Thus, the format sequence `%10.10s`
  # will always contribute exactly ten characters to the result.)
  #
  # Examples of precisions:
  #
  #     # precision for `d', 'o', 'x' and 'b' is
  #     # minimum number of digits               <------>
  #     sprintf("%20.8d", 123)  #=> "            00000123"
  #     sprintf("%20.8o", 123)  #=> "            00000173"
  #     sprintf("%20.8x", 123)  #=> "            0000007b"
  #     sprintf("%20.8b", 123)  #=> "            01111011"
  #     sprintf("%20.8d", -123) #=> "           -00000123"
  #     sprintf("%20.8o", -123) #=> "            ..777605"
  #     sprintf("%20.8x", -123) #=> "            ..ffff85"
  #     sprintf("%20.8b", -11)  #=> "            ..110101"
  #
  #     # "0x" and "0b" for `#x' and `#b' is not counted for
  #     # precision but "0" for `#o' is counted.  <------>
  #     sprintf("%#20.8d", 123)  #=> "            00000123"
  #     sprintf("%#20.8o", 123)  #=> "            00000173"
  #     sprintf("%#20.8x", 123)  #=> "          0x0000007b"
  #     sprintf("%#20.8b", 123)  #=> "          0b01111011"
  #     sprintf("%#20.8d", -123) #=> "           -00000123"
  #     sprintf("%#20.8o", -123) #=> "            ..777605"
  #     sprintf("%#20.8x", -123) #=> "          0x..ffff85"
  #     sprintf("%#20.8b", -11)  #=> "          0b..110101"
  #
  #     # precision for `e' is number of
  #     # digits after the decimal point           <------>
  #     sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"
  #
  #     # precision for `f' is number of
  #     # digits after the decimal point               <------>
  #     sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"
  #
  #     # precision for `g' is number of
  #     # significant digits                          <------->
  #     sprintf("%20.8g", 1234.56789) #=> "           1234.5679"
  #
  #     #                                         <------->
  #     sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"
  #
  #     # precision for `s' is
  #     # maximum number of characters                    <------>
  #     sprintf("%20.8s", "string test") #=> "            string t"
  #
  # Examples:
  #
  #     sprintf("%d %04x", 123, 123)               #=> "123 007b"
  #     sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
  #     sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
  #     sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
  #     sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
  #     sprintf("%u", -123)                        #=> "-123"
  #
  # For more complex formatting, Ruby supports a reference by name. %<name>s style
  # uses format style, but %{name} style doesn't.
  #
  # Examples:
  #     sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
  #       #=> 1 : 2.000000
  #     sprintf("%{foo}f", { :foo => 1 })
  #       # => "1f"
  #
  alias sprintf format

  alias self.sprintf self.format

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep=$/ [, getline_args])     -> string or nil
  #   - gets(limit [, getline_args])      -> string or nil
  #   - gets(sep, limit [, getline_args]) -> string or nil
  # -->
  # Returns (and assigns to `$_`) the next line from the list of files in `ARGV`
  # (or `$*`), or from standard input if no files are present on the command line.
  # Returns `nil` at end of file. The optional argument specifies the record
  # separator. The separator is included with the contents of each record. A
  # separator of `nil` reads the entire contents, and a zero-length separator
  # reads the input one paragraph at a time, where paragraphs are divided by two
  # consecutive newlines.  If the first argument is an integer, or optional second
  # argument is given, the returning string would not be longer than the given
  # value in bytes.  If multiple filenames are present in `ARGV`, `gets(nil)` will
  # read the contents one file at a time.
  #
  #     ARGV << "testfile"
  #     print while gets
  #
  # *produces:*
  #
  #     This is line one
  #     This is line two
  #     This is line three
  #     And so on...
  #
  # The style of programming using `$_` as an implicit parameter is gradually
  # losing favor in the Ruby community.
  #
  def self?.gets: (?String arg0, ?Integer arg1) -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - global_variables    -> array
  # -->
  # Returns an array of the names of global variables. This includes special
  # regexp global variables such as `$~` and `$+`, but does not include the
  # numbered regexp global variables (`$1`, `$2`, etc.).
  #
  #     global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]
  #
  def self?.global_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=load.c
  #   - load(filename, wrap=false)   -> true
  # -->
  # Loads and executes the Ruby program in the file *filename*.
  #
  # If the filename is an absolute path (e.g. starts with '/'), the file will be
  # loaded directly using the absolute path.
  #
  # If the filename is an explicit relative path (e.g. starts with './' or '../'),
  # the file will be loaded using the relative path from the current directory.
  #
  # Otherwise, the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the file is found in a directory, it will attempt to
  # load the file relative to that directory.  If the file is not found in any of
  # the directories in `$LOAD_PATH`, the file will be loaded using the relative
  # path from the current directory.
  #
  # If the file doesn't exist when there is an attempt to load it, a LoadError
  # will be raised.
  #
  # If the optional *wrap* parameter is `true`, the loaded script will be executed
  # under an anonymous module, protecting the calling program's global namespace.
  # If the optional *wrap* parameter is a module, the loaded script will be
  # executed under the given module. In no circumstance will any local variables
  # in the loaded file be propagated to the loading environment.
  #
  def self?.load: (String filename, ?Module | bool) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - loop { block }
  #   - loop            -> an_enumerator
  # -->
  # Repeatedly executes the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     loop do
  #       print "Input: "
  #       line = gets
  #       break if !line or line =~ /^qQ/
  #       # ...
  #     end
  #
  # StopIteration raised in the block breaks the loop.  In this case, loop returns
  # the "result" value stored in the exception.
  #
  #     enum = Enumerator.new { |y|
  #       y << "one"
  #       y << "two"
  #       :ok
  #     }
  #
  #     result = loop {
  #       puts enum.next
  #     } #=> :ok
  #
  def self?.loop: () { (nil) -> untyped } -> bot
                | () -> ::Enumerator[nil, bot]

  # <!--
  #   rdoc-file=io.c
  #   - open(path [, mode [, perm]] [, opt])                -> io or nil
  #   - open(path [, mode [, perm]] [, opt]) {|io| block }  -> obj
  # -->
  # Creates an IO object connected to the given stream, file, or subprocess.
  #
  # If `path` does not start with a pipe character (`|`), treat it as the name of
  # a file to open using the specified mode (defaulting to "r").
  #
  # The `mode` is either a string or an integer.  If it is an integer, it must be
  # bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.  If it is a
  # string, it is either "fmode", "fmode:ext_enc", or "fmode:ext_enc:int_enc".
  #
  # See the documentation of IO.new for full documentation of the `mode` string
  # directives.
  #
  # If a file is being created, its initial permissions may be set using the
  # `perm` parameter.  See File.new and the open(2) and chmod(2) man pages for a
  # description of permissions.
  #
  # If a block is specified, it will be invoked with the IO object as a parameter,
  # and the IO will be automatically closed when the block terminates.  The call
  # returns the value of the block.
  #
  # If `path` starts with a pipe character (`"|"`), a subprocess is created,
  # connected to the caller by a pair of pipes.  The returned IO object may be
  # used to write to the standard input and read from the standard output of this
  # subprocess.
  #
  # If the command following the pipe is a single minus sign (`"|-"`), Ruby forks,
  # and this subprocess is connected to the parent.  If the command is not `"-"`,
  # the subprocess runs the command.  Note that the command may be processed by
  # shell if it contains shell metacharacters.
  #
  # When the subprocess is Ruby (opened via `"|-"`), the `open` call returns
  # `nil`.  If a block is associated with the open call, that block will run twice
  # --- once in the parent and once in the child.
  #
  # The block parameter will be an IO object in the parent and `nil` in the child.
  # The parent's `IO` object will be connected to the child's $stdin and $stdout.
  # The subprocess will be terminated at the end of the block.
  #
  # ### Examples
  #
  # Reading from "testfile":
  #
  #     open("testfile") do |f|
  #       print f.gets
  #     end
  #
  # Produces:
  #
  #     This is line one
  #
  # Open a subprocess and read its output:
  #
  #     cmd = open("|date")
  #     print cmd.gets
  #     cmd.close
  #
  # Produces:
  #
  #     Wed Apr  9 08:56:31 CDT 2003
  #
  # Open a subprocess running the same Ruby program:
  #
  #     f = open("|-", "w+")
  #     if f.nil?
  #       puts "in Child"
  #       exit
  #     else
  #       puts "Got: #{f.gets}"
  #     end
  #
  # Produces:
  #
  #     Got: in Child
  #
  # Open a subprocess using a block to receive the IO object:
  #
  #     open "|-" do |f|
  #       if f then
  #         # parent process
  #         puts "Got: #{f.gets}"
  #       else
  #         # child process
  #         puts "in Child"
  #       end
  #     end
  #
  # Produces:
  #
  #     Got: in Child
  #
  def self?.open: (String name, ?String mode, ?Integer perm) -> IO?
                | [T] (String name, ?String mode, ?Integer perm) { (IO) -> T } -> T

  # <!--
  #   rdoc-file=io.c
  #   - print(obj, ...)    -> nil
  # -->
  # Prints each object in turn to `$stdout`. If the output field separator (`$,`)
  # is not `nil`, its contents will appear between each field. If the output
  # record separator (`$\`) is not `nil`, it will be appended to the output. If no
  # arguments are given, prints `$_`. Objects that aren't strings will be
  # converted by calling their `to_s` method.
  #
  #     print "cat", [1,2,3], 99, "\n"
  #     $, = ", "
  #     $\ = "\n"
  #     print "cat", [1,2,3], 99
  #
  # *produces:*
  #
  #     cat12399
  #     cat, 1, 2, 3, 99
  #
  def self?.print: (*Kernel args) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - printf(io, string [, obj ... ])    -> nil
  #   - printf(string [, obj ... ])        -> nil
  # -->
  # Equivalent to:
  #     io.write(sprintf(string, obj, ...))
  #
  # or
  #     $stdout.write(sprintf(string, obj, ...))
  #
  def self?.printf: (IO arg0, String arg1, *untyped args) -> nil
                  | (String arg1, *untyped args) -> nil
                  | () -> nil

  # <!--
  #   rdoc-file=proc.c
  #   - proc   { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new.
  #
  def self?.proc: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - lambda { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new, except the resulting Proc objects check the number of
  # parameters passed when called.
  #
  def self?.lambda: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=io.c
  #   - putc(int)   -> int
  # -->
  # Equivalent to:
  #
  #     $stdout.putc(int)
  #
  # Refer to the documentation for IO#putc for important information regarding
  # multi-byte characters.
  #
  def self?.putc: (Integer arg0) -> Integer
                | (String arg0) -> String

  # <!--
  #   rdoc-file=io.c
  #   - puts(obj, ...)    -> nil
  # -->
  # Equivalent to
  #
  #     $stdout.puts(obj, ...)
  #
  def self?.puts: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - p(obj)              -> obj
  #   - p(obj1, obj2, ...)  -> [obj, ...]
  #   - p()                 -> nil
  # -->
  # For each object, directly writes *obj*.`inspect` followed by a newline to the
  # program's standard output.
  #
  #     S = Struct.new(:name, :state)
  #     s = S['dave', 'TX']
  #     p s
  #
  # *produces:*
  #
  #     #<S name="dave", state="TX">
  #
  def self?.p: [T] (T arg0) -> T
             | (*untyped arg0) -> Array[untyped]

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pp(*objs)
  # -->
  # prints arguments in pretty form.
  #
  # pp returns argument(s).
  #
  def self?.pp: [T] (T arg0) -> T
              | (*untyped arg0) -> Array[untyped]

  # <!--
  #   rdoc-file=random.c
  #   - rand(max=0)    -> number
  # -->
  # If called without an argument, or if `max.to_i.abs == 0`, rand returns a
  # pseudo-random floating point number between 0.0 and 1.0, including 0.0 and
  # excluding 1.0.
  #
  #     rand        #=> 0.2725926052826416
  #
  # When `max.abs` is greater than or equal to 1, `rand` returns a pseudo-random
  # integer greater than or equal to 0 and less than `max.to_i.abs`.
  #
  #     rand(100)   #=> 12
  #
  # When `max` is a Range, `rand` returns a random number where
  # range.member?(number) == true.
  #
  # Negative or floating point values for `max` are allowed, but may give
  # surprising results.
  #
  #     rand(-100) # => 87
  #     rand(-0.5) # => 0.8130921818028143
  #     rand(1.9)  # equivalent to rand(1), which is always 0
  #
  # Kernel.srand may be used to ensure that sequences of random numbers are
  # reproducible between different runs of a program.
  #
  # See also Random.rand.
  #
  def self?.rand: () -> Float
                | (Integer arg0) -> Integer
                | (::Range[Integer] arg0) -> Integer
                | (::Range[Float] arg0) -> Float

  # <!--
  #   rdoc-file=io.c
  #   - readline(sep=$/)     -> string
  #   - readline(limit)      -> string
  #   - readline(sep, limit) -> string
  # -->
  # Equivalent to Kernel::gets, except `readline` raises `EOFError` at end of
  # file.
  #
  def self?.readline: (?String arg0, ?Integer arg1) -> String

  # <!--
  #   rdoc-file=io.c
  #   - readlines(sep=$/)     -> array
  #   - readlines(limit)      -> array
  #   - readlines(sep, limit) -> array
  # -->
  # Returns an array containing the lines returned by calling `Kernel.gets(*sep*)`
  # until the end of file.
  #
  def self?.readlines: (?String arg0, ?Integer arg1) -> ::Array[String]

  # <!--
  #   rdoc-file=load.c
  #   - require(name)    -> true or false
  # -->
  # Loads the given `name`, returning `true` if successful and `false` if the
  # feature is already loaded.
  #
  # If the filename neither resolves to an absolute path nor starts with './' or
  # '../', the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the filename starts with './' or '../', resolution is
  # based on Dir.pwd.
  #
  # If the filename has the extension ".rb", it is loaded as a source file; if the
  # extension is ".so", ".o", or ".dll", or the default shared library extension
  # on the current platform, Ruby loads the shared library as a Ruby extension.
  # Otherwise, Ruby tries adding ".rb", ".so", and so on to the name until found.
  # If the file named cannot be found, a LoadError will be raised.
  #
  # For Ruby extensions the filename given may use any shared library extension.
  # For example, on Linux the socket extension is "socket.so" and `require
  # 'socket.dll'` will load the socket extension.
  #
  # The absolute path of the loaded file is added to `$LOADED_FEATURES` (`$"`).  A
  # file will not be loaded again if its path already appears in `$"`.  For
  # example, `require 'a'; require './a'` will not load `a.rb` again.
  #
  #     require "my-library.rb"
  #     require "db-driver"
  #
  # Any constants or globals within the loaded source file will be available in
  # the calling program's global namespace. However, local variables will not be
  # propagated to the loading environment.
  #
  def self?.require: (String path) -> bool

  # <!--
  #   rdoc-file=load.c
  #   - require_relative(string) -> true or false
  # -->
  # Ruby tries to load the library named *string* relative to the requiring file's
  # path.  If the file's path cannot be determined a LoadError is raised. If a
  # file is loaded `true` is returned and false otherwise.
  #
  def self?.require_relative: (String feature) -> bool

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil
  # -->
  # Calls select(2) system call. It monitors given arrays of IO objects, waits
  # until one or more of IO objects are ready for reading, are ready for writing,
  # and have pending exceptions respectively, and returns an array that contains
  # arrays of those IO objects.  It will return `nil` if optional *timeout* value
  # is given and no IO object is ready in *timeout* seconds.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after nonblocking methods such as
  # #read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
  # extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
  # caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
  # should wait for reading.  If IO::WaitWritable is raised, the caller should
  # wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of nonblocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of nonblocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process. See
  # select(2) manual on GNU/Linux system.
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # ### Parameters
  # read_array
  # :   an array of IO objects that wait until ready for read
  # write_array
  # :   an array of IO objects that wait until ready for write
  # error_array
  # :   an array of IO objects that wait for exceptions
  # timeout
  # :   a numeric value in second
  #
  #
  # ### Example
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # *produces:*
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self?.select: (::Array[IO] read, ?::Array[IO] write, ?::Array[IO] error, ?Integer timeout) -> ::Array[String]

  # <!--
  #   rdoc-file=process.c
  #   - sleep([duration])    -> integer
  # -->
  # Suspends the current thread for *duration* seconds (which may be any number,
  # including a `Float` with fractional seconds). Returns the actual number of
  # seconds slept (rounded), which may be less than that asked for if another
  # thread calls Thread#run. Called without an argument, sleep() will sleep
  # forever.
  #
  #     Time.new    #=> 2008-03-08 19:56:19 +0900
  #     sleep 1.2   #=> 1
  #     Time.new    #=> 2008-03-08 19:56:20 +0900
  #     sleep 1.9   #=> 2
  #     Time.new    #=> 2008-03-08 19:56:22 +0900
  #
  def self?.sleep: () -> bot
                 | (Numeric duration) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - syscall(num [, args...])   -> integer
  # -->
  # Calls the operating system function identified by *num* and returns the result
  # of the function or raises SystemCallError if it failed.
  #
  # Arguments for the function can follow *num*. They must be either `String`
  # objects or `Integer` objects. A `String` object is passed as a pointer to the
  # byte sequence. An `Integer` object is passed as an integer whose bit size is
  # the same as a pointer. Up to nine parameters may be passed.
  #
  # The function identified by *num* is system dependent. On some Unix systems,
  # the numbers may be obtained from a header file called `syscall.h`.
  #
  #     syscall 4, 1, "hello\n", 6   # '4' is write(2) on our box
  #
  # *produces:*
  #
  #     hello
  #
  # Calling `syscall` on a platform which does not have any way to an arbitrary
  # system function just fails with NotImplementedError.
  #
  # **Note:** `syscall` is essentially unsafe and unportable. Feel free to shoot
  # your foot. The DL (Fiddle) library is preferred for safer and a bit more
  # portable programming.
  #
  def self?.syscall: (Integer num, *untyped args) -> untyped

  # <!--
  #   rdoc-file=file.c
  #   - test(cmd, file1 [, file2] ) -> obj
  # -->
  # Uses the character `cmd` to perform various tests on `file1` (first table
  # below) or on `file1` and `file2` (second table).
  #
  # File tests on a single file:
  #
  #     Cmd    Returns   Meaning
  #     "A"  | Time    | Last access time for file1
  #     "b"  | boolean | True if file1 is a block device
  #     "c"  | boolean | True if file1 is a character device
  #     "C"  | Time    | Last change time for file1
  #     "d"  | boolean | True if file1 exists and is a directory
  #     "e"  | boolean | True if file1 exists
  #     "f"  | boolean | True if file1 exists and is a regular file
  #     "g"  | boolean | True if file1 has the \CF{setgid} bit
  #          |         | set (false under NT)
  #     "G"  | boolean | True if file1 exists and has a group
  #          |         | ownership equal to the caller's group
  #     "k"  | boolean | True if file1 exists and has the sticky bit set
  #     "l"  | boolean | True if file1 exists and is a symbolic link
  #     "M"  | Time    | Last modification time for file1
  #     "o"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's effective uid
  #     "O"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's real uid
  #     "p"  | boolean | True if file1 exists and is a fifo
  #     "r"  | boolean | True if file1 is readable by the effective
  #          |         | uid/gid of the caller
  #     "R"  | boolean | True if file is readable by the real
  #          |         | uid/gid of the caller
  #     "s"  | int/nil | If file1 has nonzero size, return the size,
  #          |         | otherwise return nil
  #     "S"  | boolean | True if file1 exists and is a socket
  #     "u"  | boolean | True if file1 has the setuid bit set
  #     "w"  | boolean | True if file1 exists and is writable by
  #          |         | the effective uid/gid
  #     "W"  | boolean | True if file1 exists and is writable by
  #          |         | the real uid/gid
  #     "x"  | boolean | True if file1 exists and is executable by
  #          |         | the effective uid/gid
  #     "X"  | boolean | True if file1 exists and is executable by
  #          |         | the real uid/gid
  #     "z"  | boolean | True if file1 exists and has a zero length
  #
  # Tests that take two files:
  #
  #     "-"  | boolean | True if file1 and file2 are identical
  #     "="  | boolean | True if the modification times of file1
  #          |         | and file2 are equal
  #     "<"  | boolean | True if the modification time of file1
  #          |         | is prior to that of file2
  #     ">"  | boolean | True if the modification time of file1
  #          |         | is after that of file2
  #
  def self?.test: (String | Integer cmd, String | IO file1, ?String | IO file2) -> (TrueClass | FalseClass | Time | nil | Integer)

  # <!--
  #   rdoc-file=vm_eval.c
  #   - throw(tag [, obj])
  # -->
  # Transfers control to the end of the active `catch` block waiting for *tag*.
  # Raises `UncaughtThrowError` if there is no `catch` block for the *tag*. The
  # optional second parameter supplies a return value for the `catch` block, which
  # otherwise defaults to `nil`. For examples, see Kernel::catch.
  #
  def self?.throw: (Object tag, ?untyped obj) -> bot

  # <!--
  #   rdoc-file=warning.rb
  #   - warn(*msgs, uplevel: nil, category: nil)   -> nil
  # -->
  # If warnings have been disabled (for example with the `-W0` flag), does
  # nothing.  Otherwise, converts each of the messages to strings, appends a
  # newline character to the string if the string does not end in a newline, and
  # calls Warning.warn with the string.
  #
  #       warn("warning 1", "warning 2")
  #
  #     <em>produces:</em>
  #
  #       warning 1
  #       warning 2
  #
  # If the `uplevel` keyword argument is given, the string will be prepended with
  # information for the given caller frame in the same format used by the
  # `rb_warn` C function.
  #
  #       # In baz.rb
  #       def foo
  #         warn("invalid call to foo", uplevel: 1)
  #       end
  #
  #       def bar
  #         foo
  #       end
  #
  #       bar
  #
  #     <em>produces:</em>
  #
  #       baz.rb:6: warning: invalid call to foo
  #
  # If `category` keyword argument is given, passes the category to
  # `Warning.warn`.  The category given must be be one of the following
  # categories:
  #
  # :deprecated
  # :   Used for warning for deprecated functionality that may be removed in the
  #     future.
  # :experimental
  # :   Used for experimental features that may change in future releases.
  #
  def self?.warn: (*untyped msg, ?uplevel: Integer | nil) -> NilClass

  # <!--
  #   rdoc-file=process.c
  #   - exec([env,] command... [,options])
  # -->
  # Replaces the current process by running the given external *command*, which
  # can take one of the following forms:
  #
  # `exec(commandline)`
  # :   command line string which is passed to the standard shell
  # `exec(cmdname, arg1, ...)`
  # :   command name and one or more arguments (no shell)
  # `exec([cmdname, argv0], arg1, ...)`
  # :   command name, [argv](0) and zero or more arguments (no shell)
  #
  #
  # In the first form, the string is taken as a command line that is subject to
  # shell expansion before being executed.
  #
  # The standard shell always means `"/bin/sh"` on Unix-like systems, otherwise,
  # `ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows and similar.  The command is
  # passed as an argument to the `"-c"` switch to the shell, except in the case of
  # `COMSPEC`.
  #
  # If the string from the first form (`exec("command")`) follows these simple
  # rules:
  #
  # *   no meta characters
  # *   not starting with shell reserved word or special built-in
  # *   Ruby invokes the command directly without shell
  #
  #
  # You can force shell invocation by adding ";" to the string (because ";" is a
  # meta character).
  #
  # Note that this behavior is observable by pid obtained (return value of spawn()
  # and IO#pid for IO.popen) is the pid of the invoked command, not shell.
  #
  # In the second form (`exec("command1", "arg1", ...)`), the first is taken as a
  # command name and the rest are passed as parameters to command with no shell
  # expansion.
  #
  # In the third form (`exec(["command", "argv0"], "arg1", ...)`), starting a
  # two-element array at the beginning of the command, the first element is the
  # command to be executed, and the second argument is used as the `argv[0]`
  # value, which may show up in process listings.
  #
  # In order to execute the command, one of the `exec(2)` system calls are used,
  # so the running command may inherit some of the environment of the original
  # program (including open file descriptors).
  #
  # This behavior is modified by the given `env` and `options` parameters. See
  # ::spawn for details.
  #
  # If the command fails to execute (typically Errno::ENOENT when it was not
  # found) a SystemCallError exception is raised.
  #
  # This method modifies process attributes according to given `options` before
  # `exec(2)` system call. See ::spawn for more details about the given `options`.
  #
  # The modified attributes may be retained when `exec(2)` system call fails.
  #
  # For example, hard resource limits are not restorable.
  #
  # Consider to create a child process using ::spawn or Kernel#system if this is
  # not acceptable.
  #
  #     exec "echo *"       # echoes list of files in current directory
  #     # never get here
  #
  #     exec "echo", "*"    # echoes an asterisk
  #     # never get here
  #
  def self?.exec: (*String args) -> bot

  type redirect_fd = Integer | :in | :out | :err | IO | String | [ String ] | [ String, string | int ] | [ String, string | int, int ] | [ :child, int ] | :close

  # <!--
  #   rdoc-file=process.c
  #   - spawn([env,] command... [,options])     -> pid
  #   - Process.spawn([env,] command... [,options])     -> pid
  # -->
  # spawn executes specified command and return its pid.
  #
  #     pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
  #     Process.wait pid
  #
  #     pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
  #     Process.wait pid
  #
  # This method is similar to Kernel#system but it doesn't wait for the command to
  # finish.
  #
  # The parent process should use Process.wait to collect the termination status
  # of its child or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # spawn has bunch of options to specify process attributes:
  #
  #     env: hash
  #       name => val : set the environment variable
  #       name => nil : unset the environment variable
  #
  #       the keys and the values except for +nil+ must be strings.
  #     command...:
  #       commandline                 : command line string which is passed to the standard shell
  #       cmdname, arg1, ...          : command name and one or more arguments (This form does not use the shell. See below for caveats.)
  #       [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)
  #     options: hash
  #       clearing environment variables:
  #         :unsetenv_others => true   : clear environment variables except specified by env
  #         :unsetenv_others => false  : don't clear (default)
  #       process group:
  #         :pgroup => true or 0 : make a new process group
  #         :pgroup => pgid      : join the specified process group
  #         :pgroup => nil       : don't change the process group (default)
  #       create new process group: Windows only
  #         :new_pgroup => true  : the new process is the root process of a new process group
  #         :new_pgroup => false : don't create a new process group (default)
  #       resource limit: resourcename is core, cpu, data, etc.  See Process.setrlimit.
  #         :rlimit_resourcename => limit
  #         :rlimit_resourcename => [cur_limit, max_limit]
  #       umask:
  #         :umask => int
  #       redirection:
  #         key:
  #           FD              : single file descriptor in child process
  #           [FD, FD, ...]   : multiple file descriptor in child process
  #         value:
  #           FD                        : redirect to the file descriptor in parent process
  #           string                    : redirect to file with open(string, "r" or "w")
  #           [string]                  : redirect to file with open(string, File::RDONLY)
  #           [string, open_mode]       : redirect to file with open(string, open_mode, 0644)
  #           [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)
  #           [:child, FD]              : redirect to the redirected file descriptor
  #           :close                    : close the file descriptor in child process
  #         FD is one of follows
  #           :in     : the file descriptor 0 which is the standard input
  #           :out    : the file descriptor 1 which is the standard output
  #           :err    : the file descriptor 2 which is the standard error
  #           integer : the file descriptor of specified the integer
  #           io      : the file descriptor specified as io.fileno
  #       file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not
  #         :close_others => false  : inherit
  #       current directory:
  #         :chdir => str
  #
  # The `cmdname, arg1, ...` form does not use the shell. However, on different
  # OSes, different things are provided as built-in commands. An example of this
  # is +'echo'+, which is a built-in on Windows, but is a normal program on Linux
  # and Mac OS X. This means that `Process.spawn 'echo', '%Path%'` will display
  # the contents of the `%Path%` environment variable on Windows, but
  # `Process.spawn 'echo', '$PATH'` prints the literal `$PATH`.
  #
  # If a hash is given as `env`, the environment is updated by `env` before
  # `exec(2)` in the child process. If a pair in `env` has nil as the value, the
  # variable is deleted.
  #
  #     # set FOO as BAR and unset BAZ.
  #     pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)
  #
  # If a hash is given as `options`, it specifies process group, create new
  # process group, resource limit, current directory, umask and redirects for the
  # child process. Also, it can be specified to clear environment variables.
  #
  # The `:unsetenv_others` key in `options` specifies to clear environment
  # variables, other than specified by `env`.
  #
  #     pid = spawn(command, :unsetenv_others=>true) # no environment variable
  #     pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only
  #
  # The `:pgroup` key in `options` specifies a process group. The corresponding
  # value should be true, zero, a positive integer, or nil. true and zero cause
  # the process to be a process leader of a new process group. A non-zero positive
  # integer causes the process to join the provided process group. The default
  # value, nil, causes the process to remain in the same process group.
  #
  #     pid = spawn(command, :pgroup=>true) # process leader
  #     pid = spawn(command, :pgroup=>10) # belongs to the process group 10
  #
  # The `:new_pgroup` key in `options` specifies to pass
  # `CREATE_NEW_PROCESS_GROUP` flag to `CreateProcessW()` that is Windows API.
  # This option is only for Windows. true means the new process is the root
  # process of the new process group. The new process has CTRL+C disabled. This
  # flag is necessary for `Process.kill(:SIGINT, pid)` on the subprocess.
  # :new_pgroup is false by default.
  #
  #     pid = spawn(command, :new_pgroup=>true)  # new process group
  #     pid = spawn(command, :new_pgroup=>false) # same process group
  #
  # The `:rlimit_`*foo* key specifies a resource limit. *foo* should be one of
  # resource types such as `core`. The corresponding value should be an integer or
  # an array which have one or two integers: same as cur_limit and max_limit
  # arguments for Process.setrlimit.
  #
  #     cur, max = Process.getrlimit(:CORE)
  #     pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
  #     pid = spawn(command, :rlimit_core=>max) # enable core dump
  #     pid = spawn(command, :rlimit_core=>0) # never dump core.
  #
  # The `:umask` key in `options` specifies the umask.
  #
  #     pid = spawn(command, :umask=>077)
  #
  # The :in, :out, :err, an integer, an IO and an array key specifies a
  # redirection. The redirection maps a file descriptor in the child process.
  #
  # For example, stderr can be merged into stdout as follows:
  #
  #     pid = spawn(command, :err=>:out)
  #     pid = spawn(command, 2=>1)
  #     pid = spawn(command, STDERR=>:out)
  #     pid = spawn(command, STDERR=>STDOUT)
  #
  # The hash keys specifies a file descriptor in the child process started by
  # #spawn. :err, 2 and STDERR specifies the standard error stream (stderr).
  #
  # The hash values specifies a file descriptor in the parent process which
  # invokes #spawn. :out, 1 and STDOUT specifies the standard output stream
  # (stdout).
  #
  # In the above example, the standard output in the child process is not
  # specified. So it is inherited from the parent process.
  #
  # The standard input stream (stdin) can be specified by :in, 0 and STDIN.
  #
  # A filename can be specified as a hash value.
  #
  #     pid = spawn(command, :in=>"/dev/null") # read mode
  #     pid = spawn(command, :out=>"/dev/null") # write mode
  #     pid = spawn(command, :err=>"log") # write mode
  #     pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
  #     pid = spawn(command, 3=>"/dev/null") # read mode
  #
  # For stdout and stderr (and combination of them), it is opened in write mode.
  # Otherwise read mode is used.
  #
  # For specifying flags and permission of file creation explicitly, an array is
  # used instead.
  #
  #     pid = spawn(command, :in=>["file"]) # read mode is assumed
  #     pid = spawn(command, :in=>["file", "r"])
  #     pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
  #     pid = spawn(command, :out=>["log", "w", 0600])
  #     pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])
  #
  # The array specifies a filename, flags and permission. The flags can be a
  # string or an integer. If the flags is omitted or nil, File::RDONLY is assumed.
  # The permission should be an integer. If the permission is omitted or nil, 0644
  # is assumed.
  #
  # If an array of IOs and integers are specified as a hash key, all the elements
  # are redirected.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, [:out, :err]=>["log", "w"])
  #
  # Another way to merge multiple file descriptors is [:child, fd]. [:child, fd]
  # means the file descriptor in the child process. This is different from fd. For
  # example, :err=>:out means redirecting child stderr to parent stdout. But
  # :err=>[:child, :out] means redirecting child stderr to child stdout. They
  # differ if stdout is redirected in the child process as follows.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])
  #
  # [:child, :out] can be used to merge stderr into stdout in IO.popen. In this
  # case, IO.popen redirects stdout to a pipe in the child process and [:child,
  # :out] refers the redirected stdout.
  #
  #     io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
  #     p io.read #=> "out\nerr\n"
  #
  # The `:chdir` key in `options` specifies the current directory.
  #
  #     pid = spawn(command, :chdir=>"/var/tmp")
  #
  # spawn closes all non-standard unspecified descriptors by default. The
  # "standard" descriptors are 0, 1 and 2. This behavior is specified by
  # :close_others option. :close_others doesn't affect the standard descriptors
  # which are closed only if :close is specified explicitly.
  #
  #     pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
  #     pid = spawn(command, :close_others=>false) # don't close 3,4,5,...
  #
  # :close_others is false by default for spawn and IO.popen.
  #
  # Note that fds which close-on-exec flag is already set are closed regardless of
  # :close_others option.
  #
  # So IO.pipe and spawn can be used as IO.popen.
  #
  #     # similar to r = IO.popen(command)
  #     r, w = IO.pipe
  #     pid = spawn(command, :out=>w)   # r, w is closed in the child process.
  #     w.close
  #
  # :close is specified as a hash value to close a fd individually.
  #
  #     f = open(foo)
  #     system(command, f=>:close)        # don't inherit f.
  #
  # If a file descriptor need to be inherited, io=>io can be used.
  #
  #     # valgrind has --log-fd option for log destination.
  #     # log_w=>log_w indicates log_w.fileno inherits to child process.
  #     log_r, log_w = IO.pipe
  #     pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
  #     log_w.close
  #     p log_r.read
  #
  # It is also possible to exchange file descriptors.
  #
  #     pid = spawn(command, :out=>:err, :err=>:out)
  #
  # The hash keys specify file descriptors in the child process. The hash values
  # specifies file descriptors in the parent process. So the above specifies
  # exchanging stdout and stderr. Internally, `spawn` uses an extra file
  # descriptor to resolve such cyclic file descriptor mapping.
  #
  # See Kernel.exec for the standard shell.
  #
  def self?.spawn: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer
                 | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - system([env,] command... [,options], exception: false)    -> true, false or nil
  # -->
  # Executes *command...* in a subshell. *command...* is one of following forms.
  #
  # `commandline`
  # :   command line string which is passed to the standard shell
  # `cmdname, arg1, ...`
  # :   command name and one or more arguments (no shell)
  # `[cmdname, argv0], arg1, ...`
  # :   command name, `argv[0]` and zero or more arguments (no shell)
  #
  #
  # system returns `true` if the command gives zero exit status, `false` for non
  # zero exit status. Returns `nil` if command execution fails. An error status is
  # available in `$?`.
  #
  # If the `exception: true` argument is passed, the method raises an exception
  # instead of returning `false` or `nil`.
  #
  # The arguments are processed in the same way as for Kernel#spawn.
  #
  # The hash arguments, env and options, are same as #exec and #spawn. See
  # Kernel#spawn for details.
  #
  #     system("echo *")
  #     system("echo", "*")
  #
  # *produces:*
  #
  #     config.h main.rb
  #     *
  #
  # Error handling:
  #
  #     system("cat nonexistent.txt")
  #     # => false
  #     system("catt nonexistent.txt")
  #     # => nil
  #
  #     system("cat nonexistent.txt", exception: true)
  #     # RuntimeError (Command failed with exit 1: cat)
  #     system("catt nonexistent.txt", exception: true)
  #     # Errno::ENOENT (No such file or directory - catt)
  #
  # See Kernel#exec for the standard shell.
  #
  def self?.system: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)
                  | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)
end

Kernel::RUBYGEMS_ACTIVATION_MONITOR: untyped

# <!-- rdoc-file=file.c -->
# A File is an abstraction of any file object accessible by the program and is
# closely associated with class IO.  File includes the methods of module
# FileTest as class methods, allowing you to write (for example)
# `File.exist?("foo")`.
#
# In the description of File methods, *permission bits* are a platform-specific
# set of bits that indicate permissions of a file. On Unix-based systems,
# permissions are viewed as a set of three octets, for the owner, the group, and
# the rest of the world. For each of these entities, permissions may be set to
# read, write, or execute the file:
#
# The permission bits `0644` (in octal) would thus be interpreted as read/write
# for owner, and read-only for group and other. Higher-order bits may also be
# used to indicate the type of file (plain, directory, pipe, socket, and so on)
# and various other special features. If the permissions are for a directory,
# the meaning of the execute bit changes; when set the directory can be
# searched.
#
# On non-Posix operating systems, there may be only the ability to make a file
# read-only or read-write. In this case, the remaining permission bits will be
# synthesized to resemble typical values. For instance, on Windows NT the
# default permission bits are `0644`, which means read/write for owner,
# read-only for all others. The only change that can be made is to make the file
# read-only, which is reported as `0444`.
#
# Various constants for the methods in File can be found in File::Constants.
#
# ## What's Here
#
# First, what's elsewhere. Class File:
#
# *   Inherits from [class IO](IO.html#class-IO-label-What-27s+Here), in
#     particular, methods for creating, reading, and writing files
# *   Includes [module
#     FileTest](FileTest.html#module-FileTest-label-What-27s+Here). which
#     provides dozens of additional methods.
#
#
# Here, class File provides methods that are useful for:
#
# *   [Creating](#class-File-label-Creating)
# *   [Querying](#class-File-label-Querying)
# *   [Settings](#class-File-label-Settings)
# *   [Other](#class-File-label-Other)
#
#
# ### Creating
#
#     ::new
# :       Opens the file at the given path; returns the file.
#
#     ::open
# :       Same as ::new, but when given a block will yield the file to the
#         block, and close the file upon exiting the block.
#
#     ::link
# :       Creates a new name for an existing file using a hard link.
#
#     ::mkfifo
# :       Returns the FIFO file created at the given path.
#
#     ::symlink
# :       Creates a symbolic link for the given file path.
#
#
#
# ### Querying
#
# *Paths*
#
#     ::absolute_path
# :       Returns the absolute file path for the given path.
#
#     ::absolute_path?
# :       Returns whether the given path is the absolute file path.
#
#     ::basename
# :       Returns the last component of the given file path.
#
#     ::dirname
# :       Returns all but the last component of the given file path.
#
#     ::expand_path
# :       Returns the absolute file path for the given path, expanding `~` for a
#         home directory.
#
#     ::extname
# :       Returns the file extension for the given file path.
#
#     ::fnmatch? (aliased as ::fnmatch)
# :       Returns whether the given file path matches the given pattern.
#
#     ::join
# :       Joins path components into a single path string.
#
#     ::path
# :       Returns the string representation of the given path.
#
#     ::readlink
# :       Returns the path to the file at the given symbolic link.
#
#     ::realdirpath
# :       Returns the real path for the given file path, where the last
#         component need not exist.
#
#     ::realpath
# :       Returns the real path for the given file path, where all components
#         must exist.
#
#     ::split
# :       Returns an array of two strings: the directory name and basename of
#         the file at the given path.
#
#     #path (aliased as #to_path)
# :       Returns the string representation of the given path.
#
#
#
# *Times*
#
#     ::atime
# :       Returns a Time for the most recent access to the given file.
#
#     ::birthtime
# :       Returns a Time  for the creation of the given file.
#
#     ::ctime
# :       Returns a Time  for the metadata change of the given file.
#
#     ::mtime
# :       Returns a Time for the most recent data modification to the content of
#         the given file.
#
#     #atime
# :       Returns a Time for the most recent access to `self`.
#
#     #birthtime
# :       Returns a Time  the creation for `self`.
#
#     #ctime
# :       Returns a Time for the metadata change of `self`.
#
#     #mtime
# :       Returns a Time for the most recent data modification to the content of
#         `self`.
#
#
#
# *Types*
#
#     ::blockdev?
# :       Returns whether the file at the given path is a block device.
#
#     ::chardev?
# :       Returns whether the file at the given path is a character device.
#
#     ::directory?
# :       Returns whether the file at the given path is a diretory.
#
#     ::executable?
# :       Returns whether the file at the given path is executable by the
#         effective user and group of the current process.
#
#     ::executable_real?
# :       Returns whether the file at the given path is executable by the real
#         user and group of the current process.
#
#     ::exist?
# :       Returns whether the file at the given path exists.
#
#     ::file?
# :       Returns whether the file at the given path is a regular file.
#
#     ::ftype
# :       Returns a string giving the type of the file at the given path.
#
#     ::grpowned?
# :       Returns whether the effective group of the current process owns the
#         file at the given path.
#
#     ::identical?
# :       Returns whether the files at two given paths are identical.
#
#     ::lstat
# :       Returns the File::Stat object for the last symbolic link in the given
#         path.
#
#     ::owned?
# :       Returns whether the effective user of the current process owns the
#         file at the given path.
#
#     ::pipe?
# :       Returns whether the file at the given path is a pipe.
#
#     ::readable?
# :       Returns whether the file at the given path is readable by the
#         effective user and group of the current process.
#
#     ::readable_real?
# :       Returns whether the file at the given path is readable by the real
#         user and group of the current process.
#
#     ::setgid?
# :       Returns whether the setgid bit is set for the file at the given path.
#
#     ::setuid?
# :       Returns whether the setuid bit is set for the file at the given path.
#
#     ::socket?
# :       Returns whether the file at the given path is a socket.
#
#     ::stat
# :       Returns the File::Stat object for the file at the given path.
#
#     ::sticky?
# :       Returns whether the file at the given path has its sticky bit set.
#
#     ::symlink?
# :       Returns whether the file at the given path is a symbolic link.
#
#     ::umask
# :       Returns the umask value for the current process.
#
#     ::world_readable?
# :       Returns whether the file at the given path is readable by others.
#
#     ::world_writable?
# :       Returns whether the file at the given path is writable by others.
#
#     ::writable?
# :       Returns whether the file at the given path is writable by the
#         effective user and group of the current process.
#
#     ::writable_real?
# :       Returns whether the file at the given path is writable by the real
#         user and group of the current process.
#
#     #lstat
# :       Returns the File::Stat object for the last symbolic link in the path
#         for `self`.
#
#
#
# *Contents*
#
#     ::empty? (aliased as ::zero?)
# :       Returns whether the file at the given path exists and is empty.
#
#     ::size
# :       Returns the size (bytes) of the file at the given path.
#
#     ::size?
# :       Returns `nil` if there is no file at the given path, or if that file
#         is empty; otherwise returns the file size (bytes).
#
#     #size
# :       Returns the size (bytes) of `self`.
#
#
#
# ### Settings
#
#     ::chmod
# :       Changes permissions of the file at the given path.
#
#     ::chown
# :       Change ownership of the file at the given path.
#
#     ::lchmod
# :       Changes permissions of the last symbolic link in the given path.
#
#     ::lchown
# :       Change ownership of the last symbolic in the given path.
#
#     ::lutime
# :       For each given file path, sets the access time and modification time
#         of the last symbolic link in the path.
#
#     ::rename
# :       Moves the file at one given path to another given path.
#
#     ::utime
# :       Sets the access time and modification time of each file at the given
#         paths.
#
#     #flock
# :       Locks or unlocks `self`.
#
#
#
# ### Other
#
#     ::truncate
# :       Truncates the file at the given file path to the given size.
#
#     ::unlink (aliased as ::delete)
# :       Deletes the file for each given file path.
#
#     #truncate
# :       Truncates `self` to the given size.
#
class File < IO
  # <!--
  #   rdoc-file=io.c
  #   - File.new(filename, mode="r" [, opt])            -> file
  #   - File.new(filename [, mode [, perm]] [, opt])    -> file
  # -->
  # Opens the file named by `filename` according to the given `mode` and returns a
  # new File object.
  #
  # See IO.new for a description of `mode` and `opt`.
  #
  # If a file is being created, permission bits may be given in `perm`.  These
  # mode and permission bits are platform dependent; on Unix systems, see open(2)
  # and chmod(2) man pages for details.
  #
  # The new File object is buffered mode (or non-sync mode), unless `filename` is
  # a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync= about sync mode.
  #
  # ### Examples
  #
  #     f = File.new("testfile", "r")
  #     f = File.new("newfile",  "w+")
  #     f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)
  #
  def initialize: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> File

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless *dir_string* is
  # given, in which case it will be used as the starting point. If the given
  # pathname starts with a ```~`'' it is NOT expanded, it is treated as a normal
  # directory name.
  #
  #     File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
  #
  def self.absolute_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path?(file_name)  ->  true or false
  # -->
  # Returns `true` if `file_name` is an absolute path, and `false` otherwise.
  #
  #     File.absolute_path?("c:/foo")     #=> false (on Linux), true (on Windows)
  #
  def self.absolute_path?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.atime(file_name)  ->  time
  # -->
  # Returns the last access time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003
  #
  def self.atime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.basename(file_name [, suffix] )  ->  base_name
  # -->
  # Returns the last component of the filename given in *file_name* (after first
  # stripping trailing separators), which can be formed using both File::SEPARATOR
  # and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not
  # `nil`. If *suffix* is given and present at the end of *file_name*, it is
  # removed. If *suffix* is ".*", any extension will be removed.
  #
  #     File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
  #     File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
  #     File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"
  #
  def self.basename: (string | _ToPath file_name, ?string suffix) -> String

  # <!--
  #   rdoc-file=file.c
  #   - birthtime(p1)
  # -->
  #
  def self.birthtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a block device.
  #
  # *file_name* can be an IO object.
  #
  def self.blockdev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a character device.
  #
  # *file_name* can be an IO object.
  #
  def self.chardev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chmod(mode_int, file_name, ... )  ->  integer
  # -->
  # Changes permission bits on the named file(s) to the bit pattern represented by
  # *mode_int*. Actual effects are operating system dependent (see the beginning
  # of this section). On Unix systems, see `chmod(2)` for details. Returns the
  # number of files processed.
  #
  #     File.chmod(0644, "testfile", "out")   #=> 2
  #
  def self.chmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.chown(owner_int, group_int, file_name, ...)  ->  integer
  # -->
  # Changes the owner and group of the named file(s) to the given numeric owner
  # and group id's. Only a process with superuser privileges may change the owner
  # of a file. The current owner of a file may change the file's group to any
  # group to which the owner belongs. A `nil` or -1 owner or group id is ignored.
  # Returns the number of files processed.
  #
  #     File.chown(nil, 100, "testfile")
  #
  def self.chown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.ctime(file_name)  -> time
  # -->
  # Returns the change time for the named file (the time at which directory
  # information about the file was changed, not the file itself).
  #
  # *file_name* can be an IO object.
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
  #
  def self.ctime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  alias self.delete self.unlink

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def self.directory?: (string | _ToPath | IO path) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.dirname(file_name, level = 1)  ->  dir_name
  # -->
  # Returns all components of the filename given in *file_name* except the last
  # one (after first stripping trailing separators). The filename can be formed
  # using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when
  # File::ALT_SEPARATOR is not `nil`.
  #
  #     File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"
  #
  # If `level` is given, removes the last `level` components, not only one.
  #
  #     File.dirname("/home/gumby/work/ruby.rb", 2) #=> "/home/gumby"
  #     File.dirname("/home/gumby/work/ruby.rb", 4) #=> "/"
  #
  def self.dirname: (string | _ToPath file_name, ?Integer level) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  alias self.empty? self.zero?

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self.executable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self.executable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self.exist?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.expand_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless `dir_string` is
  # given, in which case it will be used as the starting point. The given pathname
  # may start with a ```~`'', which expands to the process owner's home directory
  # (the environment variable `HOME` must be set correctly). ```~`*user*'' expands
  # to the named user's home directory.
  #
  #     File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"
  #
  # A simple example of using `dir_string` is as follows.
  #     File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"
  #
  # A more complex example which also resolves parent directory is as follows.
  # Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.
  #
  #     File.expand_path("../../lib/mygem.rb", __FILE__)
  #     #=> ".../path/to/project/lib/mygem.rb"
  #
  # So first it resolves the parent of __FILE__, that is bin/, then go to the
  # parent, the root of the project and appends `lib/mygem.rb`.
  #
  def self.expand_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.extname(path)  ->  string
  # -->
  # Returns the extension (the portion of file name in `path` starting from the
  # last period).
  #
  # If `path` is a dotfile, or starts with a period, then the starting dot is not
  # dealt with the start of the extension.
  #
  # An empty string will also be returned when the period is the last character in
  # `path`.
  #
  # On Windows, trailing dots are truncated.
  #
  #     File.extname("test.rb")         #=> ".rb"
  #     File.extname("a/b/d/test.rb")   #=> ".rb"
  #     File.extname(".a/b/d/test.rb")  #=> ".rb"
  #     File.extname("foo.")            #=> "" on Windows
  #     File.extname("foo.")            #=> "." on non-Windows
  #     File.extname("test")            #=> ""
  #     File.extname(".profile")        #=> ""
  #     File.extname(".profile.sh")     #=> ".sh"
  #
  def self.extname: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self.file?: (string | _ToPath | IO file) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - File.fnmatch( pattern, path, [flags] ) -> (true or false)
  #   - File.fnmatch?( pattern, path, [flags] ) -> (true or false)
  # -->
  # Returns true if `path` matches against `pattern`.  The pattern is not a
  # regular expression; instead it follows rules similar to shell filename
  # globbing.  It may contain the following metacharacters:
  #
  # `*`
  # :   Matches any file. Can be restricted by other values in the glob.
  #     Equivalent to `/.*/x` in regexp.
  #
  #     `*`
  # :       Matches all regular files
  #     `c*`
  # :       Matches all files beginning with `c`
  #     `*c`
  # :       Matches all files ending with `c`
  #     `*c*`
  # :       Matches all files that have `c` in them (including at the beginning or
  #         end).
  #
  #
  #     To match hidden files (that start with a `.`) set the File::FNM_DOTMATCH
  #     flag.
  #
  # `**`
  # :   Matches directories recursively or files expansively.
  #
  # `?`
  # :   Matches any one character. Equivalent to `/.{1}/` in regexp.
  #
  # `[set]`
  # :   Matches any one character in `set`.  Behaves exactly like character sets
  #     in Regexp, including set negation (`[^a-z]`).
  #
  # `\`
  # :   Escapes the next metacharacter.
  #
  # `{a,b}`
  # :   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.
  #     Behaves like a Regexp union (`(?:a|b)`).
  #
  #
  # `flags` is a bitwise OR of the `FNM_XXX` constants. The same glob pattern and
  # flags are used by Dir::glob.
  #
  # Examples:
  #
  #     File.fnmatch('cat',       'cat')        #=> true  # match entire string
  #     File.fnmatch('cat',       'category')   #=> false # only match partial string
  #
  #     File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
  #     File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB
  #
  #     File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
  #     File.fnmatch('c??t',    'cat')          #=> false # ditto
  #     File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
  #     File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
  #     File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
  #     File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')
  #
  #     File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default
  #
  #     File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
  #     File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
  #     File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto
  #
  #     File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
  #     File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
  #     File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
  #     File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression
  #
  #     File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
  #     File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
  #     File.fnmatch('.*',  '.profile')                      #=> true
  #
  #     File.fnmatch('**/*.rb', 'main.rb')                  #=> false
  #     File.fnmatch('**/*.rb', './main.rb')                #=> false
  #     File.fnmatch('**/*.rb', 'lib/song.rb')              #=> true
  #     File.fnmatch('**.rb', 'main.rb')                    #=> true
  #     File.fnmatch('**.rb', './main.rb')                  #=> false
  #     File.fnmatch('**.rb', 'lib/song.rb')                #=> true
  #     File.fnmatch('*',     'dave/.profile')              #=> true
  #
  #     File.fnmatch('**/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
  #     File.fnmatch('**/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
  #     File.fnmatch('**/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
  #
  def self.fnmatch: (string pattern, string | _ToPath path, ?int flags) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - fnmatch?(pattern, path, flags = 0)
  # -->
  #
  alias self.fnmatch? self.fnmatch

  # <!--
  #   rdoc-file=file.c
  #   - File.ftype(file_name)   -> string
  # -->
  # Identifies the type of the named file; the return string is one of ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.ftype("testfile")            #=> "file"
  #     File.ftype("/dev/tty")            #=> "characterSpecial"
  #     File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
  #
  def self.ftype: (string | _ToPath file_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self.grpowned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self.identical?: (string | _ToPath | IO file_1, string | _ToPath | IO file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.join(string, ...)  ->  string
  # -->
  # Returns a new string formed by joining the strings using `"/"`.
  #
  #     File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"
  #
  def self.join: (*string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.lchmod(mode_int, file_name, ...)  -> integer
  # -->
  # Equivalent to File::chmod, but does not follow symbolic links (so it will
  # change the permissions associated with the link, not the file referenced by
  # the link). Often not available.
  #
  def self.lchmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.lchown(owner_int, group_int, file_name,..) -> integer
  # -->
  # Equivalent to File::chown, but does not follow symbolic links (so it will
  # change the owner associated with the link, not the file referenced by the
  # link). Often not available. Returns number of files in the argument list.
  #
  def self.lchown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.link(old_name, new_name)    -> 0
  # -->
  # Creates a new name for an existing file using a hard link. Will not overwrite
  # *new_name* if it already exists (raising a subclass of SystemCallError). Not
  # available on all platforms.
  #
  #     File.link("testfile", ".testfile")   #=> 0
  #     IO.readlines(".testfile")[0]         #=> "This is line one\n"
  #
  def self.link: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.lstat(file_name)   -> stat
  # -->
  # Same as File::stat, but does not follow the last symbolic link. Instead,
  # reports on the link itself.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.stat("testfile").size              #=> 66
  #     File.lstat("link2test").size            #=> 8
  #     File.stat("link2test").size             #=> 66
  #
  def self.lstat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.lutime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon the link itself as
  # opposed to its referent; for the inverse behavior, see File.utime. Returns the
  # number of file names in the argument list.
  #
  def self.lutime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.mkfifo(file_name, mode=0666)  => 0
  # -->
  # Creates a FIFO special file with name *file_name*.  *mode* specifies the
  # FIFO's permissions. It is modified by the process's umask in the usual way:
  # the permissions of the created file are (mode & ~umask).
  #
  def self.mkfifo: (string | _ToPath file_name, ?int mode) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.mtime(file_name)  ->  time
  # -->
  # Returns the modification time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003
  #
  def self.mtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=io.c
  #   - File.open(filename, mode="r" [, opt])                 -> file
  #   - File.open(filename [, mode [, perm]] [, opt])         -> file
  #   - File.open(filename, mode="r" [, opt]) {|file| block } -> obj
  #   - File.open(filename [, mode [, perm]] [, opt]) {|file| block } -> obj
  # -->
  # With no associated block, File.open is a synonym for File.new. If the optional
  # code block is given, it will be passed the opened `file` as an argument and
  # the File object will automatically be closed when the block terminates.  The
  # value of the block will be returned from File.open.
  #
  # If a file is being created, its initial permissions may be set using the
  # `perm` parameter.  See File.new for further discussion.
  #
  # See IO.new for a description of the `mode` and `opt` parameters.
  #
  def self.open: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> instance
               | [T] (string | _ToPath | int file_name, ?string | int mode, ?int perm) { (File) -> T } -> T

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self.owned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.path(path)  ->  string
  # -->
  # Returns the string representation of the path
  #
  #     File.path("/dev/null")          #=> "/dev/null"
  #     File.path(Pathname.new("/tmp")) #=> "/tmp"
  #
  def self.path: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a pipe.
  #
  # *file_name* can be an IO object.
  #
  def self.pipe?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self.readable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self.readable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readlink(link_name)  ->  file_name
  # -->
  # Returns the name of the file referenced by the given link. Not available on
  # all platforms.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.readlink("link2test")              #=> "testfile"
  #
  def self.readlink: (string | _ToPath link_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realdirpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem.
  # The real pathname doesn't contain symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # The last component of the real pathname can be nonexistent.
  #
  def self.realdirpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem
  # not containing symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # All components of the pathname must exist when this method is called.
  #
  def self.realpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.rename(old_name, new_name)   -> 0
  # -->
  # Renames the given file to the new name. Raises a SystemCallError if the file
  # cannot be renamed.
  #
  #     File.rename("afile", "afile.bak")   #=> 0
  #
  def self.rename: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setgid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setuid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self.size: (string | _ToPath | IO file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self.size?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a socket.
  #
  # *file_name* can be an IO object.
  #
  def self.socket?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.split(file_name)   -> array
  # -->
  # Splits the given string into a directory and a file component and returns them
  # in a two-element array. See also File::dirname and File::basename.
  #
  #     File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]
  #
  def self.split: (string | _ToPath file_name) -> [ String, String ]

  # <!--
  #   rdoc-file=file.c
  #   - File.stat(file_name)   ->  stat
  # -->
  # Returns a File::Stat object for the named file (see File::Stat).
  #
  #     File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003
  #
  def self.stat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.sticky?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink(old_name, new_name)   -> 0
  # -->
  # Creates a symbolic link called *new_name* for the existing file *old_name*.
  # Raises a NotImplemented exception on platforms that do not support symbolic
  # links.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #
  def self.symlink: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a symbolic link.
  #
  def self.symlink?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.truncate(file_name, integer)  -> 0
  # -->
  # Truncates the file *file_name* to be at most *integer* bytes long. Not
  # available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.write("1234567890")     #=> 10
  #     f.close                   #=> nil
  #     File.truncate("out", 5)   #=> 0
  #     File.size("out")          #=> 5
  #
  def self.truncate: (string | _ToPath file_name, int length) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.umask()          -> integer
  #   - File.umask(integer)   -> integer
  # -->
  # Returns the current umask value for this process. If the optional argument is
  # given, set the umask to that value and return the previous value. Umask values
  # are *subtracted* from the default permissions, so a umask of `0222` would make
  # a file read-only for everyone.
  #
  #     File.umask(0006)   #=> 18
  #     File.umask         #=> 6
  #
  def self.umask: (?int umask) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  def self.unlink: (*string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.utime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon its referent rather
  # than the link itself; for the inverse behavior see File.lutime. Returns the
  # number of file names in the argument list.
  #
  def self.utime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self.world_readable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self.world_writable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self.writable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self.writable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self.zero?: (string | _ToPath | IO file_name) -> bool

  public

  # <!--
  #   rdoc-file=file.c
  #   - file.atime    -> time
  # -->
  # Returns the last access time (a Time object) for *file*, or epoch if *file*
  # has not been accessed.
  #
  #     File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.birthtime  ->  time
  # -->
  # Returns the birth time for *file*.
  #
  #     File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.chmod(mode_int)   -> 0
  # -->
  # Changes permission bits on *file* to the bit pattern represented by
  # *mode_int*. Actual effects are platform dependent; on Unix systems, see
  # `chmod(2)` for details. Follows symbolic links. Also see File#lchmod.
  #
  #     f = File.new("out", "w");
  #     f.chmod(0644)   #=> 0
  #
  def chmod: (int mode) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.chown(owner_int, group_int )   -> 0
  # -->
  # Changes the owner and group of *file* to the given numeric owner and group
  # id's. Only a process with superuser privileges may change the owner of a file.
  # The current owner of a file may change the file's group to any group to which
  # the owner belongs. A `nil` or -1 owner or group id is ignored. Follows
  # symbolic links. See also File#lchown.
  #
  #     File.new("testfile").chown(502, 1000)
  #
  def chown: (int? owner, int? group) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.ctime  ->  time
  # -->
  # Returns the change time for *file* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.flock(locking_constant) -> 0 or false
  # -->
  # Locks or unlocks a file according to *locking_constant* (a logical *or* of the
  # values in the table below). Returns `false` if File::LOCK_NB is specified and
  # the operation would otherwise have blocked. Not available on all platforms.
  #
  # Locking constants (in class File):
  #
  #     LOCK_EX   | Exclusive lock. Only one process may hold an
  #               | exclusive lock for a given file at a time.
  #     ----------+------------------------------------------------
  #     LOCK_NB   | Don't block when locking. May be combined
  #               | with other lock options using logical or.
  #     ----------+------------------------------------------------
  #     LOCK_SH   | Shared lock. Multiple processes may each hold a
  #               | shared lock for a given file at the same time.
  #     ----------+------------------------------------------------
  #     LOCK_UN   | Unlock.
  #
  # Example:
  #
  #     # update a counter using write lock
  #     # don't use "w" because it truncates the file before lock.
  #     File.open("counter", File::RDWR|File::CREAT, 0644) {|f|
  #       f.flock(File::LOCK_EX)
  #       value = f.read.to_i + 1
  #       f.rewind
  #       f.write("#{value}\n")
  #       f.flush
  #       f.truncate(f.pos)
  #     }
  #
  #     # read the counter using read lock
  #     File.open("counter", "r") {|f|
  #       f.flock(File::LOCK_SH)
  #       p f.read
  #     }
  #
  def flock: (int locking_constant) -> (0 | false)

  # <!--
  #   rdoc-file=file.c
  #   - file.lstat   ->  stat
  # -->
  # Same as IO#stat, but does not follow the last symbolic link. Instead, reports
  # on the link itself.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.stat("testfile").size              #=> 66
  #     f = File.new("link2test")
  #     f.lstat.size                            #=> 8
  #     f.stat.size                             #=> 66
  #
  def lstat: () -> (File::Stat | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.mtime  ->  time
  # -->
  # Returns the modification time for *file*.
  #
  #     File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.path  ->  filename
  #   - file.to_path  ->  filename
  # -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  def path: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - size()
  # -->
  #
  def size: () -> Integer

  # <!-- rdoc-file=file.c -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  alias to_path path

  # <!--
  #   rdoc-file=file.c
  #   - file.truncate(integer)    -> 0
  # -->
  # Truncates *file* to at most *integer* bytes. The file must be opened for
  # writing. Not available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.syswrite("1234567890")   #=> 10
  #     f.truncate(5)              #=> 0
  #     f.close()                  #=> nil
  #     File.size("out")           #=> 5
  #
  def truncate: (int length) -> 0
end

# <!-- rdoc-file=file.c -->
# platform specific alternative separator
#
File::ALT_SEPARATOR: String?

# <!-- rdoc-file=file.c -->
# path list separator
#
File::PATH_SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::Separator: String

module File::Constants
end

File::Constants::APPEND: Integer

File::Constants::BINARY: Integer

File::Constants::CREAT: Integer

File::Constants::DIRECT: Integer

File::Constants::DSYNC: Integer

File::Constants::EXCL: Integer

File::Constants::FNM_CASEFOLD: Integer

File::Constants::FNM_DOTMATCH: Integer

File::Constants::FNM_EXTGLOB: Integer

File::Constants::FNM_NOESCAPE: Integer

File::Constants::FNM_PATHNAME: Integer

File::Constants::FNM_SHORTNAME: Integer

File::Constants::FNM_SYSCASE: Integer

File::Constants::LOCK_EX: Integer

File::Constants::LOCK_NB: Integer

File::Constants::LOCK_SH: Integer

File::Constants::LOCK_UN: Integer

File::Constants::NOATIME: Integer

File::Constants::NOCTTY: Integer

File::Constants::NOFOLLOW: Integer

File::Constants::NONBLOCK: Integer

File::Constants::NULL: String

File::Constants::RDONLY: Integer

File::Constants::RDWR: Integer

File::Constants::RSYNC: Integer

File::Constants::SHARE_DELETE: Integer

File::Constants::SYNC: Integer

File::Constants::TMPFILE: Integer

File::Constants::TRUNC: Integer

File::Constants::WRONLY: Integer

# <!-- rdoc-file=file.c -->
# Objects of class File::Stat encapsulate common status information for File
# objects. The information is recorded at the moment the File::Stat object is
# created; changes made to the file after that point will not be reflected.
# File::Stat objects are returned by IO#stat, File::stat, File#lstat, and
# File::lstat. Many of these methods return platform-specific values, and not
# all values are meaningful on all systems. See also Kernel#test.
#
class File::Stat < Object
  include Comparable

  # <!--
  #   rdoc-file=file.c
  #   - File::Stat.new(file_name)  -> stat
  # -->
  # Create a File::Stat object for the given file name (raising an exception if
  # the file doesn't exist).
  #
  def initialize: (String file) -> Object

  # <!--
  #   rdoc-file=file.c
  #   - stat <=> other_stat    -> -1, 0, 1, nil
  # -->
  # Compares File::Stat objects by comparing their respective modification times.
  #
  # `nil` is returned if `other_stat` is not a File::Stat object
  #
  #     f1 = File.new("f1", "w")
  #     sleep 1
  #     f2 = File.new("f2", "w")
  #     f1.stat <=> f2.stat   #=> -1
  #
  def <=>: (File::Stat other) -> Integer
         | (untyped) -> nil

  # <!--
  #   rdoc-file=file.c
  #   - stat.atime   -> time
  # -->
  # Returns the last access time for this file as an object of class Time.
  #
  #     File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.birthtime  ->  aTime
  # -->
  # Returns the birth time for *stat*.
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  #     File.write("testfile", "foo")
  #     sleep 10
  #     File.write("testfile", "bar")
  #     sleep 10
  #     File.chmod(0644, "testfile")
  #     sleep 10
  #     File.read("testfile")
  #     File.stat("testfile").birthtime   #=> 2014-02-24 11:19:17 +0900
  #     File.stat("testfile").mtime       #=> 2014-02-24 11:19:27 +0900
  #     File.stat("testfile").ctime       #=> 2014-02-24 11:19:37 +0900
  #     File.stat("testfile").atime       #=> 2014-02-24 11:19:47 +0900
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.blksize   -> integer or nil
  # -->
  # Returns the native file system's block size. Will return `nil` on platforms
  # that don't support this information.
  #
  #     File.stat("testfile").blksize   #=> 4096
  #
  def blksize: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.blockdev?   -> true or false
  # -->
  # Returns `true` if the file is a block device, `false` if it isn't or if the
  # operating system doesn't support this feature.
  #
  #     File.stat("testfile").blockdev?    #=> false
  #     File.stat("/dev/hda1").blockdev?   #=> true
  #
  def blockdev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.blocks    -> integer or nil
  # -->
  # Returns the number of native file system blocks allocated for this file, or
  # `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("testfile").blocks   #=> 2
  #
  def blocks: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.chardev?    -> true or false
  # -->
  # Returns `true` if the file is a character device, `false` if it isn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("/dev/tty").chardev?   #=> true
  #
  def chardev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ctime  ->  aTime
  # -->
  # Returns the change time for *stat* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev    -> integer
  # -->
  # Returns an integer representing the device on which *stat* resides.
  #
  #     File.stat("testfile").dev   #=> 774
  #
  def dev: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_major   #=> 2
  #     File.stat("/dev/tty").dev_major   #=> 5
  #
  def dev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_minor   #=> 1
  #     File.stat("/dev/tty").dev_minor   #=> 0
  #
  def dev_minor: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def directory?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable?    -> true or false
  # -->
  # Returns `true` if *stat* is executable or if the operating system doesn't
  # distinguish executable files from nonexecutable files. The tests are made
  # using the effective owner of the process.
  #
  #     File.stat("testfile").executable?   #=> false
  #
  def executable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable_real?    -> true or false
  # -->
  # Same as `executable?`, but tests using the real owner of the process.
  #
  def executable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.file?    -> true or false
  # -->
  # Returns `true` if *stat* is a regular file (not a device file, pipe, socket,
  # etc.).
  #
  #     File.stat("testfile").file?   #=> true
  #
  def file?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ftype   -> string
  # -->
  # Identifies the type of *stat*. The return string is one of: ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.stat("/dev/tty").ftype   #=> "characterSpecial"
  #
  def ftype: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.gid   -> integer
  # -->
  # Returns the numeric group id of the owner of *stat*.
  #
  #     File.stat("testfile").gid   #=> 500
  #
  def gid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.grpowned?   -> true or false
  # -->
  # Returns true if the effective group id of the process is the same as the group
  # id of *stat*. On Windows NT, returns `false`.
  #
  #     File.stat("testfile").grpowned?      #=> true
  #     File.stat("/etc/passwd").grpowned?   #=> false
  #
  def grpowned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ino   -> integer
  # -->
  # Returns the inode number for *stat*.
  #
  #     File.stat("testfile").ino   #=> 1083669
  #
  def ino: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.inspect  ->  string
  # -->
  # Produce a nicely formatted description of *stat*.
  #
  #     File.stat("/etc/passwd").inspect
  #        #=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,
  #        #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,
  #        #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,
  #        #    mtime=Fri Sep 12 15:41:41 CDT 2003,
  #        #    ctime=Mon Oct 27 11:20:27 CST 2003,
  #        #    birthtime=Mon Aug 04 08:13:49 CDT 2003>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.mode   -> integer
  # -->
  # Returns an integer representing the permission bits of *stat*. The meaning of
  # the bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  #     File.chmod(0644, "testfile")   #=> 1
  #     s = File.stat("testfile")
  #     sprintf("%o", s.mode)          #=> "100644"
  #
  def mode: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.mtime  ->  aTime
  # -->
  # Returns the modification time of *stat*.
  #
  #     File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.nlink   -> integer
  # -->
  # Returns the number of hard links to *stat*.
  #
  #     File.stat("testfile").nlink             #=> 1
  #     File.link("testfile", "testfile.bak")   #=> 0
  #     File.stat("testfile").nlink             #=> 2
  #
  def nlink: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.owned?    -> true or false
  # -->
  # Returns `true` if the effective user id of the process is the same as the
  # owner of *stat*.
  #
  #     File.stat("testfile").owned?      #=> true
  #     File.stat("/etc/passwd").owned?   #=> false
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.pipe?    -> true or false
  # -->
  # Returns `true` if the operating system supports pipes and *stat* is a pipe;
  # `false` otherwise.
  #
  def pipe?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev   ->  integer or nil
  # -->
  # Returns an integer representing the device type on which *stat* resides.
  # Returns `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("/dev/fd1").rdev   #=> 513
  #     File.stat("/dev/tty").rdev   #=> 1280
  #
  def rdev: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_major   #=> 2
  #     File.stat("/dev/tty").rdev_major   #=> 5
  #
  def rdev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_minor   #=> 1
  #     File.stat("/dev/tty").rdev_minor   #=> 0
  #
  def rdev_minor: () -> Integer

  def read: (?int? length, ?string outbuf) -> String?

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable?    -> true or false
  # -->
  # Returns `true` if *stat* is readable by the effective user id of this process.
  #
  #     File.stat("testfile").readable?   #=> true
  #
  def readable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is readable by the real user id of this process.
  #
  #     File.stat("testfile").readable_real?   #=> true
  #
  def readable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setgid?   -> true or false
  # -->
  # Returns `true` if *stat* has the set-group-id permission bit set, `false` if
  # it doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/usr/sbin/lpc").setgid?   #=> true
  #
  def setgid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setuid?    -> true or false
  # -->
  # Returns `true` if *stat* has the set-user-id permission bit set, `false` if it
  # doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/bin/su").setuid?   #=> true
  #
  def setuid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.size    -> integer
  # -->
  # Returns the size of *stat* in bytes.
  #
  #     File.stat("testfile").size   #=> 66
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.size?    -> Integer or nil
  # -->
  # Returns `nil` if *stat* is a zero-length file, the size of the file otherwise.
  #
  #     File.stat("testfile").size?   #=> 66
  #     File.stat("/dev/null").size?  #=> nil
  #
  def size?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.socket?    -> true or false
  # -->
  # Returns `true` if *stat* is a socket, `false` if it isn't or if the operating
  # system doesn't support this feature.
  #
  #     File.stat("testfile").socket?   #=> false
  #
  def socket?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.sticky?    -> true or false
  # -->
  # Returns `true` if *stat* has its sticky bit set, `false` if it doesn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("testfile").sticky?   #=> false
  #
  def sticky?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.symlink?    -> true or false
  # -->
  # Returns `true` if *stat* is a symbolic link, `false` if it isn't or if the
  # operating system doesn't support this feature. As File::stat automatically
  # follows symbolic links, #symlink? will always be `false` for an object
  # returned by File::stat.
  #
  #     File.symlink("testfile", "alink")   #=> 0
  #     File.stat("alink").symlink?         #=> false
  #     File.lstat("alink").symlink?        #=> true
  #
  def symlink?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.uid    -> integer
  # -->
  # Returns the numeric user id of the owner of *stat*.
  #
  #     File.stat("testfile").uid   #=> 501
  #
  def uid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_readable? -> integer or nil
  # -->
  # If *stat* is readable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/etc/passwd").world_readable?  #=> 420
  #     sprintf("%o", m)                              #=> "644"
  #
  def world_readable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_writable?  ->  integer or nil
  # -->
  # If *stat* is writable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/tmp").world_writable?         #=> 511
  #     sprintf("%o", m)                              #=> "777"
  #
  def world_writable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the effective user id of this process.
  #
  #     File.stat("testfile").writable?   #=> true
  #
  def writable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the real user id of this process.
  #
  #     File.stat("testfile").writable_real?   #=> true
  #
  def writable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.zero?    -> true or false
  # -->
  # Returns `true` if *stat* is a zero-length file; `false` otherwise.
  #
  #     File.stat("testfile").zero?   #=> false
  #
  def zero?: () -> bool
end

# <!-- rdoc-file=error.c -->
# Class Exception and its subclasses are used to communicate between
# Kernel#raise and `rescue` statements in `begin ... end` blocks.
#
# An Exception object carries information about an exception:
# *   Its type (the exception's class).
# *   An optional descriptive message.
# *   Optional backtrace information.
#
#
# Some built-in subclasses of Exception have additional methods: e.g.,
# NameError#name.
#
# ## Defaults
#
# Two Ruby statements have default exception classes:
# *   `raise`: defaults to RuntimeError.
# *   `rescue`: defaults to StandardError.
#
#
# ## Global Variables
#
# When an exception has been raised but not yet handled (in `rescue`, `ensure`,
# `at_exit` and `END` blocks), two global variables are set:
# *   `$!` contains the current exception.
# *   `$@` contains its backtrace.
#
#
# ## Custom Exceptions
#
# To provide additional or alternate information, a program may create custom
# exception classes that derive from the built-in exception classes.
#
# A good practice is for a library to create a single "generic" exception class
# (typically a subclass of StandardError or RuntimeError) and have its other
# exception classes derive from that class. This allows the user to rescue the
# generic exception, thus catching all exceptions the library may raise even if
# future versions of the library add new exception subclasses.
#
# For example:
#
#     class MyLibrary
#       class Error < ::StandardError
#       end
#
#       class WidgetError < Error
#       end
#
#       class FrobError < Error
#       end
#
#     end
#
# To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library
# user can rescue MyLibrary::Error.
#
# ## Built-In Exception Classes
#
# The built-in subclasses of Exception are:
#
# *   NoMemoryError
# *   ScriptError
#     *   LoadError
#     *   NotImplementedError
#     *   SyntaxError
#
# *   SecurityError
# *   SignalException
#     *   Interrupt
#
# *   StandardError
#     *   ArgumentError
#         *   UncaughtThrowError
#
#     *   EncodingError
#     *   FiberError
#     *   IOError
#         *   EOFError
#
#     *   IndexError
#         *   KeyError
#         *   StopIteration
#             *   ClosedQueueError
#
#
#     *   LocalJumpError
#     *   NameError
#         *   NoMethodError
#
#     *   RangeError
#         *   FloatDomainError
#
#     *   RegexpError
#     *   RuntimeError
#         *   FrozenError
#
#     *   SystemCallError
#         *   Errno::*
#
#     *   ThreadError
#     *   TypeError
#     *   ZeroDivisionError
#
# *   SystemExit
# *   SystemStackError
# *   fatal
#
class Exception < Object
  # <!--
  #   rdoc-file=error.c
  #   - Exception.to_tty?   ->  true or false
  # -->
  # Returns `true` if exception messages will be sent to a tty.
  #
  def self.to_tty?: () -> bool

  # <!--
  #   rdoc-file=error.c
  #   - exc.exception([string])  ->  an_exception or exc
  # -->
  # With no argument, or if the argument is the same as the receiver, return the
  # receiver. Otherwise, create a new exception object of the same class as the
  # receiver, but with a message equal to `string.to_str`.
  #
  def self.exception: (?String msg) -> Exception

  # <!--
  #   rdoc-file=error.c
  #   - exc == obj   -> true or false
  # -->
  # Equality---If *obj* is not an Exception, returns `false`. Otherwise, returns
  # `true` if *exc* and *obj* share same class, messages, and backtrace.
  #
  def ==: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=error.c
  #   - exception.backtrace    -> array or nil
  # -->
  # Returns any backtrace associated with the exception. The backtrace is an array
  # of strings, each containing either ``filename:lineNo: in `method''' or
  # ``filename:lineNo.''
  #
  #     def a
  #       raise "boom"
  #     end
  #
  #     def b
  #       a()
  #     end
  #
  #     begin
  #       b()
  #     rescue => detail
  #       print detail.backtrace.join("\n")
  #     end
  #
  # *produces:*
  #
  #     prog.rb:2:in `a'
  #     prog.rb:6:in `b'
  #     prog.rb:10
  #
  # In the case no backtrace has been set, `nil` is returned
  #
  #     ex = StandardError.new
  #     ex.backtrace
  #     #=> nil
  #
  def backtrace: () -> ::Array[String]?

  # <!--
  #   rdoc-file=error.c
  #   - exception.backtrace_locations    -> array or nil
  # -->
  # Returns any backtrace associated with the exception. This method is similar to
  # Exception#backtrace, but the backtrace is an array of
  # Thread::Backtrace::Location.
  #
  # This method is not affected by Exception#set_backtrace().
  #
  def backtrace_locations: () -> ::Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=error.c
  #   - exception.cause   -> an_exception or nil
  # -->
  # Returns the previous exception ($!) at the time this exception was raised.
  # This is useful for wrapping exceptions and retaining the original exception
  # information.
  #
  def cause: () -> Exception?

  # <!--
  #   rdoc-file=error.c
  #   - exc.exception([string])  ->  an_exception or exc
  # -->
  # With no argument, or if the argument is the same as the receiver, return the
  # receiver. Otherwise, create a new exception object of the same class as the
  # receiver, but with a message equal to `string.to_str`.
  #
  def exception: () -> self
               | (String arg0) -> Exception

  # <!--
  #   rdoc-file=error.c
  #   - Exception.new(msg = nil)        ->  exception
  #   - Exception.exception(msg = nil)  ->  exception
  # -->
  # Construct a new Exception object, optionally passing in a message.
  #
  def initialize: (?String arg0) -> void

  # <!--
  #   rdoc-file=error.c
  #   - exception.inspect   -> string
  # -->
  # Return this exception's class name and message.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exception.message   ->  string
  # -->
  # Returns the result of invoking `exception.to_s`. Normally this returns the
  # exception's message or name.
  #
  def message: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exc.set_backtrace(backtrace)   ->  array
  # -->
  # Sets the backtrace information associated with `exc`. The `backtrace` must be
  # an array of String objects or a single String in the format described in
  # Exception#backtrace.
  #
  def set_backtrace: (String | ::Array[String] arg0) -> ::Array[String]
                   | (nil) -> nil

  # <!--
  #   rdoc-file=error.c
  #   - exception.to_s   ->  string
  # -->
  # Returns exception's message (or the name of the exception if no message is
  # set).
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exception.full_message(highlight: bool, order: [:top or :bottom]) ->  string
  # -->
  # Returns formatted string of *exception*. The returned string is formatted
  # using the same format that Ruby uses when printing an uncaught exceptions to
  # stderr.
  #
  # If *highlight* is `true` the default error handler will send the messages to a
  # tty.
  #
  # *order* must be either of `:top` or `:bottom`, and places the error message
  # and the innermost backtrace come at the top or the bottom.
  #
  # The default values of these options depend on `$stderr` and its `tty?` at the
  # timing of a call.
  #
  def full_message: (?highlight: bool, ?order: :top | :bottom) -> String
end

# <!-- rdoc-file=complex.c -->
# A complex number can be represented as a paired real number with imaginary
# unit; a+bi.  Where a is real part, b is imaginary part and i is imaginary
# unit.  Real a equals complex a+0i mathematically.
#
# You can create a Complex object explicitly with:
#
# *   A [complex literal](doc/syntax/literals_rdoc.html#label-Complex+Literals).
#
#
# You can convert certain objects to Complex objects with:
#
# *   Method [Complex](Kernel.html#method-i-Complex).
#
#
# Complex object can be created as literal, and also by using Kernel#Complex,
# Complex::rect, Complex::polar or to_c method.
#
#     2+1i                 #=> (2+1i)
#     Complex(1)           #=> (1+0i)
#     Complex(2, 3)        #=> (2+3i)
#     Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
#     3.to_c               #=> (3+0i)
#
# You can also create complex object from floating-point numbers or strings.
#
#     Complex(0.3)         #=> (0.3+0i)
#     Complex('0.3-0.5i')  #=> (0.3-0.5i)
#     Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
#     Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)
#
#     0.3.to_c             #=> (0.3+0i)
#     '0.3-0.5i'.to_c      #=> (0.3-0.5i)
#     '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
#     '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)
#
# A complex object is either an exact or an inexact number.
#
#     Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
#     Complex(1, 1) / 2.0  #=> (0.5+0.5i)
#
class Complex < Numeric
  # <!--
  #   rdoc-file=complex.c
  #   - Complex.polar(abs[, arg])  ->  complex
  # -->
  # Returns a complex object which denotes the given polar form.
  #
  #     Complex.polar(3, 0)            #=> (3.0+0.0i)
  #     Complex.polar(3, Math::PI/2)   #=> (1.836909530733566e-16+3.0i)
  #     Complex.polar(3, Math::PI)     #=> (-3.0+3.673819061467132e-16i)
  #     Complex.polar(3, -Math::PI/2)  #=> (1.836909530733566e-16-3.0i)
  #
  def self.polar: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real[, imag])         ->  complex
  #   - Complex.rectangular(real[, imag])  ->  complex
  # -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  def self.rect: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real[, imag])         ->  complex
  #   - Complex.rectangular(real[, imag])  ->  complex
  # -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  alias self.rectangular self.rect

  public

  # <!--
  #   rdoc-file=complex.c
  #   - cmp * numeric  ->  complex
  # -->
  # Performs multiplication.
  #
  #     Complex(2, 3)  * Complex(2, 3)   #=> (-5+12i)
  #     Complex(900)   * Complex(1)      #=> (900+0i)
  #     Complex(-2, 9) * Complex(-9, 2)  #=> (0-85i)
  #     Complex(9, 8)  * 4               #=> (36+32i)
  #     Complex(20, 9) * 9.8             #=> (196.0+88.2i)
  #
  def *: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp ** numeric  ->  complex
  # -->
  # Performs exponentiation.
  #
  #     Complex('i') ** 2              #=> (-1+0i)
  #     Complex(-8) ** Rational(1, 3)  #=> (1.0000000000000002+1.7320508075688772i)
  #
  def **: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp + numeric  ->  complex
  # -->
  # Performs addition.
  #
  #     Complex(2, 3)  + Complex(2, 3)   #=> (4+6i)
  #     Complex(900)   + Complex(1)      #=> (901+0i)
  #     Complex(-2, 9) + Complex(-9, 2)  #=> (-11+11i)
  #     Complex(9, 8)  + 4               #=> (13+8i)
  #     Complex(20, 9) + 9.8             #=> (29.8+9i)
  #
  def +: (Numeric) -> Complex

  def +@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp - numeric  ->  complex
  # -->
  # Performs subtraction.
  #
  #     Complex(2, 3)  - Complex(2, 3)   #=> (0+0i)
  #     Complex(900)   - Complex(1)      #=> (899+0i)
  #     Complex(-2, 9) - Complex(-9, 2)  #=> (7+7i)
  #     Complex(9, 8)  - 4               #=> (5+8i)
  #     Complex(20, 9) - 9.8             #=> (10.2+9i)
  #
  def -: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - -cmp  ->  complex
  # -->
  # Returns negation of the value.
  #
  #     -Complex(1, 2)  #=> (-1-2i)
  #
  def -@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp / numeric     ->  complex
  #   - cmp.quo(numeric)  ->  complex
  # -->
  # Performs division.
  #
  #     Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
  #     Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
  #     Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
  #     Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
  #     Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)
  #
  def /: (Numeric) -> Complex

  def <: (Numeric) -> bot

  def <=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp <=> object  ->  0, 1, -1, or nil
  # -->
  # If `cmp`'s imaginary part is zero, and `object` is also a real number (or a
  # Complex number where the imaginary part is zero), compare the real part of
  # `cmp` to object.  Otherwise, return nil.
  #
  #     Complex(2, 3)  <=> Complex(2, 3)   #=> nil
  #     Complex(2, 3)  <=> 1               #=> nil
  #     Complex(2)     <=> 1               #=> 1
  #     Complex(2)     <=> 2               #=> 0
  #     Complex(2)     <=> 3               #=> -1
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp == object  ->  true or false
  # -->
  # Returns true if cmp equals object numerically.
  #
  #     Complex(2, 3)  == Complex(2, 3)   #=> true
  #     Complex(5)     == 5               #=> true
  #     Complex(0)     == 0.0             #=> true
  #     Complex('1/3') == 0.33            #=> false
  #     Complex('1/2') == '1/2'           #=> false
  #
  def ==: (untyped) -> bool

  def >: (Numeric) -> bot

  def >=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.abs        ->  real
  #   - cmp.magnitude  ->  real
  # -->
  # Returns the absolute part of its polar form.
  #
  #     Complex(-1).abs         #=> 1
  #     Complex(3.0, -4.0).abs  #=> 5.0
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.abs2  ->  real
  # -->
  # Returns square of the absolute value.
  #
  #     Complex(-1).abs2         #=> 1
  #     Complex(3.0, -4.0).abs2  #=> 25.0
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  def angle: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.arg    ->  float
  #   - cmp.angle  ->  float
  #   - cmp.phase  ->  float
  # -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  alias arg angle

  def ceil: (*untyped) -> bot

  def coerce: (Numeric) -> [ Complex, Complex ]

  # <!-- rdoc-file=complex.c -->
  # Returns the complex conjugate.
  #
  #     Complex(1, 2).conjugate  #=> (1-2i)
  #
  def conj: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.conj       ->  complex
  #   - cmp.conjugate  ->  complex
  # -->
  # Returns the complex conjugate.
  #
  #     Complex(1, 2).conjugate  #=> (1-2i)
  #
  def conjugate: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.denominator  ->  integer
  # -->
  # Returns the denominator (lcm of both denominator - real and imag).
  #
  # See numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> bot

  def divmod: (Numeric) -> bot

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.fdiv(numeric)  ->  complex
  # -->
  # Performs division as each part is a float, never returns a float.
  #
  #     Complex(11, 22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)
  #
  def fdiv: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.finite?  ->  true or false
  # -->
  # Returns `true` if `cmp`'s real and imaginary parts are both finite numbers,
  # otherwise returns `false`.
  #
  def finite?: () -> bool

  def floor: (?Integer) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - hash()
  # -->
  #
  def hash: () -> Integer

  def i: () -> bot

  # <!-- rdoc-file=complex.c -->
  # Returns the imaginary part.
  #
  #     Complex(7).imaginary      #=> 0
  #     Complex(9, -4).imaginary  #=> -4
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.imag       ->  real
  #   - cmp.imaginary  ->  real
  # -->
  # Returns the imaginary part.
  #
  #     Complex(7).imaginary      #=> 0
  #     Complex(9, -4).imaginary  #=> -4
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.infinite?  ->  nil or 1
  # -->
  # Returns `1` if `cmp`'s real or imaginary part is an infinite number, otherwise
  # returns `nil`.
  #
  #     For example:
  #
  #        (1+1i).infinite?                   #=> nil
  #        (Float::INFINITY + 1i).infinite?   #=> 1
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Complex(2).inspect                       #=> "(2+0i)"
  #     Complex('-8/6').inspect                  #=> "((-4/3)+0i)"
  #     Complex('1/2i').inspect                  #=> "(0+(1/2)*i)"
  #     Complex(0, Float::INFINITY).inspect      #=> "(0+Infinity*i)"
  #     Complex(Float::NAN, Float::NAN).inspect  #=> "(NaN+NaN*i)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns the absolute part of its polar form.
  #
  #     Complex(-1).abs         #=> 1
  #     Complex(3.0, -4.0).abs  #=> 5.0
  #
  alias magnitude abs

  def modulo: (Numeric) -> bot

  def negative?: () -> bot

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.numerator  ->  numeric
  # -->
  # Returns the numerator.
  #
  #         1   2       3+4i  <-  numerator
  #         - + -i  ->  ----
  #         2   3        6    <-  denominator
  #
  #     c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)
  #     n = c.numerator          #=> (3+4i)
  #     d = c.denominator        #=> 6
  #     n / d                    #=> ((1/2)+(2/3)*i)
  #     Complex(Rational(n.real, d), Rational(n.imag, d))
  #                              #=> ((1/2)+(2/3)*i)
  #
  # See denominator.
  #
  def numerator: () -> Complex

  # <!-- rdoc-file=complex.c -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.polar  ->  array
  # -->
  # Returns an array; [cmp.abs, cmp.arg].
  #
  #     Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]
  #
  def polar: () -> [ Numeric, Float ]

  def positive?: () -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp / numeric     ->  complex
  #   - cmp.quo(numeric)  ->  complex
  # -->
  # Performs division.
  #
  #     Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
  #     Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
  #     Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
  #     Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
  #     Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)
  #
  def quo: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.rationalize([eps])  ->  rational
  # -->
  # Returns the value as a rational if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1.0/3, 0).rationalize  #=> (1/3)
  #     Complex(1, 0.0).rationalize    # RangeError
  #     Complex(1, 2).rationalize      # RangeError
  #
  # See to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.real  ->  real
  # -->
  # Returns the real part.
  #
  #     Complex(7).real      #=> 7
  #     Complex(9, -4).real  #=> 9
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(1).real?     ->  false
  #   - Complex(1, 2).real?  ->  false
  # -->
  # Returns false, even if the complex number has no imaginary part.
  #
  def real?: () -> false

  # <!-- rdoc-file=complex.c -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.rect         ->  array
  #   - cmp.rectangular  ->  array
  # -->
  # Returns an array; [cmp.real, cmp.imag].
  #
  #     Complex(1, 2).rectangular  #=> [1, 2]
  #
  alias rectangular rect

  def reminder: (Numeric) -> bot

  def round: (*untyped) -> bot

  def step: (*untyped) ?{ (*untyped) -> untyped } -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - complex.to_c  ->  self
  # -->
  # Returns self.
  #
  #     Complex(2).to_c      #=> (2+0i)
  #     Complex(-8, 6).to_c  #=> (-8+6i)
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_f  ->  float
  # -->
  # Returns the value as a float if possible (the imaginary part should be exactly
  # zero).
  #
  #     Complex(1, 0).to_f    #=> 1.0
  #     Complex(1, 0.0).to_f  # RangeError
  #     Complex(1, 2).to_f    # RangeError
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_i  ->  integer
  # -->
  # Returns the value as an integer if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1, 0).to_i    #=> 1
  #     Complex(1, 0.0).to_i  # RangeError
  #     Complex(1, 2).to_i    # RangeError
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_r  ->  rational
  # -->
  # Returns the value as a rational if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1, 0).to_r    #=> (1/1)
  #     Complex(1, 0.0).to_r  # RangeError
  #     Complex(1, 2).to_r    # RangeError
  #
  # See rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_s  ->  string
  # -->
  # Returns the value as a string.
  #
  #     Complex(2).to_s                       #=> "2+0i"
  #     Complex('-8/6').to_s                  #=> "-4/3+0i"
  #     Complex('1/2i').to_s                  #=> "0+1/2i"
  #     Complex(0, Float::INFINITY).to_s      #=> "0+Infinity*i"
  #     Complex(Float::NAN, Float::NAN).to_s  #=> "NaN+NaN*i"
  #
  def to_s: () -> String

  def truncate: (?Integer) -> bot

  def zero?: () -> bool
end

# <!-- rdoc-file=complex.c -->
# The imaginary unit.
#
Complex::I: Complex

%a{annotate:rdoc:skip}
class IO
  # <!-- rdoc-file=io_buffer.c -->
  # IO::Buffer is a low-level efficient buffer for input/output. There are three
  # ways of using buffer:
  #
  # *   Create an empty buffer with ::new, fill it with data using #copy or
  #     #set_value, #set_string, get data with #get_string;
  # *   Create a buffer mapped to some string with ::for, then it could be used
  #     both for reading with #get_string or #get_value, and writing (writing will
  #     change the source string, too);
  # *   Create a buffer mapped to some file with ::map, then it could be used for
  #     reading and writing the underlying file.
  #
  #
  # Interaction with string and file memory is performed by efficient low-level C
  # mechanisms like `memcpy`.
  #
  # The class is meant to be an utility for implementing more high-level
  # mechanisms like Fiber::SchedulerInterface#io_read and
  # Fiber::SchedulerInterface#io_write.
  #
  # **Examples of usage:**
  #
  # Empty buffer:
  #
  #     buffer = IO::Buffer.new(8)  # create empty 8-byte buffer
  #     #  =>
  #     # #<IO::Buffer 0x0000555f5d1a5c50+8 INTERNAL>
  #     # ...
  #     buffer
  #     #  =>
  #     # <IO::Buffer 0x0000555f5d156ab0+8 INTERNAL>
  #     # 0x00000000  00 00 00 00 00 00 00 00
  #     buffer.set_string('test', 2) # put there bytes of the "test" string, starting from offset 2
  #     # => 4
  #     buffer.get_string  # get the result
  #     # => "\x00\x00test\x00\x00"
  #
  # Buffer from string:
  #
  #     string = 'data'
  #     buffer = IO::Buffer.for(str)
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # ...
  #     buffer
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # 0x00000000  64 61 74 61                                     data
  #
  #     buffer.get_string(2)  # read content starting from offset 2
  #     # => "ta"
  #     buffer.set_string('---', 1) # write content, starting from offset 1
  #     # => 3
  #     buffer
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # 0x00000000  64 2d 2d 2d                                     d---
  #     string  # original string changed, too
  #     # => "d---"
  #
  # Buffer from file:
  #
  #     File.write('test.txt', 'test data')
  #     # => 9
  #     buffer = IO::Buffer.map(File.open('test.txt'))
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f0768c000+9 MAPPED IMMUTABLE>
  #     # ...
  #     buffer.get_string(5, 2) # read 2 bytes, starting from offset 5
  #     # => "da"
  #     buffer.set_string('---', 1) # attempt to write
  #     # in `set_string': Buffer is not writable! (IO::Buffer::AccessError)
  #
  #     # To create writable file-mapped buffer
  #     # Open file for read-write, pass size, offset, and flags=0
  #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 9, 0, 0)
  #     buffer.set_string('---', 1)
  #     # => 3 -- bytes written
  #     File.read('test.txt')
  #     # => "t--- data"
  #
  # **The class is experimental and the interface is subject to change.**
  #
  class Buffer
    include Comparable

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.for(string) -> io_buffer
    # -->
    # Creates a IO::Buffer from the given string's memory. The buffer remains
    # associated with the string, and writing to a buffer will update the string's
    # contents.
    #
    # Until #free is invoked on the buffer, either explicitly or via the garbage
    # collector, the source string will be locked and cannot be modified.
    #
    # If the string is frozen, it will create a read-only buffer which cannot be
    # modified.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(str)
    #     buffer.external? #=> true
    #
    #     buffer.get_string(0, 1)
    #     # => "t"
    #     string
    #     # => "best"
    #
    #     buffer.resize(100)
    #     # in `resize': Cannot resize external buffer! (IO::Buffer::AccessError)
    #
    def self.for: (String) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.map(file, [size, [offset, [flags]]]) -> io_buffer
    # -->
    # Create an IO::Buffer for reading from `file` by memory-mapping the file.
    # `file_io` should be a `File` instance, opened for reading.
    #
    # Optional `size` and `offset` of mapping can be specified.
    #
    # By default, the buffer would be immutable (read only); to create a writable
    # mapping, you need to open a file in read-write mode, and explicitly pass
    # `flags` argument without IO::Buffer::IMMUTABLE.
    #
    #     File.write('test.txt', 'test')
    #
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     # => #<IO::Buffer 0x00000001014a0000+4 MAPPED READONLY>
    #
    #     buffer.readonly?   # => true
    #
    #     buffer.get_string
    #     # => "test"
    #
    #     buffer.set_string('b', 0)
    #     # `set_string': Buffer is not writable! (IO::Buffer::AccessError)
    #
    #     # create read/write mapping: length 4 bytes, offset 0, flags 0
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 4, 0)
    #     buffer.set_string('b', 0)
    #     # => 1
    #
    #     # Check it
    #     File.read('test.txt')
    #     # => "best"
    #
    # Note that some operating systems may not have cache coherency between mapped
    # buffers and file reads.
    #
    def self.map: (File file, ?Integer? size, ?Integer offset, ?Integer flags) -> Buffer

    public

    # <!--
    #   rdoc-file=io_buffer.c
    #   - <=>(other) -> true or false
    # -->
    # Buffers are compared by size and exact contents of the memory they are
    # referencing using `memcmp`.
    #
    def <=>: (Buffer) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - clear(value = 0, [offset, [length]]) -> self
    # -->
    # Fill buffer with `value`, starting with `offset` and going for `length` bytes.
    #
    #     buffer = IO::Buffer.for('test')
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  74 65 73 74         test
    #
    #     buffer.clear
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  00 00 00 00         ....
    #
    #     buf.clear(1) # fill with 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 01 01 01         ....
    #
    #     buffer.clear(2, 1, 2) # fill with 2, starting from offset 1, for 2 bytes
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 02 02 01         ....
    #
    #     buffer.clear(2, 1) # fill with 2, starting from offset 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 02 02 02         ....
    #
    def clear: (?Integer value, ?Integer offset, ?Integer length) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - copy(source, [offset, [length, [source_offset]]]) -> size
    # -->
    # Efficiently copy data from a source IO::Buffer into the buffer, at `offset`
    # using `memcpy`. For copying String instances, see #set_string.
    #
    #     buffer = IO::Buffer.new(32)
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5ca22520+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................  *
    #
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # => 4 -- size of data copied
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5cf8fe40+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 74 65 73 74 00 00 00 00 ........test....
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ *
    #
    # #copy can be used to put data into strings associated with buffer:
    #
    #     string= "data:    "
    #     # => "data:    "
    #     buffer = IO::Buffer.for(str)
    #     buffer.copy(IO::Buffer.for("test"), 5)
    #     # => 4
    #     string
    #     # => "data:test"
    #
    # Attempt to copy into a read-only buffer will fail:
    #
    #     File.write('test.txt', 'test')
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # in `copy': Buffer is not writable! (IO::Buffer::AccessError)
    #
    # See ::map for details of creation of mutable file mappings, this will work:
    #
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'))
    #     buffer.copy("boom", 0)
    #     # => 4
    #     File.read('test.txt')
    #     # => "boom"
    #
    # Attempt to copy the data which will need place outside of buffer's bounds will
    # fail:
    #
    #     buffer = IO::Buffer.new(2)
    #     buffer.copy('test', 0)
    #     # in `copy': Specified offset+length exceeds source size! (ArgumentError)
    #
    def copy: (Buffer source, ?Integer offset, ?Integer length, ?Integer source_offset) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - external? -> true or false
    # -->
    # If the buffer is _external_, meaning it references from memory which is not
    #     allocated or mapped by the buffer itself.
    #
    #     A buffer created using ::for has an external reference to the string's
    #     memory.
    #
    # External buffer can't be resized.
    #
    def empty?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - external?()
    # -->
    #
    def external?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - free -> self
    # -->
    # If the buffer references memory, release it back to the operating system.
    # *   for a *mapped* buffer (e.g. from file): unmap.
    # *   for a buffer created from scratch: free memory.
    # *   for a buffer created from string: undo the association.
    #
    #
    # After the buffer is freed, no further operations can't be performed on it.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.free
    #     # => #<IO::Buffer 0x0000000000000000+0 NULL>
    #
    #     buffer.get_value(:U8, 0)
    #     # in `get_value': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.get_string
    #     # in `get_string': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.null?
    #     # => true
    #
    # You can resize a freed buffer to re-allocate it.
    #
    def free: () -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_string([offset, [length, [encoding]]]) -> string
    # -->
    # Read a chunk or all of the buffer into a string, in the specified `encoding`.
    # If no encoding is provided `Encoding::BINARY` is used.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.get_string
    #     # => "test"
    #     buffer.get_string(2)
    #     # => "st"
    #     buffer.get_string(2, 1)
    #     # => "s"
    #
    def get_string: (?Integer offset, ?Integer length, ?Encoding encoding) -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_value(type, offset) -> numeric
    # -->
    # Read from buffer a value of `type` at `offset`. `type` should be one of
    # symbols:
    #
    # *   `:U8`: unsigned integer, 1 byte
    # *   `:S8`: signed integer, 1 byte
    # *   `:u16`: unsigned integer, 2 bytes, little-endian
    # *   `:U16`: unsigned integer, 2 bytes, big-endian
    # *   `:s16`: signed integer, 2 bytes, little-endian
    # *   `:S16`: signed integer, 2 bytes, big-endian
    # *   `:u32`: unsigned integer, 4 bytes, little-endian
    # *   `:U32`: unsigned integer, 4 bytes, big-endian
    # *   `:s32`: signed integer, 4 bytes, little-endian
    # *   `:S32`: signed integer, 4 bytes, big-endian
    # *   `:u64`: unsigned integer, 8 bytes, little-endian
    # *   `:U64`: unsigned integer, 8 bytes, big-endian
    # *   `:s64`: signed integer, 8 bytes, little-endian
    # *   `:S64`: signed integer, 8 bytes, big-endian
    # *   `:f32`: float, 4 bytes, little-endian
    # *   `:F32`: float, 4 bytes, big-endian
    # *   `:f64`: double, 8 bytes, little-endian
    # *   `:F64`: double, 8 bytes, big-endian
    #
    #
    # Example:
    #
    #     string = [1.5].pack('f')
    #     # => "\x00\x00\xC0?"
    #     IO::Buffer.for(string).get_value(:f32, 0)
    #     # => 1.5
    #
    def get_value: (int_get_type, Integer offset) -> Integer
                 | (float_get_type, Integer offset) -> Float

    type int_get_type = :U8 | :S8
                      | :u16 | :U16 | :s16 | :S16
                      | :u32 | :U32 | :s32 | :S32
                      | :u64 | :U64 | :s64 | :S64

    type float_get_type = :f32 | :F32 | :f64 | :F64

    # <!--
    #   rdoc-file=io_buffer.c
    #   - hexdump()
    # -->
    #
    def hexdump: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - internal? -> true or false
    # -->
    # If the buffer is *internal*, meaning it references memory allocated by the
    # buffer itself.
    #
    # An internal buffer is not associated with any external memory (e.g. string) or
    # file mapping.
    #
    # Internal buffers are created using ::new and is the default when the requested
    # size is less than the IO::Buffer::PAGE_SIZE and it was not requested to be
    # mapped on creation.
    #
    # Internal buffers can be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def internal?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked { ... }
    # -->
    # Allows to process a buffer in exclusive way, for concurrency-safety. While the
    # block is performed, the buffer is considered locked, and no other code can
    # enter the lock. Also, locked buffer can't be changed with #resize or #free.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.locked? #=> false
    #
    #     Fiber.schedule do
    #       buffer.locked do
    #         buffer.write(io) # theoretical system call interface
    #       end
    #     end
    #
    #     Fiber.schedule do
    #       # in `locked': Buffer already locked! (IO::Buffer::LockedError)
    #       buffer.locked do
    #         buffer.set_string(...)
    #       end
    #     end
    #
    # The following operations acquire a lock: #resize, #free.
    #
    # Locking is not thread safe. It is designed as a safety net around non-blocking
    # system calls. You can only share a buffer between threads with appropriate
    # synchronisation techniques.
    #
    def locked: [A] () { (IO::Buffer) -> A } -> A

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked? -> true or false
    # -->
    # If the buffer is *locked*, meaning it is inside #locked block execution.
    # Locked buffer can't be resized or freed, and another lock can't be acquired on
    # it.
    #
    # Locking is not thread safe, but is a semantic used to ensure buffers don't
    # move while being used by a system call.
    #
    #     buffer.locked do
    #       buffer.write(io) # theoretical system call interface
    #     end
    #
    def locked?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - mapped? -> true or false
    # -->
    # If the buffer is *mapped*, meaning it references memory mapped by the buffer.
    #
    # Mapped buffers are either anonymous, if created by ::new with the
    # IO::Buffer::MAPPED flag or if the size was at least IO::Buffer::PAGE_SIZE, or
    # backed by a file if created with ::map.
    #
    # Mapped buffers can usually be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def mapped?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - null? -> true or false
    # -->
    # If the buffer was freed with #free or was never allocated in the first place.
    #
    def null?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pread(p1, p2, p3)
    # -->
    #
    def pread: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pwrite(p1, p2, p3)
    # -->
    #
    def pwrite: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - read(p1, p2)
    # -->
    #
    def read: (untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - readonly?()
    # -->
    #
    def readonly?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - resize(new_size) -> self
    # -->
    # Resizes a buffer to a `new_size` bytes, preserving its content. Depending on
    # the old and new size, the memory area associated with the buffer might be
    # either extended, or rellocated at different address with content being copied.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.set_string("test", 0)
    #     buffer.resize(8) # resize to 8 bytes
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5d1a1630+8 INTERNAL>
    #     # 0x00000000  74 65 73 74 00 00 00 00                         test....
    #
    # External buffer (created with ::for), and locked buffer can not be resized.
    #
    def resize: (Integer) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_string(*args)
    # -->
    #
    def set_string: (*untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_value(type, offset, value) -> offset
    # -->
    # Write to a buffer a `value` of `type` at `offset`. `type` should be one of
    # symbols described in #get_value.
    #
    #     buffer = IO::Buffer.new(8)
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00
    #     buffer.set_value(:U8, 1, 111)
    #     # => 1
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 6f 00 00 00 00 00 00                         .o......
    #
    # Note that if the `type` is integer and `value` is Float, the implicit
    # truncation is performed:
    #
    #     buffer = IO::Buffer.new(8)
    #     buffer.set_value(:U32, 0, 2.5)
    #     buffer
    #     #   =>
    #     #  #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     #  0x00000000  00 00 00 02 00 00 00 00
    #     #                       ^^ the same as if we'd pass just integer 2
    #
    def set_value: (int_get_type | float_get_type, Integer offset, Float | Integer value) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - size -> integer
    # -->
    # Returns the size of the buffer that was explicitly set (on creation with ::new
    # or on #resize), or deduced on buffer's creation from string or file.
    #
    def size: () -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - slice(offset, length) -> io_buffer
    # -->
    # Produce another IO::Buffer which is a slice (or view into) the current one
    # starting at `offset` bytes and going for `length` bytes.
    #
    # The slicing happens without copying of memory, and the slice keeps being
    # associated with the original buffer's source (string, or file), if any.
    #
    # Raises RuntimeError if the <tt>offset+length<tt> is out of the current
    # buffer's bounds.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(string)
    #
    #     slice = buffer.slice(1, 2)
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     #  0x00000000  65 73                                           es
    #
    #     # Put "o" into 0s position of the slice
    #     slice.set_string('o', 0)
    #     slice
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     #  0x00000000  6f 73                                           os
    #
    #     # it is also visible at position 1 of the original buffer
    #     buffer
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d31e2d80+4 SLICE>
    #     #  0x00000000  74 6f 73 74                                     tost
    #
    #     # ...and original string
    #     string
    #     # => tost
    #
    def slice: (Integer offset, Integer length) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - to_s -> string
    # -->
    # Short representation of the buffer. It includes the address, size and symbolic
    # flags. This format is subject to change.
    #
    #     puts IO::Buffer.new(4) # uses to_s internally
    #     # #<IO::Buffer 0x000055769f41b1a0+4 INTERNAL>
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - transfer -> new_io_buffer
    # -->
    # Transfers ownership to a new buffer, deallocating the current one.
    #
    #     buffer = IO::Buffer.new('test')
    #     other = buffer.transfer
    #     other
    #     #  =>
    #     # #<IO::Buffer 0x00007f136a15f7b0+4 SLICE>
    #     # 0x00000000  74 65 73 74                                     test
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000000000000000+0 NULL>
    #     buffer.null?
    #     # => true
    #
    def transfer: () -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - valid? -> true or false
    # -->
    # Returns whether the buffer data is accessible.
    #
    # A buffer becomes invalid if it is a slice of another buffer which has been
    # freed.
    #
    def valid?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - write(p1, p2)
    # -->
    #
    def write: (untyped, untyped) -> untyped

    private

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.new([size = DEFAULT_SIZE, [flags = 0]]) -> io_buffer
    # -->
    # Create a new zero-filled IO::Buffer of `size` bytes. By default, the buffer
    # will be *internal*: directly allocated chunk of the memory. But if the
    # requested `size` is more than OS-specific IO::Bufer::PAGE_SIZE, the buffer
    # would be allocated using the virtual memory mechanism (anonymous `mmap` on
    # Unix, `VirtualAlloc` on Windows). The behavior can be forced by passing
    # IO::Buffer::MAPPED as a second parameter.
    #
    # Examples
    #
    #     buffer = IO::Buffer.new(4)
    #     # =>
    #     #  #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     #  0x00000000  00 00 00 00                                     ....
    #
    #     buffer.get_string(0, 1) # => "\x00"
    #
    #     buffer.set_string("test")
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     # 0x00000000  74 65 73 74                                     test
    #
    def initialize: (?Integer size, ?Integer flags) -> void

    BIG_ENDIAN: Integer

    DEFAULT_SIZE: Integer

    EXTERNAL: Integer

    HOST_ENDIAN: Integer

    INTERNAL: Integer

    LITTLE_ENDIAN: Integer

    LOCKED: Integer

    MAPPED: Integer

    NETWORK_ENDIAN: Integer

    PAGE_SIZE: Integer

    PRIVATE: Integer

    READONLY: Integer
  end
end

%a{annotate:rdoc:skip}
class IO
  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.nread -> int
  # -->
  # Returns number of bytes that can be read without blocking. Returns zero if no
  # information available.
  #
  def nread: () -> Integer

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.ready? -> true or false
  # -->
  # Returns `true` if input available without blocking, or `false`.
  #
  def ready?: () -> boolish

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait(events, timeout) -> event mask or false.
  #   - io.wait(timeout = nil, mode = :read) -> event mask or false.
  # -->
  # Waits until the IO becomes ready for the specified events and returns the
  # subset of events that become ready, or `false` when times out.
  #
  # The events can be a bit mask of `IO::READABLE`, `IO::WRITABLE` or
  # `IO::PRIORITY`.
  #
  # Returns `true` immediately when buffered data is available.
  #
  # Optional parameter `mode` is one of `:read`, `:write`, or `:read_write`.
  #
  def wait: (Integer events, ?Numeric timeout) -> (self | bool | nil)
          | (?Numeric? timeout, *wait_mode mode) -> (self | bool | nil)

  type wait_mode = :read | :r | :readable | :write | :w | :writable | :read_write | :rw | :readable_writable

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_readable          -> true or false
  #   - io.wait_readable(timeout) -> true or false
  # -->
  # Waits until IO is readable and returns `true`, or `false` when times out.
  # Returns `true` immediately when buffered data is available.
  #
  def wait_readable: (?Numeric? timeout) -> (self | bool | nil)?

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_writable          -> true or false
  #   - io.wait_writable(timeout) -> true or false
  # -->
  # Waits until IO is writable and returns `true` or `false` when times out.
  #
  def wait_writable: (?Numeric? timeout) -> (self | bool | nil)?
end

# <!-- rdoc-file=numeric.c -->
# An obsolete class, use Integer
#
Fixnum: singleton(Integer)

# <!-- rdoc-file=bignum.c -->
# An obsolete class, use Integer
#
Bignum: singleton(Integer)

# <!-- rdoc-file=enumerator.c -->
# A class which allows both internal and external iteration.
#
# An Enumerator can be created by the following methods.
# *   Object#to_enum
# *   Object#enum_for
# *   Enumerator.new
#
#
# Most methods have two forms: a block form where the contents are evaluated for
# each item in the enumeration, and a non-block form which returns a new
# Enumerator wrapping the iteration.
#
#     enumerator = %w(one two three).each
#     puts enumerator.class # => Enumerator
#
#     enumerator.each_with_object("foo") do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
#     enum_with_obj = enumerator.each_with_object("foo")
#     puts enum_with_obj.class # => Enumerator
#
#     enum_with_obj.each do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
# This allows you to chain Enumerators together.  For example, you can map a
# list's elements to strings containing the index and the element as a string
# via:
#
#     puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
#     # => ["0:foo", "1:bar", "2:baz"]
#
# An Enumerator can also be used as an external iterator. For example,
# Enumerator#next returns the next value of the iterator or raises StopIteration
# if the Enumerator is at the end.
#
#     e = [1,2,3].each   # returns an enumerator object.
#     puts e.next   # => 1
#     puts e.next   # => 2
#     puts e.next   # => 3
#     puts e.next   # raises StopIteration
#
# Note that enumeration sequence by `next`, `next_values`, `peek` and
# `peek_values` do not affect other non-external enumeration methods, unless the
# underlying iteration method itself has side-effect, e.g. IO#each_line.
#
# Moreover, implementation typically uses fibers so performance could be slower
# and exception stacktraces different than expected.
#
# You can use this to implement an internal iterator as follows:
#
#     def ext_each(e)
#       while true
#         begin
#           vs = e.next_values
#         rescue StopIteration
#           return $!.result
#         end
#         y = yield(*vs)
#         e.feed y
#       end
#     end
#
#     o = Object.new
#
#     def o.each
#       puts yield
#       puts yield(1)
#       puts yield(1, 2)
#       3
#     end
#
#     # use o.each as an internal iterator directly.
#     puts o.each {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
#     # convert o.each to an external iterator for
#     # implementing an internal iterator.
#     puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
class Enumerator[unchecked out Elem, out Return] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - enum.each { |elm| block }                    -> obj
  #   - enum.each                                    -> enum
  #   - enum.each(*appending_args) { |elm| block }   -> obj
  #   - enum.each(*appending_args)                   -> an_enumerator
  # -->
  # Iterates over the block according to how this Enumerator was constructed. If
  # no block and no arguments are given, returns self.
  #
  # ### Examples
  #
  #     "Hello, world!".scan(/\w+/)                     #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan, /\w+/).to_a      #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan).each(/\w+/).to_a #=> ["Hello", "world"]
  #
  #     obj = Object.new
  #
  #     def obj.each_arg(a, b=:b, *rest)
  #       yield a
  #       yield b
  #       yield rest
  #       :method_returned
  #     end
  #
  #     enum = obj.to_enum :each_arg, :a, :x
  #
  #     enum.each.to_a                  #=> [:a, :x, []]
  #     enum.each.equal?(enum)          #=> true
  #     enum.each { |elm| elm }         #=> :method_returned
  #
  #     enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]
  #     enum.each(:y, :z).equal?(enum)  #=> false
  #     enum.each(:y, :z) { |elm| elm } #=> :method_returned
  #
  def each: () { (Elem arg0) -> untyped } -> Return
          | () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.feed obj   -> nil
  # -->
  # Sets the value to be returned by the next yield inside `e`.
  #
  # If the value is not set, the yield returns nil.
  #
  # This value is cleared after being yielded.
  #
  #     # Array#map passes the array's elements to "yield" and collects the
  #     # results of "yield" as an array.
  #     # Following example shows that "next" returns the passed elements and
  #     # values passed to "feed" are collected as an array which can be
  #     # obtained by StopIteration#result.
  #     e = [1,2,3].map
  #     p e.next           #=> 1
  #     e.feed "a"
  #     p e.next           #=> 2
  #     e.feed "b"
  #     p e.next           #=> 3
  #     e.feed "c"
  #     begin
  #       e.next
  #     rescue StopIteration
  #       p $!.result      #=> ["a", "b", "c"]
  #     end
  #
  #     o = Object.new
  #     def o.each
  #       x = yield         # (2) blocks
  #       p x               # (5) => "foo"
  #       x = yield         # (6) blocks
  #       p x               # (8) => nil
  #       x = yield         # (9) blocks
  #       p x               # not reached w/o another e.next
  #     end
  #
  #     e = o.to_enum
  #     e.next              # (1)
  #     e.feed "foo"        # (3)
  #     e.next              # (4)
  #     e.next              # (7)
  #                         # (10)
  #
  def feed: (Elem arg0) -> NilClass

  # <!--
  #   rdoc-file=enumerator.c
  #   - Enumerator.new(size = nil) { |yielder| ... }
  # -->
  # Creates a new Enumerator object, which can be used as an Enumerable.
  #
  # Iteration is defined by the given block, in which a "yielder" object, given as
  # block parameter, can be used to yield a value by calling the `yield` method
  # (aliased as `<<`):
  #
  #     fib = Enumerator.new do |y|
  #       a = b = 1
  #       loop do
  #         y << a
  #         a, b = b, a + b
  #       end
  #     end
  #
  #     fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
  #
  # The optional parameter can be used to specify how to calculate the size in a
  # lazy fashion (see Enumerator#size). It can either be a value or a callable
  # object.
  #
  def initialize: (?Integer arg0) { (Enumerator::Yielder arg0) -> void } -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.inspect  -> string
  # -->
  # Creates a printable version of *e*.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next   -> object
  # -->
  # Returns the next object in the enumerator, and move the internal position
  # forward.  When the position reached at the end, StopIteration is raised.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.next   #raises StopIteration
  #
  # See class-level notes about external iterators.
  #
  def next: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next_values   -> array
  # -->
  # Returns the next object as an array in the enumerator, and move the internal
  # position forward.  When the position reached at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # This method can be used to distinguish `yield` and `yield nil`.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #       yield nil
  #       yield [1, 2]
  #     end
  #     e = o.to_enum
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     e = o.to_enum
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #
  #     ## yield args       next_values      next
  #     #  yield            []               nil
  #     #  yield 1          [1]              1
  #     #  yield 1, 2       [1, 2]           [1, 2]
  #     #  yield nil        [nil]            nil
  #     #  yield [1, 2]     [[1, 2]]         [1, 2]
  #
  def next_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek   -> object
  # -->
  # Returns the next object in the enumerator, but doesn't move the internal
  # position forward.  If the position is already at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.peek   #raises StopIteration
  #
  def peek: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek_values   -> array
  # -->
  # Returns the next object as an array, similar to Enumerator#next_values, but
  # doesn't move the internal position forward.  If the position is already at the
  # end, StopIteration is raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #     end
  #     e = o.to_enum
  #     p e.peek_values    #=> []
  #     e.next
  #     p e.peek_values    #=> [1]
  #     p e.peek_values    #=> [1]
  #     e.next
  #     p e.peek_values    #=> [1, 2]
  #     e.next
  #     p e.peek_values    # raises StopIteration
  #
  def peek_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.rewind   -> e
  # -->
  # Rewinds the enumeration sequence to the beginning.
  #
  # If the enclosed object responds to a "rewind" method, it is called.
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.size          -> int, Float::INFINITY or nil
  # -->
  # Returns the size of the enumerator, or `nil` if it can't be calculated lazily.
  #
  #     (1..100).to_a.permutation(4).size # => 94109400
  #     loop.size # => Float::INFINITY
  #     (1..100).drop_while.size # => nil
  #
  def size: () -> (Integer | Float)?

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.with_index(offset = 0) {|(*args), idx| ... }
  #   - e.with_index(offset = 0)
  # -->
  # Iterates the given block for each element with an index, which starts from
  # `offset`.  If no block is given, returns a new Enumerator that includes the
  # index, starting from `offset`
  #
  # `offset`
  # :   the starting index to use
  #
  def with_index: (?Integer offset) { (Elem arg0, Integer arg1) -> untyped } -> Return
                | (?Integer offset) -> ::Enumerator[[ Elem, Integer ], Return]

  # <!-- rdoc-file=enumerator.c -->
  # Iterates the given block for each element with an arbitrary object, `obj`, and
  # returns `obj`
  #
  # If no block is given, returns a new Enumerator.
  #
  # ### Example
  #
  #     to_three = Enumerator.new do |y|
  #       3.times do |x|
  #         y << x
  #       end
  #     end
  #
  #     to_three_with_string = to_three.with_object("foo")
  #     to_three_with_string.each do |x,string|
  #       puts "#{string}: #{x}"
  #     end
  #
  #     # => foo: 0
  #     # => foo: 1
  #     # => foo: 2
  #
  def with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                 | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]
end

# <!-- rdoc-file=enumerator.c -->
# Generator
#
class Enumerator::Generator[out Elem] < Object
  include Enumerable[Elem]

  def each: () { (Elem) -> void } -> void
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Lazy is a special type of Enumerator, that allows constructing
# chains of operations without evaluating them immediately, and evaluating
# values on as-needed basis. In order to do so it redefines most of Enumerable
# methods so that they just construct another lazy enumerator.
#
# Enumerator::Lazy can be constructed from any Enumerable with the
# Enumerable#lazy method.
#
#     lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
#     # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>
#
# The real enumeration is performed when any non-redefined Enumerable method is
# called, like Enumerable#first or Enumerable#to_a (the latter is aliased as
# #force for more semantic code):
#
#     lazy.first(2)
#     #=> [21, 23]
#
#     lazy.force
#     #=> [21, 23, 25, 27, 29]
#
# Note that most Enumerable methods that could be called with or without a
# block, on Enumerator::Lazy will always require a block:
#
#     [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
#     [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block
#
# This class allows idiomatic calculations on long or infinite sequences, as
# well as chaining of calculations without constructing intermediate arrays.
#
# Example for working with a slowly calculated sequence:
#
#     require 'open-uri'
#
#     # This will fetch all URLs before selecting
#     # necessary data
#     URLS.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
#     # This will fetch URLs one-by-one, only till
#     # there is enough data to satisfy the condition
#     URLS.lazy.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
# Ending a chain with ".eager" generates a non-lazy enumerator, which is
# suitable for returning or passing to another method that expects a normal
# enumerator.
#
#     def active_items
#       groups
#         .lazy
#         .flat_map(&:items)
#         .reject(&:disabled)
#         .eager
#     end
#
#     # This works lazily; if a checked item is found, it stops
#     # iteration and does not look into remaining groups.
#     first_checked = active_items.find(&:checked)
#
#     # This returns an array of items like a normal enumerator does.
#     all_checked = active_items.select(&:checked)
#
class Enumerator::Lazy[out Elem, out Return] < Enumerator[Elem, Return]
  # <!-- rdoc-file=enumerator.c -->
  # Expands `lazy` enumerator to an array. See Enumerable#to_a.
  #
  alias force to_a

  # <!--
  #   rdoc-file=enumerator.c
  #   - lazy.compact                  -> lazy_enumerator
  # -->
  # Like Enumerable#compact, but chains operation to be lazy-evaluated.
  #
  def compact: () -> Enumerator::Lazy[Elem, Return]
end

# <!-- rdoc-file=enumerator.c -->
# Yielder
#
class Enumerator::Yielder < Object
  def <<: (untyped arg0) -> void

  def yield: (*untyped arg0) -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - to_proc()
  # -->
  # Returns a Proc object that takes arguments and yields them.
  #
  # This method is implemented so that a Yielder object can be directly passed to
  # another method as a block argument.
  #
  #     enum = Enumerator.new { |y|
  #       Dir.glob("*.rb") { |file|
  #         File.open(file) { |f| f.each_line(&y) }
  #       }
  #     }
  #
  def to_proc: () -> Proc
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Chain is a subclass of Enumerator, which represents a chain of
# enumerables that works as a single enumerator.
#
# This type of objects can be created by Enumerable#chain and Enumerator#+.
#
class Enumerator::Chain[out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - obj.each(*args) { |...| ... } -> obj
  #   - obj.each(*args) -> enumerator
  # -->
  # Iterates over the elements of the first enumerable by calling the "each"
  # method on it with the given arguments, then proceeds to the following
  # enumerables in sequence until all of the enumerables are exhausted.
  #
  # If no block is given, returns an enumerator.
  #
  def each: () { (Elem) -> void } -> void
end

# <!-- rdoc-file=vm.c -->
# The RubyVM module only exists on MRI. `RubyVM` is not defined in other Ruby
# implementations such as JRuby and TruffleRuby.
#
# The RubyVM module provides some access to MRI internals. This module is for
# very limited purposes, such as debugging, prototyping, and research.  Normal
# users must not use it. This module is not portable between Ruby
# implementations.
#
class RubyVM < Object
end

# <!-- rdoc-file=vm.c -->
# DEFAULT_PARAMS This constant exposes the VM's default parameters. Note that
# changing these values does not affect VM execution. Specification is not
# stable and you should not depend on this value. Of course, this constant is
# MRI specific.
#
RubyVM::DEFAULT_PARAMS: Hash[Symbol, Integer]

# <!-- rdoc-file=vm.c -->
# INSTRUCTION_NAMES A list of bytecode instruction names in MRI. This constant
# is MRI specific.
#
RubyVM::INSTRUCTION_NAMES: Array[String]

# <!-- rdoc-file=vm.c -->
# OPTS An Array of VM build options. This constant is MRI specific.
#
RubyVM::OPTS: Array[String]

# <!-- rdoc-file=iseq.c -->
# The InstructionSequence class represents a compiled sequence of instructions
# for the Virtual Machine used in MRI. Not all implementations of Ruby may
# implement this class, and for the implementations that implement it, the
# methods defined and behavior of the methods can change in any version.
#
# With it, you can get a handle to the instructions that make up a method or a
# proc, compile strings of Ruby code down to VM instructions, and disassemble
# instruction sequences to strings for easy inspection. It is mostly useful if
# you want to learn how YARV works, but it also lets you control various
# settings for the Ruby iseq compiler.
#
# You can find the source for the VM instructions in `insns.def` in the Ruby
# source.
#
# The instruction sequence results will almost certainly change as Ruby changes,
# so example output in this documentation may be different from what you see.
#
# Of course, this class is MRI specific.
#
class RubyVM::InstructionSequence < Object
end

# <!-- rdoc-file=ext/stringio/stringio.c -->
# Pseudo I/O on String object, with interface corresponding to IO.
#
# Commonly used to simulate `$stdio` or `$stderr`
#
# ### Examples
#
#     require 'stringio'
#
#     # Writing stream emulation
#     io = StringIO.new
#     io.puts "Hello World"
#     io.string #=> "Hello World\n"
#
#     # Reading stream emulation
#     io = StringIO.new "first\nsecond\nlast\n"
#     io.getc #=> "f"
#     io.gets #=> "irst\n"
#     io.read #=> "second\nlast\n"
#
class StringIO
  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.new(string=""[, mode])
  # -->
  # Creates new StringIO instance from with *string* and *mode*.
  #
  def initialize: (?String string, ?String? mode) -> void

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.open(string=""[, mode]) {|strio| ...}
  # -->
  # Equivalent to StringIO.new except that when it is called with a block, it
  # yields with the new instance and closes it, and returns the result which
  # returned from the block.
  #
  def self.open: [U] (?String string, ?String? mode) { (StringIO arg) -> U } -> U

  def <<: (untyped arg0) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.binmode    -> stringio
  # -->
  # Puts stream into binary mode. See IO#binmode.
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close  -> nil
  # -->
  # Closes a StringIO. The stream is unavailable for any further data operations;
  # an `IOError` is raised if such an attempt is made.
  #
  def close: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close_read    -> nil
  # -->
  # Closes the read end of a StringIO.  Will raise an `IOError` if the receiver is
  # not readable.
  #
  def close_read: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close_write    -> nil
  # -->
  # Closes the write end of a StringIO.  Will raise an  `IOError` if the receiver
  # is not writeable.
  #
  def close_write: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed?    -> true or false
  # -->
  # Returns `true` if the stream is completely closed, `false` otherwise.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed_read?    -> true or false
  # -->
  # Returns `true` if the stream is not readable, `false` otherwise.
  #
  def closed_read?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed_write?    -> true or false
  # -->
  # Returns `true` if the stream is not writable, `false` otherwise.
  #
  def closed_write?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each(sep=$/, chomp: false) {|line| block }         -> strio
  #   - strio.each(limit, chomp: false) {|line| block }          -> strio
  #   - strio.each(sep, limit, chomp: false) {|line| block }     -> strio
  #   - strio.each(...)                                          -> anEnumerator
  #   - strio.each_line(sep=$/, chomp: false) {|line| block }     -> strio
  #   - strio.each_line(limit, chomp: false) {|line| block }      -> strio
  #   - strio.each_line(sep, limit, chomp: false) {|line| block } -> strio
  #   - strio.each_line(...)                                      -> anEnumerator
  # -->
  # See IO#each.
  #
  def each: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
          | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_byte {|byte| block }  -> strio
  #   - strio.each_byte                  -> anEnumerator
  # -->
  # See IO#each_byte.
  #
  def each_byte: () { (Integer arg0) -> untyped } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_char {|char| block }  -> strio
  #   - strio.each_char                  -> anEnumerator
  # -->
  # See IO#each_char.
  #
  def each_char: () { (String arg0) -> untyped } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_codepoint {|c| block }  -> strio
  #   - strio.each_codepoint               -> anEnumerator
  # -->
  # See IO#each_codepoint.
  #
  def each_codepoint: () { (Integer arg0) -> untyped } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.eof     -> true or false
  #   - strio.eof?    -> true or false
  # -->
  # Returns true if the stream is at the end of the data (underlying string). The
  # stream must be opened for reading or an `IOError` will be raised.
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fcntl(*args)
  # -->
  # Raises NotImplementedError.
  #
  def fcntl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fileno()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def fileno: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - flush()
  # -->
  # Returns an object itself.  Just for compatibility to IO.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fsync()
  # -->
  # Returns 0.  Just for compatibility to IO.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.getbyte   -> fixnum or nil
  # -->
  # See IO#getbyte.
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.getc   -> string or nil
  # -->
  # See IO#getc.
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.gets(sep=$/, chomp: false)     -> string or nil
  #   - strio.gets(limit, chomp: false)      -> string or nil
  #   - strio.gets(sep, limit, chomp: false) -> string or nil
  # -->
  # See IO#gets.
  #
  def gets: (?String sep, ?Integer limit, ?chomp: boolish) -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.internal_encoding   => encoding
  # -->
  # Returns the Encoding of the internal string if conversion is specified.
  # Otherwise returns `nil`.
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.external_encoding   => encoding
  # -->
  # Returns the Encoding object that represents the encoding of the file. If the
  # stream is write mode and no encoding is specified, returns `nil`.
  #
  def external_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - isatty()
  # -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.lineno    -> integer
  # -->
  # Returns the current line number. The stream must be opened for reading.
  # `lineno` counts the number of times  `gets` is called, rather than the number
  # of newlines  encountered. The two values will differ if `gets` is  called with
  # a separator other than newline.  See also the  `$.` variable.
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.lineno = integer    -> integer
  # -->
  # Manually sets the current line number to the given value. `$.` is updated only
  # on the next read.
  #
  def lineno=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pid()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def pid: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos     -> integer
  #   - strio.tell    -> integer
  # -->
  # Returns the current offset (in bytes).
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos = integer    -> integer
  # -->
  # Seeks to the given position (in bytes).
  #
  def pos=: (Integer arg0) -> Integer

  def print: (*untyped arg0) -> nil

  def printf: (String format_string, *untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.putc(obj)    -> obj
  # -->
  # See IO#putc.
  #
  def putc: (Numeric | String arg0) -> untyped

  def puts: (*untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.read([length [, outbuf]])    -> string, outbuf, or nil
  # -->
  # See IO#read.
  #
  def read: (?int? length, ?string outbuf) -> String?

  def read_nonblock: (int len, ?string buf) -> String

  def readbyte: () -> Integer

  def readchar: () -> String

  def readline: (?String sep, ?Integer limit) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.readlines(sep=$/, chomp: false)     ->   array
  #   - strio.readlines(limit, chomp: false)      ->   array
  #   - strio.readlines(sep, limit, chomp: false) ->   array
  # -->
  # See IO#readlines.
  #
  def readlines: (?String sep, ?Integer limit, ?chomp: boolish) -> ::Array[String]

  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.reopen(other_StrIO)     -> strio
  #   - strio.reopen(string, mode)    -> strio
  # -->
  # Reinitializes the stream with the given *other_StrIO* or *string* and *mode*
  # (see StringIO#new).
  #
  def reopen: (StringIO other) -> self
            | (String other, ?String mode_str) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.rewind    -> 0
  # -->
  # Positions the stream to the beginning of input, resetting `lineno` to zero.
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.seek(amount, whence=SEEK_SET) -> 0
  # -->
  # Seeks to a given offset *amount* in the stream according to the value of
  # *whence* (see IO#seek).
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.set_encoding(ext_enc, [int_enc[, opt]])  => strio
  # -->
  # Specify the encoding of the StringIO as *ext_enc*. Use the default external
  # encoding if *ext_enc* is nil. 2nd argument *int_enc* and optional hash *opt*
  # argument are ignored; they are for API compatibility to IO.
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.string     -> string
  # -->
  # Returns underlying String object, the subject of IO.
  #
  def string: () -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.string = string  -> string
  # -->
  # Changes underlying String object, the subject of IO.
  #
  def string=: (String str) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.length -> integer
  #   - strio.size   -> integer
  # -->
  # Returns the size of the buffer string.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.sync    -> true
  # -->
  # Returns `true` always.
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - sync=(p1)
  # -->
  # Returns the argument unchanged.  Just for compatibility to IO.
  #
  def sync=: (boolish) -> bool

  def sysread: (Integer maxlen, String outbuf) -> String

  def syswrite: (String arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos     -> integer
  #   - strio.tell    -> integer
  # -->
  # Returns the current offset (in bytes).
  #
  def tell: () -> Integer

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def tty?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.ungetbyte(fixnum)   -> nil
  # -->
  # See IO#ungetbyte
  #
  def ungetbyte: (String | Integer arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.ungetc(string)   -> nil
  # -->
  # Pushes back one character (passed as a parameter) such that a subsequent
  # buffered read will return it.  There is no limitation for multiple pushbacks
  # including pushing back behind the beginning of the buffer string.
  #
  def ungetc: (String arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.write(string, ...) -> integer
  #   - strio.syswrite(string)   -> integer
  # -->
  # Appends the given string to the underlying buffer string. The stream must be
  # opened for writing.  If the argument is not a string, it will be converted to
  # a string using `to_s`. Returns the number of bytes written.  See IO#write.
  #
  def write: (String arg0) -> Integer

  # This is a deprecated alias for #each_byte.
  #
  def bytes: () { (Integer arg0) -> untyped } -> self
           | () -> ::Enumerator[Integer, self]

  # This is a deprecated alias for #each_char.
  #
  def chars: () { (String arg0) -> untyped } -> self
           | () -> ::Enumerator[String, self]

  # This is a deprecated alias for #each_codepoint.
  #
  def codepoints: () { (Integer arg0) -> untyped } -> self
                | () -> ::Enumerator[Integer, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # See IO#each.
  #
  def each_line: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
               | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns true if the stream is at the end of the data (underlying string). The
  # stream must be opened for reading or an `IOError` will be raised.
  #
  def eof?: () -> bool

  # This is a deprecated alias for #each_line.
  #
  def lines: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
           | (?String sep, ?Integer limit) -> ::Enumerator[String, self]
end

# <!-- rdoc-file=object.c -->
# BasicObject is the parent class of all classes in Ruby.  It's an explicit
# blank class.
#
# BasicObject can be used for creating object hierarchies independent of Ruby's
# object hierarchy, proxy objects like the Delegator class, or other uses where
# namespace pollution from Ruby's methods and classes must be avoided.
#
# To avoid polluting BasicObject for other users an appropriately named subclass
# of BasicObject should be created instead of directly modifying BasicObject:
#
#     class MyObjectSystem < BasicObject
#     end
#
# BasicObject does not include Kernel (for methods like `puts`) and BasicObject
# is outside of the namespace of the standard library so common classes will not
# be found without using a full class path.
#
# A variety of strategies can be used to provide useful portions of the standard
# library to subclasses of BasicObject.  A subclass could `include Kernel` to
# obtain `puts`, `exit`, etc.  A custom Kernel-like module could be created and
# included or delegation can be used via #method_missing:
#
#     class MyObjectSystem < BasicObject
#       DELEGATE = [:puts, :p]
#
#       def method_missing(name, *args, &block)
#         return super unless DELEGATE.include? name
#         ::Kernel.send(name, *args, &block)
#       end
#
#       def respond_to_missing?(name, include_private = false)
#         DELEGATE.include?(name) or super
#       end
#     end
#
# Access to classes and modules from the Ruby standard library can be obtained
# in a BasicObject subclass by referencing the desired constant from the root
# like `::File` or `::Enumerator`. Like #method_missing, #const_missing can be
# used to delegate constant lookup to `Object`:
#
#     class MyObjectSystem < BasicObject
#       def self.const_missing(name)
#         ::Object.const_get(name)
#       end
#     end
#
# ### What's Here
#
# These are the methods defined for BasicObject:
#
#     ::new
# :       Returns a new BasicObject instance.
#
#     [!](#method-i-21)
# :       Returns the boolean negation of `self`: `true` or `false`.
#
#     [!=](#method-i-21-3D)
# :       Returns whether `self` and the given object are *not* equal.
#
#     [==](#method-i-3D-3D)
# :       Returns whether `self` and the given object are equivalent.
#
#     [__id__](#method-i-__id__)
# :       Returns the integer object identifier for `self`.
#
#     [__send__](#method-i-__send__)
# :       Calls the method identified by the given symbol.
#
#     #equal?
# :       Returns whether `self` and the given object are the same object.
#
#     #instance_eval
# :       Evaluates the given string or block in the context of `self`.
#
#     #instance_exec
# :       Executes the given block in the context of `self`, passing the given
#         arguments.
#
#     #method_missing
# :       Method called when an undefined method is called on `self`.
#
#     #singleton_method_added
# :       Method called when a singleton method is added to `self`.
#
#     #singleton_method_removed
# :       Method called when a singleton method is added removed from `self`.
#
#     #singleton_method_undefined
# :       Method called when a singleton method is undefined in `self`.
#
class BasicObject
  # <!--
  #   rdoc-file=object.c
  #   - !obj    -> true or false
  # -->
  # Boolean negate.
  #
  def !: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj != other        -> true or false
  # -->
  # Returns true if two objects are not-equal, otherwise false.
  #
  def !=: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  def __id__: () -> Integer

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  def __send__: (String | Symbol arg0, *untyped args) -> untyped

  # <!-- rdoc-file=object.c -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def equal?: (untyped other) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_eval(string [, filename [, lineno]] )   -> obj
  #   - obj.instance_eval {|obj| block }                     -> obj
  # -->
  # Evaluates a string containing Ruby source code, or the given block, within the
  # context of the receiver (*obj*). In order to set the context, the variable
  # `self` is set to *obj* while the code is executing, giving the code access to
  # *obj*'s instance variables and private methods.
  #
  # When `instance_eval` is given a block, *obj* is also passed in as the block's
  # only argument.
  #
  # When `instance_eval` is given a `String`, the optional second and third
  # parameters supply a filename and starting line number that are used when
  # reporting compilation errors.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #       private
  #       def the_secret
  #         "Ssssh! The secret is #{@secret}."
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_eval { @secret }          #=> 99
  #     k.instance_eval { the_secret }       #=> "Ssssh! The secret is 99."
  #     k.instance_eval {|obj| obj == self } #=> true
  #
  def instance_eval: (String, ?String filename, ?Integer lineno) -> untyped
                   | [U] () { (self) -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_exec(arg...) {|var...| block }                       -> obj
  # -->
  # Executes the given block within the context of the receiver (*obj*). In order
  # to set the context, the variable `self` is set to *obj* while the code is
  # executing, giving the code access to *obj*'s instance variables.  Arguments
  # are passed as block parameters.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_exec(5) {|x| @secret+x }   #=> 104
  #
  def instance_exec: [U, V] (*V args) { (*V args) -> U } -> U

  # <!--
  #   rdoc-file=object.c
  #   - BasicObject.new
  # -->
  # Returns a new BasicObject.
  #
  def initialize: () -> void

  private

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.method_missing(symbol [, *args] )   -> result
  # -->
  # Invoked by Ruby when *obj* is sent a message it cannot handle. *symbol* is the
  # symbol for the method called, and *args* are any arguments that were passed to
  # it. By default, the interpreter raises an error when this method is called.
  # However, it is possible to override the method to provide more dynamic
  # behavior. If it is decided that a particular method should not be handled,
  # then *super* should be called, so that ancestors can pick up the missing
  # method. The example below creates a class `Roman`, which responds to methods
  # with names consisting of roman numerals, returning the corresponding integer
  # values.
  #
  #     class Roman
  #       def roman_to_int(str)
  #         # ...
  #       end
  #
  #       def method_missing(symbol, *args)
  #         str = symbol.id2name
  #         begin
  #           roman_to_int(str)
  #         rescue
  #           super(symbol, *args)
  #         end
  #       end
  #     end
  #
  #     r = Roman.new
  #     r.iv      #=> 4
  #     r.xxiii   #=> 23
  #     r.mm      #=> 2000
  #     r.foo     #=> NoMethodError
  #
  def method_missing: (Symbol, *untyped, **untyped) ?{ (*untyped, **untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_added(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is added to the receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_added(id)
  #         puts "Adding #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #     end
  #
  # *produces:*
  #
  #     Adding singleton_method_added
  #     Adding one
  #     Adding three
  #
  def singleton_method_added: (Symbol) -> void

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_removed(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_removed(id)
  #         puts "Removing #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #       class << self
  #         remove_method :three
  #         remove_method :one
  #       end
  #     end
  #
  # *produces:*
  #
  #     Removing three
  #     Removing one
  #
  def singleton_method_removed: (Symbol) -> void

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_undefined(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is undefined in the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_undefined(id)
  #         puts "Undefining #{id.id2name}"
  #       end
  #       def Chatty.one()   end
  #       class << self
  #          undef_method(:one)
  #       end
  #     end
  #
  # *produces:*
  #
  #     Undefining one
  #
  def singleton_method_undefined: (Symbol) -> void
end

# <!-- rdoc-file=marshal.c -->
# The marshaling library converts collections of Ruby objects into a byte
# stream, allowing them to be stored outside the currently active script. This
# data may subsequently be read and the original objects reconstituted.
#
# Marshaled data has major and minor version numbers stored along with the
# object information. In normal use, marshaling can only load data written with
# the same major version number and an equal or lower minor version number. If
# Ruby's ``verbose'' flag is set (normally using -d, -v, -w, or --verbose) the
# major and minor numbers must match exactly. Marshal versioning is independent
# of Ruby's version numbers. You can extract the version by reading the first
# two bytes of marshaled data.
#
#     str = Marshal.dump("thing")
#     RUBY_VERSION   #=> "1.9.0"
#     str[0].ord     #=> 4
#     str[1].ord     #=> 8
#
# Some objects cannot be dumped: if the objects to be dumped include bindings,
# procedure or method objects, instances of class IO, or singleton objects, a
# TypeError will be raised.
#
# If your class has special serialization needs (for example, if you want to
# serialize in some specific format), or if it contains objects that would
# otherwise not be serializable, you can implement your own serialization
# strategy.
#
# There are two methods of doing this, your object can define either
# marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
# precedence over _dump if both are defined.  marshal_dump may result in smaller
# Marshal strings.
#
# ## Security considerations
#
# By design, Marshal.load can deserialize almost any class loaded into the Ruby
# process. In many cases this can lead to remote code execution if the Marshal
# data is loaded from an untrusted source.
#
# As a result, Marshal.load is not suitable as a general purpose serialization
# format and you should never unmarshal user supplied input or other untrusted
# data.
#
# If you need to deserialize untrusted data, use JSON or another serialization
# format that is only able to load simple, 'primitive' types such as String,
# Array, Hash, etc. Never allow user input to specify arbitrary types to
# deserialize into.
#
# ## marshal_dump and marshal_load
#
# When dumping an object the method marshal_dump will be called. marshal_dump
# must return a result containing the information necessary for marshal_load to
# reconstitute the object.  The result can be any object.
#
# When loading an object dumped using marshal_dump the object is first allocated
# then marshal_load is called with the result from marshal_dump. marshal_load
# must recreate the object from the information in the result.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def marshal_dump
#         [@name, @version]
#       end
#
#       def marshal_load array
#         @name, @version = array
#       end
#     end
#
# ## _dump and _load
#
# Use _dump and _load when you need to allocate the object you're restoring
# yourself.
#
# When dumping an object the instance method _dump is called with an Integer
# which indicates the maximum depth of objects to dump (a value of -1 implies
# that you should disable depth checking).  _dump must return a String
# containing the information necessary to reconstitute the object.
#
# The class method _load should take a String and use it to return an object of
# the same class.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def _dump level
#         [@name, @version].join ':'
#       end
#
#       def self._load args
#         new(*args.split(':'))
#       end
#     end
#
# Since Marshal.dump outputs a string you can have _dump return a Marshal string
# which is Marshal.loaded in _load for complex objects.
#
module Marshal
  # <!--
  #   rdoc-file=marshal.c
  #   - dump( obj [, anIO] , limit=-1 ) -> anIO
  # -->
  # Serializes obj and all descendant objects. If anIO is specified, the
  # serialized data will be written to it, otherwise the data will be returned as
  # a String. If limit is specified, the traversal of subobjects will be limited
  # to that depth. If limit is negative, no checking of depth will be performed.
  #
  #     class Klass
  #       def initialize(str)
  #         @str = str
  #       end
  #       def say_hello
  #         @str
  #       end
  #     end
  #
  # (produces no output)
  #
  #     o = Klass.new("hello\n")
  #     data = Marshal.dump(o)
  #     obj = Marshal.load(data)
  #     obj.say_hello  #=> "hello\n"
  #
  # Marshal can't dump following objects:
  # *   anonymous Class/Module.
  # *   objects which are related to system (ex: Dir, File::Stat, IO, File, Socket
  #     and so on)
  # *   an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,
  #     ThreadGroup, Continuation
  # *   objects which define singleton methods
  #
  def self.dump: (untyped obj, untyped port, ?Integer limit) -> untyped
               | (untyped obj, ?Integer limit) -> String

  # <!--
  #   rdoc-file=marshal.rb
  #   - load(source, proc = nil, freeze: false) -> obj
  #   - restore(source, proc = nil, freeze: false) -> obj
  # -->
  # Returns the result of converting the serialized data in source into a Ruby
  # object (possibly with associated subordinate objects). source may be either an
  # instance of IO or an object that responds to to_str. If proc is specified,
  # each object will be passed to the proc, as the object is being deserialized.
  #
  # Never pass untrusted data (including user supplied input) to this method.
  # Please see the overview for further details.
  #
  # If the `freeze: true` argument is passed, deserialized object would be deeply
  # frozen. Note that it may lead to more efficient memory usage due to frozen
  # strings deduplication:
  #
  #     serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])
  #
  #     deserialized = Marshal.load(serialized)
  #     deserialized.map(&:frozen?)
  #     # => [false, false, false, false]
  #     deserialized.map(&:object_id)
  #     # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects
  #
  #     deserialized = Marshal.load(serialized, freeze: true)
  #     deserialized.map(&:frozen?)
  #     # => [true, true, true, true]
  #     deserialized.map(&:object_id)
  #     # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating
  #
  def self.load: (String | untyped port, ?freeze: boolish) -> untyped
               | [A] (String | untyped port, ^(untyped) -> A, ?freeze: boolish) -> A

  # <!--
  #   rdoc-file=marshal.rb
  #   - restore(source, proc = nil, freeze: false)
  # -->
  #
  alias self.restore self.load
end

# <!-- rdoc-file=marshal.c -->
# major version
#
Marshal::MAJOR_VERSION: Integer

# <!-- rdoc-file=marshal.c -->
# minor version
#
Marshal::MINOR_VERSION: Integer

# <!-- rdoc-file=error.c -->
# The Warning module contains a single method named #warn, and the module
# extends itself, making Warning.warn available. Warning.warn is called for all
# warnings issued by Ruby. By default, warnings are printed to $stderr.
#
# Changing the behavior of Warning.warn is useful to customize how warnings are
# handled by Ruby, for instance by filtering some warnings, and/or outputting
# warnings somewhere other than $stderr.
#
# If you want to change the behavior of Warning.warn you should use
# +Warning.extend(MyNewModuleWithWarnMethod)+ and you can use `super` to get the
# default behavior of printing the warning to $stderr.
#
# Example:
#     module MyWarningFilter
#       def warn(message, category: nil, **kwargs)
#         if /some warning I want to ignore/.match?(message)
#           # ignore
#         else
#           super
#         end
#       end
#     end
#     Warning.extend MyWarningFilter
#
# You should never redefine Warning#warn (the instance method), as that will
# then no longer provide a way to use the default behavior.
#
# The `warning` gem provides convenient ways to customize Warning.warn.
#
module Warning
  # <!--
  #   rdoc-file=error.c
  #   - warn(msg, category: nil)  -> nil
  # -->
  # Writes warning message `msg` to $stderr. This method is called by Ruby for all
  # emitted warnings. A `category` may be included with the warning.
  #
  # See the documentation of the Warning module for how to customize this.
  #
  def warn: (String) -> nil
end

# <!-- rdoc-file=gc.rb -->
# The GC module provides an interface to Ruby's mark and sweep garbage
# collection mechanism.
#
# Some of the underlying methods are also available via the ObjectSpace module.
#
# You may obtain information about the operation of the GC through GC::Profiler.
#
module GC
  # <!--
  #   rdoc-file=gc.rb
  #   - GC.count -> Integer
  # -->
  # The number of times GC occurred.
  #
  # It returns the number of times GC occurred since the process started.
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.disable    -> true or false
  # -->
  # Disables garbage collection, returning `true` if garbage collection was
  # already disabled.
  #
  #     GC.disable   #=> false
  #     GC.disable   #=> true
  #
  def self.disable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.enable    -> true or false
  # -->
  # Enables garbage collection, returning `true` if garbage collection was
  # previously disabled.
  #
  #     GC.disable   #=> false
  #     GC.enable    #=> true
  #     GC.enable    #=> false
  #
  def self.enable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.start                     -> nil
  #   - ObjectSpace.garbage_collect  -> nil
  #   - include GC; garbage_collect  -> nil
  #   - GC.start(full_mark: true, immediate_sweep: true)           -> nil
  #   - ObjectSpace.garbage_collect(full_mark: true, immediate_sweep: true) -> nil
  #   - include GC; garbage_collect(full_mark: true, immediate_sweep: true) -> nil
  # -->
  # Initiates garbage collection, even if manually disabled.
  #
  # This method is defined with keyword arguments that default to true:
  #
  #     def GC.start(full_mark: true, immediate_sweep: true); end
  #
  # Use full_mark: false to perform a minor GC. Use immediate_sweep: false to
  # defer sweeping (use lazy sweep).
  #
  # Note: These keyword arguments are implementation and version dependent. They
  # are not guaranteed to be future-compatible, and may be ignored if the
  # underlying implementation does not support them.
  #
  def self.start: (?immediate_sweep: boolish immediate_sweep, ?immediate_mark: boolish immediate_mark, ?full_mark: boolish full_mark) -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stat -> Hash
  #   - GC.stat(hash) -> Hash
  #   - GC.stat(:key) -> Numeric
  # -->
  # Returns a Hash containing information about the GC.
  #
  # The contents of the hash are implementation specific and may change in the
  # future without notice.
  #
  # The hash includes information about internal statistics about GC such as:
  #
  # count
  # :   The total number of garbage collections ran since application start (count
  #     includes both minor and major garbage collections)
  # heap_allocated_pages
  # :   The total number of `:heap_eden_pages` + `:heap_tomb_pages`
  # heap_sorted_length
  # :   The number of pages that can fit into the buffer that holds references to
  #     all pages
  # heap_allocatable_pages
  # :   The total number of pages the application could allocate without
  #     additional GC
  # heap_available_slots
  # :   The total number of slots in all `:heap_allocated_pages`
  # heap_live_slots
  # :   The total number of slots which contain live objects
  # heap_free_slots
  # :   The total number of slots which do not contain live objects
  # heap_final_slots
  # :   The total number of slots with pending finalizers to be run
  # heap_marked_slots
  # :   The total number of objects marked in the last GC
  # heap_eden_pages
  # :   The total number of pages which contain at least one live slot
  # heap_tomb_pages
  # :   The total number of pages which do not contain any live slots
  # total_allocated_pages
  # :   The cumulative number of pages allocated since application start
  # total_freed_pages
  # :   The cumulative number of pages freed since application start
  # total_allocated_objects
  # :   The cumulative number of objects allocated since application start
  # total_freed_objects
  # :   The cumulative number of objects freed since application start
  # malloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by any GC
  # malloc_increase_bytes_limit
  # :   When `:malloc_increase_bytes` crosses this limit, GC is triggered
  # minor_gc_count
  # :   The total number of minor garbage collections run since process start
  # major_gc_count
  # :   The total number of major garbage collections run since process start
  # remembered_wb_unprotected_objects
  # :   The total number of objects without write barriers
  # remembered_wb_unprotected_objects_limit
  # :   When `:remembered_wb_unprotected_objects` crosses this limit, major GC is
  #     triggered
  # old_objects
  # :   Number of live, old objects which have survived at least 3 garbage
  #     collections
  # old_objects_limit
  # :   When `:old_objects` crosses this limit, major GC is triggered
  # oldmalloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by major GC
  # oldmalloc_increase_bytes_limit
  # :   When `:old_malloc_increase_bytes` crosses this limit, major GC is
  #     triggered
  #
  #
  # If the optional argument, hash, is given, it is overwritten and returned. This
  # is intended to avoid probe effect.
  #
  # This method is only expected to work on CRuby.
  #
  def self.stat: (?::Hash[Symbol, Integer] arg0) -> ::Hash[Symbol, Integer]
               | (?Symbol arg0) -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress            -> integer, true or false
  # -->
  # Returns current status of GC stress mode.
  #
  def self.stress: () -> (Integer | TrueClass | FalseClass)

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress = flag          -> flag
  # -->
  # Updates the GC stress mode.
  #
  # When stress mode is enabled, the GC is invoked at every GC opportunity: all
  # memory and object allocations.
  #
  # Enabling stress mode will degrade performance, it is only for debugging.
  #
  # flag can be true, false, or an integer bit-ORed following flags.
  #     0x01:: no major GC
  #     0x02:: no immediate sweep
  #     0x04:: full mark after malloc/calloc/realloc
  #
  def self.stress=: (Integer | TrueClass | FalseClass flag) -> (Integer | TrueClass | FalseClass)

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.total_time -> int
  # -->
  # Return measured GC total time in nano seconds.
  #
  def self.total_time: () -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.compact
  # -->
  # This function compacts objects together in Ruby's heap.  It eliminates unused
  # space (or fragmentation) in the heap by moving objects in to that unused
  # space.  This function returns a hash which contains statistics about which
  # objects were moved.  See `GC.latest_gc_info` for details about compaction
  # statistics.
  #
  # This method is implementation specific and not expected to be implemented in
  # any implementation besides MRI.
  #
  def self.compact: () -> ::Hash[:considered | :moved, Hash[Symbol | Integer, Integer]]

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.verify_compaction_references(toward: nil, double_heap: false) -> hash
  # -->
  # Verify compaction reference consistency.
  #
  # This method is implementation specific.  During compaction, objects that were
  # moved are replaced with T_MOVED objects.  No object should have a reference to
  # a T_MOVED object after compaction.
  #
  # This function doubles the heap to ensure room to move all objects, compacts
  # the heap to make sure everything moves, updates all references, then performs
  # a full GC.  If any object contains a reference to a T_MOVED object, that
  # object should be pushed on the mark stack, and will make a SEGV.
  #
  def self.verify_compaction_references: () -> ::Hash[:considered | :moved, Hash[Symbol | Integer, Integer]]

  # <!--
  #   rdoc-file=gc.c
  #   - GC.verify_internal_consistency                  -> nil
  # -->
  # Verify internal consistency.
  #
  # This method is implementation specific. Now this method checks generational
  # consistency if RGenGC is supported.
  #
  def self.verify_internal_consistency: () -> nil

  # <!--
  #   rdoc-file=gc.c
  #   - verify_transient_heap_internal_consistency()
  # -->
  #
  def self.verify_transient_heap_internal_consistency: () -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.latest_gc_info -> {:gc_by=>:newobj}
  #   - GC.latest_gc_info(hash) -> hash
  #   - GC.latest_gc_info(:major_by) -> :malloc
  # -->
  # Returns information about the most recent garbage collection.
  #
  # If the optional argument, hash, is given, it is overwritten and returned. This
  # is intended to avoid probe effect.
  #
  def self.latest_gc_info: () -> ::Hash[::Symbol, untyped]
                         | [K] (?Hash[K, untyped] hash) -> ::Hash[::Symbol | K, untyped]
                         | (Symbol key) -> untyped

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def garbage_collect: (?immediate_sweep: boolish immediate_sweep, ?immediate_mark: boolish immediate_mark, ?full_mark: boolish full_mark) -> nil
end

# <!-- rdoc-file=gc.c -->
# internal constants
#
GC::INTERNAL_CONSTANTS: Hash[Symbol, Integer]

# <!-- rdoc-file=gc.c -->
# GC build options
#
GC::OPTS: Array[String]

# <!-- rdoc-file=gc.c -->
# The GC profiler provides access to information on GC runs including time,
# length and object space size.
#
# Example:
#
#     GC::Profiler.enable
#
#     require 'rdoc/rdoc'
#
#     GC::Profiler.report
#
#     GC::Profiler.disable
#
# See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations
#
module GC::Profiler
  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.clear          -> nil
  # -->
  # Clears the GC profiler data.
  #
  def self.clear: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.disable      -> nil
  # -->
  # Stops the GC profiler.
  #
  def self.disable: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.enable       -> nil
  # -->
  # Starts the GC profiler.
  #
  def self.enable: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.enabled?     -> true or false
  # -->
  # The current status of GC profile mode.
  #
  def self.enabled?: () -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.raw_data    -> [Hash, ...]
  # -->
  # Returns an Array of individual raw profile data Hashes ordered from earliest
  # to latest by `:GC_INVOKE_TIME`.
  #
  # For example:
  #
  #     [
  #       {
  #          :GC_TIME=>1.3000000000000858e-05,
  #          :GC_INVOKE_TIME=>0.010634999999999999,
  #          :HEAP_USE_SIZE=>289640,
  #          :HEAP_TOTAL_SIZE=>588960,
  #          :HEAP_TOTAL_OBJECTS=>14724,
  #          :GC_IS_MARKED=>false
  #       },
  #       # ...
  #     ]
  #
  # The keys mean:
  #
  # `:GC_TIME`
  # :   Time elapsed in seconds for this GC run
  # `:GC_INVOKE_TIME`
  # :   Time elapsed in seconds from startup to when the GC was invoked
  # `:HEAP_USE_SIZE`
  # :   Total bytes of heap used
  # `:HEAP_TOTAL_SIZE`
  # :   Total size of heap in bytes
  # `:HEAP_TOTAL_OBJECTS`
  # :   Total number of objects
  # `:GC_IS_MARKED`
  # :   Returns `true` if the GC is in mark phase
  #
  #
  # If ruby was built with `GC_PROFILE_MORE_DETAIL`, you will also have access to
  # the following hash keys:
  #
  # `:GC_MARK_TIME`
  # `:GC_SWEEP_TIME`
  # `:ALLOCATE_INCREASE`
  # `:ALLOCATE_LIMIT`
  # `:HEAP_USE_PAGES`
  # `:HEAP_LIVE_OBJECTS`
  # `:HEAP_FREE_OBJECTS`
  # `:HAVE_FINALIZE`
  # :
  #
  def self.raw_data: () -> ::Array[::Hash[Symbol, untyped]]

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.report
  #   - GC::Profiler.report(io)
  # -->
  # Writes the GC::Profiler.result to `$stdout` or the given IO object.
  #
  def self.report: (?IO io) -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.result  -> String
  # -->
  # Returns a profile data report such as:
  #
  #     GC 1 invokes.
  #     Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object                    GC time(ms)
  #         1               0.012               159240               212940                10647         0.00000000000001530000
  #
  def self.result: () -> String

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.total_time  -> float
  # -->
  # The total time used for garbage collection in seconds
  #
  def self.total_time: () -> Float
end

