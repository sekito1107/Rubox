# <!-- rdoc-file=thread.c -->
# ThreadGroup provides a means of keeping track of a number of threads as a
# group.
#
# A given Thread object can only belong to one ThreadGroup at a time; adding a
# thread to a new group will remove it from any previous group.
#
# Newly created threads belong to the same group as the thread from which they
# were created.
#
class ThreadGroup
  # <!-- rdoc-file=thread.c -->
  # The default ThreadGroup created when Ruby starts; all Threads belong to it by
  # default.
  #
  Default: ThreadGroup

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.add(thread)   -> thgrp
  # -->
  # Adds the given `thread` to this group, removing it from any other group to
  # which it may have previously been a member.
  #
  #     puts "Initial group is #{ThreadGroup::Default.list}"
  #     tg = ThreadGroup.new
  #     t1 = Thread.new { sleep }
  #     t2 = Thread.new { sleep }
  #     puts "t1 is #{t1}"
  #     puts "t2 is #{t2}"
  #     tg.add(t1)
  #     puts "Initial group now #{ThreadGroup::Default.list}"
  #     puts "tg group now #{tg.list}"
  #
  # This will produce:
  #
  #     Initial group is #<Thread:0x401bdf4c>
  #     t1 is #<Thread:0x401b3c90>
  #     t2 is #<Thread:0x401b3c18>
  #     Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>
  #     tg group now #<Thread:0x401b3c90>
  #
  def add: (Thread thread) -> self

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclose   -> thgrp
  # -->
  # Prevents threads from being added to or removed from the receiving
  # ThreadGroup.
  #
  # New threads can still be started in an enclosed ThreadGroup.
  #
  #     ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>
  #     thr = Thread.new { Thread.stop }    #=> #<Thread:0x402a7210 sleep>
  #     tg = ThreadGroup.new                #=> #<ThreadGroup:0x402752d4>
  #     tg.add thr
  #     #=> ThreadError: can't move from the enclosed thread group
  #
  def enclose: () -> self

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclosed?   -> true or false
  # -->
  # Returns `true` if the `thgrp` is enclosed. See also ThreadGroup#enclose.
  #
  def enclosed?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.list   -> array
  # -->
  # Returns an array of all existing Thread objects that belong to this group.
  #
  #     ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]
  #
  def list: () -> Array[Thread]
end
# <!-- rdoc-file=ractor.rb -->
# Ractor is an Actor-model abstraction for Ruby that provides thread-safe
# parallel execution.
#
# Ractor.new makes a new Ractor, which can run in parallel.
#
#     # The simplest ractor
#     r = Ractor.new {puts "I am in Ractor!"}
#     r.take # wait for it to finish
#     # Here, "I am in Ractor!" is printed
#
# Ractors do not share all objects with each other. There are two main benefits
# to this: across ractors, thread-safety concerns such as data-races and
# race-conditions are not possible. The other benefit is parallelism.
#
# To achieve this, object sharing is limited across ractors. For example, unlike
# in threads, ractors can't access all the objects available in other ractors.
# Even objects normally available through variables in the outer scope are
# prohibited from being used across ractors.
#
#     a = 1
#     r = Ractor.new {puts "I am in Ractor! a=#{a}"}
#     # fails immediately with
#     # ArgumentError (can not isolate a Proc because it accesses outer variables (a).)
#
# The object must be explicitly shared:
#     a = 1
#     r = Ractor.new(a) { |a1| puts "I am in Ractor! a=#{a1}"}
#
# On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is
# held per ractor, so ractors can perform in parallel without locking each
# other. This is unlike the situation with threads on CRuby.
#
# Instead of accessing shared state, objects should be passed to and from
# ractors by sending and receiving them as messages.
#
#     a = 1
#     r = Ractor.new do
#       a_in_ractor = receive # receive blocks until somebody passes a message
#       puts "I am in Ractor! a=#{a_in_ractor}"
#     end
#     r.send(a)  # pass it
#     r.take
#     # Here, "I am in Ractor! a=1" is printed
#
# There are two pairs of methods for sending/receiving messages:
#
# *   Ractor#send and Ractor.receive for when the *sender* knows the receiver
#     (push);
# *   Ractor.yield and Ractor#take for when the *receiver* knows the sender
#     (pull);
#
# In addition to that, any arguments passed to Ractor.new are passed to the
# block and available there as if received by Ractor.receive, and the last block
# value is sent outside of the ractor as if sent by Ractor.yield.
#
# A little demonstration of a classic ping-pong:
#
#     server = Ractor.new(name: "server") do
#       puts "Server starts: #{self.inspect}"
#       puts "Server sends: ping"
#       Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested
#       received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent
#       puts "Server received: #{received}"
#     end
#
#     client = Ractor.new(server) do |srv|        # The server is sent to the client, and available as srv
#       puts "Client starts: #{self.inspect}"
#       received = srv.take                       # The client takes a message from the server
#       puts "Client received from " \
#            "#{srv.inspect}: #{received}"
#       puts "Client sends to " \
#            "#{srv.inspect}: pong"
#       srv.send 'pong'                           # The client sends a message to the server
#     end
#
#     [client, server].each(&:take)               # Wait until they both finish
#
# This will output something like:
#
#     Server starts: #<Ractor:#2 server test.rb:1 running>
#     Server sends: ping
#     Client starts: #<Ractor:#3 test.rb:8 running>
#     Client received from #<Ractor:#2 server test.rb:1 blocking>: ping
#     Client sends to #<Ractor:#2 server test.rb:1 blocking>: pong
#     Server received: pong
#
# Ractors receive their messages via the *incoming port*, and send them to the
# *outgoing port*. Either one can be disabled with Ractor#close_incoming and
# Ractor#close_outgoing, respectively. When a ractor terminates, its ports are
# closed automatically.
#
# ## Shareable and unshareable objects
#
# When an object is sent to and from a ractor, it's important to understand
# whether the object is shareable or unshareable. Most Ruby objects are
# unshareable objects. Even frozen objects can be unshareable if they contain
# (through their instance variables) unfrozen objects.
#
# Shareable objects are those which can be used by several threads without
# compromising thread-safety, for example numbers, `true` and `false`.
# Ractor.shareable? allows you to check this, and Ractor.make_shareable tries to
# make the object shareable if it's not already, and gives an error if it can't
# do it.
#
#     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are shareable
#     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true
#     Ractor.shareable?('foo'.freeze) #=> true
#     Ractor.shareable?([Object.new].freeze) #=> false, inner object is unfrozen
#
#     ary = ['hello', 'world']
#     ary.frozen?                 #=> false
#     ary[0].frozen?              #=> false
#     Ractor.make_shareable(ary)
#     ary.frozen?                 #=> true
#     ary[0].frozen?              #=> true
#     ary[1].frozen?              #=> true
#
# When a shareable object is sent (via #send or Ractor.yield), no additional
# processing occurs on it. It just becomes usable by both ractors. When an
# unshareable object is sent, it can be either *copied* or *moved*. The first is
# the default, and it copies the object fully by deep cloning (Object#clone) the
# non-shareable parts of its structure.
#
#     data = ['foo', 'bar'.freeze]
#     r = Ractor.new do
#       data2 = Ractor.receive
#       puts "In ractor: #{data2.object_id}, #{data2[0].object_id}, #{data2[1].object_id}"
#     end
#     r.send(data)
#     r.take
#     puts "Outside  : #{data.object_id}, #{data[0].object_id}, #{data[1].object_id}"
#
# This will output something like:
#
#     In ractor: 340, 360, 320
#     Outside  : 380, 400, 320
#
# Note that the object ids of the array and the non-frozen string inside the
# array have changed in the ractor because they are different objects. The
# second array's element, which is a shareable frozen string, is the same
# object.
#
# Deep cloning of objects may be slow, and sometimes impossible. Alternatively,
# `move: true` may be used during sending. This will *move* the unshareable
# object to the receiving ractor, making it inaccessible to the sending ractor.
#
#     data = ['foo', 'bar']
#     r = Ractor.new do
#       data_in_ractor = Ractor.receive
#       puts "In ractor: #{data_in_ractor.object_id}, #{data_in_ractor[0].object_id}"
#     end
#     r.send(data, move: true)
#     r.take
#     puts "Outside: moved? #{Ractor::MovedObject === data}"
#     puts "Outside: #{data.inspect}"
#
# This will output:
#
#     In ractor: 100, 120
#     Outside: moved? true
#     test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError)
#
# Notice that even `inspect` (and more basic methods like `__id__`) is
# inaccessible on a moved object.
#
# Class and Module objects are shareable so the class/module definitions are
# shared between ractors. Ractor objects are also shareable. All operations on
# shareable objects are thread-safe, so the thread-safety property will be kept.
# We can not define mutable shareable objects in Ruby, but C extensions can
# introduce them.
#
# It is prohibited to access (get) instance variables of shareable objects in
# other ractors if the values of the variables aren't shareable. This can occur
# because modules/classes are shareable, but they can have instance variables
# whose values are not. In non-main ractors, it's also prohibited to set
# instance variables on classes/modules (even if the value is shareable).
#
#     class C
#       class << self
#         attr_accessor :tricky
#       end
#     end
#
#     C.tricky = "unshareable".dup
#
#     r = Ractor.new(C) do |cls|
#       puts "I see #{cls}"
#       puts "I can't see #{cls.tricky}"
#       cls.tricky = true # doesn't get here, but this would also raise an error
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# Ractors can access constants if they are shareable. The main Ractor is the
# only one that can access non-shareable constants.
#
#     GOOD = 'good'.freeze
#     BAD = 'bad'.dup
#
#     r = Ractor.new do
#       puts "GOOD=#{GOOD}"
#       puts "BAD=#{BAD}"
#     end
#     r.take
#     # GOOD=good
#     # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError)
#
#     # Consider the same C class from above
#
#     r = Ractor.new do
#       puts "I see #{C}"
#       puts "I can't see #{C.tricky}"
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# See also the description of `# shareable_constant_value` pragma in [Comments
# syntax](rdoc-ref:syntax/comments.rdoc) explanation.
#
# ## Ractors vs threads
#
# Each ractor has its own main Thread. New threads can be created from inside
# ractors (and, on CRuby, they share the GVL with other threads of this ractor).
#
#     r = Ractor.new do
#       a = 1
#       Thread.new {puts "Thread in ractor: a=#{a}"}.join
#     end
#     r.take
#     # Here "Thread in ractor: a=1" will be printed
#
# ## Note on code examples
#
# In the examples below, sometimes we use the following method to wait for
# ractors that are not currently blocked to finish (or to make progress).
#
#     def wait
#       sleep(0.1)
#     end
#
# It is **only for demonstration purposes** and shouldn't be used in a real
# code. Most of the time, #take is used to wait for ractors to finish.
#
# ## Reference
#
# See [Ractor design doc](rdoc-ref:ractor.md) for more details.
#
class Ractor
  # <!--
  #   rdoc-file=ractor.rb
  #   - _require(feature)
  # -->
  # internal method
  #
  def self._require: (String feature) -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - [](sym)
  # -->
  # get a value from ractor-local storage of current Ractor
  #
  def self.[]: (Symbol) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - []=(sym, val)
  # -->
  # set a value in ractor-local storage of current Ractor
  #
  def self.[]=: (Symbol, untyped) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - count()
  # -->
  # Returns the number of Ractors currently running or blocking (waiting).
  #
  #     Ractor.count                   #=> 1
  #     r = Ractor.new(name: 'example') { Ractor.yield(1) }
  #     Ractor.count                   #=> 2 (main + example ractor)
  #     r.take                         # wait for Ractor.yield(1)
  #     r.take                         # wait until r will finish
  #     Ractor.count                   #=> 1
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=ractor.rb
  #   - current()
  # -->
  # Returns the currently executing Ractor.
  #
  #     Ractor.current #=> #<Ractor:#1 running>
  #
  def self.current: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - main()
  # -->
  # returns main ractor
  #
  def self.main: () -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - main?()
  # -->
  # return true if the current ractor is main ractor
  #
  def self.main?: () -> boolish

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.make_shareable(obj, copy: false) -> shareable_obj
  # -->
  # Make `obj` shareable between ractors.
  #
  # `obj` and all the objects it refers to will be frozen, unless they are already
  # shareable.
  #
  # If `copy` keyword is `true`, it will copy objects before freezing them, and
  # will not modify `obj` or its internal objects.
  #
  # Note that the specification and implementation of this method are not mature
  # and may be changed in the future.
  #
  #     obj = ['test']
  #     Ractor.shareable?(obj)     #=> false
  #     Ractor.make_shareable(obj) #=> ["test"]
  #     Ractor.shareable?(obj)     #=> true
  #     obj.frozen?                #=> true
  #     obj[0].frozen?             #=> true
  #
  #     # Copy vs non-copy versions:
  #     obj1 = ['test']
  #     obj1s = Ractor.make_shareable(obj1)
  #     obj1.frozen?                        #=> true
  #     obj1s.object_id == obj1.object_id   #=> true
  #     obj2 = ['test']
  #     obj2s = Ractor.make_shareable(obj2, copy: true)
  #     obj2.frozen?                        #=> false
  #     obj2s.frozen?                       #=> true
  #     obj2s.object_id == obj2.object_id   #=> false
  #     obj2s[0].object_id == obj2[0].object_id #=> false
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.make_shareable: [T] (T obj, ?copy: boolish) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.new(*args, name: nil) {|*args| block } -> ractor
  # -->
  # Create a new Ractor with args and a block.
  #
  # The given block (Proc) will be isolated (can't access any outer variables).
  # `self` inside the block will refer to the current Ractor.
  #
  #     r = Ractor.new { puts "Hi, I am #{self.inspect}" }
  #     r.take
  #     # Prints "Hi, I am #<Ractor:#2 test.rb:1 running>"
  #
  # Any `args` passed are propagated to the block arguments by the same rules as
  # objects sent via #send/Ractor.receive. If an argument in `args` is not
  # shareable, it will be copied (via deep cloning, which might be inefficient).
  #
  #     arg = [1, 2, 3]
  #     puts "Passing: #{arg} (##{arg.object_id})"
  #     r = Ractor.new(arg) {|received_arg|
  #       puts "Received: #{received_arg} (##{received_arg.object_id})"
  #     }
  #     r.take
  #     # Prints:
  #     #   Passing: [1, 2, 3] (#280)
  #     #   Received: [1, 2, 3] (#300)
  #
  # Ractor's `name` can be set for debugging purposes:
  #
  #     r = Ractor.new(name: 'my ractor') {}; r.take
  #     p r
  #     #=> #<Ractor:#3 my ractor test.rb:1 terminated>
  #
  def self.new: (*untyped args, ?name: string) { (?) -> untyped } -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive -> msg
  # -->
  # Receive a message from the incoming port of the current ractor (which was sent
  # there by #send from another ractor).
  #
  #     r = Ractor.new do
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # Here will be printed: "Received: message1"
  #
  # Alternatively, the private instance method `receive` may be used:
  #
  #     r = Ractor.new do
  #       v1 = receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # This prints: "Received: message1"
  #
  # The method blocks if the queue is empty.
  #
  #     r = Ractor.new do
  #       puts "Before first receive"
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #       v2 = Ractor.receive
  #       puts "Received: #{v2}"
  #     end
  #     wait
  #     puts "Still not received"
  #     r.send('message1')
  #     wait
  #     puts "Still received only one"
  #     r.send('message2')
  #     r.take
  #
  # Output:
  #
  #     Before first receive
  #     Still not received
  #     Received: message1
  #     Still received only one
  #     Received: message2
  #
  # If close_incoming was called on the ractor, the method raises
  # Ractor::ClosedError if there are no more messages in the incoming queue:
  #
  #     Ractor.new do
  #       close_incoming
  #       receive
  #     end
  #     wait
  #     # in `receive': The incoming port is already closed => #<Ractor:#2 test.rb:1 running> (Ractor::ClosedError)
  #
  def self.receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive_if {|msg| block } -> msg
  # -->
  # Receive only a specific message.
  #
  # Instead of Ractor.receive, Ractor.receive_if can be given a pattern (or any
  # filter) in a block and you can choose the messages to accept that are
  # available in your ractor's incoming queue.
  #
  #     r = Ractor.new do
  #       p Ractor.receive_if{|msg| msg.match?(/foo/)} #=> "foo3"
  #       p Ractor.receive_if{|msg| msg.match?(/bar/)} #=> "bar1"
  #       p Ractor.receive_if{|msg| msg.match?(/baz/)} #=> "baz2"
  #     end
  #     r << "bar1"
  #     r << "baz2"
  #     r << "foo3"
  #     r.take
  #
  # This will output:
  #
  #     foo3
  #     bar1
  #     baz2
  #
  # If the block returns a truthy value, the message is removed from the incoming
  # queue and returned. Otherwise, the message remains in the incoming queue and
  # the next messages are checked by the given block.
  #
  # If there are no messages left in the incoming queue, the method will block
  # until new messages arrive.
  #
  # If the block is escaped by break/return/exception/throw, the message is
  # removed from the incoming queue as if a truthy value had been returned.
  #
  #     r = Ractor.new do
  #       val = Ractor.receive_if{|msg| msg.is_a?(Array)}
  #       puts "Received successfully: #{val}"
  #     end
  #
  #     r.send(1)
  #     r.send('test')
  #     wait
  #     puts "2 non-matching sent, nothing received"
  #     r.send([1, 2, 3])
  #     wait
  #
  # Prints:
  #
  #     2 non-matching sent, nothing received
  #     Received successfully: [1, 2, 3]
  #
  # Note that you can not call receive/receive_if in the given block recursively.
  # You should not do any tasks in the block other than message filtration.
  #
  #     Ractor.current << true
  #     Ractor.receive_if{|msg| Ractor.receive}
  #     #=> `receive': can not call receive/receive_if recursively (Ractor::Error)
  #
  def self.receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias self.recv self.receive

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.select(*ractors, [yield_value:, move: false]) -> [ractor or symbol, obj]
  # -->
  # Wait for any ractor to have something in its outgoing port, read from this
  # ractor, and then return that ractor and the object received.
  #
  #     r1 = Ractor.new {Ractor.yield 'from 1'}
  #     r2 = Ractor.new {Ractor.yield 'from 2'}
  #
  #     r, obj = Ractor.select(r1, r2)
  #
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Prints: received "from 1" from #<Ractor:#2 test.rb:1 running>
  #     # But could just as well print "from r2" here, either prints could be first.
  #
  # If one of the given ractors is the current ractor, and it is selected, `r`
  # will contain the `:receive` symbol instead of the ractor object.
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       main.send 'to main'
  #       Ractor.yield 'from 1'
  #     end
  #     r2 = Ractor.new do
  #       Ractor.yield 'from 2'
  #     end
  #
  #     r, obj = Ractor.select(r1, r2, Ractor.current)
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Could print: received "to main" from :receive
  #
  # If `yield_value` is provided, that value may be yielded if another ractor is
  # calling #take. In this case, the pair `[:yield, nil]` is returned:
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       puts "Received from main: #{main.take}"
  #     end
  #
  #     puts "Trying to select"
  #     r, obj = Ractor.select(r1, Ractor.current, yield_value: 123)
  #     wait
  #     puts "Received #{obj.inspect} from #{r.inspect}"
  #
  # This will print:
  #
  #     Trying to select
  #     Received from main: 123
  #     Received nil from :yield
  #
  # `move` boolean flag defines whether yielded value will be copied (default) or
  # moved.
  #
  def self.select: (*Ractor ractors, ?move: boolish, ?yield_value: untyped) -> [ Ractor | Symbol, untyped ]

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.shareable?(obj) -> true | false
  # -->
  # Checks if the object is shareable by ractors.
  #
  #     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are frozen
  #     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true
  #     Ractor.shareable?('foo'.freeze) #=> true
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.shareable?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.store_if_absent(key){ init_block }
  # -->
  # If the correponding value is not set, yield a value with init_block and store
  # the value in thread-safe manner. This method returns corresponding stored
  # value.
  #
  #     (1..10).map{
  #       Thread.new(it){|i|
  #         Ractor.store_if_absent(:s){ f(); i }
  #         #=> return stored value of key :s
  #       }
  #     }.map(&:value).uniq.size #=> 1 and f() is called only once
  #
  def self.store_if_absent: (Symbol) { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.yield(msg, move: false) -> nil
  # -->
  # Send a message to the current ractor's outgoing port to be accepted by #take.
  #
  #     r = Ractor.new {Ractor.yield 'Hello from ractor'}
  #     puts r.take
  #     # Prints: "Hello from ractor"
  #
  # This method is blocking, and will return only when somebody consumes the sent
  # message.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'Hello from ractor'
  #       puts "Ractor: after yield"
  #     end
  #     wait
  #     puts "Still not taken"
  #     puts r.take
  #
  # This will print:
  #
  #     Still not taken
  #     Hello from ractor
  #     Ractor: after yield
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise:
  #
  #     r = Ractor.new do
  #       close_outgoing
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     wait
  #     # `yield': The outgoing-port is already closed (Ractor::ClosedError)
  #
  # The meaning of the `move` argument is the same as for #send.
  #
  def self.yield: (untyped obj, ?move: boolish) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - <<(obj, move: false)
  # -->
  #
  alias << send

  # <!--
  #   rdoc-file=ractor.rb
  #   - [](sym)
  # -->
  # get a value from ractor-local storage of current Ractor Obsolete and use
  # Ractor.[] instead.
  #
  def []: (interned sym) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - []=(sym, val)
  # -->
  # set a value in ractor-local storage of current Ractor Obsolete and use
  # Ractor.[]= instead.
  #
  def []=: [T] (interned sym, T val) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_incoming -> true | false
  # -->
  # Closes the incoming port and returns whether it was already closed. All
  # further attempts to Ractor.receive in the ractor, and #send to the ractor will
  # fail with Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_incoming  #=> false
  #     r.close_incoming  #=> true
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  def close_incoming: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_outgoing -> true | false
  # -->
  # Closes the outgoing port and returns whether it was already closed. All
  # further attempts to Ractor.yield in the ractor, and #take from the ractor will
  # fail with Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_outgoing  #=> false
  #     r.close_outgoing  #=> true
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #
  def close_outgoing: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - inspect()
  # -->
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ractor.rb
  #   - name()
  # -->
  # The name set in Ractor.new, or `nil`.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.send(msg, move: false) -> self
  # -->
  # Send a message to a Ractor's incoming queue to be accepted by Ractor.receive.
  #
  #     r = Ractor.new do
  #       value = Ractor.receive
  #       puts "Received #{value}"
  #     end
  #     r.send 'message'
  #     # Prints: "Received: message"
  #
  # The method is non-blocking (will return immediately even if the ractor is not
  # ready to receive anything):
  #
  #     r = Ractor.new {sleep(5)}
  #     r.send('test')
  #     puts "Sent successfully"
  #     # Prints: "Sent successfully" immediately
  #
  # An attempt to send to a ractor which already finished its execution will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {}
  #     r.take
  #     p r
  #     # "#<Ractor:#6 (irb):23 terminated>"
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  # If close_incoming was called on the ractor, the method also raises
  # Ractor::ClosedError.
  #
  #     r =  Ractor.new do
  #       sleep(500)
  #       receive
  #     end
  #     r.close_incoming
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #     # The error is raised immediately, not when the ractor tries to receive
  #
  # If the `obj` is unshareable, by default it will be copied into the receiving
  # ractor by deep cloning. If `move: true` is passed, the object is *moved* into
  # the receiving ractor and becomes inaccessible to the sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     msg = 'message'
  #     r.send(msg, move: true)
  #     r.take
  #     p msg
  #
  # This prints:
  #
  #     Received: message
  #     in `p': undefined method `inspect' for #<Ractor::MovedObject:0x000055c99b9b69b8>
  #
  # All references to the object and its parts will become invalid to the sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'
  #     ary = [s]
  #     copy = ary.dup
  #     r.send(ary, move: true)
  #
  #     s.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     ary.class
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     copy.class
  #     # => Array, it is different object
  #     copy[0].inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     # ...but its item was still a reference to `s`, which was moved
  #
  # If the object is shareable, `move: true` has no effect on it:
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'.freeze
  #     r.send(s, move: true)
  #     s.inspect #=> "message", still available
  #
  def send: (untyped obj, ?move: boolish) -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.take -> msg
  # -->
  # Get a message from the ractor's outgoing port, which was put there by
  # Ractor.yield or at ractor's termination.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'explicit yield'
  #       'last value'
  #     end
  #     puts r.take #=> 'explicit yield'
  #     puts r.take #=> 'last value'
  #     puts r.take # Ractor::ClosedError (The outgoing-port is already closed)
  #
  # The fact that the last value is also sent to the outgoing port means that
  # `take` can be used as an analog of Thread#join ("just wait until ractor
  # finishes"). However, it will raise if somebody has already consumed that
  # message.
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new do
  #       sleep(500)
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     r.close_outgoing
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #     # The error would be raised immediately, not when ractor will try to receive
  #
  # If an uncaught exception is raised in the Ractor, it is propagated by take as
  # a Ractor::RemoteError.
  #
  #     r = Ractor.new {raise "Something weird happened"}
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e              #  => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r  # => true
  #       p e.cause        # => #<RuntimeError: Something weird happened>
  #     end
  #
  # Ractor::ClosedError is a descendant of StopIteration, so the termination of
  # the ractor will break out of any loops that receive this message without
  # propagating the error:
  #
  #     r = Ractor.new do
  #       3.times {|i| Ractor.yield "message #{i}"}
  #       "finishing"
  #     end
  #
  #     loop {puts "Received: " + r.take}
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: message 0
  #     Received: message 1
  #     Received: message 2
  #     Received: finishing
  #     Continue successfully
  #
  def take: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - to_s()
  # -->
  #
  alias to_s inspect

  private

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive()
  # -->
  # same as Ractor.receive
  #
  def receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive_if(&b)
  # -->
  # same as Ractor.receive_if
  #
  def receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias recv receive

  # <!-- rdoc-file=ractor.c -->
  # Raised when an attempt is made to send a message to a closed port, or to
  # retrieve a message from a closed and empty port. Ports may be closed
  # explicitly with Ractor#close_outgoing/close_incoming and are closed implicitly
  # when a Ractor terminates.
  #
  #     r = Ractor.new { sleep(500) }
  #     r.close_outgoing
  #     r.take # Ractor::ClosedError
  #
  # ClosedError is a descendant of StopIteration, so the closing of the ractor
  # will break the loops without propagating the error:
  #
  #     r = Ractor.new do
  #       loop do
  #         msg = receive # raises ClosedError and loop traps it
  #         puts "Received: #{msg}"
  #       end
  #       puts "loop exited"
  #     end
  #
  #     3.times{|i| r << i}
  #     r.close_incoming
  #     r.take
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: 0
  #     Received: 1
  #     Received: 2
  #     loop exited
  #     Continue successfully
  #
  class ClosedError < StopIteration
  end

  class Error < RuntimeError
  end

  class IsolationError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on an attempt to access an object which was moved in Ractor#send or
  # Ractor.yield.
  #
  #     r = Ractor.new { sleep }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # A special object which replaces any value that was moved to another ractor in
  # Ractor#send or Ractor.yield. Any attempt to access the object results in
  # Ractor::MovedError.
  #
  #     r = Ractor.new { receive }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     p Ractor::MovedObject === ary
  #     # => true
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedObject < BasicObject
    # <!--
    #   rdoc-file=ractor.c
    #   - !(*args)
    # -->
    #
    def !: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - !=(*args)
    # -->
    #
    def !=: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - ==(*args)
    # -->
    #
    def ==: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __id__(*args)
    # -->
    #
    def __id__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __send__(*args)
    # -->
    #
    def __send__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - equal?(*args)
    # -->
    #
    def equal?: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_eval(*args)
    # -->
    #
    def instance_eval: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_exec(*args)
    # -->
    #
    def instance_exec: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - method_missing(*args)
    # -->
    #
    def method_missing: (*untyped) -> untyped
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on attempt to Ractor#take if there was an uncaught exception in the
  # Ractor. Its `cause` will contain the original exception, and `ractor` is the
  # original ractor it was raised in.
  #
  #     r = Ractor.new { raise "Something weird happened" }
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e             # => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r # => true
  #       p e.cause       # => #<RuntimeError: Something weird happened>
  #     end
  #
  class RemoteError < Ractor::Error
    def ractor: () -> Ractor
  end

  class UnsafeError < Ractor::Error
  end

  %a{annotate:rdoc:skip}
  class Selector
  end
end
# <!-- rdoc-file=array.c -->
# An Array object is an ordered, integer-indexed collection of objects, called
# *elements*; the object represents an [array data
# structure](https://en.wikipedia.org/wiki/Array_(data_structure)).
#
# An element may be any object (even another array); elements may be any mixture
# of objects of different types.
#
# Important data structures that use arrays include:
#
# *   [Coordinate vector](https://en.wikipedia.org/wiki/Coordinate_vector).
# *   [Matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)).
# *   [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)).
# *   [Hash table](https://en.wikipedia.org/wiki/Hash_table).
# *   [Deque (double-ended
#     queue)](https://en.wikipedia.org/wiki/Double-ended_queue).
# *   [Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)).
# *   [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).
#
# There are also array-like data structures:
#
# *   [Associative array](https://en.wikipedia.org/wiki/Associative_array) (see
#     Hash).
# *   [Directory](https://en.wikipedia.org/wiki/Directory_(computing)) (see
#     Dir).
# *   [Environment](https://en.wikipedia.org/wiki/Environment_variable) (see
#     ENV).
# *   [Set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) (see Set).
# *   [String](https://en.wikipedia.org/wiki/String_(computer_science)) (see
#     String).
#
# ## Array Indexes
#
# Array indexing starts at 0, as in C or Java.
#
# A non-negative index is an offset from the first element:
#
# *   Index 0 indicates the first element.
# *   Index 1 indicates the second element.
# *   ...
#
# A negative index is an offset, backwards, from the end of the array:
#
# *   Index -1 indicates the last element.
# *   Index -2 indicates the next-to-last element.
# *   ...
#
# ### In-Range and Out-of-Range Indexes
#
# A non-negative index is *in range* if and only if it is smaller than the size
# of the array.  For a 3-element array:
#
# *   Indexes 0 through 2 are in range.
# *   Index 3 is out of range.
#
# A negative index is *in range* if and only if its absolute value is not larger
# than the size of the array.  For a 3-element array:
#
# *   Indexes -1 through -3 are in range.
# *   Index -4 is out of range.
#
# ### Effective Index
#
# Although the effective index into an array is always an integer, some methods
# (both within class Array and elsewhere) accept one or more non-integer
# arguments that are [integer-convertible
# objects](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
#
# ## Creating Arrays
#
# You can create an Array object explicitly with:
#
# *   An [array literal](rdoc-ref:syntax/literals.rdoc@Array+Literals):
#
#         [1, 'one', :one, [2, 'two', :two]]
#
# *   A [%w or %W string-array
#     Literal](rdoc-ref:syntax/literals.rdoc@25w+and+-25W-3A+String-Array+Litera
#     ls):
#
#         %w[foo bar baz] # => ["foo", "bar", "baz"]
#         %w[1 % *]       # => ["1", "%", "*"]
#
# *   A [%i or %I symbol-array
#     Literal](rdoc-ref:syntax/literals.rdoc@25i+and+-25I-3A+Symbol-Array+Litera
#     ls):
#
#         %i[foo bar baz] # => [:foo, :bar, :baz]
#         %i[1 % *]       # => [:"1", :%, :*]
#
# *   Method Kernel#Array:
#
#         Array(["a", "b"])             # => ["a", "b"]
#         Array(1..5)                   # => [1, 2, 3, 4, 5]
#         Array(key: :value)            # => [[:key, :value]]
#         Array(nil)                    # => []
#         Array(1)                      # => [1]
#         Array({:a => "a", :b => "b"}) # => [[:a, "a"], [:b, "b"]]
#
# *   Method Array.new:
#
#         Array.new               # => []
#         Array.new(3)            # => [nil, nil, nil]
#         Array.new(4) {Hash.new} # => [{}, {}, {}, {}]
#         Array.new(3, true)      # => [true, true, true]
#
#     Note that the last example above populates the array with references to
#     the same object. This is recommended only in cases where that object is a
#     natively immutable object such as a symbol, a numeric, `nil`, `true`, or
#     `false`.
#
#     Another way to create an array with various objects, using a block; this
#     usage is safe for mutable objects such as hashes, strings or other arrays:
#
#         Array.new(4) {|i| i.to_s } # => ["0", "1", "2", "3"]
#
#     Here is a way to create a multi-dimensional array:
#
#         Array.new(3) {Array.new(3)}
#         # => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
#
# A number of Ruby methods, both in the core and in the standard library,
# provide instance method `to_a`, which converts an object to an array.
#
# *   ARGF#to_a
# *   Array#to_a
# *   Enumerable#to_a
# *   Hash#to_a
# *   MatchData#to_a
# *   NilClass#to_a
# *   OptionParser#to_a
# *   Range#to_a
# *   Set#to_a
# *   Struct#to_a
# *   Time#to_a
# *   Benchmark::Tms#to_a
# *   CSV::Table#to_a
# *   Enumerator::Lazy#to_a
# *   Gem::List#to_a
# *   Gem::NameTuple#to_a
# *   Gem::Platform#to_a
# *   Gem::RequestSet::Lockfile::Tokenizer#to_a
# *   Gem::SourceList#to_a
# *   OpenSSL::X509::Extension#to_a
# *   OpenSSL::X509::Name#to_a
# *   Racc::ISet#to_a
# *   Rinda::RingFinger#to_a
# *   Ripper::Lexer::Elem#to_a
# *   RubyVM::InstructionSequence#to_a
# *   YAML::DBM#to_a
#
# ## Example Usage
#
# In addition to the methods it mixes in through the Enumerable module, the
# `Array` class has proprietary methods for accessing, searching and otherwise
# manipulating arrays.
#
# Some of the more common ones are illustrated below.
#
# ## Accessing Elements
#
# Elements in an array can be retrieved using the Array#[] method.  It can take
# a single integer argument (a numeric index), a pair of arguments (start and
# length) or a range. Negative indices start counting from the end, with -1
# being the last element.
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr[2]    #=> 3
#     arr[100]  #=> nil
#     arr[-3]   #=> 4
#     arr[2, 3] #=> [3, 4, 5]
#     arr[1..4] #=> [2, 3, 4, 5]
#     arr[1..-3] #=> [2, 3, 4]
#
# Another way to access a particular array element is by using the #at method
#
#     arr.at(0) #=> 1
#
# The #slice method works in an identical manner to Array#[].
#
# To raise an error for indices outside of the array bounds or else to provide a
# default value when that happens, you can use #fetch.
#
#     arr = ['a', 'b', 'c', 'd', 'e', 'f']
#     arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
#     arr.fetch(100, "oops") #=> "oops"
#
# The special methods #first and #last will return the first and last elements
# of an array, respectively.
#
#     arr.first #=> 1
#     arr.last  #=> 6
#
# To return the first `n` elements of an array, use #take
#
#     arr.take(3) #=> [1, 2, 3]
#
# #drop does the opposite of #take, by returning the elements after `n` elements
# have been dropped:
#
#     arr.drop(3) #=> [4, 5, 6]
#
# ## Obtaining Information about an `Array`
#
# Arrays keep track of their own length at all times.  To query an array about
# the number of elements it contains, use #length, #count or #size.
#
#     browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
#     browsers.length #=> 5
#     browsers.count #=> 5
#
# To check whether an array contains any elements at all
#
#     browsers.empty? #=> false
#
# To check whether a particular item is included in the array
#
#     browsers.include?('Konqueror') #=> false
#
# ## Adding Items to Arrays
#
# Items can be added to the end of an array by using either #push or #<<
#
#     arr = [1, 2, 3, 4]
#     arr.push(5) #=> [1, 2, 3, 4, 5]
#     arr << 6    #=> [1, 2, 3, 4, 5, 6]
#
# #unshift will add a new item to the beginning of an array.
#
#     arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]
#
# With #insert you can add a new element to an array at any position.
#
#     arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]
#
# Using the #insert method, you can also insert multiple values at once:
#
#     arr.insert(3, 'orange', 'pear', 'grapefruit')
#     #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
#
# ## Removing Items from an `Array`
#
# The method #pop removes the last element in an array and returns it:
#
#     arr =  [1, 2, 3, 4, 5, 6]
#     arr.pop #=> 6
#     arr #=> [1, 2, 3, 4, 5]
#
# To retrieve and at the same time remove the first item, use #shift:
#
#     arr.shift #=> 1
#     arr #=> [2, 3, 4, 5]
#
# To delete an element at a particular index:
#
#     arr.delete_at(2) #=> 4
#     arr #=> [2, 3, 5]
#
# To delete a particular element anywhere in an array, use #delete:
#
#     arr = [1, 2, 2, 3]
#     arr.delete(2) #=> 2
#     arr #=> [1,3]
#
# A useful method if you need to remove `nil` values from an array is #compact:
#
#     arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, 'bar', 7, 'baz']
#
# Another common need is to remove duplicate elements from an array.
#
# It has the non-destructive #uniq, and destructive method #uniq!
#
#     arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
#     arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]
#
# ## Iterating over Arrays
#
# Like all classes that include the Enumerable module, `Array` has an each
# method, which defines what elements should be iterated over and how.  In case
# of Array's #each, all elements in the `Array` instance are yielded to the
# supplied block in sequence.
#
# Note that this operation leaves the array unchanged.
#
#     arr = [1, 2, 3, 4, 5]
#     arr.each {|a| print a -= 10, " "}
#     # prints: -9 -8 -7 -6 -5
#     #=> [1, 2, 3, 4, 5]
#
# Another sometimes useful iterator is #reverse_each which will iterate over the
# elements in the array in reverse order.
#
#     words = %w[first second third fourth fifth sixth]
#     str = ""
#     words.reverse_each {|word| str += "#{word} "}
#     p str #=> "sixth fifth fourth third second first "
#
# The #map method can be used to create a new array based on the original array,
# but with the values modified by the supplied block:
#
#     arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
#     arr                   #=> [1, 2, 3, 4, 5]
#     arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
#     arr                   #=> [1, 4, 9, 16, 25]
#
# ## Selecting Items from an `Array`
#
# Elements can be selected from an array according to criteria defined in a
# block.  The selection can happen in a destructive or a non-destructive manner.
#  While the destructive operations will modify the array they were called on,
# the non-destructive methods usually return a new array with the selected
# elements, but leave the original array unchanged.
#
# ### Non-destructive Selection
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.select {|a| a > 3}       #=> [4, 5, 6]
#     arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
#     arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
#     arr                          #=> [1, 2, 3, 4, 5, 6]
#
# ### Destructive Selection
#
# #select! and #reject! are the corresponding destructive methods to #select and
# #reject
#
# Similar to #select vs. #reject, #delete_if and #keep_if have the exact
# opposite result when supplied with the same block:
#
#     arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
#     arr                         #=> [4, 5, 6]
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
#     arr                       #=> [1, 2, 3]
#
# ## What's Here
#
# First, what's elsewhere. Class `Array`:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# Here, class `Array` provides methods that are useful for:
#
# *   [Creating an Array](rdoc-ref:Array@Methods+for+Creating+an+Array)
# *   [Querying](rdoc-ref:Array@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Array@Methods+for+Comparing)
# *   [Fetching](rdoc-ref:Array@Methods+for+Fetching)
# *   [Assigning](rdoc-ref:Array@Methods+for+Assigning)
# *   [Deleting](rdoc-ref:Array@Methods+for+Deleting)
# *   [Combining](rdoc-ref:Array@Methods+for+Combining)
# *   [Iterating](rdoc-ref:Array@Methods+for+Iterating)
# *   [Converting](rdoc-ref:Array@Methods+for+Converting)
# *   [And more....](rdoc-ref:Array@Other+Methods)
#
# ### Methods for Creating an `Array`
#
# *   ::[]: Returns a new array populated with given objects.
# *   ::new: Returns a new array.
# *   ::try_convert: Returns a new array created from a given object.
#
# See also [Creating Arrays](rdoc-ref:Array@Creating+Arrays).
#
# ### Methods for Querying
#
# *   #all?: Returns whether all elements meet a given criterion.
# *   #any?: Returns whether any element meets a given criterion.
# *   #count: Returns the count of elements that meet a given criterion.
# *   #empty?: Returns whether there are no elements.
# *   #find_index (aliased as #index): Returns the index of the first element
#     that meets a given criterion.
# *   #hash: Returns the integer hash code.
# *   #include?: Returns whether any element `==` a given object.
# *   #length (aliased as #size): Returns the count of elements.
# *   #none?: Returns whether no element `==` a given object.
# *   #one?: Returns whether exactly one element `==` a given object.
# *   #rindex: Returns the index of the last element that meets a given
#     criterion.
#
# ### Methods for Comparing
#
# *   #<=>: Returns -1, 0, or 1, as `self` is less than, equal to, or greater
#     than a given object.
# *   #==: Returns whether each element in `self` is `==` to the corresponding
#     element in a given object.
# *   #eql?: Returns whether each element in `self` is `eql?` to the
#     corresponding element in a given object.
#
# ### Methods for Fetching
#
# These methods do not modify `self`.
#
# *   #[] (aliased as #slice): Returns consecutive elements as determined by a
#     given argument.
# *   #assoc: Returns the first element that is an array whose first element
#     `==` a given object.
# *   #at: Returns the element at a given offset.
# *   #bsearch: Returns an element selected via a binary search as determined by
#     a given block.
# *   #bsearch_index: Returns the index of an element selected via a binary
#     search as determined by a given block.
# *   #compact: Returns an array containing all non-`nil` elements.
# *   #dig: Returns the object in nested objects that is specified by a given
#     index and additional arguments.
# *   #drop: Returns trailing elements as determined by a given index.
# *   #drop_while: Returns trailing elements as determined by a given block.
# *   #fetch: Returns the element at a given offset.
# *   #fetch_values: Returns elements at given offsets.
# *   #first: Returns one or more leading elements.
# *   #last: Returns one or more trailing elements.
# *   #max: Returns one or more maximum-valued elements, as determined by `#<=>`
#     or a given block.
# *   #min: Returns one or more minimum-valued elements, as determined by `#<=>`
#     or a given block.
# *   #minmax: Returns the minimum-valued and maximum-valued elements, as
#     determined by `#<=>` or a given block.
# *   #rassoc: Returns the first element that is an array whose second element
#     `==` a given object.
# *   #reject: Returns an array containing elements not rejected by a given
#     block.
# *   #reverse: Returns all elements in reverse order.
# *   #rotate: Returns all elements with some rotated from one end to the other.
# *   #sample: Returns one or more random elements.
# *   #select (aliased as #filter): Returns an array containing elements
#     selected by a given block.
# *   #shuffle: Returns elements in a random order.
# *   #sort: Returns all elements in an order determined by `#<=>` or a given
#     block.
# *   #take: Returns leading elements as determined by a given index.
# *   #take_while: Returns leading elements as determined by a given block.
# *   #uniq: Returns an array containing non-duplicate elements.
# *   #values_at: Returns the elements at given offsets.
#
# ### Methods for Assigning
#
# These methods add, replace, or reorder elements in `self`.
#
# *   #<<: Appends an element.
# *   #[]=: Assigns specified elements with a given object.
# *   #concat: Appends all elements from given arrays.
# *   #fill: Replaces specified elements with specified objects.
# *   #flatten!: Replaces each nested array in `self` with the elements from
#     that array.
# *   #initialize_copy (aliased as #replace): Replaces the content of `self`
#     with the content of a given array.
# *   #insert: Inserts given objects at a given offset; does not replace
#     elements.
# *   #push (aliased as #append): Appends elements.
# *   #reverse!: Replaces `self` with its elements reversed.
# *   #rotate!: Replaces `self` with its elements rotated.
# *   #shuffle!: Replaces `self` with its elements in random order.
# *   #sort!: Replaces `self` with its elements sorted, as determined by `#<=>`
#     or a given block.
# *   #sort_by!: Replaces `self` with its elements sorted, as determined by a
#     given block.
# *   #unshift (aliased as #prepend): Prepends leading elements.
#
# ### Methods for Deleting
#
# Each of these methods removes elements from `self`:
#
# *   #clear: Removes all elements.
# *   #compact!: Removes all `nil` elements.
# *   #delete: Removes elements equal to a given object.
# *   #delete_at: Removes the element at a given offset.
# *   #delete_if: Removes elements specified by a given block.
# *   #keep_if: Removes elements not specified by a given block.
# *   #pop: Removes and returns the last element.
# *   #reject!: Removes elements specified by a given block.
# *   #select! (aliased as #filter!): Removes elements not specified by a given
#     block.
# *   #shift:  Removes and returns the first element.
# *   #slice!: Removes and returns a sequence of elements.
# *   #uniq!: Removes duplicates.
#
# ### Methods for Combining
#
# *   #&: Returns an array containing elements found both in `self` and a given
#     array.
# *   #+: Returns an array containing all elements of `self` followed by all
#     elements of a given array.
# *   #-: Returns an array containing all elements of `self` that are not found
#     in a given array.
# *   #|: Returns an array containing all element of `self` and all elements of
#     a given array, duplicates removed.
# *   #difference: Returns an array containing all elements of `self` that are
#     not found in any of the given arrays..
# *   #intersection: Returns an array containing elements found both in `self`
#     and in each given array.
# *   #product: Returns or yields all combinations of elements from `self` and
#     given arrays.
# *   #reverse: Returns an array containing all elements of `self` in reverse
#     order.
# *   #union: Returns an array containing all elements of `self` and all
#     elements of given arrays, duplicates removed.
#
# ### Methods for Iterating
#
# *   #combination: Calls a given block with combinations of elements of `self`;
#     a combination does not use the same element more than once.
# *   #cycle: Calls a given block with each element, then does so again, for a
#     specified number of times, or forever.
# *   #each: Passes each element to a given block.
# *   #each_index: Passes each element index to a given block.
# *   #permutation: Calls a given block with permutations of elements of `self`;
#     a permutation does not use the same element more than once.
# *   #repeated_combination: Calls a given block with combinations of elements
#     of `self`; a combination may use the same element more than once.
# *   #repeated_permutation: Calls a given block with permutations of elements
#     of `self`; a permutation may use the same element more than once.
# *   #reverse_each:  Passes each element, in reverse order, to a given block.
#
# ### Methods for Converting
#
# *   #collect (aliased as #map): Returns an array containing the block
#     return-value for each element.
# *   #collect! (aliased as #map!): Replaces each element with a block
#     return-value.
# *   #flatten: Returns an array that is a recursive flattening of `self`.
# *   #inspect (aliased as #to_s): Returns a new String containing the elements.
# *   #join: Returns a newsString containing the elements joined by the field
#     separator.
# *   #to_a: Returns `self` or a new array containing all elements.
# *   #to_ary: Returns `self`.
# *   #to_h: Returns a new hash formed from the elements.
# *   #transpose: Transposes `self`, which must be an array of arrays.
# *   #zip: Returns a new array of arrays containing `self` and given arrays.
#
# ### Other Methods
#
# *   #*: Returns one of the following:
#
#     *   With integer argument `n`, a new array that is the concatenation of
#         `n` copies of `self`.
#     *   With string argument `field_separator`, a new string that is
#         equivalent to `join(field_separator)`.
#
# *   #pack: Packs the elements into a binary sequence.
# *   #sum: Returns a sum of elements according to either `+` or a given block.
#
%a{annotate:rdoc:source:from=array.c}
class Array[unchecked out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - Array.new -> new_empty_array
  #   - Array.new(array) -> new_array
  #   - Array.new(size, default_value = nil) -> new_array
  #   - Array.new(size = 0) {|index| ... } -> new_array
  # -->
  # Returns a new array.
  #
  # With no block and no argument given, returns a new empty array:
  #
  #     Array.new # => []
  #
  # With no block and array argument given, returns a new array with the same
  # elements:
  #
  #     Array.new([:foo, 'bar', 2]) # => [:foo, "bar", 2]
  #
  # With no block and integer argument given, returns a new array containing that
  # many instances of the given `default_value`:
  #
  #     Array.new(0)    # => []
  #     Array.new(3)    # => [nil, nil, nil]
  #     Array.new(2, 3) # => [3, 3]
  #
  # With a block given, returns an array of the given `size`; calls the block with
  # each `index` in the range `(0...size)`; the element at that `index` in the
  # returned array is the blocks return value:
  #
  #     Array.new(3)  {|index| "Element #{index}" } # => ["Element 0", "Element 1", "Element 2"]
  #
  # A common pitfall for new Rubyists is providing an expression as
  # `default_value`:
  #
  #     array = Array.new(2, {})
  #     array # => [{}, {}]
  #     array[0][:a] = 1
  #     array # => [{a: 1}, {a: 1}], as array[0] and array[1] are same object
  #
  # If you want the elements of the array to be distinct, you should pass a block:
  #
  #     array = Array.new(2) { {} }
  #     array # => [{}, {}]
  #     array[0][:a] = 1
  #     array # => [{a: 1}, {}], as array[0] and array[1] are different objects
  #
  # Raises TypeError if the first argument is not either an array or an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects)).
  # Raises ArgumentError if the first argument is a negative integer.
  #
  # Related: see [Methods for Creating an
  # Array](rdoc-ref:Array@Methods+for+Creating+an+Array).
  #
  def initialize: () -> void
                | (::Array[Elem] ary) -> void
                | (int size, ?Elem val) -> void
                | (int size) { (::Integer index) -> Elem } -> void

  # <!--
  #   rdoc-file=array.c
  #   - [](*args)
  # -->
  # Returns a new array, populated with the given objects:
  #
  #     Array[1, 'a', /^A/]    # => [1, "a", /^A/]
  #     Array[]                # => []
  #     Array.[](1, 'a', /^A/) # => [1, "a", /^A/]
  #
  # Related: see [Methods for Creating an
  # Array](rdoc-ref:Array@Methods+for+Creating+an+Array).
  #
  def self.[]: [U] (*U) -> ::Array[U]

  # <!--
  #   rdoc-file=array.c
  #   - Array.try_convert(object) -> object, new_array, or nil
  # -->
  # Attempts to return an array, based on the given `object`.
  #
  # If `object` is an array, returns `object`.
  #
  # Otherwise if `object` responds to `:to_ary`. calls `object.to_ary`: if the
  # return value is an array or `nil`, returns that value; if not, raises
  # TypeError.
  #
  # Otherwise returns `nil`.
  #
  # Related: see [Methods for Creating an
  # Array](rdoc-ref:Array@Methods+for+Creating+an+Array).
  #
  def self.try_convert: [U] (untyped) -> ::Array[U]?

  # <!--
  #   rdoc-file=array.c
  #   - self & other_array -> new_array
  # -->
  # Returns a new array containing the *intersection* of `self` and `other_array`;
  # that is, containing those elements found in both `self` and `other_array`:
  #
  #     [0, 1, 2, 3] & [1, 2] # => [1, 2]
  #
  # Omits duplicates:
  #
  #     [0, 1, 1, 0] & [0, 1] # => [0, 1]
  #
  # Preserves order from `self`:
  #
  #     [0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]
  #
  # Identifies common elements using method `#eql?` (as defined in each element of
  # `self`).
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def &: (::Array[untyped] | _ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - self * n -> new_array
  #   - self * string_separator -> new_string
  # -->
  # When non-negative integer argument `n` is given, returns a new array built by
  # concatenating `n` copies of `self`:
  #
  #     a = ['x', 'y']
  #     a * 3 # => ["x", "y", "x", "y", "x", "y"]
  #
  # When string argument `string_separator` is given, equivalent to
  # `self.join(string_separator)`:
  #
  #     [0, [0, 1], {foo: 0}] * ', ' # => "0, 0, 1, {foo: 0}"
  #
  def *: (string str) -> ::String
       | (int int) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - self + other_array -> new_array
  # -->
  # Returns a new array containing all elements of `self` followed by all elements
  # of `other_array`:
  #
  #     a = [0, 1] + [2, 3]
  #     a # => [0, 1, 2, 3]
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def +: [U] (_ToAry[U]) -> ::Array[Elem | U]

  # <!--
  #   rdoc-file=array.c
  #   - self - other_array -> new_array
  # -->
  # Returns a new array containing only those elements of `self` that are not
  # found in `other_array`; the order from `self` is preserved:
  #
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1] - [1]             # => [0, 2, 3]
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1] - [3, 2, 0, :foo] # => [1, 1, 1, 1, 1, 1]
  #     [0, 1, 2] - [:foo]                            # => [0, 1, 2]
  #
  # Element are compared using method `#eql?` (as defined in each element of
  # `self`).
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def -: (_ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - self << object -> self
  # -->
  # Appends `object` as the last element in `self`; returns `self`:
  #
  #     [:foo, 'bar', 2] << :baz # => [:foo, "bar", 2, :baz]
  #
  # Appends `object` as a single element, even if it is another array:
  #
  #     [:foo, 'bar', 2] << [3, 4] # => [:foo, "bar", 2, [3, 4]]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def <<: (Elem) -> self

  # <!--
  #   rdoc-file=array.c
  #   - self <=> other_array -> -1, 0, or 1
  # -->
  # Returns -1, 0, or 1 as `self` is determined to be less than, equal to, or
  # greater than `other_array`.
  #
  # Iterates over each index `i` in `(0...self.size)`:
  #
  # *   Computes `result[i]` as `self[i] <=> other_array[i]`.
  # *   Immediately returns 1 if `result[i]` is 1:
  #
  #         [0, 1, 2] <=> [0, 0, 2] # => 1
  #
  # *   Immediately returns -1 if `result[i]` is -1:
  #
  #         [0, 1, 2] <=> [0, 2, 2] # => -1
  #
  # *   Continues if `result[i]` is 0.
  #
  # When every `result` is 0, returns `self.size <=> other_array.size` (see
  # Integer#<=>):
  #
  #     [0, 1, 2] <=> [0, 1]        # => 1
  #     [0, 1, 2] <=> [0, 1, 2]     # => 0
  #     [0, 1, 2] <=> [0, 1, 2, 3]  # => -1
  #
  # Note that when `other_array` is larger than `self`, its trailing elements do
  # not affect the result:
  #
  #     [0, 1, 2] <=> [0, 1, 2, -3] # => -1
  #     [0, 1, 2] <=> [0, 1, 2, 0]  # => -1
  #     [0, 1, 2] <=> [0, 1, 2, 3]  # => -1
  #
  # Related: see [Methods for Comparing](rdoc-ref:Array@Methods+for+Comparing).
  #
  def <=>: (untyped) -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - self == other_array -> true or false
  # -->
  # Returns whether both:
  #
  # *   `self` and `other_array` are the same size.
  # *   Their corresponding elements are the same; that is, for each index `i` in
  #     `(0...self.size)`, `self[i] == other_array[i]`.
  #
  # Examples:
  #
  #     [:foo, 'bar', 2] == [:foo, 'bar', 2]   # => true
  #     [:foo, 'bar', 2] == [:foo, 'bar', 2.0] # => true
  #     [:foo, 'bar', 2] == [:foo, 'bar']      # => false # Different sizes.
  #     [:foo, 'bar', 2] == [:foo, 'bar', 3]   # => false # Different elements.
  #
  # This method is different from method Array#eql?, which compares elements using
  # `Object#eql?`.
  #
  # Related: see [Methods for Comparing](rdoc-ref:Array@Methods+for+Comparing).
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - self[index] -> object or nil
  #   - self[start, length] -> object or nil
  #   - self[range] -> object or nil
  #   - self[aseq] -> object or nil
  #   - slice(index) -> object or nil
  #   - slice(start, length) -> object or nil
  #   - slice(range) -> object or nil
  #   - slice(aseq) -> object or nil
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # In brief:
  #
  #     a = [:foo, 'bar', 2]
  #
  #     # Single argument index: returns one element.
  #     a[0]     # => :foo          # Zero-based index.
  #     a[-1]    # => 2             # Negative index counts backwards from end.
  #
  #     # Arguments start and length: returns an array.
  #     a[1, 2]  # => ["bar", 2]
  #     a[-2, 2] # => ["bar", 2]    # Negative start counts backwards from end.
  #
  #     # Single argument range: returns an array.
  #     a[0..1]  # => [:foo, "bar"]
  #     a[0..-2] # => [:foo, "bar"] # Negative range-begin counts backwards from end.
  #     a[-2..2] # => ["bar", 2]    # Negative range-end counts backwards from end.
  #
  # When a single integer argument `index` is given, returns the element at offset
  # `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts backwards from the end of `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new
  # `Array` of size `length` containing successive elements beginning at offset
  # `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty `Array`.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty `Array`.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an `Array` of elements corresponding to the indexes produced by the sequence.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def []: %a{implicitly-returns-nil} (int index) -> Elem
        | (int start, int length) -> ::Array[Elem]?
        | (::Range[::Integer?] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - self[index] = object -> object
  #   - self[start, length] = object -> object
  #   - self[range] = object -> object
  # -->
  # Assigns elements in `self`, based on the given `object`; returns `object`.
  #
  # In brief:
  #
  #     a_orig = [:foo, 'bar', 2]
  #
  #     # With argument index.
  #     a = a_orig.dup
  #     a[0] = 'foo' # => "foo"
  #     a # => ["foo", "bar", 2]
  #     a = a_orig.dup
  #     a[7] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
  #
  #     # With arguments start and length.
  #     a = a_orig.dup
  #     a[0, 2] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #     a = a_orig.dup
  #     a[6, 50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  #     # With argument range.
  #     a = a_orig.dup
  #     a[0..1] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #     a = a_orig.dup
  #     a[6..50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # When Integer argument `index` is given, assigns `object` to an element in
  # `self`.
  #
  # If `index` is non-negative, assigns `object` the element at offset `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0] = 'foo' # => "foo"
  #     a # => ["foo", "bar", 2]
  #
  # If `index` is greater than `self.length`, extends the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[7] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
  #
  # If `index` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1] = 'two' # => "two"
  #     a # => [:foo, "bar", "two"]
  #
  # When Integer arguments `start` and `length` are given and `object` is not an
  # `Array`, removes `length - 1` elements beginning at offset `start`, and
  # assigns `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # If `start` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-2, 2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If `start` is non-negative and outside the array (` >= self.size`), extends
  # the array with `nil`, assigns `object` at offset `start`, and ignores
  # `length`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[6, 50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `length` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1, 0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `length` is too large for the existing array, does not extend the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1, 5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # When Range argument `range` is given and `object` is not an `Array`, removes
  # `length - 1` elements beginning at offset `start`, and assigns `object` at
  # offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..1] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # if `range.begin` is negative, counts backwards from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-2..2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If the array length is less than `range.begin`, extends the array with `nil`,
  # assigns `object` at offset `range.begin`, and ignores `length`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[6..50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `range.end` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `range.end` is negative, assigns `object` at offset `start`, retains
  # `range.end.abs -1` elements past that, and removes those beyond:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..-1] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #     a = [:foo, 'bar', 2]
  #     a[1..-2] = 'foo' # => "foo"
  #     a # => [:foo, "foo", 2]
  #     a = [:foo, 'bar', 2]
  #     a[1..-3] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #     a = [:foo, 'bar', 2]
  #
  # If `range.end` is too large for the existing array, replaces array elements,
  # but does not extend the array with `nil` values:
  #
  #     a = [:foo, 'bar', 2]
  #     a[1..5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def []=: (int index, Elem obj) -> Elem
         | (int start, int length, Elem obj) -> Elem
         | (int start, int length, ::Array[Elem]) -> ::Array[Elem]
         | (int start, int length, nil) -> nil
         | (::Range[::Integer?], Elem obj) -> Elem
         | (::Range[::Integer?], ::Array[Elem]) -> ::Array[Elem]
         | (::Range[::Integer?], nil) -> nil

  # <!--
  #   rdoc-file=array.c
  #   - all? -> true or false
  #   - all?(object) -> true or false
  #   - all? {|element| ... } -> true or false
  # -->
  # Returns whether for every element of `self`, a given criterion is satisfied.
  #
  # With no block and no argument, returns whether every element of `self` is
  # truthy:
  #
  #     [[], {}, '', 0, 0.0, Object.new].all? # => true  # All truthy objects.
  #     [[], {}, '', 0, 0.0, nil].all?        # => false # nil is not truthy.
  #     [[], {}, '', 0, 0.0, false].all?      # => false # false is not truthy.
  #
  # With argument `object` given, returns whether `object === ele` for every
  # element `ele` in `self`:
  #
  #     [0, 0, 0].all?(0)                    # => true
  #     [0, 1, 2].all?(1)                    # => false
  #     ['food', 'fool', 'foot'].all?(/foo/) # => true
  #     ['food', 'drink'].all?(/foo/)        # => false
  #
  # With a block given, calls the block with each element in `self`; returns
  # whether the block returns only truthy values:
  #
  #     [0, 1, 2].all? { |ele| ele < 3 } # => true
  #     [0, 1, 2].all? { |ele| ele < 2 } # => false
  #
  # With both a block and argument `object` given, ignores the block and uses
  # `object` as above.
  #
  # **Special case**: returns `true` if `self` is empty (regardless of any given
  # argument or block).
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def all?: () -> bool
          | (_Pattern[Elem] pattern) -> bool
          | () { (Elem obj) -> boolish } -> bool

  # <!--
  #   rdoc-file=array.c
  #   - any? -> true or false
  #   - any?(object) -> true or false
  #   - any? {|element| ... } -> true or false
  # -->
  # Returns whether for any element of `self`, a given criterion is satisfied.
  #
  # With no block and no argument, returns whether any element of `self` is
  # truthy:
  #
  #     [nil, false, []].any? # => true  # Array object is truthy.
  #     [nil, false, {}].any? # => true  # Hash object is truthy.
  #     [nil, false, ''].any? # => true  # String object is truthy.
  #     [nil, false].any?     # => false # Nil and false are not truthy.
  #
  # With argument `object` given, returns whether `object === ele` for any element
  # `ele` in `self`:
  #
  #     [nil, false, 0].any?(0)          # => true
  #     [nil, false, 1].any?(0)          # => false
  #     [nil, false, 'food'].any?(/foo/) # => true
  #     [nil, false, 'food'].any?(/bar/) # => false
  #
  # With a block given, calls the block with each element in `self`; returns
  # whether the block returns any truthy value:
  #
  #     [0, 1, 2].any? {|ele| ele < 1 } # => true
  #     [0, 1, 2].any? {|ele| ele < 0 } # => false
  #
  # With both a block and argument `object` given, ignores the block and uses
  # `object` as above.
  #
  # **Special case**: returns `false` if `self` is empty (regardless of any given
  # argument or block).
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  alias any? all?

  # <!-- rdoc-file=array.c -->
  # Appends each argument in `objects` to `self`; returns `self`:
  #
  #     a = [:foo, 'bar', 2] # => [:foo, "bar", 2]
  #     a.push(:baz, :bat)   # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as a single element, even if it is another array:
  #
  #     a = [:foo, 'bar', 2]               # => [:foo, "bar", 2]
  #     a.push([:baz, :bat], [:bam, :bad]) # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  alias append push

  # <!--
  #   rdoc-file=array.c
  #   - assoc(object) -> found_array or nil
  # -->
  # Returns the first element `ele` in `self` such that `ele` is an array and
  # `ele[0] == object`:
  #
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.assoc(4) # => [4, 5, 6]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: Array#rassoc; see also [Methods for
  # Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def assoc: (untyped) -> ::Array[untyped]?

  # <!--
  #   rdoc-file=array.c
  #   - at(index) -> object or nil
  # -->
  # Returns the element of `self` specified by the given `index` or `nil` if there
  # is no such element; `index` must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  #
  # For non-negative `index`, returns the element of `self` at offset `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.at(0)   # => :foo
  #     a.at(2)   # => 2
  #     a.at(2.0) # => 2
  #
  # For negative `index`, counts backwards from the end of `self`:
  #
  #     a.at(-2) # => "bar"
  #
  # Related: Array#[]; see also [Methods for
  # Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def at: %a{implicitly-returns-nil} (int index) -> Elem

  # <!--
  #   rdoc-file=array.c
  #   - bsearch {|element| ... } -> found_element or nil
  #   - bsearch -> new_enumerator
  # -->
  # Returns the element from `self` found by a binary search, or `nil` if the
  # search found no suitable element.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - bsearch_index {|element| ... } -> integer or nil
  #   - bsearch_index -> new_enumerator
  # -->
  # Returns the integer index of the element from `self` found by a binary search,
  # or `nil` if the search found no suitable element.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def bsearch_index: () { (Elem) -> (true | false) } -> ::Integer?
                   | () { (Elem) -> ::Integer } -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - clear -> self
  # -->
  # Removes all elements from `self`; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.clear # => []
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - collect {|element| ... } -> new_array
  #   - collect -> new_enumerator
  #   - map {|element| ... } -> new_array
  #   - map -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self`; returns a new
  # array whose elements are the return values from the block:
  #
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: #collect!; see also [Methods for
  # Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def collect: [U] () { (Elem item) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - collect! {|element| ... } -> new_array
  #   - collect! -> new_enumerator
  #   - map! {|element| ... } -> new_array
  #   - map! -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self` and replaces
  # the element with the block's return value; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: #collect; see also [Methods for
  # Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def collect!: () { (Elem item) -> Elem } -> self
              | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - combination(count) {|element| ... } -> self
  #   - combination(count) -> new_enumerator
  # -->
  # When a block and a positive [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects)
  # argument `count` (`0 < count <= self.size`) are given, calls the block with
  # each combination of `self` of size `count`; returns `self`:
  #
  #     a = %w[a b c]                                   # => ["a", "b", "c"]
  #     a.combination(2) {|combination| p combination } # => ["a", "b", "c"]
  #
  # Output:
  #
  #     ["a", "b"]
  #     ["a", "c"]
  #     ["b", "c"]
  #
  # The order of the yielded combinations is not guaranteed.
  #
  # When `count` is zero, calls the block once with a new empty array:
  #
  #     a.combination(0) {|combination| p combination }
  #     [].combination(0) {|combination| p combination }
  #
  # Output:
  #
  #     []
  #     []
  #
  # When `count` is negative or larger than `self.size` and `self` is non-empty,
  # does not call the block:
  #
  #     a.combination(-1) {|combination| fail 'Cannot happen' } # => ["a", "b", "c"]
  #     a.combination(4)  {|combination| fail 'Cannot happen' } # => ["a", "b", "c"]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: Array#permutation; see also [Methods for
  # Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def combination: (int n) { (::Array[Elem]) -> void } -> self
                 | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - compact -> new_array
  # -->
  # Returns a new array containing only the non-`nil` elements from `self`;
  # element order is preserved:
  #
  #     a = [nil, 0, nil, false, nil, '', nil, [], nil, {}]
  #     a.compact # => [0, false, "", [], {}]
  #
  # Related: Array#compact!; see also [Methods for
  # Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def compact: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - compact! -> self or nil
  # -->
  # Removes all `nil` elements from `self`; Returns `self` if any elements are
  # removed, `nil` otherwise:
  #
  #     a = [nil, 0, nil, false, nil, '', nil, [], nil, {}]
  #     a.compact! # => [0, false, "", [], {}]
  #     a          # => [0, false, "", [], {}]
  #     a.compact! # => nil
  #
  # Related: Array#compact; see also [Methods for
  # Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=array.c
  #   - concat(*other_arrays) -> self
  # -->
  # Adds to `self` all elements from each array in `other_arrays`; returns `self`:
  #
  #     a = [0, 1]
  #     a.concat(['two', 'three'], [:four, :five], a)
  #     # => [0, 1, "two", "three", :four, :five, 0, 1]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def concat: (*::Array[Elem] arrays) -> self

  # <!--
  #   rdoc-file=array.c
  #   - count -> integer
  #   - count(object) -> integer
  #   - count {|element| ... } -> integer
  # -->
  # Returns a count of specified elements.
  #
  # With no argument and no block, returns the count of all elements:
  #
  #     [0, :one, 'two', 3, 3.0].count # => 5
  #
  # With argument `object` given, returns the count of elements `==` to `object`:
  #
  #     [0, :one, 'two', 3, 3.0].count(3) # => 2
  #
  # With no argument and a block given, calls the block with each element; returns
  # the count of elements for which the block returns a truthy value:
  #
  #     [0, 1, 2, 3].count {|element| element > 1 } # => 2
  #
  # With argument `object` and a block given, issues a warning, ignores the block,
  # and returns the count of elements `==` to `object`.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def count: () -> ::Integer
           | (Elem obj) -> ::Integer
           | () { (Elem) -> boolish } -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - cycle(count = nil) {|element| ... } -> nil
  #   - cycle(count = nil) -> new_enumerator
  # -->
  # With a block given, may call the block, depending on the value of argument
  # `count`; `count` must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects), or
  # `nil`.
  #
  # When `count` is positive, calls the block with each element, then does so
  # repeatedly, until it has done so `count` times; returns `nil`:
  #
  #     output = []
  #     [0, 1].cycle(2) {|element| output.push(element) } # => nil
  #     output # => [0, 1, 0, 1]
  #
  # When `count` is zero or negative, does not call the block:
  #
  #     [0, 1].cycle(0) {|element| fail 'Cannot happen' }  # => nil
  #     [0, 1].cycle(-1) {|element| fail 'Cannot happen' } # => nil
  #
  # When `count` is `nil`, cycles forever:
  #
  #     # Prints 0 and 1 forever.
  #     [0, 1].cycle {|element| puts element }
  #     [0, 1].cycle(nil) {|element| puts element }
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def cycle: (?int? n) { (Elem) -> void } -> nil
           | (?int? n) -> ::Enumerator[Elem, nil]

  # <!--
  #   rdoc-file=array.c
  #   - deconstruct()
  # -->
  #
  def deconstruct: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - delete(object) -> last_removed_object
  #   - delete(object) {|element| ... } -> last_removed_object or block_return
  # -->
  # Removes zero or more elements from `self`.
  #
  # With no block given, removes from `self` each element `ele` such that `ele ==
  # object`; returns the last removed element:
  #
  #     a = [0, 1, 2, 2.0]
  #     a.delete(2) # => 2.0
  #     a           # => [0, 1]
  #
  # Returns `nil` if no elements removed:
  #
  #     a.delete(2) # => nil
  #
  # With a block given, removes from `self` each element `ele` such that `ele ==
  # object`.
  #
  # If any such elements are found, ignores the block and returns the last removed
  # element:
  #
  #     a = [0, 1, 2, 2.0]
  #     a.delete(2) {|element| fail 'Cannot happen' } # => 2.0
  #     a                                             # => [0, 1]
  #
  # If no such element is found, returns the block's return value:
  #
  #     a.delete(2) {|element| "Element #{element} not found." }
  #     # => "Element 2 not found."
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def delete: (Elem obj) -> Elem?
            | [S, T] (S obj) { (S) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.c
  #   - delete_at(index) -> removed_object or nil
  # -->
  # Removes the element of `self` at the given `index`, which must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  #
  # When `index` is non-negative, deletes the element at offset `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # When `index` is negative, counts backward from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(-2) # => "bar"
  #     a # => [:foo, 2]
  #
  # When `index` is out of range, returns `nil`.
  #
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(3)  # => nil
  #     a.delete_at(-4) # => nil
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def delete_at: %a{implicitly-returns-nil} (int index) -> Elem

  # <!--
  #   rdoc-file=array.c
  #   - delete_if {|element| ... } -> self
  #   - delete_if -> new_numerator
  # -->
  # With a block given, calls the block with each element of `self`; removes the
  # element if the block returns a truthy value; returns `self`:
  #
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.delete_if {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def delete_if: () { (Elem item) -> boolish } -> self
               | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - difference(*other_arrays = []) -> new_array
  # -->
  # Returns a new array containing only those elements from `self` that are not
  # found in any of the given `other_arrays`; items are compared using `eql?`;
  # order from `self` is preserved:
  #
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # => [0, 2, 3]
  #     [0, 1, 2, 3].difference([3, 0], [1, 3])     # => [2]
  #     [0, 1, 2].difference([4])                   # => [0, 1, 2]
  #     [0, 1, 2].difference                        # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments are given.
  #
  # Related: Array#-; see also [Methods for
  # Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def difference: (*::Array[untyped] arrays) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.dig(index, *identifiers) -> object
  # -->
  # Finds and returns the object in nested object specified by `index` and
  # `identifiers`; the nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Examples:
  #
  #     a = [:foo, [:bar, :baz, [:bat, :bam]]]
  #     a.dig(1) # => [:bar, :baz, [:bat, :bam]]
  #     a.dig(1, 2) # => [:bat, :bam]
  #     a.dig(1, 2, 0) # => :bat
  #     a.dig(1, 2, 3) # => nil
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def dig: (int idx) -> Elem?
         | (int idx, untyped, *untyped) -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - drop(count) -> new_array
  # -->
  # Returns a new array containing all but the first `count` element of `self`,
  # where `count` is a non-negative integer; does not modify `self`.
  #
  # Examples:
  #
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop(0) # => [0, 1, 2, 3, 4, 5]
  #     a.drop(1) # => [1, 2, 3, 4, 5]
  #     a.drop(2) # => [2, 3, 4, 5]
  #     a.drop(9) # => []
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def drop: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - drop_while {|element| ... } -> new_array
  #   - drop_while -> new_enumerator
  # -->
  # With a block given, calls the block with each successive element of `self`;
  # stops if the block returns `false` or `nil`; returns a new array *omitting*
  # those elements for which the block returned a truthy value; does not modify
  # `self`:
  #
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop_while {|element| element < 3 } # => [3, 4, 5]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def drop_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - each {|element| ... } -> self
  #   - each -> new_enumerator
  # -->
  # With a block given, iterates over the elements of `self`, passing each element
  # to the block; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Allows the array to be modified during iteration:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #
  #     foo
  #     bar
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def each: () -> ::Enumerator[Elem, self]
          | () { (Elem item) -> void } -> self

  # <!--
  #   rdoc-file=array.c
  #   - each_index {|index| ... } -> self
  #   - each_index -> new_enumerator
  # -->
  # With a block given, iterates over the elements of `self`, passing each *array
  # index* to the block; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index|  puts "#{index} #{a[index]}" }
  #
  # Output:
  #
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Allows the array to be modified during iteration:
  #
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index| puts index; a.clear if index > 0 }
  #     a # => []
  #
  # Output:
  #
  #     0
  #     1
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def each_index: () { (::Integer index) -> void } -> self
                | () -> ::Enumerator[::Integer, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.empty?  -> true or false
  # -->
  # Returns `true` if the count of elements in `self` is zero, `false` otherwise.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=array.c
  #   - eql?(other_array) -> true or false
  # -->
  # Returns `true` if `self` and `other_array` are the same size, and if, for each
  # index `i` in `self`, `self[i].eql?(other_array[i])`:
  #
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2]
  #     a1.eql?(a0) # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method Array#==, which compares using method
  # `Object#==`.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - fetch(index) -> element
  #   - fetch(index, default_value) -> element or default_value
  #   - fetch(index) {|index| ... } -> element or block_return_value
  # -->
  # Returns the element of `self` at offset `index` if `index` is in range;
  # `index` must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  #
  # With the single argument `index` and no block, returns the element at offset
  # `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1)   # => "bar"
  #     a.fetch(1.1) # => "bar"
  #
  # If `index` is negative, counts from the end of the array:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(-1) # => 2
  #     a.fetch(-2) # => "bar"
  #
  # With arguments `index` and `default_value` (which may be any object) and no
  # block, returns `default_value` if `index` is out-of-range:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1, nil)  # => "bar"
  #     a.fetch(3, :foo) # => :foo
  #
  # With argument `index` and a block, returns the element at offset `index` if
  # index is in range (and the block is not called); otherwise calls the block
  # with index and returns its return value:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1) {|index| raise 'Cannot happen' } # => "bar"
  #     a.fetch(50) {|index| "Value for #{index}" } # => "Value for 50"
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def fetch: (int index) -> Elem
           | [T] (int index, T default) -> (Elem | T)
           | [T] (int index) { (int index) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.rb
  #   - fetch_values(*indexes) -> new_array
  #   - fetch_values(*indexes) { |index| ... } -> new_array
  # -->
  # With no block given, returns a new array containing the elements of `self` at
  # the offsets specified by `indexes`. Each of the `indexes` must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects):
  #
  #     a = [:foo, :bar, :baz]
  #     a.fetch_values(2, 0)   # => [:baz, :foo]
  #     a.fetch_values(2.1, 0) # => [:baz, :foo]
  #     a.fetch_values         # => []
  #
  # For a negative index, counts backwards from the end of the array:
  #
  #     a.fetch_values(-2, -1) # [:bar, :baz]
  #
  # When no block is given, raises an exception if any index is out of range.
  #
  # With a block given, for each index:
  #
  # *   If the index is in range, uses an element of `self` (as above).
  # *   Otherwise, calls the block with the index and uses the block's return
  #     value.
  #
  # Example:
  #
  #     a = [:foo, :bar, :baz]
  #     a.fetch_values(1, 0, 42, 777) { |index| index.to_s }
  #     # => [:bar, :foo, "42", "777"]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def fetch_values: (*int indexes) -> self

  # <!--
  #   rdoc-file=array.c
  #   - fill(object, start = nil, count = nil) -> new_array
  #   - fill(object, range) -> new_array
  #   - fill(start = nil, count = nil) {|element| ... } -> new_array
  #   - fill(range) {|element| ... } -> new_array
  # -->
  # Replaces selected elements in `self`; may add elements to `self`; always
  # returns `self` (never a new array).
  #
  # In brief:
  #
  #     # Non-negative start.
  #     ['a', 'b', 'c', 'd'].fill('-', 1, 2)          # => ["a", "-", "-", "d"]
  #     ['a', 'b', 'c', 'd'].fill(1, 2) {|e| e.to_s } # => ["a", "1", "2", "d"]
  #
  #     # Extends with specified values if necessary.
  #     ['a', 'b', 'c', 'd'].fill('-', 3, 2)          # => ["a", "b", "c", "-", "-"]
  #     ['a', 'b', 'c', 'd'].fill(3, 2) {|e| e.to_s } # => ["a", "b", "c", "3", "4"]
  #
  #     # Fills with nils if necessary.
  #     ['a', 'b', 'c', 'd'].fill('-', 6, 2)          # => ["a", "b", "c", "d", nil, nil, "-", "-"]
  #     ['a', 'b', 'c', 'd'].fill(6, 2) {|e| e.to_s } # => ["a", "b", "c", "d", nil, nil, "6", "7"]
  #
  #     # For negative start, counts backwards from the end.
  #     ['a', 'b', 'c', 'd'].fill('-', -3, 3)          # => ["a", "-", "-", "-"]
  #     ['a', 'b', 'c', 'd'].fill(-3, 3) {|e| e.to_s } # => ["a", "1", "2", "3"]
  #
  #     # Range.
  #     ['a', 'b', 'c', 'd'].fill('-', 1..2)          # => ["a", "-", "-", "d"]
  #     ['a', 'b', 'c', 'd'].fill(1..2) {|e| e.to_s } # => ["a", "1", "2", "d"]
  #
  # When arguments `start` and `count` are given, they select the elements of
  # `self` to be replaced; each must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects) (or
  # `nil`):
  #
  # *   `start` specifies the zero-based offset of the first element to be
  #     replaced; `nil` means zero.
  # *   `count` is the number of consecutive elements to be replaced; `nil` means
  #     "all the rest."
  #
  # With argument `object` given, that one object is used for all replacements:
  #
  #     o = Object.new           # => #<Object:0x0000014e7bff7600>
  #     a = ['a', 'b', 'c', 'd'] # => ["a", "b", "c", "d"]
  #     a.fill(o, 1, 2)
  #     # => ["a", #<Object:0x0000014e7bff7600>, #<Object:0x0000014e7bff7600>, "d"]
  #
  # With a block given, the block is called once for each element to be replaced;
  # the value passed to the block is the *index* of the element to be replaced
  # (not the element itself); the block's return value replaces the element:
  #
  #     a = ['a', 'b', 'c', 'd']               # => ["a", "b", "c", "d"]
  #     a.fill(1, 2) {|element| element.to_s } # => ["a", "1", "2", "d"]
  #
  # For arguments `start` and `count`:
  #
  # *   If `start` is non-negative, replaces `count` elements beginning at offset
  #     `start`:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 0, 2) # => ["-", "-", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 1, 2) # => ["a", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 2, 2) # => ["a", "b", "-", "-"]
  #
  #         ['a', 'b', 'c', 'd'].fill(0, 2) {|e| e.to_s } # => ["0", "1", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(1, 2) {|e| e.to_s } # => ["a", "1", "2", "d"]
  #         ['a', 'b', 'c', 'd'].fill(2, 2) {|e| e.to_s } # => ["a", "b", "2", "3"]
  #
  #     Extends `self` if necessary:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 3, 2) # => ["a", "b", "c", "-", "-"]
  #         ['a', 'b', 'c', 'd'].fill('-', 4, 2) # => ["a", "b", "c", "d", "-", "-"]
  #
  #         ['a', 'b', 'c', 'd'].fill(3, 2) {|e| e.to_s } # => ["a", "b", "c", "3", "4"]
  #         ['a', 'b', 'c', 'd'].fill(4, 2) {|e| e.to_s } # => ["a", "b", "c", "d", "4", "5"]
  #
  #     Fills with `nil` if necessary:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 5, 2) # => ["a", "b", "c", "d", nil, "-", "-"]
  #         ['a', 'b', 'c', 'd'].fill('-', 6, 2) # => ["a", "b", "c", "d", nil, nil, "-", "-"]
  #
  #         ['a', 'b', 'c', 'd'].fill(5, 2) {|e| e.to_s } # => ["a", "b", "c", "d", nil, "5", "6"]
  #         ['a', 'b', 'c', 'd'].fill(6, 2) {|e| e.to_s } # => ["a", "b", "c", "d", nil, nil, "6", "7"]
  #
  #     Does nothing if `count` is non-positive:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 2, 0)    # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 2, -100) # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 6, -100) # => ["a", "b", "c", "d"]
  #
  #         ['a', 'b', 'c', 'd'].fill(2, 0) {|e| fail 'Cannot happen' }    # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(2, -100) {|e| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(6, -100) {|e| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # *   If `start` is negative, counts backwards from the end of `self`:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', -4, 3) # => ["-", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', -3, 3) # => ["a", "-", "-", "-"]
  #
  #         ['a', 'b', 'c', 'd'].fill(-4, 3) {|e| e.to_s } # => ["0", "1", "2", "d"]
  #         ['a', 'b', 'c', 'd'].fill(-3, 3) {|e| e.to_s } # => ["a", "1", "2", "3"]
  #
  #     Extends `self` if necessary:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', -2, 3) # => ["a", "b", "-", "-", "-"]
  #         ['a', 'b', 'c', 'd'].fill('-', -1, 3) # => ["a", "b", "c", "-", "-", "-"]
  #
  #         ['a', 'b', 'c', 'd'].fill(-2, 3) {|e| e.to_s } # => ["a", "b", "2", "3", "4"]
  #         ['a', 'b', 'c', 'd'].fill(-1, 3) {|e| e.to_s } # => ["a", "b", "c", "3", "4", "5"]
  #
  #     Starts at the beginning of `self` if `start` is negative and out-of-range:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', -5, 2) # => ["-", "-", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', -6, 2) # => ["-", "-", "c", "d"]
  #
  #         ['a', 'b', 'c', 'd'].fill(-5, 2) {|e| e.to_s } # => ["0", "1", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(-6, 2) {|e| e.to_s } # => ["0", "1", "c", "d"]
  #
  #     Does nothing if `count` is non-positive:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', -2, 0)  # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', -2, -1) # => ["a", "b", "c", "d"]
  #
  #         ['a', 'b', 'c', 'd'].fill(-2, 0) {|e| fail 'Cannot happen' }  # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(-2, -1) {|e| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # When argument `range` is given, it must be a Range object whose members are
  # numeric; its `begin` and `end` values determine the elements of `self` to be
  # replaced:
  #
  # *   If both `begin` and `end` are positive, they specify the first and last
  #     elements to be replaced:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 1..2)          # => ["a", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill(1..2) {|e| e.to_s } # => ["a", "1", "2", "d"]
  #
  #     If `end` is smaller than `begin`, replaces no elements:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 2..1)          # => ["a", "b", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(2..1) {|e| e.to_s } # => ["a", "b", "c", "d"]
  #
  # *   If either is negative (or both are negative), counts backwards from the
  #     end of `self`:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', -3..2)  # => ["a", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 1..-2)  # => ["a", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', -3..-2) # => ["a", "-", "-", "d"]
  #
  #         ['a', 'b', 'c', 'd'].fill(-3..2) {|e| e.to_s }  # => ["a", "1", "2", "d"]
  #         ['a', 'b', 'c', 'd'].fill(1..-2) {|e| e.to_s }  # => ["a", "1", "2", "d"]
  #         ['a', 'b', 'c', 'd'].fill(-3..-2) {|e| e.to_s } # => ["a", "1", "2", "d"]
  #
  # *   If the `end` value is excluded (see Range#exclude_end?), omits the last
  #     replacement:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 1...2)  # => ["a", "-", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill('-', 1...-2) # => ["a", "-", "c", "d"]
  #
  #         ['a', 'b', 'c', 'd'].fill(1...2) {|e| e.to_s }  # => ["a", "1", "c", "d"]
  #         ['a', 'b', 'c', 'd'].fill(1...-2) {|e| e.to_s } # => ["a", "1", "c", "d"]
  #
  # *   If the range is endless (see [Endless
  #     Ranges](rdoc-ref:Range@Endless+Ranges)), replaces elements to the end of
  #     `self`:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', 1..)          # => ["a", "-", "-", "-"]
  #         ['a', 'b', 'c', 'd'].fill(1..) {|e| e.to_s } # => ["a", "1", "2", "3"]
  #
  # *   If the range is beginless (see [Beginless
  #     Ranges](rdoc-ref:Range@Beginless+Ranges)), replaces elements from the
  #     beginning of `self`:
  #
  #         ['a', 'b', 'c', 'd'].fill('-', ..2)          # => ["-", "-", "-", "d"]
  #         ['a', 'b', 'c', 'd'].fill(..2) {|e| e.to_s } # => ["0", "1", "2", "d"]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def fill: (Elem obj) -> self
          | (Elem obj, int? start, ?int? length) -> self
          | (Elem obj, ::Range[::Integer] range) -> self
          | (?int? start, ?int? length) { (::Integer index) -> Elem } -> self
          | (::Range[::Integer] range) { (::Integer index) -> Elem } -> self

  # <!-- rdoc-file=array.c -->
  # With a block given, calls the block with each element of `self`; returns a new
  # array containing those elements of `self` for which the block returns a truthy
  # value:
  #
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select {|element| element.to_s.start_with?('b') }
  #     # => ["bar", :bam]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def filter: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=array.c -->
  # With a block given, calls the block with each element of `self`; removes from
  # `self` those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def filter!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - find_index(object) -> integer or nil
  #   - find_index {|element| ... } -> integer or nil
  #   - find_index -> new_enumerator
  #   - index(object) -> integer or nil
  #   - index {|element| ... } -> integer or nil
  #   - index -> new_enumerator
  # -->
  # Returns the zero-based integer index of a specified element, or `nil`.
  #
  # With only argument `object` given, returns the index of the first element
  # `element` for which `object == element`:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # With only a block given, calls the block with each successive element; returns
  # the index of the first element for which the block returns a truthy value:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # With neither an argument nor a block given, returns a new Enumerator.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def find_index: (untyped obj) -> ::Integer?
                | () { (Elem item) -> boolish } -> ::Integer?
                | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.rb
  #   - first -> object or nil
  #   - first(count) -> new_array
  # -->
  # Returns elements from `self`, or `nil`; does not modify `self`.
  #
  # With no argument given, returns the first element (if available):
  #
  #     a = [:foo, 'bar', 2]
  #     a.first # => :foo
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  #     [].first # => nil
  #
  # With a non-negative integer argument `count` given, returns the first `count`
  # elements (as available) in a new array:
  #
  #     a.first(0)  # => []
  #     a.first(2)  # => [:foo, "bar"]
  #     a.first(50) # => [:foo, "bar", 2]
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def first: %a{implicitly-returns-nil} () -> Elem
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - flatten(depth = nil) -> new_array
  # -->
  # Returns a new array that is a recursive flattening of `self` to `depth` levels
  # of recursion; `depth` must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects) or
  # `nil`. At each level of recursion:
  #
  # *   Each element that is an array is "flattened" (that is, replaced by its
  #     individual array elements).
  # *   Each element that is not an array is unchanged (even if the element is an
  #     object that has instance method `flatten`).
  #
  # With non-negative integer argument `depth`, flattens recursively through
  # `depth` levels:
  #
  #     a = [ 0, [ 1, [2, 3], 4 ], 5, {foo: 0}, Set.new([6, 7]) ]
  #     a              # => [0, [1, [2, 3], 4], 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(0)   # => [0, [1, [2, 3], 4], 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(1  ) # => [0, 1, [2, 3], 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(1.1) # => [0, 1, [2, 3], 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(2)   # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(3)   # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #
  # With `nil` or negative `depth`, flattens all levels.
  #
  #     a.flatten     # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.flatten(-1) # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #
  # Related: Array#flatten!; see also [Methods for
  # Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def flatten: (?int level) -> ::Array[untyped]

  # <!--
  #   rdoc-file=array.c
  #   - flatten!(depth = nil) -> self or nil
  # -->
  # Returns `self` as a recursively flattening of `self` to `depth` levels of
  # recursion; `depth` must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects), or
  # `nil`. At each level of recursion:
  #
  # *   Each element that is an array is "flattened" (that is, replaced by its
  #     individual array elements).
  # *   Each element that is not an array is unchanged (even if the element is an
  #     object that has instance method `flatten`).
  #
  # Returns `nil` if no elements were flattened.
  #
  # With non-negative integer argument `depth`, flattens recursively through
  # `depth` levels:
  #
  #     a = [ 0, [ 1, [2, 3], 4 ], 5, {foo: 0}, Set.new([6, 7]) ]
  #     a                   # => [0, [1, [2, 3], 4], 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.dup.flatten!(1)   # => [0, 1, [2, 3], 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.dup.flatten!(1.1) # => [0, 1, [2, 3], 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.dup.flatten!(2)   # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.dup.flatten!(3)   # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #
  # With `nil` or negative argument `depth`, flattens all levels:
  #
  #     a.dup.flatten!     # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #     a.dup.flatten!(-1) # => [0, 1, 2, 3, 4, 5, {:foo=>0}, #<Set: {6, 7}>]
  #
  # Related: Array#flatten; see also [Methods for
  # Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def flatten!: (?int level) -> self?

  # <!--
  #   rdoc-file=array.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two arrays with the same content will have the same hash value (and will
  # compare using eql?):
  #
  #     ['a', 'b'].hash == ['a', 'b'].hash # => true
  #     ['a', 'b'].hash == ['a', 'c'].hash # => false
  #     ['a', 'b'].hash == ['a'].hash      # => false
  #
  def hash: () -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - include?(object) -> true or false
  # -->
  # Returns whether for some element `element` in `self`, `object == element`:
  #
  #     [0, 1, 2].include?(2)   # => true
  #     [0, 1, 2].include?(2.0) # => true
  #     [0, 1, 2].include?(2.1) # => false
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def include?: (Elem object) -> bool

  # <!-- rdoc-file=array.c -->
  # Returns the zero-based integer index of a specified element, or `nil`.
  #
  # With only argument `object` given, returns the index of the first element
  # `element` for which `object == element`:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # With only a block given, calls the block with each successive element; returns
  # the index of the first element for which the block returns a truthy value:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # With neither an argument nor a block given, returns a new Enumerator.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  alias index find_index

  # <!--
  #   rdoc-file=array.c
  #   - insert(index, *objects) -> self
  # -->
  # Inserts the given `objects` as elements of `self`; returns `self`.
  #
  # When `index` is non-negative, inserts `objects` *before* the element at offset
  # `index`:
  #
  #     a = ['a', 'b', 'c']     # => ["a", "b", "c"]
  #     a.insert(1, :x, :y, :z) # => ["a", :x, :y, :z, "b", "c"]
  #
  # Extends the array if `index` is beyond the array (`index >= self.size`):
  #
  #     a = ['a', 'b', 'c']     # => ["a", "b", "c"]
  #     a.insert(5, :x, :y, :z) # => ["a", "b", "c", nil, nil, :x, :y, :z]
  #
  # When `index` is negative, inserts `objects` *after* the element at offset
  # `index + self.size`:
  #
  #     a = ['a', 'b', 'c']      # => ["a", "b", "c"]
  #     a.insert(-2, :x, :y, :z) # => ["a", "b", :x, :y, :z, "c"]
  #
  # With no `objects` given, does nothing:
  #
  #     a = ['a', 'b', 'c'] # => ["a", "b", "c"]
  #     a.insert(1)         # => ["a", "b", "c"]
  #     a.insert(50)        # => ["a", "b", "c"]
  #     a.insert(-50)       # => ["a", "b", "c"]
  #
  # Raises IndexError if `objects` are given and `index` is negative and out of
  # range.
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def insert: (int index, *Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - inspect -> new_string
  #   - to_s -> new_string
  # -->
  # Returns the new string formed by calling method `#inspect` on each array
  # element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=array.c
  #   - intersect?(other_array) -> true or false
  # -->
  # Returns whether `other_array` has at least one element that is `#eql?` to some
  # element of `self`:
  #
  #     [1, 2, 3].intersect?([3, 4, 5]) # => true
  #     [1, 2, 3].intersect?([4, 5, 6]) # => false
  #
  # Each element must correctly implement method `#hash`.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def intersect?: (_ToAry[untyped]) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - intersection(*other_arrays) -> new_array
  # -->
  # Returns a new array containing each element in `self` that is `#eql?` to at
  # least one element in each of the given `other_arrays`; duplicates are omitted:
  #
  #     [0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
  #
  # Each element must correctly implement method `#hash`.
  #
  # Order from `self` is preserved:
  #
  #     [0, 1, 2].intersection([2, 1, 0]) # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments are given.
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def intersection: (*::Array[untyped] | _ToAry[untyped] other_ary) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.join(separator = $,) -> new_string
  # -->
  # Returns the new string formed by joining the converted elements of `self`; for
  # each element `element`:
  #
  # *   Converts recursively using `element.join(separator)` if `element` is a
  #     `kind_of?(Array)`.
  # *   Otherwise, converts using `element.to_s`.
  #
  # With no argument given, joins using the output field separator, `$,`:
  #
  #     a = [:foo, 'bar', 2]
  #     $, # => nil
  #     a.join # => "foobar2"
  #
  # With string argument `separator` given, joins using that separator:
  #
  #     a = [:foo, 'bar', 2]
  #     a.join("\n") # => "foo\nbar\n2"
  #
  # Joins recursively for nested arrays:
  #
  #     a = [:foo, [:bar, [:baz, :bat]]]
  #     a.join # => "foobarbazbat"
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def join: (?string separator) -> String

  # <!--
  #   rdoc-file=array.c
  #   - keep_if {|element| ... } -> self
  #   - keep_if -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self`; removes the
  # element from `self` if the block does not return a truthy value:
  #
  #     a = [:foo, 'bar', 2, :bam]
  #     a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def keep_if: () { (Elem item) -> boolish } -> self
             | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.rb
  #   - last  -> last_object or nil
  #   - last(count) -> new_array
  # -->
  # Returns elements from `self`, or `nil`; `self` is not modified.
  #
  # With no argument given, returns the last element, or `nil` if `self` is empty:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last # => 2
  #     a # => [:foo, "bar", 2]
  #     [].last # => nil
  #
  # With non-negative integer argument `count` given, returns a new array
  # containing the trailing `count` elements of `self`, as available:
  #
  #     a = [:foo, 'bar', 2]
  #     a.last(2)  # => ["bar", 2]
  #     a.last(50) # => [:foo, "bar", 2]
  #     a.last(0)  # => []
  #     [].last(3) # => []
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def last: %a{implicitly-returns-nil} () -> Elem
          | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - length -> integer
  #   - size -> integer
  # -->
  # Returns the count of elements in `self`:
  #
  #     [0, 1, 2].length # => 3
  #     [].length        # => 0
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def length: () -> ::Integer

  # <!-- rdoc-file=array.c -->
  # With a block given, calls the block with each element of `self`; returns a new
  # array whose elements are the return values from the block:
  #
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: #collect!; see also [Methods for
  # Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  alias map collect

  # <!-- rdoc-file=array.c -->
  # With a block given, calls the block with each element of `self` and replaces
  # the element with the block's return value; returns `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: #collect; see also [Methods for
  # Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  alias map! collect!

  # <!--
  #   rdoc-file=array.c
  #   - max -> element
  #   - max(count) -> new_array
  #   - max {|a, b| ... } -> element
  #   - max(count) {|a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  #
  # *   The maximum-valued element from `self`.
  # *   A new array of maximum-valued elements from `self`.
  #
  # Does not modify `self`.
  #
  # With no block given, each element in `self` must respond to method `#<=>` with
  # a numeric.
  #
  # With no argument and no block, returns the element in `self` having the
  # maximum value per method `#<=>`:
  #
  #     [1, 0, 3, 2].max # => 3
  #
  # With non-negative numeric argument `count` and no block, returns a new array
  # with at most `count` elements, in descending order, per method `#<=>`:
  #
  #     [1, 0, 3, 2].max(3)   # => [3, 2, 1]
  #     [1, 0, 3, 2].max(3.0) # => [3, 2, 1]
  #     [1, 0, 3, 2].max(9)   # => [3, 2, 1, 0]
  #     [1, 0, 3, 2].max(0)   # => []
  #
  # With a block given, the block must return a numeric.
  #
  # With a block and no argument, calls the block `self.size - 1` times to compare
  # elements; returns the element having the maximum value per the block:
  #
  #     ['0', '', '000', '00'].max {|a, b| a.size <=> b.size }
  #     # => "000"
  #
  # With non-negative numeric argument `count` and a block, returns a new array
  # with at most `count` elements, in descending order, per the block:
  #
  #     ['0', '', '000', '00'].max(2) {|a, b| a.size <=> b.size }
  #     # => ["000", "00"]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def max: %a{implicitly-returns-nil} () -> Elem
         | %a{implicitly-returns-nil} () { (Elem a, Elem b) -> ::Integer? } -> Elem
         | (int n) -> ::Array[Elem]
         | (int n) { (Elem a, Elem b) -> ::Integer? } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - min -> element
  #   - min(count) -> new_array
  #   - min {|a, b| ... } -> element
  #   - min(count) {|a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  #
  # *   The minimum-valued element from `self`.
  # *   A new array of minimum-valued elements from `self`.
  #
  # Does not modify `self`.
  #
  # With no block given, each element in `self` must respond to method `#<=>` with
  # a numeric.
  #
  # With no argument and no block, returns the element in `self` having the
  # minimum value per method `#<=>`:
  #
  #     [1, 0, 3, 2].min # => 0
  #
  # With non-negative numeric argument `count` and no block, returns a new array
  # with at most `count` elements, in ascending order, per method `#<=>`:
  #
  #     [1, 0, 3, 2].min(3)   # => [0, 1, 2]
  #     [1, 0, 3, 2].min(3.0) # => [0, 1, 2]
  #     [1, 0, 3, 2].min(9)   # => [0, 1, 2, 3]
  #     [1, 0, 3, 2].min(0)   # => []
  #
  # With a block given, the block must return a numeric.
  #
  # With a block and no argument, calls the block `self.size - 1` times to compare
  # elements; returns the element having the minimum value per the block:
  #
  #     ['0', '', '000', '00'].min {|a, b| a.size <=> b.size }
  #     # => ""
  #
  # With non-negative numeric argument `count` and a block, returns a new array
  # with at most `count` elements, in ascending order, per the block:
  #
  #     ['0', '', '000', '00'].min(2) {|a, b| a.size <=> b.size }
  #     # => ["", "0"]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  alias min max

  # <!--
  #   rdoc-file=array.c
  #   - minmax -> array
  #   - minmax {|a, b| ... } -> array
  # -->
  # Returns a 2-element array containing the minimum-valued and maximum-valued
  # elements from `self`; does not modify `self`.
  #
  # With no block given, the minimum and maximum values are determined using
  # method `#<=>`:
  #
  #     [1, 0, 3, 2].minmax # => [0, 3]
  #
  # With a block given, the block must return a numeric; the block is called
  # `self.size - 1` times to compare elements; returns the elements having the
  # minimum and maximum values per the block:
  #
  #     ['0', '', '000', '00'].minmax {|a, b| a.size <=> b.size }
  #     # => ["", "000"]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem a, Elem b) -> ::Integer? } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=array.c
  #   - none? -> true or false
  #   - none?(object) -> true or false
  #   - none? {|element| ... } -> true or false
  # -->
  # Returns `true` if no element of `self` meets a given criterion, `false`
  # otherwise.
  #
  # With no block given and no argument, returns `true` if `self` has no truthy
  # elements, `false` otherwise:
  #
  #     [nil, false].none?    # => true
  #     [nil, 0, false].none? # => false
  #     [].none?              # => true
  #
  # With argument `object` given, returns `false` if for any element `element`,
  # `object === element`; `true` otherwise:
  #
  #     ['food', 'drink'].none?(/bar/) # => true
  #     ['food', 'drink'].none?(/foo/) # => false
  #     [].none?(/foo/)                # => true
  #     [0, 1, 2].none?(3)             # => true
  #     [0, 1, 2].none?(1)             # => false
  #
  # With a block given, calls the block with each element in `self`; returns
  # `true` if the block returns no truthy value, `false` otherwise:
  #
  #     [0, 1, 2].none? {|element| element > 3 } # => true
  #     [0, 1, 2].none? {|element| element > 1 } # => false
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  alias none? all?

  # <!--
  #   rdoc-file=array.c
  #   - one? -> true or false
  #   - one? {|element| ... } -> true or false
  #   - one?(object) -> true or false
  # -->
  # Returns `true` if exactly one element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has exactly one
  # truthy element, `false` otherwise:
  #
  #     [nil, 0].one? # => true
  #     [0, 0].one? # => false
  #     [nil, nil].one? # => false
  #     [].one? # => false
  #
  # With a block given, calls the block with each element in `self`; returns
  # `true` if the block a truthy value for exactly one element, `false` otherwise:
  #
  #     [0, 1, 2].one? {|element| element > 0 } # => false
  #     [0, 1, 2].one? {|element| element > 1 } # => true
  #     [0, 1, 2].one? {|element| element > 2 } # => false
  #
  # With argument `object` given, returns `true` if for exactly one element
  # `element`, `object === element`; `false` otherwise:
  #
  #     [0, 1, 2].one?(0) # => true
  #     [0, 0, 1].one?(0) # => false
  #     [1, 1, 2].one?(0) # => false
  #     ['food', 'drink'].one?(/bar/) # => false
  #     ['food', 'drink'].one?(/foo/) # => true
  #     [].one?(/foo/) # => false
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  alias one? none?

  # <!--
  #   rdoc-file=pack.rb
  #   - pack(template, buffer: nil) -> string
  # -->
  # Formats each element in `self` into a binary string; returns that string. See
  # [Packed Data](rdoc-ref:packed_data.rdoc).
  #
  def pack: (string fmt, ?buffer: String?) -> String

  # <!--
  #   rdoc-file=array.c
  #   - permutation(count = self.size) {|permutation| ... } -> self
  #   - permutation(count = self.size) -> new_enumerator
  # -->
  # Iterates over permutations of the elements of `self`; the order of
  # permutations is indeterminate.
  #
  # With a block and an in-range positive integer argument `count` (`0 < count <=
  # self.size`) given, calls the block with each permutation of `self` of size
  # `count`; returns `self`:
  #
  #     a = [0, 1, 2]
  #     perms = []
  #     a.permutation(1) {|perm| perms.push(perm) }
  #     perms # => [[0], [1], [2]]
  #
  #     perms = []
  #     a.permutation(2) {|perm| perms.push(perm) }
  #     perms # => [[0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]]
  #
  #     perms = []
  #     a.permutation(3) {|perm| perms.push(perm) }
  #     perms # => [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]
  #
  # When `count` is zero, calls the block once with a new empty array:
  #
  #     perms = []
  #     a.permutation(0) {|perm| perms.push(perm) }
  #     perms # => [[]]
  #
  # When `count` is out of range (negative or larger than `self.size`), does not
  # call the block:
  #
  #     a.permutation(-1) {|permutation| fail 'Cannot happen' }
  #     a.permutation(4) {|permutation| fail 'Cannot happen' }
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: [Methods for Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def permutation: (?int n) -> ::Enumerator[::Array[Elem], ::Array[Elem]]
                 | (?int n) { (::Array[Elem] p) -> void } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - pop -> object or nil
  #   - pop(count) -> new_array
  # -->
  # Removes and returns trailing elements of `self`.
  #
  # With no argument given, removes and returns the last element, if available;
  # otherwise returns `nil`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.pop  # => 2
  #     a      # => [:foo, "bar"]
  #     [].pop # => nil
  #
  # With non-negative integer argument `count` given, returns a new array
  # containing the trailing `count` elements of `self`, as available:
  #
  #     a = [:foo, 'bar', 2]
  #     a.pop(2) # => ["bar", 2]
  #     a        # => [:foo]
  #
  #     a = [:foo, 'bar', 2]
  #     a.pop(50) # => [:foo, "bar", 2]
  #     a         # => []
  #
  # Related: Array#push; see also [Methods for
  # Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def pop: () -> Elem?
         | (int n) -> ::Array[Elem]

  # <!-- rdoc-file=array.c -->
  # Prepends the given `objects` to `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Related: Array#shift; see also [Methods for
  # Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  alias prepend unshift

  # <!--
  #   rdoc-file=array.c
  #   - product(*other_arrays) -> new_array
  #   - product(*other_arrays) {|combination| ... } -> self
  # -->
  # Computes all combinations of elements from all the arrays, including both
  # `self` and `other_arrays`:
  #
  # *   The number of combinations is the product of the sizes of all the arrays,
  #     including both `self` and `other_arrays`.
  # *   The order of the returned combinations is indeterminate.
  #
  # With no block given, returns the combinations as an array of arrays:
  #
  #     p = [0, 1].product([2, 3])
  #     # => [[0, 2], [0, 3], [1, 2], [1, 3]]
  #     p.size # => 4
  #     p = [0, 1].product([2, 3], [4, 5])
  #     # => [[0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3,...
  #     p.size # => 8
  #
  # If `self` or any argument is empty, returns an empty array:
  #
  #     [].product([2, 3], [4, 5]) # => []
  #     [0, 1].product([2, 3], []) # => []
  #
  # If no argument is given, returns an array of 1-element arrays, each containing
  # an element of `self`:
  #
  #     a.product # => [[0], [1], [2]]
  #
  # With a block given, calls the block with each combination; returns `self`:
  #
  #     p = []
  #     [0, 1].product([2, 3]) {|combination| p.push(combination) }
  #     p # => [[0, 2], [0, 3], [1, 2], [1, 3]]
  #
  # If `self` or any argument is empty, does not call the block:
  #
  #     [].product([2, 3], [4, 5]) {|combination| fail 'Cannot happen' }
  #     # => []
  #     [0, 1].product([2, 3], []) {|combination| fail 'Cannot happen' }
  #     # => [0, 1]
  #
  # If no argument is given, calls the block with each element of `self` as a
  # 1-element array:
  #
  #     p = []
  #     [0, 1].product {|combination| p.push(combination) }
  #     p # => [[0], [1]]
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def product: () -> ::Array[[ Elem ]]
             | [X] (::Array[X] other_ary) -> ::Array[[ Elem, X ]]
             | [X, Y] (::Array[X] other_ary1, ::Array[Y] other_ary2) -> ::Array[[ Elem, X, Y ]]
             | [U] (*::Array[U] other_arys) -> ::Array[::Array[Elem | U]]

  # <!--
  #   rdoc-file=array.c
  #   - push(*objects) -> self
  #   - append(*objects) -> self
  # -->
  # Appends each argument in `objects` to `self`; returns `self`:
  #
  #     a = [:foo, 'bar', 2] # => [:foo, "bar", 2]
  #     a.push(:baz, :bat)   # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as a single element, even if it is another array:
  #
  #     a = [:foo, 'bar', 2]               # => [:foo, "bar", 2]
  #     a.push([:baz, :bat], [:bam, :bad]) # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def push: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - rassoc(object) -> found_array or nil
  # -->
  # Returns the first element `ele` in `self` such that `ele` is an array and
  # `ele[1] == object`:
  #
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.rassoc(4) # => [2, 4]
  #     a.rassoc(5) # => [4, 5, 6]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: Array#assoc; see also [Methods for
  # Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  alias rassoc assoc

  # <!--
  #   rdoc-file=array.c
  #   - reject {|element| ... } -> new_array
  #   - reject -> new_enumerator
  # -->
  # With a block given, returns a new array whose elements are all those from
  # `self` for which the block returns `false` or `nil`:
  #
  #     a = [:foo, 'bar', 2, 'bat']
  #     a1 = a.reject {|element| element.to_s.start_with?('b') }
  #     a1 # => [:foo, 2]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  alias reject delete_if

  # <!--
  #   rdoc-file=array.c
  #   - reject! {|element| ... } -> self or nil
  #   - reject! -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self`; removes each
  # element for which the block returns a truthy value.
  #
  # Returns `self` if any elements removed:
  #
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.reject! {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def reject!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - repeated_combination(size) {|combination| ... } -> self
  #   - repeated_combination(size) -> new_enumerator
  # -->
  # With a block given, calls the block with each repeated combination of length
  # `size` of the elements of `self`; each combination is an array; returns
  # `self`. The order of the combinations is indeterminate.
  #
  # If a positive integer argument `size` is given, calls the block with each
  # `size`-tuple repeated combination of the elements of `self`. The number of
  # combinations is `(size+1)(size+2)/2`.
  #
  # Examples:
  #
  # *   `size` is 1:
  #
  #         c = []
  #         [0, 1, 2].repeated_combination(1) {|combination| c.push(combination) }
  #         c # => [[0], [1], [2]]
  #
  # *   `size` is 2:
  #
  #         c = []
  #         [0, 1, 2].repeated_combination(2) {|combination| c.push(combination) }
  #         c # => [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]
  #
  # If `size` is zero, calls the block once with an empty array.
  #
  # If `size` is negative, does not call the block:
  #
  #     [0, 1, 2].repeated_combination(-1) {|combination| fail 'Cannot happen' }
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def repeated_combination: (int n) { (::Array[Elem] c) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - repeated_permutation(size) {|permutation| ... } -> self
  #   - repeated_permutation(size) -> new_enumerator
  # -->
  # With a block given, calls the block with each repeated permutation of length
  # `size` of the elements of `self`; each permutation is an array; returns
  # `self`. The order of the permutations is indeterminate.
  #
  # If a positive integer argument `size` is given, calls the block with each
  # `size`-tuple repeated permutation of the elements of `self`. The number of
  # permutations is `self.size**size`.
  #
  # Examples:
  #
  # *   `size` is 1:
  #
  #         p = []
  #         [0, 1, 2].repeated_permutation(1) {|permutation| p.push(permutation) }
  #         p # => [[0], [1], [2]]
  #
  # *   `size` is 2:
  #
  #         p = []
  #         [0, 1, 2].repeated_permutation(2) {|permutation| p.push(permutation) }
  #         p # => [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
  #
  # If `size` is zero, calls the block once with an empty array.
  #
  # If `size` is negative, does not call the block:
  #
  #     [0, 1, 2].repeated_permutation(-1) {|permutation| fail 'Cannot happen' }
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def repeated_permutation: (int n) { (::Array[Elem] p) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!-- rdoc-file=array.c -->
  # Replaces the elements of `self` with the elements of `other_array`, which must
  # be an [array-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Array-Convertible+Objects); returns
  # `self`:
  #
  #     a = ['a', 'b', 'c']   # => ["a", "b", "c"]
  #     a.replace(['d', 'e']) # => ["d", "e"]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def replace: (::Array[Elem]) -> self

  # <!--
  #   rdoc-file=array.c
  #   - reverse -> new_array
  # -->
  # Returns a new array containing the elements of `self` in reverse order:
  #
  #     [0, 1, 2].reverse # => [2, 1, 0]
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def reverse: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - reverse! -> self
  # -->
  # Reverses the order of the elements of `self`; returns `self`:
  #
  #     a = [0, 1, 2]
  #     a.reverse! # => [2, 1, 0]
  #     a          # => [2, 1, 0]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def reverse!: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - reverse_each {|element| ... } -> self
  #   - reverse_each -> Enumerator
  # -->
  # When a block given, iterates backwards over the elements of `self`, passing,
  # in reverse order, each element to the block; returns `self`:
  #
  #     a = []
  #     [0, 1, 2].reverse_each {|element| a.push(element) }
  #     a # => [2, 1, 0]
  #
  # Allows the array to be modified during iteration:
  #
  #     a = ['a', 'b', 'c']
  #     a.reverse_each {|element| a.clear if element.start_with?('b') }
  #     a # => []
  #
  # When no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Iterating](rdoc-ref:Array@Methods+for+Iterating).
  #
  def reverse_each: () { (Elem item) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - rindex(object) -> integer or nil
  #   - rindex {|element| ... } -> integer or nil
  #   - rindex -> new_enumerator
  # -->
  # Returns the index of the last element for which `object == element`.
  #
  # With argument `object` given, returns the index of the last such element
  # found:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex('bar') # => 3
  #
  # Returns `nil` if no such object found.
  #
  # With a block given, calls the block with each successive element; returns the
  # index of the last element for which the block returns a truthy value:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex {|element| element == 'bar' } # => 3
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator.
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  def rindex: (untyped obj) -> ::Integer?
            | () { (Elem item) -> boolish } -> ::Integer?
            | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.c
  #   - rotate(count = 1) -> new_array
  # -->
  # Returns a new array formed from `self` with elements rotated from one end to
  # the other.
  #
  # With non-negative numeric `count`, rotates elements from the beginning to the
  # end:
  #
  #     [0, 1, 2, 3].rotate(2)   # => [2, 3, 0, 1]
  #     [0, 1, 2, 3].rotate(2.1) # => [2, 3, 0, 1]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #
  #     [0, 1, 2, 3].rotate(22) # => [2, 3, 0, 1]
  #
  # With a `count` of zero, rotates no elements:
  #
  #     [0, 1, 2, 3].rotate(0) # => [0, 1, 2, 3]
  #
  # With negative numeric `count`, rotates in the opposite direction, from the end
  # to the beginning:
  #
  #     [0, 1, 2, 3].rotate(-1) # => [3, 0, 1, 2]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #
  #     [0, 1, 2, 3].rotate(-21) # => [3, 0, 1, 2]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def rotate: (?int count) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - rotate!(count = 1) -> self
  # -->
  # Rotates `self` in place by moving elements from one end to the other; returns
  # `self`.
  #
  # With non-negative numeric `count`, rotates `count` elements from the beginning
  # to the end:
  #
  #     [0, 1, 2, 3].rotate!(2)   # => [2, 3, 0, 1]
  #     [0, 1, 2, 3].rotate!(2.1) # => [2, 3, 0, 1]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #
  #     [0, 1, 2, 3].rotate!(21) # => [1, 2, 3, 0]
  #
  # If `count` is zero, rotates no elements:
  #
  #     [0, 1, 2, 3].rotate!(0) # => [0, 1, 2, 3]
  #
  # With a negative numeric `count`, rotates in the opposite direction, from end
  # to beginning:
  #
  #     [0, 1, 2, 3].rotate!(-1) # => [3, 0, 1, 2]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #
  #     [0, 1, 2, 3].rotate!(-21) # => [3, 0, 1, 2]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def rotate!: (?int count) -> self

  # <!--
  #   rdoc-file=array.rb
  #   - sample(random: Random) -> object
  #   - sample(count, random: Random) -> new_ary
  # -->
  # Returns random elements from `self`, as selected by the object given by the
  # keyword argument `random`.
  #
  # With no argument `count` given, returns one random element from `self`:
  #
  #     a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     a.sample # => 3
  #     a.sample # => 8
  #
  # Returns `nil` if `self` is empty:
  #
  #     [].sample # => nil
  #
  # With a non-negative numeric argument `count` given, returns a new array
  # containing `count` random elements from `self`:
  #
  #     a.sample(3) # => [8, 9, 2]
  #     a.sample(6) # => [9, 6, 0, 3, 1, 4]
  #
  # The order of the result array is unrelated to the order of `self`.
  #
  # Returns a new empty `Array` if `self` is empty:
  #
  #     [].sample(4) # => []
  #
  # May return duplicates in `self`:
  #
  #     a = [1, 1, 1, 2, 2, 3]
  #     a.sample(a.size) # => [1, 1, 3, 2, 1, 2]
  #
  # Returns no more than `a.size` elements (because no new duplicates are
  # introduced):
  #
  #     a.sample(50) # => [6, 4, 1, 8, 5, 9, 0, 2, 3, 7]
  #
  # The object given with the keyword argument `random` is used as the random
  # number generator:
  #
  #     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a.sample(random: Random.new(1))     # => 6
  #     a.sample(4, random: Random.new(1))  # => [6, 10, 9, 2]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def sample: %a{implicitly-returns-nil} (?random: _Rand rng) -> Elem
            | (int n, ?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - select {|element| ... } -> new_array
  #   - select -> new_enumerator
  #   - filter {|element| ... } -> new_array
  #   - filter -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self`; returns a new
  # array containing those elements of `self` for which the block returns a truthy
  # value:
  #
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select {|element| element.to_s.start_with?('b') }
  #     # => ["bar", :bam]
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def select: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - select! {|element| ... } -> self or nil
  #   - select! -> new_enumerator
  #   - filter! {|element| ... } -> self or nil
  #   - filter! -> new_enumerator
  # -->
  # With a block given, calls the block with each element of `self`; removes from
  # `self` those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def select!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - shift -> object or nil
  #   - shift(count) -> new_array or nil
  # -->
  # Removes and returns leading elements from `self`.
  #
  # With no argument, removes and returns one element, if available, or `nil`
  # otherwise:
  #
  #     a = [0, 1, 2, 3]
  #     a.shift  # => 0
  #     a        # => [1, 2, 3]
  #     [].shift # => nil
  #
  # With non-negative numeric argument `count` given, removes and returns the
  # first `count` elements:
  #
  #     a = [0, 1, 2, 3]
  #     a.shift(2)   # => [0, 1]
  #     a            # => [2, 3]
  #     a.shift(1.1) # => [2]
  #     a            # => [3]
  #     a.shift(0)   # => []
  #     a            # => [3]
  #
  # If `count` is large, removes and returns all elements:
  #
  #     a = [0, 1, 2, 3]
  #     a.shift(50) # => [0, 1, 2, 3]
  #     a           # => []
  #
  # If `self` is empty, returns a new empty array.
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def shift: %a{implicitly-returns-nil} () -> Elem
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - shuffle(random: Random) -> new_array
  # -->
  # Returns a new array containing all elements from `self` in a random order, as
  # selected by the object given by the keyword argument `random`:
  #
  #     a =            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     a.shuffle # => [0, 8, 1, 9, 6, 3, 4, 7, 2, 5]
  #     a.shuffle # => [8, 9, 0, 5, 1, 2, 6, 4, 7, 3]
  #
  # Duplicate elements are included:
  #
  #     a =            [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  #     a.shuffle # => [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]
  #     a.shuffle # => [1, 1, 0, 0, 0, 1, 1, 0, 0, 1]
  #
  # The object given with the keyword argument `random` is used as the random
  # number generator.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def shuffle: (?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - shuffle!(random: Random) -> self
  # -->
  # Shuffles all elements in `self` into a random order, as selected by the object
  # given by the keyword argument `random`. Returns `self`:
  #
  #     a =             [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     a.shuffle! # => [5, 3, 8, 7, 6, 1, 9, 4, 2, 0]
  #     a.shuffle! # => [9, 4, 0, 6, 2, 8, 1, 5, 3, 7]
  #
  # Duplicate elements are included:
  #
  #     a =             [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  #     a.shuffle! # => [1, 0, 0, 1, 1, 0, 1, 0, 0, 1]
  #     a.shuffle! # => [0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  #
  # The object given with the keyword argument `random` is used as the random
  # number generator.
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def shuffle!: (?random: _Rand rng) -> self

  # <!-- rdoc-file=array.c -->
  # Returns the count of elements in `self`:
  #
  #     [0, 1, 2].length # => 3
  #     [].length        # => 0
  #
  # Related: see [Methods for Querying](rdoc-ref:Array@Methods+for+Querying).
  #
  alias size length

  # <!-- rdoc-file=array.c -->
  # Returns elements from `self`; does not modify `self`.
  #
  # In brief:
  #
  #     a = [:foo, 'bar', 2]
  #
  #     # Single argument index: returns one element.
  #     a[0]     # => :foo          # Zero-based index.
  #     a[-1]    # => 2             # Negative index counts backwards from end.
  #
  #     # Arguments start and length: returns an array.
  #     a[1, 2]  # => ["bar", 2]
  #     a[-2, 2] # => ["bar", 2]    # Negative start counts backwards from end.
  #
  #     # Single argument range: returns an array.
  #     a[0..1]  # => [:foo, "bar"]
  #     a[0..-2] # => [:foo, "bar"] # Negative range-begin counts backwards from end.
  #     a[-2..2] # => ["bar", 2]    # Negative range-end counts backwards from end.
  #
  # When a single integer argument `index` is given, returns the element at offset
  # `index`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts backwards from the end of `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new
  # `Array` of size `length` containing successive elements beginning at offset
  # `start`:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty `Array`.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty `Array`.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an `Array` of elements corresponding to the indexes produced by the sequence.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def slice: %a{implicitly-returns-nil} (int index) -> Elem
           | (int start, int length) -> ::Array[Elem]?
           | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - slice!(index) -> object or nil
  #   - slice!(start, length) -> new_array or nil
  #   - slice!(range) -> new_array or nil
  # -->
  # Removes and returns elements from `self`.
  #
  # With numeric argument `index` given, removes and returns the element at offset
  # `index`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(2)   # => "c"
  #     a             # => ["a", "b", "d"]
  #     a.slice!(2.1) # => "d"
  #     a             # => ["a", "b"]
  #
  # If `index` is negative, counts backwards from the end of `self`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(-2) # => "c"
  #     a            # => ["a", "b", "d"]
  #
  # If `index` is out of range, returns `nil`.
  #
  # With numeric arguments `start` and `length` given, removes `length` elements
  # from `self` beginning at zero-based offset `start`; returns the removed
  # objects in a new array:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(1, 2)     # => ["b", "c"]
  #     a                  # => ["a", "d"]
  #     a.slice!(0.1, 1.1) # => ["a"]
  #     a                  # => ["d"]
  #
  # If `start` is negative, counts backwards from the end of `self`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(-2, 1) # => ["c"]
  #     a               # => ["a", "b", "d"]
  #
  # If `start` is out-of-range, returns `nil`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(5, 1)  # => nil
  #     a.slice!(-5, 1) # => nil
  #
  # If `start + length` exceeds the array size, removes and returns all elements
  # from offset `start` to the end:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(2, 50) # => ["c", "d"]
  #     a               # => ["a", "b"]
  #
  # If `start == a.size` and `length` is non-negative, returns a new empty array.
  #
  # If `length` is negative, returns `nil`.
  #
  # With Range argument `range` given, treats `range.min` as `start` (as above)
  # and `range.size` as `length` (as above):
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(1..2) # => ["b", "c"]
  #     a              # => ["a", "d"]
  #
  # If `range.start == a.size`, returns a new empty array:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(4..5) # => []
  #
  # If `range.start` is larger than the array size, returns `nil`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(5..6) # => nil
  #
  # If `range.start` is negative, calculates the start index by counting backwards
  # from the end of `self`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(-2..2) # => ["c"]
  #
  # If `range.end` is negative, calculates the end index by counting backwards
  # from the end of `self`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.slice!(0..-2) # => ["a", "b", "c"]
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def slice!: %a{implicitly-returns-nil} (int index) -> Elem
            | (int start, int length) -> ::Array[Elem]?
            | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - sort -> new_array
  #   - sort {|a, b| ... } -> new_array
  # -->
  # Returns a new array containing the elements of `self`, sorted.
  #
  # With no block given, compares elements using operator `#<=>` (see Object#<=>):
  #
  #     [0, 2, 3, 1].sort # => [0, 1, 2, 3]
  #
  # With a block given, calls the block with each combination of pairs of elements
  # from `self`; for each pair `a` and `b`, the block should return a numeric:
  #
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  # Example:
  #
  #     a = [3, 2, 0, 1]
  #     a.sort {|a, b| a <=> b } # => [0, 1, 2, 3]
  #     a.sort {|a, b| b <=> a } # => [3, 2, 1, 0]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem a, Elem b) -> ::Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - sort! -> self
  #   - sort! {|a, b| ... } -> self
  # -->
  # Like Array#sort, but returns `self` with its elements sorted in place.
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def sort!: () -> self
           | () { (Elem a, Elem b) -> ::Integer } -> self

  # <!--
  #   rdoc-file=array.c
  #   - sort_by! {|element| ... } -> self
  #   - sort_by! -> new_enumerator
  # -->
  # With a block given, sorts the elements of `self` in place; returns self.
  #
  # Calls the block with each successive element; sorts elements based on the
  # values returned from the block:
  #
  #     a = ['aaaa', 'bbb', 'cc', 'd']
  #     a.sort_by! {|element| element.size }
  #     a # => ["d", "cc", "bbb", "aaaa"]
  #
  # For duplicate values returned by the block, the ordering is indeterminate, and
  # may be unstable.
  #
  # With no block given, returns a new Enumerator.
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def sort_by!: [U] () { (Elem obj) -> U } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - sum(init = 0) -> object
  #   - sum(init = 0) {|element| ... } -> object
  # -->
  # With no block given, returns the sum of `init` and all elements of `self`; for
  # array `array` and value `init`, equivalent to:
  #
  #     sum = init
  #     array.each {|element| sum += element }
  #     sum
  #
  # For example, `[e0, e1, e2].sum` returns `init + e0 + e1 + e2`.
  #
  # Examples:
  #
  #     [0, 1, 2, 3].sum                 # => 6
  #     [0, 1, 2, 3].sum(100)            # => 106
  #     ['abc', 'def', 'ghi'].sum('jkl') # => "jklabcdefghi"
  #     [[:foo, :bar], ['foo', 'bar']].sum([2, 3])
  #     # => [2, 3, :foo, :bar, "foo", "bar"]
  #
  # The `init` value and elements need not be numeric, but must all be
  # `+`-compatible:
  #
  #     # Raises TypeError: Array can't be coerced into Integer.
  #     [[:foo, :bar], ['foo', 'bar']].sum(2)
  #
  # With a block given, calls the block with each element of `self`; the block's
  # return value (instead of the element itself) is used as the addend:
  #
  #     ['zero', 1, :two].sum('Coerced and concatenated: ') {|element| element.to_s }
  #     # => "Coerced and concatenated: zero1two"
  #
  # Notes:
  #
  # *   Array#join and Array#flatten may be faster than Array#sum for an array of
  #     strings or an array of arrays.
  # *   Array#sum method may not respect method redefinition of "+" methods such
  #     as Integer#+.
  #
  def sum: (?untyped init) -> untyped
         | (?untyped init) { (Elem e) -> untyped } -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - take(count) -> new_array
  # -->
  # Returns a new array containing the first `count` element of `self` (as
  # available); `count` must be a non-negative numeric; does not modify `self`:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.take(2)   # => ["a", "b"]
  #     a.take(2.1) # => ["a", "b"]
  #     a.take(50)  # => ["a", "b", "c", "d"]
  #     a.take(0)   # => []
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def take: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - take_while {|element| ... } -> new_array
  #   - take_while -> new_enumerator
  # -->
  # With a block given, calls the block with each successive element of `self`;
  # stops iterating if the block returns `false` or `nil`; returns a new array
  # containing those elements for which the block returned a truthy value:
  #
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.take_while {|element| element < 3 } # => [0, 1, 2]
  #     a.take_while {|element| true }        # => [0, 1, 2, 3, 4, 5]
  #     a.take_while {|element| false }       # => []
  #
  # With no block given, returns a new Enumerator.
  #
  # Does not modify `self`.
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def take_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - to_a -> self or new_array
  # -->
  # When `self` is an instance of `Array`, returns `self`.
  #
  # Otherwise, returns a new array containing the elements of `self`:
  #
  #     class MyArray < Array; end
  #     my_a = MyArray.new(['foo', 'bar', 'two'])
  #     a = my_a.to_a
  #     a # => ["foo", "bar", "two"]
  #     a.class # => Array # Not MyArray.
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.to_ary -> self
  # -->
  # Returns `self`.
  #
  def to_ary: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - to_h -> new_hash
  #   - to_h {|element| ... } -> new_hash
  # -->
  # Returns a new hash formed from `self`.
  #
  # With no block given, each element of `self` must be a 2-element sub-array;
  # forms each sub-array into a key-value pair in the new hash:
  #
  #     a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
  #     a.to_h # => {"foo"=>"zero", "bar"=>"one", "baz"=>"two"}
  #     [].to_h # => {}
  #
  # With a block given, the block must return a 2-element array; calls the block
  # with each element of `self`; forms each returned array into a key-value pair
  # in the returned hash:
  #
  #     a = ['foo', :bar, 1, [2, 3], {baz: 4}]
  #     a.to_h {|element| [element, element.class] }
  #     # => {"foo"=>String, :bar=>Symbol, 1=>Integer, [2, 3]=>Array, {:baz=>4}=>Hash}
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def to_h: () -> Hash[untyped, untyped]
          | [T, S] () { (Elem) -> [ T, S ] } -> Hash[T, S]

  # <!-- rdoc-file=array.c -->
  # Returns the new string formed by calling method `#inspect` on each array
  # element:
  #
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=array.c
  #   - transpose -> new_array
  # -->
  # Returns a new array that is `self` as a [transposed
  # matrix](https://en.wikipedia.org/wiki/Transpose):
  #
  #     a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
  #     a.transpose # => [[:a0, :b0, :c0], [:a1, :b1, :c1]]
  #
  # The elements of `self` must all be the same size.
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def transpose: () -> ::Array[::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - union(*other_arrays) -> new_array
  # -->
  # Returns a new array that is the union of the elements of `self` and all given
  # arrays `other_arrays`; items are compared using `eql?`:
  #
  #     [0, 1, 2, 3].union([4, 5], [6, 7]) # => [0, 1, 2, 3, 4, 5, 6, 7]
  #
  # Removes duplicates (preserving the first found):
  #
  #     [0, 1, 1].union([2, 1], [3, 1]) # => [0, 1, 2, 3]
  #
  # Preserves order (preserving the position of the first found):
  #
  #     [3, 2, 1, 0].union([5, 3], [4, 2]) # => [3, 2, 1, 0, 5, 4]
  #
  # With no arguments given, returns a copy of `self`.
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def union: [T] (*::Array[T] other_arys) -> ::Array[T | Elem]

  # <!--
  #   rdoc-file=array.c
  #   - uniq -> new_array
  #   - uniq {|element| ... } -> new_array
  # -->
  # Returns a new array containing those elements from `self` that are not
  # duplicates, the first occurrence always being retained.
  #
  # With no block given, identifies and omits duplicate elements using method
  # `eql?` to compare elements:
  #
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq # => [0, 1, 2]
  #
  # With a block given, calls the block for each element; identifies and omits
  # "duplicate" elements using method `eql?` to compare *block return values*;
  # that is, an element is a duplicate if its block return value is the same as
  # that of a previous element:
  #
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq {|element| element.size } # => ["a", "aa", "aaa"]
  #
  # Related: [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - uniq! -> self or nil
  #   - uniq! {|element| ... } -> self or nil
  # -->
  # Removes duplicate elements from `self`, the first occurrence always being
  # retained; returns `self` if any elements removed, `nil` otherwise.
  #
  # With no block given, identifies and removes elements using method `eql?` to
  # compare elements:
  #
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq! # => [0, 1, 2]
  #     a.uniq! # => nil
  #
  # With a block given, calls the block for each element; identifies and omits
  # "duplicate" elements using method `eql?` to compare *block return values*;
  # that is, an element is a duplicate if its block return value is the same as
  # that of a previous element:
  #
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq! {|element| element.size } # => ["a", "aa", "aaa"]
  #     a.uniq! {|element| element.size } # => nil
  #
  # Related: see [Methods for Deleting](rdoc-ref:Array@Methods+for+Deleting).
  #
  def uniq!: () -> self?
           | () { (Elem) -> untyped } -> self?

  # <!--
  #   rdoc-file=array.c
  #   - unshift(*objects) -> self
  #   - prepend(*objects) -> self
  # -->
  # Prepends the given `objects` to `self`:
  #
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Related: Array#shift; see also [Methods for
  # Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def unshift: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - values_at(*specifiers) -> new_array
  # -->
  # Returns elements from `self` in a new array; does not modify `self`.
  #
  # The objects included in the returned array are the elements of `self` selected
  # by the given `specifiers`, each of which must be a numeric index or a Range.
  #
  # In brief:
  #
  #     a = ['a', 'b', 'c', 'd']
  #
  #     # Index specifiers.
  #     a.values_at(2, 0, 2, 0)     # => ["c", "a", "c", "a"] # May repeat.
  #     a.values_at(-4, -3, -2, -1) # => ["a", "b", "c", "d"] # Counts backwards if negative.
  #     a.values_at(-50, 50)        # => [nil, nil]           # Outside of self.
  #
  #     # Range specifiers.
  #     a.values_at(1..3)       # => ["b", "c", "d"] # From range.begin to range.end.
  #     a.values_at(1...3)      # => ["b", "c"]      # End excluded.
  #     a.values_at(3..1)       # => []              # No such elements.
  #
  #     a.values_at(-3..3)  # => ["b", "c", "d"]     # Negative range.begin counts backwards.
  #     a.values_at(-50..3)                          # Raises RangeError.
  #
  #     a.values_at(1..-2)  # => ["b", "c"]          # Negative range.end counts backwards.
  #     a.values_at(1..-50) # => []                  # No such elements.
  #
  #     # Mixture of specifiers.
  #     a.values_at(2..3, 3, 0..1, 0) # => ["c", "d", "d", "a", "b", "a"]
  #
  # With no `specifiers` given, returns a new empty array:
  #
  #     a = ['a', 'b', 'c', 'd']
  #     a.values_at # => []
  #
  # For each numeric specifier `index`, includes an element:
  #
  # *   For each non-negative numeric specifier `index` that is in-range (less
  #     than `self.size`), includes the element at offset `index`:
  #
  #         a.values_at(0, 2)     # => ["a", "c"]
  #         a.values_at(0.1, 2.9) # => ["a", "c"]
  #
  # *   For each negative numeric `index` that is in-range (greater than or equal
  #     to `- self.size`), counts backwards from the end of `self`:
  #
  #         a.values_at(-1, -4) # => ["d", "a"]
  #
  # The given indexes may be in any order, and may repeat:
  #
  #     a.values_at(2, 0, 1, 0, 2) # => ["c", "a", "b", "a", "c"]
  #
  # For each `index` that is out-of-range, includes `nil`:
  #
  #     a.values_at(4, -5) # => [nil, nil]
  #
  # For each Range specifier `range`, includes elements according to `range.begin`
  # and `range.end`:
  #
  # *   If both `range.begin` and `range.end` are non-negative and in-range (less
  #     than `self.size`), includes elements from index `range.begin` through
  #     `range.end - 1` (if `range.exclude_end?`), or through `range.end`
  #     (otherwise):
  #
  #         a.values_at(1..2)  # => ["b", "c"]
  #         a.values_at(1...2) # => ["b"]
  #
  # *   If `range.begin` is negative and in-range (greater than or equal to `-
  #     self.size`), counts backwards from the end of `self`:
  #
  #         a.values_at(-2..3) # => ["c", "d"]
  #
  # *   If `range.begin` is negative and out-of-range, raises an exception:
  #
  #         a.values_at(-5..3) # Raises RangeError.
  #
  # *   If `range.end` is positive and out-of-range, extends the returned array
  #     with `nil` elements:
  #
  #         a.values_at(1..5) # => ["b", "c", "d", nil, nil]
  #
  # *   If `range.end` is negative and in-range, counts backwards from the end of
  #     `self`:
  #
  #         a.values_at(1..-2) # => ["b", "c"]
  #
  # *   If `range.end` is negative and out-of-range, returns an empty array:
  #
  #         a.values_at(1..-5) # => []
  #
  # The given ranges may be in any order and may repeat:
  #
  #     a.values_at(2..3, 0..1, 2..3) # => ["c", "d", "a", "b", "c", "d"]
  #
  # The given specifiers may be any mixture of indexes and ranges:
  #
  #     a.values_at(3, 1..2, 0, 2..3) # => ["d", "b", "c", "a", "c", "d"]
  #
  # Related: see [Methods for Fetching](rdoc-ref:Array@Methods+for+Fetching).
  #
  def values_at: (*int | ::Range[::Integer] selector) -> ::Array[Elem?]

  # <!--
  #   rdoc-file=array.c
  #   - zip(*other_arrays) -> new_array
  #   - zip(*other_arrays) {|sub_array| ... } -> nil
  # -->
  # With no block given, combines `self` with the collection of `other_arrays`;
  # returns a new array of sub-arrays:
  #
  #     [0, 1].zip(['zero', 'one'], [:zero, :one])
  #     # => [[0, "zero", :zero], [1, "one", :one]]
  #
  # Returned:
  #
  # *   The outer array is of size `self.size`.
  # *   Each sub-array is of size `other_arrays.size + 1`.
  # *   The *nth* sub-array contains (in order):
  #
  #     *   The *nth* element of `self`.
  #     *   The *nth* element of each of the other arrays, as available.
  #
  # Example:
  #
  #     a = [0, 1]
  #     zipped = a.zip(['zero', 'one'], [:zero, :one])
  #     # => [[0, "zero", :zero], [1, "one", :one]]
  #     zipped.size       # => 2 # Same size as a.
  #     zipped.first.size # => 3 # Size of other arrays plus 1.
  #
  # When the other arrays are all the same size as `self`, the returned sub-arrays
  # are a rearrangement containing exactly elements of all the arrays (including
  # `self`), with no omissions or additions:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     pp d
  #     # =>
  #     [[:a0, :b0, :c0],
  #      [:a1, :b1, :c1],
  #      [:a2, :b2, :c2],
  #      [:a3, :b3, :c3]]
  #
  # When one of the other arrays is smaller than `self`, pads the corresponding
  # sub-array with `nil` elements:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     pp d
  #     # =>
  #     [[:a0, :b0, :c0],
  #      [:a1, :b1, :c1],
  #      [:a2, :b2, nil],
  #      [:a3, nil, nil]]
  #
  # When one of the other arrays is larger than `self`, *ignores* its trailing
  # elements:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     pp d
  #     # =>
  #     [[:a0, :b0, :c0],
  #      [:a1, :b1, :c1],
  #      [:a2, :b2, :c2],
  #      [:a3, :b3, :c3]]
  #
  # With a block given, calls the block with each of the other arrays; returns
  # `nil`:
  #
  #     d = []
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| d.push(sub_array.reverse) } # => nil
  #     pp d
  #     # =>
  #     [[:c0, :b0, :a0],
  #      [:c1, :b1, :a1],
  #      [:c2, :b2, :a2],
  #      [:c3, :b3, :a3]]
  #
  # For an **object** in **other_arrays** that is not actually an array, forms the
  # the "other array" as `object.to_ary`, if defined, or as `object.each.to_a`
  # otherwise.
  #
  # Related: see [Methods for Converting](rdoc-ref:Array@Methods+for+Converting).
  #
  def zip: [U] (_Each[U] arg) -> Array[[ Elem, U? ]]
         | (_Each[untyped] arg, *_Each[untyped] args) -> Array[Array[untyped]]
         | [U] (_Each[U] arg) { ([ Elem, U? ]) -> void } -> nil
         | (_Each[untyped] arg, *_Each[untyped] args) { (Array[untyped]) -> void } -> nil

  # <!--
  #   rdoc-file=array.c
  #   - self | other_array -> new_array
  # -->
  # Returns the union of `self` and `other_array`; duplicates are removed; order
  # is preserved; items are compared using `eql?`:
  #
  #     [0, 1] | [2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 1] | [2, 2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 2] | [3, 2, 1, 0] # => [0, 1, 2, 3]
  #
  # Related: see [Methods for Combining](rdoc-ref:Array@Methods+for+Combining).
  #
  def |: [T] (::Array[T] other_ary) -> ::Array[Elem | T]

  private

  # <!--
  #   rdoc-file=array.c
  #   - initialize_copy(other_array) -> self
  #   - replace(other_array) -> self
  # -->
  # Replaces the elements of `self` with the elements of `other_array`, which must
  # be an [array-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Array-Convertible+Objects); returns
  # `self`:
  #
  #     a = ['a', 'b', 'c']   # => ["a", "b", "c"]
  #     a.replace(['d', 'e']) # => ["d", "e"]
  #
  # Related: see [Methods for Assigning](rdoc-ref:Array@Methods+for+Assigning).
  #
  def initialize_copy: (self other_ary) -> void
end

interface _Rand
  def rand: (::Integer max) -> ::Integer
end

interface Array::_Pattern[T]
  def ===: (T) -> bool
end
# <!-- rdoc-file=compar.c -->
# The Comparable mixin is used by classes whose objects may be ordered. The
# class must define the `<=>` operator, which compares the receiver against
# another object, returning a value less than 0, returning 0, or returning a
# value greater than 0, depending on whether the receiver is less than, equal
# to, or greater than the other object. If the other object is not comparable
# then the `<=>` operator should return `nil`. Comparable uses `<=>` to
# implement the conventional comparison operators (`<`, `<=`, `==`, `>=`, and
# `>`) and the method `between?`.
#
#     class StringSorter
#       include Comparable
#
#       attr :str
#       def <=>(other)
#         str.size <=> other.str.size
#       end
#
#       def initialize(str)
#         @str = str
#       end
#
#       def inspect
#         @str
#       end
#     end
#
#     s1 = StringSorter.new("Z")
#     s2 = StringSorter.new("YY")
#     s3 = StringSorter.new("XXX")
#     s4 = StringSorter.new("WWWW")
#     s5 = StringSorter.new("VVVVV")
#
#     s1 < s2                       #=> true
#     s4.between?(s1, s3)           #=> false
#     s4.between?(s3, s5)           #=> true
#     [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]
#
# ## What's Here
#
# Module Comparable provides these methods, all of which use method `#<=>`:
#
# *   #<: Returns whether `self` is less than the given object.
# *   #<=: Returns whether `self` is less than or equal to the given object.
# *   #==: Returns whether `self` is equal to the given object.
# *   #>: Returns whether `self` is greater than the given object.
# *   #>=: Returns whether `self` is greater than or equal to the given object.
# *   #between?: Returns `true` if `self` is between two given objects.
# *   #clamp: For given objects `min` and `max`, or range `(min..max)`, returns:
#
#     *   `min` if `(self <=> min) < 0`.
#     *   `max` if `(self <=> max) > 0`.
#     *   `self` otherwise.
#
module Comparable : _WithSpaceshipOperator
  # <!--
  #   rdoc-file=compar.c
  #   - obj < other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than 0.
  #
  def <: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj <= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than or equal to 0.
  #
  def <=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj == other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns 0. Also returns true if *obj* and *other* are the same object.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj > other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than 0.
  #
  def >: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj >= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than or equal to 0.
  #
  def >=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.between?(min, max)    -> true or false
  # -->
  # Returns `false` if *obj* `<=>` *min* is less than zero or if *obj* `<=>` *max*
  # is greater than zero, `true` otherwise.
  #
  #     3.between?(1, 5)               #=> true
  #     6.between?(1, 5)               #=> false
  #     'cat'.between?('ant', 'dog')   #=> true
  #     'gnu'.between?('ant', 'dog')   #=> false
  #
  def between?: (untyped min, untyped max) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.clamp(min, max) ->  obj
  #   - obj.clamp(range)    ->  obj
  # -->
  # In `(min, max)` form, returns *min* if *obj* `<=>` *min* is less than zero,
  # *max* if *obj* `<=>` *max* is greater than zero, and *obj* otherwise.
  #
  #     12.clamp(0, 100)         #=> 12
  #     523.clamp(0, 100)        #=> 100
  #     -3.123.clamp(0, 100)     #=> 0
  #
  #     'd'.clamp('a', 'f')      #=> 'd'
  #     'z'.clamp('a', 'f')      #=> 'f'
  #
  # If *min* is `nil`, it is considered smaller than *obj*, and if *max* is `nil`,
  # it is considered greater than *obj*.
  #
  #     -20.clamp(0, nil)           #=> 0
  #     523.clamp(nil, 100)         #=> 100
  #
  # In `(range)` form, returns *range.begin* if *obj* `<=>` *range.begin* is less
  # than zero, *range.end* if *obj* `<=>` *range.end* is greater than zero, and
  # *obj* otherwise.
  #
  #     12.clamp(0..100)         #=> 12
  #     523.clamp(0..100)        #=> 100
  #     -3.123.clamp(0..100)     #=> 0
  #
  #     'd'.clamp('a'..'f')      #=> 'd'
  #     'z'.clamp('a'..'f')      #=> 'f'
  #
  # If *range.begin* is `nil`, it is considered smaller than *obj*, and if
  # *range.end* is `nil`, it is considered greater than *obj*.
  #
  #     -20.clamp(0..)           #=> 0
  #     523.clamp(..100)         #=> 100
  #
  # When *range.end* is excluded and not `nil`, an exception is raised.
  #
  #     100.clamp(0...100)       # ArgumentError
  #
  def clamp: [A, B] (A min, B max) -> (self | A | B)
           | [A] (Range[A]) -> (self | A)
end

# This interface defines the condition for Comparable mixin.
#
interface Comparable::_WithSpaceshipOperator
  # `<=>` operator must return Integer or `nil`.
  # If `other` is greater than `self`, it returns a positive Integer.
  # If `other` equals to `self`, it returns zero.
  # If `other` is less than `self`, it returns a positive Integer.
  # If no comparison is defined with `other` and `self`, it returns `nil`.
  #
  def <=>: (untyped other) -> Integer?
end
# <!-- rdoc-file=hash.c -->
# A `Hash` maps each of its unique keys to a specific value.
#
# A `Hash` has certain similarities to an Array, but:
# *   An Array index is always an Integer.
# *   A `Hash` key can be (almost) any object.
#
# ### `Hash` Data Syntax
#
# The older syntax for `Hash` data uses the "hash rocket," `=>`:
#
#     h = {:foo => 0, :bar => 1, :baz => 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Alternatively, but only for a `Hash` key that's a Symbol, you can use a newer
# JSON-style syntax, where each bareword becomes a Symbol:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can also use a String in place of a bareword:
#
#     h = {'foo': 0, 'bar': 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# And you can mix the styles:
#
#     h = {foo: 0, :bar => 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# But it's an error to try the JSON-style syntax for a key that's not a bareword
# or a String:
#
#     # Raises SyntaxError (syntax error, unexpected ':', expecting =>):
#     h = {0: 'zero'}
#
# `Hash` value can be omitted, meaning that value will be fetched from the
# context by the name of the key:
#
#     x = 0
#     y = 100
#     h = {x:, y:}
#     h # => {:x=>0, :y=>100}
#
# ### Common Uses
#
# You can use a `Hash` to give names to objects:
#
#     person = {name: 'Matz', language: 'Ruby'}
#     person # => {:name=>"Matz", :language=>"Ruby"}
#
# You can use a `Hash` to give names to method arguments:
#
#     def some_method(hash)
#       p hash
#     end
#     some_method({foo: 0, bar: 1, baz: 2}) # => {:foo=>0, :bar=>1, :baz=>2}
#
# Note: when the last argument in a method call is a `Hash`, the curly braces
# may be omitted:
#
#     some_method(foo: 0, bar: 1, baz: 2) # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can use a `Hash` to initialize an object:
#
#     class Dev
#       attr_accessor :name, :language
#       def initialize(hash)
#         self.name = hash[:name]
#         self.language = hash[:language]
#       end
#     end
#     matz = Dev.new(name: 'Matz', language: 'Ruby')
#     matz # => #<Dev: @name="Matz", @language="Ruby">
#
# ### Creating a `Hash`
#
# You can create a `Hash` object explicitly with:
#
# *   A [hash literal](rdoc-ref:syntax/literals.rdoc@Hash+Literals).
#
# You can convert certain objects to Hashes with:
#
# *   Method #Hash.
#
# You can create a `Hash` by calling method Hash.new.
#
# Create an empty `Hash`:
#
#     h = Hash.new
#     h # => {}
#     h.class # => Hash
#
# You can create a `Hash` by calling method Hash.[].
#
# Create an empty `Hash`:
#
#     h = Hash[]
#     h # => {}
#
# Create a `Hash` with initial entries:
#
#     h = Hash[foo: 0, bar: 1, baz: 2]
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can create a `Hash` by using its literal form (curly braces).
#
# Create an empty `Hash`:
#
#     h = {}
#     h # => {}
#
# Create a `Hash` with initial entries:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# ### `Hash` Value Basics
#
# The simplest way to retrieve a `Hash` value (instance method #[]):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:foo] # => 0
#
# The simplest way to create or update a `Hash` value (instance method #[]=):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:bat] = 3 # => 3
#     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
#     h[:foo] = 4 # => 4
#     h # => {:foo=>4, :bar=>1, :baz=>2, :bat=>3}
#
# The simplest way to delete a `Hash` entry (instance method #delete):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h.delete(:bar) # => 1
#     h # => {:foo=>0, :baz=>2}
#
# ### Entry Order
#
# A `Hash` object presents its entries in the order of their creation. This is
# seen in:
#
# *   Iterative methods such as `each`, `each_key`, `each_pair`, `each_value`.
# *   Other order-sensitive methods such as `shift`, `keys`, `values`.
# *   The String returned by method `inspect`.
#
# A new `Hash` has its initial ordering per the given entries:
#
#     h = Hash[foo: 0, bar: 1]
#     h # => {:foo=>0, :bar=>1}
#
# New entries are added at the end:
#
#     h[:baz] = 2
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Updating a value does not affect the order:
#
#     h[:baz] = 3
#     h # => {:foo=>0, :bar=>1, :baz=>3}
#
# But re-creating a deleted entry can affect the order:
#
#     h.delete(:foo)
#     h[:foo] = 5
#     h # => {:bar=>1, :baz=>3, :foo=>5}
#
# ### `Hash` Keys
#
# #### `Hash` Key Equivalence
#
# Two objects are treated as the same hash key when their `hash` value is
# identical and the two objects are `eql?` to each other.
#
# #### Modifying an Active `Hash` Key
#
# Modifying a `Hash` key while it is in use damages the hash's index.
#
# This `Hash` has keys that are Arrays:
#
#     a0 = [ :foo, :bar ]
#     a1 = [ :baz, :bat ]
#     h = {a0 => 0, a1 => 1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#     a0.hash # => 110002110
#
# Modifying array element `a0[0]` changes its hash value:
#
#     a0[0] = :bam
#     a0.hash # => 1069447059
#
# And damages the `Hash` index:
#
#     h.include?(a0) # => false
#     h[a0] # => nil
#
# You can repair the hash index using method `rehash`:
#
#     h.rehash # => {[:bam, :bar]=>0, [:baz, :bat]=>1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#
# A String key is always safe. That's because an unfrozen String passed as a key
# will be replaced by a duplicated and frozen String:
#
#     s = 'foo'
#     s.frozen? # => false
#     h = {s => 0}
#     first_key = h.keys.first
#     first_key.frozen? # => true
#
# #### User-Defined `Hash` Keys
#
# To be usable as a `Hash` key, objects must implement the methods `hash` and
# `eql?`. Note: this requirement does not apply if the `Hash` uses
# #compare_by_identity since comparison will then rely on the keys' object id
# instead of `hash` and `eql?`.
#
# Object defines basic implementation for `hash` and `eq?` that makes each
# object a distinct key. Typically, user-defined classes will want to override
# these methods to provide meaningful behavior, or for example inherit Struct
# that has useful definitions for these.
#
# A typical implementation of `hash` is based on the object's data while `eql?`
# is usually aliased to the overridden `==` method:
#
#     class Book
#       attr_reader :author, :title
#
#       def initialize(author, title)
#         @author = author
#         @title = title
#       end
#
#       def ==(other)
#         self.class === other &&
#           other.author == @author &&
#           other.title == @title
#       end
#
#       alias eql? ==
#
#       def hash
#         [self.class, @author, @title].hash
#       end
#     end
#
#     book1 = Book.new 'matz', 'Ruby in a Nutshell'
#     book2 = Book.new 'matz', 'Ruby in a Nutshell'
#
#     reviews = {}
#
#     reviews[book1] = 'Great reference!'
#     reviews[book2] = 'Nice and compact!'
#
#     reviews.length #=> 1
#
# ### Default Values
#
# The methods #[], #values_at and #dig need to return the value associated to a
# certain key. When that key is not found, that value will be determined by its
# default proc (if any) or else its default (initially `nil`).
#
# You can retrieve the default value with method #default:
#
#     h = Hash.new
#     h.default # => nil
#
# You can set the default value by passing an argument to method Hash.new or
# with method #default=
#
#     h = Hash.new(-1)
#     h.default # => -1
#     h.default = 0
#     h.default # => 0
#
# This default value is returned for #[], #values_at and #dig when a key is not
# found:
#
#     counts = {foo: 42}
#     counts.default # => nil (default)
#     counts[:foo] = 42
#     counts[:bar] # => nil
#     counts.default = 0
#     counts[:bar] # => 0
#     counts.values_at(:foo, :bar, :baz) # => [42, 0, 0]
#     counts.dig(:bar) # => 0
#
# Note that the default value is used without being duplicated. It is not
# advised to set the default value to a mutable object:
#
#     synonyms = Hash.new([])
#     synonyms[:hello] # => []
#     synonyms[:hello] << :hi # => [:hi], but this mutates the default!
#     synonyms.default # => [:hi]
#     synonyms[:world] << :universe
#     synonyms[:world] # => [:hi, :universe], oops
#     synonyms.keys # => [], oops
#
# To use a mutable object as default, it is recommended to use a default proc
#
# #### Default Proc
#
# When the default proc for a `Hash` is set (i.e., not `nil`), the default value
# returned by method #[] is determined by the default proc alone.
#
# You can retrieve the default proc with method #default_proc:
#
#     h = Hash.new
#     h.default_proc # => nil
#
# You can set the default proc by calling Hash.new with a block or calling the
# method #default_proc=
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h.default_proc.class # => Proc
#     h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
#     h.default_proc.class # => Proc
#
# When the default proc is set (i.e., not `nil`) and method #[] is called with
# with a non-existent key, #[] calls the default proc with both the `Hash`
# object itself and the missing key, then returns the proc's return value:
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h[:nosuch] # => "Default value for nosuch"
#
# Note that in the example above no entry for key `:nosuch` is created:
#
#     h.include?(:nosuch) # => false
#
# However, the proc itself can add a new entry:
#
#     synonyms = Hash.new { |hash, key| hash[key] = [] }
#     synonyms.include?(:hello) # => false
#     synonyms[:hello] << :hi # => [:hi]
#     synonyms[:world] << :universe # => [:universe]
#     synonyms.keys # => [:hello, :world]
#
# Note that setting the default proc will clear the default value and vice
# versa.
#
# Be aware that a default proc that modifies the hash is not thread-safe in the
# sense that multiple threads can call into the default proc concurrently for
# the same key.
#
# ### What's Here
#
# First, what's elsewhere. Class `Hash`:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# Here, class `Hash` provides methods that are useful for:
#
# *   [Creating a Hash](rdoc-ref:Hash@Methods+for+Creating+a+Hash)
# *   [Setting Hash State](rdoc-ref:Hash@Methods+for+Setting+Hash+State)
# *   [Querying](rdoc-ref:Hash@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Hash@Methods+for+Comparing)
# *   [Fetching](rdoc-ref:Hash@Methods+for+Fetching)
# *   [Assigning](rdoc-ref:Hash@Methods+for+Assigning)
# *   [Deleting](rdoc-ref:Hash@Methods+for+Deleting)
# *   [Iterating](rdoc-ref:Hash@Methods+for+Iterating)
# *   [Converting](rdoc-ref:Hash@Methods+for+Converting)
# *   [Transforming Keys and
#     Values](rdoc-ref:Hash@Methods+for+Transforming+Keys+and+Values)
# *   [And more....](rdoc-ref:Hash@Other+Methods)
#
# Class `Hash` also includes methods from module Enumerable.
#
# #### Methods for Creating a `Hash`
#
# *   ::[]: Returns a new hash populated with given objects.
# *   ::new: Returns a new empty hash.
# *   ::try_convert: Returns a new hash created from a given object.
#
# #### Methods for Setting `Hash` State
#
# *   #compare_by_identity: Sets `self` to consider only identity in comparing
#     keys.
# *   #default=: Sets the default to a given value.
# *   #default_proc=: Sets the default proc to a given proc.
# *   #rehash: Rebuilds the hash table by recomputing the hash index for each
#     key.
#
# #### Methods for Querying
#
# *   #any?: Returns whether any element satisfies a given criterion.
# *   #compare_by_identity?: Returns whether the hash considers only identity
#     when comparing keys.
# *   #default: Returns the default value, or the default value for a given key.
# *   #default_proc: Returns the default proc.
# *   #empty?: Returns whether there are no entries.
# *   #eql?: Returns whether a given object is equal to `self`.
# *   #hash: Returns the integer hash code.
# *   #has_value? (aliased as #value?): Returns whether a given object is a
#     value in `self`.
# *   #include? (aliased as #has_key?, #member?, #key?): Returns whether a given
#     object is a key in `self`.
# *   #size (aliased as #length): Returns the count of entries.
#
# #### Methods for Comparing
#
# *   #<: Returns whether `self` is a proper subset of a given object.
# *   #<=: Returns whether `self` is a subset of a given object.
# *   #==: Returns whether a given object is equal to `self`.
# *   #>: Returns whether `self` is a proper superset of a given object
# *   #>=: Returns whether `self` is a superset of a given object.
#
# #### Methods for Fetching
#
# *   #[]: Returns the value associated with a given key.
# *   #assoc: Returns a 2-element array containing a given key and its value.
# *   #dig: Returns the object in nested objects that is specified by a given
#     key and additional arguments.
# *   #fetch: Returns the value for a given key.
# *   #fetch_values: Returns array containing the values associated with given
#     keys.
# *   #key: Returns the key for the first-found entry with a given value.
# *   #keys: Returns an array containing all keys in `self`.
# *   #rassoc: Returns a 2-element array consisting of the key and value of the
#     first-found entry having a given value.
# *   #values: Returns an array containing all values in `self`/
# *   #values_at: Returns an array containing values for given keys.
#
# #### Methods for Assigning
#
# *   #[]= (aliased as #store): Associates a given key with a given value.
# *   #merge: Returns the hash formed by merging each given hash into a copy of
#     `self`.
# *   #update (aliased as #merge!): Merges each given hash into `self`.
# *   #replace (aliased as #initialize_copy): Replaces the entire contents of
#     `self` with the contents of a given hash.
#
# #### Methods for Deleting
#
# These methods remove entries from `self`:
#
# *   #clear: Removes all entries from `self`.
# *   #compact!: Removes all `nil`-valued entries from `self`.
# *   #delete: Removes the entry for a given key.
# *   #delete_if: Removes entries selected by a given block.
# *   #select! (aliased as #filter!): Keep only those entries selected by a
#     given block.
# *   #keep_if: Keep only those entries selected by a given block.
# *   #reject!: Removes entries selected by a given block.
# *   #shift: Removes and returns the first entry.
#
# These methods return a copy of `self` with some entries removed:
#
# *   #compact: Returns a copy of `self` with all `nil`-valued entries removed.
# *   #except: Returns a copy of `self` with entries removed for specified keys.
# *   #select (aliased as #filter): Returns a copy of `self` with only those
#     entries selected by a given block.
# *   #reject: Returns a copy of `self` with entries removed as specified by a
#     given block.
# *   #slice: Returns a hash containing the entries for given keys.
#
# #### Methods for Iterating
# *   #each_pair (aliased as #each): Calls a given block with each key-value
#     pair.
# *   #each_key: Calls a given block with each key.
# *   #each_value: Calls a given block with each value.
#
# #### Methods for Converting
#
# *   #inspect (aliased as #to_s): Returns a new String containing the hash
#     entries.
# *   #to_a: Returns a new array of 2-element arrays; each nested array contains
#     a key-value pair from `self`.
# *   #to_h: Returns `self` if a `Hash`; if a subclass of `Hash`, returns a
#     `Hash` containing the entries from `self`.
# *   #to_hash: Returns `self`.
# *   #to_proc: Returns a proc that maps a given key to its value.
#
# #### Methods for Transforming Keys and Values
#
# *   #transform_keys: Returns a copy of `self` with modified keys.
# *   #transform_keys!: Modifies keys in `self`
# *   #transform_values: Returns a copy of `self` with modified values.
# *   #transform_values!: Modifies values in `self`.
#
# #### Other Methods
# *   #flatten: Returns an array that is a 1-dimensional flattening of `self`.
# *   #invert: Returns a hash with the each key-value pair inverted.
#
class Hash[unchecked out K, unchecked out V] < Object
  include Enumerable[[ K, V ]]

  interface _Key
    def hash: () -> Integer

    def eql?: (untyped rhs) -> boolish
  end

  # <!--
  #   rdoc-file=hash.c
  #   - Hash[] -> new_empty_hash
  #   - Hash[hash] -> new_hash
  #   - Hash[ [*2_element_arrays] ] -> new_hash
  #   - Hash[*objects] -> new_hash
  # -->
  # Returns a new `Hash` object populated with the given objects, if any. See
  # Hash::new.
  #
  # With no argument, returns a new empty `Hash`.
  #
  # When the single given argument is a `Hash`, returns a new `Hash` populated
  # with the entries from the given `Hash`, excluding the default value or proc.
  #
  #     h = {foo: 0, bar: 1, baz: 2}
  #     Hash[h] # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When the single given argument is an Array of 2-element Arrays, returns a new
  # `Hash` object wherein each 2-element array forms a key-value entry:
  #
  #     Hash[ [ [:foo, 0], [:bar, 1] ] ] # => {:foo=>0, :bar=>1}
  #
  # When the argument count is an even number; returns a new `Hash` object wherein
  # each successive pair of arguments has become a key-value entry:
  #
  #     Hash[:foo, 0, :bar, 1] # => {:foo=>0, :bar=>1}
  #
  # Raises an exception if the argument list does not conform to any of the above.
  #
  def self.[]: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
             | [U, V] (Array[[ U, V ]]) -> ::Hash[U, V]
             | (*untyped) -> ::Hash[untyped, untyped]

  # <!--
  #   rdoc-file=hash.c
  #   - Hash.try_convert(obj) -> obj, new_hash, or nil
  # -->
  # If `obj` is a `Hash` object, returns `obj`.
  #
  # Otherwise if `obj` responds to `:to_hash`, calls `obj.to_hash` and returns the
  # result.
  #
  # Returns `nil` if `obj` does not respond to `:to_hash`
  #
  # Raises an exception unless `obj.to_hash` returns a `Hash` object.
  #
  def self.try_convert: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
                      | (untyped) -> (::Hash[untyped, untyped] | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash < other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper subset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 < h2 # => true
  #     h2 < h1 # => false
  #     h1 < h1 # => false
  #
  def <: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash <= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a subset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 <= h2 # => true
  #     h2 <= h1 # => false
  #     h1 <= h1 # => true
  #
  def <=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash == object -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a `Hash` object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `hash[key] == object[key]`.
  #
  # Otherwise, returns `false`.
  #
  # Equal:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 == h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1 == h3 # => true
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash > other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper superset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 > h2 # => true
  #     h2 > h1 # => false
  #     h1 > h1 # => false
  #
  def >: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash >= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a superset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 >= h2 # => true
  #     h2 >= h1 # => false
  #     h1 >= h1 # => true
  #
  def >=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] -> value
  # -->
  # Returns the value associated with the given `key`, if found:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:foo] # => 0
  #
  # If `key` is not found, returns a default value (see [Default
  # Values](rdoc-ref:Hash@Default+Values)):
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:nosuch] # => nil
  #
  def []: %a{implicitly-returns-nil} (K arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] = value -> value
  #   - hash.store(key, value)
  # -->
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  def []=: (K arg0, V arg1) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.any? -> true or false
  #   - hash.any?(object) -> true or false
  #   - hash.any? {|key, value| ... } -> true or false
  # -->
  # Returns `true` if any element satisfies a given criterion; `false` otherwise.
  #
  # If `self` has no element, returns `false` and argument or block are not used.
  #
  # With no argument and no block, returns `true` if `self` is non-empty; `false`
  # if empty.
  #
  # With argument `object` and no block, returns `true` if for any key `key`
  # `h.assoc(key) == object`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any?([:bar, 1]) # => true
  #     h.any?([:bar, 0]) # => false
  #     h.any?([:baz, 1]) # => false
  #
  # With no argument and a block, calls the block with each key-value pair;
  # returns `true` if the block returns any truthy value, `false` otherwise:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any? {|key, value| value < 3 } # => true
  #     h.any? {|key, value| value > 3 } # => false
  #
  # Related: Enumerable#any?
  #
  def any?: () -> bool
          | (untyped pattern) -> bool
          | () { (K, V) -> boolish } -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.assoc(key) -> new_array or nil
  # -->
  # If the given `key` is found, returns a 2-element Array containing that key and
  # its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.assoc(:bar) # => [:bar, 1]
  #
  # Returns `nil` if key `key` is not found.
  #
  def assoc: (K arg0) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.clear -> self
  # -->
  # Removes all hash entries; returns `self`.
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact -> new_hash
  # -->
  # Returns a copy of `self` with all `nil`-valued entries removed:
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h1 = h.compact
  #     h1 # => {:foo=>0, :baz=>2}
  #
  def compact: () -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact! -> self or nil
  # -->
  # Returns `self` with all its `nil`-valued entries removed (in place):
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h.compact! # => {:foo=>0, :baz=>2}
  #
  # Returns `nil` if no entries were removed.
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity -> self
  # -->
  # Sets `self` to consider only identity in comparing keys; two keys are
  # considered the same only if they are the same object; returns `self`.
  #
  # By default, these two object are considered to be the same key, so `s1` will
  # overwrite `s0`:
  #     s0 = 'x'
  #     s1 = 'x'
  #     h = {}
  #     h.compare_by_identity? # => false
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>1}
  #
  # After calling #compare_by_identity, the keys are considered to be different,
  # and therefore do not overwrite each other:
  #     h = {}
  #     h.compare_by_identity # => {}
  #     h.compare_by_identity? # => true
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>0, "x"=>1}
  #
  def compare_by_identity: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity? -> true or false
  # -->
  # Returns `true` if #compare_by_identity has been called, `false` otherwise.
  #
  def compare_by_identity?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - deconstruct_keys(p1)
  # -->
  #
  def deconstruct_keys: (Array[K] | nil) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default -> object
  #   - hash.default(key) -> object
  # -->
  # Returns the default value for the given `key`. The returned value will be
  # determined either by the default proc or by the default value. See [Default
  # Values](rdoc-ref:Hash@Default+Values).
  #
  # With no argument, returns the current default value:
  #     h = {}
  #     h.default # => nil
  #
  # If `key` is given, returns the default value for `key`, regardless of whether
  # that key exists:
  #     h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
  #     h[:foo] = "Hello"
  #     h.default(:foo) # => "No key foo"
  #
  def default: (?K arg0) -> V?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default = value -> object
  # -->
  # Sets the default value to `value`; returns `value`:
  #     h = {}
  #     h.default # => nil
  #     h.default = false # => false
  #     h.default # => false
  #
  # See [Default Values](rdoc-ref:Hash@Default+Values).
  #
  def default=: (V arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc -> proc or nil
  # -->
  # Returns the default proc for `self` (see [Default
  # Values](rdoc-ref:Hash@Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc {|hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #
  def default_proc: () -> (Proc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc = proc -> proc
  # -->
  # Sets the default proc for `self` to `proc` (see [Default
  # Values](rdoc-ref:Hash@Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc { |hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #     h.default_proc = nil
  #     h.default_proc # => nil
  #
  def default_proc=: (Proc | _ToProc | nil) -> (Proc | _ToProc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete(key) -> value or nil
  #   - hash.delete(key) {|key| ... } -> object
  # -->
  # Deletes the entry for the given `key` and returns its associated value.
  #
  # If no block is given and `key` is found, deletes the entry and returns the
  # associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:bar) # => 1
  #     h # => {:foo=>0, :baz=>2}
  #
  # If no block given and `key` is not found, returns `nil`.
  #
  # If a block is given and `key` is found, ignores the block, deletes the entry,
  # and returns the associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:baz) { |key| raise 'Will never happen'} # => 2
  #     h # => {:foo=>0, :bar=>1}
  #
  # If a block is given and `key` is not found, calls the block and returns the
  # block's return value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:nosuch) { |key| "Key #{key} not found" } # => "Key nosuch not found"
  #     h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def delete: (K arg0) -> V?
            | [U] (K arg0) { (K arg0) -> U } -> (U | V)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete_if {|key, value| ... } -> self
  #   - hash.delete_if -> new_enumerator
  # -->
  # If a block given, calls the block with each key-value pair; deletes each entry
  # for which the block returns a truthy value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete_if {|key, value| value > 0 } # => {:foo=>0}
  #
  # If no block given, returns a new Enumerator:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.delete_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:delete_if>
  #     e.each { |key, value| value > 0 } # => {:foo=>0}
  #
  def delete_if: () { (K, V) -> boolish } -> self
               | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.dig(key, *identifiers) -> object
  # -->
  # Finds and returns the object in nested objects that is specified by `key` and
  # `identifiers`. The nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Nested Hashes:
  #     h = {foo: {bar: {baz: 2}}}
  #     h.dig(:foo) # => {:bar=>{:baz=>2}}
  #     h.dig(:foo, :bar) # => {:baz=>2}
  #     h.dig(:foo, :bar, :baz) # => 2
  #     h.dig(:foo, :bar, :BAZ) # => nil
  #
  # Nested Hashes and Arrays:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:foo, :bar, 2) # => :c
  #
  # This method will use the [default values](rdoc-ref:Hash@Default+Values) for
  # keys that are not present:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:hello) # => nil
  #     h.default_proc = -> (hash, _key) { hash }
  #     h.dig(:hello, :world) # => h
  #     h.dig(:hello, :world, :foo, :bar, 2) # => :c
  #
  def dig: (K, *untyped) -> untyped

  # <!-- rdoc-file=hash.c -->
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  def each: () { ([ K, V ] arg0) -> untyped } -> self
          | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_key {|key| ... } -> self
  #   - hash.each_key -> new_enumerator
  # -->
  # Calls the given block with each key; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_key {|key| puts key }  # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_key # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_key>
  #     h1 = e.each {|key| puts key }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  def each_key: () { (K arg0) -> untyped } -> ::Hash[K, V]
              | () -> ::Enumerator[K, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each {|key, value| ... } -> self
  #   - hash.each_pair {|key, value| ... } -> self
  #   - hash.each -> new_enumerator
  #   - hash.each_pair -> new_enumerator
  # -->
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  alias each_pair each

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_value {|value| ... } -> self
  #   - hash.each_value -> new_enumerator
  # -->
  # Calls the given block with each value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_value {|value| puts value } # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_value # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_value>
  #     h1 = e.each {|value| puts value }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  def each_value: () { (V arg0) -> untyped } -> self
                | () -> ::Enumerator[V, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.empty? -> true or false
  # -->
  # Returns `true` if there are no hash entries, `false` otherwise:
  #     {}.empty? # => true
  #     {foo: 0, bar: 1, baz: 2}.empty? # => false
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.eql?(object) -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a `Hash` object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `h[key].eql?(object[key])`.
  #
  # Otherwise, returns `false`.
  #
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1.eql? h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1.eql? h3 # => true
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hsh.except(*keys) -> a_hash
  # -->
  # Returns a new `Hash` excluding entries for the given `keys`:
  #     h = { a: 100, b: 200, c: 300 }
  #     h.except(:a)          #=> {:b=>200, :c=>300}
  #
  # Any given `keys` that are not found are ignored.
  #
  def except: (*K) -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch(key) -> object
  #   - hash.fetch(key, default_value) -> object
  #   - hash.fetch(key) {|key| ... } -> object
  # -->
  # Returns the value for the given `key`, if found.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch(:bar) # => 1
  #
  # If `key` is not found and no block was given, returns `default_value`:
  #     {}.fetch(:nosuch, :default) # => :default
  #
  # If `key` is not found and a block was given, yields `key` to the block and
  # returns the block's return value:
  #     {}.fetch(:nosuch) {|key| "No key #{key}"} # => "No key nosuch"
  #
  # Raises KeyError if neither `default_value` nor a block was given.
  #
  # Note that this method does not use the values of either #default or
  # #default_proc.
  #
  def fetch: (K arg0) -> V
           | [X] (K arg0, X arg1) -> (V | X)
           | [X] (K arg0) { (K arg0) -> X } -> (V | X)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch_values(*keys) -> new_array
  #   - hash.fetch_values(*keys) {|key| ... } -> new_array
  # -->
  # Returns a new Array containing the values associated with the given keys
  # *keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch_values(:baz, :foo) # => [2, 0]
  #
  # Returns a new empty Array if no arguments given.
  #
  # When a block is given, calls the block with each missing key, treating the
  # block's return value as the value for that key:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
  #     values # => [1, 0, "bad", "bam"]
  #
  # When no block is given, raises an exception if any given key is not found.
  #
  def fetch_values: (*K) -> ::Array[V]
                  | [X] (*K) { (K) -> X } -> ::Array[V | X]

  # <!-- rdoc-file=hash.c -->
  # Returns a new `Hash` object whose entries are those for which the block
  # returns a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter: () { (K, V) -> boolish } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], ::Hash[K, V]]

  # <!-- rdoc-file=hash.c -->
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter!: () { (K, V) -> boolish } -> self?
             | () -> ::Enumerator[[ K, V ], self?]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.flatten -> new_array
  #   - hash.flatten(level) -> new_array
  # -->
  # Returns a new Array object that is a 1-dimensional flattening of `self`.
  #
  # ---
  #
  # By default, nested Arrays are not flattened:
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten # => [:foo, 0, :bar, [:bat, 3], :baz, 2]
  #
  # Takes the depth of recursive flattening from Integer argument `level`:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(1) # => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
  #     h.flatten(2) # => [:foo, 0, :bar, :bat, [:baz, [:bat]]]
  #     h.flatten(3) # => [:foo, 0, :bar, :bat, :baz, [:bat]]
  #     h.flatten(4) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is negative, flattens all nested Arrays:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(-1) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #     h.flatten(-2) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is zero, returns the equivalent of #to_a :
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten(0) # => [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
  #     h.flatten(0) == h.to_a # => true
  #
  def flatten: () -> ::Array[K | V]
             | (1 level) -> ::Array[K | V]
             | (Integer level) -> Array[untyped]

  # <!-- rdoc-file=hash.c -->
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  def has_key?: (K arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.has_value?(value) -> true or false
  #   - hash.value?(value) -> true or false
  # -->
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  def has_value?: (V arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.hash -> an_integer
  # -->
  # Returns the Integer hash-code for the hash.
  #
  # Two `Hash` objects have the same hash-code if their content is the same
  # (regardless of order):
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {baz: 2, bar: 1, foo: 0}
  #     h2.hash == h1.hash # => true
  #     h2.eql? h1 # => true
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=hash.c
  #   - hash.include?(key) -> true or false
  #   - hash.has_key?(key) -> true or false
  #   - hash.key?(key) -> true or false
  #   - hash.member?(key) -> true or false
  # -->
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias include? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.inspect -> new_string
  # -->
  # Returns a new String containing the hash entries:
  #
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{foo: 0, bar: 1, baz: 2}"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=hash.c
  #   - hash.invert -> new_hash
  # -->
  # Returns a new `Hash` object with the each key-value pair inverted:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.invert
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # Overwrites any repeated new keys: (see [Entry
  # Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 0, baz: 0}
  #     h.invert # => {0=>:baz}
  #
  def invert: () -> ::Hash[V, K]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keep_if {|key, value| ... } -> self
  #   - hash.keep_if -> new_enumerator
  # -->
  # Calls the block for each key-value pair; retains the entry if the block
  # returns a truthy value; otherwise deletes the entry; returns `self`.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keep_if { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.keep_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:keep_if>
  #     e.each { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  def keep_if: () { (K, V) -> boolish } -> self
             | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.key(value) -> key or nil
  # -->
  # Returns the key for the first-found entry with the given `value` (see [Entry
  # Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 2, baz: 2}
  #     h.key(0) # => :foo
  #     h.key(2) # => :bar
  #
  # Returns `nil` if no such value is found.
  #
  def key: (V) -> K?

  # <!-- rdoc-file=hash.c -->
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias key? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keys -> new_array
  # -->
  # Returns a new Array containing all keys in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keys # => [:foo, :bar, :baz]
  #
  def keys: () -> ::Array[K]

  # <!-- rdoc-file=hash.c -->
  # Returns the count of entries in `self`:
  #
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  def length: () -> Integer

  # <!-- rdoc-file=hash.c -->
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias member? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge -> copy_of_self
  #   - hash.merge(*other_hashes) -> new_hash
  #   - hash.merge(*other_hashes) { |key, old_value, new_value| ... } -> new_hash
  # -->
  # Returns the new `Hash` formed by merging each of `other_hashes` into a copy of
  # `self`.
  #
  # Each argument in `other_hashes` must be a `Hash`.
  #
  # ---
  #
  # With arguments and no block:
  # *   Returns the new `Hash` object formed by merging each successive `Hash` in
  #     `other_hashes` into `self`.
  # *   Each new-key entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns a new `Hash` object that is the merge of `self` and each given
  #     hash.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns a copy of `self`.
  # *   The block, if given, is ignored.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge: [A, B] (*::Hash[A, B] other_hashes) -> ::Hash[A | K, B | V]
           | [A, B, C] (*::Hash[A, B] other_hashes) { (K key, V oldval, B newval) -> C } -> ::Hash[A | K, B | V | C]

  # <!-- rdoc-file=hash.c -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a `Hash`.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge!: (*::Hash[K, V] other_hashes) -> self
            | (*::Hash[K, V] other_hashes) { (K key, V oldval, V newval) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rassoc(value) -> new_array or nil
  # -->
  # Returns a new 2-element Array consisting of the key and value of the
  # first-found entry whose value is `==` to value (see [Entry
  # Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 1, baz: 1}
  #     h.rassoc(1) # => [:bar, 1]
  #
  # Returns `nil` if no such value found.
  #
  def rassoc: (V) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rehash -> self
  # -->
  # Rebuilds the hash table by recomputing the hash index for each key; returns
  # `self`.
  #
  # The hash table becomes invalid if the hash value of a key has changed after
  # the entry was created. See [Modifying an Active Hash
  # Key](rdoc-ref:Hash@Modifying+an+Active+Hash+Key).
  #
  def rehash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject {|key, value| ... } -> new_hash
  #   - hash.reject -> new_enumerator
  # -->
  # Returns a new `Hash` object whose entries are all those from `self` for which
  # the block returns `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.reject {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject>
  #     h1 = e.each {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  def reject: () -> ::Enumerator[[ K, V ], ::Hash[K, V]]
            | () { (K, V) -> boolish } -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject! {|key, value| ... } -> self or nil
  #   - hash.reject! -> new_enumerator
  # -->
  # Returns `self`, whose remaining entries are those for which the block returns
  # `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.reject! {|key, value| value < 2 } # => {:baz=>2}
  #
  # Returns `nil` if no entries are removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject! # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject!>
  #     e.each {|key, value| key.start_with?('b') } # => {:foo=>0}
  #
  def reject!: () -> ::Enumerator[[ K, V ], self?]
             | () { (K, V) -> boolish } -> self?

  # <!-- rdoc-file=hash.c -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def replace: (Hash[K, V]) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select {|key, value| ... } -> new_hash
  #   - hash.select -> new_enumerator
  # -->
  # Returns a new `Hash` object whose entries are those for which the block
  # returns a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select filter

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select! {|key, value| ... } -> self or nil
  #   - hash.select! -> new_enumerator
  # -->
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select! filter!

  # <!--
  #   rdoc-file=hash.c
  #   - hash.shift -> [key, value] or nil
  # -->
  # Removes the first hash entry (see [Entry Order](rdoc-ref:Hash@Entry+Order));
  # returns a 2-element Array containing the removed key and value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.shift # => [:foo, 0]
  #     h # => {:bar=>1, :baz=>2}
  #
  # Returns nil if the hash is empty.
  #
  def shift: () -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.length -> integer
  #   - hash.size -> integer
  # -->
  # Returns the count of entries in `self`:
  #
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  alias size length

  # <!--
  #   rdoc-file=hash.c
  #   - hash.slice(*keys) -> new_hash
  # -->
  # Returns a new `Hash` object containing the entries for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.slice(:baz, :foo) # => {:baz=>2, :foo=>0}
  #
  # Any given `keys` that are not found are ignored.
  #
  def slice: (*K) -> ::Hash[K, V]

  # <!-- rdoc-file=hash.c -->
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](rdoc-ref:Hash@Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  alias store []=

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_a -> new_array
  # -->
  # Returns a new Array of 2-element Array objects; each nested Array contains a
  # key-value pair from `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.to_a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  def to_a: () -> ::Array[[ K, V ]]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_h -> self or new_hash
  #   - hash.to_h {|key, value| ... } -> new_hash
  # -->
  # For an instance of `Hash`, returns `self`.
  #
  # For a subclass of `Hash`, returns a new `Hash` containing the content of
  # `self`.
  #
  # When a block is given, returns a new `Hash` object whose content is based on
  # the block; the block should return a 2-element Array object specifying the
  # key-value pair to be included in the returned Array:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.to_h {|key, value| [value, key] }
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  def to_h: () -> Hash[K, V]
          | [A, B] () { (K, V) -> [ A, B ] } -> Hash[A, B]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_hash -> self
  # -->
  # Returns `self`.
  #
  def to_hash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_proc -> proc
  # -->
  # Returns a Proc object that maps a key to its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     proc = h.to_proc
  #     proc.class # => Proc
  #     proc.call(:foo) # => 0
  #     proc.call(:bar) # => 1
  #     proc.call(:nosuch) # => nil
  #
  def to_proc: () -> ^(K) -> V?

  # <!-- rdoc-file=hash.c -->
  # Returns a new String containing the hash entries:
  #
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{foo: 0, bar: 1, baz: 2}"
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys {|key| ... } -> new_hash
  #   - hash.transform_keys(hash2) -> new_hash
  #   - hash.transform_keys(hash2) {|other_key| ...} -> new_hash
  #   - hash.transform_keys -> new_enumerator
  # -->
  # Returns a new `Hash` object; each entry has:
  # *   A key provided by the block.
  # *   The value from `self`.
  #
  # An optional hash argument can be provided to map keys to new keys. Any key not
  # given will be mapped using the provided block, or remain the same if no block
  # is given.
  #
  # Transform keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  #     h.transform_keys(foo: :bar, bar: :foo)
  #     #=> {bar: 0, foo: 1, baz: 2}
  #
  #     h.transform_keys(foo: :hello, &:to_s)
  #     #=> {:hello=>0, "bar"=>1, "baz"=>2}
  #
  # Overwrites values for duplicate keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| :bat }
  #     h1 # => {:bat=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_keys # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_keys>
  #     h1 = e.each { |key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  def transform_keys: () -> Enumerator[K, Hash[untyped, V]]
                    | [A] () { (K) -> A } -> Hash[A, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys! {|key| ... } -> self
  #   - hash.transform_keys!(hash2) -> self
  #   - hash.transform_keys!(hash2) {|other_key| ...} -> self
  #   - hash.transform_keys! -> new_enumerator
  # -->
  # Same as Hash#transform_keys but modifies the receiver in place instead of
  # returning a new hash.
  #
  def transform_keys!: () -> Enumerator[K, self]
                     | () { (K) -> K } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values {|value| ... } -> new_hash
  #   - hash.transform_values -> new_enumerator
  # -->
  # Returns a new `Hash` object; each entry has:
  # *   A key from `self`.
  # *   A value provided by the block.
  #
  # Transform values:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_values {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_values>
  #     h1 = e.each { |value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values: () -> Enumerator[V, Hash[K, untyped]]
                      | [A] () { (V) -> A } -> Hash[K, A]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values! {|value| ... } -> self
  #   - hash.transform_values! -> new_enumerator
  # -->
  # Returns `self`, whose keys are unchanged, and whose values are determined by
  # the given block.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.transform_values! {|value| value * 100} # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values! # => #<Enumerator: {:foo=>0, :bar=>100, :baz=>200}:transform_values!>
  #     h1 = e.each {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values!: () -> Enumerator[V, self]
                       | () { (V) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge! -> self
  #   - hash.merge!(*other_hashes) -> self
  #   - hash.merge!(*other_hashes) { |key, old_value, new_value| ... } -> self
  # -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a `Hash`.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  alias update merge!

  # <!-- rdoc-file=hash.c -->
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  alias value? has_value?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values -> new_array
  # -->
  # Returns a new Array containing all values in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values # => [0, 1, 2]
  #
  def values: () -> ::Array[V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values_at(*keys) -> new_array
  # -->
  # Returns a new Array containing values for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values_at(:baz, :foo) # => [2, 0]
  #
  # The [default values](rdoc-ref:Hash@Default+Values) are returned for any keys
  # that are not found:
  #     h.values_at(:hello, :foo) # => [nil, 0]
  #
  def values_at: (*K arg0) -> ::Array[V?]

  private

  # <!--
  #   rdoc-file=hash.rb
  #   - Hash.new(default_value = nil) -> new_hash
  #   - Hash.new(default_value = nil, capacity: size) -> new_hash
  #   - Hash.new {|hash, key| ... } -> new_hash
  #   - Hash.new(capacity: size) {|hash, key| ... } -> new_hash
  # -->
  # Returns a new empty `Hash` object.
  #
  # The initial default value and initial default proc for the new hash depend on
  # which form above was used. See [Default Values](rdoc-ref:Hash@Default+Values).
  #
  # If neither an argument nor a block is given, initializes both the default
  # value and the default proc to `nil`:
  #     h = Hash.new
  #     h.default # => nil
  #     h.default_proc # => nil
  #
  # If argument `default_value` is given but no block is given, initializes the
  # default value to the given `default_value` and the default proc to `nil`:
  #     h = Hash.new(false)
  #     h.default # => false
  #     h.default_proc # => nil
  #
  # If a block is given but no `default_value`, stores the block as the default
  # proc and sets the default value to `nil`:
  #     h = Hash.new {|hash, key| "Default value for #{key}" }
  #     h.default # => nil
  #     h.default_proc.class # => Proc
  #     h[:nosuch] # => "Default value for nosuch"
  #
  # If both a block and a `default_value` are given, raises an `ArgumentError`
  #
  # If the optional keyword argument `capacity` is given, the hash will be
  # allocated with enough capacity to accommodate this many keys without having to
  # be resized.
  #
  def initialize: (?capacity: int) -> void
                | [V] (V default, ?capacity: int) -> void
                | [A, B] (?capacity: int) { (Hash[A, B] hash, A key) -> B } -> void

  # <!--
  #   rdoc-file=hash.c
  #   - hash.replace(other_hash) -> self
  # -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def initialize_copy: (self object) -> self
end
# <!-- rdoc-file=proc.c -->
# Ruby supports two forms of objectified methods. Class Method is used to
# represent methods that are associated with a particular object: these method
# objects are bound to that object. Bound method objects for an object can be
# created using Object#method.
#
# Ruby also supports unbound methods; methods objects that are not associated
# with a particular object. These can be created either by calling
# Module#instance_method or by calling #unbind on a bound method object. The
# result of both of these is an UnboundMethod object.
#
# Unbound methods can only be called after they are bound to an object. That
# object must be a kind_of? the method's original class.
#
#     class Square
#       def area
#         @side * @side
#       end
#       def initialize(side)
#         @side = side
#       end
#     end
#
#     area_un = Square.instance_method(:area)
#
#     s = Square.new(12)
#     area = area_un.bind(s)
#     area.call   #=> 144
#
# Unbound methods are a reference to the method at the time it was objectified:
# subsequent changes to the underlying class will not affect the unbound method.
#
#     class Test
#       def test
#         :original
#       end
#     end
#     um = Test.instance_method(:test)
#     class Test
#       def test
#         :modified
#       end
#     end
#     t = Test.new
#     t.test            #=> :modified
#     um.bind(t).call   #=> :original
#
class UnboundMethod
  # <!--
  #   rdoc-file=proc.c
  #   - meth.eql?(other_meth)  -> true or false
  #   - meth == other_meth  -> true or false
  # -->
  # Two unbound method objects are equal if they refer to the same method
  # definition.
  #
  #     Array.instance_method(:each_slice) == Enumerable.instance_method(:each_slice)
  #     #=> true
  #
  #     Array.instance_method(:sum) == Enumerable.instance_method(:sum)
  #     #=> false, Array redefines the method for efficiency
  #
  def ==: (untyped other) -> bool

  # <!-- rdoc-file=proc.c -->
  # Two unbound method objects are equal if they refer to the same method
  # definition.
  #
  #     Array.instance_method(:each_slice) == Enumerable.instance_method(:each_slice)
  #     #=> true
  #
  #     Array.instance_method(:sum) == Enumerable.instance_method(:sum)
  #     #=> false, Array redefines the method for efficiency
  #
  alias eql? ==

  # <!--
  #   rdoc-file=proc.c
  #   - meth.hash   -> integer
  # -->
  # Returns a hash value corresponding to the method object.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> instance

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind(obj) -> method
  # -->
  # Bind *umeth* to *obj*. If Klass was the class from which *umeth* was obtained,
  # `obj.kind_of?(Klass)` must be true.
  #
  #     class A
  #       def test
  #         puts "In test, class = #{self.class}"
  #       end
  #     end
  #     class B < A
  #     end
  #     class C < B
  #     end
  #
  #     um = B.instance_method(:test)
  #     bm = um.bind(C.new)
  #     bm.call
  #     bm = um.bind(B.new)
  #     bm.call
  #     bm = um.bind(A.new)
  #     bm.call
  #
  # *produces:*
  #
  #     In test, class = C
  #     In test, class = B
  #     prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)
  #      from prog.rb:16
  #
  def bind: (untyped obj) -> Method

  # <!--
  #   rdoc-file=proc.c
  #   - meth.to_s      ->  string
  #   - meth.inspect   ->  string
  # -->
  # Returns a human-readable description of the underlying method.
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     (1..3).method(:map).inspect    #=> "#<Method: Range(Enumerable)#map()>"
  #
  # In the latter case, the method description includes the "owner" of the
  # original method (`Enumerable` module, which is included into `Range`).
  #
  # `inspect` also provides, when possible, method argument names (call sequence)
  # and source location.
  #
  #     require 'net/http'
  #     Net::HTTP.method(:get).inspect
  #     #=> "#<Method: Net::HTTP.get(uri_or_host, path=..., port=...) <skip>/lib/ruby/2.7.0/net/http.rb:457>"
  #
  # `...` in argument definition means argument is optional (has some default
  # value).
  #
  # For methods defined in C (language core and extensions), location and argument
  # names can't be extracted, and only generic information is provided in form of
  # `*` (any number of arguments) or `_` (some positional argument).
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     "cat".method(:+).inspect       #=> "#<Method: String#+(_)>""
  #
  def inspect: () -> String

  # <!-- rdoc-file=proc.c -->
  # Returns a human-readable description of the underlying method.
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     (1..3).method(:map).inspect    #=> "#<Method: Range(Enumerable)#map()>"
  #
  # In the latter case, the method description includes the "owner" of the
  # original method (`Enumerable` module, which is included into `Range`).
  #
  # `inspect` also provides, when possible, method argument names (call sequence)
  # and source location.
  #
  #     require 'net/http'
  #     Net::HTTP.method(:get).inspect
  #     #=> "#<Method: Net::HTTP.get(uri_or_host, path=..., port=...) <skip>/lib/ruby/2.7.0/net/http.rb:457>"
  #
  # `...` in argument definition means argument is optional (has some default
  # value).
  #
  # For methods defined in C (language core and extensions), location and argument
  # names can't be extracted, and only generic information is provided in form of
  # `*` (any number of arguments) or `_` (some positional argument).
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     "cat".method(:+).inspect       #=> "#<Method: String#+(_)>""
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module on which this method is defined. In other words,
  #
  #     meth.owner.instance_methods(false).include?(meth.name) # => true
  #
  # holds as long as the method is not removed/undefined/replaced, (with
  # private_instance_methods instead of instance_methods if the method is
  # private).
  #
  # See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> (Class | Module)

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> Method::param_types

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [String, Integer]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> UnboundMethod?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind_call(recv, args, ...) -> obj
  # -->
  # Bind *umeth* to *recv* and then invokes the method with the specified
  # arguments. This is semantically equivalent to `umeth.bind(recv).call(args,
  # ...)`.
  #
  def bind_call: (untyped recv, *untyped, **untyped) ?{ (?) -> untyped } -> untyped
end
# <!-- rdoc-file=numeric.c -->
# A Float object represents a sometimes-inexact real number using the native
# architecture's double-precision floating point representation.
#
# Floating point has a different arithmetic and is an inexact number. So you
# should know its esoteric system. See following:
#
# *   https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
# *   https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#-why-are-rub
#     ys-floats-imprecise
# *   https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
#
# You can create a Float object explicitly with:
#
# *   A [floating-point literal](rdoc-ref:syntax/literals.rdoc@Float+Literals).
#
# You can convert certain objects to Floats with:
#
# *   Method #Float.
#
# ## What's Here
#
# First, what's elsewhere. Class Float:
#
# *   Inherits from [class Numeric](rdoc-ref:Numeric@What-27s+Here) and [class
#     Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class Float provides methods for:
#
# *   [Querying](rdoc-ref:Float@Querying)
# *   [Comparing](rdoc-ref:Float@Comparing)
# *   [Converting](rdoc-ref:Float@Converting)
#
# ### Querying
#
# *   #finite?: Returns whether `self` is finite.
# *   #hash: Returns the integer hash code for `self`.
# *   #infinite?: Returns whether `self` is infinite.
# *   #nan?: Returns whether `self` is a NaN (not-a-number).
#
# ### Comparing
#
# *   #<: Returns whether `self` is less than the given value.
# *   #<=: Returns whether `self` is less than or equal to the given value.
# *   #<=>: Returns a number indicating whether `self` is less than, equal to,
#     or greater than the given value.
# *   #== (aliased as #=== and #eql?): Returns whether `self` is equal to the
#     given value.
# *   #>: Returns whether `self` is greater than the given value.
# *   #>=: Returns whether `self` is greater than or equal to the given value.
#
# ### Converting
#
# *   #% (aliased as #modulo): Returns `self` modulo the given value.
# *   #*: Returns the product of `self` and the given value.
# *   #**: Returns the value of `self` raised to the power of the given value.
# *   #+: Returns the sum of `self` and the given value.
# *   #-: Returns the difference of `self` and the given value.
# *   #/: Returns the quotient of `self` and the given value.
# *   #ceil: Returns the smallest number greater than or equal to `self`.
# *   #coerce: Returns a 2-element array containing the given value converted to
#     a Float and `self`
# *   #divmod: Returns a 2-element array containing the quotient and remainder
#     results of dividing `self` by the given value.
# *   #fdiv: Returns the Float result of dividing `self` by the given value.
# *   #floor: Returns the greatest number smaller than or equal to `self`.
# *   #next_float: Returns the next-larger representable Float.
# *   #prev_float: Returns the next-smaller representable Float.
# *   #quo: Returns the quotient from dividing `self` by the given value.
# *   #round: Returns `self` rounded to the nearest value, to a given precision.
# *   #to_i (aliased as #to_int): Returns `self` truncated to an Integer.
# *   #to_s (aliased as #inspect): Returns a string containing the place-value
#     representation of `self` in the given radix.
# *   #truncate: Returns `self` truncated to a given precision.
#
class Float < Numeric
  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> float
  # -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  def %: (Integer) -> Float
       | (Float) -> Float
       | (Rational) -> Float
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self * other -> numeric
  # -->
  # Returns a new Float which is the product of `self` and `other`:
  #
  #     f = 3.14
  #     f * 2              # => 6.28
  #     f * 2.0            # => 6.28
  #     f * Rational(1, 2) # => 1.57
  #     f * Complex(2, 0)  # => (6.28+0.0i)
  #
  def *: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** other -> numeric
  # -->
  # Raises `self` to the power of `other`:
  #
  #     f = 3.14
  #     f ** 2              # => 9.8596
  #     f ** -2             # => 0.1014239928597509
  #     f ** 2.1            # => 11.054834900588839
  #     f ** Rational(2, 1) # => 9.8596
  #     f ** Complex(2, 0)  # => (9.8596+0i)
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self + other -> numeric
  # -->
  # Returns a new Float which is the sum of `self` and `other`:
  #
  #     f = 3.14
  #     f + 1                 # => 4.140000000000001
  #     f + 1.0               # => 4.140000000000001
  #     f + Rational(1, 1)    # => 4.140000000000001
  #     f + Complex(1, 0)     # => (4.140000000000001+0i)
  #
  def +: (Complex) -> Complex
       | (Numeric) -> Float

  def +@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self - other -> numeric
  # -->
  # Returns a new Float which is the difference of `self` and `other`:
  #
  #     f = 3.14
  #     f - 1                 # => 2.14
  #     f - 1.0               # => 2.14
  #     f - Rational(1, 1)    # => 2.14
  #     f - Complex(1, 0)     # => (2.14+0i)
  #
  def -: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - -float -> float
  # -->
  # Returns `self`, negated.
  #
  def -@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self / other -> numeric
  # -->
  # Returns a new Float which is the result of dividing `self` by `other`:
  #
  #     f = 3.14
  #     f / 2              # => 1.57
  #     f / 2.0            # => 1.57
  #     f / Rational(2, 1) # => 1.57
  #     f / Complex(2, 0)  # => (1.57+0.0i)
  #
  def /: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than `other`:
  #
  #     2.0 < 3              # => true
  #     2.0 < 3.0            # => true
  #     2.0 < Rational(3, 1) # => true
  #     2.0 < 2.0            # => false
  #
  # `Float::NAN < Float::NAN` returns an implementation-dependent value.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than or equal to `other`:
  #
  #     2.0 <= 3              # => true
  #     2.0 <= 3.0            # => true
  #     2.0 <= Rational(3, 1) # => true
  #     2.0 <= 2.0            # => true
  #     2.0 <= 1.0            # => false
  #
  # `Float::NAN <= Float::NAN` returns an implementation-dependent value.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other ->  -1, 0, +1, or nil
  # -->
  # Returns a value that depends on the numeric relation between `self` and
  # `other`:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater than `other`.
  # *   `nil`, if the two values are incommensurate.
  #
  # Examples:
  #
  #     2.0 <=> 2              # => 0
  #     2.0 <=> 2.0            # => 0
  #     2.0 <=> Rational(2, 1) # => 0
  #     2.0 <=> Complex(2, 0)  # => 0
  #     2.0 <=> 1.9            # => 1
  #     2.0 <=> 2.1            # => -1
  #     2.0 <=> 'foo'          # => nil
  #
  # This is the basis for the tests in the Comparable module.
  #
  # `Float::NAN <=> Float::NAN` returns an implementation-dependent value.
  #
  def <=>: (Numeric) -> Integer?

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than `other`:
  #
  #     2.0 > 1              # => true
  #     2.0 > 1.0            # => true
  #     2.0 > Rational(1, 2) # => true
  #     2.0 > 2.0            # => false
  #
  # `Float::NAN > Float::NAN` returns an implementation-dependent value.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than or equal to `other`:
  #
  #     2.0 >= 1              # => true
  #     2.0 >= 1.0            # => true
  #     2.0 >= Rational(1, 2) # => true
  #     2.0 >= 2.0            # => true
  #     2.0 >= 2.1            # => false
  #
  # `Float::NAN >= Float::NAN` returns an implementation-dependent value.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.abs ->  float
  # -->
  # Returns the absolute value of `self`:
  #
  #     (-34.56).abs # => 34.56
  #     -34.56.abs   # => 34.56
  #     34.56.abs    # => 34.56
  #
  def abs: () -> Float

  def abs2: () -> Float

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if `self` is positive, Math::PI otherwise.
  #
  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=complex.c
  #   - arg -> 0 or Math::PI
  # -->
  # Returns 0 if `self` is positive, Math::PI otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> float or integer
  # -->
  # Returns a numeric that is a "ceiling" value for `self`,
  # as specified by the given `ndigits`,
  # which must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  # When `ndigits` is positive, returns a Float with `ndigits`
  # decimal digits after the decimal point
  # (as available, but no fewer than 1):
  #     f = 12345.6789
  # f.ceil(1) # => 12345.7
  # f.ceil(3) # => 12345.679
  # f.ceil(30) # => 12345.6789
  # f = -12345.6789
  # f.ceil(1) # => -12345.6
  # f.ceil(3) # => -12345.678
  # f.ceil(30) # => -12345.6789
  # f = 0.0
  # f.ceil(1)   # => 0.0
  # f.ceil(100) # => 0.0
  #
  # When `ndigits` is non-positive,
  # returns an Integer based on a computed granularity:
  # *   The granularity is `10 ** ndigits.abs`.
  # *   The returned value is the largest multiple of the granularity
  #      that is less than or equal to `self`.
  # Examples with positive `self`:
  # ndigits|Granularity|12345.6789.ceil(ndigits)
  # -------|-----------|------------------------
  #       0|          1|                   12346
  #      -1|         10|                   12350
  #      -2|        100|                   12400
  #      -3|       1000|                   13000
  #      -4|      10000|                   20000
  #      -5|     100000|                  100000
  # Examples with negative `self`:
  # ndigits|Granularity|-12345.6789.ceil(ndigits)
  # -------|-----------|-------------------------
  #       0|          1|                   -12345
  #      -1|         10|                   -12340
  #      -2|        100|                   -12300
  #      -3|       1000|                   -12000
  #      -4|      10000|                   -10000
  #      -5|     100000|                        0
  # When `self` is zero and `ndigits` is non-positive,
  # returns Integer zero:
  #     0.0.ceil(0)  # => 0
  # 0.0.ceil(-1) # => 0
  # 0.0.ceil(-2) # => 0
  #
  # Note that the limited precision of floating-point arithmetic
  # may lead to surprising results:
  #     (2.1 / 0.7).ceil  #=> 4 # Not 3 (because 2.1 / 0.7 # => 3.0000000000000004, not 3.0)
  #
  # Related: Float#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing `other` converted to a Float and `self`:
  #
  #     f = 3.14                 # => 3.14
  #     f.coerce(2)              # => [2.0, 3.14]
  #     f.coerce(2.0)            # => [2.0, 3.14]
  #     f.coerce(Rational(1, 2)) # => [0.5, 3.14]
  #     f.coerce(Complex(1, 0))  # => [1.0, 3.14]
  #
  # Raises an exception if a type conversion fails.
  #
  def coerce: (Numeric) -> [ Float, Float ]

  def conj: () -> Float

  def conjugate: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flo.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).  The result is machine dependent.
  #
  # See also Float#numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor      # Quotient
  #     r = self % other            # Remainder
  #
  # Examples:
  #
  #     11.0.divmod(4)              # => [2, 3.0]
  #     11.0.divmod(-4)             # => [-3, -1.0]
  #     -11.0.divmod(4)             # => [-3, 1.0]
  #     -11.0.divmod(-4)            # => [2, -3.0]
  #
  #     12.0.divmod(4)              # => [3, 0.0]
  #     12.0.divmod(-4)             # => [-3, 0.0]
  #     -12.0.divmod(4)             # => [-3, -0.0]
  #     -12.0.divmod(-4)            # => [3, -0.0]
  #
  #     13.0.divmod(4.0)            # => [3, 1.0]
  #     13.0.divmod(Rational(4, 1)) # => [3, 1.0]
  #
  def divmod: (Integer | Float | Rational) -> [ Integer, Float ]
            | (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `other` is a Float with the same value as `self`, `false`
  # otherwise:
  #
  #     2.0.eql?(2.0)            # => true
  #     2.0.eql?(1.0)            # => false
  #     2.0.eql?(1)              # => false
  #     2.0.eql?(Rational(2, 1)) # => false
  #     2.0.eql?(Complex(2, 0))  # => false
  #
  # `Float::NAN.eql?(Float::NAN)` returns an implementation-dependent value.
  #
  # Related: Float#== (performs type conversions).
  #
  def eql?: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  def fdiv: (Complex) -> Complex
          | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - finite? -> true or false
  # -->
  # Returns `true` if `self` is not `Infinity`, `-Infinity`, or `NaN`, `false`
  # otherwise:
  #
  #     f = 2.0      # => 2.0
  #     f.finite?    # => true
  #     f = 1.0/0.0  # => Infinity
  #     f.finite?    # => false
  #     f = -1.0/0.0 # => -Infinity
  #     f.finite?    # => false
  #     f = 0.0/0.0  # => NaN
  #     f.finite?    # => false
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> float or integer
  # -->
  # Returns a float or integer that is a "floor" value for `self`,
  # as specified by `ndigits`,
  # which must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  # When `self` is zero,
  # returns a zero value:
  # a float if `ndigits` is positive,
  # an integer otherwise:
  #     f = 0.0      # => 0.0
  # f.floor(20)  # => 0.0
  # f.floor(0)   # => 0
  # f.floor(-20) # => 0
  #
  # When `self` is non-zero and `ndigits` is positive, returns a float with
  # `ndigits`
  # digits after the decimal point (as available):
  #     f = 12345.6789
  # f.floor(1)  # => 12345.6
  # f.floor(3)  # => 12345.678
  # f.floor(30) # => 12345.6789
  # f = -12345.6789
  # f.floor(1)  # => -12345.7
  # f.floor(3)  # => -12345.679
  # f.floor(30) # => -12345.6789
  #
  # When `self` is non-zero and `ndigits` is non-positive,
  # returns an integer value based on a computed granularity:
  # *   The granularity is `10 ** ndigits.abs`.
  # *   The returned value is the largest multiple of the granularity
  #      that is less than or equal to `self`.
  # Examples with positive `self`:
  # ndigits|Granularity|12345.6789.floor(ndigits)
  # -------|-----------|-------------------------
  #       0|          1|                    12345
  #      -1|         10|                    12340
  #      -2|        100|                    12300
  #      -3|       1000|                    12000
  #      -4|      10000|                    10000
  #      -5|     100000|                        0
  # Examples with negative `self`:
  # ndigits|Granularity|-12345.6789.floor(ndigits)
  # -------|-----------|--------------------------
  #       0|          1|                    -12346
  #      -1|         10|                    -12350
  #      -2|        100|                    -12400
  #      -3|       1000|                    -13000
  #      -4|      10000|                    -20000
  #      -5|     100000|                   -100000
  #      -6|    1000000|                  -1000000
  # Note that the limited precision of floating-point arithmetic
  # may lead to surprising results:
  #     (0.3 / 0.1).floor  # => 2 # Not 3, (because (0.3 / 0.1) # => 2.9999999999999996, not 3.0)
  #
  # Related: Float#ceil.
  #
  def floor: () -> Integer
           | (int digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - infinite? -> -1, 1, or nil
  # -->
  # Returns:
  #
  # *   1, if `self` is `Infinity`.
  # *   -1 if `self` is `-Infinity`.
  # *   `nil`, otherwise.
  #
  # Examples:
  #
  #     f = 1.0/0.0  # => Infinity
  #     f.infinite?  # => 1
  #     f = -1.0/0.0 # => -Infinity
  #     f.infinite?  # => -1
  #     f = 1.0      # => 1.0
  #     f.infinite?  # => nil
  #     f = 0.0/0.0  # => NaN
  #     f.infinite?  # => nil
  #
  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  #         3.14.to_s         # => "3.14"
  #
  # *   A number in "scientific notation" (containing an exponent).
  #         (10.1**50).to_s   # => "1.644631821843879e+50"
  #
  # *   'Infinity'.
  #         (10.1**500).to_s  # => "Infinity"
  #
  # *   '-Infinity'.
  #         (-10.1**500).to_s # => "-Infinity"
  #
  # *   'NaN' (indicating not-a-number).
  #         (0.0/0.0).to_s    # => "NaN"
  #
  alias inspect to_s

  def integer?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  def modulo: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - nan? -> true or false
  # -->
  # Returns `true` if `self` is a NaN, `false` otherwise.
  #
  #     f = -1.0     #=> -1.0
  #     f.nan?       #=> false
  #     f = 0.0/0.0  #=> NaN
  #     f.nan?       #=> true
  #
  def nan?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - negative? -> true or false
  # -->
  # Returns `true` if `self` is less than 0, `false` otherwise.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - next_float -> float
  # -->
  # Returns the next-larger representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.next_float`:
  #
  #     f = 0.0      # 0x0000000000000000
  #     f.next_float # 0x0000000000000001
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.next_float # 0x3f847ae147ae147c
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.next_float    # => 0.010000000000000002
  #     1.0.next_float     # => 1.0000000000000002
  #     100.0.next_float   # => 100.00000000000001
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.next_float }
  #
  # Output:
  #
  #      0 0x1.47ae147ae147bp-7 0.01
  #      1 0x1.47ae147ae147cp-7 0.010000000000000002
  #      2 0x1.47ae147ae147dp-7 0.010000000000000004
  #      3 0x1.47ae147ae147ep-7 0.010000000000000005
  #
  #     f = 0.0; 100.times { f += 0.1 }
  #     f                           # => 9.99999999999998       # should be 10.0 in the ideal world.
  #     10-f                        # => 1.9539925233402755e-14 # the floating point error.
  #     10.0.next_float-10          # => 1.7763568394002505e-15 # 1 ulp (unit in the last place).
  #     (10-f)/(10.0.next_float-10) # => 11.0                   # the error is 11 ulp.
  #     (10-f)/(10*Float::EPSILON)  # => 8.8                    # approximation of the above.
  #     "%a" % 10                   # => "0x1.4p+3"
  #     "%a" % f                    # => "0x1.3fffffffffff5p+3" # the last hex digit is 5.  16 - 5 = 11 ulp.
  #
  # Related: Float#prev_float
  #
  def next_float: () -> Float

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - flo.numerator  ->  integer
  # -->
  # Returns the numerator.  The result is machine dependent.
  #
  #     n = 0.3.numerator    #=> 5404319552844595
  #     d = 0.3.denominator  #=> 18014398509481984
  #     n.fdiv(d)            #=> 0.3
  #
  # See also Float#denominator.
  #
  def numerator: () -> Integer

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if `self` is positive, Math::PI otherwise.
  #
  alias phase angle

  def polar: () -> [ Float, Integer | Float ]

  # <!--
  #   rdoc-file=numeric.rb
  #   - positive? -> true or false
  # -->
  # Returns `true` if `self` is greater than 0, `false` otherwise.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - float.prev_float  ->  float
  # -->
  # Returns the next-smaller representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.pev_float`:
  #
  #     f = 5e-324   # 0x0000000000000001
  #     f.prev_float # 0x0000000000000000
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.prev_float # 0x3f847ae147ae147a
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.prev_float   # => 0.009999999999999998
  #     1.0.prev_float    # => 0.9999999999999999
  #     100.0.prev_float  # => 99.99999999999999
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.prev_float }
  #
  # Output:
  #
  #     0 0x1.47ae147ae147bp-7 0.01
  #     1 0x1.47ae147ae147ap-7 0.009999999999999998
  #     2 0x1.47ae147ae1479p-7 0.009999999999999997
  #     3 0x1.47ae147ae1478p-7 0.009999999999999995
  #
  # Related: Float#next_float.
  #
  def prev_float: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - quo(other) -> numeric
  # -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  def quo: (Complex) -> Complex
         | (Numeric) -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flt.rationalize([eps])  ->  rational
  # -->
  # Returns a simpler approximation of the value (flt-|eps| <= result <=
  # flt+|eps|).  If the optional argument `eps` is not given, it will be chosen
  # automatically.
  #
  #     0.3.rationalize          #=> (3/10)
  #     1.333.rationalize        #=> (1333/1000)
  #     1.333.rationalize(0.01)  #=> (4/3)
  #
  # See also Float#to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Float

  def real?: () -> true

  def rect: () -> [ Float, Numeric ]

  alias rectangular rect

  def remainder: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits = 0, half: :up) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is non-negative, returns a float with `ndigits` after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.round(1) # => 12345.7
  #     f.round(3) # => 12345.679
  #     f = -12345.6789
  #     f.round(1) # => -12345.7
  #     f.round(3) # => -12345.679
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.round(0)  # => 12346
  #     f.round(-3) # => 12000
  #     f = -12345.6789
  #     f.round(0)  # => -12346
  #     f.round(-3) # => -12000
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         2.5.round(half: :up)      # => 3
  #         3.5.round(half: :up)      # => 4
  #         (-2.5).round(half: :up)   # => -3
  #
  # *   `:down`: round toward zero:
  #
  #         2.5.round(half: :down)    # => 2
  #         3.5.round(half: :down)    # => 3
  #         (-2.5).round(half: :down) # => -2
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         2.5.round(half: :even)    # => 2
  #         3.5.round(half: :even)    # => 4
  #         (-2.5).round(half: :even) # => -2
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Float#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  def step: (?Numeric limit, ?Numeric step) { (Float) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Float, self]
          | (?by: Numeric, ?to: Numeric) { (Float) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Float, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - to_f -> self
  # -->
  # Returns `self` (which is already a Float).
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - to_i -> integer
  # -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  def to_i: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - flt.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     2.0.to_r    #=> (2/1)
  #     2.5.to_r    #=> (5/2)
  #     -0.75.to_r  #=> (-3/4)
  #     0.0.to_r    #=> (0/1)
  #     0.3.to_r    #=> (5404319552844595/18014398509481984)
  #
  # NOTE: 0.3.to_r isn't the same as "0.3".to_r.  The latter is equivalent to
  # "3/10".to_r, but the former isn't so.
  #
  #     0.3.to_r   == 3/10r  #=> false
  #     "0.3".to_r == 3/10r  #=> true
  #
  # See also Float#rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s -> string
  # -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  #         3.14.to_s         # => "3.14"
  #
  # *   A number in "scientific notation" (containing an exponent).
  #         (10.1**50).to_s   # => "1.644631821843879e+50"
  #
  # *   'Infinity'.
  #         (10.1**500).to_s  # => "Infinity"
  #
  # *   '-Infinity'.
  #         (-10.1**500).to_s # => "-Infinity"
  #
  # *   'NaN' (indicating not-a-number).
  #         (0.0/0.0).to_s    # => "NaN"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> float or integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.truncate(1) # => 12345.6
  #     f.truncate(3) # => 12345.678
  #     f = -12345.6789
  #     f.truncate(1) # => -12345.6
  #     f.truncate(3) # => -12345.678
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.truncate(0)  # => 12345
  #     f.truncate(-3) # => 12000
  #     f = -12345.6789
  #     f.truncate(0)  # => -12345
  #     f.truncate(-3) # => -12000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).truncate  #=> 2 (!)
  #
  # Related: Float#round.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - zero? -> true or false
  # -->
  # Returns `true` if `self` is 0.0, `false` otherwise.
  #
  def zero?: () -> bool
end

# <!-- rdoc-file=numeric.c -->
# The minimum number of significant decimal digits in a double-precision
# floating point.
#
# Usually defaults to 15.
#
Float::DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The difference between 1 and the smallest double-precision floating point
# number greater than 1.
#
# Usually defaults to 2.2204460492503131e-16.
#
Float::EPSILON: Float

# <!-- rdoc-file=numeric.c -->
# An expression representing positive infinity.
#
Float::INFINITY: Float

Float::Infinity: Float

# <!-- rdoc-file=numeric.c -->
# The number of base digits for the `double` data type.
#
# Usually defaults to 53.
#
Float::MANT_DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible integer in a double-precision floating point number.
#
# Usually defaults to 1.7976931348623157e+308.
#
Float::MAX: Float

# <!-- rdoc-file=numeric.c -->
# The largest positive exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to 308.
#
Float::MAX_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible exponent value in a double-precision floating point.
#
# Usually defaults to 1024.
#
Float::MAX_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest positive normalized number in a double-precision floating point.
#
# Usually defaults to 2.2250738585072014e-308.
#
# If the platform supports denormalized numbers, there are numbers between zero
# and Float::MIN. 0.0.next_float returns the smallest positive floating point
# number including denormalized numbers.
#
Float::MIN: Float

# <!-- rdoc-file=numeric.c -->
# The smallest negative exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to -307.
#
Float::MIN_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest possible exponent value in a double-precision floating point.
#
# Usually defaults to -1021.
#
Float::MIN_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# An expression representing a value which is "not a number".
#
Float::NAN: Float

# <!-- rdoc-file=numeric.c -->
# The base of the floating point, or number of unique digits used to represent
# the number.
#
# Usually defaults to 2 on most systems, which would represent a base-10
# decimal.
#
Float::RADIX: Integer

# Deprecated, do not use.
#
# Represents the rounding mode for floating point addition at the start time.
#
# Usually defaults to 1, rounding to the nearest number.
#
# Other modes include:
#
# -1
# :   Indeterminable
# 0
# :   Rounding towards zero
# 1
# :   Rounding to the nearest number
# 2
# :   Rounding towards positive infinity
# 3
# :   Rounding towards negative infinity
#
#
Float::ROUNDS: Integer
# <!-- rdoc-file=hash.c -->
# `ENV` is a Hash-like accessor for environment variables.
#
# See ENV (the class) for more details.
#
ENV: RBS::Unnamed::ENVClass
# A type that's convertible to a `Complex`.
#
interface _ToC
  # Convert `self` to a `Complex`.
  #
  def to_c: () -> Complex
end

# A type that's convertible to a `Rational`.
#
interface _ToR
  # Convert `self` to a `Complex`.
  #
  def to_r: () -> Rational
end

# A type that's convertible to a `Float`.
#
interface _ToF
  # Convert `self` to a `Float`.
  #
  def to_f: () -> Float
end

# A type that's convertible to an `Integer`.
#
interface _ToI
  # Convert `self` to an `Integer`.
  #
  def to_i: () -> Integer
end

# A type that's implicitly convertible to an `Integer`.
#
# Implicit `.to_int` conversions are usable all over Ruby's stdlib, such as `Kernel#exit`,
# `File#chmod`, and `Array#take`. Virtually anywhere that accepts an `Integer` will also accept
# something that defines `.to_int`.
#
# Interestingly, types that define `.to_int` aren't immediately converted in math operations on
# `Integers` (eg `1 + defines_to_int`): Instead, `.coerce` must be defined on the right-hand-side
# value.
#
interface _ToInt
  # Converts `self` to an `Integer`.
  #
  def to_int: () -> Integer
end

# A type that's convertible to a `String`.
#
interface _ToS
  # Converts `self` to a `String`.
  #
  def to_s: () -> String
end

# A type that's implicitly convertible to a `String`.
#
# Implicit `.to_str` conversions are usable all over Ruby's stdlib, such as `Kernel#abort`,
# `String#+`, and `Object#send`. Virtually anywhere that accepts a `String` will also accept
# something that defines `.to_Str`.
#
# Types that define `.to_str` are also usable wherever paths are expected (See the `path` type
# alias).
#
interface _ToStr
  # Converts `self` to a `String`.
  #
  def to_str: () -> String
end

# A type that's explicitly convertible to a `String`.
#
# Interestingly enough, most methods that accept `Symbol` in the standard library _do not_ accept
# an object that defines `.to_sym` (unlike `String` and `.to_str`).
#
# There are only two places that `Symbol | _ToSym`, and they're quite obscure:
# - `Kernel#warn`'s `category:` optional parameter. (Oddly enough, not for  `Warning.warn`, though.)
# - `TracePoint#trace`'s `event`s parameter.
# Additionally, the `rb_iseq_load` C function, only accessible through `Fiddle`, uses `.to_sym`
# internally.
#
interface _ToSym
  # Converts `self` to a `Symbol`.
  #
  def to_sym: () -> Symbol
end

# A type that's convertible to a `Hash`.
#
interface _ToH[K, V]
  # Converts `self` to a `Hash`.
  #
  def to_h: () -> Hash[K, V]
end

# A type that's implicitly convertible to a `Hash`.
#
# Implicit `.to_hash` conversions are usable infrequently in Ruby's stdlib, such as `Io#popen`,
# `Kernel#sprintf`, and `Enumerable#tally`. It's also used with the `**` "splatsplat" operator.
#
interface _ToHash[K, V]
  # Converts `self` to a `Hash`.
  #
  def to_hash: () -> Hash[K, V]
end

# A type that's convertible to an `Array`.
#
interface _ToA[T]
  # Converts `self` to an `Array`.
  #
  def to_a: () -> Array[T]
end

# A type that's implicitly convertible to an `Array`.
#
# Implicit `.to_ary` conversions are usable semi-frequently in Ruby's stdlib, such as `Dir#glob`,
# `Regex#union`, and `Class#private`. It's also used with the `*` "splat" operator.
#
interface _ToAry[T]
  # Converts `self` to an `Array`.
  #
  def to_ary: () -> Array[T]
end

# A type that's convertible to a `Proc`.
#
# This is implicitly called when the `&` "block-passing" operator is used, in addition to a handful
# of other places, such as `Hash#default_proc=`.
#
interface _ToProc
  # Converts `self` to a `Proc.`
  #
  def to_proc: () -> Proc
end

# A type that's convertible to a `String` that contains a filepath.
#
# Implicit `.to_path` conversions are usable throughout Ruby's stdlib, whenever a file path is
# expected, such as `Dir#mkdir`, `File#open`, and `UNIXSocket#read`. These functions, however, also
# accept types that define `.to_str`. See the `path` type alias.
#
interface _ToPath
  # Converts `self` to a `String` containing a filepath.
  #
  def to_path: () -> String
end

# A type that's convertible to an `IO`.
#
# Implicit `.to_io` conversions are usuable infrequently in Ruby's stdlib, such as `IO#reopen`,
# `File.exist?`, and `Kernel#select`.
#
interface _ToIO
  # Converts `self` to an `IO` object.
  #
  def to_io: () -> IO
end

# A type that defines the `.inspect` method.
#
# Since `Object` defines `.inspect`, nearly every object in Ruby has it defined: Only those that
# derive from `BasicObject`, or `undef inspect` won't have it. It's used in a few locations,
# such as `Kernel#p` and `Array#join`.
#
interface _Inspect
  # Returns a debugging representation of `self`.
  #
  def inspect: () -> String
end

interface _Each[out E, out R = void]
  def each: () { (E) -> void } -> R
end

interface _EachEntry[out E]
  def each_entry: () { (E) -> void } -> self
end

interface _Reader
  def read: (?int? length, ?string outbuf) -> String?
end

interface _ReaderPartial
  def readpartial: (int maxlen, ?string outbuf) -> String
end

interface _Writer
  # Writes the +data+ string. Returns the number of bytes written
  #
  def write: (*_ToS data) -> Integer
end

interface _Rewindable
  # Positions the stream to the beginning of input, resetting `lineno` to zero.
  #
  def rewind: () -> Integer
end

# A type that's usable like a `Range[T]`.
#
# Implicit `_Range` usage is usable frequently in ruby's stdlib, such as `Comparable#clamp`,
# `String#[]`, and `Kernel#rand`.
#
interface _Range[T]
  # The beginning value, `nil` if there is no beginning.
  def begin: () -> T?

  # The ending value, `nil` if there is no ending.
  def end: () -> T?

  # Whether or not to include the end in the range.
  def exclude_end?: () -> bool
end

interface _Exception
  def exception: () -> Exception
               | (String arg0) -> Exception
end

# Represents an `Integer`, or a type convertible to it (via `.to_int`).
#
type int = Integer | _ToInt

# Represents a `Float`, or a type convertible to it (via `.to_f`).
#
type float = Float | _ToF

# Represents a `Range[T]`, or a type that acts like it (via `.begin`, `.end`, and `.exclude_end?`).
#
type range[T] = Range[T] | _Range[T]

# Represents a `String`, or a type convertible to it (via `.to_str`).
#
type string = String | _ToStr

# Represents an `Array[T]`, or a type convertible to it (via `.to_ary`).
#
type array[T] = Array[T] | _ToAry[T]

# Represents a `Hash[K, V]`, or a type convertible to it (via `.to_hash`).
#
type hash[K, V] = Hash[K, V] | _ToHash[K, V]

# Represents an `IO`, or a type convertible to it (via `.to_io`).
#
type io = IO | _ToIO

# A filesystem path: Either something that defines `.to_path`, or a `String` (or a type that is
# convertible to a string via `.to_str`).
#
# If a type defines both `.to_path` and `.to_str`, the `.to_path` function is called.
#
type path = string | _ToPath

# An `Encoding`, or a `String` (or type that defines `.to_str`) that represents it.
#
type encoding = Encoding | string

# A real number, ie not a `Complex`.
#
type real = Integer | Float | Rational

# Represents a `Symbol` or a `string`.
#
# A lot of builtin functions accept either a Symbol, a String, or something which has `.to_str`
# defined.
#
type interned = Symbol | string

# `boolish` is a type for documentation.
# It means the value of this type is only for testing a condition.
# Unlike `bool` type, it doesn't require the value is one of `true` or `false`.
# Any Ruby object can have `boolish` type.
#
type boolish = top
# <!-- rdoc-file=string.c -->
# A `Symbol` object represents a named identifier inside the Ruby interpreter.
#
# You can create a `Symbol` object explicitly with:
#
# *   A [symbol literal](rdoc-ref:syntax/literals.rdoc@Symbol+Literals).
#
# The same `Symbol` object will be created for a given name or string for the
# duration of a program's execution, regardless of the context or meaning of
# that name. Thus if `Fred` is a constant in one context, a method in another,
# and a class in a third, the `Symbol` `:Fred` will be the same object in all
# three contexts.
#
#     module One
#       class Fred
#       end
#       $f1 = :Fred
#     end
#     module Two
#       Fred = 1
#       $f2 = :Fred
#     end
#     def Fred()
#     end
#     $f3 = :Fred
#     $f1.object_id   #=> 2514190
#     $f2.object_id   #=> 2514190
#     $f3.object_id   #=> 2514190
#
# Constant, method, and variable names are returned as symbols:
#
#     module One
#       Two = 2
#       def three; 3 end
#       @four = 4
#       @@five = 5
#       $six = 6
#     end
#     seven = 7
#
#     One.constants
#     # => [:Two]
#     One.instance_methods(true)
#     # => [:three]
#     One.instance_variables
#     # => [:@four]
#     One.class_variables
#     # => [:@@five]
#     global_variables.grep(/six/)
#     # => [:$six]
#     local_variables
#     # => [:seven]
#
# A `Symbol` object differs from a String object in that a `Symbol` object
# represents an identifier, while a String object represents text or data.
#
# ## What's Here
#
# First, what's elsewhere. Class `Symbol`:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class `Symbol` provides methods that are useful for:
#
# *   [Querying](rdoc-ref:Symbol@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Symbol@Methods+for+Comparing)
# *   [Converting](rdoc-ref:Symbol@Methods+for+Converting)
#
# ### Methods for Querying
#
# *   ::all_symbols: Returns an array of the symbols currently in Ruby's symbol
#     table.
# *   #=~: Returns the index of the first substring in symbol that matches a
#     given Regexp or other object; returns `nil` if no match is found.
# *   #[], #slice : Returns a substring of symbol determined by a given index,
#     start/length, or range, or string.
# *   #empty?: Returns `true` if `self.length` is zero; `false` otherwise.
# *   #encoding: Returns the Encoding object that represents the encoding of
#     symbol.
# *   #end_with?: Returns `true` if symbol ends with any of the given strings.
# *   #match: Returns a MatchData object if symbol matches a given Regexp; `nil`
#     otherwise.
# *   #match?: Returns `true` if symbol matches a given Regexp; `false`
#     otherwise.
# *   #length, #size: Returns the number of characters in symbol.
# *   #start_with?: Returns `true` if symbol starts with any of the given
#     strings.
#
# ### Methods for Comparing
#
# *   #<=>: Returns -1, 0, or 1 as a given symbol is smaller than, equal to, or
#     larger than symbol.
# *   #==, #===: Returns `true` if a given symbol has the same content and
#     encoding.
# *   #casecmp: Ignoring case, returns -1, 0, or 1 as a given symbol is smaller
#     than, equal to, or larger than symbol.
# *   #casecmp?: Returns `true` if symbol is equal to a given symbol after
#     Unicode case folding; `false` otherwise.
#
# ### Methods for Converting
#
# *   #capitalize: Returns symbol with the first character upcased and all other
#     characters downcased.
# *   #downcase: Returns symbol with all characters downcased.
# *   #inspect: Returns the string representation of `self` as a symbol literal.
# *   #name: Returns the frozen string corresponding to symbol.
# *   #succ, #next: Returns the symbol that is the successor to symbol.
# *   #swapcase: Returns symbol with all upcase characters downcased and all
#     downcase characters upcased.
# *   #to_proc: Returns a Proc object which responds to the method named by
#     symbol.
# *   #to_s, #id2name: Returns the string corresponding to `self`.
# *   #to_sym, #intern: Returns `self`.
# *   #upcase: Returns symbol with all characters upcased.
#
class Symbol
  include Comparable

  # <!--
  #   rdoc-file=string.c
  #   - Symbol.all_symbols -> array_of_symbols
  # -->
  # Returns an array of all symbols currently in Ruby's symbol table:
  #
  #     Symbol.all_symbols.size    # => 9334
  #     Symbol.all_symbols.take(3) # => [:!, :"\"", :"#"]
  #
  def self.all_symbols: () -> Array[Symbol]

  # <!--
  #   rdoc-file=string.c
  #   - symbol <=> object -> -1, 0, +1, or nil
  # -->
  # If `object` is a symbol, returns the equivalent of `symbol.to_s <=>
  # object.to_s`:
  #
  #     :bar <=> :foo # => -1
  #     :foo <=> :foo # => 0
  #     :foo <=> :bar # => 1
  #
  # Otherwise, returns `nil`:
  #
  #     :foo <=> 'bar' # => nil
  #
  # Related: String#<=>.
  #
  def <=>: (Symbol object) -> (-1 | 0 | 1)
         | (untyped) -> (-1 | 0 | 1)?

  # <!--
  #   rdoc-file=string.c
  #   - symbol == object -> true or false
  # -->
  # Returns `true` if `object` is the same object as `self`, `false` otherwise.
  #
  def ==: (untyped object) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns `true` if `object` is the same object as `self`, `false` otherwise.
  #
  alias === ==

  # <!--
  #   rdoc-file=string.c
  #   - symbol =~ object -> integer or nil
  # -->
  # Equivalent to `symbol.to_s =~ object`, including possible updates to global
  # variables; see String#=~.
  #
  def =~: (Regexp regex) -> Integer?
        | [T] (String::_MatchAgainst[String, T] object) -> T

  # <!--
  #   rdoc-file=string.c
  #   - symbol[index] -> string or nil
  #   - symbol[start, length] -> string or nil
  #   - symbol[range] -> string or nil
  #   - symbol[regexp, capture = 0] -> string or nil
  #   - symbol[substring] -> string or nil
  # -->
  # Equivalent to `symbol.to_s[]`; see String#[].
  #
  def []: (int start, ?int length) -> String?
        | (range[int?] range) -> String?
        | (Regexp regexp, ?MatchData::capture backref) -> String?
        | (String substring) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.capitalize.to_sym`.
  #
  # See String#capitalize.
  #
  def capitalize: () -> Symbol
                | (:ascii | :lithuanian | :turkic) -> Symbol
                | (:lithuanian, :turkic) -> Symbol
                | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(object) -> -1, 0, 1, or nil
  # -->
  # Like Symbol#<=>, but case-insensitive; equivalent to
  # `self.to_s.casecmp(object.to_s)`:
  #
  #     lower = :abc
  #     upper = :ABC
  #     upper.casecmp(lower) # => 0
  #     lower.casecmp(lower) # => 0
  #     lower.casecmp(upper) # => 0
  #
  # Returns nil if `self` and `object` have incompatible encodings, or if `object`
  # is not a symbol:
  #
  #     sym = ''.encode("ISO-8859-1").to_sym
  #     other_sym = ''
  #     sym.casecmp(other_sym) # => nil
  #     :foo.casecmp(2)        # => nil
  #
  # Unlike Symbol#casecmp?, case-insensitivity does not work for characters
  # outside of 'A'..'Z' and 'a'..'z':
  #
  #     lower = :
  #     upper = :
  #     upper.casecmp(lower) # => -1
  #     lower.casecmp(lower) # => 0
  #     lower.casecmp(upper) # => 1
  #
  # Related: Symbol#casecmp?, String#casecmp.
  #
  def casecmp: (untyped object) -> (-1 | 0 | 1)?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(object) -> true, false, or nil
  # -->
  # Returns `true` if `self` and `object` are equal after Unicode case folding,
  # otherwise `false`:
  #
  #     lower = :abc
  #     upper = :ABC
  #     upper.casecmp?(lower) # => true
  #     lower.casecmp?(lower) # => true
  #     lower.casecmp?(upper) # => true
  #
  # Returns nil if `self` and `object` have incompatible encodings, or if `object`
  # is not a symbol:
  #
  #     sym = ''.encode("ISO-8859-1").to_sym
  #     other_sym = ''
  #     sym.casecmp?(other_sym) # => nil
  #     :foo.casecmp?(2)        # => nil
  #
  # Unlike Symbol#casecmp, works for characters outside of 'A'..'Z' and 'a'..'z':
  #
  #     lower = :
  #     upper = :
  #     upper.casecmp?(lower) # => true
  #     lower.casecmp?(lower) # => true
  #     lower.casecmp?(upper) # => true
  #
  # Related: Symbol#casecmp, String#casecmp?.
  #
  def casecmp?: (untyped object) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.downcase.to_sym`.
  #
  # See String#downcase.
  #
  # Related: Symbol#upcase.
  #
  def downcase: () -> Symbol
              | (:ascii | :fold | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - empty? -> true or false
  # -->
  # Returns `true` if `self` is `:''`, `false` otherwise.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - encoding -> encoding
  # -->
  # Equivalent to `self.to_s.encoding`; see String#encoding.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - end_with?(*strings) -> true or false
  # -->
  # Equivalent to `self.to_s.end_with?`; see String#end_with?.
  #
  def end_with?: (*string suffixes) -> bool

  # <!--
  #   rdoc-file=symbol.rb
  #   - id2name()
  # -->
  #
  alias id2name to_s

  # <!--
  #   rdoc-file=string.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self` (including the leading colon):
  #
  #     :foo.inspect # => ":foo"
  #
  # Related:  Symbol#to_s, Symbol#name.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=symbol.rb
  #   - intern()
  # -->
  #
  alias intern to_sym

  # <!--
  #   rdoc-file=string.c
  #   - length -> integer
  # -->
  # Equivalent to `self.to_s.length`; see String#length.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - match(pattern, offset = 0) -> matchdata or nil
  #   - match(pattern, offset = 0) {|matchdata| } -> object
  # -->
  # Equivalent to `self.to_s.match`, including possible updates to global
  # variables; see String#match.
  #
  def match: (Regexp | string pattern, ?int offset) -> MatchData?
           | [T] (Regexp | string pattern, ?int offset) { (MatchData matchdata) -> T } -> T?

  # <!--
  #   rdoc-file=string.c
  #   - match?(pattern, offset) -> true or false
  # -->
  # Equivalent to `sym.to_s.match?`; see String#match.
  #
  def match?: (Regexp | string pattern, ?int offset) -> bool

  # <!-- rdoc-file=string.c -->
  # Equivalent to `self.to_s.succ.to_sym`:
  #
  #     :foo.succ # => :fop
  #
  # Related: String#succ.
  #
  def next: () -> Symbol

  # <!--
  #   rdoc-file=symbol.rb
  #   - name -> string
  # -->
  # Returns a frozen string representation of `self` (not including the leading
  # colon):
  #
  #     :foo.name         # => "foo"
  #     :foo.name.frozen? # => true
  #
  # Related: Symbol#to_s, Symbol#inspect.
  #
  def name: () -> String

  # <!-- rdoc-file=string.c -->
  # Equivalent to `self.to_s.length`; see String#length.
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Equivalent to `symbol.to_s[]`; see String#[].
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - start_with?(*string_or_regexp) -> true or false
  # -->
  # Equivalent to `self.to_s.start_with?`; see String#start_with?.
  #
  def start_with?: (*Regexp | string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - succ
  # -->
  # Equivalent to `self.to_s.succ.to_sym`:
  #
  #     :foo.succ # => :fop
  #
  # Related: String#succ.
  #
  alias succ next

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.swapcase.to_sym`.
  #
  # See String#swapcase.
  #
  def swapcase: () -> Symbol
              | (:ascii | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - to_proc
  # -->
  # Returns a Proc object which calls the method with name of `self` on the first
  # parameter and passes the remaining parameters to the method.
  #
  #     proc = :to_s.to_proc   # => #<Proc:0x000001afe0e48680(&:to_s) (lambda)>
  #     proc.call(1000)        # => "1000"
  #     proc.call(1000, 16)    # => "3e8"
  #     (1..3).collect(&:to_s) # => ["1", "2", "3"]
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=symbol.rb
  #   - to_s -> string
  # -->
  # Returns a string representation of `self` (not including the leading colon):
  #
  #     :foo.to_s # => "foo"
  #
  # Related: Symbol#inspect, Symbol#name.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=symbol.rb
  #   - to_sym -> self
  # -->
  # Returns `self`.
  #
  # Related: String#to_sym.
  #
  def to_sym: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.upcase.to_sym`.
  #
  # See String#upcase.
  #
  def upcase: () -> Symbol
            | (:ascii | :lithuanian | :turkic) -> Symbol
            | (:lithuanian, :turkic) -> Symbol
            | (:turkic, :lithuanian) -> Symbol
end
# <!-- rdoc-file=file.c -->
# FileTest implements file test operations similar to those used in File::Stat.
# It exists as a standalone module, and its methods are also insinuated into the
# File class. (Note that this is not done by inclusion: the interpreter cheats).
#
module FileTest
  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a block device, `false` otherwise:
  #
  #     File.blockdev?('/dev/sda1')       # => true
  #     File.blockdev?(File.new('t.tmp')) # => false
  #
  def self?.blockdev?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a character device, `false` otherwise.
  #
  #     File.chardev?($stdin)     # => true
  #     File.chardev?('t.txt')     # => false
  #
  def self?.chardev?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(path) -> true or false
  # -->
  # With string `object` given, returns `true` if `path` is a string path leading
  # to a directory, or to a symbolic link to a directory; `false` otherwise:
  #
  #     File.directory?('.')              # => true
  #     File.directory?('foo')            # => false
  #     File.symlink('.', 'dirlink')      # => 0
  #     File.directory?('dirlink')        # => true
  #     File.symlink('t,txt', 'filelink') # => 0
  #     File.directory?('filelink')       # => false
  #
  # Argument `path` can be an IO object.
  #
  def self?.directory?: (path | io file_name) -> bool

  # <!-- rdoc-file=file.c -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  alias empty? zero?

  alias self.empty? self.zero?

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self?.executable?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self?.executable_real?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self?.exist?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self?.file?: (path | io file) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self?.grpowned?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self?.identical?: (path | io file_1, path | io file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self?.owned?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a pipe, `false` otherwise:
  #
  #     File.mkfifo('tmp/fifo')
  #     File.pipe?('tmp/fifo') # => true
  #     File.pipe?('t.txt')    # => false
  #
  def self?.pipe?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self?.readable?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self?.readable_real?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setgid?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setuid?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self?.size: (path | io file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self?.size?: (path | io file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(filepath)   ->  true or false
  # -->
  # Returns `true` if `filepath` points to a socket, `false` otherwise:
  #
  #     require 'socket'
  #     File.socket?(Socket.new(:INET, :STREAM)) # => true
  #     File.socket?(File.new('t.txt'))          # => false
  #
  def self?.socket?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.sticky?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a symbolic link, `false` otherwise:
  #
  #     symlink = File.symlink('t.txt', 'symlink')
  #     File.symlink?('symlink') # => true
  #     File.symlink?('t.txt')   # => false
  #
  def self?.symlink?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self?.world_readable?: (path | io file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self?.world_writable?: (path | io file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self?.writable?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self?.writable_real?: (path file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self?.zero?: (path | io file_name) -> bool
end
# The Exception object set by Kernel#raise.
$!: Exception?

# The array contains the module names loaded by require.
$": Array[String]

# The process number of the Ruby running this script. Same as Process.pid.
$$: Integer

# The string matched by the last successful match.
$&: String?

# The string to the right of the last successful match.
$': String?

# The same as ARGV.
$*: Array[String]

# The highest group matched by the last successful match.
$+: String?

# The output field separator for Kernel#print and Array#join. Non-nil $, will be deprecated.
$,: String?

# The input record separator, newline by default.
$-0: String?

# The default separator for String#split. Non-nil $; will be deprecated.
$-F: Regexp | String | nil

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$-I: Array[String]

$-W: 0 | 1 | 2

# True if option <tt>-a</tt> is set. Read-only variable.
$-a: bool

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output.
$-d: boolish

# In in-place-edit mode, this variable holds the extension, otherwise +nil+.
$-i: String?

# True if option <tt>-l</tt> is set. Read-only variable.
$-l: bool

# True if option <tt>-p</tt> is set. Read-only variable.
$-p: bool

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-v: bool?

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-w: bool?

# The current input line number of the last file that was read.
$.: Integer

# The input record separator, newline by default. Aliased to $-0.
$/: String?

# Contains the name of the script being executed. May be assignable.
$0: String

# The Nth group of the last successful match. May be > 1.
$1: String?

# The Nth group of the last successful match. May be > 1.
$2: String?

# The Nth group of the last successful match. May be > 1.
$3: String?

# The Nth group of the last successful match. May be > 1.
$4: String?

# The Nth group of the last successful match. May be > 1.
$5: String?

# The Nth group of the last successful match. May be > 1.
$6: String?

# The Nth group of the last successful match. May be > 1.
$7: String?

# The Nth group of the last successful match. May be > 1.
$8: String?

# The Nth group of the last successful match. May be > 1.
$9: String?

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$:: Array[String]

# The default separator for String#split. Non-nil $; will be deprecated. Aliased to $-F.
$;: Regexp | String | nil

# The same as ARGF.
$<: RBS::Unnamed::ARGFClass

# This variable is no longer effective. Deprecated.
$=: false

# The default output stream for Kernel#print and Kernel#printf. $stdout by default.
$>: IO

# The status of the last executed child process (thread-local).
$?: Process::Status?

# The same as <code>$!.backtrace</code>.
$@: Array[String]?

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output. Aliased to $-d.
$DEBUG: boolish

# Current input filename from ARGF. Same as ARGF.filename.
$FILENAME: String

# The array contains the module names loaded by require.
$LOADED_FEATURES: Array[String]

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require. Aliased to $: and $-I.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$LOAD_PATH: Array[String] & _LoadPathAPI

interface _LoadPathAPI
  def resolve_feature_path: (path feature_path) -> [:rb | :so, String]?
end

# Contains the name of the script being executed. May be assignable.
$PROGRAM_NAME: String

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn. Aliased to $-v and $-w.
$VERBOSE: bool?

# The output record separator for Kernel#print and IO#write. Default is +nil+.
$\: String?

# The last input line of string by gets or readline.
$_: String?

# The string to the left of the last successful match.
$`: String?

# The current standard error output.
$stderr: IO

# The current standard input.
$stdin: IO

# The current standard output.
$stdout: IO

# The information about the last match in the current scope (thread-local and frame-local).
$~: MatchData?
# <!-- rdoc-file=range.c -->
# A Range object represents a collection of values that are between given begin
# and end values.
#
# You can create an Range object explicitly with:
#
# *   A [range literal](rdoc-ref:syntax/literals.rdoc@Range+Literals):
#
#         # Ranges that use '..' to include the given end value.
#         (1..4).to_a      # => [1, 2, 3, 4]
#         ('a'..'d').to_a  # => ["a", "b", "c", "d"]
#         # Ranges that use '...' to exclude the given end value.
#         (1...4).to_a     # => [1, 2, 3]
#         ('a'...'d').to_a # => ["a", "b", "c"]
#
# *   Method Range.new:
#
#     # Ranges that by default include the given end value. Range.new(1, 4).to_a
#         # => [1, 2, 3, 4] Range.new('a', 'd').to_a # => ["a", "b", "c", "d"] #
#     Ranges that use third argument `exclude_end` to exclude the given end
#     value. Range.new(1, 4, true).to_a     # => [1, 2, 3] Range.new('a', 'd',
#     true).to_a # => ["a", "b", "c"]
#
# ## Beginless Ranges
#
# A *beginless* *range* has a definite end value, but a `nil` begin value. Such
# a range includes all values up to the end value.
#
#     r = (..4)               # => nil..4
#     r.begin                 # => nil
#     r.include?(-50)         # => true
#     r.include?(4)           # => true
#
#     r = (...4)              # => nil...4
#     r.include?(4)           # => false
#
#     Range.new(nil, 4)       # => nil..4
#     Range.new(nil, 4, true) # => nil...4
#
# A beginless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     # Include the third array element in the slice
#     r = (..2)  # => nil..2
#     a[r]       # => [1, 2, 3]
#     # Exclude the third array element from the slice
#     r = (...2) # => nil...2
#     a[r]       # => [1, 2]
#
# Method `each` for a beginless range raises an exception.
#
# ## Endless Ranges
#
# An *endless* *range* has a definite begin value, but a `nil` end value. Such a
# range includes all values from the begin value.
#
#     r = (1..)         # => 1..
#     r.end             # => nil
#     r.include?(50)    # => true
#
#     Range.new(1, nil) # => 1..
#
# The literal for an endless range may be written with either two dots or three.
# The range has the same elements, either way. But note that the two are not
# equal:
#
#     r0 = (1..)           # => 1..
#     r1 = (1...)          # => 1...
#     r0.begin == r1.begin # => true
#     r0.end == r1.end     # => true
#     r0 == r1             # => false
#
# An endless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     r = (2..) # => 2..
#     a[r]      # => [3, 4]
#
# Method `each` for an endless range calls the given block indefinitely:
#
#     a = []
#     r = (1..)
#     r.each do |i|
#       a.push(i) if i.even?
#       break if i > 10
#     end
#     a # => [2, 4, 6, 8, 10]
#
# A range can be both beginless and endless.  For literal beginless, endless
# ranges, at least the beginning or end of the range must be given as an
# explicit nil value. It is recommended to use an explicit nil beginning and
# implicit nil end, since that is what Ruby uses for Range#inspect:
#
#     (nil..)    # => (nil..)
#     (..nil)    # => (nil..)
#     (nil..nil) # => (nil..)
#
# ## Ranges and Other Classes
#
# An object may be put into a range if its class implements instance method
# `#<=>`. Ruby core classes that do so include Array, Complex, File::Stat,
# Float, Integer, Kernel, Module, Numeric, Rational, String, Symbol, and Time.
#
# Example:
#
#     t0 = Time.now         # => 2021-09-19 09:22:48.4854986 -0500
#     t1 = Time.now         # => 2021-09-19 09:22:56.0365079 -0500
#     t2 = Time.now         # => 2021-09-19 09:23:08.5263283 -0500
#     (t0..t2).include?(t1) # => true
#     (t0..t1).include?(t2) # => false
#
# A range can be iterated over only if its elements implement instance method
# `succ`. Ruby core classes that do so include Integer, String, and Symbol (but
# not the other classes mentioned above).
#
# Iterator methods include:
#
# *   In Range itself: #each, #step, and #%
# *   Included from module Enumerable: #each_entry, #each_with_index,
#     #each_with_object, #each_slice, #each_cons, and #reverse_each.
#
# Example:
#
#     a = []
#     (1..4).each {|i| a.push(i) }
#     a # => [1, 2, 3, 4]
#
# ## Ranges and User-Defined Classes
#
# A user-defined class that is to be used in a range must implement instance
# method `#<=>`; see Integer#<=>. To make iteration available, it must also
# implement instance method `succ`; see Integer#succ.
#
# The class below implements both `#<=>` and `succ`, and so can be used both to
# construct ranges and to iterate over them. Note that the Comparable module is
# included so the `==` method is defined in terms of `#<=>`.
#
#     # Represent a string of 'X' characters.
#     class Xs
#       include Comparable
#       attr_accessor :length
#       def initialize(n)
#         @length = n
#       end
#       def succ
#         Xs.new(@length + 1)
#       end
#       def <=>(other)
#         @length <=> other.length
#       end
#       def to_s
#         sprintf "%2d #{inspect}", @length
#       end
#       def inspect
#         'X' * @length
#       end
#     end
#
#     r = Xs.new(3)..Xs.new(6) #=> XXX..XXXXXX
#     r.to_a                   #=> [XXX, XXXX, XXXXX, XXXXXX]
#     r.include?(Xs.new(5))    #=> true
#     r.include?(Xs.new(7))    #=> false
#
# ## What's Here
#
# First, what's elsewhere. Class Range:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# Here, class Range provides methods that are useful for:
#
# *   [Creating a Range](rdoc-ref:Range@Methods+for+Creating+a+Range)
# *   [Querying](rdoc-ref:Range@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Range@Methods+for+Comparing)
# *   [Iterating](rdoc-ref:Range@Methods+for+Iterating)
# *   [Converting](rdoc-ref:Range@Methods+for+Converting)
# *   [Methods for Working with
#     JSON](rdoc-ref:Range@Methods+for+Working+with+JSON)
#
# ### Methods for Creating a Range
#
# *   ::new: Returns a new range.
#
# ### Methods for Querying
#
# *   #begin: Returns the begin value given for `self`.
# *   #bsearch: Returns an element from `self` selected by a binary search.
# *   #count: Returns a count of elements in `self`.
# *   #end: Returns the end value given for `self`.
# *   #exclude_end?: Returns whether the end object is excluded.
# *   #first: Returns the first elements of `self`.
# *   #hash: Returns the integer hash code.
# *   #last: Returns the last elements of `self`.
# *   #max: Returns the maximum values in `self`.
# *   #min: Returns the minimum values in `self`.
# *   #minmax: Returns the minimum and maximum values in `self`.
# *   #size: Returns the count of elements in `self`.
#
# ### Methods for Comparing
#
# *   #==: Returns whether a given object is equal to `self` (uses #==).
# *   #===: Returns whether the given object is between the begin and end
#     values.
# *   #cover?: Returns whether a given object is within `self`.
# *   #eql?: Returns whether a given object is equal to `self` (uses #eql?).
# *   #include? (aliased as #member?): Returns whether a given object is an
#     element of `self`.
#
# ### Methods for Iterating
#
# *   #%: Requires argument `n`; calls the block with each `n`-th element of
#     `self`.
# *   #each: Calls the block with each element of `self`.
# *   #step: Takes optional argument `n` (defaults to 1); calls the block with
#     each `n`-th element of `self`.
#
# ### Methods for Converting
#
# *   #inspect: Returns a string representation of `self` (uses #inspect).
# *   #to_a (aliased as #entries): Returns elements of `self` in an array.
# *   #to_s: Returns a string representation of `self` (uses #to_s).
#
# ### Methods for Working with JSON
#
# *   ::json_create: Returns a new Range object constructed from the given
#     object.
# *   #as_json: Returns a 2-element hash representing `self`.
# *   #to_json: Returns a JSON string representing `self`.
#
# To make these methods available:
#
#     require 'json/add/range'
#
class Range[out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - %(n) {|element| ... } -> self
  #   - %(n)                  -> enumerator or arithmetic_sequence
  # -->
  # Same as #step (but doesn't provide default value for `n`). The method is
  # convenient for experssive producing of Enumerator::ArithmeticSequence.
  #
  #     array = [0, 1, 2, 3, 4, 5, 6]
  #
  #     # slice each second element:
  #     seq = (0..) % 2 #=> ((0..).%(2))
  #     array[seq] #=> [0, 2, 4, 6]
  #     # or just
  #     array[(0..) % 2] #=> [0, 2, 4, 6]
  #
  # Note that due to operator precedence in Ruby, parentheses are mandatory around
  # range in this case:
  #
  #     (0..7) % 2 #=> ((0..7).%(2)) -- as expected
  #     0..7 % 2 #=> 0..1 -- parsed as 0..(7 % 2)
  #
  def %: (Numeric | int n) -> Enumerator[Elem, self]
       | (Numeric | int n) { (Elem element) -> void } -> self

  # <!--
  #   rdoc-file=range.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin == self.begin`.
  # *   `other.end == self.end`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r == (1..5)                # => true
  #     r = Range.new(1, 5)
  #     r == 'foo'                 # => false
  #     r == (2..5)                # => false
  #     r == (1..4)                # => false
  #     r == (1...5)               # => false
  #     r == Range.new(1, 5, true) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#eql?.
  #
  def ==: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self === object ->  true or false
  # -->
  # Returns `true` if `object` is between `self.begin` and `self.end`. `false`
  # otherwise:
  #
  #     (1..4) === 2       # => true
  #     (1..4) === 5       # => false
  #     (1..4) === 'a'     # => false
  #     (1..4) === 4       # => true
  #     (1...4) === 4      # => false
  #     ('a'..'d') === 'c' # => true
  #     ('a'..'d') === 'e' # => false
  #
  # A case statement uses method `===`, and so:
  #
  #     case 79
  #     when (1..50)
  #       "low"
  #     when (51..75)
  #       "medium"
  #     when (76..100)
  #       "high"
  #     end # => "high"
  #
  #     case "2.6.5"
  #     when ..."2.4"
  #       "EOL"
  #     when "2.4"..."2.5"
  #       "maintenance"
  #     when "2.5"..."3.0"
  #       "stable"
  #     when "3.1"..
  #       "upcoming"
  #     end # => "stable"
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self.begin -> object
  # -->
  # Returns the object that defines the beginning of `self`.
  #
  #     (1..4).begin # => 1
  #     (..2).begin  # => nil
  #
  # Related: Range#first, Range#end.
  #
  def begin: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - bsearch {|obj| block }  -> value
  # -->
  # Returns an element from `self` selected by a binary search.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=range.c
  #   - cover?(object) -> true or false
  #   - cover?(range) -> true or false
  # -->
  # Returns `true` if the given argument is within `self`, `false` otherwise.
  #
  # With non-range argument `object`, evaluates with `<=` and `<`.
  #
  # For range `self` with included end value (`#exclude_end? == false`), evaluates
  # thus:
  #
  #     self.begin <= object <= self.end
  #
  # Examples:
  #
  #     r = (1..4)
  #     r.cover?(1)     # => true
  #     r.cover?(4)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(5)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'..'d')
  #     r.cover?('a')     # => true
  #     r.cover?('d')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('e')     # => false
  #     r.cover?(0)       # => false
  #
  # For range `r` with excluded end value (`#exclude_end? == true`), evaluates
  # thus:
  #
  #     r.begin <= object < r.end
  #
  # Examples:
  #
  #     r = (1...4)
  #     r.cover?(1)     # => true
  #     r.cover?(3)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(4)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'...'d')
  #     r.cover?('a')     # => true
  #     r.cover?('c')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('d')     # => false
  #     r.cover?(0)       # => false
  #
  # With range argument `range`, compares the first and last elements of `self`
  # and `range`:
  #
  #     r = (1..4)
  #     r.cover?(1..4)     # => true
  #     r.cover?(0..4)     # => false
  #     r.cover?(1..5)     # => false
  #     r.cover?('a'..'d') # => false
  #
  #     r = (1...4)
  #     r.cover?(1..3)     # => true
  #     r.cover?(1..4)     # => false
  #
  # If begin and end are numeric, #cover? behaves like #include?
  #
  #     (1..3).cover?(1.5) # => true
  #     (1..3).include?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').cover?('cc')   # => true
  #     ('a'..'d').include?('cc') # => false
  #
  # Returns `false` if either:
  #
  # *   The begin value of `self` is larger than its end value.
  # *   An internal call to `#<=>` returns `nil`; that is, the operands are not
  #     comparable.
  #
  # Beginless ranges cover all values of the same type before the end, excluding
  # the end for exclusive ranges. Beginless ranges cover ranges that end before
  # the end of the beginless range, or at the end of the beginless range for
  # inclusive ranges.
  #
  #     (..2).cover?(1)     # => true
  #     (..2).cover?(2)     # => true
  #     (..2).cover?(3)     # => false
  #     (...2).cover?(2)    # => false
  #     (..2).cover?("2")   # => false
  #     (..2).cover?(..2)   # => true
  #     (..2).cover?(...2)  # => true
  #     (..2).cover?(.."2") # => false
  #     (...2).cover?(..2)  # => false
  #
  # Endless ranges cover all values of the same type after the beginning. Endless
  # exclusive ranges do not cover endless inclusive ranges.
  #
  #     (2..).cover?(1)     # => false
  #     (2..).cover?(3)     # => true
  #     (2...).cover?(3)    # => true
  #     (2..).cover?(2)     # => true
  #     (2..).cover?("2")   # => false
  #     (2..).cover?(2..)   # => true
  #     (2..).cover?(2...)  # => true
  #     (2..).cover?("2"..) # => false
  #     (2...).cover?(2..)  # => false
  #     (2...).cover?(3...) # => true
  #     (2...).cover?(3..)  # => false
  #     (3..).cover?(2..)   # => false
  #
  # Ranges that are both beginless and endless cover all values and ranges, and
  # return true for all arguments, with the exception that beginless and endless
  # exclusive ranges do not cover endless inclusive ranges.
  #
  #     (nil...).cover?(Object.new) # => true
  #     (nil...).cover?(nil...)     # => true
  #     (nil..).cover?(nil...)      # => true
  #     (nil...).cover?(nil..)      # => false
  #     (nil...).cover?(1..)        # => false
  #
  # Related: Range#include?.
  #
  def cover?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - each {|element| ... } -> self
  #   - each                  -> an_enumerator
  # -->
  # With a block given, passes each element of `self` to the block:
  #
  #     a = []
  #     (1..4).each {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  # Raises an exception unless `self.first.respond_to?(:succ)`.
  #
  # With no block given, returns an enumerator.
  #
  def each: () { (Elem arg0) -> untyped } -> self
          | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=range.c
  #   - self.end -> object
  # -->
  # Returns the object that defines the end of `self`.
  #
  #     (1..4).end  # => 4
  #     (1...4).end # => 4
  #     (1..).end   # => nil
  #
  # Related: Range#begin, Range#last.
  #
  def end: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - exclude_end? -> true or false
  # -->
  # Returns `true` if `self` excludes its end value; `false` otherwise:
  #
  #     Range.new(2, 5).exclude_end?       # => false
  #     Range.new(2, 5, true).exclude_end? # => true
  #     (2..5).exclude_end?                # => false
  #     (2...5).exclude_end?               # => true
  #
  def exclude_end?: () -> bool

  # <!--
  #   rdoc-file=range.c
  #   - first -> object
  #   - first(n) -> array
  # -->
  # With no argument, returns the first element of `self`, if it exists:
  #
  #     (1..4).first     # => 1
  #     ('a'..'d').first # => "a"
  #
  # With non-negative integer argument `n` given, returns the first `n` elements
  # in an array:
  #
  #     (1..10).first(3) # => [1, 2, 3]
  #     (1..10).first(0) # => []
  #     (1..4).first(50) # => [1, 2, 3, 4]
  #
  # Raises an exception if there is no first element:
  #
  #     (..4).first # Raises RangeError
  #
  def first: () -> Elem
           | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. Two range objects `r0` and `r1`
  # have the same hash value if and only if `r0.eql?(r1)`.
  #
  # Related: Range#eql?, Object#hash.
  #
  def hash: () -> Integer

  # <!-- rdoc-file=range.c -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  def include?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - Range.new(begin, end, exclude_end = false) -> new_range
  # -->
  # Returns a new range based on the given objects `begin` and `end`. Optional
  # argument `exclude_end` determines whether object `end` is included as the last
  # object in the range:
  #
  #     Range.new(2, 5).to_a            # => [2, 3, 4, 5]
  #     Range.new(2, 5, true).to_a      # => [2, 3, 4]
  #     Range.new('a', 'd').to_a        # => ["a", "b", "c", "d"]
  #     Range.new('a', 'd', true).to_a  # => ["a", "b", "c"]
  #
  def initialize: (Elem from, Elem to, ?boolish exclude_end) -> void

  # <!--
  #   rdoc-file=range.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`, including `begin.inspect` and
  # `end.inspect`:
  #
  #     (1..4).inspect  # => "1..4"
  #     (1...4).inspect # => "1...4"
  #     (1..).inspect   # => "1.."
  #     (..4).inspect   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#to_s.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - last -> object
  #   - last(n) -> array
  # -->
  # With no argument, returns the last element of `self`, if it exists:
  #
  #     (1..4).last     # => 4
  #     ('a'..'d').last # => "d"
  #
  # Note that `last` with no argument returns the end element of `self` even if
  # #exclude_end? is `true`:
  #
  #     (1...4).last     # => 4
  #     ('a'...'d').last # => "d"
  #
  # With non-negative integer argument `n` given, returns the last `n` elements in
  # an array:
  #
  #     (1..10).last(3) # => [8, 9, 10]
  #     (1..10).last(0) # => []
  #     (1..4).last(50) # => [1, 2, 3, 4]
  #
  # Note that `last` with argument does not return the end element of `self` if
  # #exclude_end? it `true`:
  #
  #     (1...4).last(3)     # => [1, 2, 3]
  #     ('a'...'d').last(3) # => ["a", "b", "c"]
  #
  # Raises an exception if there is no last element:
  #
  #     (1..).last # Raises RangeError
  #
  def last: () -> Elem
          | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - max -> object
  #   - max(n) -> array
  #   - max {|a, b| ... } -> object
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the maximum value in `self`, using method `#<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the maximum-valued element of
  # `self`.
  #
  #     (1..4).max     # => 4
  #     ('a'..'d').max # => "d"
  #     (-4..-1).max   # => -1
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` maximum-valued elements of `self` in an array:
  #
  #     (1..4).max(2)     # => [4, 3]
  #     ('a'..'d').max(2) # => ["d", "c"]
  #     (-4..-1).max(2)   # => [-1, -2]
  #     (1..4).max(50)    # => [4, 3, 2, 1]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far maximum value and the next element of
  #     `self`.
  #
  # To illustrate:
  #
  #     (1..4).max {|a, b| p [a, b]; a <=> b } # => 4
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 2]
  #     [4, 3]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).max {|a, b| -(a <=> b) } # => 1
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).max(2) {|a, b| -(a <=> b) }  # => [1, 2]
  #     (1..4).max(50) {|a, b| -(a <=> b) } # => [1, 2, 3, 4]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).max(0)                      # => []
  #     (1..4).max(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).max                         # => nil
  #         (4..1).max(2)                      # => []
  #         (4..1).max {|a, b| -(a <=> b) }    # => nil
  #         (4..1).max(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).max                          # => nil
  #         (1...1).max(2)                       # => []
  #         (1...1).max  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).max(2)  {|a, b| -(a <=> b) } # => []
  #
  # Raises an exception if either:
  #
  # *   `self` is a endless range: `(1..)`.
  # *   A block is given and `self` is a beginless range.
  #
  # Related: Range#min, Range#minmax.
  #
  def max: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - min -> object
  #   - min(n) -> array
  #   - min {|a, b| ... } -> object
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the minimum value in `self`, using method `#<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the minimum-valued element of
  # `self`.
  #
  #     (1..4).min     # => 1
  #     ('a'..'d').min # => "a"
  #     (-4..-1).min   # => -4
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` minimum-valued elements of `self` in an array:
  #
  #     (1..4).min(2)     # => [1, 2]
  #     ('a'..'d').min(2) # => ["a", "b"]
  #     (-4..-1).min(2)   # => [-4, -3]
  #     (1..4).min(50)    # => [1, 2, 3, 4]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far minimum value and the next element of
  #     `self`.
  #
  # To illustrate:
  #
  #     (1..4).min {|a, b| p [a, b]; a <=> b } # => 1
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 1]
  #     [4, 1]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).min {|a, b| -(a <=> b) } # => 4
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).min(2) {|a, b| -(a <=> b) }  # => [4, 3]
  #     (1..4).min(50) {|a, b| -(a <=> b) } # => [4, 3, 2, 1]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).min(0)                      # => []
  #     (1..4).min(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).min                         # => nil
  #         (4..1).min(2)                      # => []
  #         (4..1).min {|a, b| -(a <=> b) }    # => nil
  #         (4..1).min(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).min                          # => nil
  #         (1...1).min(2)                       # => []
  #         (1...1).min  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).min(2)  {|a, b| -(a <=> b) } # => []
  #
  # Raises an exception if either:
  #
  # *   `self` is a beginless range: `(..4)`.
  # *   A block is given and `self` is an endless range.
  #
  # Related: Range#max, Range#minmax.
  #
  def min: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - overlap?(range) -> true or false
  # -->
  # Returns `true` if `range` overlaps with `self`, `false` otherwise:
  #
  #     (0..2).overlap?(1..3) #=> true
  #     (0..2).overlap?(3..4) #=> false
  #     (0..).overlap?(..0)   #=> true
  #
  # With non-range argument, raises TypeError.
  #
  #     (1..3).overlap?(1)         # TypeError
  #
  # Returns `false` if an internal call to `#<=>` returns `nil`; that is, the
  # operands are not comparable.
  #
  #     (1..3).overlap?('a'..'d')  # => false
  #
  # Returns `false` if `self` or `range` is empty. "Empty range" means that its
  # begin value is larger than, or equal for an exclusive range, its end value.
  #
  #     (4..1).overlap?(2..3)      # => false
  #     (4..1).overlap?(..3)       # => false
  #     (4..1).overlap?(2..)       # => false
  #     (2...2).overlap?(1..2)     # => false
  #
  #     (1..4).overlap?(3..2)      # => false
  #     (..4).overlap?(3..2)       # => false
  #     (1..).overlap?(3..2)       # => false
  #     (1..2).overlap?(2...2)     # => false
  #
  # Returns `false` if the begin value one of `self` and `range` is larger than,
  # or equal if the other is an exclusive range, the end value of the other:
  #
  #     (4..5).overlap?(2..3)      # => false
  #     (4..5).overlap?(2...4)     # => false
  #
  #     (1..2).overlap?(3..4)      # => false
  #     (1...3).overlap?(3..4)     # => false
  #
  # Returns `false` if the end value one of `self` and `range` is larger than, or
  # equal for an exclusive range, the end value of the other:
  #
  #     (4..5).overlap?(2..3)      # => false
  #     (4..5).overlap?(2...4)     # => false
  #
  #     (1..2).overlap?(3..4)      # => false
  #     (1...3).overlap?(3..4)     # => false
  #
  # Note that the method wouldn't make any assumptions about the beginless range
  # being actually empty, even if its upper bound is the minimum possible value of
  # its type, so all this would return `true`:
  #
  #     (...-Float::INFINITY).overlap?(...-Float::INFINITY) # => true
  #     (..."").overlap?(..."") # => true
  #     (...[]).overlap?(...[]) # => true
  #
  # Even if those ranges are effectively empty (no number can be smaller than
  # `-Float::INFINITY`), they are still considered overlapping with themselves.
  #
  # Related: Range#cover?.
  #
  def overlap?: (Range[untyped]) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - reverse_each {|element| ... } -> self
  #   - reverse_each                  -> an_enumerator
  # -->
  # With a block given, passes each element of `self` to the block in reverse
  # order:
  #
  #     a = []
  #     (1..4).reverse_each {|element| a.push(element) } # => 1..4
  #     a # => [4, 3, 2, 1]
  #
  #     a = []
  #     (1...4).reverse_each {|element| a.push(element) } # => 1...4
  #     a # => [3, 2, 1]
  #
  # With no block given, returns an enumerator.
  #
  def reverse_each: () { (Elem) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=range.c
  #   - size -> non_negative_integer or Infinity or nil
  # -->
  # Returns the count of elements in `self` if both begin and end values are
  # numeric; otherwise, returns `nil`:
  #
  #     (1..4).size      # => 4
  #     (1...4).size     # => 3
  #     (1..).size       # => Infinity
  #     ('a'..'z').size  # => nil
  #
  # If `self` is not iterable, raises an exception:
  #
  #     (0.5..2.5).size  # TypeError
  #     (..1).size       # TypeError
  #
  # Related: Range#count.
  #
  def size: () -> Integer?
          | () -> Float?

  # <!--
  #   rdoc-file=range.c
  #   - step(s = 1) {|element| ... } -> self
  #   - step(s = 1)                  -> enumerator/arithmetic_sequence
  # -->
  # Iterates over the elements of range in steps of `s`. The iteration is
  # performed by `+` operator:
  #
  #     (0..6).step(2) { puts _1 } #=> 1..5
  #     # Prints: 0, 2, 4, 6
  #
  #     # Iterate between two dates in step of 1 day (24 hours)
  #     (Time.utc(2022, 2, 24)..Time.utc(2022, 3, 1)).step(24*60*60) { puts _1 }
  #     # Prints:
  #     #   2022-02-24 00:00:00 UTC
  #     #   2022-02-25 00:00:00 UTC
  #     #   2022-02-26 00:00:00 UTC
  #     #   2022-02-27 00:00:00 UTC
  #     #   2022-02-28 00:00:00 UTC
  #     #   2022-03-01 00:00:00 UTC
  #
  # If ` + step` decreases the value, iteration is still performed when step
  # `begin` is higher than the `end`:
  #
  #     (0..6).step(-2) { puts _1 }
  #     # Prints nothing
  #
  #     (6..0).step(-2) { puts _1 }
  #     # Prints: 6, 4, 2, 0
  #
  #     (Time.utc(2022, 3, 1)..Time.utc(2022, 2, 24)).step(-24*60*60) { puts _1 }
  #     # Prints:
  #     #   2022-03-01 00:00:00 UTC
  #     #   2022-02-28 00:00:00 UTC
  #     #   2022-02-27 00:00:00 UTC
  #     #   2022-02-26 00:00:00 UTC
  #     #   2022-02-25 00:00:00 UTC
  #     #   2022-02-24 00:00:00 UTC
  #
  # When the block is not provided, and range boundaries and step are Numeric, the
  # method returns Enumerator::ArithmeticSequence.
  #
  #     (1..5).step(2) # => ((1..5).step(2))
  #     (1.0..).step(1.5) #=> ((1.0..).step(1.5))
  #     (..3r).step(1/3r) #=> ((..3/1).step((1/3)))
  #
  # Enumerator::ArithmeticSequence can be further used as a value object for
  # iteration or slicing of collections (see Array#[]). There is a convenience
  # method #% with behavior similar to `step` to produce arithmetic sequences more
  # expressively:
  #
  #     # Same as (1..5).step(2)
  #     (1..5) % 2 # => ((1..5).%(2))
  #
  # In a generic case, when the block is not provided, Enumerator is returned:
  #
  #     ('a'..).step('b')         #=> #<Enumerator: "a"..:step("b")>
  #     ('a'..).step('b').take(3) #=> ["a", "ab", "abb"]
  #
  # If `s` is not provided, it is considered `1` for ranges with numeric `begin`:
  #
  #     (1..5).step { p _1 }
  #     # Prints: 1, 2, 3, 4, 5
  #
  # For non-Numeric ranges, step absence is an error:
  #
  #     (Time.utc(2022, 3, 1)..Time.utc(2022, 2, 24)).step { p _1 }
  #     # raises: step is required for non-numeric ranges (ArgumentError)
  #
  # For backward compatibility reasons, String ranges support the iteration both
  # with string step and with integer step. In the latter case, the iteration is
  # performed by calculating the next values with String#succ:
  #
  #     ('a'..'e').step(2) { p _1 }
  #     # Prints: a, c, e
  #     ('a'..'e').step { p _1 }
  #     # Default step 1; prints: a, b, c, d, e
  #
  def step: (?Numeric | int) -> Enumerator[Elem, self]
          | (?Numeric | int) { (Elem element) -> void } -> self
          | (untyped) -> Enumerator[Elem, self]
          | (untyped) { (Elem element) -> void } -> self

  # <!--
  #   rdoc-file=range.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`, including `begin.to_s` and
  # `end.to_s`:
  #
  #     (1..4).to_s  # => "1..4"
  #     (1...4).to_s # => "1...4"
  #     (1..).to_s   # => "1.."
  #     (..4).to_s   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#inspect.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin.eql?(self.begin)`.
  # *   `other.end.eql?(self.end)`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r.eql?(1..5)                  # => true
  #     r = Range.new(1, 5)
  #     r.eql?('foo')                 # => false
  #     r.eql?(2..5)                  # => false
  #     r.eql?(1..4)                  # => false
  #     r.eql?(1...5)                 # => false
  #     r.eql?(Range.new(1, 5, true)) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#==.
  #
  def eql?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - include?(object) -> true or false
  # -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  def member?: (untyped obj) -> bool
end
# <!-- rdoc-file=proc.c -->
# Objects of class Binding encapsulate the execution context at some particular
# place in the code and retain this context for future use. The variables,
# methods, value of `self`, and possibly an iterator block that can be accessed
# in this context are all retained. Binding objects can be created using
# Kernel#binding, and are made available to the callback of
# Kernel#set_trace_func and instances of TracePoint.
#
# These binding objects can be passed as the second argument of the Kernel#eval
# method, establishing an environment for the evaluation.
#
#     class Demo
#       def initialize(n)
#         @secret = n
#       end
#       def get_binding
#         binding
#       end
#     end
#
#     k1 = Demo.new(99)
#     b1 = k1.get_binding
#     k2 = Demo.new(-3)
#     b2 = k2.get_binding
#
#     eval("@secret", b1)   #=> 99
#     eval("@secret", b2)   #=> -3
#     eval("@secret")       #=> nil
#
# Binding objects have no class-specific methods.
#
class Binding
  def clone: () -> self

  def dup: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - binding.eval(string [, filename [,lineno]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*, in the *binding*'s context.  If
  # the optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     b.eval("param")   #=> "hello"
  #
  def eval: (string src, ?string filename, ?int lineno) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_defined?(symbol) -> obj
  # -->
  # Returns `true` if a local variable `symbol` exists.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_defined?(:a) #=> true
  #       binding.local_variable_defined?(:b) #=> false
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("defined?(#{symbol}) == 'local-variable'")
  #
  def local_variable_defined?: (interned varname) -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_get(symbol) -> obj
  # -->
  # Returns the value of the local variable `symbol`.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_get(:a) #=> 1
  #       binding.local_variable_get(:b) #=> NameError
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("#{symbol}")
  #
  def local_variable_get: (interned varname) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_set(symbol, obj) -> obj
  # -->
  # Set local variable named `symbol` as `obj`.
  #
  #     def foo
  #       a = 1
  #       bind = binding
  #       bind.local_variable_set(:a, 2) # set existing local variable `a'
  #       bind.local_variable_set(:b, 3) # create new local variable `b'
  #                                      # `b' exists only in binding
  #
  #       p bind.local_variable_get(:a)  #=> 2
  #       p bind.local_variable_get(:b)  #=> 3
  #       p a                            #=> 2
  #       p b                            #=> NameError
  #     end
  #
  # This method behaves similarly to the following code:
  #
  #     binding.eval("#{symbol} = #{obj}")
  #
  # if `obj` can be dumped in Ruby code.
  #
  def local_variable_set: [U] (interned varname, U obj) -> U

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variables -> Array
  # -->
  # Returns the names of the binding's local variables as symbols.
  #
  #     def foo
  #       a = 1
  #       2.times do |n|
  #         binding.local_variables #=> [:a, :n]
  #       end
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("local_variables")
  #
  def local_variables: () -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - binding.receiver    -> object
  # -->
  # Returns the bound receiver of the binding object.
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number of the binding object.
  #
  def source_location: () -> [String, Integer]
end
# <!-- rdoc-file=enum.c -->
# ## What's Here
#
# Module Enumerable provides methods that are useful to a collection class for:
#
# *   [Querying](rdoc-ref:Enumerable@Methods+for+Querying)
# *   [Fetching](rdoc-ref:Enumerable@Methods+for+Fetching)
# *   [Searching and
#     Filtering](rdoc-ref:Enumerable@Methods+for+Searching+and+Filtering)
# *   [Sorting](rdoc-ref:Enumerable@Methods+for+Sorting)
# *   [Iterating](rdoc-ref:Enumerable@Methods+for+Iterating)
# *   [And more....](rdoc-ref:Enumerable@Other+Methods)
#
# ### Methods for Querying
#
# These methods return information about the Enumerable other than the elements
# themselves:
#
# *   #member? (aliased as #include?): Returns `true` if `self == object`,
#     `false` otherwise.
# *   #all?: Returns `true` if all elements meet a specified criterion; `false`
#     otherwise.
# *   #any?: Returns `true` if any element meets a specified criterion; `false`
#     otherwise.
# *   #none?: Returns `true` if no element meets a specified criterion; `false`
#     otherwise.
# *   #one?: Returns `true` if exactly one element meets a specified criterion;
#     `false` otherwise.
# *   #count: Returns the count of elements, based on an argument or block
#     criterion, if given.
# *   #tally: Returns a new Hash containing the counts of occurrences of each
#     element.
#
# ### Methods for Fetching
#
# These methods return entries from the Enumerable, without modifying it:
#
# *Leading, trailing, or all elements*:
#
# *   #to_a (aliased as #entries): Returns all elements.
# *   #first: Returns the first element or leading elements.
# *   #take: Returns a specified number of leading elements.
# *   #drop: Returns a specified number of trailing elements.
# *   #take_while: Returns leading elements as specified by the given block.
# *   #drop_while: Returns trailing elements as specified by the given block.
#
# *Minimum and maximum value elements*:
#
# *   #min: Returns the elements whose values are smallest among the elements,
#     as determined by `#<=>` or a given block.
# *   #max: Returns the elements whose values are largest among the elements, as
#     determined by `#<=>` or a given block.
# *   #minmax: Returns a 2-element Array containing the smallest and largest
#     elements.
# *   #min_by: Returns the smallest element, as determined by the given block.
# *   #max_by: Returns the largest element, as determined by the given block.
# *   #minmax_by: Returns the smallest and largest elements, as determined by
#     the given block.
#
# *Groups, slices, and partitions*:
#
# *   #group_by: Returns a Hash that partitions the elements into groups.
# *   #partition: Returns elements partitioned into two new Arrays, as
#     determined by the given block.
# *   #slice_after: Returns a new Enumerator whose entries are a partition of
#     `self`, based either on a given `object` or a given block.
# *   #slice_before: Returns a new Enumerator whose entries are a partition of
#     `self`, based either on a given `object` or a given block.
# *   #slice_when: Returns a new Enumerator whose entries are a partition of
#     `self` based on the given block.
# *   #chunk: Returns elements organized into chunks as specified by the given
#     block.
# *   #chunk_while: Returns elements organized into chunks as specified by the
#     given block.
#
# ### Methods for Searching and Filtering
#
# These methods return elements that meet a specified criterion:
#
# *   #find (aliased as #detect): Returns an element selected by the block.
# *   #find_all (aliased as #filter, #select): Returns elements selected by the
#     block.
# *   #find_index: Returns the index of an element selected by a given object or
#     block.
# *   #reject: Returns elements not rejected by the block.
# *   #uniq: Returns elements that are not duplicates.
#
# ### Methods for Sorting
#
# These methods return elements in sorted order:
#
# *   #sort: Returns the elements, sorted by `#<=>` or the given block.
# *   #sort_by: Returns the elements, sorted by the given block.
#
# ### Methods for Iterating
#
# *   #each_entry: Calls the block with each successive element (slightly
#     different from #each).
# *   #each_with_index: Calls the block with each successive element and its
#     index.
# *   #each_with_object: Calls the block with each successive element and a
#     given object.
# *   #each_slice: Calls the block with successive non-overlapping slices.
# *   #each_cons: Calls the block with successive overlapping slices. (different
#     from #each_slice).
# *   #reverse_each: Calls the block with each successive element, in reverse
#     order.
#
# ### Other Methods
#
# *   #collect (aliased as #map): Returns objects returned by the block.
# *   #filter_map: Returns truthy objects returned by the block.
# *   #flat_map (aliased as #collect_concat): Returns flattened objects returned
#     by the block.
# *   #grep: Returns elements selected by a given object or objects returned by
#     a given block.
# *   #grep_v: Returns elements selected by a given object or objects returned
#     by a given block.
# *   #inject (aliased as #reduce): Returns the object formed by combining all
#     elements.
# *   #sum: Returns the sum of the elements, using method `+`.
# *   #zip: Combines each element with elements from other enumerables; returns
#     the n-tuples or calls the block with each.
# *   #cycle: Calls the block with each element, cycling repeatedly.
#
# ## Usage
#
# To use module Enumerable in a collection class:
#
# *   Include it:
#
#         include Enumerable
#
# *   Implement method `#each` which must yield successive elements of the
#     collection. The method will be called by almost any Enumerable method.
#
# Example:
#
#     class Foo
#       include Enumerable
#       def each
#         yield 1
#         yield 1, 2
#         yield
#       end
#     end
#     Foo.new.each_entry{ |element| p element }
#
# Output:
#
#     1
#     [1, 2]
#     nil
#
# ## Enumerable in Ruby Classes
#
# These Ruby core classes include (or extend) Enumerable:
#
# *   ARGF
# *   Array
# *   Dir
# *   Enumerator
# *   ENV (extends)
# *   Hash
# *   IO
# *   Range
# *   Struct
#
# These Ruby standard library classes include Enumerable:
#
# *   CSV
# *   CSV::Table
# *   CSV::Row
# *   Set
#
# Virtually all methods in Enumerable call method `#each` in the including
# class:
#
# *   `Hash#each` yields the next key-value pair as a 2-element Array.
# *   `Struct#each` yields the next name-value pair as a 2-element Array.
# *   For the other classes above, `#each` yields the next object from the
#     collection.
#
# ## About the Examples
#
# The example code snippets for the Enumerable methods:
#
# *   Always show the use of one or more Array-like classes (often Array
#     itself).
# *   Sometimes show the use of a Hash-like class. For some methods, though, the
#     usage would not make sense, and so it is not shown.  Example: #tally would
#     find exactly one of each Hash entry.
#
module Enumerable[unchecked out Elem] : _Each[Elem]
  # <!--
  #   rdoc-file=enum.c
  #   - all?                  -> true or false
  #   - all?(pattern)         -> true or false
  #   - all? {|element| ... } -> true or false
  # -->
  # Returns whether every element meets a given criterion.
  #
  # If `self` has no element, returns `true` and argument or block are not used.
  #
  # With no argument and no block, returns whether every element is truthy:
  #
  #     (1..4).all?           # => true
  #     %w[a b c d].all?      # => true
  #     [1, 2, nil].all?      # => false
  #     ['a','b', false].all? # => false
  #     [].all?               # => true
  #
  # With argument `pattern` and no block, returns whether for each element
  # `element`, `pattern === element`:
  #
  #     (1..4).all?(Integer)                 # => true
  #     (1..4).all?(Numeric)                 # => true
  #     (1..4).all?(Float)                   # => false
  #     %w[bar baz bat bam].all?(/ba/)       # => true
  #     %w[bar baz bat bam].all?(/bar/)      # => false
  #     %w[bar baz bat bam].all?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.all?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.all?(Hash)  # => false
  #     [].all?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for every
  # element:
  #
  #     (1..4).all? {|element| element < 5 }                    # => true
  #     (1..4).all? {|element| element < 4 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 3 } # => true
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 2 } # => false
  #
  # Related: #any?, #none? #one?.
  #
  def all?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - any?                  -> true or false
  #   - any?(pattern)         -> true or false
  #   - any? {|element| ... } -> true or false
  # -->
  # Returns whether any element meets a given criterion.
  #
  # If `self` has no element, returns `false` and argument or block are not used.
  #
  # With no argument and no block, returns whether any element is truthy:
  #
  #     (1..4).any?          # => true
  #     %w[a b c d].any?     # => true
  #     [1, false, nil].any? # => true
  #     [].any?              # => false
  #
  # With argument `pattern` and no block, returns whether for any element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].any?(Integer)        # => true
  #     [nil, false, 0].any?(Numeric)        # => true
  #     [nil, false, 0].any?(Float)          # => false
  #     %w[bar baz bat bam].any?(/m/)        # => true
  #     %w[bar baz bat bam].any?(/foo/)      # => false
  #     %w[bar baz bat bam].any?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.any?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.any?(Hash)  # => false
  #     [].any?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for any
  # element:
  #
  #     (1..4).any? {|element| element < 2 }                    # => true
  #     (1..4).any? {|element| element < 1 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 1 } # => true
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 0 } # => false
  #
  # Related: #all?, #none?, #one?.
  #
  def any?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - map {|element| ... } -> array
  #   - map -> enumerator
  # -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def collect: [U] () { (Elem arg0) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def collect_concat: [U] () { (Elem) -> (::Array[U] | U) } -> ::Array[U]
                    | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - compact -> array
  # -->
  # Returns an array of all non-`nil` elements:
  #
  #     a = [nil, 0, nil, 'a', false, nil, false, nil, 'a', nil, 0, nil]
  #     a.compact # => [0, "a", false, false, "a", 0]
  #
  def compact: () -> Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - count -> integer
  #   - count(object) -> integer
  #   - count {|element| ... } -> integer
  # -->
  # Returns the count of elements, based on an argument or block criterion, if
  # given.
  #
  # With no argument and no block given, returns the number of elements:
  #
  #     [0, 1, 2].count                # => 3
  #     {foo: 0, bar: 1, baz: 2}.count # => 3
  #
  # With argument `object` given, returns the number of elements that are `==` to
  # `object`:
  #
  #     [0, 1, 2, 1].count(1)           # => 2
  #
  # With a block given, calls the block with each element and returns the number
  # of elements for which the block returns a truthy value:
  #
  #     [0, 1, 2, 3].count {|element| element < 2}              # => 2
  #     {foo: 0, bar: 1, baz: 2}.count {|key, value| value < 2} # => 2
  #
  def count: () -> Integer
           | (Elem) -> Integer
           | () { (Elem) -> boolish } -> Integer

  # <!--
  #   rdoc-file=enum.c
  #   - cycle(n = nil) {|element| ...} ->  nil
  #   - cycle(n = nil)                 ->  enumerator
  # -->
  # When called with positive integer argument `n` and a block, calls the block
  # with each element, then does so again, until it has done so `n` times; returns
  # `nil`:
  #
  #     a = []
  #     (1..4).cycle(3) {|element| a.push(element) } # => nil
  #     a # => [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
  #     a = []
  #     ('a'..'d').cycle(2) {|element| a.push(element) }
  #     a # => ["a", "b", "c", "d", "a", "b", "c", "d"]
  #     a = []
  #     {foo: 0, bar: 1, baz: 2}.cycle(2) {|element| a.push(element) }
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2], [:foo, 0], [:bar, 1], [:baz, 2]]
  #
  # If count is zero or negative, does not call the block.
  #
  # When called with a block and `n` is `nil`, cycles forever.
  #
  # When no block is given, returns an Enumerator.
  #
  def cycle: (?Integer n) { (Elem arg0) -> untyped } -> NilClass
           | (?Integer n) -> ::Enumerator[Elem, NilClass]

  # <!-- rdoc-file=enum.c -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def detect: (?Proc ifnone) { (Elem) -> boolish } -> Elem?
            | (?Proc ifnone) -> ::Enumerator[Elem, Elem?]

  # <!--
  #   rdoc-file=enum.c
  #   - drop(n) -> array
  # -->
  # For positive integer `n`, returns an array containing all but the first `n`
  # elements:
  #
  #     r = (1..4)
  #     r.drop(3)  # => [4]
  #     r.drop(2)  # => [3, 4]
  #     r.drop(1)  # => [2, 3, 4]
  #     r.drop(0)  # => [1, 2, 3, 4]
  #     r.drop(50) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.drop(2) # => [[:baz, 2], [:bat, 3]]
  #
  def drop: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - drop_while {|element| ... } -> array
  #   - drop_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements after that point:
  #
  #     (1..4).drop_while{|i| i < 3 } # => [3, 4]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     a = h.drop_while{|element| key, value = *element; value < 2 }
  #     a # => [[:baz, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  def drop_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - each_cons(n) { ... } ->  self
  #   - each_cons(n)         ->  enumerator
  # -->
  # Calls the block with each successive overlapped `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..5).each_cons(3) {|element| a.push(element) }
  #     a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
  #
  #     a = []
  #     h = {foo: 0,  bar: 1, baz: 2, bam: 3}
  #     h.each_cons(2) {|element| a.push(element) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:bar, 1], [:baz, 2]], [[:baz, 2], [:bam, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_cons: (Integer n) { (::Array[Elem]) -> void } -> self
               | (Integer n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_index(*args) {|element, i| ..... } -> self
  #   - each_with_index(*args)                       -> enumerator
  # -->
  # Invoke `self.each` with `*args`. With a block given, the block receives each
  # element and its index; returns `self`:
  #
  #     h = {}
  #     (1..4).each_with_index {|element, i| h[element] = i } # => 1..4
  #     h # => {1=>0, 2=>1, 3=>2, 4=>3}
  #
  #     h = {}
  #     %w[a b c d].each_with_index {|element, i| h[element] = i }
  #     # => ["a", "b", "c", "d"]
  #     h # => {"a"=>0, "b"=>1, "c"=>2, "d"=>3}
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_with_index {|element, i| a.push([i, element]) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[0, [:foo, 0]], [1, [:bar, 1]], [2, [:baz, 2]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_index: () { (Elem, Integer index) -> untyped } -> self
                     | () -> ::Enumerator[[ Elem, Integer ], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_object(object) { |(*args), memo_object| ... }  ->  object
  #   - each_with_object(object)                                 ->  enumerator
  # -->
  # Calls the block once for each element, passing both the element and the given
  # object:
  #
  #     (1..4).each_with_object([]) {|i, a| a.push(i**2) }
  #     # => [1, 4, 9, 16]
  #
  #     {foo: 0, bar: 1, baz: 2}.each_with_object({}) {|(k, v), h| h[v] = k }
  #     # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                      | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  def entries: () -> ::Array[Elem]

  def enum_for: (Symbol method, *untyped, **untyped) ?{ (?) -> Integer } -> Enumerator[untyped, untyped]
              | () ?{ () -> Integer } -> Enumerator[Elem, self]

  %a{annotate:rdoc:skip}
  alias to_enum enum_for

  # <!--
  #   rdoc-file=enum.c
  #   - select {|element| ... } -> array
  #   - select -> enumerator
  # -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  def find_all: () { (Elem) -> boolish } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias select find_all

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias filter find_all

  # <!--
  #   rdoc-file=enum.c
  #   - find_index(object) -> integer or nil
  #   - find_index {|element| ... } -> integer or nil
  #   - find_index -> enumerator
  # -->
  # Returns the index of the first element that meets a specified criterion, or
  # `nil` if no such element is found.
  #
  # With argument `object` given, returns the index of the first element that is
  # `==` `object`:
  #
  #     ['a', 'b', 'c', 'b'].find_index('b') # => 1
  #
  # With a block given, calls the block with successive elements; returns the
  # first element for which the block returns a truthy value:
  #
  #     ['a', 'b', 'c', 'b'].find_index {|element| element.start_with?('b') } # => 1
  #     {foo: 0, bar: 1, baz: 2}.find_index {|key, value| value > 1 }         # => 2
  #
  # With no argument and no block given, returns an Enumerator.
  #
  def find_index: (untyped value) -> Integer?
                | () { (Elem) -> boolish } -> Integer?
                | () -> ::Enumerator[Elem, Integer?]

  # <!--
  #   rdoc-file=enum.c
  #   - first    -> element or nil
  #   - first(n) -> array
  # -->
  # Returns the first element or elements.
  #
  # With no argument, returns the first element, or `nil` if there is none:
  #
  #     (1..4).first                   # => 1
  #     %w[a b c].first                # => "a"
  #     {foo: 1, bar: 1, baz: 2}.first # => [:foo, 1]
  #     [].first                       # => nil
  #
  # With integer argument `n`, returns an array containing the first `n` elements
  # that exist:
  #
  #     (1..4).first(2)                   # => [1, 2]
  #     %w[a b c d].first(3)              # => ["a", "b", "c"]
  #     %w[a b c d].first(50)             # => ["a", "b", "c", "d"]
  #     {foo: 1, bar: 1, baz: 2}.first(2) # => [[:foo, 1], [:bar, 1]]
  #     [].first(2)                       # => []
  #
  def first: () -> Elem?
           | (_ToInt n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - grep(pattern) -> array
  #   - grep(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based elements of `self` that match the given
  # pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `true`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/)                   # => ["bar", "car"]
  #     (1..10).grep(3..8)             # => [3, 4, 5, 6, 7, 8]
  #     ['a', 'b', 0, 1].grep(Integer) # => [0, 1]
  #
  # With a block given, calls the block with each matching element and returns an
  # array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/) {|element| element.upcase } # => ["BAR", "CAR"]
  #
  # Related: #grep_v.
  #
  def grep: (untyped arg0) -> ::Array[Elem]
          | [U] (untyped arg0) { (Elem arg0) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - grep_v(pattern) -> array
  #   - grep_v(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based on elements of `self` that *don't* match the
  # given pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `false`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/)                   # => ["foo", "moo"]
  #     (1..10).grep_v(3..8)             # => [1, 2, 9, 10]
  #     ['a', 'b', 0, 1].grep_v(Integer) # => ["a", "b"]
  #
  # With a block given, calls the block with each non-matching element and returns
  # an array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/) {|element| element.upcase } # => ["FOO", "MOO"]
  #
  # Related: #grep.
  #
  def grep_v: (untyped) -> ::Array[Elem]
            | [U] (untyped) { (Elem) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - group_by {|element| ... } -> hash
  #   - group_by                  -> enumerator
  # -->
  # With a block given returns a hash:
  #
  # *   Each key is a return value from the block.
  # *   Each value is an array of those elements for which the block returned that
  #     key.
  #
  # Examples:
  #
  #     g = (1..6).group_by {|i| i%3 }
  #     g # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]}
  #     h = {foo: 0, bar: 1, baz: 0, bat: 1}
  #     g = h.group_by {|key, value| value }
  #     g # => {0=>[[:foo, 0], [:baz, 0]], 1=>[[:bar, 1], [:bat, 1]]}
  #
  # With no block given, returns an Enumerator.
  #
  def group_by: [U] () { (Elem arg0) -> U } -> ::Hash[U, ::Array[Elem]]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  def include?: (Elem arg0) -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - inject(symbol)                -> object
  #   - inject(initial_value, symbol) -> object
  #   - inject {|memo, value| ... }   -> object
  #   - inject(initial_value) {|memo, value| ... } -> object
  # -->
  # Returns the result of applying a reducer to an initial value and the first
  # element of the Enumerable. It then takes the result and applies the function
  # to it and the second element of the collection, and so on. The return value is
  # the result returned by the final call to the function.
  #
  # You can think of
  #
  #     [ a, b, c, d ].inject(i) { |r, v| fn(r, v) }
  #
  # as being
  #
  #     fn(fn(fn(fn(i, a), b), c), d)
  #
  # In a way the `inject` function *injects* the function between the elements of
  # the enumerable.
  #
  # `inject` is aliased as `reduce`. You use it when you want to *reduce* a
  # collection to a single value.
  #
  # **The Calling Sequences**
  #
  # Let's start with the most verbose:
  #
  #     enum.inject(initial_value) do |result, next_value|
  #       # do something with +result+ and +next_value+
  #       # the value returned by the block becomes the
  #       # value passed in to the next iteration
  #       # as +result+
  #     end
  #
  # For example:
  #
  #     product = [ 2, 3, 4 ].inject(1) do |result, next_value|
  #       result * next_value
  #     end
  #     product #=> 24
  #
  # When this runs, the block is first called with `1` (the initial value) and `2`
  # (the first element of the array). The block returns `1*2`, so on the next
  # iteration the block is called with `2` (the previous result) and `3`. The
  # block returns `6`, and is called one last time with `6` and `4`. The result of
  # the block, `24` becomes the value returned by `inject`. This code returns the
  # product of the elements in the enumerable.
  #
  # **First Shortcut: Default Initial value**
  #
  # In the case of the previous example, the initial value, `1`, wasn't really
  # necessary: the calculation of the product of a list of numbers is
  # self-contained.
  #
  # In these circumstances, you can omit the `initial_value` parameter. `inject`
  # will then initially call the block with the first element of the collection as
  # the `result` parameter and the second element as the `next_value`.
  #
  #     [ 2, 3, 4 ].inject do |result, next_value|
  #       result * next_value
  #     end
  #
  # This shortcut is convenient, but can only be used when the block produces a
  # result which can be passed back to it as a first parameter.
  #
  # Here's an example where that's not the case: it returns a hash where the keys
  # are words and the values are the number of occurrences of that word in the
  # enumerable.
  #
  #     freqs = File.read("README.md")
  #       .scan(/\w{2,}/)
  #       .reduce(Hash.new(0)) do |counts, word|
  #         counts[word] += 1
  #         counts
  #       end
  #     freqs #=> {"Actions"=>4,
  #                "Status"=>5,
  #                "MinGW"=>3,
  #                "https"=>27,
  #                "github"=>10,
  #                "com"=>15, ...
  #
  # Note that the last line of the block is just the word `counts`. This ensures
  # the return value of the block is the result that's being calculated.
  #
  # **Second Shortcut: a Reducer function**
  #
  # A *reducer function* is a function that takes a partial result and the next
  # value, returning the next partial result. The block that is given to `inject`
  # is a reducer.
  #
  # You can also write a reducer as a function and pass the name of that function
  # (as a symbol) to `inject`. However, for this to work, the function
  #
  # 1.  Must be defined on the type of the result value
  # 2.  Must accept a single parameter, the next value in the collection, and
  # 3.  Must return an updated result which will also implement the function.
  #
  # Here's an example that adds elements to a string. The two calls invoke the
  # functions String#concat and String#+ on the result so far, passing it the next
  # value.
  #
  #     s = [ "cat", " ", "dog" ].inject("", :concat)
  #     s #=> "cat dog"
  #     s = [ "cat", " ", "dog" ].inject("The result is:", :+)
  #     s #=> "The result is: cat dog"
  #
  # Here's a more complex example when the result object maintains state of a
  # different type to the enumerable elements.
  #
  #     class Turtle
  #
  #       def initialize
  #         @x = @y = 0
  #       end
  #
  #       def move(dir)
  #         case dir
  #         when "n" then @y += 1
  #         when "s" then @y -= 1
  #         when "e" then @x += 1
  #         when "w" then @x -= 1
  #         end
  #         self
  #       end
  #     end
  #
  #     position = "nnneesw".chars.reduce(Turtle.new, :move)
  #     position  #=>> #<Turtle:0x00000001052f4698 @y=2, @x=1>
  #
  # **Third Shortcut: Reducer With no Initial Value**
  #
  # If your reducer returns a value that it can accept as a parameter, then you
  # don't have to pass in an initial value. Here `:*` is the name of the *times*
  # function:
  #
  #     product = [ 2, 3, 4 ].inject(:*)
  #     product # => 24
  #
  # String concatenation again:
  #
  #     s = [ "cat", " ", "dog" ].inject(:+)
  #     s #=> "cat dog"
  #
  # And an example that converts a hash to an array of two-element subarrays.
  #
  #     nested = {foo: 0, bar: 1}.inject([], :push)
  #     nested # => [[:foo, 0], [:bar, 1]]
  #
  def inject: (untyped init, Symbol method) -> untyped
            | (Symbol method) -> untyped
            | [A] (A initial) { (A, Elem) -> A } -> A
            | () { (Elem, Elem) -> Elem } -> Elem

  # <!--
  #   rdoc-file=enum.c
  #   - max                  -> element
  #   - max(n)               -> array
  #   - max {|a, b| ... }    -> element
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the maximum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the maximum element, using the
  # elements' own method `#<=>` for comparison:
  #
  #     (1..4).max                   # => 4
  #     (-4..-1).max                 # => -1
  #     %w[d c b a].max              # => "d"
  #     {foo: 0, bar: 1, baz: 2}.max # => [:foo, 0]
  #     [].max                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` maximum elements that exist:
  #
  #     (1..4).max(2)                   # => [4, 3]
  #     (-4..-1).max(2)                # => [-1, -2]
  #     %w[d c b a].max(2)              # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.max(2) # => [[:foo, 0], [:baz, 2]]
  #     [].max(2)                       # => []
  #
  # With a block given, the block determines the maximum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  # With a block given and no argument, returns the maximum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].max {|a, b| a.size <=> b.size } # => "xxxx"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max {|pair1, pair2| pair1[1] <=> pair2[1] }     # => [:baz, 2]
  #     [].max {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` maximum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].max(2) {|a, b| a.size <=> b.size } # => ["xxxx", "xxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].max(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min, #minmax, #max_by.
  #
  def max: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - max_by {|element| ... }    -> element
  #   - max_by(n) {|element| ... } -> array
  #   - max_by                     -> enumerator
  #   - max_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the maximum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the maximum value:
  #
  #     (1..4).max_by {|element| -element }                    # => 1
  #     %w[a b c d].max_by {|element| -element.ord }           # => "a"
  #     {foo: 0, bar: 1, baz: 2}.max_by {|key, value| -value } # => [:foo, 0]
  #     [].max_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns maximum values:
  #
  #     (1..4).max_by(2) {|element| -element }
  #     # => [1, 2]
  #     %w[a b c d].max_by(2) {|element| -element.ord }
  #     # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.max_by(2) {|key, value| -value }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].max_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max, #minmax, #min_by.
  #
  def max_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min                  -> element
  #   - min(n)               -> array
  #   - min {|a, b| ... }    -> element
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the minimum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum element, using the
  # elements' own method `#<=>` for comparison:
  #
  #     (1..4).min                   # => 1
  #     (-4..-1).min                 # => -4
  #     %w[d c b a].min              # => "a"
  #     {foo: 0, bar: 1, baz: 2}.min # => [:bar, 1]
  #     [].min                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` minimum elements that exist:
  #
  #     (1..4).min(2)                   # => [1, 2]
  #     (-4..-1).min(2)                 # => [-4, -3]
  #     %w[d c b a].min(2)              # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.min(2) # => [[:bar, 1], [:baz, 2]]
  #     [].min(2)                       # => []
  #
  # With a block given, the block determines the minimum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  # With a block given and no argument, returns the minimum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].min {|a, b| a.size <=> b.size } # => "x"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min {|pair1, pair2| pair1[1] <=> pair2[1] } # => [:foo, 0]
  #     [].min {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` minimum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].min(2) {|a, b| a.size <=> b.size } # => ["x", "xx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].min(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min_by, #minmax, #max.
  #
  def min: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min_by {|element| ... }    -> element
  #   - min_by(n) {|element| ... } -> array
  #   - min_by                     -> enumerator
  #   - min_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the minimum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the minimum value:
  #
  #     (1..4).min_by {|element| -element }                    # => 4
  #     %w[a b c d].min_by {|element| -element.ord }           # => "d"
  #     {foo: 0, bar: 1, baz: 2}.min_by {|key, value| -value } # => [:baz, 2]
  #     [].min_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns minimum values:
  #
  #     (1..4).min_by(2) {|element| -element }
  #     # => [4, 3]
  #     %w[a b c d].min_by(2) {|element| -element.ord }
  #     # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.min_by(2) {|key, value| -value }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].min_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #min, #minmax, #max_by.
  #
  def min_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax               -> [minimum, maximum]
  #   - minmax {|a, b| ... } -> [minimum, maximum]
  # -->
  # Returns a 2-element array containing the minimum and maximum elements
  # according to a given criterion. The ordering of equal elements is
  # indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum and maximum elements, using
  # the elements' own method `#<=>` for comparison:
  #
  #     (1..4).minmax                   # => [1, 4]
  #     (-4..-1).minmax                 # => [-4, -1]
  #     %w[d c b a].minmax              # => ["a", "d"]
  #     {foo: 0, bar: 1, baz: 2}.minmax # => [[:bar, 1], [:foo, 0]]
  #     [].minmax                       # => [nil, nil]
  #
  # With a block given, returns the minimum and maximum elements as determined by
  # the block:
  #
  #     %w[xxx x xxxx xx].minmax {|a, b| a.size <=> b.size } # => ["x", "xxxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.minmax {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:baz, 2]]
  #     [].minmax {|a, b| a <=> b }                          # => [nil, nil]
  #
  # Related: #min, #max, #minmax_by.
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem arg0, Elem arg1) -> Integer } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax_by {|element| ... } -> [minimum, maximum]
  #   - minmax_by                  -> enumerator
  # -->
  # Returns a 2-element array containing the elements for which the block returns
  # minimum and maximum values:
  #
  #     (1..4).minmax_by {|element| -element }
  #     # => [4, 1]
  #     %w[a b c d].minmax_by {|element| -element.ord }
  #     # => ["d", "a"]
  #     {foo: 0, bar: 1, baz: 2}.minmax_by {|key, value| -value }
  #     # => [[:baz, 2], [:foo, 0]]
  #     [].minmax_by {|element| -element }
  #     # => [nil, nil]
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max_by, #minmax, #min_by.
  #
  def minmax_by: () -> [ Elem?, Elem? ]
               | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - none?                  -> true or false
  #   - none?(pattern)         -> true or false
  #   - none? {|element| ... } -> true or false
  # -->
  # Returns whether no element meets a given criterion.
  #
  # With no argument and no block, returns whether no element is truthy:
  #
  #     (1..4).none?           # => false
  #     [nil, false].none?     # => true
  #     {foo: 0}.none?         # => false
  #     {foo: 0, bar: 1}.none? # => false
  #     [].none?               # => true
  #
  # With argument `pattern` and no block, returns whether for no element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 1.1].none?(Integer)      # => true
  #     %w[bar baz bat bam].none?(/m/)        # => false
  #     %w[bar baz bat bam].none?(/foo/)      # => true
  #     %w[bar baz bat bam].none?('ba')       # => true
  #     {foo: 0, bar: 1, baz: 2}.none?(Hash)  # => true
  #     {foo: 0}.none?(Array)                 # => false
  #     [].none?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for no
  # element:
  #
  #     (1..4).none? {|element| element < 1 }                     # => true
  #     (1..4).none? {|element| element < 2 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 0 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 1 } # => false
  #
  # Related: #one?, #all?, #any?.
  #
  def none?: () -> bool
           | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - one?                  -> true or false
  #   - one?(pattern)         -> true or false
  #   - one? {|element| ... } -> true or false
  # -->
  # Returns whether exactly one element meets a given criterion.
  #
  # With no argument and no block, returns whether exactly one element is truthy:
  #
  #     (1..1).one?           # => true
  #     [1, nil, false].one?  # => true
  #     (1..4).one?           # => false
  #     {foo: 0}.one?         # => true
  #     {foo: 0, bar: 1}.one? # => false
  #     [].one?               # => false
  #
  # With argument `pattern` and no block, returns whether for exactly one element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].one?(Integer)        # => true
  #     [nil, false, 0].one?(Numeric)        # => true
  #     [nil, false, 0].one?(Float)          # => false
  #     %w[bar baz bat bam].one?(/m/)        # => true
  #     %w[bar baz bat bam].one?(/foo/)      # => false
  #     %w[bar baz bat bam].one?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.one?(Array) # => false
  #     {foo: 0}.one?(Array)                 # => true
  #     [].one?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for
  # exactly one element:
  #
  #     (1..4).one? {|element| element < 2 }                     # => true
  #     (1..4).one? {|element| element < 1 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 1 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 2 } # => false
  #
  # Related: #none?, #all?, #any?.
  #
  def one?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - partition {|element| ... } -> [true_array, false_array]
  #   - partition -> enumerator
  # -->
  # With a block given, returns an array of two arrays:
  #
  # *   The first having those elements for which the block returns a truthy
  #     value.
  # *   The other having all other elements.
  #
  # Examples:
  #
  #     p = (1..4).partition {|i| i.even? }
  #     p # => [[2, 4], [1, 3]]
  #     p = ('a'..'d').partition {|c| c < 'c' }
  #     p # => [["a", "b"], ["c", "d"]]
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     p = h.partition {|key, value| key.start_with?('b') }
  #     p # => [[[:bar, 1], [:baz, 2], [:bat, 3]], [[:foo, 0]]]
  #     p = h.partition {|key, value| value < 2 }
  #     p # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  # Related: Enumerable#group_by.
  #
  def partition: () { (Elem) -> boolish } -> [ ::Array[Elem], ::Array[Elem] ]
               | () -> ::Enumerator[Elem, [ ::Array[Elem], ::Array[Elem] ]]

  # <!--
  #   rdoc-file=enum.c
  #   - reject {|element| ... } -> array
  #   - reject -> enumerator
  # -->
  # Returns an array of objects rejected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns `nil` or `false`:
  #
  #     (0..9).reject {|i| i * 2 if i.even? }                             # => [1, 3, 5, 7, 9]
  #     {foo: 0, bar: 1, baz: 2}.reject {|key, value| key if value.odd? } # => {:foo=>0, :baz=>2}
  #
  # When no block given, returns an Enumerator.
  #
  # Related: #select.
  #
  def reject: () { (Elem) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - reverse_each(*args) {|element| ... } ->  self
  #   - reverse_each(*args)                  ->  enumerator
  # -->
  # With a block given, calls the block with each element, but in reverse order;
  # returns `self`:
  #
  #     a = []
  #     (1..4).reverse_each {|element| a.push(-element) } # => 1..4
  #     a # => [-4, -3, -2, -1]
  #
  #     a = []
  #     %w[a b c d].reverse_each {|element| a.push(element) }
  #     # => ["a", "b", "c", "d"]
  #     a # => ["d", "c", "b", "a"]
  #
  #     a = []
  #     h.reverse_each {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:baz, 2], [:bar, 1], [:foo, 0]]
  #
  # With no block given, returns an Enumerator.
  #
  def reverse_each: () { (Elem arg0) -> untyped } -> void
                  | () -> ::Enumerator[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sort               -> array
  #   - sort {|a, b| ... } -> array
  # -->
  # Returns an array containing the sorted elements of `self`. The ordering of
  # equal elements is indeterminate and may be unstable.
  #
  # With no block given, the sort compares using the elements' own method `#<=>`:
  #
  #     %w[b c a d].sort              # => ["a", "b", "c", "d"]
  #     {foo: 0, bar: 1, baz: 2}.sort # => [[:bar, 1], [:baz, 2], [:foo, 0]]
  #
  # With a block given, comparisons in the block determine the ordering. The block
  # is called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  # Examples:
  #
  #     a = %w[b c a d]
  #     a.sort {|a, b| b <=> a } # => ["d", "c", "b", "a"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.sort {|a, b| b <=> a } # => [[:foo, 0], [:baz, 2], [:bar, 1]]
  #
  # See also #sort_by. It implements a Schwartzian transform which is useful when
  # key computation or comparison is expensive.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sort_by {|element| ... } -> array
  #   - sort_by                  -> enumerator
  # -->
  # With a block given, returns an array of elements of `self`, sorted according
  # to the value returned by the block for each element. The ordering of equal
  # elements is indeterminate and may be unstable.
  #
  # Examples:
  #
  #     a = %w[xx xxx x xxxx]
  #     a.sort_by {|s| s.size }        # => ["x", "xx", "xxx", "xxxx"]
  #     a.sort_by {|s| -s.size }       # => ["xxxx", "xxx", "xx", "x"]
  #     h = {foo: 2, bar: 1, baz: 0}
  #     h.sort_by{|key, value| value } # => [[:baz, 0], [:bar, 1], [:foo, 2]]
  #     h.sort_by{|key, value| key }   # => [[:bar, 1], [:baz, 0], [:foo, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  # The current implementation of #sort_by generates an array of tuples containing
  # the original collection element and the mapped value. This makes #sort_by
  # fairly expensive when the keysets are simple.
  #
  #     require 'benchmark'
  #
  #     a = (1..100000).map { rand(100000) }
  #
  #     Benchmark.bm(10) do |b|
  #       b.report("Sort")    { a.sort }
  #       b.report("Sort by") { a.sort_by { |a| a } }
  #     end
  #
  # *produces:*
  #
  #     user     system      total        real
  #     Sort        0.180000   0.000000   0.180000 (  0.175469)
  #     Sort by     1.980000   0.040000   2.020000 (  2.013586)
  #
  # However, consider the case where comparing the keys is a non-trivial
  # operation. The following code sorts some files on modification time using the
  # basic #sort method.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This sort is inefficient: it generates two new File objects during every
  # comparison. A slightly better technique is to use the Kernel#test method to
  # generate the modification times directly.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b|
  #       test(?M, a) <=> test(?M, b)
  #     }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This still generates many unnecessary Time objects. A more efficient technique
  # is to cache the sort keys (modification times in this case) before the sort.
  # Perl users often call this approach a Schwartzian transform, after Randal
  # Schwartz. We construct a temporary array, where each element is an array
  # containing our sort key along with the filename. We sort this array, and then
  # extract the filename from the result.
  #
  #     sorted = Dir["*"].collect { |f|
  #        [test(?M, f), f]
  #     }.sort.collect { |f| f[1] }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This is exactly what #sort_by does internally.
  #
  #     sorted = Dir["*"].sort_by { |f| test(?M, f) }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # To produce the reverse of a specific order, the following can be used:
  #
  #     ary.sort_by { ... }.reverse!
  #
  def sort_by: () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]
             | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - take(n) -> array
  # -->
  # For non-negative integer `n`, returns the first `n` elements:
  #
  #     r = (1..4)
  #     r.take(2) # => [1, 2]
  #     r.take(0) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.take(2) # => [[:foo, 0], [:bar, 1]]
  #
  def take: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - take_while {|element| ... } -> array
  #   - take_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements up to that point:
  #
  #     (1..4).take_while{|i| i < 3 } # => [1, 2]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.take_while{|element| key, value = *element; value < 2 }
  #     # => [[:foo, 0], [:bar, 1]]
  #
  # With no block given, returns an Enumerator.
  #
  def take_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - to_h(*args) -> hash
  #   - to_h(*args) {|element| ... }  -> hash
  # -->
  # When `self` consists of 2-element arrays, returns a hash each of whose entries
  # is the key-value pair formed from one of those arrays:
  #
  #     [[:foo, 0], [:bar, 1], [:baz, 2]].to_h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When a block is given, the block is called with each element of `self`; the
  # block should return a 2-element array which becomes a key-value pair in the
  # returned hash:
  #
  #     (0..3).to_h {|i| [i, i ** 2]} # => {0=>0, 1=>1, 2=>4, 3=>9}
  #
  # Raises an exception if an element of `self` is not a 2-element array, and a
  # block is not passed.
  #
  def to_h: () -> ::Hash[untyped, untyped]
          | [T, U] () { (Elem) -> [ T, U ] } -> ::Hash[T, U]

  # <!--
  #   rdoc-file=enum.c
  #   - each_slice(n) { ... }  ->  self
  #   - each_slice(n)          ->  enumerator
  # -->
  # Calls the block with each successive disjoint `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..10).each_slice(3) {|tuple| a.push(tuple) }
  #     a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3, bam: 4}
  #     h.each_slice(2) {|tuple| a.push(tuple) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]], [[:bam, 4]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_slice: (Integer n) { (::Array[Elem]) -> void } -> self
                | (Integer n) -> ::Enumerator[::Array[Elem], self]

  interface _NotFound[T]
    def call: () -> T
  end

  # <!--
  #   rdoc-file=enum.c
  #   - find(if_none_proc = nil) {|element| ... } -> object or nil
  #   - find(if_none_proc = nil) -> enumerator
  # -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def find: () { (Elem) -> boolish } -> Elem?
          | () -> ::Enumerator[Elem, Elem?]
          | [T] (_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
          | [T] (_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  # <!--
  #   rdoc-file=enum.c
  #   - flat_map {|element| ... } -> array
  #   - flat_map -> enumerator
  # -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def flat_map: [U] () { (Elem) -> (Array[U] | U) } -> Array[U]
              | () -> ::Enumerator[Elem, Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def map: [U] () { (Elem arg0) -> U } -> ::Array[U]
         | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - include?(object) -> true or false
  # -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  def member?: (Elem arg0) -> bool

  # <!-- rdoc-file=enum.c -->
  # Returns the result of applying a reducer to an initial value and the first
  # element of the Enumerable. It then takes the result and applies the function
  # to it and the second element of the collection, and so on. The return value is
  # the result returned by the final call to the function.
  #
  # You can think of
  #
  #     [ a, b, c, d ].inject(i) { |r, v| fn(r, v) }
  #
  # as being
  #
  #     fn(fn(fn(fn(i, a), b), c), d)
  #
  # In a way the `inject` function *injects* the function between the elements of
  # the enumerable.
  #
  # `inject` is aliased as `reduce`. You use it when you want to *reduce* a
  # collection to a single value.
  #
  # **The Calling Sequences**
  #
  # Let's start with the most verbose:
  #
  #     enum.inject(initial_value) do |result, next_value|
  #       # do something with +result+ and +next_value+
  #       # the value returned by the block becomes the
  #       # value passed in to the next iteration
  #       # as +result+
  #     end
  #
  # For example:
  #
  #     product = [ 2, 3, 4 ].inject(1) do |result, next_value|
  #       result * next_value
  #     end
  #     product #=> 24
  #
  # When this runs, the block is first called with `1` (the initial value) and `2`
  # (the first element of the array). The block returns `1*2`, so on the next
  # iteration the block is called with `2` (the previous result) and `3`. The
  # block returns `6`, and is called one last time with `6` and `4`. The result of
  # the block, `24` becomes the value returned by `inject`. This code returns the
  # product of the elements in the enumerable.
  #
  # **First Shortcut: Default Initial value**
  #
  # In the case of the previous example, the initial value, `1`, wasn't really
  # necessary: the calculation of the product of a list of numbers is
  # self-contained.
  #
  # In these circumstances, you can omit the `initial_value` parameter. `inject`
  # will then initially call the block with the first element of the collection as
  # the `result` parameter and the second element as the `next_value`.
  #
  #     [ 2, 3, 4 ].inject do |result, next_value|
  #       result * next_value
  #     end
  #
  # This shortcut is convenient, but can only be used when the block produces a
  # result which can be passed back to it as a first parameter.
  #
  # Here's an example where that's not the case: it returns a hash where the keys
  # are words and the values are the number of occurrences of that word in the
  # enumerable.
  #
  #     freqs = File.read("README.md")
  #       .scan(/\w{2,}/)
  #       .reduce(Hash.new(0)) do |counts, word|
  #         counts[word] += 1
  #         counts
  #       end
  #     freqs #=> {"Actions"=>4,
  #                "Status"=>5,
  #                "MinGW"=>3,
  #                "https"=>27,
  #                "github"=>10,
  #                "com"=>15, ...
  #
  # Note that the last line of the block is just the word `counts`. This ensures
  # the return value of the block is the result that's being calculated.
  #
  # **Second Shortcut: a Reducer function**
  #
  # A *reducer function* is a function that takes a partial result and the next
  # value, returning the next partial result. The block that is given to `inject`
  # is a reducer.
  #
  # You can also write a reducer as a function and pass the name of that function
  # (as a symbol) to `inject`. However, for this to work, the function
  #
  # 1.  Must be defined on the type of the result value
  # 2.  Must accept a single parameter, the next value in the collection, and
  # 3.  Must return an updated result which will also implement the function.
  #
  # Here's an example that adds elements to a string. The two calls invoke the
  # functions String#concat and String#+ on the result so far, passing it the next
  # value.
  #
  #     s = [ "cat", " ", "dog" ].inject("", :concat)
  #     s #=> "cat dog"
  #     s = [ "cat", " ", "dog" ].inject("The result is:", :+)
  #     s #=> "The result is: cat dog"
  #
  # Here's a more complex example when the result object maintains state of a
  # different type to the enumerable elements.
  #
  #     class Turtle
  #
  #       def initialize
  #         @x = @y = 0
  #       end
  #
  #       def move(dir)
  #         case dir
  #         when "n" then @y += 1
  #         when "s" then @y -= 1
  #         when "e" then @x += 1
  #         when "w" then @x -= 1
  #         end
  #         self
  #       end
  #     end
  #
  #     position = "nnneesw".chars.reduce(Turtle.new, :move)
  #     position  #=>> #<Turtle:0x00000001052f4698 @y=2, @x=1>
  #
  # **Third Shortcut: Reducer With no Initial Value**
  #
  # If your reducer returns a value that it can accept as a parameter, then you
  # don't have to pass in an initial value. Here `:*` is the name of the *times*
  # function:
  #
  #     product = [ 2, 3, 4 ].inject(:*)
  #     product # => 24
  #
  # String concatenation again:
  #
  #     s = [ "cat", " ", "dog" ].inject(:+)
  #     s #=> "cat dog"
  #
  # And an example that converts a hash to an array of two-element subarrays.
  #
  #     nested = {foo: 0, bar: 1}.inject([], :push)
  #     nested # => [[:foo, 0], [:bar, 1]]
  #
  alias reduce inject

  # <!--
  #   rdoc-file=enum.c
  #   - to_a(*args) -> array
  # -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.lazy -> lazy_enumerator
  # -->
  # Returns an Enumerator::Lazy, which redefines most Enumerable methods to
  # postpone enumeration and enumerate values only on an as-needed basis.
  #
  # ### Example
  #
  # The following program finds pythagorean triples:
  #
  #     def pythagorean_triples
  #       (1..Float::INFINITY).lazy.flat_map {|z|
  #         (1..z).flat_map {|x|
  #           (x..z).select {|y|
  #             x**2 + y**2 == z**2
  #           }.map {|y|
  #             [x, y, z]
  #           }
  #         }
  #       }
  #     end
  #     # show first ten pythagorean triples
  #     p pythagorean_triples.take(10).force # take is lazy, so force is needed
  #     p pythagorean_triples.first(10)      # first is eager
  #     # show pythagorean triples less than 100
  #     p pythagorean_triples.take_while { |*, z| z < 100 }.force
  #
  def lazy: () -> Enumerator::Lazy[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - uniq                  -> array
  #   - uniq {|element| ... } -> array
  # -->
  # With no block, returns a new array containing only unique elements; the array
  # has no two elements `e0` and `e1` such that `e0.eql?(e1)`:
  #
  #     %w[a b c c b a a b c].uniq       # => ["a", "b", "c"]
  #     [0, 1, 2, 2, 1, 0, 0, 1, 2].uniq # => [0, 1, 2]
  #
  # With a block, returns a new array containing elements only for which the block
  # returns a unique value:
  #
  #     a = [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
  #     a.uniq {|i| i.even? ? i : 0 } # => [0, 2, 4]
  #     a = %w[a b c d e e d c b a a b c d e]
  #     a.uniq {|c| c < 'c' }         # => ["a", "c"]
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sum(initial_value = 0)                  -> number
  #   - sum(initial_value = 0) {|element| ... } -> object
  # -->
  # With no block given, returns the sum of `initial_value` and the elements:
  #
  #     (1..100).sum          # => 5050
  #     (1..100).sum(1)       # => 5051
  #     ('a'..'d').sum('foo') # => "fooabcd"
  #
  # Generally, the sum is computed using methods `+` and `each`; for performance
  # optimizations, those methods may not be used, and so any redefinition of those
  # methods may not have effect here.
  #
  # One such optimization: When possible, computes using Gauss's summation formula
  # *n(n+1)/2*:
  #
  #     100 * (100 + 1) / 2 # => 5050
  #
  # With a block given, calls the block with each element; returns the sum of
  # `initial_value` and the block return values:
  #
  #     (1..4).sum {|i| i*i }                        # => 30
  #     (1..4).sum(100) {|i| i*i }                   # => 130
  #     h = {a: 0, b: 1, c: 2, d: 3, e: 4, f: 5}
  #     h.sum {|key, value| value.odd? ? value : 0 } # => 9
  #     ('a'..'f').sum('x') {|c| c < 'd' ? c : '' }  # => "xabc"
  #
  def sum: () -> (Elem | Integer)
         | [T] () { (Elem arg0) -> T } -> (Integer | T)
         | [T] (?T arg0) -> (Elem | T)
         | [U] (?U arg0) { (Elem arg0) -> U } -> U

  # <!--
  #   rdoc-file=enum.c
  #   - filter_map {|element| ... } -> array
  #   - filter_map -> enumerator
  # -->
  # Returns an array containing truthy elements returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # containing each truthy value returned by the block:
  #
  #     (0..9).filter_map {|i| i * 2 if i.even? }                              # => [0, 4, 8, 12, 16]
  #     {foo: 0, bar: 1, baz: 2}.filter_map {|key, value| key if value.even? } # => [:foo, :baz]
  #
  # When no block given, returns an Enumerator.
  #
  def filter_map: [U] () { (Elem elem) -> (nil | false | U) } -> ::Array[U]
                | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.chain(*enums) -> enumerator
  # -->
  # Returns an enumerator object generated from this enumerator and given
  # enumerables.
  #
  #     e = (1..3).chain([4, 5])
  #     e.to_a #=> [1, 2, 3, 4, 5]
  #
  def chain: [Elem2] (*_Each[Elem2] enumerables) -> ::Enumerator::Chain[Elem | Elem2]

  # <!--
  #   rdoc-file=enum.c
  #   - tally(hash = {}) -> hash
  # -->
  # When argument `hash` is not given, returns a new hash whose keys are the
  # distinct elements in `self`; each integer value is the count of occurrences of
  # each element:
  #
  #     %w[a b c b c a c b].tally # => {"a"=>2, "b"=>3, "c"=>3}
  #
  # When argument `hash` is given, returns `hash`, possibly augmented; for each
  # element `ele` in `self`:
  #
  # *   Adds it as a key with a zero value if that key does not already exist:
  #
  #         hash[ele] = 0 unless hash.include?(ele)
  #
  # *   Increments the value of key `ele`:
  #
  #         hash[ele] += 1
  #
  # This is useful for accumulating tallies across multiple enumerables:
  #
  #     h = {}                   # => {}
  #     %w[a c d b c a].tally(h) # => {"a"=>2, "c"=>2, "d"=>1, "b"=>1}
  #     %w[b a z].tally(h)       # => {"a"=>3, "c"=>2, "d"=>1, "b"=>2, "z"=>1}
  #     %w[b a m].tally(h)       # => {"a"=>4, "c"=>2, "d"=>1, "b"=>3, "z"=>1, "m"=>1}
  #
  # The key to be added or found for an element depends on the class of `self`;
  # see [Enumerable in Ruby
  # Classes](rdoc-ref:Enumerable@Enumerable+in+Ruby+Classes).
  #
  # Examples:
  #
  # *   Array (and certain array-like classes): the key is the element (as above).
  # *   Hash (and certain hash-like classes): the key is the 2-element array
  #     formed from the key-value pair:
  #
  #         h = {}                        # => {}
  #         {foo: 'a', bar: 'b'}.tally(h) # => {[:foo, "a"]=>1, [:bar, "b"]=>1}
  #         {foo: 'c', bar: 'd'}.tally(h) # => {[:foo, "a"]=>1, [:bar, "b"]=>1, [:foo, "c"]=>1, [:bar, "d"]=>1}
  #         {foo: 'a', bar: 'b'}.tally(h) # => {[:foo, "a"]=>2, [:bar, "b"]=>2, [:foo, "c"]=>1, [:bar, "d"]=>1}
  #         {foo: 'c', bar: 'd'}.tally(h) # => {[:foo, "a"]=>2, [:bar, "b"]=>2, [:foo, "c"]=>2, [:bar, "d"]=>2}
  #
  def tally: (?Hash[Elem, Integer] hash) -> ::Hash[Elem, Integer]

  # <!--
  #   rdoc-file=enum.c
  #   - each_entry(*args) {|element| ... } -> self
  #   - each_entry(*args)                  -> enumerator
  # -->
  # Calls the given block with each element, converting multiple values from yield
  # to an array; returns `self`:
  #
  #     a = []
  #     (1..4).each_entry {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz:2}
  #     h.each_entry {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  #     class Foo
  #       include Enumerable
  #       def each
  #         yield 1
  #         yield 1, 2
  #         yield
  #       end
  #     end
  #     Foo.new.each_entry {|yielded| p yielded }
  #
  # Output:
  #
  #     1
  #     [1, 2]
  #     nil
  #
  # With no block given, returns an Enumerator.
  #
  def each_entry: () -> ::Enumerator[Elem, self]
                | () { (Elem arg0) -> untyped } -> self

  # <!--
  #   rdoc-file=enum.c
  #   - zip(*other_enums) -> array
  #   - zip(*other_enums) {|array| ... } -> nil
  # -->
  # With no block given, returns a new array `new_array` of size self.size whose
  # elements are arrays. Each nested array `new_array[n]` is of size
  # `other_enums.size+1`, and contains:
  #
  # *   The `n`-th element of self.
  # *   The `n`-th element of each of the `other_enums`.
  #
  # If all `other_enums` and self are the same size, all elements are included in
  # the result, and there is no `nil`-filling:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  #     f = {foo: 0, bar: 1, baz: 2}
  #     g = {goo: 3, gar: 4, gaz: 5}
  #     h = {hoo: 6, har: 7, haz: 8}
  #     d = f.zip(g, h)
  #     d # => [
  #       #      [[:foo, 0], [:goo, 3], [:hoo, 6]],
  #       #      [[:bar, 1], [:gar, 4], [:har, 7]],
  #       #      [[:baz, 2], [:gaz, 5], [:haz, 8]]
  #       #    ]
  #
  # If any enumerable in other_enums is smaller than self, fills to `self.size`
  # with `nil`:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
  #
  # If any enumerable in other_enums is larger than self, its trailing elements
  # are ignored:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # When a block is given, calls the block with each of the sub-arrays (formed as
  # above); returns nil:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| p sub_array} # => nil
  #
  # Output:
  #
  #     [:a0, :b0, :c0]
  #     [:a1, :b1, :c1]
  #     [:a2, :b2, :c2]
  #     [:a3, :b3, :c3]
  #
  def zip: [Elem2] (_Each[Elem2] enum) -> Array[[ Elem, Elem2? ]]
         | (_Each[untyped], *_Each[untyped]) -> Array[Array[untyped]]
         | [Elem2] (_Each[Elem2]) { ([ Elem, Elem2? ]) -> void } -> nil
         | (_Each[untyped], *_Each[untyped]) { (Array[untyped]) -> void } -> nil

  # <!--
  #   rdoc-file=enum.c
  #   - chunk {|array| ... } -> enumerator
  # -->
  # Each element in the returned enumerator is a 2-element array consisting of:
  #
  # *   A value returned by the block.
  # *   An array ("chunk") containing the element for which that value was
  #     returned, and all following elements for which the block returned the same
  #     value:
  #
  # So that:
  #
  # *   Each block return value that is different from its predecessor begins a
  #     new chunk.
  # *   Each block return value that is the same as its predecessor continues the
  #     same chunk.
  #
  # Example:
  #
  #     e = (0..10).chunk {|i| (i / 3).floor } # => #<Enumerator: ...>
  #     # The enumerator elements.
  #     e.next # => [0, [0, 1, 2]]
  #     e.next # => [1, [3, 4, 5]]
  #     e.next # => [2, [6, 7, 8]]
  #     e.next # => [3, [9, 10]]
  #
  # Method `chunk` is especially useful for an enumerable that is already sorted.
  # This example counts words for each initial letter in a large array of words:
  #
  #     # Get sorted words from a web page.
  #     url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
  #     words = URI::open(url).readlines
  #     # Make chunks, one for each letter.
  #     e = words.chunk {|word| word.upcase[0] } # => #<Enumerator: ...>
  #     # Display 'A' through 'F'.
  #     e.each {|c, words| p [c, words.length]; break if c == 'F' }
  #
  # Output:
  #
  #     ["A", 17096]
  #     ["B", 11070]
  #     ["C", 19901]
  #     ["D", 10896]
  #     ["E", 8736]
  #     ["F", 6860]
  #
  # You can use the special symbol `:_alone` to force an element into its own
  # separate chuck:
  #
  #     a = [0, 0, 1, 1]
  #     e = a.chunk{|i| i.even? ? :_alone : true }
  #     e.to_a # => [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]
  #
  # For example, you can put each line that contains a URL into its own chunk:
  #
  #     pattern = /http/
  #     open(filename) { |f|
  #       f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
  #         pp lines
  #       }
  #     }
  #
  # You can use the special symbol `:_separator` or `nil` to force an element to
  # be ignored (not included in any chunk):
  #
  #     a = [0, 0, -1, 1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1, 1]]]
  #
  # Note that the separator does end the chunk:
  #
  #     a = [0, 0, -1, 1, -1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1]], [true, [1]]]
  #
  # For example, the sequence of hyphens in svn log can be eliminated as follows:
  #
  #     sep = "-"*72 + "\n"
  #     IO.popen("svn log README") { |f|
  #       f.chunk { |line|
  #         line != sep || nil
  #       }.each { |_, lines|
  #         pp lines
  #       }
  #     }
  #     #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Update the portability section.\n",
  #     #    "\n"]
  #     #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Add a note about default C flags.\n",
  #     #    "\n"]
  #     #   ...
  #
  # Paragraphs separated by empty lines can be parsed as follows:
  #
  #     File.foreach("README").chunk { |line|
  #       /\A\s*\z/ !~ line || nil
  #     }.each { |_, lines|
  #       pp lines
  #     }
  #
  def chunk: [U] () { (Elem elt) -> U } -> ::Enumerator[[ U, ::Array[Elem] ]]
           | () -> ::Enumerator[Elem, ::Enumerator[[ untyped, ::Array[Elem] ]]]

  # <!--
  #   rdoc-file=enum.c
  #   - enum.chunk_while {|elt_before, elt_after| bool } -> an_enumerator
  # -->
  # Creates an enumerator for each chunked elements. The beginnings of chunks are
  # defined by the block.
  #
  # This method splits each chunk using adjacent elements, *elt_before* and
  # *elt_after*, in the receiver enumerator. This method split chunks between
  # *elt_before* and *elt_after* where the block returns `false`.
  #
  # The block is called the length of the receiver enumerator minus one.
  #
  # The result enumerator yields the chunked elements as an array. So `each`
  # method can be called as follows:
  #
  #     enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }
  #
  # Other methods of the Enumerator class and Enumerable module, such as `to_a`,
  # `map`, etc., are also usable.
  #
  # For example, one-by-one increasing subsequence can be chunked as follows:
  #
  #     a = [1,2,4,9,10,11,12,15,16,19,20,21]
  #     b = a.chunk_while {|i, j| i+1 == j }
  #     p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
  #     c = b.map {|a| a.length < 3 ? a : "#{a.first}-#{a.last}" }
  #     p c #=> [[1, 2], [4], "9-12", [15, 16], "19-21"]
  #     d = c.join(",")
  #     p d #=> "1,2,4,9-12,15,16,19-21"
  #
  # Increasing (non-decreasing) subsequence can be chunked as follows:
  #
  #     a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
  #     p a.chunk_while {|i, j| i <= j }.to_a
  #     #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
  #
  # Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
  # another way to do it.)
  #
  #     a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
  #     p a.chunk_while {|i, j| i.even? == j.even? }.to_a
  #     #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
  #
  # Enumerable#slice_when does the same, except splitting when the block returns
  # `true` instead of `false`.
  #
  def chunk_while: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - enum.slice_when {|elt_before, elt_after| bool } -> an_enumerator
  # -->
  # Creates an enumerator for each chunked elements. The beginnings of chunks are
  # defined by the block.
  #
  # This method splits each chunk using adjacent elements, *elt_before* and
  # *elt_after*, in the receiver enumerator. This method split chunks between
  # *elt_before* and *elt_after* where the block returns `true`.
  #
  # The block is called the length of the receiver enumerator minus one.
  #
  # The result enumerator yields the chunked elements as an array. So `each`
  # method can be called as follows:
  #
  #     enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }
  #
  # Other methods of the Enumerator class and Enumerable module, such as `to_a`,
  # `map`, etc., are also usable.
  #
  # For example, one-by-one increasing subsequence can be chunked as follows:
  #
  #     a = [1,2,4,9,10,11,12,15,16,19,20,21]
  #     b = a.slice_when {|i, j| i+1 != j }
  #     p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
  #     c = b.map {|a| a.length < 3 ? a : "#{a.first}-#{a.last}" }
  #     p c #=> [[1, 2], [4], "9-12", [15, 16], "19-21"]
  #     d = c.join(",")
  #     p d #=> "1,2,4,9-12,15,16,19-21"
  #
  # Near elements (threshold: 6) in sorted array can be chunked as follows:
  #
  #     a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]
  #     p a.slice_when {|i, j| 6 < j - i }.to_a
  #     #=> [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]
  #
  # Increasing (non-decreasing) subsequence can be chunked as follows:
  #
  #     a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
  #     p a.slice_when {|i, j| i > j }.to_a
  #     #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
  #
  # Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
  # another way to do it.)
  #
  #     a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
  #     p a.slice_when {|i, j| i.even? != j.even? }.to_a
  #     #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
  #
  # Paragraphs (non-empty lines with trailing empty lines) can be chunked as
  # follows: (See Enumerable#chunk to ignore empty lines.)
  #
  #     lines = ["foo\n", "bar\n", "\n", "baz\n", "qux\n"]
  #     p lines.slice_when {|l1, l2| /\A\s*\z/ =~ l1 && /\S/ =~ l2 }.to_a
  #     #=> [["foo\n", "bar\n", "\n"], ["baz\n", "qux\n"]]
  #
  # Enumerable#chunk_while does the same, except splitting when the block returns
  # `false` instead of `true`.
  #
  def slice_when: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - enum.slice_after(pattern)       -> an_enumerator
  #   - enum.slice_after { |elt| bool } -> an_enumerator
  # -->
  # Creates an enumerator for each chunked elements. The ends of chunks are
  # defined by *pattern* and the block.
  #
  # If *`pattern* === *elt`* returns `true` or the block returns `true` for the
  # element, the element is end of a chunk.
  #
  # The `===` and *block* is called from the first element to the last element of
  # *enum*.
  #
  # The result enumerator yields the chunked elements as an array. So `each`
  # method can be called as follows:
  #
  #     enum.slice_after(pattern).each { |ary| ... }
  #     enum.slice_after { |elt| bool }.each { |ary| ... }
  #
  # Other methods of the Enumerator class and Enumerable module, such as `map`,
  # etc., are also usable.
  #
  # For example, continuation lines (lines end with backslash) can be concatenated
  # as follows:
  #
  #     lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
  #     e = lines.slice_after(/(?<!\\)\n\z/)
  #     p e.to_a
  #     #=> [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
  #     p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
  #     #=>["foo\n", "barbaz\n", "\n", "qux\n"]
  #
  def slice_after: (untyped pattern) -> ::Enumerator[::Array[Elem]]
                 | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_before(pattern)       -> enumerator
  #   - slice_before {|elt| ... } -> enumerator
  # -->
  # With argument `pattern`, returns an enumerator that uses the pattern to
  # partition elements into arrays ("slices"). An element begins a new slice if
  # `element === pattern` (or if it is the first element).
  #
  #     a = %w[foo bar fop for baz fob fog bam foy]
  #     e = a.slice_before(/ba/) # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     ["foo"]
  #     ["bar", "fop", "for"]
  #     ["baz", "fob", "fog"]
  #     ["bam", "foy"]
  #
  # With a block, returns an enumerator that uses the block to partition elements
  # into arrays. An element begins a new slice if its block return is a truthy
  # value (or if it is the first element):
  #
  #     e = (1..20).slice_before {|i| i % 4 == 2 } # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1]
  #     [2, 3, 4, 5]
  #     [6, 7, 8, 9]
  #     [10, 11, 12, 13]
  #     [14, 15, 16, 17]
  #     [18, 19, 20]
  #
  # Other methods of the Enumerator class and Enumerable module, such as `to_a`,
  # `map`, etc., are also usable.
  #
  # For example, iteration over ChangeLog entries can be implemented as follows:
  #
  #     # iterate over ChangeLog entries.
  #     open("ChangeLog") { |f|
  #       f.slice_before(/\A\S/).each { |e| pp e }
  #     }
  #
  #     # same as above.  block is used instead of pattern argument.
  #     open("ChangeLog") { |f|
  #       f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
  #     }
  #
  # "svn proplist -R" produces multiline output for each file. They can be chunked
  # as follows:
  #
  #     IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
  #       f.lines.slice_before(/\AProp/).each { |lines| p lines }
  #     }
  #     #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
  #     #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
  #     #   ...
  #
  # If the block needs to maintain state over multiple elements, local variables
  # can be used. For example, three or more consecutive increasing numbers can be
  # squashed as follows (see `chunk_while` for a better way):
  #
  #     a = [0, 2, 3, 4, 6, 7, 9]
  #     prev = a[0]
  #     p a.slice_before { |e|
  #       prev, prev2 = e, prev
  #       prev2 + 1 != e
  #     }.map { |es|
  #       es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
  #     }.join(",")
  #     #=> "0,2-4,6,7,9"
  #
  # However local variables should be used carefully if the result enumerator is
  # enumerated twice or more. The local variables should be initialized for each
  # enumeration. Enumerator.new can be used to do it.
  #
  #     # Word wrapping.  This assumes all characters have same width.
  #     def wordwrap(words, maxwidth)
  #       Enumerator.new {|y|
  #         # cols is initialized in Enumerator.new.
  #         cols = 0
  #         words.slice_before { |w|
  #           cols += 1 if cols != 0
  #           cols += w.length
  #           if maxwidth < cols
  #             cols = w.length
  #             true
  #           else
  #             false
  #           end
  #         }.each {|ws| y.yield ws }
  #       }
  #     end
  #     text = (1..20).to_a.join(" ")
  #     enum = wordwrap(text.split(/\s+/), 10)
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # first enumeration.
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
  #     puts "-"*10
  #     #=> ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #
  # mbox contains series of mails which start with Unix From line. So each mail
  # can be extracted by slice before Unix From line.
  #
  #     # parse mbox
  #     open("mbox") { |f|
  #       f.slice_before { |line|
  #         line.start_with? "From "
  #       }.each { |mail|
  #         unix_from = mail.shift
  #         i = mail.index("\n")
  #         header = mail[0...i]
  #         body = mail[(i+1)..-1]
  #         body.pop if body.last == "\n"
  #         fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
  #         p unix_from
  #         pp fields
  #         pp body
  #       }
  #     }
  #
  #     # split mails in mbox (slice before Unix From line after an empty line)
  #     open("mbox") { |f|
  #       emp = true
  #       f.slice_before { |line|
  #         prevemp = emp
  #         emp = line == "\n"
  #         prevemp && line.start_with?("From ")
  #       }.each { |mail|
  #         mail.pop if mail.last == "\n"
  #         pp mail
  #       }
  #     }
  #
  def slice_before: (untyped pattern) -> ::Enumerator[::Array[Elem]]
                  | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem]]
end
%a{annotate:rdoc:skip}
class Enumerator[unchecked out Elem, out Return = void]
  # <!-- rdoc-file=enumerator.c -->
  # Enumerator::Product generates a Cartesian product of any number of enumerable
  # objects.  Iterating over the product of enumerable objects is roughly
  # equivalent to nested each_entry loops where the loop for the rightmost object
  # is put innermost.
  #
  #     innings = Enumerator::Product.new(1..9, ['top', 'bottom'])
  #
  #     innings.each do |i, h|
  #       p [i, h]
  #     end
  #     # [1, "top"]
  #     # [1, "bottom"]
  #     # [2, "top"]
  #     # [2, "bottom"]
  #     # [3, "top"]
  #     # [3, "bottom"]
  #     # ...
  #     # [9, "top"]
  #     # [9, "bottom"]
  #
  # The method used against each enumerable object is `each_entry` instead of
  # `each` so that the product of N enumerable objects yields an array of exactly
  # N elements in each iteration.
  #
  # When no enumerator is given, it calls a given block once yielding an empty
  # argument list.
  #
  # This type of objects can be created by Enumerator.product.
  #
  class Product[unchecked out Elem] < Enumerator[Array[Elem], Product[Elem]]
    # <!--
    #   rdoc-file=enumerator.c
    #   - Enumerator::Product.new(*enums) -> enum
    # -->
    # Generates a new enumerator object that generates a Cartesian product of given
    # enumerable objects.
    #
    #     e = Enumerator::Product.new(1..3, [4, 5])
    #     e.to_a #=> [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
    #     e.size #=> 6
    #
    def initialize: (*_EachEntry[Elem]) -> void

    # <!--
    #   rdoc-file=enumerator.c
    #   - obj.each { |...| ... } -> obj
    #   - obj.each -> enumerator
    # -->
    # Iterates over the elements of the first enumerable by calling the "each_entry"
    # method on it with the given arguments, then proceeds to the following
    # enumerables in sequence until all of the enumerables are exhausted.
    #
    # If no block is given, returns an enumerator.  Otherwise, returns self.
    #
    def each: () { (Array[Elem]) -> void } -> self

    # <!--
    #   rdoc-file=enumerator.c
    #   - obj.inspect -> string
    # -->
    # Returns a printable version of the product enumerator.
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=enumerator.c
    #   - obj.rewind -> obj
    # -->
    # Rewinds the product enumerator by calling the "rewind" method on each
    # enumerable in reverse order.  Each call is performed only if the enumerable
    # responds to the method.
    #
    def rewind: () -> self

    # <!--
    #   rdoc-file=enumerator.c
    #   - obj.size -> int, Float::INFINITY or nil
    # -->
    # Returns the total size of the enumerator product calculated by multiplying the
    # sizes of enumerables in the product.  If any of the enumerables reports its
    # size as nil or Float::INFINITY, that value is returned as the size.
    #
    def size: () -> (Integer | Float | nil)

    private

    def initialize_copy: (Product[Elem]) -> void
  end
end
# <!-- rdoc-file=error.c -->
# When an operating system encounters an error, it typically reports the error
# as an integer error code:
#
#     $ ls nosuch.txt
#     ls: cannot access 'nosuch.txt': No such file or directory
#     $ echo $? # Code for last error.
#     2
#
# When the Ruby interpreter interacts with the operating system and receives
# such an error code (e.g., `2`), it maps the code to a particular Ruby
# exception class (e.g., `Errno::ENOENT`):
#
#     File.open('nosuch.txt')
#     # => No such file or directory @ rb_sysopen - nosuch.txt (Errno::ENOENT)
#
# Each such class is:
#
# *   A nested class in this module, `Errno`.
# *   A subclass of class SystemCallError.
# *   Associated with an error code.
#
# Thus:
#
#     Errno::ENOENT.superclass # => SystemCallError
#     Errno::ENOENT::Errno     # => 2
#
# The names of nested classes are returned by method `Errno.constants`:
#
#     Errno.constants.size         # => 158
#     Errno.constants.sort.take(5) # => [:E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, :EADV]
#
# As seen above, the error code associated with each class is available as the
# value of a constant; the value for a particular class may vary among operating
# systems. If the class is not needed for the particular operating system, the
# value is zero:
#
#     Errno::ENOENT::Errno      # => 2
#     Errno::ENOTCAPABLE::Errno # => 0
#
module Errno
  class NOERROR < SystemCallError
    Errno: 0
  end

  class E2BIG < SystemCallError
    Errno: Integer
  end

  class EACCES < SystemCallError
    Errno: Integer
  end

  class EADDRINUSE < SystemCallError
    Errno: Integer
  end

  class EADDRNOTAVAIL < SystemCallError
    Errno: Integer
  end

  class EADV < SystemCallError
    Errno: Integer
  end

  class EAFNOSUPPORT < SystemCallError
    Errno: Integer
  end

  class EAGAIN < SystemCallError
    Errno: Integer
  end

  class EALREADY < SystemCallError
    Errno: Integer
  end

  class EAUTH < SystemCallError
    Errno: Integer
  end

  class EBADARCH < SystemCallError
    Errno: Integer
  end

  class EBADE < SystemCallError
    Errno: Integer
  end

  class EBADEXEC < SystemCallError
    Errno: Integer
  end

  class EBADF < SystemCallError
    Errno: Integer
  end

  class EBADFD < SystemCallError
    Errno: Integer
  end

  class EBADMACHO < SystemCallError
    Errno: Integer
  end

  class EBADMSG < SystemCallError
    Errno: Integer
  end

  class EBADR < SystemCallError
    Errno: Integer
  end

  class EBADRPC < SystemCallError
    Errno: Integer
  end

  class EBADRQC < SystemCallError
    Errno: Integer
  end

  class EBADSLT < SystemCallError
    Errno: Integer
  end

  class EBFONT < SystemCallError
    Errno: Integer
  end

  class EBUSY < SystemCallError
    Errno: Integer
  end

  class ECANCELED < SystemCallError
    Errno: Integer
  end

  class ECAPMODE < SystemCallError
    Errno: Integer
  end

  class ECHILD < SystemCallError
    Errno: Integer
  end

  class ECHRNG < SystemCallError
    Errno: Integer
  end

  class ECOMM < SystemCallError
    Errno: Integer
  end

  class ECONNABORTED < SystemCallError
    Errno: Integer
  end

  class ECONNREFUSED < SystemCallError
    Errno: Integer
  end

  class ECONNRESET < SystemCallError
    Errno: Integer
  end

  class EDEADLK < SystemCallError
    Errno: Integer
  end

  class EDEADLOCK < SystemCallError
    Errno: Integer
  end

  class EDESTADDRREQ < SystemCallError
    Errno: Integer
  end

  class EDEVERR < SystemCallError
    Errno: Integer
  end

  class EDOM < SystemCallError
    Errno: Integer
  end

  class EDOOFUS < SystemCallError
    Errno: Integer
  end

  class EDOTDOT < SystemCallError
    Errno: Integer
  end

  class EDQUOT < SystemCallError
    Errno: Integer
  end

  class EEXIST < SystemCallError
    Errno: Integer
  end

  class EFAULT < SystemCallError
    Errno: Integer
  end

  class EFBIG < SystemCallError
    Errno: Integer
  end

  class EFTYPE < SystemCallError
    Errno: Integer
  end

  class EHOSTDOWN < SystemCallError
    Errno: Integer
  end

  class EHOSTUNREACH < SystemCallError
    Errno: Integer
  end

  class EHWPOISON < SystemCallError
    Errno: Integer
  end

  class EIDRM < SystemCallError
    Errno: Integer
  end

  class EILSEQ < SystemCallError
    Errno: Integer
  end

  class EINPROGRESS < SystemCallError
    Errno: Integer
  end

  class EINTR < SystemCallError
    Errno: Integer
  end

  class EINVAL < SystemCallError
    Errno: Integer
  end

  class EIO < SystemCallError
    Errno: Integer
  end

  class EIPSEC < SystemCallError
    Errno: Integer
  end

  class EISCONN < SystemCallError
    Errno: Integer
  end

  class EISDIR < SystemCallError
    Errno: Integer
  end

  class EISNAM < SystemCallError
    Errno: Integer
  end

  class EKEYEXPIRED < SystemCallError
    Errno: Integer
  end

  class EKEYREJECTED < SystemCallError
    Errno: Integer
  end

  class EKEYREVOKED < SystemCallError
    Errno: Integer
  end

  class EL2HLT < SystemCallError
    Errno: Integer
  end

  class EL2NSYNC < SystemCallError
    Errno: Integer
  end

  class EL3HLT < SystemCallError
    Errno: Integer
  end

  class EL3RST < SystemCallError
    Errno: Integer
  end

  class ELAST < SystemCallError
    Errno: Integer
  end

  class ELIBACC < SystemCallError
    Errno: Integer
  end

  class ELIBBAD < SystemCallError
    Errno: Integer
  end

  class ELIBEXEC < SystemCallError
    Errno: Integer
  end

  class ELIBMAX < SystemCallError
    Errno: Integer
  end

  class ELIBSCN < SystemCallError
    Errno: Integer
  end

  class ELNRNG < SystemCallError
    Errno: Integer
  end

  class ELOOP < SystemCallError
    Errno: Integer
  end

  class EMEDIUMTYPE < SystemCallError
    Errno: Integer
  end

  class EMFILE < SystemCallError
    Errno: Integer
  end

  class EMLINK < SystemCallError
    Errno: Integer
  end

  class EMSGSIZE < SystemCallError
    Errno: Integer
  end

  class EMULTIHOP < SystemCallError
    Errno: Integer
  end

  class ENAMETOOLONG < SystemCallError
    Errno: Integer
  end

  class ENAVAIL < SystemCallError
    Errno: Integer
  end

  class ENEEDAUTH < SystemCallError
    Errno: Integer
  end

  class ENETDOWN < SystemCallError
    Errno: Integer
  end

  class ENETRESET < SystemCallError
    Errno: Integer
  end

  class ENETUNREACH < SystemCallError
    Errno: Integer
  end

  class ENFILE < SystemCallError
    Errno: Integer
  end

  class ENOANO < SystemCallError
    Errno: Integer
  end

  class ENOATTR < SystemCallError
    Errno: Integer
  end

  class ENOBUFS < SystemCallError
    Errno: Integer
  end

  class ENOCSI < SystemCallError
    Errno: Integer
  end

  class ENODATA < SystemCallError
    Errno: Integer
  end

  class ENODEV < SystemCallError
    Errno: Integer
  end

  class ENOENT < SystemCallError
    Errno: Integer
  end

  class ENOEXEC < SystemCallError
    Errno: Integer
  end

  class ENOKEY < SystemCallError
    Errno: Integer
  end

  class ENOLCK < SystemCallError
    Errno: Integer
  end

  class ENOLINK < SystemCallError
    Errno: Integer
  end

  class ENOMEDIUM < SystemCallError
    Errno: Integer
  end

  class ENOMEM < SystemCallError
    Errno: Integer
  end

  class ENOMSG < SystemCallError
    Errno: Integer
  end

  class ENONET < SystemCallError
    Errno: Integer
  end

  class ENOPKG < SystemCallError
    Errno: Integer
  end

  class ENOPOLICY < SystemCallError
    Errno: Integer
  end

  class ENOPROTOOPT < SystemCallError
    Errno: Integer
  end

  class ENOSPC < SystemCallError
    Errno: Integer
  end

  class ENOSR < SystemCallError
    Errno: Integer
  end

  class ENOSTR < SystemCallError
    Errno: Integer
  end

  class ENOSYS < SystemCallError
    Errno: Integer
  end

  class ENOTBLK < SystemCallError
    Errno: Integer
  end

  class ENOTCAPABLE < SystemCallError
    Errno: Integer
  end

  class ENOTCONN < SystemCallError
    Errno: Integer
  end

  class ENOTDIR < SystemCallError
    Errno: Integer
  end

  class ENOTEMPTY < SystemCallError
    Errno: Integer
  end

  class ENOTNAM < SystemCallError
    Errno: Integer
  end

  class ENOTRECOVERABLE < SystemCallError
    Errno: Integer
  end

  class ENOTSOCK < SystemCallError
    Errno: Integer
  end

  class ENOTSUP < SystemCallError
    Errno: Integer
  end

  class ENOTTY < SystemCallError
    Errno: Integer
  end

  class ENOTUNIQ < SystemCallError
    Errno: Integer
  end

  class ENXIO < SystemCallError
    Errno: Integer
  end

  class EOPNOTSUPP < SystemCallError
    Errno: Integer
  end

  class EOVERFLOW < SystemCallError
    Errno: Integer
  end

  class EOWNERDEAD < SystemCallError
    Errno: Integer
  end

  class EPERM < SystemCallError
    Errno: Integer
  end

  class EPFNOSUPPORT < SystemCallError
    Errno: Integer
  end

  class EPIPE < SystemCallError
    Errno: Integer
  end

  class EPROCLIM < SystemCallError
    Errno: Integer
  end

  class EPROCUNAVAIL < SystemCallError
    Errno: Integer
  end

  class EPROGMISMATCH < SystemCallError
    Errno: Integer
  end

  class EPROGUNAVAIL < SystemCallError
    Errno: Integer
  end

  class EPROTO < SystemCallError
    Errno: Integer
  end

  class EPROTONOSUPPORT < SystemCallError
    Errno: Integer
  end

  class EPROTOTYPE < SystemCallError
    Errno: Integer
  end

  class EPWROFF < SystemCallError
    Errno: Integer
  end

  class EQFULL < SystemCallError
    Errno: Integer
  end

  class ERANGE < SystemCallError
    Errno: Integer
  end

  class EREMCHG < SystemCallError
    Errno: Integer
  end

  class EREMOTE < SystemCallError
    Errno: Integer
  end

  class EREMOTEIO < SystemCallError
    Errno: Integer
  end

  class ERESTART < SystemCallError
    Errno: Integer
  end

  class ERFKILL < SystemCallError
    Errno: Integer
  end

  class EROFS < SystemCallError
    Errno: Integer
  end

  class ERPCMISMATCH < SystemCallError
    Errno: Integer
  end

  class ESHLIBVERS < SystemCallError
    Errno: Integer
  end

  class ESHUTDOWN < SystemCallError
    Errno: Integer
  end

  class ESOCKTNOSUPPORT < SystemCallError
    Errno: Integer
  end

  class ESPIPE < SystemCallError
    Errno: Integer
  end

  class ESRCH < SystemCallError
    Errno: Integer
  end

  class ESRMNT < SystemCallError
    Errno: Integer
  end

  class ESTALE < SystemCallError
    Errno: Integer
  end

  class ESTRPIPE < SystemCallError
    Errno: Integer
  end

  class ETIME < SystemCallError
    Errno: Integer
  end

  class ETIMEDOUT < SystemCallError
    Errno: Integer
  end

  class ETOOMANYREFS < SystemCallError
    Errno: Integer
  end

  class ETXTBSY < SystemCallError
    Errno: Integer
  end

  class EUCLEAN < SystemCallError
    Errno: Integer
  end

  class EUNATCH < SystemCallError
    Errno: Integer
  end

  class EUSERS < SystemCallError
    Errno: Integer
  end

  class EWOULDBLOCK < SystemCallError
    Errno: Integer
  end

  class EXDEV < SystemCallError
    Errno: Integer
  end

  class EXFULL < SystemCallError
    Errno: Integer
  end
end
# <!-- rdoc-file=dir.rb -->
# An object of class Dir represents a directory in the underlying file system.
#
# It consists mainly of:
#
# *   A string *path*, given when the object is created, that specifies a
#     directory in the underlying file system; method #path returns the path.
# *   A collection of string *entry names*, each of which is the name of a
#     directory or file in the underlying file system; the entry names may be
#     retrieved in an [array-like fashion](rdoc-ref:Dir@Dir+As+Array-Like) or in
#     a [stream-like fashion](rdoc-ref:Dir@Dir+As+Stream-Like).
#
# ## About the Examples
#
# Some examples on this page use this simple file tree:
#
#     example/
#      config.h
#      lib/
#         song/
#            karaoke.rb
#         song.rb
#      main.rb
#
# Others use the file tree for the [Ruby project
# itself](https://github.com/ruby/ruby).
#
# ## Dir As Array-Like
#
# A Dir object is in some ways array-like:
#
# *   It has instance methods #children, #each, and #each_child.
# *   It includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here).
#
# ## Dir As Stream-Like
#
# A Dir object is in some ways stream-like.
#
# The stream is initially open for reading, but may be closed manually (using
# method #close), and will be closed on block exit if created by Dir.open called
# with a block. The closed stream may not be further manipulated, and may not be
# reopened.
#
# The stream has a *position*, which is the index of an entry in the directory:
#
# *   The initial position is zero (before the first entry).
# *   Method #tell (aliased as #pos) returns the position.
# *   Method #pos= sets the position (but ignores a value outside the stream),
#     and returns the position.
# *   Method #seek is like #pos=, but returns `self` (convenient for chaining).
# *   Method #read, if not at end-of-stream, reads the next entry and increments
#     the position; if at end-of-stream, does not increment the position.
# *   Method #rewind sets the position to zero.
#
# Examples (using the [simple file tree](rdoc-ref:Dir@About+the+Examples)):
#
#     dir = Dir.new('example') # => #<Dir:example>
#     dir.pos                  # => 0
#
#     dir.read # => "."
#     dir.read # => ".."
#     dir.read # => "config.h"
#     dir.read # => "lib"
#     dir.read # => "main.rb"
#     dir.pos  # => 5
#     dir.read # => nil
#     dir.pos  # => 5
#
#     dir.rewind # => #<Dir:example>
#     dir.pos    # => 0
#
#     dir.pos = 3 # => 3
#     dir.pos     # => 3
#
#     dir.seek(4) # => #<Dir:example>
#     dir.pos     # => 4
#
#     dir.close # => nil
#     dir.read  # Raises IOError.
#
# ## What's Here
#
# First, what's elsewhere. Class Dir:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# Here, class Dir provides methods that are useful for:
#
# *   [Reading](rdoc-ref:Dir@Reading)
# *   [Setting](rdoc-ref:Dir@Setting)
# *   [Querying](rdoc-ref:Dir@Querying)
# *   [Iterating](rdoc-ref:Dir@Iterating)
# *   [Other](rdoc-ref:Dir@Other)
#
# ### Reading
#
# *   #close: Closes the directory stream for `self`.
# *   #pos=: Sets the position in the directory stream for `self`.
# *   #read: Reads and returns the next entry in the directory stream for
#     `self`.
# *   #rewind: Sets the position in the directory stream for `self` to the first
#     entry.
# *   #seek: Sets the position in the directory stream for `self` the entry at
#     the given offset.
#
# ### Setting
#
# *   ::chdir: Changes the working directory of the current process to the given
#     directory.
# *   ::chroot: Changes the file-system root for the current process to the
#     given directory.
#
# ### Querying
#
# *   ::[]: Same as ::glob without the ability to pass flags.
# *   ::children: Returns an array of names of the children (both files and
#     directories) of the given directory, but not including `.` or `..`.
# *   ::empty?: Returns whether the given path is an empty directory.
# *   ::entries: Returns an array of names of the children (both files and
#     directories) of the given directory, including `.` and `..`.
# *   ::exist?: Returns whether the given path is a directory.
# *   ::getwd (aliased as #pwd): Returns the path to the current working
#     directory.
# *   ::glob: Returns an array of file paths matching the given pattern and
#     flags.
# *   ::home: Returns the home directory path for a given user or the current
#     user.
# *   #children: Returns an array of names of the children (both files and
#     directories) of `self`, but not including `.` or `..`.
# *   #fileno: Returns the integer file descriptor for `self`.
# *   #path (aliased as #to_path): Returns the path used to create `self`.
# *   #tell (aliased as #pos): Returns the integer position in the directory
#     stream for `self`.
#
# ### Iterating
#
# *   ::each_child: Calls the given block with each entry in the given
#     directory, but not including `.` or `..`.
# *   ::foreach: Calls the given block with each entry in the given directory,
#     including `.` and `..`.
# *   #each: Calls the given block with each entry in `self`, including `.` and
#     `..`.
# *   #each_child: Calls the given block with each entry in `self`, but not
#     including `.` or `..`.
#
# ### Other
#
# *   ::mkdir: Creates a directory at the given path, with optional permissions.
# *   ::new: Returns a new Dir for the given path, with optional encoding.
# *   ::open: Same as ::new, but if a block is given, yields the Dir to the
#     block, closing it upon block exit.
# *   ::unlink (aliased as ::delete and ::rmdir): Removes the given directory.
# *   #inspect: Returns a string description of `self`.
#
class Dir
  include Enumerable[String]

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.new(dirpath) -> dir
  #   - Dir.new(dirpath, encoding: nil) -> dir
  # -->
  # Returns a new Dir object for the directory at `dirpath`:
  #
  #     Dir.new('.') # => #<Dir:.>
  #
  # The value given with optional keyword argument `encoding` specifies the
  # encoding for the directory entry names; if `nil` (the default), the file
  # system's encoding is used:
  #
  #     Dir.new('.').read.encoding                       # => #<Encoding:UTF-8>
  #     Dir.new('.', encoding: 'US-ASCII').read.encoding # => #<Encoding:US-ASCII>
  #
  def initialize: (path dir, ?encoding: encoding?) -> void

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir[*patterns, base: nil, sort: true] -> array
  # -->
  # Calls Dir.glob with argument `patterns` and the values of keyword arguments
  # `base` and `sort`; returns the array of selected entry names.
  #
  def self.[]: (*path patterns, ?base: path?, ?sort: bool) -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chdir(new_dirpath) -> 0
  #   - Dir.chdir -> 0
  #   - Dir.chdir(new_dirpath) {|new_dirpath| ... } -> object
  #   - Dir.chdir {|cur_dirpath| ... } -> object
  # -->
  # Changes the current working directory.
  #
  # With argument `new_dirpath` and no block, changes to the given `dirpath`:
  #
  #     Dir.pwd         # => "/example"
  #     Dir.chdir('..') # => 0
  #     Dir.pwd         # => "/"
  #
  # With no argument and no block:
  #
  # *   Changes to the value of environment variable `HOME` if defined.
  # *   Otherwise changes to the value of environment variable `LOGDIR` if
  #     defined.
  # *   Otherwise makes no change.
  #
  # With argument `new_dirpath` and a block, temporarily changes the working
  # directory:
  #
  # *   Calls the block with the argument.
  # *   Changes to the given directory.
  # *   Executes the block (yielding the new path).
  # *   Restores the previous working directory.
  # *   Returns the block's return value.
  #
  # Example:
  #
  #     Dir.chdir('/var/spool/mail')
  #     Dir.pwd   # => "/var/spool/mail"
  #     Dir.chdir('/tmp') do
  #       Dir.pwd # => "/tmp"
  #     end
  #     Dir.pwd   # => "/var/spool/mail"
  #
  # With no argument and a block, calls the block with the current working
  # directory (string) and returns the block's return value.
  #
  # Calls to Dir.chdir with blocks may be nested:
  #
  #     Dir.chdir('/var/spool/mail')
  #     Dir.pwd     # => "/var/spool/mail"
  #     Dir.chdir('/tmp') do
  #       Dir.pwd   # => "/tmp"
  #       Dir.chdir('/usr') do
  #         Dir.pwd # => "/usr"
  #       end
  #       Dir.pwd   # => "/tmp"
  #     end
  #     Dir.pwd     # => "/var/spool/mail"
  #
  # In a multi-threaded program an error is raised if a thread attempts to open a
  # `chdir` block while another thread has one open, or a call to `chdir` without
  # a block occurs inside a block passed to `chdir` (even in the same thread).
  #
  # Raises an exception if the target directory does not exist.
  #
  def self.chdir: (?path dir) -> 0
                | [U] (?path dir) { (String dir) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.children(dirpath) -> array
  #   - Dir.children(dirpath, encoding: 'UTF-8') -> array
  # -->
  # Returns an array of the entry names in the directory at `dirpath` except for
  # `'.'` and `'..'`; sets the given encoding onto each returned entry name:
  #
  #     Dir.children('/example') # => ["config.h", "lib", "main.rb"]
  #     Dir.children('/example').first.encoding
  #     # => #<Encoding:UTF-8>
  #     Dir.children('/example', encoding: 'US-ASCII').first.encoding
  #     # => #<Encoding:US-ASCII>
  #
  # See [String Encoding](rdoc-ref:encodings.rdoc@String+Encoding).
  #
  # Raises an exception if the directory does not exist.
  #
  def self.children: (path dirname, ?encoding: encoding?) -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chroot(dirpath) -> 0
  # -->
  # Changes the root directory of the calling process to that specified in
  # `dirpath`. The new root directory is used for pathnames beginning with `'/'`.
  # The root directory is inherited by all children of the calling process.
  #
  # Only a privileged process may call `chroot`.
  #
  # See [Linux chroot](https://man7.org/linux/man-pages/man2/chroot.2.html).
  #
  def self.chroot: (path root) -> 0

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.rmdir(dirpath) -> 0
  # -->
  # Removes the directory at `dirpath` from the underlying file system:
  #
  #     Dir.rmdir('foo') # => 0
  #
  # Raises an exception if the directory is not empty.
  #
  def self.delete: (path dirname) -> 0

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.each_child(dirpath) {|entry_name| ... } -> nil
  #   - Dir.each_child(dirpath, encoding: 'UTF-8') {|entry_name| ... }  -> nil
  # -->
  # Like Dir.foreach, except that entries `'.'` and `'..'` are not included.
  #
  def self.each_child: (path dirname, ?encoding: encoding?) -> Enumerator[String, nil]
                     | (path dirname, ?encoding: encoding?) { (String filename) -> void } -> nil

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.empty?(dirpath) ->  true or false
  # -->
  # Returns whether `dirpath` specifies an empty directory:
  #
  #     dirpath = '/tmp/foo'
  #     Dir.mkdir(dirpath)
  #     Dir.empty?(dirpath)            # => true
  #     Dir.empty?('/example')         # => false
  #     Dir.empty?('/example/main.rb') # => false
  #
  # Raises an exception if `dirpath` does not specify a directory or file in the
  # underlying file system.
  #
  def self.empty?: (path path_name) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.entries(dirname, encoding: 'UTF-8') -> array
  # -->
  # Returns an array of the entry names in the directory at `dirpath`; sets the
  # given encoding onto each returned entry name:
  #
  #     Dir.entries('/example') # => ["config.h", "lib", "main.rb", "..", "."]
  #     Dir.entries('/example').first.encoding
  #     # => #<Encoding:UTF-8>
  #     Dir.entries('/example', encoding: 'US-ASCII').first.encoding
  #     # => #<Encoding:US-ASCII>
  #
  # See [String Encoding](rdoc-ref:encodings.rdoc@String+Encoding).
  #
  # Raises an exception if the directory does not exist.
  #
  def self.entries: (path dirname, ?encoding: encoding?) -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.exist?(dirpath) ->  true or false
  # -->
  # Returns whether `dirpath` is a directory in the underlying file system:
  #
  #     Dir.exist?('/example')         # => true
  #     Dir.exist?('/nosuch')          # => false
  #     Dir.exist?('/example/main.rb') # => false
  #
  # Same as File.directory?.
  #
  def self.exist?: (path | io file_name) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.fchdir(fd) -> 0
  #   - Dir.fchdir(fd) { ... } -> object
  # -->
  # Changes the current working directory to the directory specified by the
  # integer file descriptor `fd`.
  #
  # When passing a file descriptor over a UNIX socket or to a child process, using
  # `fchdir` instead of `chdir` avoids the [time-of-check to time-of-use
  # vulnerability](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)
  #
  # With no block, changes to the directory given by `fd`:
  #
  #     Dir.chdir('/var/spool/mail')
  #     Dir.pwd # => "/var/spool/mail"
  #     dir  = Dir.new('/usr')
  #     fd = dir.fileno
  #     Dir.fchdir(fd)
  #     Dir.pwd # => "/usr"
  #
  # With a block, temporarily changes the working directory:
  #
  # *   Calls the block with the argument.
  # *   Changes to the given directory.
  # *   Executes the block (yields no args).
  # *   Restores the previous working directory.
  # *   Returns the block's return value.
  #
  # Example:
  #
  #     Dir.chdir('/var/spool/mail')
  #     Dir.pwd # => "/var/spool/mail"
  #     dir  = Dir.new('/tmp')
  #     fd = dir.fileno
  #     Dir.fchdir(fd) do
  #       Dir.pwd # => "/tmp"
  #     end
  #     Dir.pwd # => "/var/spool/mail"
  #
  # This method uses the
  # [fchdir()](https://www.man7.org/linux/man-pages/man3/fchdir.3p.html) function
  # defined by POSIX 2008; the method is not implemented on non-POSIX platforms
  # (raises NotImplementedError).
  #
  # Raises an exception if the file descriptor is not valid.
  #
  # In a multi-threaded program an error is raised if a thread attempts to open a
  # `chdir` block while another thread has one open, or a call to `chdir` without
  # a block occurs inside a block passed to `chdir` (even in the same thread).
  #
  def self.fchdir: (int) -> Integer
                 | [T] (int) { () -> T } -> T

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.foreach(dirpath, encoding: 'UTF-8') {|entry_name| ... }  -> nil
  # -->
  # Calls the block with each entry name in the directory at `dirpath`; sets the
  # given encoding onto each passed `entry_name`:
  #
  #     Dir.foreach('/example') {|entry_name| p entry_name }
  #
  # Output:
  #
  #     "config.h"
  #     "lib"
  #     "main.rb"
  #     ".."
  #     "."
  #
  # Encoding:
  #
  #     Dir.foreach('/example') {|entry_name| p entry_name.encoding; break }
  #     Dir.foreach('/example', encoding: 'US-ASCII') {|entry_name| p entry_name.encoding; break }
  #
  # Output:
  #
  #     #<Encoding:UTF-8>
  #     #<Encoding:US-ASCII>
  #
  # See [String Encoding](rdoc-ref:encodings.rdoc@String+Encoding).
  #
  # Returns an enumerator if no block is given.
  #
  alias self.foreach self.each_child

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.for_fd(fd) -> dir
  # -->
  # Returns a new Dir object representing the directory specified by the given
  # integer directory file descriptor `fd`:
  #
  #     d0 = Dir.new('..')
  #     d1 = Dir.for_fd(d0.fileno)
  #
  # Note that the returned `d1` does not have an associated path:
  #
  #     d0.path # => '..'
  #     d1.path # => nil
  #
  # This method uses the
  # [fdopendir()](https://www.man7.org/linux/man-pages/man3/fdopendir.3p.html)
  # function defined by POSIX 2008; the method is not implemented on non-POSIX
  # platforms (raises NotImplementedError).
  #
  def self.for_fd: (int) -> Dir

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory:
  #
  #     Dir.chdir("/tmp") # => 0
  #     Dir.pwd           # => "/tmp"
  #
  def self.getwd: () -> String

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.glob(*patterns, flags: 0, base: nil, sort: true) -> array
  #   - Dir.glob(*patterns, flags: 0, base: nil, sort: true) {|entry_name| ... } -> nil
  # -->
  # Forms an array *entry_names* of the entry names selected by the arguments.
  #
  # Argument `patterns` is a string pattern or an array of string patterns; note
  # that these are not regexps; see below.
  #
  # Notes for the following examples:
  #
  # *   `'*'` is the pattern that matches any entry name except those that begin
  #     with `'.'`.
  # *   We use method Array#take to shorten returned arrays that otherwise would
  #     be very large.
  #
  # With no block, returns array *entry_names*; example (using the [simple file
  # tree](rdoc-ref:Dir@About+the+Examples)):
  #
  #     Dir.glob('*') # => ["config.h", "lib", "main.rb"]
  #
  # With a block, calls the block with each of the *entry_names* and returns
  # `nil`:
  #
  #     Dir.glob('*') {|entry_name| puts entry_name } # => nil
  #
  # Output:
  #
  #     config.h
  #     lib
  #     main.rb
  #
  # If optional keyword argument `flags` is given, the value modifies the
  # matching; see below.
  #
  # If optional keyword argument `base` is given, its value specifies the base
  # directory. Each pattern string specifies entries relative to the base
  # directory; the default is `'.'`. The base directory is not prepended to the
  # entry names in the result:
  #
  #     Dir.glob(pattern, base: 'lib').take(5)
  #     # => ["abbrev.gemspec", "abbrev.rb", "base64.gemspec", "base64.rb", "benchmark.gemspec"]
  #     Dir.glob(pattern, base: 'lib/irb').take(5)
  #     # => ["cmd", "color.rb", "color_printer.rb", "completion.rb", "context.rb"]
  #
  # If optional keyword `sort` is given, its value specifies whether the array is
  # to be sorted; the default is `true`. Passing value `false` with that keyword
  # disables sorting (though the underlying file system may already have sorted
  # the array).
  #
  # **Patterns**
  #
  # Each pattern string is expanded according to certain metacharacters; examples
  # below use the [Ruby file tree](rdoc-ref:Dir@About+the+Examples):
  #
  # *   `'*'`: Matches any substring in an entry name, similar in meaning to
  #     regexp `/.*/mx`; may be restricted by other values in the pattern strings:
  #
  #     *   `'*'` matches all entry names:
  #
  #             Dir.glob('*').take(3)  # => ["BSDL", "CONTRIBUTING.md", "COPYING"]
  #
  #     *   `'c*'` matches entry names beginning with `'c'`:
  #
  #             Dir.glob('c*').take(3) # => ["CONTRIBUTING.md", "COPYING", "COPYING.ja"]
  #
  #     *   `'*c'` matches entry names ending with `'c'`:
  #
  #             Dir.glob('*c').take(3) # => ["addr2line.c", "array.c", "ast.c"]
  #
  #     *   `'*c*'` matches entry names that contain `'c'`, even at the beginning
  #         or end:
  #
  #             Dir.glob('*c*').take(3) # => ["CONTRIBUTING.md", "COPYING", "COPYING.ja"]
  #
  #     Does not match Unix-like hidden entry names ("dot files"). To include
  #     those in the matched entry names, use flag IO::FNM_DOTMATCH or something
  #     like `'{*,.*}'`.
  #
  # *   `'**'`: Matches entry names recursively if followed by  the slash
  #     character `'/'`:
  #
  #         Dir.glob('**/').take(3) # => ["basictest/", "benchmark/", "benchmark/gc/"]
  #
  #     If the string pattern contains other characters or is not followed by a
  #     slash character, it is equivalent to `'*'`.
  #
  # *   `'?'` Matches any single character; similar in meaning to regexp `/./`:
  #
  #         Dir.glob('io.?') # => ["io.c"]
  #
  # *   `'[*set*]'`: Matches any one character in the string *set*; behaves like a
  #     [Regexp character class](rdoc-ref:Regexp@Character+Classes), including set
  #     negation (`'[^a-z]'`):
  #
  #         Dir.glob('*.[a-z][a-z]').take(3)
  #         # => ["CONTRIBUTING.md", "COPYING.ja", "KNOWNBUGS.rb"]
  #
  # *   `'{*abc*,*xyz*}'`: Matches either string *abc* or string *xyz*; behaves
  #     like [Regexp alternation](rdoc-ref:Regexp@Alternation):
  #
  #         Dir.glob('{LEGAL,BSDL}') # => ["LEGAL", "BSDL"]
  #
  #     More than two alternatives may be given.
  #
  # *   `\`: Escapes the following metacharacter.
  #
  #     Note that on Windows, the backslash character may not be used in a string
  #     pattern: `Dir['c:\\foo*']` will not work, use `Dir['c:/foo*']` instead.
  #
  # More examples (using the [simple file tree](rdoc-ref:Dir@About+the+Examples)):
  #
  #     # We're in the example directory.
  #     File.basename(Dir.pwd) # => "example"
  #     Dir.glob('config.?')              # => ["config.h"]
  #     Dir.glob('*.[a-z][a-z]')          # => ["main.rb"]
  #     Dir.glob('*.[^r]*')               # => ["config.h"]
  #     Dir.glob('*.{rb,h}')              # => ["main.rb", "config.h"]
  #     Dir.glob('*')                     # => ["config.h", "lib", "main.rb"]
  #     Dir.glob('*', File::FNM_DOTMATCH) # => [".", "config.h", "lib", "main.rb"]
  #     Dir.glob(["*.rb", "*.h"])         # => ["main.rb", "config.h"]
  #
  #     Dir.glob('**/*.rb')
  #     => ["lib/song/karaoke.rb", "lib/song.rb", "main.rb"]
  #
  #     Dir.glob('**/*.rb', base: 'lib')  #   => ["song/karaoke.rb", "song.rb"]
  #
  #     Dir.glob('**/lib')                # => ["lib"]
  #
  #     Dir.glob('**/lib/**/*.rb')        # => ["lib/song/karaoke.rb", "lib/song.rb"]
  #
  #     Dir.glob('**/lib/*.rb')           # => ["lib/song.rb"]
  #
  # **Flags**
  #
  # If optional keyword argument `flags` is given (the default is zero -- no
  # flags), its value should be the bitwise OR of one or more of the constants
  # defined in module File::Constants.
  #
  # Example:
  #
  #     flags = File::FNM_EXTGLOB | File::FNM_DOTMATCH
  #
  # Specifying flags can extend, restrict, or otherwise modify the matching.
  #
  # The flags for this method (other constants in File::Constants do not apply):
  #
  # *   File::FNM_DOTMATCH: specifies that entry names beginning with `'.'` should
  #     be considered for matching:
  #
  #         Dir.glob('*').take(5)
  #         # => ["BSDL", "CONTRIBUTING.md", "COPYING", "COPYING.ja", "GPL"]
  #         Dir.glob('*', flags: File::FNM_DOTMATCH).take(5)
  #         # => [".", ".appveyor.yml", ".cirrus.yml", ".dir-locals.el", ".document"]
  #
  # *   File::FNM_EXTGLOB: enables the pattern extension `'{*a*,*b*}'`, which
  #     matches pattern *a* and pattern *b*; behaves like a [regexp
  #     union](rdoc-ref:Regexp.union) (e.g., `'(?:*a*|*b*)'`):
  #
  #         pattern = '{LEGAL,BSDL}'
  #         Dir.glob(pattern)      # => ["LEGAL", "BSDL"]
  #
  # *   File::FNM_NOESCAPE: specifies that escaping with the backslash character
  #     `'\'` is disabled; the character is not an escape character.
  #
  # *   File::FNM_PATHNAME: specifies that metacharacters `'*'` and `'?'` do not
  #     match directory separators.
  #
  # *   File::FNM_SHORTNAME: specifies that patterns may match short names if they
  #     exist; Windows only.
  #
  def self.glob: (array[path] | path pattern, ?int flags, ?base: path?, ?sort: bool) -> Array[String]
               | (array[path] | path pattern, ?int flags, ?base: path?, ?sort: bool) { (String pathname) -> void } -> nil

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.home(user_name = nil) -> dirpath
  # -->
  # Returns the home directory path of the user specified with `user_name` if it
  # is not `nil`, or the current login user:
  #
  #     Dir.home         # => "/home/me"
  #     Dir.home('root') # => "/root"
  #
  # Raises ArgumentError if `user_name` is not a user name.
  #
  def self.home: (?string? user) -> String

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.mkdir(dirpath, permissions = 0775) -> 0
  # -->
  # Creates a directory in the underlying file system at `dirpath` with the given
  # `permissions`; returns zero:
  #
  #     Dir.mkdir('foo')
  #     File.stat(Dir.new('foo')).mode.to_s(8)[1..4] # => "0755"
  #     Dir.mkdir('bar', 0644)
  #     File.stat(Dir.new('bar')).mode.to_s(8)[1..4] # => "0644"
  #
  # See [File Permissions](rdoc-ref:File@File+Permissions). Note that argument
  # `permissions` is ignored on Windows.
  #
  def self.mkdir: (path dirname, ?int permissions) -> 0

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.open(dirpath) -> dir
  #   - Dir.open(dirpath, encoding: nil) -> dir
  #   - Dir.open(dirpath) {|dir| ... } -> object
  #   - Dir.open(dirpath, encoding: nil) {|dir| ... } -> object
  # -->
  # Creates a new Dir object *dir* for the directory at `dirpath`.
  #
  # With no block, the method equivalent to Dir.new(dirpath, encoding):
  #
  #     Dir.open('.') # => #<Dir:.>
  #
  # With a block given, the block is called with the created *dir*; on block exit
  # *dir* is closed and the block's value is returned:
  #
  #     Dir.open('.') {|dir| dir.inspect } # => "#<Dir:.>"
  #
  # The value given with optional keyword argument `encoding` specifies the
  # encoding for the directory entry names; if `nil` (the default), the file
  # system's encoding is used:
  #
  #     Dir.open('.').read.encoding                       # => #<Encoding:UTF-8>
  #     Dir.open('.', encoding: 'US-ASCII').read.encoding # => #<Encoding:US-ASCII>
  #
  def self.open: (path dirname, ?encoding: encoding?) -> instance
               | [U] (path dirname, ?encoding: encoding?) { (instance) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory:
  #
  #     Dir.chdir("/tmp") # => 0
  #     Dir.pwd           # => "/tmp"
  #
  alias self.pwd self.getwd

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.rmdir(dirpath) -> 0
  # -->
  # Removes the directory at `dirpath` from the underlying file system:
  #
  #     Dir.rmdir('foo') # => 0
  #
  # Raises an exception if the directory is not empty.
  #
  alias self.rmdir self.delete

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.rmdir(dirpath) -> 0
  # -->
  # Removes the directory at `dirpath` from the underlying file system:
  #
  #     Dir.rmdir('foo') # => 0
  #
  # Raises an exception if the directory is not empty.
  #
  alias self.unlink self.delete

  # <!--
  #   rdoc-file=dir.c
  #   - chdir -> 0
  #   - chdir { ... } -> object
  # -->
  # Changes the current working directory to `self`:
  #
  #     Dir.pwd # => "/"
  #     dir = Dir.new('example')
  #     dir.chdir
  #     Dir.pwd # => "/example"
  #
  # With a block, temporarily changes the working directory:
  #
  # *   Calls the block.
  # *   Changes to the given directory.
  # *   Executes the block (yields no args).
  # *   Restores the previous working directory.
  # *   Returns the block's return value.
  #
  # Uses Dir.fchdir if available, and Dir.chdir if not, see those methods for
  # caveats.
  #
  def chdir: () -> Integer
           | [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=dir.c
  #   - children -> array
  # -->
  # Returns an array of the entry names in `self` except for `'.'` and `'..'`:
  #
  #     dir = Dir.new('/example')
  #     dir.children # => ["config.h", "lib", "main.rb"]
  #
  def children: () -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - close -> nil
  # -->
  # Closes the stream in `self`, if it is open, and returns `nil`; ignored if
  # `self` is already closed:
  #
  #     dir = Dir.new('example')
  #     dir.read     # => "."
  #     dir.close     # => nil
  #     dir.close     # => nil
  #     dir.read # Raises IOError.
  #
  def close: () -> nil

  # <!--
  #   rdoc-file=dir.c
  #   - each {|entry_name| ... } -> self
  # -->
  # Calls the block with each entry name in `self`:
  #
  #     Dir.new('example').each {|entry_name| p entry_name }
  #
  # Output:
  #
  #     "."
  #     ".."
  #     "config.h"
  #     "lib"
  #     "main.rb"
  #
  # With no block given, returns an Enumerator.
  #
  def each: () { (String) -> void } -> self
          | () -> Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - each_child {|entry_name| ... } -> self
  # -->
  # Calls the block with each entry name in `self` except `'.'` and `'..'`:
  #
  #     dir = Dir.new('/example')
  #     dir.each_child {|entry_name| p entry_name }
  #
  # Output:
  #
  #     "config.h"
  #     "lib"
  #     "main.rb"
  #
  # If no block is given, returns an enumerator.
  #
  def each_child: () { (String) -> void } -> self
                | () -> Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - fileno -> integer
  # -->
  # Returns the file descriptor used in *dir*.
  #
  #     d = Dir.new('..')
  #     d.fileno # => 8
  #
  # This method uses the
  # [dirfd()](https://www.man7.org/linux/man-pages/man3/dirfd.3.html) function
  # defined by POSIX 2008; the method is not implemented on non-POSIX platforms
  # (raises NotImplementedError).
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - inspect -> string
  # -->
  # Returns a string description of `self`:
  #
  #     Dir.new('example').inspect # => "#<Dir:example>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=dir.c
  #   - path -> string or nil
  # -->
  # Returns the `dirpath` string that was used to create `self` (or `nil` if
  # created by method Dir.for_fd):
  #
  #     Dir.new('example').path # => "example"
  #
  def path: () -> String?

  # <!-- rdoc-file=dir.c -->
  # Returns the current position of `self`; see [Dir As
  # Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like):
  #
  #     dir = Dir.new('example')
  #     dir.tell  # => 0
  #     dir.read  # => "."
  #     dir.tell  # => 1
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - pos = position -> integer
  # -->
  # Sets the position in `self` and returns `position`. The value of `position`
  # should have been returned from an earlier call to #tell; if not, the return
  # values from subsequent calls to #read are unspecified.
  #
  # See [Dir As Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like).
  #
  # Examples:
  #
  #     dir = Dir.new('example')
  #     dir.pos      # => 0
  #     dir.pos = 3  # => 3
  #     dir.pos      # => 3
  #     dir.pos = 30 # => 30
  #     dir.pos      # => 5
  #
  def pos=: [U < _ToInt] (U pos) -> U

  # <!--
  #   rdoc-file=dir.c
  #   - read -> string or nil
  # -->
  # Reads and returns the next entry name from `self`; returns `nil` if at
  # end-of-stream; see [Dir As Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like):
  #
  #     dir = Dir.new('example')
  #     dir.read # => "."
  #     dir.read # => ".."
  #     dir.read # => "config.h"
  #
  def read: () -> String?

  # <!--
  #   rdoc-file=dir.c
  #   - rewind -> self
  # -->
  # Sets the position in `self` to zero; see [Dir As
  # Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like):
  #
  #     dir = Dir.new('example')
  #     dir.read    # => "."
  #     dir.read    # => ".."
  #     dir.pos     # => 2
  #     dir.rewind  # => #<Dir:example>
  #     dir.pos     # => 0
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=dir.c
  #   - seek(position) -> self
  # -->
  # Sets the position in `self` and returns `self`. The value of `position` should
  # have been returned from an earlier call to #tell; if not, the return values
  # from subsequent calls to #read are unspecified.
  #
  # See [Dir As Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like).
  #
  # Examples:
  #
  #     dir = Dir.new('example')
  #     dir.pos      # => 0
  #     dir.seek(3)  # => #<Dir:example>
  #     dir.pos      # => 3
  #     dir.seek(30) # => #<Dir:example>
  #     dir.pos      # => 5
  #
  def seek: (int pos) -> self

  # <!--
  #   rdoc-file=dir.c
  #   - tell -> integer
  # -->
  # Returns the current position of `self`; see [Dir As
  # Stream-Like](rdoc-ref:Dir@Dir+As+Stream-Like):
  #
  #     dir = Dir.new('example')
  #     dir.tell  # => 0
  #     dir.read  # => "."
  #     dir.tell  # => 1
  #
  alias tell pos

  # <!-- rdoc-file=dir.c -->
  # Returns the `dirpath` string that was used to create `self` (or `nil` if
  # created by method Dir.for_fd):
  #
  #     Dir.new('example').path # => "example"
  #
  alias to_path path
end
# <!-- rdoc-file=object.c -->
# A Module is a collection of methods and constants. The methods in a module may
# be instance methods or module methods. Instance methods appear as methods in a
# class when the module is included, module methods do not. Conversely, module
# methods may be called without creating an encapsulating object, while instance
# methods may not. (See Module#module_function.)
#
# In the descriptions that follow, the parameter *sym* refers to a symbol, which
# is either a quoted string or a Symbol (such as `:name`).
#
#     module Mod
#       include Math
#       CONST = 1
#       def meth
#         #  ...
#       end
#     end
#     Mod.class              #=> Module
#     Mod.constants          #=> [:CONST, :PI, :E]
#     Mod.instance_methods   #=> [:meth]
#
class Module < Object
  # <!--
  #   rdoc-file=eval.c
  #   - Module.constants   -> array
  #   - Module.constants(inherited)   -> array
  # -->
  # In the first form, returns an array of the names of all constants accessible
  # from the point of call. This list includes the names of all modules and
  # classes defined in the global scope.
  #
  #     Module.constants.first(4)
  #        # => [:ARGF, :ARGV, :ArgumentError, :Array]
  #
  #     Module.constants.include?(:SEEK_SET)   # => false
  #
  #     class IO
  #       Module.constants.include?(:SEEK_SET) # => true
  #     end
  #
  # The second form calls the instance method `constants`.
  #
  def self.constants: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=eval.c
  #   - Module.nesting    -> array
  # -->
  # Returns the list of `Modules` nested at the point of call.
  #
  #     module M1
  #       module M2
  #         $a = Module.nesting
  #       end
  #     end
  #     $a           #=> [M1::M2, M1]
  #     $a[0].name   #=> "M1::M2"
  #
  def self.nesting: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - used_modules -> array
  # -->
  # Returns an array of all modules used in the current scope. The ordering of
  # modules in the resulting array is not defined.
  #
  #     module A
  #       refine Object do
  #       end
  #     end
  #
  #     module B
  #       refine Object do
  #       end
  #     end
  #
  #     using A
  #     using B
  #     p Module.used_modules
  #
  # *produces:*
  #
  #     [B, A]
  #
  def self.used_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - used_refinements -> array
  # -->
  # Returns an array of all modules used in the current scope. The ordering of
  # modules in the resulting array is not defined.
  #
  #     module A
  #       refine Object do
  #       end
  #     end
  #
  #     module B
  #       refine Object do
  #       end
  #     end
  #
  #     using A
  #     using B
  #     p Module.used_refinements
  #
  # *produces:*
  #
  #     [#<refinement:Object@B>, #<refinement:Object@A>]
  #
  def self.used_refinements: () -> Array[Refinement]

  # <!--
  #   rdoc-file=object.c
  #   - mod < other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other*. Returns `false` if *mod* is
  # the same as *other* or *mod* is an ancestor of *other*. Returns `nil` if
  # there's no relationship between the two. (Think of the relationship in terms
  # of the class definition: "class A < B" implies "A < B".)
  #
  def <: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod <= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other* or is the same as *other*.
  # Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "A < B".)
  #
  def <=: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - module <=> other_module   -> -1, 0, +1, or nil
  # -->
  # Comparison---Returns -1, 0, +1 or nil depending on whether `module` includes
  # `other_module`, they are the same, or if `module` is included by
  # `other_module`.
  #
  # Returns `nil` if `module` has no relationship with `other_module`, if
  # `other_module` is not a module, or if the two values are incomparable.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod === obj    -> true or false
  # -->
  # Case Equality---Returns `true` if *obj* is an instance of *mod* or an instance
  # of one of *mod*'s descendants. Of limited use for modules, but can be used in
  # `case` statements to classify objects by class.
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod > other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*. Returns `false` if *mod* is
  # the same as *other* or *mod* is a descendant of *other*. Returns `nil` if
  # there's no relationship between the two. (Think of the relationship in terms
  # of the class definition: "class A < B" implies "B > A".)
  #
  def >: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod >= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*, or the two modules are the
  # same. Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "B > A".)
  #
  def >=: (Module other) -> bool?

  # <!--
  #   rdoc-file=vm_method.c
  #   - alias_method(new_name, old_name)   -> symbol
  # -->
  # Makes *new_name* a new copy of the method *old_name*. This can be used to
  # retain access to methods that are overridden.
  #
  #     module Mod
  #       alias_method :orig_exit, :exit #=> :orig_exit
  #       def exit(code=0)
  #         puts "Exiting with code #{code}"
  #         orig_exit(code)
  #       end
  #     end
  #     include Mod
  #     exit(99)
  #
  # *produces:*
  #
  #     Exiting with code 99
  #
  def alias_method: (interned new_name, interned old_name) -> ::Symbol

  # <!--
  #   rdoc-file=object.c
  #   - mod.ancestors -> array
  # -->
  # Returns a list of modules included/prepended in *mod* (including *mod*
  # itself).
  #
  #     module Mod
  #       include Math
  #       include Comparable
  #       prepend Enumerable
  #     end
  #
  #     Mod.ancestors        #=> [Enumerable, Mod, Comparable, Math]
  #     Math.ancestors       #=> [Math]
  #     Enumerable.ancestors #=> [Enumerable]
  #
  def ancestors: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - append_features(mod)   -> mod
  # -->
  # When this module is included in another, Ruby calls #append_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to add the constants, methods, and module variables of this
  # module to *mod* if this module has not already been added to *mod* or one of
  # its ancestors. See also Module#include.
  #
  def append_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - attr_accessor(symbol, ...)    -> array
  #   - attr_accessor(string, ...)    -> array
  # -->
  # Defines a named attribute for this module, where the name is
  # *symbol.*`id2name`, creating an instance variable (`@name`) and a
  # corresponding access method to read it. Also creates a method called `name=`
  # to set the attribute. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  #     module Mod
  #       attr_accessor(:one, :two) #=> [:one, :one=, :two, :two=]
  #     end
  #     Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]
  #
  def attr_accessor: (*interned arg0) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - attr_reader(symbol, ...)  -> array
  #   - attr(symbol, ...)         -> array
  #   - attr_reader(string, ...)  -> array
  #   - attr(string, ...)         -> array
  # -->
  # Creates instance variables and corresponding methods that return the value of
  # each instance variable. Equivalent to calling ```attr`*:name*'' on each name
  # in turn. String arguments are converted to symbols. Returns an array of
  # defined method names as symbols.
  #
  def attr_reader: (*interned arg0) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - attr_writer(symbol, ...)    -> array
  #   - attr_writer(string, ...)    -> array
  # -->
  # Creates an accessor method to allow assignment to the attribute
  # *symbol*`.id2name`. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  def attr_writer: (*interned arg0) -> Array[Symbol]

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload(const, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *const* (which may be a String or a symbol) is accessed in the namespace of
  # *mod*.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A::B.doit            # autoloads "b"
  #
  # If *const* in *mod* is defined as autoload, the file name to be loaded is
  # replaced with *filename*.  If *const* is defined but not as autoload, does
  # nothing.
  #
  def autoload: (interned _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload` in the
  # namespace of *mod* or one of its ancestors.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A.autoload?(:B)            #=> "b"
  #
  # If `inherit` is false, the lookup only checks the autoloads in the receiver:
  #
  #     class A
  #       autoload :CONST, "const.rb"
  #     end
  #
  #     class B < A
  #     end
  #
  #     B.autoload?(:CONST)          #=> "const.rb", found in A (ancestor)
  #     B.autoload?(:CONST, false)   #=> nil, not found in B itself
  #
  def autoload?: (interned name, ?boolish inherit) -> String?

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def class_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                | [U] () { (self m) [self: self] -> U } -> U

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def class_exec: [U] (*untyped, **untyped) { (?) [self: self] -> U } -> U

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_defined?(symbol)    -> true or false
  #   - obj.class_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given class variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_defined?(:@@foo)    #=> true
  #     Fred.class_variable_defined?(:@@bar)    #=> false
  #
  def class_variable_defined?: (interned arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variable_get(symbol)    -> obj
  #   - mod.class_variable_get(string)    -> obj
  # -->
  # Returns the value of the given class variable (or throws a NameError
  # exception). The `@@` part of the variable name should be included for regular
  # class variables. String arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_get(:@@foo)     #=> 99
  #
  def class_variable_get: (interned arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_set(symbol, obj)    -> obj
  #   - obj.class_variable_set(string, obj)    -> obj
  # -->
  # Sets the class variable named by *symbol* to the given object. If the class
  # variable name is passed as a string, that string is converted to a symbol.
  #
  #     class Fred
  #       @@foo = 99
  #       def foo
  #         @@foo
  #       end
  #     end
  #     Fred.class_variable_set(:@@foo, 101)     #=> 101
  #     Fred.new.foo                             #=> 101
  #
  def class_variable_set: (interned arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variables(inherit=true)    -> array
  # -->
  # Returns an array of the names of class variables in *mod*. This includes the
  # names of class variables in any included modules, unless the *inherit*
  # parameter is set to `false`.
  #
  #     class One
  #       @@var1 = 1
  #     end
  #     class Two < One
  #       @@var2 = 2
  #     end
  #     One.class_variables          #=> [:@@var1]
  #     Two.class_variables          #=> [:@@var2, :@@var1]
  #     Two.class_variables(false)   #=> [:@@var2]
  #
  def class_variables: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - const_added(const_name)
  # -->
  # Invoked as a callback whenever a constant is assigned on the receiver
  #
  #     module Chatty
  #       def self.const_added(const_name)
  #         super
  #         puts "Added #{const_name.inspect}"
  #       end
  #       FOO = 1
  #     end
  #
  # *produces:*
  #
  #     Added :FOO
  #
  def const_added: (Symbol) -> void

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_defined?(sym, inherit=true)   -> true or false
  #   - mod.const_defined?(str, inherit=true)   -> true or false
  # -->
  # Says whether *mod* or its ancestors have a constant with the given name:
  #
  #     Float.const_defined?(:EPSILON)      #=> true, found in Float itself
  #     Float.const_defined?("String")      #=> true, found in Object (ancestor)
  #     BasicObject.const_defined?(:Hash)   #=> false
  #
  # If *mod* is a `Module`, additionally `Object` and its ancestors are checked:
  #
  #     Math.const_defined?(:String)   #=> true, found in Object
  #
  # In each of the checked classes or modules, if the constant is not present but
  # there is an autoload for it, `true` is returned directly without autoloading:
  #
  #     module Admin
  #       autoload :User, 'admin/user'
  #     end
  #     Admin.const_defined?(:User)   #=> true
  #
  # If the constant is not found the callback `const_missing` is **not** called
  # and the method returns `false`.
  #
  # If `inherit` is false, the lookup only checks the constants in the receiver:
  #
  #     IO.const_defined?(:SYNC)          #=> true, found in File::Constants (ancestor)
  #     IO.const_defined?(:SYNC, false)   #=> false, not found in IO itself
  #
  # In this case, the same logic for autoloading applies.
  #
  # If the argument is not a valid constant name a `NameError` is raised with the
  # message "wrong constant name *name*":
  #
  #     Hash.const_defined? 'foobar'   #=> NameError: wrong constant name foobar
  #
  def const_defined?: (interned name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_get(sym, inherit=true)    -> obj
  #   - mod.const_get(str, inherit=true)    -> obj
  # -->
  # Checks for a constant with the given name in *mod*. If `inherit` is set, the
  # lookup will also search the ancestors (and `Object` if *mod* is a `Module`).
  #
  # The value of the constant is returned if a definition is found, otherwise a
  # `NameError` is raised.
  #
  #     Math.const_get(:PI)   #=> 3.14159265358979
  #
  # This method will recursively look up constant names if a namespaced class name
  # is provided.  For example:
  #
  #     module Foo; class Bar; end end
  #     Object.const_get 'Foo::Bar'
  #
  # The `inherit` flag is respected on each lookup.  For example:
  #
  #     module Foo
  #       class Bar
  #         VAL = 10
  #       end
  #
  #       class Baz < Bar; end
  #     end
  #
  #     Object.const_get 'Foo::Baz::VAL'         # => 10
  #     Object.const_get 'Foo::Baz::VAL', false  # => NameError
  #
  # If the argument is not a valid constant name a `NameError` will be raised with
  # a warning "wrong constant name".
  #
  #     Object.const_get 'foobar' #=> NameError: wrong constant name foobar
  #
  def const_get: (interned name, ?boolish inherit) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_missing(sym)    -> obj
  # -->
  # Invoked when a reference is made to an undefined constant in *mod*. It is
  # passed a symbol for the undefined constant, and returns a value to be used for
  # that constant. For example, consider:
  #
  #     def Foo.const_missing(name)
  #       name # return the constant name as Symbol
  #     end
  #
  #     Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned
  #
  # As the example above shows, `const_missing` is not required to create the
  # missing constant in *mod*, though that is often a side-effect. The caller gets
  # its return value when triggered. If the constant is also defined, further
  # lookups won't hit `const_missing` and will return the value stored in the
  # constant as usual. Otherwise, `const_missing` will be invoked again.
  #
  # In the next example, when a reference is made to an undefined constant,
  # `const_missing` attempts to load a file whose path is the lowercase version of
  # the constant name (thus class `Fred` is assumed to be in file `fred.rb`). If
  # defined as a side-effect of loading the file, the method returns the value
  # stored in the constant. This implements an autoload feature similar to
  # Kernel#autoload and Module#autoload, though it differs in important ways.
  #
  #     def Object.const_missing(name)
  #       @looked_for ||= {}
  #       str_name = name.to_s
  #       raise "Constant not found: #{name}" if @looked_for[str_name]
  #       @looked_for[str_name] = 1
  #       file = str_name.downcase
  #       require file
  #       const_get(name, false)
  #     end
  #
  def const_missing: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_set(sym, obj)    -> obj
  #   - mod.const_set(str, obj)    -> obj
  # -->
  # Sets the named constant to the given object, returning that object. Creates a
  # new constant if no constant with the given name previously existed.
  #
  #     Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714
  #     Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968
  #
  # If `sym` or `str` is not a valid constant name a `NameError` will be raised
  # with a warning "wrong constant name".
  #
  #     Object.const_set('foobar', 42) #=> NameError: wrong constant name foobar
  #
  def const_set: (interned arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_source_location(sym, inherit=true)   -> [String, Integer]
  #   - mod.const_source_location(str, inherit=true)   -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing the definition of
  # the constant specified. If the named constant is not found, `nil` is returned.
  # If the constant is found, but its source location can not be extracted
  # (constant is defined in C code), empty array is returned.
  #
  # *inherit* specifies whether to lookup in `mod.ancestors` (`true` by default).
  #
  #     # test.rb:
  #     class A         # line 1
  #       C1 = 1
  #       C2 = 2
  #     end
  #
  #     module M        # line 6
  #       C3 = 3
  #     end
  #
  #     class B < A     # line 10
  #       include M
  #       C4 = 4
  #     end
  #
  #     class A # continuation of A definition
  #       C2 = 8 # constant redefinition; warned yet allowed
  #     end
  #
  #     p B.const_source_location('C4')           # => ["test.rb", 12]
  #     p B.const_source_location('C3')           # => ["test.rb", 7]
  #     p B.const_source_location('C1')           # => ["test.rb", 2]
  #
  #     p B.const_source_location('C3', false)    # => nil  -- don't lookup in ancestors
  #
  #     p A.const_source_location('C2')           # => ["test.rb", 16] -- actual (last) definition place
  #
  #     p Object.const_source_location('B')       # => ["test.rb", 10] -- top-level constant could be looked through Object
  #     p Object.const_source_location('A')       # => ["test.rb", 1] -- class reopening is NOT considered new definition
  #
  #     p B.const_source_location('A')            # => ["test.rb", 1]  -- because Object is in ancestors
  #     p M.const_source_location('A')            # => ["test.rb", 1]  -- Object is not ancestor, but additionally checked for modules
  #
  #     p Object.const_source_location('A::C1')   # => ["test.rb", 2]  -- nesting is supported
  #     p Object.const_source_location('String')  # => []  -- constant is defined in C code
  #
  def const_source_location: (interned name, ?boolish inherit) -> ([ String, Integer ] | [ ] | nil)

  # <!--
  #   rdoc-file=object.c
  #   - mod.constants(inherit=true)    -> array
  # -->
  # Returns an array of the names of the constants accessible in *mod*. This
  # includes the names of constants in any included modules (example at start of
  # section), unless the *inherit* parameter is set to `false`.
  #
  # The implementation makes no guarantees about the order in which the constants
  # are yielded.
  #
  #     IO.constants.include?(:SYNC)        #=> true
  #     IO.constants(false).include?(:SYNC) #=> false
  #
  # Also see Module#const_defined?.
  #
  def constants: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - define_method(symbol, method)     -> symbol
  #   - define_method(symbol) { block }   -> symbol
  # -->
  # Defines an instance method in the receiver. The *method* parameter can be a
  # `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
  # is used as the method body. If a block or the *method* parameter has
  # parameters, they're used as method parameters. This block is evaluated using
  # #instance_eval.
  #
  #     class A
  #       def fred
  #         puts "In Fred"
  #       end
  #       def create_method(name, &block)
  #         self.class.define_method(name, &block)
  #       end
  #       define_method(:wilma) { puts "Charge it!" }
  #       define_method(:flint) {|name| puts "I'm #{name}!"}
  #     end
  #     class B < A
  #       define_method(:barney, instance_method(:fred))
  #     end
  #     a = B.new
  #     a.barney
  #     a.wilma
  #     a.flint('Dino')
  #     a.create_method(:betty) { p self }
  #     a.betty
  #
  # *produces:*
  #
  #     In Fred
  #     Charge it!
  #     I'm Dino!
  #     #<B:0x401b39e8>
  #
  def define_method: (interned symbol, ^() [self: instance] -> untyped | Method | UnboundMethod method) -> Symbol
                   | (interned symbol) { () [self: instance] -> untyped } -> Symbol

  # <!--
  #   rdoc-file=object.c
  #   - mod.deprecate_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants deprecated. Attempt to refer to them will
  # produce a warning.
  #
  #     module HTTP
  #       NotFound = Exception.new
  #       NOT_FOUND = NotFound # previous version of the library used this name
  #
  #       deprecate_constant :NOT_FOUND
  #     end
  #
  #     HTTP::NOT_FOUND
  #     # warning: constant HTTP::NOT_FOUND is deprecated
  #
  def deprecate_constant: (*interned) -> self

  def eql?: (untyped other) -> bool

  def equal?: (untyped other) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - extend_object(obj)    -> obj
  # -->
  # Extends the specified object by adding this module's constants and methods
  # (which are added as singleton methods). This is the callback method used by
  # Object#extend.
  #
  #     module Picky
  #       def Picky.extend_object(o)
  #         if String === o
  #           puts "Can't add Picky to a String"
  #         else
  #           puts "Picky added to #{o.class}"
  #           super
  #         end
  #       end
  #     end
  #     (s = Array.new).extend Picky  # Call Object.extend
  #     (s = "quick brown fox").extend Picky
  #
  # *produces:*
  #
  #     Picky added to Array
  #     Can't add Picky to a String
  #
  def extend_object: (untyped arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - extended(othermod)
  # -->
  # The equivalent of `included`, but for extended modules.
  #
  #     module A
  #       def self.extended(mod)
  #         puts "#{self} extended in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       extend A
  #     end
  #      # => prints "A extended in Enumerable"
  #
  def extended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.freeze       -> mod
  # -->
  # Prevents further modifications to *mod*.
  #
  # This method returns self.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=eval.c
  #   - include(module, ...)    -> self
  # -->
  # Invokes Module.append_features on each parameter in reverse order.
  #
  def include: (Module, *Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.include?(module)    -> true or false
  # -->
  # Returns `true` if *module* is included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module A
  #     end
  #     class B
  #       include A
  #     end
  #     class C < B
  #     end
  #     B.include?(A)   #=> true
  #     C.include?(A)   #=> true
  #     A.include?(A)   #=> false
  #
  def include?: (Module arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - included(othermod)
  # -->
  # Callback invoked whenever the receiver is included in another module or class.
  # This should be used in preference to `Module.append_features` if your code
  # wants to perform some action when a module is included in another.
  #
  #     module A
  #       def A.included(mod)
  #         puts "#{self} included in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       include A
  #     end
  #      # => prints "A included in Enumerable"
  #
  def included: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.included_modules -> array
  # -->
  # Returns the list of modules included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module Sub
  #     end
  #
  #     module Mixin
  #       prepend Sub
  #     end
  #
  #     module Outer
  #       include Mixin
  #     end
  #
  #     Mixin.included_modules   #=> [Sub]
  #     Outer.included_modules   #=> [Sub, Mixin]
  #
  def included_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=object.c
  #   - Module.new                  -> mod
  #   - Module.new {|mod| block }   -> mod
  # -->
  # Creates a new anonymous module. If a block is given, it is passed the module
  # object, and the block is evaluated in the context of this module like
  # #module_eval.
  #
  #     fred = Module.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #     a = "my string"
  #     a.extend(fred)   #=> "my string"
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the module to a constant (name starting uppercase) if you want to treat
  # it like a regular module.
  #
  def initialize: () -> void
                | () { (Module arg0) -> untyped } -> void

  # <!--
  #   rdoc-file=proc.c
  #   - mod.instance_method(symbol)   -> unbound_method
  # -->
  # Returns an `UnboundMethod` representing the given instance method in *mod*.
  #
  #     class Interpreter
  #       def do_a() print "there, "; end
  #       def do_d() print "Hello ";  end
  #       def do_e() print "!\n";     end
  #       def do_v() print "Dave";    end
  #       Dispatcher = {
  #         "a" => instance_method(:do_a),
  #         "d" => instance_method(:do_d),
  #         "e" => instance_method(:do_e),
  #         "v" => instance_method(:do_v)
  #       }
  #       def interpret(string)
  #         string.each_char {|b| Dispatcher[b].bind(self).call }
  #       end
  #     end
  #
  #     interpreter = Interpreter.new
  #     interpreter.interpret('dave')
  #
  # *produces:*
  #
  #     Hello there, Dave!
  #
  def instance_method: (interned arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.instance_methods(include_super=true)   -> array
  # -->
  # Returns an array containing the names of the public and protected instance
  # methods in the receiver. For a module, these are the public and protected
  # methods; for a class, they are the instance (not singleton) methods. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       include A
  #       def method2()  end
  #     end
  #     class C < B
  #       def method3()  end
  #     end
  #
  #     A.instance_methods(false)                   #=> [:method1]
  #     B.instance_methods(false)                   #=> [:method2]
  #     B.instance_methods(true).include?(:method1) #=> true
  #     C.instance_methods(false)                   #=> [:method3]
  #     C.instance_methods.include?(:method2)       #=> true
  #
  # Note that method visibility changes in the current class, as well as aliases,
  # are considered as methods of the current class by this method:
  #
  #     class C < B
  #       alias method4 method2
  #       protected :method2
  #     end
  #     C.instance_methods(false).sort               #=> [:method2, :method3, :method4]
  #
  def instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - method_added(method_name)
  # -->
  # Invoked as a callback whenever an instance method is added to the receiver.
  #
  #     module Chatty
  #       def self.method_added(method_name)
  #         puts "Adding #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #     end
  #
  # *produces:*
  #
  #     Adding :some_instance_method
  #
  def method_added: (Symbol meth) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named method is defined by *mod*.  If *inherit* is set,
  # the lookup will also search *mod*'s ancestors. Public and protected methods
  # are matched. String arguments are converted to symbols.
  #
  #     module A
  #       def method1()  end
  #       def protected_method1()  end
  #       protected :protected_method1
  #     end
  #     class B
  #       def method2()  end
  #       def private_method2()  end
  #       private :private_method2
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1              #=> true
  #     C.method_defined? "method1"             #=> true
  #     C.method_defined? "method2"             #=> true
  #     C.method_defined? "method2", true       #=> true
  #     C.method_defined? "method2", false      #=> false
  #     C.method_defined? "method3"             #=> true
  #     C.method_defined? "protected_method1"   #=> true
  #     C.method_defined? "method4"             #=> false
  #     C.method_defined? "private_method2"     #=> false
  #
  def method_defined?: (interned name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - method_removed(method_name)
  # -->
  # Invoked as a callback whenever an instance method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def self.method_removed(method_name)
  #         puts "Removing #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #       class << self
  #         remove_method :some_class_method
  #       end
  #       remove_method :some_instance_method
  #     end
  #
  # *produces:*
  #
  #     Removing :some_instance_method
  #
  def method_removed: (Symbol method_name) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.class_eval(string [, filename [, lineno]])  -> obj
  #   - mod.class_eval {|mod| block }                   -> obj
  #   - mod.module_eval(string [, filename [, lineno]]) -> obj
  #   - mod.module_eval {|mod| block }                  -> obj
  # -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def module_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                 | [U] () { (self m) [self: self] -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.module_exec(arg...) {|var...| block }       -> obj
  #   - mod.class_exec(arg...) {|var...| block }        -> obj
  # -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def module_exec: [U] (*untyped, **untyped) { (?) [self: self] -> U } -> U

  # <!--
  #   rdoc-file=vm_method.c
  #   - module_function                                -> nil
  #   - module_function(method_name)                   -> method_name
  #   - module_function(method_name, method_name, ...) -> array
  # -->
  # Creates module functions for the named methods. These functions may be called
  # with the module as a receiver, and also become available as instance methods
  # to classes that mix in the module. Module functions are copies of the
  # original, and so may be changed independently. The instance-method versions
  # are made private. If used with no arguments, subsequently defined methods
  # become module functions. String arguments are converted to symbols. If a
  # single argument is passed, it is returned. If no argument is passed, nil is
  # returned. If multiple arguments are passed, the arguments are returned as an
  # array.
  #
  #     module Mod
  #       def one
  #         "This is one"
  #       end
  #       module_function :one
  #     end
  #     class Cls
  #       include Mod
  #       def call_one
  #         one
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c = Cls.new
  #     c.call_one  #=> "This is one"
  #     module Mod
  #       def one
  #         "This is the new one"
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c.call_one  #=> "This is the new one"
  #
  def module_function: () -> nil
                     | (Symbol method_name) -> Symbol
                     | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
                     | (string method_name) -> string
                     | (interned, interned, *interned method_name) -> Array[interned]

  # <!--
  #   rdoc-file=object.c
  #   - mod.name    -> string or nil
  # -->
  # Returns the name of the module *mod*.  Returns `nil` for anonymous modules.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - prepend(module, ...)    -> self
  # -->
  # Invokes Module.prepend_features on each parameter in reverse order.
  #
  def prepend: (Module, *Module arg0) -> self

  # <!--
  #   rdoc-file=eval.c
  #   - prepend_features(mod)   -> mod
  # -->
  # When this module is prepended in another, Ruby calls #prepend_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to overlay the constants, methods, and module variables of
  # this module to *mod* if this module has not already been added to *mod* or one
  # of its ancestors. See also Module#prepend.
  #
  def prepend_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - prepended(othermod)
  # -->
  # The equivalent of `included`, but for prepended modules.
  #
  #     module A
  #       def self.prepended(mod)
  #         puts "#{self} prepended to #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       prepend A
  #     end
  #      # => prints "A prepended to Enumerable"
  #
  def prepended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - private                                -> nil
  #   - private(method_name)                   -> method_name
  #   - private(method_name, method_name, ...) -> array
  #   - private(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to private. With arguments, sets the named methods to have private
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  #     module Mod
  #       def a()  end
  #       def b()  end
  #       private
  #       def c()  end
  #       private :a
  #     end
  #     Mod.private_instance_methods   #=> [:a, :c]
  #
  # Note that to show a private method on RDoc, use `:doc:`.
  #
  def private: () -> nil
             | (Symbol method_name) -> Symbol
             | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
             | (string method_name) -> string
             | (interned, interned, *interned method_name) -> Array[interned]
             | (Array[interned]) -> Array[interned]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_class_method(symbol, ...)   -> mod
  #   - mod.private_class_method(string, ...)   -> mod
  #   - mod.private_class_method(array)         -> mod
  # -->
  # Makes existing class methods private. Often used to hide the default
  # constructor `new`.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  #     class SimpleSingleton  # Not thread safe
  #       private_class_method :new
  #       def SimpleSingleton.create(*args, &block)
  #         @me = new(*args, &block) if ! @me
  #         @me
  #       end
  #     end
  #
  def private_class_method: (*interned arg0) -> self
                          | (Array[interned] arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants private.
  #
  def private_constant: (*interned arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_instance_methods(include_super=true)    -> array
  # -->
  # Returns a list of the private instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module Mod
  #       def method1()  end
  #       private :method1
  #       def method2()  end
  #     end
  #     Mod.instance_methods           #=> [:method2]
  #     Mod.private_instance_methods   #=> [:method1]
  #
  def private_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.private_method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named private method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       private
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                   #=> true
  #     C.private_method_defined? "method1"          #=> false
  #     C.private_method_defined? "method2"          #=> true
  #     C.private_method_defined? "method2", true    #=> true
  #     C.private_method_defined? "method2", false   #=> false
  #     C.method_defined? "method2"                  #=> false
  #
  def private_method_defined?: (interned name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - protected                                -> nil
  #   - protected(method_name)                   -> method_name
  #   - protected(method_name, method_name, ...) -> array
  #   - protected(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to protected. With arguments, sets the named methods to have protected
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  # If a method has protected visibility, it is callable only where `self` of the
  # context is the same as the method. (method definition or instance_eval). This
  # behavior is different from Java's protected method. Usually `private` should
  # be used.
  #
  # Note that a protected method is slow because it can't use inline cache.
  #
  # To show a private method on RDoc, use `:doc:` instead of this.
  #
  def protected: () -> nil
               | (Symbol method_name) -> Symbol
               | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
               | (string method_name) -> string
               | (interned, interned, *interned method_name) -> Array[interned]
               | (Array[interned]) -> Array[interned]

  # <!--
  #   rdoc-file=object.c
  #   - mod.protected_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the protected instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def protected_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.protected_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.protected_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named protected method is defined *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                    #=> true
  #     C.protected_method_defined? "method1"         #=> false
  #     C.protected_method_defined? "method2"         #=> true
  #     C.protected_method_defined? "method2", true   #=> true
  #     C.protected_method_defined? "method2", false  #=> false
  #     C.method_defined? "method2"                   #=> true
  #
  def protected_method_defined?: (interned name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - public                                -> nil
  #   - public(method_name)                   -> method_name
  #   - public(method_name, method_name, ...) -> array
  #   - public(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to public. With arguments, sets the named methods to have public
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  def public: () -> nil
            | (Symbol method_name) -> Symbol
            | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
            | (string method_name) -> string
            | (interned, interned, *interned method_name) -> Array[interned]
            | (Array[interned]) -> Array[interned]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_class_method(symbol, ...)    -> mod
  #   - mod.public_class_method(string, ...)    -> mod
  #   - mod.public_class_method(array)          -> mod
  # -->
  # Makes a list of existing class methods public.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  def public_class_method: (*interned arg0) -> self
                         | (Array[interned] arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants public.
  #
  def public_constant: (*interned arg0) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - mod.public_instance_method(symbol)   -> unbound_method
  # -->
  # Similar to *instance_method*, searches public method only.
  #
  def public_instance_method: (interned arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the public instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def public_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.public_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named public method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                 #=> true
  #     C.public_method_defined? "method1"         #=> true
  #     C.public_method_defined? "method1", true   #=> true
  #     C.public_method_defined? "method1", false  #=> true
  #     C.public_method_defined? "method2"         #=> false
  #     C.method_defined? "method2"                #=> true
  #
  def public_method_defined?: (interned name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - refine(mod) { block }   -> module
  # -->
  # Refine *mod* in the receiver.
  #
  # Returns a module, where refined methods are defined.
  #
  def refine: (Module mod) { () [self: Refinement] -> void } -> Refinement

  # <!--
  #   rdoc-file=eval.c
  #   - refinements -> array
  # -->
  # Returns an array of `Refinement` defined within the receiver.
  #
  #     module A
  #       refine Integer do
  #       end
  #
  #       refine String do
  #       end
  #     end
  #
  #     p A.refinements
  #
  # *produces:*
  #
  #     [#<refinement:Integer@A>, #<refinement:String@A>]
  #
  def refinements: () -> Array[Refinement]

  # <!--
  #   rdoc-file=object.c
  #   - remove_class_variable(sym)    -> obj
  # -->
  # Removes the named class variable from the receiver, returning that variable's
  # value.
  #
  #     class Example
  #       @@var = 99
  #       puts remove_class_variable(:@@var)
  #       p(defined? @@var)
  #     end
  #
  # *produces:*
  #
  #     99
  #     nil
  #
  def remove_class_variable: (interned arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - remove_const(sym)   -> obj
  # -->
  # Removes the definition of the given constant, returning that constant's
  # previous value.  If that constant referred to a module, this will not change
  # that module's name and can lead to confusion.
  #
  def remove_const: (interned arg0) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - remove_method(symbol)   -> self
  #   - remove_method(string)   -> self
  # -->
  # Removes the method identified by *symbol* from the current class. For an
  # example, see Module#undef_method. String arguments are converted to symbols.
  #
  def remove_method: (*interned arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.set_temporary_name(string) -> self
  #   - mod.set_temporary_name(nil) -> self
  # -->
  # Sets the temporary name of the module. This name is reflected in introspection
  # of the module and the values that are related to it, such as instances,
  # constants, and methods.
  #
  # The name should be `nil` or a non-empty string that is not a valid constant
  # path (to avoid confusing between permanent and temporary names).
  #
  # The method can be useful to distinguish dynamically generated classes and
  # modules without assigning them to constants.
  #
  # If the module is given a permanent name by assigning it to a constant, the
  # temporary name is discarded. A temporary name can't be assigned to modules
  # that have a permanent name.
  #
  # If the given name is `nil`, the module becomes anonymous again.
  #
  # Example:
  #
  #     m = Module.new # => #<Module:0x0000000102c68f38>
  #     m.name #=> nil
  #
  #     m.set_temporary_name("fake_name") # => fake_name
  #     m.name #=> "fake_name"
  #
  #     m.set_temporary_name(nil) # => #<Module:0x0000000102c68f38>
  #     m.name #=> nil
  #
  #     c = Class.new
  #     c.set_temporary_name("MyClass(with description)")
  #
  #     c.new # => #<MyClass(with description):0x0....>
  #
  #     c::M = m
  #     c::M.name #=> "MyClass(with description)::M"
  #
  #     # Assigning to a constant replaces the name with a permanent one
  #     C = c
  #
  #     C.name #=> "C"
  #     C::M.name #=> "C::M"
  #     c.new # => #<C:0x0....>
  #
  def set_temporary_name: (string?) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.singleton_class?    -> true or false
  # -->
  # Returns `true` if *mod* is a singleton class or `false` if it is an ordinary
  # class or module.
  #
  #     class C
  #     end
  #     C.singleton_class?                  #=> false
  #     C.singleton_class.singleton_class?  #=> true
  #
  def singleton_class?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.to_s   -> string
  # -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_method.c
  #   - undef_method(symbol)    -> self
  #   - undef_method(string)    -> self
  # -->
  # Prevents the current class from responding to calls to the named method.
  # Contrast this with `remove_method`, which deletes the method from the
  # particular class; Ruby will still search superclasses and mixed-in modules for
  # a possible receiver. String arguments are converted to symbols.
  #
  #     class Parent
  #       def hello
  #         puts "In parent"
  #       end
  #     end
  #     class Child < Parent
  #       def hello
  #         puts "In child"
  #       end
  #     end
  #
  #     c = Child.new
  #     c.hello
  #
  #     class Child
  #       remove_method :hello  # remove from child, still in parent
  #     end
  #     c.hello
  #
  #     class Child
  #       undef_method :hello   # prevent any calls to 'hello'
  #     end
  #     c.hello
  #
  # *produces:*
  #
  #     In child
  #     In parent
  #     prog.rb:23: undefined method 'hello' for #<Child:0x401b3bb4> (NoMethodError)
  #
  def undef_method: (*interned arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.undefined_instance_methods   -> array
  # -->
  # Returns a list of the undefined instance methods defined in *mod*. The
  # undefined methods of any ancestors are not included.
  #
  def undefined_instance_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=eval.c
  #   - using(module)    -> self
  # -->
  # Import class refinements from *module* into the current class or module
  # definition.
  #
  def using: (Module arg0) -> self

  # <!-- rdoc-file=object.c -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - attr(name, ...) -> array
  #   - attr(name, true) -> array
  #   - attr(name, false) -> array
  # -->
  # The first form is equivalent to #attr_reader. The second form is equivalent to
  # `attr_accessor(name)` but deprecated. The last form is equivalent to
  # `attr_reader(name)` but deprecated. Returns an array of defined method names
  # as symbols.
  #
  def attr: (*interned arg0) -> Array[Symbol]

  # A previous incarnation of `interned` for backward-compatibility (see #1499)
  %a{steep:deprecated}
  type id = interned
end
# <!-- rdoc-file=encoding.c -->
# An Encoding instance represents a character encoding usable in Ruby. It is
# defined as a constant under the Encoding namespace. It has a name and,
# optionally, aliases:
#
#     Encoding::US_ASCII.name  # => "US-ASCII"
#     Encoding::US_ASCII.names # => ["US-ASCII", "ASCII", "ANSI_X3.4-1968", "646"]
#
# A Ruby method that accepts an encoding as an argument will accept:
#
# *   An Encoding object.
# *   The name of an encoding.
# *   An alias for an encoding name.
#
# These are equivalent:
#
#     'foo'.encode(Encoding::US_ASCII) # Encoding object.
#     'foo'.encode('US-ASCII')         # Encoding name.
#     'foo'.encode('ASCII')            # Encoding alias.
#
# For a full discussion of encodings and their uses, see [the Encodings
# document](rdoc-ref:encodings.rdoc).
#
# Encoding::ASCII_8BIT is a special-purpose encoding that is usually used for a
# string of bytes, not a string of characters. But as the name indicates, its
# characters in the ASCII range are considered as ASCII characters. This is
# useful when you use other ASCII-compatible encodings.
#
class Encoding
  def self._load: [T] (T) -> T

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.locale_charmap -> string
  # -->
  # Returns the locale charmap name. It returns nil if no appropriate information.
  #
  #     Debian GNU/Linux
  #       LANG=C
  #         Encoding.locale_charmap  #=> "ANSI_X3.4-1968"
  #       LANG=ja_JP.EUC-JP
  #         Encoding.locale_charmap  #=> "EUC-JP"
  #
  #     SunOS 5
  #       LANG=C
  #         Encoding.locale_charmap  #=> "646"
  #       LANG=ja
  #         Encoding.locale_charmap  #=> "eucJP"
  #
  # The result is highly platform dependent. So
  # Encoding.find(Encoding.locale_charmap) may cause an error. If you need some
  # encoding object even for unknown locale, Encoding.find("locale") can be used.
  #
  def self.locale_charmap: () -> String

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.aliases -> {"alias1" => "orig1", "alias2" => "orig2", ...}
  # -->
  # Returns the hash of available encoding alias and original encoding name.
  #
  #     Encoding.aliases
  #     #=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII",
  #           "SJIS"=>"Windows-31J", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}
  #
  def self.aliases: () -> Hash[String, String]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.compatible?(obj1, obj2) -> enc or nil
  # -->
  # Checks the compatibility of two objects.
  #
  # If the objects are both strings they are compatible when they are
  # concatenatable.  The encoding of the concatenated string will be returned if
  # they are compatible, nil if they are not.
  #
  #     Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")
  #     #=> #<Encoding:ISO-8859-1>
  #
  #     Encoding.compatible?(
  #       "\xa1".force_encoding("iso-8859-1"),
  #       "\xa1\xa1".force_encoding("euc-jp"))
  #     #=> nil
  #
  # If the objects are non-strings their encodings are compatible when they have
  # an encoding and:
  # *   Either encoding is US-ASCII compatible
  # *   One of the encodings is a 7-bit encoding
  #
  def self.compatible?: (untyped obj1, untyped obj2) -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external -> enc
  # -->
  # Returns default external encoding.
  #
  # The default external encoding is used by default for strings created from the
  # following locations:
  #
  # *   CSV
  # *   File data read from disk
  # *   SDBM
  # *   StringIO
  # *   Zlib::GzipReader
  # *   Zlib::GzipWriter
  # *   String#inspect
  # *   Regexp#inspect
  #
  # While strings created from these locations will have this encoding, the
  # encoding may not be valid.  Be sure to check String#valid_encoding?.
  #
  # File data written to disk will be transcoded to the default external encoding
  # when written, if default_internal is not nil.
  #
  # The default external encoding is initialized by the -E option. If -E isn't
  # set, it is initialized to UTF-8 on Windows and the locale on other operating
  # systems.
  #
  def self.default_external: () -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external = enc
  # -->
  # Sets default external encoding.  You should not set Encoding::default_external
  # in ruby code as strings created before changing the value may have a different
  # encoding from strings created after the value was changed., instead you should
  # use `ruby -E` to invoke ruby with the correct default_external.
  #
  # See Encoding::default_external for information on how the default external
  # encoding is used.
  #
  def self.default_external=: (Encoding enc) -> Encoding
                            | [T < _ToStr] (T enc) -> T

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal -> enc
  # -->
  # Returns default internal encoding.  Strings will be transcoded to the default
  # internal encoding in the following places if the default internal encoding is
  # not nil:
  #
  # *   CSV
  # *   Etc.sysconfdir and Etc.systmpdir
  # *   File data read from disk
  # *   File names from Dir
  # *   Integer#chr
  # *   String#inspect and Regexp#inspect
  # *   Strings returned from Readline
  # *   Strings returned from SDBM
  # *   Time#zone
  # *   Values from ENV
  # *   Values in ARGV including $PROGRAM_NAME
  #
  # Additionally String#encode and String#encode! use the default internal
  # encoding if no encoding is given.
  #
  # The script encoding (__ENCODING__), not default_internal, is used as the
  # encoding of created strings.
  #
  # Encoding::default_internal is initialized with -E option or nil otherwise.
  #
  def self.default_internal: () -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal = enc or nil
  # -->
  # Sets default internal encoding or removes default internal encoding when
  # passed nil.  You should not set Encoding::default_internal in ruby code as
  # strings created before changing the value may have a different encoding from
  # strings created after the change.  Instead you should use `ruby -E` to invoke
  # ruby with the correct default_internal.
  #
  # See Encoding::default_internal for information on how the default internal
  # encoding is used.
  #
  def self.default_internal=: (Encoding enc) -> Encoding
                            | [T < _ToStr] (T enc) -> T
                            | (nil) -> nil

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.find(string) -> enc
  # -->
  # Search the encoding with specified *name*. *name* should be a string.
  #
  #     Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>
  #
  # Names which this method accept are encoding names and aliases including
  # following special aliases
  #
  # "external"
  # :   default external encoding
  #
  # "internal"
  # :   default internal encoding
  #
  # "locale"
  # :   locale encoding
  #
  # "filesystem"
  # :   filesystem encoding
  #
  #
  # An ArgumentError is raised when no encoding with *name*. Only
  # `Encoding.find("internal")` however returns nil when no encoding named
  # "internal", in other words, when Ruby has no default internal encoding.
  #
  def self.find: (encoding enc) -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.list -> [enc1, enc2, ...]
  # -->
  # Returns the list of loaded encodings.
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:ISO-2022-JP (dummy)>]
  #
  #     Encoding.find("US-ASCII")
  #     #=> #<Encoding:US-ASCII>
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]
  #
  def self.list: () -> Array[Encoding]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.name_list -> ["enc1", "enc2", ...]
  # -->
  # Returns the list of available encoding names.
  #
  #     Encoding.name_list
  #     #=> ["US-ASCII", "ASCII-8BIT", "UTF-8",
  #           "ISO-8859-1", "Shift_JIS", "EUC-JP",
  #           "Windows-31J",
  #           "BINARY", "CP932", "eucJP"]
  #
  def self.name_list: () -> Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.ascii_compatible? -> true or false
  # -->
  # Returns whether ASCII-compatible or not.
  #
  #     Encoding::UTF_8.ascii_compatible?     #=> true
  #     Encoding::UTF_16BE.ascii_compatible?  #=> false
  #
  def ascii_compatible?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.dummy? -> true or false
  # -->
  # Returns true for dummy encodings. A dummy encoding is an encoding for which
  # character handling is not properly implemented. It is used for stateful
  # encodings.
  #
  #     Encoding::ISO_2022_JP.dummy?       #=> true
  #     Encoding::UTF_8.dummy?             #=> false
  #
  def dummy?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.inspect -> string
  # -->
  # Returns a string which represents the encoding for programmers.
  #
  #     Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"
  #     Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"
  #
  def inspect: () -> String

  # <!-- rdoc-file=encoding.c -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  def name: () -> String

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.names -> array
  # -->
  # Returns the list of name and aliases of the encoding.
  #
  #     Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J", "SJIS", "PCK"]
  #
  def names: () -> Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.name -> string
  #   - enc.to_s -> string
  # -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  alias to_s name

  ANSI_X3_4_1968: Encoding
  ASCII: Encoding
  ASCII_8BIT: Encoding
  BIG5: Encoding
  BIG5_HKSCS: Encoding
  BIG5_HKSCS_2008: Encoding
  BIG5_UAO: Encoding
  BINARY: Encoding
  Big5: Encoding
  Big5_HKSCS: Encoding
  Big5_HKSCS_2008: Encoding
  Big5_UAO: Encoding
  CESU_8: Encoding
  CP1250: Encoding
  CP1251: Encoding
  CP1252: Encoding
  CP1253: Encoding
  CP1254: Encoding
  CP1255: Encoding
  CP1256: Encoding
  CP1257: Encoding
  CP1258: Encoding
  CP437: Encoding
  CP50220: Encoding
  CP50221: Encoding
  CP51932: Encoding
  CP65000: Encoding
  CP65001: Encoding
  CP737: Encoding
  CP775: Encoding
  CP850: Encoding
  CP852: Encoding
  CP855: Encoding
  CP857: Encoding
  CP860: Encoding
  CP861: Encoding
  CP862: Encoding
  CP863: Encoding
  CP864: Encoding
  CP865: Encoding
  CP866: Encoding
  CP869: Encoding
  CP874: Encoding
  CP878: Encoding
  CP932: Encoding
  CP936: Encoding
  CP949: Encoding
  CP950: Encoding
  CP951: Encoding
  CSWINDOWS31J: Encoding
  CsWindows31J: Encoding
  EBCDIC_CP_US: Encoding
  EMACS_MULE: Encoding
  EUCCN: Encoding
  EUCJP: Encoding
  EUCJP_MS: Encoding
  EUCKR: Encoding
  EUCTW: Encoding
  EUC_CN: Encoding
  EUC_JISX0213: Encoding
  EUC_JIS_2004: Encoding
  EUC_JP: Encoding
  EUC_JP_MS: Encoding
  EUC_KR: Encoding
  EUC_TW: Encoding
  Emacs_Mule: Encoding
  EucCN: Encoding
  EucJP: Encoding
  EucJP_ms: Encoding
  EucKR: Encoding
  EucTW: Encoding
  GB12345: Encoding
  GB18030: Encoding
  GB1988: Encoding
  GB2312: Encoding
  GBK: Encoding
  IBM037: Encoding
  IBM437: Encoding
  IBM737: Encoding
  IBM720: Encoding
  CP720: Encoding
  IBM775: Encoding
  IBM850: Encoding
  IBM852: Encoding
  IBM855: Encoding
  IBM857: Encoding
  IBM860: Encoding
  IBM861: Encoding
  IBM862: Encoding
  IBM863: Encoding
  IBM864: Encoding
  IBM865: Encoding
  IBM866: Encoding
  IBM869: Encoding
  ISO2022_JP: Encoding
  ISO2022_JP2: Encoding
  ISO8859_1: Encoding
  ISO8859_10: Encoding
  ISO8859_11: Encoding
  ISO8859_13: Encoding
  ISO8859_14: Encoding
  ISO8859_15: Encoding
  ISO8859_16: Encoding
  ISO8859_2: Encoding
  ISO8859_3: Encoding
  ISO8859_4: Encoding
  ISO8859_5: Encoding
  ISO8859_6: Encoding
  ISO8859_7: Encoding
  ISO8859_8: Encoding
  ISO8859_9: Encoding
  ISO_2022_JP: Encoding
  ISO_2022_JP_2: Encoding
  ISO_2022_JP_KDDI: Encoding
  ISO_8859_1: Encoding
  ISO_8859_10: Encoding
  ISO_8859_11: Encoding
  ISO_8859_13: Encoding
  ISO_8859_14: Encoding
  ISO_8859_15: Encoding
  ISO_8859_16: Encoding
  ISO_8859_2: Encoding
  ISO_8859_3: Encoding
  ISO_8859_4: Encoding
  ISO_8859_5: Encoding
  ISO_8859_6: Encoding
  ISO_8859_7: Encoding
  ISO_8859_8: Encoding
  ISO_8859_9: Encoding
  KOI8_R: Encoding
  KOI8_U: Encoding
  MACCENTEURO: Encoding
  MACCROATIAN: Encoding
  MACCYRILLIC: Encoding
  MACGREEK: Encoding
  MACICELAND: Encoding
  MACJAPAN: Encoding
  MACJAPANESE: Encoding
  MACROMAN: Encoding
  MACROMANIA: Encoding
  MACTHAI: Encoding
  MACTURKISH: Encoding
  MACUKRAINE: Encoding
  MacCentEuro: Encoding
  MacCroatian: Encoding
  MacCyrillic: Encoding
  MacGreek: Encoding
  MacIceland: Encoding
  MacJapan: Encoding
  MacJapanese: Encoding
  MacRoman: Encoding
  MacRomania: Encoding
  MacThai: Encoding
  MacTurkish: Encoding
  MacUkraine: Encoding
  PCK: Encoding
  SHIFT_JIS: Encoding
  SJIS: Encoding
  SJIS_DOCOMO: Encoding
  SJIS_DoCoMo: Encoding
  SJIS_KDDI: Encoding
  SJIS_SOFTBANK: Encoding
  SJIS_SoftBank: Encoding
  STATELESS_ISO_2022_JP: Encoding
  STATELESS_ISO_2022_JP_KDDI: Encoding
  Shift_JIS: Encoding
  Stateless_ISO_2022_JP: Encoding
  Stateless_ISO_2022_JP_KDDI: Encoding
  TIS_620: Encoding
  UCS_2BE: Encoding
  UCS_4BE: Encoding
  UCS_4LE: Encoding
  US_ASCII: Encoding
  UTF8_DOCOMO: Encoding
  UTF8_DoCoMo: Encoding
  UTF8_KDDI: Encoding
  UTF8_MAC: Encoding
  UTF8_SOFTBANK: Encoding
  UTF8_SoftBank: Encoding
  UTF_16: Encoding
  UTF_16BE: Encoding
  UTF_16LE: Encoding
  UTF_32: Encoding
  UTF_32BE: Encoding
  UTF_32LE: Encoding
  UTF_7: Encoding
  UTF_8: Encoding
  UTF_8_HFS: Encoding
  UTF_8_MAC: Encoding
  WINDOWS_1250: Encoding
  WINDOWS_1251: Encoding
  WINDOWS_1252: Encoding
  WINDOWS_1253: Encoding
  WINDOWS_1254: Encoding
  WINDOWS_1255: Encoding
  WINDOWS_1256: Encoding
  WINDOWS_1257: Encoding
  WINDOWS_1258: Encoding
  WINDOWS_31J: Encoding
  WINDOWS_874: Encoding
  Windows_1250: Encoding
  Windows_1251: Encoding
  Windows_1252: Encoding
  Windows_1253: Encoding
  Windows_1254: Encoding
  Windows_1255: Encoding
  Windows_1256: Encoding
  Windows_1257: Encoding
  Windows_1258: Encoding
  Windows_31J: Encoding
  Windows_874: Encoding

  # <!-- rdoc-file=error.c -->
  # Raised by Encoding and String methods when the source encoding is incompatible
  # with the target encoding.
  #
  class CompatibilityError < EncodingError
  end

  # <!-- rdoc-file=transcode.c -->
  # Raised by transcoding methods when a named encoding does not correspond with a
  # known converter.
  #
  class ConverterNotFoundError < EncodingError
  end

  # <!-- rdoc-file=transcode.c -->
  # Raised by Encoding and String methods when the string being transcoded
  # contains a byte invalid for the either the source or target encoding.
  #
  class InvalidByteSequenceError < EncodingError
    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.destination_encoding         -> string
    # -->
    # Returns the destination encoding as an encoding object.
    #
    def destination_encoding: () -> Encoding

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.destination_encoding_name         -> string
    # -->
    # Returns the destination encoding name as a string.
    #
    def destination_encoding_name: () -> String

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.error_bytes         -> string
    # -->
    # Returns the discarded bytes when Encoding::InvalidByteSequenceError occurs.
    #
    #     ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    #     begin
    #       ec.convert("abc\xA1\xFFdef")
    #     rescue Encoding::InvalidByteSequenceError
    #       p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "\xFF" on EUC-JP>
    #       puts $!.error_bytes.dump          #=> "\xA1"
    #       puts $!.readagain_bytes.dump      #=> "\xFF"
    #     end
    #
    def error_bytes: () -> String

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.incomplete_input?         -> true or false
    # -->
    # Returns true if the invalid byte sequence error is caused by premature end of
    # string.
    #
    #     ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    #
    #     begin
    #       ec.convert("abc\xA1z")
    #     rescue Encoding::InvalidByteSequenceError
    #       p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "z" on EUC-JP>
    #       p $!.incomplete_input?    #=> false
    #     end
    #
    #     begin
    #       ec.convert("abc\xA1")
    #       ec.finish
    #     rescue Encoding::InvalidByteSequenceError
    #       p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1" on EUC-JP>
    #       p $!.incomplete_input?    #=> true
    #     end
    #
    def incomplete_input?: () -> bool

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.readagain_bytes         -> string
    # -->
    # Returns the bytes to be read again when Encoding::InvalidByteSequenceError
    # occurs.
    #
    def readagain_bytes: () -> String

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.source_encoding              -> encoding
    # -->
    # Returns the source encoding as an encoding object.
    #
    # Note that the result may not be equal to the source encoding of the encoding
    # converter if the conversion has multiple steps.
    #
    #     ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8 -> EUC-JP
    #     begin
    #       ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.
    #     rescue Encoding::UndefinedConversionError
    #       p $!.source_encoding              #=> #<Encoding:UTF-8>
    #       p $!.destination_encoding         #=> #<Encoding:EUC-JP>
    #       p $!.source_encoding_name         #=> "UTF-8"
    #       p $!.destination_encoding_name    #=> "EUC-JP"
    #     end
    #
    def source_encoding: () -> Encoding

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.source_encoding_name         -> string
    # -->
    # Returns the source encoding name as a string.
    #
    def source_encoding_name: () -> String
  end

  # <!-- rdoc-file=transcode.c -->
  # Raised by Encoding and String methods when a transcoding operation fails.
  #
  class UndefinedConversionError < EncodingError
    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.destination_encoding         -> string
    # -->
    # Returns the destination encoding as an encoding object.
    #
    def destination_encoding: () -> Encoding

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.destination_encoding_name         -> string
    # -->
    # Returns the destination encoding name as a string.
    #
    def destination_encoding_name: () -> String

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.error_char         -> string
    # -->
    # Returns the one-character string which cause
    # Encoding::UndefinedConversionError.
    #
    #     ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")
    #     begin
    #       ec.convert("\xa0")
    #     rescue Encoding::UndefinedConversionError
    #       puts $!.error_char.dump   #=> "\xC2\xA0"
    #       p $!.error_char.encoding  #=> #<Encoding:UTF-8>
    #     end
    #
    def error_char: () -> String

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.source_encoding              -> encoding
    # -->
    # Returns the source encoding as an encoding object.
    #
    # Note that the result may not be equal to the source encoding of the encoding
    # converter if the conversion has multiple steps.
    #
    #     ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8 -> EUC-JP
    #     begin
    #       ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.
    #     rescue Encoding::UndefinedConversionError
    #       p $!.source_encoding              #=> #<Encoding:UTF-8>
    #       p $!.destination_encoding         #=> #<Encoding:EUC-JP>
    #       p $!.source_encoding_name         #=> "UTF-8"
    #       p $!.destination_encoding_name    #=> "EUC-JP"
    #     end
    #
    def source_encoding: () -> Encoding

    # <!--
    #   rdoc-file=transcode.c
    #   - ecerr.source_encoding_name         -> string
    # -->
    # Returns the source encoding name as a string.
    #
    def source_encoding_name: () -> String
  end
end

# <!-- rdoc-file=transcode.c -->
# Encoding conversion class.
#
class Encoding::Converter < Object
  type encoding = String | Encoding
  type decorator = "universal_newline"
                  | "crlf_newline"
                  | "cr_newline"
                  | "xml_text_escape"
                  | "xml_attr_content_escape"
                  | "xml_attr_quote"
  type conversion_path = Array[[encoding, encoding] | decorator]
  type convert_result = :invalid_byte_sequence
                      | :incomplete_input
                      | :undefined_conversion
                      | :after_output
                      | :destination_buffer_full
                      | :source_buffer_empty
                      | :finished

  # <!--
  #   rdoc-file=transcode.c
  #   - Encoding::Converter.asciicompat_encoding(string) -> encoding or nil
  #   - Encoding::Converter.asciicompat_encoding(encoding) -> encoding or nil
  # -->
  # Returns the corresponding ASCII compatible encoding.
  #
  # Returns nil if the argument is an ASCII compatible encoding.
  #
  # "corresponding ASCII compatible encoding" is an ASCII compatible encoding
  # which can represents exactly the same characters as the given ASCII
  # incompatible encoding. So, no conversion undefined error occurs when
  # converting between the two encodings.
  #
  #     Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=> #<Encoding:stateless-ISO-2022-JP>
  #     Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>
  #     Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil
  #
  def self.asciicompat_encoding: (encoding enc) -> Encoding?

  # <!--
  #   rdoc-file=transcode.c
  #   - Encoding::Converter.search_convpath(source_encoding, destination_encoding)         -> ary
  #   - Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    -> ary
  # -->
  # Returns a conversion path.
  #
  #     p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")
  #     #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
  #     #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]
  #
  #     p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", universal_newline: true)
  #     or
  #     p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", newline: :universal)
  #     #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
  #     #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
  #     #    "universal_newline"]
  #
  #     p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", universal_newline: true)
  #     or
  #     p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", newline: :universal)
  #     #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
  #     #    "universal_newline",
  #     #    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]
  #
  def self.search_convpath: (
                              encoding source,
                              encoding destination,
                              ?newline: :universal | :crlf | :cr,
                              ?universal_newline: bool,
                              ?crlf_newline: bool,
                              ?cr_newline: bool,
                              ?xml: :text | :attr
                            ) -> conversion_path

  # <!--
  #   rdoc-file=transcode.c
  #   - ec == other        -> true or false
  # -->
  #
  def ==: (self) -> bool

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.convert(source_string) -> destination_string
  # -->
  # Convert source_string and return destination_string.
  #
  # source_string is assumed as a part of source. i.e.  :partial_input=>true is
  # specified internally. finish method should be used last.
  #
  #     ec = Encoding::Converter.new("utf-8", "euc-jp")
  #     puts ec.convert("\u3042").dump     #=> "\xA4\xA2"
  #     puts ec.finish.dump                #=> ""
  #
  #     ec = Encoding::Converter.new("euc-jp", "utf-8")
  #     puts ec.convert("\xA4").dump       #=> ""
  #     puts ec.convert("\xA2").dump       #=> "\xE3\x81\x82"
  #     puts ec.finish.dump                #=> ""
  #
  #     ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
  #     puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")
  #     puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")
  #     puts ec.convert("\x82").dump       #=> "\e$B$\"".force_encoding("ISO-2022-JP")
  #     puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")
  #
  # If a conversion error occur, Encoding::UndefinedConversionError or
  # Encoding::InvalidByteSequenceError is raised. Encoding::Converter#convert
  # doesn't supply methods to recover or restart from these exceptions. When you
  # want to handle these conversion errors, use
  # Encoding::Converter#primitive_convert.
  #
  def convert: (String source) -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.convpath        -> ary
  # -->
  # Returns the conversion path of ec.
  #
  # The result is an array of conversions.
  #
  #     ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP", crlf_newline: true)
  #     p ec.convpath
  #     #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
  #     #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
  #     #    "crlf_newline"]
  #
  # Each element of the array is a pair of encodings or a string. A pair means an
  # encoding conversion. A string means a decorator.
  #
  # In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means a
  # converter from ISO-8859-1 to UTF-8. "crlf_newline" means newline converter
  # from LF to CRLF.
  #
  def convpath: () -> conversion_path

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.destination_encoding -> encoding
  # -->
  # Returns the destination encoding as an Encoding object.
  #
  def destination_encoding: () -> Encoding

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.finish -> string
  # -->
  # Finishes the converter. It returns the last part of the converted string.
  #
  #     ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
  #     p ec.convert("\u3042")     #=> "\e$B$\""
  #     p ec.finish                #=> "\e(B"
  #
  def finish: () -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.insert_output(string) -> nil
  # -->
  # Inserts string into the encoding converter. The string will be converted to
  # the destination encoding and output on later conversions.
  #
  # If the destination encoding is stateful, string is converted according to the
  # state and the state is updated.
  #
  # This method should be used only when a conversion error occurs.
  #
  #     ec = Encoding::Converter.new("utf-8", "iso-8859-1")
  #     src = "HIRAGANA LETTER A is \u{3042}."
  #     dst = ""
  #     p ec.primitive_convert(src, dst)    #=> :undefined_conversion
  #     puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is ", "."]
  #     ec.insert_output("<err>")
  #     p ec.primitive_convert(src, dst)    #=> :finished
  #     puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is <err>.", ""]
  #
  #     ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
  #     src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in iso-2022-jp
  #     dst = ""
  #     p ec.primitive_convert(src, dst)    #=> :undefined_conversion
  #     puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]
  #     ec.insert_output "?"                # state change required to output "?".
  #     p ec.primitive_convert(src, dst)    #=> :finished
  #     puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]
  #
  def insert_output: (String) -> nil

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.inspect         -> string
  # -->
  # Returns a printable version of *ec*
  #
  #     ec = Encoding::Converter.new("iso-8859-1", "utf-8")
  #     puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.last_error -> exception or nil
  # -->
  # Returns an exception object for the last conversion. Returns nil if the last
  # conversion did not produce an error.
  #
  # "error" means that Encoding::InvalidByteSequenceError and
  # Encoding::UndefinedConversionError for Encoding::Converter#convert and
  # :invalid_byte_sequence, :incomplete_input and :undefined_conversion for
  # Encoding::Converter#primitive_convert.
  #
  #     ec = Encoding::Converter.new("utf-8", "iso-8859-1")
  #     p ec.primitive_convert(src="\xf1abcd", dst="")       #=> :invalid_byte_sequence
  #     p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1" followed by "a" on UTF-8>
  #     p ec.primitive_convert(src, dst, nil, 1)             #=> :destination_buffer_full
  #     p ec.last_error      #=> nil
  #
  def last_error: () -> Encoding::InvalidByteSequenceError?
                | () -> Encoding::UndefinedConversionError?

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.primitive_convert(source_buffer, destination_buffer) -> symbol
  #   - ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) -> symbol
  #   - ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) -> symbol
  #   - ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) -> symbol
  # -->
  # possible opt elements:
  #     hash form:
  #       :partial_input => true           # source buffer may be part of larger source
  #       :after_output => true            # stop conversion after output before input
  #     integer form:
  #       Encoding::Converter::PARTIAL_INPUT
  #       Encoding::Converter::AFTER_OUTPUT
  #
  # possible results:
  #     :invalid_byte_sequence
  #     :incomplete_input
  #     :undefined_conversion
  #     :after_output
  #     :destination_buffer_full
  #     :source_buffer_empty
  #     :finished
  #
  # primitive_convert converts source_buffer into destination_buffer.
  #
  # source_buffer should be a string or nil. nil means an empty string.
  #
  # destination_buffer should be a string.
  #
  # destination_byteoffset should be an integer or nil. nil means the end of
  # destination_buffer. If it is omitted, nil is assumed.
  #
  # destination_bytesize should be an integer or nil. nil means unlimited. If it
  # is omitted, nil is assumed.
  #
  # opt should be nil, a hash or an integer. nil means no flags. If it is omitted,
  # nil is assumed.
  #
  # primitive_convert converts the content of source_buffer from beginning and
  # store the result into destination_buffer.
  #
  # destination_byteoffset and destination_bytesize specify the region which the
  # converted result is stored. destination_byteoffset specifies the start
  # position in destination_buffer in bytes. If destination_byteoffset is nil,
  # destination_buffer.bytesize is used for appending the result.
  # destination_bytesize specifies maximum number of bytes. If
  # destination_bytesize is nil, destination size is unlimited. After conversion,
  # destination_buffer is resized to destination_byteoffset + actually produced
  # number of bytes. Also destination_buffer's encoding is set to
  # destination_encoding.
  #
  # primitive_convert drops the converted part of source_buffer. the dropped part
  # is converted in destination_buffer or buffered in Encoding::Converter object.
  #
  # primitive_convert stops conversion when one of following condition met.
  # *   invalid byte sequence found in source buffer (:invalid_byte_sequence)
  #     `primitive_errinfo` and `last_error` methods returns the detail of the
  #     error.
  # *   unexpected end of source buffer (:incomplete_input) this occur only when
  #     :partial_input is not specified. `primitive_errinfo` and `last_error`
  #     methods returns the detail of the error.
  # *   character not representable in output encoding (:undefined_conversion)
  #     `primitive_errinfo` and `last_error` methods returns the detail of the
  #     error.
  # *   after some output is generated, before input is done (:after_output) this
  #     occur only when :after_output is specified.
  # *   destination buffer is full (:destination_buffer_full) this occur only when
  #     destination_bytesize is non-nil.
  # *   source buffer is empty (:source_buffer_empty) this occur only when
  #     :partial_input is specified.
  # *   conversion is finished (:finished)
  #
  # example:
  #     ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
  #     ret = ec.primitive_convert(src="pi", dst="", nil, 100)
  #     p [ret, src, dst] #=> [:finished, "", "\x00p\x00i"]
  #
  #     ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
  #     ret = ec.primitive_convert(src="pi", dst="", nil, 1)
  #     p [ret, src, dst] #=> [:destination_buffer_full, "i", "\x00"]
  #     ret = ec.primitive_convert(src, dst="", nil, 1)
  #     p [ret, src, dst] #=> [:destination_buffer_full, "", "p"]
  #     ret = ec.primitive_convert(src, dst="", nil, 1)
  #     p [ret, src, dst] #=> [:destination_buffer_full, "", "\x00"]
  #     ret = ec.primitive_convert(src, dst="", nil, 1)
  #     p [ret, src, dst] #=> [:finished, "", "i"]
  #
  def primitive_convert: (
                          String? source,
                          String destination,
                          ?Integer? destination_byteoffset,
                          ?Integer? destination_bytesize,
                          ?partial_input: bool,
                          ?after_output: bool
                        ) -> convert_result
                       | (
                          String? source,
                          String destination,
                          ?Integer? destination_byteoffset,
                          ?Integer? destination_bytesize,
                          ?Integer opt
                        ) -> convert_result

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.primitive_errinfo -> array
  # -->
  # primitive_errinfo returns important information regarding the last error as a
  # 5-element array:
  #
  #     [result, enc1, enc2, error_bytes, readagain_bytes]
  #
  # result is the last result of primitive_convert.
  #
  # Other elements are only meaningful when result is :invalid_byte_sequence,
  # :incomplete_input or :undefined_conversion.
  #
  # enc1 and enc2 indicate a conversion step as a pair of strings. For example, a
  # converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP ->
  # UTF-8 -> ISO-8859-1. So [enc1, enc2] is either ["EUC-JP", "UTF-8"] or
  # ["UTF-8", "ISO-8859-1"].
  #
  # error_bytes and readagain_bytes indicate the byte sequences which caused the
  # error. error_bytes is discarded portion. readagain_bytes is buffered portion
  # which is read again on next conversion.
  #
  # Example:
  #
  #     # \xff is invalid as EUC-JP.
  #     ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")
  #     ec.primitive_convert(src="\xff", dst="", nil, 10)
  #     p ec.primitive_errinfo
  #     #=> [:invalid_byte_sequence, "EUC-JP", "Shift_JIS", "\xFF", ""]
  #
  #     # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
  #     # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
  #     # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
  #     ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
  #     ec.primitive_convert(src="\xa4\xa2", dst="", nil, 10)
  #     p ec.primitive_errinfo
  #     #=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]
  #
  #     # partial character is invalid
  #     ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
  #     ec.primitive_convert(src="\xa4", dst="", nil, 10)
  #     p ec.primitive_errinfo
  #     #=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]
  #
  #     # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
  #     # partial characters.
  #     ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
  #     ec.primitive_convert(src="\xa4", dst="", nil, 10, Encoding::Converter::PARTIAL_INPUT)
  #     p ec.primitive_errinfo
  #     #=> [:source_buffer_empty, nil, nil, nil, nil]
  #
  #     # \xd8\x00\x00@ is invalid as UTF-16BE because
  #     # no low surrogate after high surrogate (\xd8\x00).
  #     # It is detected by 3rd byte (\00) which is part of next character.
  #     # So the high surrogate (\xd8\x00) is discarded and
  #     # the 3rd byte is read again later.
  #     # Since the byte is buffered in ec, it is dropped from src.
  #     ec = Encoding::Converter.new("UTF-16BE", "UTF-8")
  #     ec.primitive_convert(src="\xd8\x00\x00@", dst="", nil, 10)
  #     p ec.primitive_errinfo
  #     #=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]
  #     p src
  #     #=> "@"
  #
  #     # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
  #     # The problem is detected by 4th byte.
  #     ec = Encoding::Converter.new("UTF-16LE", "UTF-8")
  #     ec.primitive_convert(src="\x00\xd8@\x00", dst="", nil, 10)
  #     p ec.primitive_errinfo
  #     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]
  #     p src
  #     #=> ""
  #
  def primitive_errinfo: () -> [convert_result, String?, String?, String?, String?]

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.putback                    -> string
  #   - ec.putback(max_numbytes)      -> string
  # -->
  # Put back the bytes which will be converted.
  #
  # The bytes are caused by invalid_byte_sequence error. When
  # invalid_byte_sequence error, some bytes are discarded and some bytes are
  # buffered to be converted later. The latter bytes can be put back. It can be
  # observed by Encoding::InvalidByteSequenceError#readagain_bytes and
  # Encoding::Converter#primitive_errinfo.
  #
  #     ec = Encoding::Converter.new("utf-16le", "iso-8859-1")
  #     src = "\x00\xd8\x61\x00"
  #     dst = ""
  #     p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence
  #     p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "a\x00"]
  #     p ec.putback               #=> "a\x00"
  #     p ec.putback               #=> ""          # no more bytes to put back
  #
  def putback: (?Integer max_numbytes) -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.replacement -> string
  # -->
  # Returns the replacement string.
  #
  #     ec = Encoding::Converter.new("euc-jp", "us-ascii")
  #     p ec.replacement    #=> "?"
  #
  #     ec = Encoding::Converter.new("euc-jp", "utf-8")
  #     p ec.replacement    #=> "\uFFFD"
  #
  def replacement: () -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.replacement = string
  # -->
  # Sets the replacement string.
  #
  #     ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)
  #     ec.replacement = "<undef>"
  #     p ec.convert("a \u3042 b")      #=> "a <undef> b"
  #
  def replacement=: (String str) -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - ec.source_encoding -> encoding
  # -->
  # Returns the source encoding as an Encoding object.
  #
  def source_encoding: () -> Encoding

  private

  # <!--
  #   rdoc-file=transcode.c
  #   - Encoding::Converter.new(source_encoding, destination_encoding)
  #   - Encoding::Converter.new(source_encoding, destination_encoding, opt)
  #   - Encoding::Converter.new(convpath)
  # -->
  # possible options elements:
  #     hash form:
  #       :invalid => nil            # raise error on invalid byte sequence (default)
  #       :invalid => :replace       # replace invalid byte sequence
  #       :undef => nil              # raise error on undefined conversion (default)
  #       :undef => :replace         # replace undefined conversion
  #       :replace => string         # replacement string ("?" or "\uFFFD" if not specified)
  #       :newline => :universal     # decorator for converting CRLF and CR to LF
  #       :newline => :lf            # decorator for converting CRLF and CR to LF when writing
  #       :newline => :crlf          # decorator for converting LF to CRLF
  #       :newline => :cr            # decorator for converting LF to CR
  #       :universal_newline => true # decorator for converting CRLF and CR to LF
  #       :crlf_newline => true      # decorator for converting LF to CRLF
  #       :cr_newline => true        # decorator for converting LF to CR
  #       :lf_newline => true        # decorator for converting CRLF and CR to LF when writing
  #       :xml => :text              # escape as XML CharData.
  #       :xml => :attr              # escape as XML AttValue
  #     integer form:
  #       Encoding::Converter::INVALID_REPLACE
  #       Encoding::Converter::UNDEF_REPLACE
  #       Encoding::Converter::UNDEF_HEX_CHARREF
  #       Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
  #       Encoding::Converter::LF_NEWLINE_DECORATOR
  #       Encoding::Converter::CRLF_NEWLINE_DECORATOR
  #       Encoding::Converter::CR_NEWLINE_DECORATOR
  #       Encoding::Converter::XML_TEXT_DECORATOR
  #       Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
  #       Encoding::Converter::XML_ATTR_QUOTE_DECORATOR
  #
  # Encoding::Converter.new creates an instance of Encoding::Converter.
  #
  # Source_encoding and destination_encoding should be a string or Encoding
  # object.
  #
  # opt should be nil, a hash or an integer.
  #
  # convpath should be an array. convpath may contain
  # *   two-element arrays which contain encodings or encoding names, or
  # *   strings representing decorator names.
  #
  # Encoding::Converter.new optionally takes an option. The option should be a
  # hash or an integer. The option hash can contain :invalid => nil, etc. The
  # option integer should be logical-or of constants such as
  # Encoding::Converter::INVALID_REPLACE, etc.
  #
  # :invalid => nil
  # :   Raise error on invalid byte sequence.  This is a default behavior.
  #
  # :invalid => :replace
  # :   Replace invalid byte sequence by replacement string.
  #
  # :undef => nil
  # :   Raise an error if a character in source_encoding is not defined in
  #     destination_encoding. This is a default behavior.
  #
  # :undef => :replace
  # :   Replace undefined character in destination_encoding with replacement
  #     string.
  #
  # :replace => string
  # :   Specify the replacement string. If not specified, "uFFFD" is used for
  #     Unicode encodings and "?" for others.
  #
  # :universal_newline => true
  # :   Convert CRLF and CR to LF.
  #
  # :crlf_newline => true
  # :   Convert LF to CRLF.
  #
  # :cr_newline => true
  # :   Convert LF to CR.
  #
  # :lf_newline => true
  # :   Convert CRLF and CR to LF (when writing).
  #
  # :xml => :text
  # :   Escape as XML CharData. This form can be used as an HTML 4.0 #PCDATA.
  #     *   '&' -> '&amp;'
  #     *   '<' -> '&lt;'
  #     *   '>' -> '&gt;'
  #     *   undefined characters in destination_encoding -> hexadecimal CharRef
  #         such as &#xHH;
  #
  # :xml => :attr
  # :   Escape as XML AttValue. The converted result is quoted as "...". This form
  #     can be used as an HTML 4.0 attribute value.
  #     *   '&' -> '&amp;'
  #     *   '<' -> '&lt;'
  #     *   '>' -> '&gt;'
  #     *   '"' -> '&quot;'
  #     *   undefined characters in destination_encoding -> hexadecimal CharRef
  #         such as &#xHH;
  #
  #
  # Examples:
  #     # UTF-16BE to UTF-8
  #     ec = Encoding::Converter.new("UTF-16BE", "UTF-8")
  #
  #     # Usually, decorators such as newline conversion are inserted last.
  #     ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)
  #     p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],
  #                   #    "universal_newline"]
  #
  #     # But, if the last encoding is ASCII incompatible,
  #     # decorators are inserted before the last conversion.
  #     ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)
  #     p ec.convpath #=> ["crlf_newline",
  #                   #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]
  #
  #     # Conversion path can be specified directly.
  #     ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"], ["UTF-8", "UTF-16BE"]])
  #     p ec.convpath #=> ["universal_newline",
  #                   #    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],
  #                   #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]
  #
  def initialize: (encoding source, encoding destination) -> void
                | (encoding source, encoding destination,
                    ?invalid: :replace | nil,
                    ?undef: :replace | nil,
                    ?replace: String,
                    ?newline: :universal | :crlf | :cr,
                    ?universal_newline: bool,
                    ?crlf_newline: bool,
                    ?cr_newline: bool,
                    ?xml: :text | :attr
                  ) -> void
                | (encoding source, encoding destination, Integer opts) -> void
                | (conversion_path convpath) -> void
end

# <!-- rdoc-file=transcode.c -->
# Stop converting after some output is complete but before all of the input was
# consumed.  See primitive_convert for an example.
#
Encoding::Converter::AFTER_OUTPUT: Integer

# <!-- rdoc-file=transcode.c -->
# Decorator for converting LF to CRLF
#
Encoding::Converter::CRLF_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# Decorator for converting LF to CR
#
Encoding::Converter::CR_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# Mask for invalid byte sequences
#
Encoding::Converter::INVALID_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# Replace invalid byte sequences
#
Encoding::Converter::INVALID_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# Indicates the source may be part of a larger string.  See primitive_convert
# for an example.
#
Encoding::Converter::PARTIAL_INPUT: Integer

# <!-- rdoc-file=transcode.c -->
# Replace byte sequences that are undefined in the destination encoding with an
# XML hexadecimal character reference.  This is valid for XML conversion.
#
Encoding::Converter::UNDEF_HEX_CHARREF: Integer

# <!-- rdoc-file=transcode.c -->
# Mask for a valid character in the source encoding but no related character(s)
# in destination encoding.
#
Encoding::Converter::UNDEF_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# Replace byte sequences that are undefined in the destination encoding.
#
Encoding::Converter::UNDEF_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# Decorator for converting CRLF and CR to LF
#
Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_CONTENT_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_QUOTE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# Escape as XML CharData
#
Encoding::Converter::XML_TEXT_DECORATOR: Integer
# <!-- rdoc-file=math.c -->
# Module Math provides methods for basic trigonometric, logarithmic, and
# transcendental functions, and for extracting roots.
#
# You can write its constants and method calls thus:
#
#     Math::PI      # => 3.141592653589793
#     Math::E       # => 2.718281828459045
#     Math.sin(0.0) # => 0.0
#     Math.cos(0.0) # => 1.0
#
# If you include module Math, you can write simpler forms:
#
#     include Math
#     PI       # => 3.141592653589793
#     E        # => 2.718281828459045
#     sin(0.0) # => 0.0
#     cos(0.0) # => 1.0
#
# For simplicity, the examples here assume:
#
#     include Math
#     INFINITY = Float::INFINITY
#
# The domains and ranges for the methods are denoted by open or closed
# intervals, using, respectively, parentheses or square brackets:
#
# *   An open interval does not include the endpoints:
#
#         (-INFINITY, INFINITY)
#
# *   A closed interval includes the endpoints:
#
#         [-1.0, 1.0]
#
# *   A half-open interval includes one endpoint, but not the other:
#
#         [1.0, INFINITY)
#
# Many values returned by Math methods are numerical approximations. This is
# because many such values are, in mathematics, of infinite precision, while in
# numerical computation the precision is finite.
#
# Thus, in mathematics, *cos(/2)* is exactly zero, but in our computation
# `cos(PI/2)` is a number very close to zero:
#
#     cos(PI/2) # => 6.123031769111886e-17
#
# For very large and very small returned values, we have added formatted numbers
# for clarity:
#
#     tan(PI/2)  # => 1.633123935319537e+16   # 16331239353195370.0
#     tan(PI)    # => -1.2246467991473532e-16 # -0.0000000000000001
#
# See class Float for the constants that affect Ruby's floating-point
# arithmetic.
#
# ### What's Here
#
# #### Trigonometric Functions
#
# *   ::cos: Returns the cosine of the given argument.
# *   ::sin: Returns the sine of the given argument.
# *   ::tan: Returns the tangent of the given argument.
#
# #### Inverse Trigonometric Functions
#
# *   ::acos: Returns the arc cosine of the given argument.
# *   ::asin: Returns the arc sine of the given argument.
# *   ::atan: Returns the arc tangent of the given argument.
# *   ::atan2: Returns the arg tangent of two given arguments.
#
# #### Hyperbolic Trigonometric Functions
#
# *   ::cosh: Returns the hyperbolic cosine of the given argument.
# *   ::sinh: Returns the hyperbolic sine of the given argument.
# *   ::tanh: Returns the hyperbolic tangent of the given argument.
#
# #### Inverse Hyperbolic Trigonometric Functions
#
# *   ::acosh: Returns the inverse hyperbolic cosine of the given argument.
# *   ::asinh: Returns the inverse hyperbolic sine of the given argument.
# *   ::atanh: Returns the inverse hyperbolic tangent of the given argument.
#
# #### Exponentiation and Logarithmic Functions
#
# *   ::exp: Returns the value of a given value raised to a given power.
# *   ::log: Returns the logarithm of a given value in a given base.
# *   ::log10: Returns the base 10 logarithm of the given argument.
# *   ::log2: Returns the base 2 logarithm of the given argument.
#
# #### Fraction and Exponent Functions
#
# *   ::frexp: Returns the fraction and exponent of the given argument.
# *   ::ldexp: Returns the value for a given fraction and exponent.
#
# #### Root Functions
#
# *   ::cbrt: Returns the cube root of the given argument.
# *   ::sqrt: Returns the square root of the given argument.
#
# #### Error Functions
#
# *   ::erf: Returns the value of the Gauss error function for the given
#     argument.
# *   ::erfc: Returns the value of the complementary error function for the
#     given argument.
#
# #### Gamma Functions
#
# *   ::gamma: Returns the value of the gamma function for the given argument.
# *   ::lgamma: Returns the value of the logarithmic gamma function for the
#     given argument.
#
# #### Hypotenuse Function
#
# *   ::hypot: Returns `sqrt(a**2 + b**2)` for the given `a` and `b`.
#
module Math
  # <!-- rdoc-file=math.c -->
  # Definition of the mathematical constant E for Euler's number (e) as a Float
  # number.
  #
  E: Float

  # <!-- rdoc-file=math.c -->
  # Definition of the mathematical constant PI as a Float number.
  #
  PI: Float

  # <!-- rdoc-file=math.c -->
  # Raised when a mathematical function is evaluated outside of its domain of
  # definition.
  #
  # For example, since `cos` returns values in the range -1..1, its inverse
  # function `acos` is only defined on that interval:
  #
  #     Math.acos(42)
  #
  # *produces:*
  #
  #     Math::DomainError: Numerical argument is out of domain - "acos"
  #
  class DomainError < StandardError
  end

  # A type that's passable to `Math` functions: A `Numeric` type that defines `.to_f`.
  #
  type double = Numeric & _ToF

  # <!--
  #   rdoc-file=math.c
  #   - Math.acos(x) -> float
  # -->
  # Returns the [arc
  # cosine](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of `x`.
  #
  # *   Domain: `[-1, 1]`.
  # *   Range: `[0, PI]`.
  #
  # Examples:
  #
  #     acos(-1.0) # => 3.141592653589793  # PI
  #     acos(0.0)  # => 1.5707963267948966 # PI/2
  #     acos(1.0)  # => 0.0
  #
  def self.acos: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.acosh(x) -> float
  # -->
  # Returns the [inverse hyperbolic
  # cosine](https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions) of `x`.
  #
  # *   Domain: `[1, INFINITY]`.
  # *   Range: `[0, INFINITY]`.
  #
  # Examples:
  #
  #     acosh(1.0)      # => 0.0
  #     acosh(INFINITY) # => Infinity
  #
  def self.acosh: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asin(x) -> float
  # -->
  # Returns the [arc
  # sine](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of `x`.
  #
  # *   Domain: `[-1, -1]`.
  # *   Range: `[-PI/2, PI/2]`.
  #
  # Examples:
  #
  #     asin(-1.0) # => -1.5707963267948966 # -PI/2
  #     asin(0.0)  # => 0.0
  #     asin(1.0)  # => 1.5707963267948966  # PI/2
  #
  def self.asin: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asinh(x) -> float
  # -->
  # Returns the [inverse hyperbolic
  # sine](https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions) of `x`.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     asinh(-INFINITY) # => -Infinity
  #     asinh(0.0)       # => 0.0
  #     asinh(INFINITY)  # => Infinity
  #
  def self.asinh: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan(x)    -> Float
  # -->
  # Returns the [arc
  # tangent](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of
  # `x`.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-PI/2, PI/2]  `.
  #
  # Examples:
  #
  #     atan(-INFINITY) # => -1.5707963267948966 # -PI2
  #     atan(-PI)       # => -1.2626272556789115
  #     atan(-PI/2)     # => -1.0038848218538872
  #     atan(0.0)       # => 0.0
  #     atan(PI/2)      # => 1.0038848218538872
  #     atan(PI)        # => 1.2626272556789115
  #     atan(INFINITY)  # => 1.5707963267948966  # PI/2
  #
  def self.atan: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan2(y, x) -> float
  # -->
  # Returns the [arc tangent](https://en.wikipedia.org/wiki/Atan2) of `y` and `x`
  # in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain of `y`: `[-INFINITY, INFINITY]`.
  # *   Domain of `x`: `[-INFINITY, INFINITY]`.
  # *   Range: `[-PI, PI]`.
  #
  # Examples:
  #
  #     atan2(-1.0, -1.0) # => -2.356194490192345  # -3*PI/4
  #     atan2(-1.0, 0.0)  # => -1.5707963267948966 # -PI/2
  #     atan2(-1.0, 1.0)  # => -0.7853981633974483 # -PI/4
  #     atan2(0.0, -1.0)  # => 3.141592653589793   # PI
  #
  def self.atan2: (double y, double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atanh(x) -> float
  # -->
  # Returns the [inverse hyperbolic
  # tangent](https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions) of `x`.
  #
  # *   Domain: `[-1, 1]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     atanh(-1.0) # => -Infinity
  #     atanh(0.0)  # => 0.0
  #     atanh(1.0)  # => Infinity
  #
  def self.atanh: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cbrt(x) -> float
  # -->
  # Returns the [cube root](https://en.wikipedia.org/wiki/Cube_root) of `x`.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     cbrt(-INFINITY) # => -Infinity
  #     cbrt(-27.0)     # => -3.0
  #     cbrt(-8.0)      # => -2.0
  #     cbrt(-2.0)      # => -1.2599210498948732
  #     cbrt(1.0)       # => 1.0
  #     cbrt(0.0)       # => 0.0
  #     cbrt(1.0)       # => 1.0
  #     cbrt(2.0)       # => 1.2599210498948732
  #     cbrt(8.0)       # => 2.0
  #     cbrt(27.0)      # => 3.0
  #     cbrt(INFINITY)  # => Infinity
  #
  def self.cbrt: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cos(x) -> float
  # -->
  # Returns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `(-INFINITY, INFINITY)`.
  # *   Range: `[-1.0, 1.0]`.
  #
  # Examples:
  #
  #     cos(-PI)   # => -1.0
  #     cos(-PI/2) # => 6.123031769111886e-17 # 0.0000000000000001
  #     cos(0.0)   # => 1.0
  #     cos(PI/2)  # => 6.123031769111886e-17 # 0.0000000000000001
  #     cos(PI)    # => -1.0
  #
  def self.cos: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cosh(x) -> float
  # -->
  # Returns the [hyperbolic
  # cosine](https://en.wikipedia.org/wiki/Hyperbolic_functions) of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[1, INFINITY]`.
  #
  # Examples:
  #
  #     cosh(-INFINITY) # => Infinity
  #     cosh(0.0)       # => 1.0
  #     cosh(INFINITY)  # => Infinity
  #
  def self.cosh: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erf(x) -> float
  # -->
  # Returns the value of the [Gauss error
  # function](https://en.wikipedia.org/wiki/Error_function) for `x`.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-1, 1]`.
  #
  # Examples:
  #
  #     erf(-INFINITY) # => -1.0
  #     erf(0.0)       # => 0.0
  #     erf(INFINITY)  # => 1.0
  #
  # Related: Math.erfc.
  #
  def self.erf: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erfc(x)  -> Float
  # -->
  # Returns the value of the [complementary error
  # function](https://en.wikipedia.org/wiki/Error_function#Complementary_error_fun
  # ction) for `x`.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[0, 2]`.
  #
  # Examples:
  #
  #     erfc(-INFINITY) # => 2.0
  #     erfc(0.0)       # => 1.0
  #     erfc(INFINITY)  # => 0.0
  #
  # Related: Math.erf.
  #
  def self.erfc: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.exp(x) -> float
  # -->
  # Returns `e` raised to the `x` power.
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[0, INFINITY]`.
  #
  # Examples:
  #
  #     exp(-INFINITY) # => 0.0
  #     exp(-1.0)      # => 0.36787944117144233 # 1.0/E
  #     exp(0.0)       # => 1.0
  #     exp(0.5)       # => 1.6487212707001282  # sqrt(E)
  #     exp(1.0)       # => 2.718281828459045   # E
  #     exp(2.0)       # => 7.38905609893065    # E**2
  #     exp(INFINITY)  # => Infinity
  #
  def self.exp: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.frexp(x) -> [fraction, exponent]
  # -->
  # Returns a 2-element array containing the normalized signed float `fraction`
  # and integer `exponent` of `x` such that:
  #
  #     x = fraction * 2**exponent
  #
  # See [IEEE 754 double-precision binary floating-point format:
  # binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format
  # #IEEE_754_double-precision_binary_floating-point_format:_binary64).
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     frexp(-INFINITY) # => [-Infinity, -1]
  #     frexp(-2.0)      # => [-0.5, 2]
  #     frexp(-1.0)      # => [-0.5, 1]
  #     frexp(0.0)       # => [0.0, 0]
  #     frexp(1.0)       # => [0.5, 1]
  #     frexp(2.0)       # => [0.5, 2]
  #     frexp(INFINITY)  # => [Infinity, -1]
  #
  # Related: Math.ldexp (inverse of Math.frexp).
  #
  def self.frexp: (double x) -> [Float, Integer]

  # <!--
  #   rdoc-file=math.c
  #   - Math.gamma(x) -> float
  # -->
  # Returns the value of the [gamma
  # function](https://en.wikipedia.org/wiki/Gamma_function) for `x`.
  #
  # *   Domain: `(-INFINITY, INFINITY]` excluding negative integers.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     gamma(-2.5)      # => -0.9453087204829431
  #     gamma(-1.5)      # => 2.3632718012073513
  #     gamma(-0.5)      # => -3.5449077018110375
  #     gamma(0.0)      # => Infinity
  #     gamma(1.0)      # => 1.0
  #     gamma(2.0)      # => 1.0
  #     gamma(3.0)      # => 2.0
  #     gamma(4.0)      # => 6.0
  #     gamma(5.0)      # => 24.0
  #
  # Related: Math.lgamma.
  #
  def self.gamma: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.hypot(a, b) -> float
  # -->
  # Returns `sqrt(a**2 + b**2)`, which is the length of the longest side `c` (the
  # hypotenuse) of the right triangle whose other sides have lengths `a` and `b`.
  #
  # *   Domain of `a`: `[-INFINITY, INFINITY]`.
  # *   Domain of +ab: `[-INFINITY, INFINITY]`.
  # *   Range: `[0, INFINITY]`.
  #
  # Examples:
  #
  #     hypot(0.0, 1.0)       # => 1.0
  #     hypot(1.0, 1.0)       # => 1.4142135623730951 # sqrt(2.0)
  #     hypot(3.0, 4.0)       # => 5.0
  #     hypot(5.0, 12.0)      # => 13.0
  #     hypot(1.0, sqrt(3.0)) # => 1.9999999999999998 # Near 2.0
  #
  # Note that if either argument is `INFINITY` or `-INFINITY`, the result is
  # `Infinity`.
  #
  def self.hypot: (double x, double y) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.ldexp(fraction, exponent) -> float
  # -->
  # Returns the value of `fraction * 2**exponent`.
  #
  # *   Domain of `fraction`: `[0.0, 1.0)`.
  # *   Domain of `exponent`: `[0, 1024]` (larger values are equivalent to 1024).
  #
  # See [IEEE 754 double-precision binary floating-point format:
  # binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format
  # #IEEE_754_double-precision_binary_floating-point_format:_binary64).
  #
  # Examples:
  #
  #     ldexp(-INFINITY, -1) # => -Infinity
  #     ldexp(-0.5, 2)       # => -2.0
  #     ldexp(-0.5, 1)       # => -1.0
  #     ldexp(0.0, 0)        # => 0.0
  #     ldexp(-0.5, 1)       # => 1.0
  #     ldexp(-0.5, 2)       # => 2.0
  #     ldexp(INFINITY, -1)  # => Infinity
  #
  # Related: Math.frexp (inverse of Math.ldexp).
  #
  def self.ldexp: (double fraction, int exponent) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.lgamma(x) -> [float, -1 or 1]
  # -->
  # Returns a 2-element array equivalent to:
  #
  #     [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]
  #
  # See [logarithmic gamma
  # function](https://en.wikipedia.org/wiki/Gamma_function#The_log-gamma_function)
  # .
  #
  # *   Domain: `(-INFINITY, INFINITY]`.
  # *   Range of first element: `(-INFINITY, INFINITY]`.
  # *   Second element is -1 or 1.
  #
  # Examples:
  #
  #     lgamma(-4.0) # => [Infinity, -1]
  #     lgamma(-3.0) # => [Infinity, -1]
  #     lgamma(-2.0) # => [Infinity, -1]
  #     lgamma(-1.0) # => [Infinity, -1]
  #     lgamma(0.0)  # => [Infinity, 1]
  #
  #     lgamma(1.0)  # => [0.0, 1]
  #     lgamma(2.0)  # => [0.0, 1]
  #     lgamma(3.0)  # => [0.6931471805599436, 1]
  #     lgamma(4.0)  # => [1.7917594692280545, 1]
  #
  #     lgamma(-2.5) # => [-0.05624371649767279, -1]
  #     lgamma(-1.5) # => [0.8600470153764797, 1]
  #     lgamma(-0.5) # => [1.265512123484647, -1]
  #     lgamma(0.5)  # => [0.5723649429247004, 1]
  #     lgamma(1.5)  # => [-0.12078223763524676, 1]
  #     lgamma(2.5)      # => [0.2846828704729205, 1]
  #
  # Related: Math.gamma.
  #
  def self.lgamma: (double x) -> [Float, -1 | 1]

  # <!--
  #   rdoc-file=math.c
  #   - Math.log(x, base = Math::E) -> Float
  # -->
  # Returns the base `base` [logarithm](https://en.wikipedia.org/wiki/Logarithm)
  # of `x`.
  #
  # *   Domain: `[0, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY)]`.
  #
  # Examples:
  #
  #     log(0.0)        # => -Infinity
  #     log(1.0)        # => 0.0
  #     log(E)          # => 1.0
  #     log(INFINITY)   # => Infinity
  #
  #     log(0.0, 2.0)   # => -Infinity
  #     log(1.0, 2.0)   # => 0.0
  #     log(2.0, 2.0)   # => 1.0
  #
  #     log(0.0, 10.0)  # => -Infinity
  #     log(1.0, 10.0)  # => 0.0
  #     log(10.0, 10.0) # => 1.0
  #
  def self.log: (double x, ?double base) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log10(x) -> float
  # -->
  # Returns the base 10 [logarithm](https://en.wikipedia.org/wiki/Logarithm) of
  # `x`.
  #
  # *   Domain: `[0, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     log10(0.0)      # => -Infinity
  #     log10(1.0)      # => 0.0
  #     log10(10.0)     # => 1.0
  #     log10(INFINITY) # => Infinity
  #
  def self.log10: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log2(x) -> float
  # -->
  # Returns the base 2 [logarithm](https://en.wikipedia.org/wiki/Logarithm) of
  # `x`.
  #
  # *   Domain: `[0, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     log2(0.0)      # => -Infinity
  #     log2(1.0)      # => 0.0
  #     log2(2.0)      # => 1.0
  #     log2(INFINITY) # => Infinity
  #
  def self.log2: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sin(x) -> float
  # -->
  # Returns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `(-INFINITY, INFINITY)`.
  # *   Range: `[-1.0, 1.0]`.
  #
  # Examples:
  #
  #     sin(-PI)   # => -1.2246063538223773e-16 # -0.0000000000000001
  #     sin(-PI/2) # => -1.0
  #     sin(0.0)   # => 0.0
  #     sin(PI/2)  # => 1.0
  #     sin(PI)    # => 1.2246063538223773e-16  # 0.0000000000000001
  #
  def self.sin: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sinh(x) -> float
  # -->
  # Returns the [hyperbolic
  # sine](https://en.wikipedia.org/wiki/Hyperbolic_functions) of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-INFINITY, INFINITY]`.
  #
  # Examples:
  #
  #     sinh(-INFINITY) # => -Infinity
  #     sinh(0.0)       # => 0.0
  #     sinh(INFINITY)  # => Infinity
  #
  def self.sinh: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sqrt(x) -> float
  # -->
  # Returns the principal (non-negative) [square
  # root](https://en.wikipedia.org/wiki/Square_root) of `x`.
  #
  # *   Domain: `[0, INFINITY]`.
  # *   Range: `[0, INFINITY]`.
  #
  # Examples:
  #
  #     sqrt(0.0)      # => 0.0
  #     sqrt(0.5)      # => 0.7071067811865476
  #     sqrt(1.0)      # => 1.0
  #     sqrt(2.0)      # => 1.4142135623730951
  #     sqrt(4.0)      # => 2.0
  #     sqrt(9.0)      # => 3.0
  #     sqrt(INFINITY) # => Infinity
  #
  def self.sqrt: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tan(x) -> float
  # -->
  # Returns the [tangent](https://en.wikipedia.org/wiki/Trigonometric_functions)
  # of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `(-INFINITY, INFINITY)`.
  # *   Range: `(-INFINITY, INFINITY)`.
  #
  # Examples:
  #
  #     tan(-PI)   # => 1.2246467991473532e-16  # -0.0000000000000001
  #     tan(-PI/2) # => -1.633123935319537e+16  # -16331239353195370.0
  #     tan(0.0)   # => 0.0
  #     tan(PI/2)  # => 1.633123935319537e+16   # 16331239353195370.0
  #     tan(PI)    # => -1.2246467991473532e-16 # -0.0000000000000001
  #
  def self.tan: (double x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tanh(x) -> float
  # -->
  # Returns the [hyperbolic
  # tangent](https://en.wikipedia.org/wiki/Hyperbolic_functions) of `x` in
  # [radians](https://en.wikipedia.org/wiki/Trigonometric_functions#Radians_versus
  # _degrees).
  #
  # *   Domain: `[-INFINITY, INFINITY]`.
  # *   Range: `[-1, 1]`.
  #
  # Examples:
  #
  #     tanh(-INFINITY) # => -1.0
  #     tanh(0.0)       # => 0.0
  #     tanh(INFINITY)  # => 1.0
  #
  def self.tanh: (double x) -> Float
end
# <!-- rdoc-file=cont.c -->
# Fibers are primitives for implementing light weight cooperative concurrency in
# Ruby. Basically they are a means of creating code blocks that can be paused
# and resumed, much like threads. The main difference is that they are never
# preempted and that the scheduling must be done by the programmer and not the
# VM.
#
# As opposed to other stackless light weight concurrency models, each fiber
# comes with a stack.  This enables the fiber to be paused from deeply nested
# function calls within the fiber block.  See the ruby(1) manpage to configure
# the size of the fiber stack(s).
#
# When a fiber is created it will not run automatically. Rather it must be
# explicitly asked to run using the Fiber#resume method. The code running inside
# the fiber can give up control by calling Fiber.yield in which case it yields
# control back to caller (the caller of the Fiber#resume).
#
# Upon yielding or termination the Fiber returns the value of the last executed
# expression
#
# For instance:
#
#     fiber = Fiber.new do
#       Fiber.yield 1
#       2
#     end
#
#     puts fiber.resume
#     puts fiber.resume
#     puts fiber.resume
#
# *produces*
#
#     1
#     2
#     FiberError: dead fiber called
#
# The Fiber#resume method accepts an arbitrary number of parameters, if it is
# the first call to #resume then they will be passed as block arguments.
# Otherwise they will be the return value of the call to Fiber.yield
#
# Example:
#
#     fiber = Fiber.new do |first|
#       second = Fiber.yield first + 2
#     end
#
#     puts fiber.resume 10
#     puts fiber.resume 1_000_000
#     puts fiber.resume "The fiber will be dead before I can cause trouble"
#
# *produces*
#
#     12
#     1000000
#     FiberError: dead fiber called
#
# ## Non-blocking Fibers
#
# The concept of *non-blocking fiber* was introduced in Ruby 3.0. A non-blocking
# fiber, when reaching a operation that would normally block the fiber (like
# `sleep`, or wait for another process or I/O) will yield control to other
# fibers and allow the *scheduler* to handle blocking and waking up (resuming)
# this fiber when it can proceed.
#
# For a Fiber to behave as non-blocking, it need to be created in Fiber.new with
# `blocking: false` (which is the default), and Fiber.scheduler should be set
# with Fiber.set_scheduler. If Fiber.scheduler is not set in the current thread,
# blocking and non-blocking fibers' behavior is identical.
#
# Ruby doesn't provide a scheduler class: it is expected to be implemented by
# the user and correspond to Fiber::Scheduler.
#
# There is also Fiber.schedule method, which is expected to immediately perform
# the given block in a non-blocking manner. Its actual implementation is up to
# the scheduler.
#
class Fiber < Object
  # <!--
  #   rdoc-file=cont.c
  #   - Fiber[key] -> value
  # -->
  # Returns the value of the fiber storage variable identified by `key`.
  #
  # The `key` must be a symbol, and the value is set by Fiber#[]= or Fiber#store.
  #
  # See also Fiber::[]=.
  #
  def self.[]: (Symbol) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber[key] = value
  # -->
  # Assign `value` to the fiber storage variable identified by `key`. The variable
  # is created if it doesn't exist.
  #
  # `key` must be a Symbol, otherwise a TypeError is raised.
  #
  # See also Fiber::[].
  #
  def self.[]=: [A] (Symbol, A) -> A

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.blocking? -> false or 1
  # -->
  # Returns `false` if the current fiber is non-blocking. Fiber is non-blocking if
  # it was created via passing `blocking: false` to Fiber.new, or via
  # Fiber.schedule.
  #
  # If the current Fiber is blocking, the method returns 1. Future developments
  # may allow for situations where larger integers could be returned.
  #
  # Note that, even if the method returns `false`, Fiber behaves differently only
  # if Fiber.scheduler is set in the current thread.
  #
  # See the "Non-blocking fibers" section in class docs for details.
  #
  def self.blocking?: () -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.current -> fiber
  # -->
  # Returns the current fiber. If you are not running in the context of a fiber
  # this method will return the root fiber.
  #
  def self.current: () -> Fiber

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.current_scheduler -> obj or nil
  # -->
  # Returns the Fiber scheduler, that was last set for the current thread with
  # Fiber.set_scheduler if and only if the current fiber is non-blocking.
  #
  def self.current_scheduler: () -> untyped?

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.schedule { |*args| ... } -> fiber
  # -->
  # The method is *expected* to immediately run the provided block of code in a
  # separate non-blocking fiber.
  #
  #     puts "Go to sleep!"
  #
  #     Fiber.set_scheduler(MyScheduler.new)
  #
  #     Fiber.schedule do
  #       puts "Going to sleep"
  #       sleep(1)
  #       puts "I slept well"
  #     end
  #
  #     puts "Wakey-wakey, sleepyhead"
  #
  # Assuming MyScheduler is properly implemented, this program will produce:
  #
  #     Go to sleep!
  #     Going to sleep
  #     Wakey-wakey, sleepyhead
  #     ...1 sec pause here...
  #     I slept well
  #
  # ...e.g. on the first blocking operation inside the Fiber (`sleep(1)`), the
  # control is yielded to the outside code (main fiber), and *at the end of that
  # execution*, the scheduler takes care of properly resuming all the blocked
  # fibers.
  #
  # Note that the behavior described above is how the method is *expected* to
  # behave, actual behavior is up to the current scheduler's implementation of
  # Fiber::Scheduler#fiber method. Ruby doesn't enforce this method to behave in
  # any particular way.
  #
  # If the scheduler is not set, the method raises `RuntimeError (No scheduler is
  # available!)`.
  #
  def self.schedule: () { () -> void } -> Fiber

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.scheduler -> obj or nil
  # -->
  # Returns the Fiber scheduler, that was last set for the current thread with
  # Fiber.set_scheduler. Returns `nil` if no scheduler is set (which is the
  # default), and non-blocking fibers' behavior is the same as blocking. (see
  # "Non-blocking fibers" section in class docs for details about the scheduler
  # concept).
  #
  def self.scheduler: () -> untyped?

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.set_scheduler(scheduler) -> scheduler
  # -->
  # Sets the Fiber scheduler for the current thread. If the scheduler is set,
  # non-blocking fibers (created by Fiber.new with `blocking: false`, or by
  # Fiber.schedule) call that scheduler's hook methods on potentially blocking
  # operations, and the current thread will call scheduler's `close` method on
  # finalization (allowing the scheduler to properly manage all non-finished
  # fibers).
  #
  # `scheduler` can be an object of any class corresponding to Fiber::Scheduler.
  # Its implementation is up to the user.
  #
  # See also the "Non-blocking fibers" section in class docs.
  #
  def self.set_scheduler: (untyped) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.yield(args, ...) -> obj
  # -->
  # Yields control back to the context that resumed the fiber, passing along any
  # arguments that were passed to it. The fiber will resume processing at this
  # point when #resume is called next. Any arguments passed to the next #resume
  # will be the value that this Fiber.yield expression evaluates to.
  #
  def self.yield: (*untyped) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.new(blocking: false, storage: true) { |*args| ... } -> fiber
  # -->
  # Creates new Fiber. Initially, the fiber is not running and can be resumed with
  # #resume. Arguments to the first #resume call will be passed to the block:
  #
  #     f = Fiber.new do |initial|
  #        current = initial
  #        loop do
  #          puts "current: #{current.inspect}"
  #          current = Fiber.yield
  #        end
  #     end
  #     f.resume(100)     # prints: current: 100
  #     f.resume(1, 2, 3) # prints: current: [1, 2, 3]
  #     f.resume          # prints: current: nil
  #     # ... and so on ...
  #
  # If `blocking: false` is passed to `Fiber.new`, *and* current thread has a
  # Fiber.scheduler defined, the Fiber becomes non-blocking (see "Non-blocking
  # Fibers" section in class docs).
  #
  # If the `storage` is unspecified, the default is to inherit a copy of the
  # storage from the current fiber. This is the same as specifying `storage:
  # true`.
  #
  #     Fiber[:x] = 1
  #     Fiber.new do
  #       Fiber[:x] # => 1
  #       Fiber[:x] = 2
  #     end.resume
  #     Fiber[:x] # => 1
  #
  # If the given `storage` is `nil`, this function will lazy initialize the
  # internal storage, which starts as an empty hash.
  #
  #     Fiber[:x] = "Hello World"
  #     Fiber.new(storage: nil) do
  #       Fiber[:x] # nil
  #     end
  #
  # Otherwise, the given `storage` is used as the new fiber's storage, and it must
  # be an instance of Hash.
  #
  # Explicitly using `storage: true` is currently experimental and may change in
  # the future.
  #
  def initialize: (?blocking: boolish, ?storage: true | Hash[interned, untyped] | nil) { (?) -> void } -> void

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.alive? -> true or false
  # -->
  # Returns true if the fiber can still be resumed (or transferred to). After
  # finishing execution of the fiber block this method will always return `false`.
  #
  def alive?: () -> bool

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.backtrace -> array
  #   - fiber.backtrace(start) -> array
  #   - fiber.backtrace(start, count) -> array
  #   - fiber.backtrace(start..end) -> array
  # -->
  # Returns the current execution stack of the fiber. `start`, `count` and `end`
  # allow to select only parts of the backtrace.
  #
  #     def level3
  #       Fiber.yield
  #     end
  #
  #     def level2
  #       level3
  #     end
  #
  #     def level1
  #       level2
  #     end
  #
  #     f = Fiber.new { level1 }
  #
  #     # It is empty before the fiber started
  #     f.backtrace
  #     #=> []
  #
  #     f.resume
  #
  #     f.backtrace
  #     #=> ["test.rb:2:in `yield'", "test.rb:2:in `level3'", "test.rb:6:in `level2'", "test.rb:10:in `level1'", "test.rb:13:in `block in <main>'"]
  #     p f.backtrace(1) # start from the item 1
  #     #=> ["test.rb:2:in `level3'", "test.rb:6:in `level2'", "test.rb:10:in `level1'", "test.rb:13:in `block in <main>'"]
  #     p f.backtrace(2, 2) # start from item 2, take 2
  #     #=> ["test.rb:6:in `level2'", "test.rb:10:in `level1'"]
  #     p f.backtrace(1..3) # take items from 1 to 3
  #     #=> ["test.rb:2:in `level3'", "test.rb:6:in `level2'", "test.rb:10:in `level1'"]
  #
  #     f.resume
  #
  #     # It is nil after the fiber is finished
  #     f.backtrace
  #     #=> nil
  #
  def backtrace: (?Integer start, ?Integer count) -> Array[String]?
               | (Range[Integer]) -> Array[String]?

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.backtrace_locations -> array
  #   - fiber.backtrace_locations(start) -> array
  #   - fiber.backtrace_locations(start, count) -> array
  #   - fiber.backtrace_locations(start..end) -> array
  # -->
  # Like #backtrace, but returns each line of the execution stack as a
  # Thread::Backtrace::Location. Accepts the same arguments as #backtrace.
  #
  #     f = Fiber.new { Fiber.yield }
  #     f.resume
  #     loc = f.backtrace_locations.first
  #     loc.label  #=> "yield"
  #     loc.path   #=> "test.rb"
  #     loc.lineno #=> 1
  #
  def backtrace_locations: (?Integer start, ?Integer count) -> Array[Thread::Backtrace::Location]?
                         | (Range[Integer]) -> Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.blocking? -> true or false
  # -->
  # Returns `true` if `fiber` is blocking and `false` otherwise. Fiber is
  # non-blocking if it was created via passing `blocking: false` to Fiber.new, or
  # via Fiber.schedule.
  #
  # Note that, even if the method returns `false`, the fiber behaves differently
  # only if Fiber.scheduler is set in the current thread.
  #
  # See the "Non-blocking fibers" section in class docs for details.
  #
  def blocking?: () -> bool

  # <!--
  #   rdoc-file=cont.c
  #   - inspect()
  # -->
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.kill -> nil
  # -->
  # Terminates the fiber by raising an uncatchable exception. It only terminates
  # the given fiber and no other fiber, returning `nil` to another fiber if that
  # fiber was calling #resume or #transfer.
  #
  # `Fiber#kill` only interrupts another fiber when it is in Fiber.yield. If
  # called on the current fiber then it raises that exception at the `Fiber#kill`
  # call site.
  #
  # If the fiber has not been started, transition directly to the terminated
  # state.
  #
  # If the fiber is already terminated, does nothing.
  #
  # Raises FiberError if called on a fiber belonging to another thread.
  #
  def kill: () -> nil

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.raise                                 -> obj
  #   - fiber.raise(string)                         -> obj
  #   - fiber.raise(exception [, string [, array]]) -> obj
  # -->
  # Raises an exception in the fiber at the point at which the last `Fiber.yield`
  # was called. If the fiber has not been started or has already run to
  # completion, raises `FiberError`. If the fiber is yielding, it is resumed. If
  # it is transferring, it is transferred into. But if it is resuming, raises
  # `FiberError`.
  #
  # With no arguments, raises a `RuntimeError`. With a single `String` argument,
  # raises a `RuntimeError` with the string as a message.  Otherwise, the first
  # parameter should be the name of an `Exception` class (or an object that
  # returns an `Exception` object when sent an `exception` message). The optional
  # second parameter sets the message associated with the exception, and the third
  # parameter is an array of callback information. Exceptions are caught by the
  # `rescue` clause of `begin...end` blocks.
  #
  # Raises `FiberError` if called on a Fiber belonging to another `Thread`.
  #
  # See Kernel#raise for more information.
  #
  def raise: (?string msg) -> untyped
           | (_Exception, ?string msg, ?Array[string] | Array[Thread::Backtrace::Location] | nil backtrace) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.resume(args, ...) -> obj
  # -->
  # Resumes the fiber from the point at which the last Fiber.yield was called, or
  # starts running it if it is the first call to #resume. Arguments passed to
  # resume will be the value of the Fiber.yield expression or will be passed as
  # block parameters to the fiber's block if this is the first #resume.
  #
  # Alternatively, when resume is called it evaluates to the arguments passed to
  # the next Fiber.yield statement inside the fiber's block or to the block value
  # if it runs to completion without any Fiber.yield
  #
  def resume: (*untyped) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.storage -> hash (dup)
  # -->
  # Returns a copy of the storage hash for the fiber. The method can only be
  # called on the Fiber.current.
  #
  def storage: () -> Hash[interned, untyped]

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.storage = hash
  # -->
  # Sets the storage hash for the fiber. This feature is experimental and may
  # change in the future. The method can only be called on the Fiber.current.
  #
  # You should be careful about using this method as you may inadvertently clear
  # important fiber-storage state. You should mostly prefer to assign specific
  # keys in the storage using Fiber::[]=.
  #
  # You can also use `Fiber.new(storage: nil)` to create a fiber with an empty
  # storage.
  #
  # Example:
  #
  #     while request = request_queue.pop
  #       # Reset the per-request state:
  #       Fiber.current.storage = nil
  #       handle_request(request)
  #     end
  #
  def storage=: (Hash[interned, untyped]) -> Hash[interned, untyped]

  # <!--
  #   rdoc-file=cont.c
  #   - to_s()
  # -->
  #
  def to_s: () -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.transfer(args, ...) -> obj
  # -->
  # Transfer control to another fiber, resuming it from where it last stopped or
  # starting it if it was not resumed before. The calling fiber will be suspended
  # much like in a call to Fiber.yield.
  #
  # The fiber which receives the transfer call treats it much like a resume call.
  # Arguments passed to transfer are treated like those passed to resume.
  #
  # The two style of control passing to and from fiber (one is #resume and
  # Fiber::yield, another is #transfer to and from fiber) can't be freely mixed.
  #
  # *   If the Fiber's lifecycle had started with transfer, it will never be able
  #     to yield or be resumed control passing, only finish or transfer back. (It
  #     still can resume other fibers that are allowed to be resumed.)
  # *   If the Fiber's lifecycle had started with resume, it can yield or transfer
  #     to another Fiber, but can receive control back only the way compatible
  #     with the way it was given away: if it had transferred, it only can be
  #     transferred back, and if it had yielded, it only can be resumed back.
  #     After that, it again can transfer or yield.
  #
  # If those rules are broken FiberError is raised.
  #
  # For an individual Fiber design, yield/resume is easier to use (the Fiber just
  # gives away control, it doesn't need to think about who the control is given
  # to), while transfer is more flexible for complex cases, allowing to build
  # arbitrary graphs of Fibers dependent on each other.
  #
  # Example:
  #
  #     manager = nil # For local var to be visible inside worker block
  #
  #     # This fiber would be started with transfer
  #     # It can't yield, and can't be resumed
  #     worker = Fiber.new { |work|
  #       puts "Worker: starts"
  #       puts "Worker: Performed #{work.inspect}, transferring back"
  #       # Fiber.yield     # this would raise FiberError: attempt to yield on a not resumed fiber
  #       # manager.resume  # this would raise FiberError: attempt to resume a resumed fiber (double resume)
  #       manager.transfer(work.capitalize)
  #     }
  #
  #     # This fiber would be started with resume
  #     # It can yield or transfer, and can be transferred
  #     # back or resumed
  #     manager = Fiber.new {
  #       puts "Manager: starts"
  #       puts "Manager: transferring 'something' to worker"
  #       result = worker.transfer('something')
  #       puts "Manager: worker returned #{result.inspect}"
  #       # worker.resume    # this would raise FiberError: attempt to resume a transferring fiber
  #       Fiber.yield        # this is OK, the fiber transferred from and to, now it can yield
  #       puts "Manager: finished"
  #     }
  #
  #     puts "Starting the manager"
  #     manager.resume
  #     puts "Resuming the manager"
  #     # manager.transfer  # this would raise FiberError: attempt to transfer to a yielding fiber
  #     manager.resume
  #
  # *produces*
  #
  #     Starting the manager
  #     Manager: starts
  #     Manager: transferring 'something' to worker
  #     Worker: starts
  #     Worker: Performed "something", transferring back
  #     Manager: worker returned "Something"
  #     Resuming the manager
  #     Manager: finished
  #
  def transfer: (*untyped) -> untyped
end
# <!-- rdoc-file=gc.c -->
# The ObjectSpace module contains a number of routines that interact with the
# garbage collection facility and allow you to traverse all living objects with
# an iterator.
#
# ObjectSpace also provides support for object finalizers, procs that will be
# called after a specific object was destroyed by garbage collection.  See the
# documentation for `ObjectSpace.define_finalizer` for important information on
# how to use this method correctly.
#
#     a = "A"
#     b = "B"
#
#     ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
#     ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })
#
#     a = nil
#     b = nil
#
# *produces:*
#
#     Finalizer two on 537763470
#     Finalizer one on 537763480
#
%a{annotate:rdoc:source:from=gc.c}
module ObjectSpace
  # <!--
  #   rdoc-file=gc.c
  #   - _id2ref(p1)
  # -->
  #
  def self._id2ref: (Integer id) -> untyped

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.count_objects([result_hash]) -> hash
  # -->
  # Counts all objects grouped by type.
  #
  # It returns a hash, such as:
  #     {
  #       :TOTAL=>10000,
  #       :FREE=>3011,
  #       :T_OBJECT=>6,
  #       :T_CLASS=>404,
  #       # ...
  #     }
  #
  # The contents of the returned hash are implementation specific. It may be
  # changed in future.
  #
  # The keys starting with `:T_` means live objects. For example, `:T_ARRAY` is
  # the number of arrays. `:FREE` means object slots which is not used now.
  # `:TOTAL` means sum of above.
  #
  # If the optional argument `result_hash` is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  #     h = {}
  #     ObjectSpace.count_objects(h)
  #     puts h
  #     # => { :TOTAL=>10000, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249 }
  #
  # This method is only expected to work on C Ruby.
  #
  def self.count_objects: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.define_finalizer(obj, aProc=proc())
  # -->
  # Adds *aProc* as a finalizer, to be called after *obj* was destroyed. The
  # object ID of the *obj* will be passed as an argument to *aProc*. If *aProc* is
  # a lambda or method, make sure it can be called with a single argument.
  #
  # The return value is an array `[0, aProc]`.
  #
  # The two recommended patterns are to either create the finaliser proc in a
  # non-instance method where it can safely capture the needed state, or to use a
  # custom callable object that stores the needed state explicitly as instance
  # variables.
  #
  #     class Foo
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, self.class.create_finalizer(data_needed_for_finalization))
  #       end
  #
  #       def self.create_finalizer(data_needed_for_finalization)
  #         proc {
  #           puts "finalizing #{data_needed_for_finalization}"
  #         }
  #       end
  #     end
  #
  #     class Bar
  #      class Remover
  #         def initialize(data_needed_for_finalization)
  #           @data_needed_for_finalization = data_needed_for_finalization
  #         end
  #
  #         def call(id)
  #           puts "finalizing #{@data_needed_for_finalization}"
  #         end
  #       end
  #
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, Remover.new(data_needed_for_finalization))
  #       end
  #     end
  #
  # Note that if your finalizer references the object to be finalized it will
  # never be run on GC, although it will still be run at exit. You will get a
  # warning if you capture the object to be finalized as the receiver of the
  # finalizer.
  #
  #     class CapturesSelf
  #       def initialize(name)
  #         ObjectSpace.define_finalizer(self, proc {
  #           # this finalizer will only be run on exit
  #           puts "finalizing #{name}"
  #         })
  #       end
  #     end
  #
  # Also note that finalization can be unpredictable and is never guaranteed to be
  # run except on exit.
  #
  def self.define_finalizer: (untyped obj, ^(Integer id) -> void aProc) -> [ Integer, Proc ]
                           | (untyped obj) { (Integer id) -> void } -> [ Integer, Proc ]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.each_object([module]) {|obj| ... } -> integer
  #   - ObjectSpace.each_object([module])              -> an_enumerator
  # -->
  # Calls the block once for each living, nonimmediate object in this Ruby
  # process. If *module* is specified, calls the block for only those classes or
  # modules that match (or are a subclass of) *module*. Returns the number of
  # objects found. Immediate objects (`Fixnum`s, `Symbol`s `true`, `false`, and
  # `nil`) are never returned. In the example below, #each_object returns both the
  # numbers we defined and several constants defined in the Math module.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     a = 102.7
  #     b = 95       # Won't be returned
  #     c = 12345678987654321
  #     count = ObjectSpace.each_object(Numeric) {|x| p x }
  #     puts "Total count: #{count}"
  #
  # *produces:*
  #
  #     12345678987654321
  #     102.7
  #     2.71828182845905
  #     3.14159265358979
  #     2.22044604925031e-16
  #     1.7976931348623157e+308
  #     2.2250738585072e-308
  #     Total count: 7
  #
  def self.each_object: (?Module `module`) -> Enumerator[untyped, Integer]
                      | (?Module `module`) { (untyped obj) -> void } -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  # Alias of GC.start
  #
  def self.garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.undefine_finalizer(obj)
  # -->
  # Removes all finalizers for *obj*.
  #
  def self.undefine_finalizer: [X] (X obj) -> X

  private

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  # Alias of GC.start
  #
  def garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void
end
# <!-- rdoc-file=lib/set.rb -->
# This library provides the Set class, which implements a collection
# of unordered values with no duplicates. It is a hybrid of Array's
# intuitive inter-operation facilities and Hash's fast lookup.
# The method `to_set` is added to Enumerable for convenience.
# Set is easy to use with Enumerable objects (implementing `each`).
# Most of the initializer methods and binary operators accept generic
# Enumerable objects besides sets and arrays. An Enumerable object
# can be converted to Set using the `to_set` method.
# Set uses Hash as storage, so you must note the following points:
# *   Equality of elements is determined according to Object#eql? and
#      Object#hash. Use Set#compare_by_identity to make a set compare
#      its elements by their identity.
# *   Set assumes that the identity of each element does not change
#      while it is stored. Modifying an element of a set will render the
#      set to an unreliable state.
# *   When a string is to be stored, a frozen copy of the string is
#      stored instead unless the original string is already frozen.
# ## Comparison
# The comparison operators `<`, `>`, `<=`, and `>=` are implemented as
# shorthand for the {proper_,}{subset?,superset?} methods. The `<=>`
# operator reflects this order, or return `nil` for sets that both
# have distinct elements (`{x, y}` vs. `{x, z}` for example).
# ## Example
#     require 'set'
# s1 = Set[1, 2]                        #=> #<Set: {1, 2}>
# s2 = [1, 2].to_set                    #=> #<Set: {1, 2}>
# s1 == s2                              #=> true
# s1.add("foo")                         #=> #<Set: {1, 2, "foo"}>
# s1.merge([2, 6])                      #=> #<Set: {1, 2, "foo", 6}>
# s1.subset?(s2)                        #=> false
# s2.subset?(s1)                        #=> true
#
# ## Contact
# *   Akinori MUSHA <mailto:knu@iDaemons.org> (current maintainer)
# ## What's Here
# First, what's elsewhere. Class Set:
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here),
#      which provides dozens of additional methods.
# In particular, class Set does not have many methods of its own
# for fetching or for iterating.
# Instead, it relies on those in Enumerable.
# Here, class Set provides methods that are useful for:
# *   [Creating a Set](#class-Set-label-Methods+for+Creating+a+Set)
# *   [Set Operations](#class-Set-label-Methods+for+Set+Operations)
# *   [Comparing](#class-Set-label-Methods+for+Comparing)
# *   [Querying](#class-Set-label-Methods+for+Querying)
# *   [Assigning](#class-Set-label-Methods+for+Assigning)
# *   [Deleting](#class-Set-label-Methods+for+Deleting)
# *   [Converting](#class-Set-label-Methods+for+Converting)
# *   [Iterating](#class-Set-label-Methods+for+Iterating)
# *   [And more....](#class-Set-label-Other+Methods)
# ### Methods for Creating a Set
# *   ::[]:
#      Returns a new set containing the given objects.
# *   ::new:
#      Returns a new set containing either the given objects
#      (if no block given) or the return values from the called block
#      (if a block given).
# ### Methods for Set Operations
# *   [|](#method-i-7C) (aliased as #union and #+):
#      Returns a new set containing all elements from `self`
#      and all elements from a given enumerable (no duplicates).
# *   [&](#method-i-26) (aliased as #intersection):
#      Returns a new set containing all elements common to `self`
#      and a given enumerable.
# *   [-](#method-i-2D) (aliased as #difference):
#      Returns a copy of `self` with all elements
#      in a given enumerable removed.
# *   [\^](#method-i-5E):
#      Returns a new set containing all elements from `self`
#      and a given enumerable except those common to both.
# ### Methods for Comparing
# *   [<=>](#method-i-3C-3D-3E):
#      Returns -1, 0, or 1 as `self` is less than, equal to,
#      or greater than a given object.
# *   [==](#method-i-3D-3D):
#      Returns whether `self` and a given enumerable are equal,
#      as determined by Object#eql?.
# *   #compare_by_identity?:
#      Returns whether the set considers only identity
#      when comparing elements.
# ### Methods for Querying
# *   #length (aliased as #size):
#      Returns the count of elements.
# *   #empty?:
#      Returns whether the set has no elements.
# *   #include? (aliased as #member? and #===):
#      Returns whether a given object is an element in the set.
# *   #subset? (aliased as [<=](#method-i-3C-3D)):
#      Returns whether a given object is a subset of the set.
# *   #proper_subset? (aliased as [<](#method-i-3C)):
#      Returns whether a given enumerable is a proper subset of the set.
# *   #superset? (aliased as [>=](#method-i-3E-3D)]):
#      Returns whether a given enumerable is a superset of the set.
# *   #proper_superset? (aliased as [>](#method-i-3E)):
#      Returns whether a given enumerable is a proper superset of the set.
# *   #disjoint?:
#      Returns `true` if the set and a given enumerable
#      have no common elements, `false` otherwise.
# *   #intersect?:
#      Returns `true` if the set and a given enumerable:
#      have any common elements, `false` otherwise.
# *   #compare_by_identity?:
#      Returns whether the set considers only identity
#      when comparing elements.
# ### Methods for Assigning
# *   #add (aliased as #<<):
#      Adds a given object to the set; returns `self`.
# *   #add?:
#      If the given object is not an element in the set,
#      adds it and returns `self`; otherwise, returns `nil`.
# *   #merge:
#      Merges the elements of each given enumerable object to the set; returns
#     `self`.
# *   #replace:
#      Replaces the contents of the set with the contents
#      of a given enumerable.
# ### Methods for Deleting
# *   #clear:
#      Removes all elements in the set; returns `self`.
# *   #delete:
#      Removes a given object from the set; returns `self`.
# *   #delete?:
#      If the given object is an element in the set,
#      removes it and returns `self`; otherwise, returns `nil`.
# *   #subtract:
#      Removes each given object from the set; returns `self`.
# *   #delete_if - Removes elements specified by a given block.
# *   #select! (aliased as #filter!):
#      Removes elements not specified by a given block.
# *   #keep_if:
#      Removes elements not specified by a given block.
# *   #reject!
#      Removes elements specified by a given block.
# ### Methods for Converting
# *   #classify:
#      Returns a hash that classifies the elements,
#      as determined by the given block.
# *   #collect! (aliased as #map!):
#      Replaces each element with a block return-value.
# *   #divide:
#      Returns a hash that classifies the elements,
#      as determined by the given block;
#      differs from #classify in that the block may accept
#      either one or two arguments.
# *   #flatten:
#      Returns a new set that is a recursive flattening of `self`.
#      #flatten!:
#      Replaces each nested set in `self` with the elements from that set.
# *   #inspect (aliased as #to_s):
#      Returns a string displaying the elements.
# *   #join:
#      Returns a string containing all elements, converted to strings
#      as needed, and joined by the given record separator.
# *   #to_a:
#      Returns an array containing all set elements.
# *   #to_set:
#      Returns `self` if given no arguments and no block;
#      with a block given, returns a new set consisting of block
#      return values.
# ### Methods for Iterating
# *   #each:
#      Calls the block with each successive element; returns `self`.
# ### Other Methods
# *   #reset:
#      Resets the internal state; useful if an object
#      has been modified while an element in the set.
#
class Set[unchecked out A]
  include Enumerable[A]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - new(enum = nil) { |o| ... }
  # -->
  # Creates a new set containing the elements of the given enumerable
  # object.
  # If a block is given, the elements of enum are preprocessed by the
  # given block.
  #     Set.new([1, 2])                       #=> #<Set: {1, 2}>
  #     Set.new([1, 2, 1])                    #=> #<Set: {1, 2}>
  #     Set.new([1, 'c', :s])                 #=> #<Set: {1, "c", :s}>
  #     Set.new(1..5)                         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set.new([1, 2, 3]) { |x| x * x }      #=> #<Set: {1, 4, 9}>
  #
  def initialize: (_Each[A]) -> untyped
                | [X] (_Each[X]) { (X) -> A } -> untyped
                | (?nil) -> untyped

  # <!--
  #   rdoc-file=lib/set.rb
  #   - [](*ary)
  # -->
  # Creates a new set containing the given objects.
  #     Set[1, 2]                   # => #<Set: {1, 2}>
  #     Set[1, 2, 1]                # => #<Set: {1, 2}>
  #     Set[1, 'c', :s]             # => #<Set: {1, "c", :s}>
  #
  def self.[]: [X] (*X) -> Set[X]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - &(enum)
  # -->
  # Returns a new set containing elements common to the set and the
  # given enumerable object.
  #     Set[1, 3, 5] & Set[3, 2, 1]             #=> #<Set: {3, 1}>
  #     Set['a', 'b', 'z'] & ['a', 'b', 'c']    #=> #<Set: {"a", "b"}>
  #
  def &: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - intersection(enum)
  # -->
  #
  alias intersection &

  # <!--
  #   rdoc-file=lib/set.rb
  #   - |(enum)
  # -->
  # Returns a new set built by merging the set and the elements of the
  # given enumerable object.
  #     Set[1, 2, 3] | Set[2, 4, 5]         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set[1, 5, 'z'] | (1..6)             #=> #<Set: {1, 5, "z", 2, 3, 4, 6}>
  #
  def |: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - union(enum)
  # -->
  #
  alias union |

  # <!--
  #   rdoc-file=lib/set.rb
  #   - +(enum)
  # -->
  #
  alias + |

  # <!--
  #   rdoc-file=lib/set.rb
  #   - -(enum)
  # -->
  # Returns a new set built by duplicating the set, removing every
  # element that appears in the given enumerable object.
  #     Set[1, 3, 5] - Set[1, 5]                #=> #<Set: {3}>
  #     Set['a', 'b', 'z'] - ['a', 'c']         #=> #<Set: {"b", "z"}>
  #
  def -: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - difference(enum)
  # -->
  #
  alias difference -

  # <!--
  #   rdoc-file=lib/set.rb
  #   - add(o)
  # -->
  # Adds the given object to the set and returns self. Use `merge` to
  # add many elements at once.
  #     Set[1, 2].add(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add(2)                    #=> #<Set: {1, 2}>
  #
  def add: (A) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - <<(o)
  # -->
  #
  alias << add

  # <!--
  #   rdoc-file=lib/set.rb
  #   - add?(o)
  # -->
  # Adds the given object to the set and returns self. If the
  # object is already in the set, returns nil.
  #     Set[1, 2].add?(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add?([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add?(2)                    #=> nil
  #
  def add?: (A) -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - include?(o)
  # -->
  # Returns true if the set contains the given object.
  # Note that `include?` and `member?` do not test member
  # equality using `==` as do other Enumerables.
  # See also Enumerable#include?
  #
  def include?: (A) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - member?(o)
  # -->
  #
  alias member? include?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - ^(enum)
  # -->
  # Returns a new set containing elements exclusive between the set
  # and the given enumerable object. `(set ^ enum)` is equivalent to
  # `((set | enum) - (set & enum))`.
  #     Set[1, 2] ^ Set[2, 3]                   #=> #<Set: {3, 1}>
  #     Set[1, 'b', 'c'] ^ ['b', 'd']           #=> #<Set: {"d", 1, "c"}>
  #
  def ^: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - classify() { |o| ... }
  # -->
  # Classifies the set by the return value of the given block and
  # returns a hash of {value => set of elements} pairs. The block is
  # called once for each element of the set, passing the element as
  # parameter.
  #     require 'set'
  #     files = Set.new(Dir.glob("*.rb"))
  #     hash = files.classify { |f| File.mtime(f).year }
  #     hash       #=> {2000=>#<Set: {"a.rb", "b.rb"}>,
  #                #    2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,
  #                #    2002=>#<Set: {"f.rb"}>}
  #
  # Returns an enumerator if no block is given.
  #
  def classify: [X] () { (A) -> X } -> Hash[X, self]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - clear()
  # -->
  # Removes all elements and returns self.
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.clear                         #=> #<Set: {}>
  #     set                               #=> #<Set: {}>
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - collect!() { |o| ... }
  # -->
  # Replaces the elements with ones returned by `collect()`.
  # Returns an enumerator if no block is given.
  #
  def collect!: () { (A) -> A } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - map!()
  # -->
  #
  alias map! collect!

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete(o)
  # -->
  # Deletes the given object from the set and returns self. Use
  # `subtract` to delete many items at once.
  #
  def delete: (A) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete?(o)
  # -->
  # Deletes the given object from the set and returns self. If the
  # object is not in the set, returns nil.
  #
  def delete?: (A) -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete_if(&block)
  # -->
  # Deletes every element of the set for which block evaluates to
  # true, and returns self. Returns an enumerator if no block is
  # given.
  #
  def delete_if: () { (A) -> untyped } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - reject!(&block)
  # -->
  # Equivalent to Set#delete_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  #
  def reject!: () { (A) -> untyped } -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - compare_by_identity()
  # -->
  # Makes the set compare its elements by their identity and returns
  # self. This method may not be supported by all subclasses of Set.
  #
  def compare_by_identity: () -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - disjoint?(set)
  # -->
  # Returns true if the set and the given enumerable have
  # no element in common. This method is the opposite of `intersect?`.
  #     Set[1, 2, 3].disjoint? Set[3, 4]   #=> false
  #     Set[1, 2, 3].disjoint? Set[4, 5]   #=> true
  #     Set[1, 2, 3].disjoint? [3, 4]      #=> false
  #     Set[1, 2, 3].disjoint? 4..5        #=> true
  #
  def disjoint?: (Set[A] | Enumerable[A]) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - divide(&func)
  # -->
  # Divides the set into a set of subsets according to the commonality
  # defined by the given block.
  # If the arity of the block is 2, elements o1 and o2 are in common
  # if block.call(o1, o2) is true. Otherwise, elements o1 and o2 are
  # in common if block.call(o1) == block.call(o2).
  #     require 'set'
  #     numbers = Set[1, 3, 4, 6, 9, 10, 11]
  #     set = numbers.divide { |i,j| (i - j).abs == 1 }
  #     set        #=> #<Set: {#<Set: {1}>,
  #                #           #<Set: {11, 9, 10}>,
  #                #           #<Set: {3, 4}>,
  #                #           #<Set: {6}>}>
  #
  # Returns an enumerator if no block is given.
  #
  def divide: () { (A, A) -> Hash::_Key } -> Set[self]
            | () { (A) -> Hash::_Key } -> Set[self]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - each(&block)
  # -->
  # Calls the given block once for each element in the set, passing
  # the element as parameter. Returns an enumerator if no block is
  # given.
  #
  def each: () { (A) -> void } -> self
          | () -> Enumerator[A, self]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - empty?()
  # -->
  # Returns true if the set contains no elements.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - flatten()
  # -->
  # Returns a new set that is a copy of the set, flattening each
  # containing set recursively.
  #
  def flatten: () -> Set[untyped]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - intersect?(set)
  # -->
  # Returns true if the set and the given enumerable have at least one
  # element in common.
  #     Set[1, 2, 3].intersect? Set[4, 5]   #=> false
  #     Set[1, 2, 3].intersect? Set[3, 4]   #=> true
  #     Set[1, 2, 3].intersect? 4..5        #=> false
  #     Set[1, 2, 3].intersect? [3, 4]      #=> true
  #
  def intersect?: (Set[A] | Enumerable[A]) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - keep_if(&block)
  # -->
  # Deletes every element of the set for which block evaluates to
  # false, and returns self. Returns an enumerator if no block is
  # given.
  #
  def keep_if: () { (A) -> untyped } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - size()
  # -->
  # Returns the number of elements.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=lib/set.rb
  #   - length()
  # -->
  #
  alias length size

  # <!--
  #   rdoc-file=lib/set.rb
  #   - merge(*enums, **nil)
  # -->
  # Merges the elements of the given enumerable objects to the set and
  # returns self.
  #
  def merge: (*_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - subset?(set)
  # -->
  # Returns true if the set is a subset of the given set.
  #
  def subset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - proper_subset?(set)
  # -->
  # Returns true if the set is a proper subset of the given set.
  #
  def proper_subset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - superset?(set)
  # -->
  # Returns true if the set is a superset of the given set.
  #
  def superset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - proper_superset?(set)
  # -->
  # Returns true if the set is a proper superset of the given set.
  #
  def proper_superset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - replace(enum)
  # -->
  # Replaces the contents of the set with the contents of the given
  # enumerable object and returns self.
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.replace([1, 2])               #=> #<Set: {1, 2}>
  #     set                               #=> #<Set: {1, 2}>
  #
  def replace: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - reset()
  # -->
  # Resets the internal state after modification to existing elements
  # and returns self.
  # Elements will be reindexed and deduplicated.
  #
  def reset: () -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - select!(&block)
  # -->
  # Equivalent to Set#keep_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  #
  def select!: () { (A) -> untyped } -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - subtract(enum)
  # -->
  # Deletes every element that appears in the given enumerable object
  # and returns self.
  #
  def subtract: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - to_a()
  # -->
  # Returns an array containing all elements in the set.
  #     Set[1, 2].to_a                    #=> [1, 2]
  #     Set[1, 'c', :s].to_a              #=> [1, "c", :s]
  #
  def to_a: () -> Array[A]
end

%a{annotate:rdoc:skip}
module Enumerable[unchecked out Elem]
  # <!--
  #   rdoc-file=lib/set.rb
  #   - to_set(klass = Set, *args, &block)
  # -->
  # Makes a set from the enumerable object with given arguments.
  # Needs to `require "set"` to use this method.
  #
  def to_set: () -> Set[Elem]
            | [T] () { (Elem) -> T } -> Set[T]
end
# <!-- rdoc-file=object.c -->
# Classes in Ruby are first-class objects---each is an instance of class Class.
#
# Typically, you create a new class by using:
#
#     class Name
#      # some code describing the class behavior
#     end
#
# When a new class is created, an object of type Class is initialized and
# assigned to a global constant (Name in this case).
#
# When `Name.new` is called to create a new object, the #new method in Class is
# run by default. This can be demonstrated by overriding #new in Class:
#
#     class Class
#       alias old_new new
#       def new(*args)
#         print "Creating a new ", self.name, "\n"
#         old_new(*args)
#       end
#     end
#
#     class Name
#     end
#
#     n = Name.new
#
# *produces:*
#
#     Creating a new Name
#
# Classes, modules, and objects are interrelated. In the diagram that follows,
# the vertical arrows represent inheritance, and the parentheses metaclasses.
# All metaclasses are instances of the class `Class'.
#                              +---------+             +-...
#                              |         |             |
#              BasicObject-----|-->(BasicObject)-------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#               Object---------|----->(Object)---------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#                  +-------+   |         +--------+    |
#                  |       |   |         |        |    |
#                  |    Module-|---------|--->(Module)-|-...
#                  |       ^   |         |        ^    |
#                  |       |   |         |        |    |
#                  |     Class-|---------|---->(Class)-|-...
#                  |       ^   |         |        ^    |
#                  |       +---+         |        +----+
#                  |                     |
#     obj--->OtherClass---------->(OtherClass)-----------...
#
%a{annotate:rdoc:source:from=object.c}
class Class < Module
  # <!--
  #   rdoc-file=object.c
  #   - Class.new(super_class=Object)               -> a_class
  #   - Class.new(super_class=Object) { |mod| ... } -> a_class
  # -->
  # Creates a new anonymous (unnamed) class with the given superclass (or Object
  # if no parameter is given). You can give a class a name by assigning the class
  # object to a constant.
  #
  # If a block is given, it is passed the class object, and the block is evaluated
  # in the context of this class like #class_eval.
  #
  #     fred = Class.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #
  #     a = fred.new     #=> #<#<Class:0x100381890>:0x100376b98>
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the class to a constant (name starting uppercase) if you want to treat
  # it like a regular class.
  #
  def initialize: (?Class superclass) ?{ (Class newclass) -> void } -> void

  # <!--
  #   rdoc-file=object.c
  #   - class.allocate()   ->   obj
  # -->
  # Allocates space for a new object of *class*'s class and does not call
  # initialize on the new instance. The returned object must be an instance of
  # *class*.
  #
  #     klass = Class.new do
  #       def initialize(*args)
  #         @initialized = true
  #       end
  #
  #       def initialized?
  #         @initialized || false
  #       end
  #     end
  #
  #     klass.allocate.initialized? #=> false
  #
  def allocate: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - attached_object -> object
  # -->
  # Returns the object for which the receiver is the singleton class.
  #
  # Raises an TypeError if the class is not a singleton class.
  #
  #     class Foo; end
  #
  #     Foo.singleton_class.attached_object        #=> Foo
  #     Foo.attached_object                        #=> TypeError: `Foo' is not a singleton class
  #     Foo.new.singleton_class.attached_object    #=> #<Foo:0x000000010491a370>
  #     TrueClass.attached_object                  #=> TypeError: `TrueClass' is not a singleton class
  #     NilClass.attached_object                   #=> TypeError: `NilClass' is not a singleton class
  #
  def attached_object: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - inherited(subclass)
  # -->
  # Callback invoked whenever a subclass of the current class is created.
  #
  # Example:
  #
  #     class Foo
  #       def self.inherited(subclass)
  #         puts "New subclass: #{subclass}"
  #       end
  #     end
  #
  #     class Bar < Foo
  #     end
  #
  #     class Baz < Bar
  #     end
  #
  # *produces:*
  #
  #     New subclass: Bar
  #     New subclass: Baz
  #
  def inherited: (Class arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - class.new(args, ...)    ->  obj
  # -->
  # Calls #allocate to create a new object of *class*'s class, then invokes that
  # object's #initialize method, passing it *args*.  This is the method that ends
  # up getting called whenever an object is constructed using `.new`.
  #
  def new: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - subclasses -> array
  # -->
  # Returns an array of classes where the receiver is the direct superclass of the
  # class, excluding singleton classes. The order of the returned array is not
  # defined.
  #
  #     class A; end
  #     class B < A; end
  #     class C < B; end
  #     class D < A; end
  #
  #     A.subclasses        #=> [D, B]
  #     B.subclasses        #=> [C]
  #     C.subclasses        #=> []
  #
  # Anonymous subclasses (not associated with a constant) are returned, too:
  #
  #     c = Class.new(A)
  #     A.subclasses        # => [#<Class:0x00007f003c77bd78>, D, B]
  #
  # Note that the parent does not hold references to subclasses and doesn't
  # prevent them from being garbage collected. This means that the subclass might
  # disappear when all references to it are dropped:
  #
  #     # drop the reference to subclass, it can be garbage-collected now
  #     c = nil
  #
  #     A.subclasses
  #     # It can be
  #     #  => [#<Class:0x00007f003c77bd78>, D, B]
  #     # ...or just
  #     #  => [D, B]
  #     # ...depending on whether garbage collector was run
  #
  def subclasses: () -> Array[Class]

  # <!--
  #   rdoc-file=object.c
  #   - class.superclass -> a_super_class or nil
  # -->
  # Returns the superclass of *class*, or `nil`.
  #
  #     File.superclass          #=> IO
  #     IO.superclass            #=> Object
  #     Object.superclass        #=> BasicObject
  #     class Foo; end
  #     class Bar < Foo; end
  #     Bar.superclass           #=> Foo
  #
  # Returns nil when the given class does not have a parent class:
  #
  #     BasicObject.superclass   #=> nil
  #
  def superclass: () -> Class?
end
# <!-- rdoc-file=io.c -->
# An instance of class IO (commonly called a *stream*) represents an
# input/output stream in the underlying operating system. Class IO is the basis
# for input and output in Ruby.
#
# Class File is the only class in the Ruby core that is a subclass of IO. Some
# classes in the Ruby standard library are also subclasses of IO; these include
# TCPSocket and UDPSocket.
#
# The global constant ARGF (also accessible as `$<`) provides an IO-like stream
# that allows access to all file paths found in ARGV (or found in STDIN if ARGV
# is empty). ARGF is not itself a subclass of IO.
#
# Class StringIO provides an IO-like stream that handles a String. StringIO is
# not itself a subclass of IO.
#
# Important objects based on IO include:
#
# *   $stdin.
# *   $stdout.
# *   $stderr.
# *   Instances of class File.
#
# An instance of IO may be created using:
#
# *   IO.new: returns a new IO object for the given integer file descriptor.
# *   IO.open: passes a new IO object to the given block.
# *   IO.popen: returns a new IO object that is connected to the $stdin and
#     $stdout of a newly-launched subprocess.
# *   Kernel#open: Returns a new IO object connected to a given source: stream,
#     file, or subprocess.
#
# Like a File stream, an IO stream has:
#
# *   A read/write mode, which may be read-only, write-only, or read/write; see
#     [Read/Write Mode](rdoc-ref:File@Read-2FWrite+Mode).
# *   A data mode, which may be text-only or binary; see [Data
#     Mode](rdoc-ref:File@Data+Mode).
# *   Internal and external encodings; see [Encodings](rdoc-ref:File@Encodings).
#
# And like other IO streams, it has:
#
# *   A position, which determines where in the stream the next read or write is
#     to occur; see [Position](rdoc-ref:IO@Position).
# *   A line number, which is a special, line-oriented, "position" (different
#     from the position mentioned above); see [Line
#     Number](rdoc-ref:IO@Line+Number).
#
# ## Extension `io/console`
#
# Extension `io/console` provides numerous methods for interacting with the
# console; requiring it adds numerous methods to class IO.
#
# ## Example Files
#
# Many examples here use these variables:
#
#     # English text with newlines.
#     text = <<~EOT
#       First line
#       Second line
#
#       Fourth line
#       Fifth line
#     EOT
#
#     # Russian text.
#     russian = "\u{442 435 441 442}" # => ""
#
#     # Binary data.
#     data = "\u9990\u9991\u9992\u9993\u9994"
#
#     # Text file.
#     File.write('t.txt', text)
#
#     # File with Russian text.
#     File.write('t.rus', russian)
#
#     # File with binary data.
#     f = File.new('t.dat', 'wb:UTF-16')
#     f.write(data)
#     f.close
#
# ## Open Options
#
# A number of IO methods accept optional keyword arguments that determine how a
# new stream is to be opened:
#
# *   `:mode`: Stream mode.
# *   `:flags`: Integer file open flags; If `mode` is also given, the two are
#     bitwise-ORed.
# *   `:external_encoding`: External encoding for the stream.
# *   `:internal_encoding`: Internal encoding for the stream. `'-'` is a synonym
#     for the default internal encoding. If the value is `nil` no conversion
#     occurs.
# *   `:encoding`: Specifies external and internal encodings as
#     `'extern:intern'`.
# *   `:textmode`: If a truthy value, specifies the mode as text-only, binary
#     otherwise.
# *   `:binmode`: If a truthy value, specifies the mode as binary, text-only
#     otherwise.
# *   `:autoclose`: If a truthy value, specifies that the `fd` will close when
#     the stream closes; otherwise it remains open.
# *   `:path:` If a string value is provided, it is used in #inspect and is
#     available as #path method.
#
# Also available are the options offered in String#encode, which may control
# conversion between external and internal encoding.
#
# ## Basic IO
#
# You can perform basic stream IO with these methods, which typically operate on
# multi-byte strings:
#
# *   IO#read: Reads and returns some or all of the remaining bytes from the
#     stream.
# *   IO#write: Writes zero or more strings to the stream; each given object
#     that is not already a string is converted via `to_s`.
#
# ### Position
#
# An IO stream has a nonnegative integer *position*, which is the byte offset at
# which the next read or write is to occur. A new stream has position zero (and
# line number zero); method `rewind` resets the position (and line number) to
# zero.
#
# These methods discard [buffers](rdoc-ref:IO@Buffering) and the
# Encoding::Converter instances used for that IO.
#
# The relevant methods:
#
# *   IO#tell (aliased as `#pos`): Returns the current position (in bytes) in
#     the stream.
# *   IO#pos=: Sets the position of the stream to a given integer `new_position`
#     (in bytes).
# *   IO#seek: Sets the position of the stream to a given integer `offset` (in
#     bytes), relative to a given position `whence` (indicating the beginning,
#     end, or current position).
# *   IO#rewind: Positions the stream at the beginning (also resetting the line
#     number).
#
# ### Open and Closed Streams
#
# A new IO stream may be open for reading, open for writing, or both.
#
# A stream is automatically closed when claimed by the garbage collector.
#
# Attempted reading or writing on a closed stream raises an exception.
#
# The relevant methods:
#
# *   IO#close: Closes the stream for both reading and writing.
# *   IO#close_read: Closes the stream for reading.
# *   IO#close_write: Closes the stream for writing.
# *   IO#closed?: Returns whether the stream is closed.
#
# ### End-of-Stream
#
# You can query whether a stream is positioned at its end:
#
# *   IO#eof? (also aliased as `#eof`): Returns whether the stream is at
#     end-of-stream.
#
# You can reposition to end-of-stream by using method IO#seek:
#
#     f = File.new('t.txt')
#     f.eof? # => false
#     f.seek(0, :END)
#     f.eof? # => true
#     f.close
#
# Or by reading all stream content (which is slower than using IO#seek):
#
#     f.rewind
#     f.eof? # => false
#     f.read # => "First line\nSecond line\n\nFourth line\nFifth line\n"
#     f.eof? # => true
#
# ## Line IO
#
# Class IO supports line-oriented [input](rdoc-ref:IO@Line+Input) and
# [output](rdoc-ref:IO@Line+Output)
#
# ### Line Input
#
# Class IO supports line-oriented input for [files](rdoc-ref:IO@File+Line+Input)
# and [IO streams](rdoc-ref:IO@Stream+Line+Input)
#
# #### File Line Input
#
# You can read lines from a file using these methods:
#
# *   IO.foreach: Reads each line and passes it to the given block.
# *   IO.readlines: Reads and returns all lines in an array.
#
# For each of these methods:
#
# *   You can specify [open options](rdoc-ref:IO@Open+Options).
# *   Line parsing depends on the effective *line separator*; see [Line
#     Separator](rdoc-ref:IO@Line+Separator).
# *   The length of each returned line depends on the effective *line limit*;
#     see [Line Limit](rdoc-ref:IO@Line+Limit).
#
# #### Stream Line Input
#
# You can read lines from an IO stream using these methods:
#
# *   IO#each_line: Reads each remaining line, passing it to the given block.
# *   IO#gets: Returns the next line.
# *   IO#readline: Like #gets, but raises an exception at end-of-stream.
# *   IO#readlines: Returns all remaining lines in an array.
#
# For each of these methods:
#
# *   Reading may begin mid-line, depending on the stream's *position*; see
#     [Position](rdoc-ref:IO@Position).
# *   Line parsing depends on the effective *line separator*; see [Line
#     Separator](rdoc-ref:IO@Line+Separator).
# *   The length of each returned line depends on the effective *line limit*;
#     see [Line Limit](rdoc-ref:IO@Line+Limit).
#
# ##### Line Separator
#
# Each of the [line input methods](rdoc-ref:IO@Line+Input) uses a *line
# separator*: the string that determines what is considered a line; it is
# sometimes called the *input record separator*.
#
# The default line separator is taken from global variable `$/`, whose initial
# value is `"\n"`.
#
# Generally, the line to be read next is all data from the current
# [position](rdoc-ref:IO@Position) to the next line separator (but see [Special
# Line Separator Values](rdoc-ref:IO@Special+Line+Separator+Values)):
#
#     f = File.new('t.txt')
#     # Method gets with no sep argument returns the next line, according to $/.
#     f.gets # => "First line\n"
#     f.gets # => "Second line\n"
#     f.gets # => "\n"
#     f.gets # => "Fourth line\n"
#     f.gets # => "Fifth line\n"
#     f.close
#
# You can use a different line separator by passing argument `sep`:
#
#     f = File.new('t.txt')
#     f.gets('l')   # => "First l"
#     f.gets('li')  # => "ine\nSecond li"
#     f.gets('lin') # => "ne\n\nFourth lin"
#     f.gets        # => "e\n"
#     f.close
#
# Or by setting global variable `$/`:
#
#     f = File.new('t.txt')
#     $/ = 'l'
#     f.gets # => "First l"
#     f.gets # => "ine\nSecond l"
#     f.gets # => "ine\n\nFourth l"
#     f.close
#
# ##### Special Line Separator Values
#
# Each of the [line input methods](rdoc-ref:IO@Line+Input) accepts two special
# values for parameter `sep`:
#
# *   `nil`: The entire stream is to be read ("slurped") into a single string:
#
#         f = File.new('t.txt')
#         f.gets(nil) # => "First line\nSecond line\n\nFourth line\nFifth line\n"
#         f.close
#
# *   `''` (the empty string): The next "paragraph" is to be read (paragraphs
#     being separated by two consecutive line separators):
#
#         f = File.new('t.txt')
#         f.gets('') # => "First line\nSecond line\n\n"
#         f.gets('') # => "Fourth line\nFifth line\n"
#         f.close
#
# ##### Line Limit
#
# Each of the [line input methods](rdoc-ref:IO@Line+Input) uses an integer *line
# limit*, which restricts the number of bytes that may be returned. (A
# multi-byte character will not be split, and so a returned line may be slightly
# longer than the limit).
#
# The default limit value is `-1`; any negative limit value means that there is
# no limit.
#
# If there is no limit, the line is determined only by `sep`.
#
#     # Text with 1-byte characters.
#     File.open('t.txt') {|f| f.gets(1) }  # => "F"
#     File.open('t.txt') {|f| f.gets(2) }  # => "Fi"
#     File.open('t.txt') {|f| f.gets(3) }  # => "Fir"
#     File.open('t.txt') {|f| f.gets(4) }  # => "Firs"
#     # No more than one line.
#     File.open('t.txt') {|f| f.gets(10) } # => "First line"
#     File.open('t.txt') {|f| f.gets(11) } # => "First line\n"
#     File.open('t.txt') {|f| f.gets(12) } # => "First line\n"
#
#     # Text with 2-byte characters, which will not be split.
#     File.open('t.rus') {|f| f.gets(1).size } # => 1
#     File.open('t.rus') {|f| f.gets(2).size } # => 1
#     File.open('t.rus') {|f| f.gets(3).size } # => 2
#     File.open('t.rus') {|f| f.gets(4).size } # => 2
#
# ##### Line Separator and Line Limit
#
# With arguments `sep` and `limit` given, combines the two behaviors:
#
# *   Returns the next line as determined by line separator `sep`.
# *   But returns no more bytes than are allowed by the limit `limit`.
#
# Example:
#
#     File.open('t.txt') {|f| f.gets('li', 20) } # => "First li"
#     File.open('t.txt') {|f| f.gets('li', 2) }  # => "Fi"
#
# ##### Line Number
#
# A readable IO stream has a non-negative integer *line number*:
#
# *   IO#lineno: Returns the line number.
# *   IO#lineno=: Resets and returns the line number.
#
# Unless modified by a call to method IO#lineno=, the line number is the number
# of lines read by certain line-oriented methods, according to the effective
# [line separator](rdoc-ref:IO@Line+Separator):
#
# *   IO.foreach: Increments the line number on each call to the block.
# *   IO#each_line: Increments the line number on each call to the block.
# *   IO#gets: Increments the line number.
# *   IO#readline: Increments the line number.
# *   IO#readlines: Increments the line number for each line read.
#
# A new stream is initially has line number zero (and position zero); method
# `rewind` resets the line number (and position) to zero:
#
#     f = File.new('t.txt')
#     f.lineno # => 0
#     f.gets   # => "First line\n"
#     f.lineno # => 1
#     f.rewind
#     f.lineno # => 0
#     f.close
#
# Reading lines from a stream usually changes its line number:
#
#     f = File.new('t.txt', 'r')
#     f.lineno   # => 0
#     f.readline # => "This is line one.\n"
#     f.lineno   # => 1
#     f.readline # => "This is the second line.\n"
#     f.lineno   # => 2
#     f.readline # => "Here's the third line.\n"
#     f.lineno   # => 3
#     f.eof?     # => true
#     f.close
#
# Iterating over lines in a stream usually changes its line number:
#
#     File.open('t.txt') do |f|
#       f.each_line do |line|
#         p "position=#{f.pos} eof?=#{f.eof?} lineno=#{f.lineno}"
#       end
#     end
#
# Output:
#
#     "position=11 eof?=false lineno=1"
#     "position=23 eof?=false lineno=2"
#     "position=24 eof?=false lineno=3"
#     "position=36 eof?=false lineno=4"
#     "position=47 eof?=true lineno=5"
#
# Unlike the stream's [position](rdoc-ref:IO@Position), the line number does not
# affect where the next read or write will occur:
#
#     f = File.new('t.txt')
#     f.lineno = 1000
#     f.lineno # => 1000
#     f.gets   # => "First line\n"
#     f.lineno # => 1001
#     f.close
#
# Associated with the line number is the global variable `$.`:
#
# *   When a stream is opened, `$.` is not set; its value is left over from
#     previous activity in the process:
#
#         $. = 41
#         f = File.new('t.txt')
#         $. = 41
#         # => 41
#         f.close
#
# *   When a stream is read, `$.` is set to the line number for that stream:
#
#         f0 = File.new('t.txt')
#         f1 = File.new('t.dat')
#         f0.readlines # => ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
#         $.           # => 5
#         f1.readlines # => ["\xFE\xFF\x99\x90\x99\x91\x99\x92\x99\x93\x99\x94"]
#         $.           # => 1
#         f0.close
#         f1.close
#
# *   Methods IO#rewind and IO#seek do not affect `$.`:
#
#         f = File.new('t.txt')
#         f.readlines # => ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
#         $.          # => 5
#         f.rewind
#         f.seek(0, :SET)
#         $.          # => 5
#         f.close
#
# ### Line Output
#
# You can write to an IO stream line-by-line using this method:
#
# *   IO#puts: Writes objects to the stream.
#
# ## Character IO
#
# You can process an IO stream character-by-character using these methods:
#
# *   IO#getc: Reads and returns the next character from the stream.
# *   IO#readchar: Like #getc, but raises an exception at end-of-stream.
# *   IO#ungetc: Pushes back ("unshifts") a character or integer onto the
#     stream.
# *   IO#putc: Writes a character to the stream.
# *   IO#each_char: Reads each remaining character in the stream, passing the
#     character to the given block.
#
# ## Byte IO
#
# You can process an IO stream byte-by-byte using these methods:
#
# *   IO#getbyte: Returns the next 8-bit byte as an integer in range 0..255.
# *   IO#readbyte: Like #getbyte, but raises an exception if at end-of-stream.
# *   IO#ungetbyte: Pushes back ("unshifts") a byte back onto the stream.
# *   IO#each_byte: Reads each remaining byte in the stream, passing the byte to
#     the given block.
#
# ## Codepoint IO
#
# You can process an IO stream codepoint-by-codepoint:
#
# *   IO#each_codepoint: Reads each remaining codepoint, passing it to the given
#     block.
#
# ## What's Here
#
# First, what's elsewhere. Class IO:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# Here, class IO provides methods that are useful for:
#
# *   [Creating](rdoc-ref:IO@Creating)
# *   [Reading](rdoc-ref:IO@Reading)
# *   [Writing](rdoc-ref:IO@Writing)
# *   [Positioning](rdoc-ref:IO@Positioning)
# *   [Iterating](rdoc-ref:IO@Iterating)
# *   [Settings](rdoc-ref:IO@Settings)
# *   [Querying](rdoc-ref:IO@Querying)
# *   [Buffering](rdoc-ref:IO@Buffering)
# *   [Low-Level Access](rdoc-ref:IO@Low-Level+Access)
# *   [Other](rdoc-ref:IO@Other)
#
# ### Creating
#
# *   ::new (aliased as ::for_fd): Creates and returns a new IO object for the
#     given integer file descriptor.
# *   ::open: Creates a new IO object.
# *   ::pipe: Creates a connected pair of reader and writer IO objects.
# *   ::popen: Creates an IO object to interact with a subprocess.
# *   ::select: Selects which given IO instances are ready for reading, writing,
#     or have pending exceptions.
#
# ### Reading
#
# *   ::binread: Returns a binary string with all or a subset of bytes from the
#     given file.
# *   ::read: Returns a string with all or a subset of bytes from the given
#     file.
# *   ::readlines: Returns an array of strings, which are the lines from the
#     given file.
# *   #getbyte: Returns the next 8-bit byte read from `self` as an integer.
# *   #getc: Returns the next character read from `self` as a string.
# *   #gets: Returns the line read from `self`.
# *   #pread: Returns all or the next *n* bytes read from `self`, not updating
#     the receiver's offset.
# *   #read: Returns all remaining or the next *n* bytes read from `self` for a
#     given *n*.
# *   #read_nonblock: the next *n* bytes read from `self` for a given *n*, in
#     non-block mode.
# *   #readbyte: Returns the next byte read from `self`; same as #getbyte, but
#     raises an exception on end-of-stream.
# *   #readchar: Returns the next character read from `self`; same as #getc, but
#     raises an exception on end-of-stream.
# *   #readline: Returns the next line read from `self`; same as #getline, but
#     raises an exception of end-of-stream.
# *   #readlines: Returns an array of all lines read read from `self`.
# *   #readpartial: Returns up to the given number of bytes from `self`.
#
# ### Writing
#
# *   ::binwrite: Writes the given string to the file at the given filepath, in
#     binary mode.
# *   ::write: Writes the given string to `self`.
# *   #<<: Appends the given string to `self`.
# *   #print: Prints last read line or given objects to `self`.
# *   #printf: Writes to `self` based on the given format string and objects.
# *   #putc: Writes a character to `self`.
# *   #puts: Writes lines to `self`, making sure line ends with a newline.
# *   #pwrite: Writes the given string at the given offset, not updating the
#     receiver's offset.
# *   #write: Writes one or more given strings to `self`.
# *   #write_nonblock: Writes one or more given strings to `self` in
#     non-blocking mode.
#
# ### Positioning
#
# *   #lineno: Returns the current line number in `self`.
# *   #lineno=: Sets the line number is `self`.
# *   #pos (aliased as #tell): Returns the current byte offset in `self`.
# *   #pos=: Sets the byte offset in `self`.
# *   #reopen: Reassociates `self` with a new or existing IO stream.
# *   #rewind: Positions `self` to the beginning of input.
# *   #seek: Sets the offset for `self` relative to given position.
#
# ### Iterating
#
# *   ::foreach: Yields each line of given file to the block.
# *   #each (aliased as #each_line): Calls the given block with each successive
#     line in `self`.
# *   #each_byte: Calls the given block with each successive byte in `self` as
#     an integer.
# *   #each_char: Calls the given block with each successive character in `self`
#     as a string.
# *   #each_codepoint: Calls the given block with each successive codepoint in
#     `self` as an integer.
#
# ### Settings
#
# *   #autoclose=: Sets whether `self` auto-closes.
# *   #binmode: Sets `self` to binary mode.
# *   #close: Closes `self`.
# *   #close_on_exec=: Sets the close-on-exec flag.
# *   #close_read: Closes `self` for reading.
# *   #close_write: Closes `self` for writing.
# *   #set_encoding: Sets the encoding for `self`.
# *   #set_encoding_by_bom: Sets the encoding for `self`, based on its Unicode
#     byte-order-mark.
# *   #sync=: Sets the sync-mode to the given value.
#
# ### Querying
#
# *   #autoclose?: Returns whether `self` auto-closes.
# *   #binmode?: Returns whether `self` is in binary mode.
# *   #close_on_exec?: Returns the close-on-exec flag for `self`.
# *   #closed?: Returns whether `self` is closed.
# *   #eof? (aliased as #eof): Returns whether `self` is at end-of-stream.
# *   #external_encoding: Returns the external encoding object for `self`.
# *   #fileno (aliased as #to_i): Returns the integer file descriptor for `self`
# *   #internal_encoding: Returns the internal encoding object for `self`.
# *   #pid: Returns the process ID of a child process associated with `self`, if
#     `self` was created by ::popen.
# *   #stat: Returns the File::Stat object containing status information for
#     `self`.
# *   #sync: Returns whether `self` is in sync-mode.
# *   #tty? (aliased as #isatty): Returns whether `self` is a terminal.
#
# ### Buffering
#
# *   #fdatasync: Immediately writes all buffered data in `self` to disk.
# *   #flush: Flushes any buffered data within `self` to the underlying
#     operating system.
# *   #fsync: Immediately writes all buffered data and attributes in `self` to
#     disk.
# *   #ungetbyte: Prepends buffer for `self` with given integer byte or string.
# *   #ungetc: Prepends buffer for `self` with given string.
#
# ### Low-Level Access
#
# *   ::sysopen: Opens the file given by its path, returning the integer file
#     descriptor.
# *   #advise: Announces the intention to access data from `self` in a specific
#     way.
# *   #fcntl: Passes a low-level command to the file specified by the given file
#     descriptor.
# *   #ioctl: Passes a low-level command to the device specified by the given
#     file descriptor.
# *   #sysread: Returns up to the next *n* bytes read from self using a
#     low-level read.
# *   #sysseek: Sets the offset for `self`.
# *   #syswrite: Writes the given string to `self` using a low-level write.
#
# ### Other
#
# *   ::copy_stream: Copies data from a source to a destination, each of which
#     is a filepath or an IO-like object.
# *   ::try_convert: Returns a new IO object resulting from converting the given
#     object.
# *   #inspect: Returns the string representation of `self`.
#
%a{annotate:rdoc:source:from=io.c}
class IO < Object
  include File::Constants

  include Enumerable[String]

  # <!--
  #   rdoc-file=io.c
  #   - self << object -> self
  # -->
  # Writes the given `object` to `self`, which must be opened for writing (see
  # [Access Modes](rdoc-ref:File@Access+Modes)); returns `self`; if `object` is
  # not a string, it is converted via method `to_s`:
  #
  #     $stdout << 'Hello' << ', ' << 'World!' << "\n"
  #     $stdout << 'foo' << :bar << 2 << "\n"
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  def <<: (_ToS obj) -> self

  # <!--
  #   rdoc-file=io.c
  #   - advise(advice, offset = 0, len = 0) -> nil
  # -->
  # Invokes Posix system call
  # [posix_fadvise(2)](https://linux.die.net/man/2/posix_fadvise), which announces
  # an intention to access data from the current file in a particular manner.
  #
  # The arguments and results are platform-dependent.
  #
  # The relevant data is specified by:
  #
  # *   `offset`: The offset of the first byte of data.
  # *   `len`: The number of bytes to be accessed; if `len` is zero, or is larger
  #     than the number of bytes remaining, all remaining bytes will be accessed.
  #
  # Argument `advice` is one of the following symbols:
  #
  # *   `:normal`: The application has no advice to give about its access pattern
  #     for the specified data. If no advice is given for an open file, this is
  #     the default assumption.
  # *   `:sequential`: The application expects to access the specified data
  #     sequentially (with lower offsets read before higher ones).
  # *   `:random`: The specified data will be accessed in random order.
  # *   `:noreuse`: The specified data will be accessed only once.
  # *   `:willneed`: The specified data will be accessed in the near future.
  # *   `:dontneed`: The specified data will not be accessed in the near future.
  #
  # Not implemented on all platforms.
  #
  def advise: (:normal | :sequential | :random | :willneed | :dontneed | :noreuse advise, ?Integer offset, ?Integer len) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - io.autoclose = bool    -> true or false
  # -->
  # Sets auto-close flag.
  #
  #     f = File.open(File::NULL)
  #     IO.for_fd(f.fileno).close
  #     f.gets # raises Errno::EBADF
  #
  #     f = File.open(File::NULL)
  #     g = IO.for_fd(f.fileno)
  #     g.autoclose = false
  #     g.close
  #     f.gets # won't cause Errno::EBADF
  #
  def autoclose=: (boolish bool) -> boolish

  # <!--
  #   rdoc-file=io.c
  #   - ios.autoclose?   -> true or false
  # -->
  # Returns `true` if the underlying file descriptor of *ios* will be closed at
  # its finalization or at calling #close, otherwise `false`.
  #
  def autoclose?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - binmode -> self
  # -->
  # Sets the stream's data mode as binary (see [Data
  # Mode](rdoc-ref:File@Data+Mode)).
  #
  # A stream's data mode may not be changed from binary to text.
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - binmode? -> true or false
  # -->
  # Returns `true` if the stream is on binary mode, `false` otherwise. See [Data
  # Mode](rdoc-ref:File@Data+Mode).
  #
  def binmode?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - close -> nil
  # -->
  # Closes the stream for both reading and writing if open for either or both;
  # returns `nil`. See [Open and Closed
  # Streams](rdoc-ref:IO@Open+and+Closed+Streams).
  #
  # If the stream is open for writing, flushes any buffered writes to the
  # operating system before closing.
  #
  # If the stream was opened by IO.popen, sets global variable `$?` (child exit
  # status).
  #
  # It is not an error to close an IO object that has already been closed. It just
  # returns nil.
  #
  # Example:
  #
  #     IO.popen('ruby', 'r+') do |pipe|
  #       puts pipe.closed?
  #       pipe.close
  #       puts $?
  #       puts pipe.closed?
  #     end
  #
  # Output:
  #
  #     false
  #     pid 13760 exit 0
  #     true
  #
  # Related: IO#close_read, IO#close_write, IO#closed?.
  #
  def close: () -> nil

  # <!--
  #   rdoc-file=io.c
  #   - self.close_on_exec = bool -> true or false
  # -->
  # Sets a close-on-exec flag.
  #
  #     f = File.open(File::NULL)
  #     f.close_on_exec = true
  #     system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No such file or directory
  #     f.closed?                #=> false
  #
  # Ruby sets close-on-exec flags of all file descriptors by default since Ruby
  # 2.0.0. So you don't need to set by yourself. Also, unsetting a close-on-exec
  # flag can cause file descriptor leak if another thread use fork() and exec()
  # (via system() method for example). If you really needs file descriptor
  # inheritance to child process, use spawn()'s argument such as fd=>fd.
  #
  def close_on_exec=: (boolish bool) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - close_on_exec? -> true or false
  # -->
  # Returns `true` if the stream will be closed on exec, `false` otherwise:
  #
  #     f = File.open('t.txt')
  #     f.close_on_exec? # => true
  #     f.close_on_exec = false
  #     f.close_on_exec? # => false
  #     f.close
  #
  def close_on_exec?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - close_read -> nil
  # -->
  # Closes the stream for reading if open for reading; returns `nil`. See [Open
  # and Closed Streams](rdoc-ref:IO@Open+and+Closed+Streams).
  #
  # If the stream was opened by IO.popen and is also closed for writing, sets
  # global variable `$?` (child exit status).
  #
  # Example:
  #
  #     IO.popen('ruby', 'r+') do |pipe|
  #       puts pipe.closed?
  #       pipe.close_write
  #       puts pipe.closed?
  #       pipe.close_read
  #       puts $?
  #       puts pipe.closed?
  #     end
  #
  # Output:
  #
  #     false
  #     false
  #     pid 14748 exit 0
  #     true
  #
  # Related: IO#close, IO#close_write, IO#closed?.
  #
  def close_read: () -> nil

  # <!--
  #   rdoc-file=io.c
  #   - close_write -> nil
  # -->
  # Closes the stream for writing if open for writing; returns `nil`. See [Open
  # and Closed Streams](rdoc-ref:IO@Open+and+Closed+Streams).
  #
  # Flushes any buffered writes to the operating system before closing.
  #
  # If the stream was opened by IO.popen and is also closed for reading, sets
  # global variable `$?` (child exit status).
  #
  #     IO.popen('ruby', 'r+') do |pipe|
  #       puts pipe.closed?
  #       pipe.close_read
  #       puts pipe.closed?
  #       pipe.close_write
  #       puts $?
  #       puts pipe.closed?
  #     end
  #
  # Output:
  #
  #     false
  #     false
  #     pid 15044 exit 0
  #     true
  #
  # Related: IO#close, IO#close_read, IO#closed?.
  #
  def close_write: () -> nil

  # <!--
  #   rdoc-file=io.c
  #   - closed? -> true or false
  # -->
  # Returns `true` if the stream is closed for both reading and writing, `false`
  # otherwise. See [Open and Closed Streams](rdoc-ref:IO@Open+and+Closed+Streams).
  #
  #     IO.popen('ruby', 'r+') do |pipe|
  #       puts pipe.closed?
  #       pipe.close_read
  #       puts pipe.closed?
  #       pipe.close_write
  #       puts pipe.closed?
  #     end
  #
  # Output:
  #
  #     false
  #     false
  #     true
  #
  # Related: IO#close_read, IO#close_write, IO#close.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - each_byte {|byte| ... } -> self
  #   - each_byte               -> enumerator
  # -->
  # Calls the given block with each byte (0..255) in the stream; returns `self`.
  # See [Byte IO](rdoc-ref:IO@Byte+IO).
  #
  #     f = File.new('t.rus')
  #     a = []
  #     f.each_byte {|b| a << b }
  #     a # => [209, 130, 208, 181, 209, 129, 209, 130]
  #     f.close
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: IO#each_char, IO#each_codepoint.
  #
  def each_byte: () { (Integer byte) -> void } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - each_char {|c| ... } -> self
  #   - each_char            -> enumerator
  # -->
  # Calls the given block with each character in the stream; returns `self`. See
  # [Character IO](rdoc-ref:IO@Character+IO).
  #
  #     f = File.new('t.rus')
  #     a = []
  #     f.each_char {|c| a << c.ord }
  #     a # => [1090, 1077, 1089, 1090]
  #     f.close
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: IO#each_byte, IO#each_codepoint.
  #
  def each_char: () { (String c) -> void } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - each_codepoint {|c| ... } -> self
  #   - each_codepoint            -> enumerator
  # -->
  # Calls the given block with each codepoint in the stream; returns `self`:
  #
  #     f = File.new('t.rus')
  #     a = []
  #     f.each_codepoint {|c| a << c }
  #     a # => [1090, 1077, 1089, 1090]
  #     f.close
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: IO#each_byte, IO#each_char.
  #
  def each_codepoint: () { (Integer c) -> void } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - eof -> true or false
  # -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](rdoc-ref:IO@Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #     f.close
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](rdoc-ref:File@Access+Modes).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - fcntl(integer_cmd, argument) -> integer
  # -->
  # Invokes Posix system call [fcntl(2)](https://linux.die.net/man/2/fcntl), which
  # provides a mechanism for issuing low-level commands to control or query a
  # file-oriented I/O stream. Arguments and results are platform dependent.
  #
  # If `argument` is a number, its value is passed directly; if it is a string, it
  # is interpreted as a binary sequence of bytes. (Array#pack might be a useful
  # way to build this string.)
  #
  # Not implemented on all platforms.
  #
  def fcntl: (Integer integer_cmd, String | Integer argument) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - fdatasync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's: `fdatasync(2)`, if supported, otherwise via `fsync(2)`, if
  # supported; otherwise raises an exception.
  #
  def fdatasync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - fileno -> integer
  # -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #     f.close
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - flush -> self
  # -->
  # Flushes data buffered in `self` to the operating system (but does not
  # necessarily flush data buffered in the operating system):
  #
  #     $stdout.print 'no newline' # Not necessarily flushed.
  #     $stdout.flush              # Flushed.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - fsync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's `fsync(2)`.
  #
  # Note this difference:
  #
  # *   IO#sync=: Ensures that data is flushed from the stream's internal buffers,
  #     but does not guarantee that the operating system actually writes the data
  #     to disk.
  # *   IO#fsync: Ensures both that data is flushed from internal buffers, and
  #     that data is written to disk.
  #
  # Raises an exception if the operating system does not support `fsync(2)`.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - getbyte -> integer or nil
  # -->
  # Reads and returns the next byte (in range 0..255) from the stream; returns
  # `nil` if already at end-of-stream. See [Byte IO](rdoc-ref:IO@Byte+IO).
  #
  #     f = File.open('t.txt')
  #     f.getbyte # => 70
  #     f.close
  #     f = File.open('t.rus')
  #     f.getbyte # => 209
  #     f.close
  #
  # Related: IO#readbyte (may raise EOFError).
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - getc -> character or nil
  # -->
  # Reads and returns the next 1-character string from the stream; returns `nil`
  # if already at end-of-stream. See [Character IO](rdoc-ref:IO@Character+IO).
  #
  #     f = File.open('t.txt')
  #     f.getc     # => "F"
  #     f.close
  #     f = File.open('t.rus')
  #     f.getc.ord # => 1090
  #     f.close
  #
  # Related:  IO#readchar (may raise EOFError).
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep = $/, chomp: false)   -> string or nil
  #   - gets(limit, chomp: false)      -> string or nil
  #   - gets(sep, limit, chomp: false) -> string or nil
  # -->
  # Reads and returns a line from the stream; assigns the return value to `$_`.
  # See [Line IO](rdoc-ref:IO@Line+IO).
  #
  # With no arguments given, returns the next line as determined by line separator
  # `$/`, or `nil` if none:
  #
  #     f = File.open('t.txt')
  #     f.gets # => "First line\n"
  #     $_     # => "First line\n"
  #     f.gets # => "\n"
  #     f.gets # => "Fourth line\n"
  #     f.gets # => "Fifth line\n"
  #     f.gets # => nil
  #     f.close
  #
  # With only string argument `sep` given, returns the next line as determined by
  # line separator `sep`, or `nil` if none; see [Line
  # Separator](rdoc-ref:IO@Line+Separator):
  #
  #     f = File.new('t.txt')
  #     f.gets('l')   # => "First l"
  #     f.gets('li')  # => "ine\nSecond li"
  #     f.gets('lin') # => "ne\n\nFourth lin"
  #     f.gets        # => "e\n"
  #     f.close
  #
  # The two special values for `sep` are honored:
  #
  #     f = File.new('t.txt')
  #     # Get all.
  #     f.gets(nil) # => "First line\nSecond line\n\nFourth line\nFifth line\n"
  #     f.rewind
  #     # Get paragraph (up to two line separators).
  #     f.gets('')  # => "First line\nSecond line\n\n"
  #     f.close
  #
  # With only integer argument `limit` given, limits the number of bytes in the
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     # No more than one line.
  #     File.open('t.txt') {|f| f.gets(10) } # => "First line"
  #     File.open('t.txt') {|f| f.gets(11) } # => "First line\n"
  #     File.open('t.txt') {|f| f.gets(12) } # => "First line\n"
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     f = File.open('t.txt')
  #     # Chomp the lines.
  #     f.gets(chomp: true) # => "First line"
  #     f.gets(chomp: true) # => "Second line"
  #     f.gets(chomp: true) # => ""
  #     f.gets(chomp: true) # => "Fourth line"
  #     f.gets(chomp: true) # => "Fifth line"
  #     f.gets(chomp: true) # => nil
  #     f.close
  #
  def gets: (string? sep, ?int limit, ?chomp: boolish) -> String?
          | (?int limit, ?chomp: boolish) -> String?

  # <!--
  #   rdoc-file=io.c
  #   - IO.new(fd, mode = 'r', **opts) -> io
  # -->
  # Creates and returns a new IO object (file stream) from a file descriptor.
  #
  # IO.new may be useful for interaction with low-level libraries. For
  # higher-level interactions, it may be simpler to create the file stream using
  # File.open.
  #
  # Argument `fd` must be a valid file descriptor (integer):
  #
  #     path = 't.tmp'
  #     fd = IO.sysopen(path) # => 3
  #     IO.new(fd)            # => #<IO:fd 3>
  #
  # The new IO object does not inherit encoding (because the integer file
  # descriptor does not have an encoding):
  #
  #     fd = IO.sysopen('t.rus', 'rb')
  #     io = IO.new(fd)
  #     io.external_encoding # => #<Encoding:UTF-8> # Not ASCII-8BIT.
  #
  # Optional argument `mode` (defaults to 'r') must specify a valid mode; see
  # [Access Modes](rdoc-ref:File@Access+Modes):
  #
  #     IO.new(fd, 'w')         # => #<IO:fd 3>
  #     IO.new(fd, File::WRONLY) # => #<IO:fd 3>
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  # Examples:
  #
  #     IO.new(fd, internal_encoding: nil) # => #<IO:fd 3>
  #     IO.new(fd, autoclose: true)        # => #<IO:fd 3>
  #
  def initialize: ( int fd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String) -> void

  # <!--
  #   rdoc-file=io.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     f = File.open('t.txt')
  #     f.inspect # => "#<File:t.txt>"
  #     f.close
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=io.c
  #   - internal_encoding -> encoding or nil
  # -->
  # Returns the Encoding object that represents the encoding of the internal
  # string, if conversion is specified, or `nil` otherwise.
  #
  # See [Encodings](rdoc-ref:File@Encodings).
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=io.c
  #   - ioctl(integer_cmd, argument) -> integer
  # -->
  # Invokes Posix system call [ioctl(2)](https://linux.die.net/man/2/ioctl), which
  # issues a low-level command to an I/O device.
  #
  # Issues a low-level command to an I/O device. The arguments and returned value
  # are platform-dependent. The effect of the call is platform-dependent.
  #
  # If argument `argument` is an integer, it is passed directly; if it is a
  # string, it is interpreted as a binary sequence of bytes.
  #
  # Not implemented on all platforms.
  #
  def ioctl: (Integer integer_cmd, String | Integer argument) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - isatty -> true or false
  # -->
  # Returns `true` if the stream is associated with a terminal device (tty),
  # `false` otherwise:
  #
  #     f = File.new('t.txt').isatty    #=> false
  #     f.close
  #     f = File.new('/dev/tty').isatty #=> true
  #     f.close
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - lineno -> integer
  # -->
  # Returns the current line number for the stream; see [Line
  # Number](rdoc-ref:IO@Line+Number).
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - lineno = integer -> integer
  # -->
  # Sets and returns the line number for the stream; see [Line
  # Number](rdoc-ref:IO@Line+Number).
  #
  def lineno=: (Integer integer) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - path -> string or nil
  # -->
  # Returns the path associated with the IO, or `nil` if there is no path
  # associated with the IO. It is not guaranteed that the path exists on the
  # filesystem.
  #
  #     $stdin.path # => "<STDIN>"
  #
  #     File.open("testfile") {|f| f.path} # => "testfile"
  #
  def path: () -> String?

  # <!--
  #   rdoc-file=io.c
  #   - pid -> integer or nil
  # -->
  # Returns the process ID of a child process associated with the stream, which
  # will have been set by IO#popen, or `nil` if the stream was not created by
  # IO#popen:
  #
  #     pipe = IO.popen("-")
  #     if pipe
  #       $stderr.puts "In parent, child pid is #{pipe.pid}"
  #     else
  #       $stderr.puts "In child, pid is #{$$}"
  #     end
  #
  # Output:
  #
  #     In child, pid is 26209
  #     In parent, child pid is 26209
  #
  def pid: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - pos = new_position -> new_position
  # -->
  # Seeks to the given `new_position` (in bytes); see
  # [Position](rdoc-ref:IO@Position):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.pos = 20 # => 20
  #     f.tell     # => 20
  #     f.close
  #
  # Related: IO#seek, IO#tell.
  #
  def pos=: (Integer new_position) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - print(*objects) -> nil
  # -->
  # Writes the given objects to the stream; returns `nil`. Appends the output
  # record separator `$OUTPUT_RECORD_SEPARATOR` (`$\`), if it is not `nil`. See
  # [Line IO](rdoc-ref:IO@Line+IO).
  #
  # With argument `objects` given, for each object:
  #
  # *   Converts via its method `to_s` if not a string.
  # *   Writes to the stream.
  # *   If not the last object, writes the output field separator
  #     `$OUTPUT_FIELD_SEPARATOR` (`$,`) if it is not `nil`.
  #
  # With default separators:
  #
  #     f = File.open('t.tmp', 'w+')
  #     objects = [0, 0.0, Rational(0, 1), Complex(0, 0), :zero, 'zero']
  #     p $OUTPUT_RECORD_SEPARATOR
  #     p $OUTPUT_FIELD_SEPARATOR
  #     f.print(*objects)
  #     f.rewind
  #     p f.read
  #     f.close
  #
  # Output:
  #
  #     nil
  #     nil
  #     "00.00/10+0izerozero"
  #
  # With specified separators:
  #
  #     $\ = "\n"
  #     $, = ','
  #     f.rewind
  #     f.print(*objects)
  #     f.rewind
  #     p f.read
  #
  # Output:
  #
  #     "0,0.0,0/1,0+0i,zero,zero\n"
  #
  # With no argument given, writes the content of `$_` (which is usually the most
  # recent user input):
  #
  #     f = File.open('t.tmp', 'w+')
  #     gets # Sets $_ to the most recent user input.
  #     f.print
  #     f.close
  #
  def print: (*untyped objects) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - printf(format_string, *objects) -> nil
  # -->
  # Formats and writes `objects` to the stream.
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  def printf: (String format_string, *untyped objects) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - putc(object) -> object
  # -->
  # Writes a character to the stream. See [Character
  # IO](rdoc-ref:IO@Character+IO).
  #
  # If `object` is numeric, converts to integer if necessary, then writes the
  # character whose code is the least significant byte; if `object` is a string,
  # writes the first character:
  #
  #     $stdout.putc "A"
  #     $stdout.putc 65
  #
  # Output:
  #
  #     AA
  #
  def putc: (Numeric | String object) -> (Numeric | String)

  # <!--
  #   rdoc-file=io.c
  #   - puts(*objects) -> nil
  # -->
  # Writes the given `objects` to the stream, which must be open for writing;
  # returns `nil`.\ Writes a newline after each that does not already end with a
  # newline sequence. If called without arguments, writes a newline. See [Line
  # IO](rdoc-ref:IO@Line+IO).
  #
  # Note that each added newline is the character `"\n"<//tt>, not the output
  # record separator (<tt>$\`).
  #
  # Treatment for each object:
  #
  # *   String: writes the string.
  # *   Neither string nor array: writes `object.to_s`.
  # *   Array: writes each element of the array; arrays may be nested.
  #
  # To keep these examples brief, we define this helper method:
  #
  #     def show(*objects)
  #       # Puts objects to file.
  #       f = File.new('t.tmp', 'w+')
  #       f.puts(objects)
  #       # Return file content.
  #       f.rewind
  #       p f.read
  #       f.close
  #     end
  #
  #     # Strings without newlines.
  #     show('foo', 'bar', 'baz')     # => "foo\nbar\nbaz\n"
  #     # Strings, some with newlines.
  #     show("foo\n", 'bar', "baz\n") # => "foo\nbar\nbaz\n"
  #
  #     # Neither strings nor arrays:
  #     show(0, 0.0, Rational(0, 1), Complex(9, 0), :zero)
  #     # => "0\n0.0\n0/1\n9+0i\nzero\n"
  #
  #     # Array of strings.
  #     show(['foo', "bar\n", 'baz']) # => "foo\nbar\nbaz\n"
  #     # Nested arrays.
  #     show([[[0, 1], 2, 3], 4, 5])  # => "0\n1\n2\n3\n4\n5\n"
  #
  def puts: (*untyped objects) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - read(maxlen = nil, out_string = nil) -> new_string, out_string, or nil
  # -->
  # Reads bytes from the stream; the stream must be opened for reading (see
  # [Access Modes](rdoc-ref:File@Access+Modes)):
  #
  # *   If `maxlen` is `nil`, reads all bytes using the stream's data mode.
  # *   Otherwise reads up to `maxlen` bytes in binary mode.
  #
  # Returns a string (either a new string or the given `out_string`) containing
  # the bytes read. The encoding of the string depends on both `maxLen` and
  # `out_string`:
  #
  # *   `maxlen` is `nil`: uses internal encoding of `self` (regardless of whether
  #     `out_string` was given).
  # *   `maxlen` not `nil`:
  #
  #     *   `out_string` given: encoding of `out_string` not modified.
  #     *   `out_string` not given: ASCII-8BIT is used.
  #
  # **Without Argument `out_string`**
  #
  # When argument `out_string` is omitted, the returned value is a new string:
  #
  #     f = File.new('t.txt')
  #     f.read
  #     # => "First line\nSecond line\n\nFourth line\nFifth line\n"
  #     f.rewind
  #     f.read(30) # => "First line\r\nSecond line\r\n\r\nFou"
  #     f.read(30) # => "rth line\r\nFifth line\r\n"
  #     f.read(30) # => nil
  #     f.close
  #
  # If `maxlen` is zero, returns an empty string.
  #
  # ** With Argument `out_string`**
  #
  # When argument `out_string` is given, the returned value is `out_string`, whose
  # content is replaced:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'      # => "foo"
  #     f.read(nil, s) # => "First line\nSecond line\n\nFourth line\nFifth line\n"
  #     s              # => "First line\nSecond line\n\nFourth line\nFifth line\n"
  #     f.rewind
  #     s = 'bar'
  #     f.read(30, s)  # => "First line\r\nSecond line\r\n\r\nFou"
  #     s              # => "First line\r\nSecond line\r\n\r\nFou"
  #     s = 'baz'
  #     f.read(30, s)  # => "rth line\r\nFifth line\r\n"
  #     s              # => "rth line\r\nFifth line\r\n"
  #     s = 'bat'
  #     f.read(30, s)  # => nil
  #     s              # => ""
  #     f.close
  #
  # Note that this method behaves like the fread() function in C. This means it
  # retries to invoke read(2) system calls to read data with the specified maxlen
  # (or until EOF).
  #
  # This behavior is preserved even if the stream is in non-blocking mode. (This
  # method is non-blocking-flag insensitive as other methods.)
  #
  # If you need the behavior like a single read(2) system call, consider
  # #readpartial, #read_nonblock, and #sysread.
  #
  # Related: IO#write.
  #
  def read: (?nil, ?string outbuf) -> String
          | (int? length, ?string outbuf) -> String?

  # <!--
  #   rdoc-file=io.rb
  #   - ios.read_nonblock(maxlen [, options])              -> string
  #   - ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf
  # -->
  # Reads at most *maxlen* bytes from *ios* using the read(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # If the optional *outbuf* argument is present, it must reference a String,
  # which will receive the data. The *outbuf* will contain only the received data
  # after the method call even if it is not empty at the beginning.
  #
  # read_nonblock just calls the read(2) system call. It causes all errors the
  # read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller
  # should care such errors.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying read_nonblock.
  #
  # read_nonblock causes EOFError on EOF.
  #
  # On some platforms, such as Windows, non-blocking mode is not supported on IO
  # objects other than sockets. In such cases, Errno::EBADF will be raised.
  #
  # If the read byte buffer is not empty, read_nonblock reads from the buffer like
  # readpartial. In this case, the read(2) system call is not called.
  #
  # When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock
  # should not be called until io is readable for avoiding busy loop. This can be
  # done as follows.
  #
  #     # emulates blocking read (readpartial).
  #     begin
  #       result = io.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io])
  #       retry
  #     end
  #
  # Although IO#read_nonblock doesn't raise IO::WaitWritable.
  # OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. If IO and SSL
  # should be used polymorphically, IO::WaitWritable should be rescued too. See
  # the document of OpenSSL::Buffering#read_nonblock for sample code.
  #
  # Note that this method is identical to readpartial except the non-blocking flag
  # is set.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # read_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead. At EOF, it will return nil instead of raising
  # EOFError.
  #
  def read_nonblock: (int len, ?string buf, ?exception: true) -> String
                   | (int len, ?string buf, exception: false) -> (String | :wait_readable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - readbyte -> integer
  # -->
  # Reads and returns the next byte (in range 0..255) from the stream; raises
  # EOFError if already at end-of-stream. See [Byte IO](rdoc-ref:IO@Byte+IO).
  #
  #     f = File.open('t.txt')
  #     f.readbyte # => 70
  #     f.close
  #     f = File.open('t.rus')
  #     f.readbyte # => 209
  #     f.close
  #
  # Related: IO#getbyte (will not raise EOFError).
  #
  def readbyte: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - readchar -> string
  # -->
  # Reads and returns the next 1-character string from the stream; raises EOFError
  # if already at end-of-stream. See [Character IO](rdoc-ref:IO@Character+IO).
  #
  #     f = File.open('t.txt')
  #     f.readchar     # => "F"
  #     f.close
  #     f = File.open('t.rus')
  #     f.readchar.ord # => 1090
  #     f.close
  #
  # Related:  IO#getc (will not raise EOFError).
  #
  def readchar: () -> String

  # <!--
  #   rdoc-file=io.rb
  #   - readline(sep = $/, chomp: false)   -> string
  #   - readline(limit, chomp: false)      -> string
  #   - readline(sep, limit, chomp: false) -> string
  # -->
  # Reads a line as with IO#gets, but raises EOFError if already at end-of-stream.
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted.
  #
  def readline: (?String sep, ?Integer limit, ?chomp: boolish) -> String

  # <!--
  #   rdoc-file=io.c
  #   - readlines(sep = $/, chomp: false)   -> array
  #   - readlines(limit, chomp: false)       -> array
  #   - readlines(sep, limit, chomp: false) -> array
  # -->
  # Reads and returns all remaining line from the stream; does not modify `$_`.
  # See [Line IO](rdoc-ref:IO@Line+IO).
  #
  # With no arguments given, returns lines as determined by line separator `$/`,
  # or `nil` if none:
  #
  #     f = File.new('t.txt')
  #     f.readlines
  #     # => ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #     f.readlines # => []
  #     f.close
  #
  # With only string argument `sep` given, returns lines as determined by line
  # separator `sep`, or `nil` if none; see [Line
  # Separator](rdoc-ref:IO@Line+Separator):
  #
  #     f = File.new('t.txt')
  #     f.readlines('li')
  #     # => ["First li", "ne\nSecond li", "ne\n\nFourth li", "ne\nFifth li", "ne\n"]
  #     f.close
  #
  # The two special values for `sep` are honored:
  #
  #     f = File.new('t.txt')
  #     # Get all into one string.
  #     f.readlines(nil)
  #     # => ["First line\nSecond line\n\nFourth line\nFifth line\n"]
  #     # Get paragraphs (up to two line separators).
  #     f.rewind
  #     f.readlines('')
  #     # => ["First line\nSecond line\n\n", "Fourth line\nFifth line\n"]
  #     f.close
  #
  # With only integer argument `limit` given, limits the number of bytes in each
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     f = File.new('t.txt')
  #     f.readlines(8)
  #     # => ["First li", "ne\n", "Second l", "ine\n", "\n", "Fourth l", "ine\n", "Fifth li", "ne\n"]
  #     f.close
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     f = File.new('t.txt')
  #     f.readlines(chomp: true)
  #     # => ["First line", "Second line", "", "Fourth line", "Fifth line"]
  #     f.close
  #
  def readlines: (?String sep, ?Integer limit, ?chomp: boolish) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - readpartial(maxlen)             -> string
  #   - readpartial(maxlen, out_string) -> out_string
  # -->
  # Reads up to `maxlen` bytes from the stream; returns a string (either a new
  # string or the given `out_string`). Its encoding is:
  #
  # *   The unchanged encoding of `out_string`, if `out_string` is given.
  # *   ASCII-8BIT, otherwise.
  #
  # *   Contains `maxlen` bytes from the stream, if available.
  # *   Otherwise contains all available bytes, if any available.
  # *   Otherwise is an empty string.
  #
  # With the single non-negative integer argument `maxlen` given, returns a new
  # string:
  #
  #     f = File.new('t.txt')
  #     f.readpartial(20) # => "First line\nSecond l"
  #     f.readpartial(20) # => "ine\n\nFourth line\n"
  #     f.readpartial(20) # => "Fifth line\n"
  #     f.readpartial(20) # Raises EOFError.
  #     f.close
  #
  # With both argument `maxlen` and string argument `out_string` given, returns
  # modified `out_string`:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'
  #     f.readpartial(20, s) # => "First line\nSecond l"
  #     s = 'bar'
  #     f.readpartial(0, s)  # => ""
  #     f.close
  #
  # This method is useful for a stream such as a pipe, a socket, or a tty. It
  # blocks only when no data is immediately available. This means that it blocks
  # only when *all* of the following are true:
  #
  # *   The byte buffer in the stream is empty.
  # *   The content of the stream is empty.
  # *   The stream is not at EOF.
  #
  # When blocked, the method waits for either more data or EOF on the stream:
  #
  # *   If more data is read, the method returns the data.
  # *   If EOF is reached, the method raises EOFError.
  #
  # When not blocked, the method responds immediately:
  #
  # *   Returns data from the buffer if there is any.
  # *   Otherwise returns data from the stream if there is any.
  # *   Otherwise raises EOFError if the stream has reached EOF.
  #
  # Note that this method is similar to sysread. The differences are:
  #
  # *   If the byte buffer is not empty, read from the byte buffer instead of
  #     "sysread for buffered IO (IOError)".
  # *   It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial
  #     meets EWOULDBLOCK and EINTR by read system call, readpartial retries the
  #     system call.
  #
  # The latter means that readpartial is non-blocking-flag insensitive. It blocks
  # on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking
  # mode.
  #
  # Examples:
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc".
  #     r.readpartial(4096)      # => "abc"      ""                ""
  #     r.readpartial(4096)      # (Blocks because buffer and pipe are empty.)
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc"
  #     w.close                  #               ""                "abc" EOF
  #     r.readpartial(4096)      # => "abc"      ""                 EOF
  #     r.readpartial(4096)      # raises EOFError
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << "abc\ndef\n"        #               ""                "abc\ndef\n"
  #     r.gets                   # => "abc\n"    "def\n"           ""
  #     w << "ghi\n"             #               "def\n"           "ghi\n"
  #     r.readpartial(4096)      # => "def\n"    ""                "ghi\n"
  #     r.readpartial(4096)      # => "ghi\n"    ""                ""
  #
  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - reopen(other_io)                 -> self
  #   - reopen(path, mode = 'r', **opts) -> self
  # -->
  # Reassociates the stream with another stream, which may be of a different
  # class. This method may be used to redirect an existing stream to a new
  # destination.
  #
  # With argument `other_io` given, reassociates with that stream:
  #
  #     # Redirect $stdin from a file.
  #     f = File.open('t.txt')
  #     $stdin.reopen(f)
  #     f.close
  #
  #     # Redirect $stdout to a file.
  #     f = File.open('t.tmp', 'w')
  #     $stdout.reopen(f)
  #     f.close
  #
  # With argument `path` given, reassociates with a new stream to that file path:
  #
  #     $stdin.reopen('t.txt')
  #     $stdout.reopen('t.tmp', 'w')
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def reopen: (IO other_IO_or_path) -> IO
            | (String other_IO_or_path, ?String mode_str) -> IO

  # <!--
  #   rdoc-file=io.c
  #   - rewind -> 0
  # -->
  # Repositions the stream to its beginning, setting both the position and the
  # line number to zero; see [Position](rdoc-ref:IO@Position) and [Line
  # Number](rdoc-ref:IO@Line+Number):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #     f.gets     # => "First line\n"
  #     f.tell     # => 12
  #     f.lineno   # => 1
  #     f.rewind   # => 0
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #     f.close
  #
  # Note that this method cannot be used with streams such as pipes, ttys, and
  # sockets.
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - seek(offset, whence = IO::SEEK_SET) -> 0
  # -->
  # Seeks to the position given by integer `offset` (see
  # [Position](rdoc-ref:IO@Position)) and constant `whence`, which is one of:
  #
  # *   `:CUR` or `IO::SEEK_CUR`: Repositions the stream to its current position
  #     plus the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :CUR)  # => 0
  #         f.tell            # => 20
  #         f.seek(-10, :CUR) # => 0
  #         f.tell            # => 10
  #         f.close
  #
  # *   `:END` or `IO::SEEK_END`: Repositions the stream to its end plus the given
  #     `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(0, :END)   # => 0  # Repositions to stream end.
  #         f.tell            # => 52
  #         f.seek(-20, :END) # => 0
  #         f.tell            # => 32
  #         f.seek(-40, :END) # => 0
  #         f.tell            # => 12
  #         f.close
  #
  # *   `:SET` or `IO:SEEK_SET`: Repositions the stream to the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :SET) # => 0
  #         f.tell           # => 20
  #         f.seek(40, :SET) # => 0
  #         f.tell           # => 40
  #         f.close
  #
  # Related: IO#pos=, IO#tell.
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - set_encoding(ext_enc)                   -> self
  #   - set_encoding(ext_enc, int_enc, **enc_opts)  -> self
  #   - set_encoding('ext_enc:int_enc', **enc_opts) -> self
  # -->
  # See [Encodings](rdoc-ref:File@Encodings).
  #
  # Argument `ext_enc`, if given, must be an Encoding object or a String with the
  # encoding name; it is assigned as the encoding for the stream.
  #
  # Argument `int_enc`, if given, must be an Encoding object or a String with the
  # encoding name; it is assigned as the encoding for the internal string.
  #
  # Argument `'ext_enc:int_enc'`, if given, is a string containing two
  # colon-separated encoding names; corresponding Encoding objects are assigned as
  # the external and internal encodings for the stream.
  #
  # If the external encoding of a string is binary/ASCII-8BIT, the internal
  # encoding of the string is set to nil, since no transcoding is needed.
  #
  # Optional keyword arguments `enc_opts` specify [Encoding
  # options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=io.c
  #   - set_encoding_by_bom -> encoding or nil
  # -->
  # If the stream begins with a BOM ([byte order
  # marker](https://en.wikipedia.org/wiki/Byte_order_mark)), consumes the BOM and
  # sets the external encoding accordingly; returns the result encoding if found,
  # or `nil` otherwise:
  #
  #     File.write('t.tmp', "\u{FEFF}abc")
  #     io = File.open('t.tmp', 'rb')
  #     io.set_encoding_by_bom # => #<Encoding:UTF-8>
  #     io.close
  #
  #     File.write('t.tmp', 'abc')
  #     io = File.open('t.tmp', 'rb')
  #     io.set_encoding_by_bom # => nil
  #     io.close
  #
  # Raises an exception if the stream is not binmode or its encoding has already
  # been set.
  #
  def set_encoding_by_bom: () -> Encoding?

  # <!--
  #   rdoc-file=file.c
  #   - ios.stat    -> stat
  # -->
  # Returns status information for *ios* as an object of type File::Stat.
  #
  #     f = File.new("testfile")
  #     s = f.stat
  #     "%o" % s.mode   #=> "100644"
  #     s.blksize       #=> 4096
  #     s.atime         #=> Wed Apr 09 08:53:54 CDT 2003
  #
  def stat: () -> File::Stat

  # <!--
  #   rdoc-file=io.c
  #   - sync -> true or false
  # -->
  # Returns the current sync mode of the stream. When sync mode is true, all
  # output is immediately flushed to the underlying operating system and is not
  # buffered by Ruby internally. See also #fsync.
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #     f.close
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - sync = boolean -> boolean
  # -->
  # Sets the *sync* *mode* for the stream to the given value; returns the given
  # value.
  #
  # Values for the sync mode:
  #
  # *   `true`: All output is immediately flushed to the underlying operating
  #     system and is not buffered internally.
  # *   `false`: Output may be buffered internally.
  #
  # Example;
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #     f.close
  #
  # Related: IO#fsync.
  #
  def sync=: (boolish boolean) -> boolish

  # <!--
  #   rdoc-file=io.c
  #   - sysread(maxlen)             -> string
  #   - sysread(maxlen, out_string) -> string
  # -->
  # Behaves like IO#readpartial, except that it uses low-level system functions.
  #
  # This method should not be used with other stream-reader methods.
  #
  def sysread: (Integer maxlen, String outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - sysseek(offset, whence = IO::SEEK_SET) -> integer
  # -->
  # Behaves like IO#seek, except that it:
  #
  # *   Uses low-level system functions.
  # *   Returns the new position.
  #
  def sysseek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - syswrite(object) -> integer
  # -->
  # Writes the given `object` to self, which must be opened for writing (see
  # Modes); returns the number bytes written. If `object` is not a string is
  # converted via method to_s:
  #
  #     f = File.new('t.tmp', 'w')
  #     f.syswrite('foo') # => 3
  #     f.syswrite(30)    # => 2
  #     f.syswrite(:foo)  # => 3
  #     f.close
  #
  # This methods should not be used with other stream-writer methods.
  #
  def syswrite: (_ToS object) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - tell -> integer
  # -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](rdoc-ref:IO@Position)):
  #
  #     f = File.open('t.txt')
  #     f.tell # => 0
  #     f.gets # => "First line\n"
  #     f.tell # => 12
  #     f.close
  #
  # Related: IO#pos=, IO#seek.
  #
  def tell: () -> Integer

  # <!-- rdoc-file=io.c -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](rdoc-ref:IO@Position)):
  #
  #     f = File.open('t.txt')
  #     f.tell # => 0
  #     f.gets # => "First line\n"
  #     f.tell # => 12
  #     f.close
  #
  # Related: IO#pos=, IO#seek.
  #
  alias pos tell

  # <!--
  #   rdoc-file=io.c
  #   - timeout -> duration or nil
  # -->
  # Get the internal timeout duration or nil if it was not set.
  #
  def timeout: () -> io_timeout

  # The type used for timeouts in `IO`.
  #
  # Technically, this type should be `Time::_Timeout?`. However, in the vast majority of use-cases,
  # people aren't going to pass their own `_Timeout` in, so `Numeric` is returned for ergonomics
  # (eg `io.timeout += 10`).
  type io_timeout = Numeric?

  # <!--
  #   rdoc-file=io.c
  #   - timeout = duration -> duration
  #   - timeout = nil -> nil
  # -->
  # Sets the internal timeout to the specified duration or nil. The timeout
  # applies to all blocking operations where possible.
  #
  # When the operation performs longer than the timeout set, IO::TimeoutError is
  # raised.
  #
  # This affects the following methods (but is not limited to): #gets, #puts,
  # #read, #write, #wait_readable and #wait_writable. This also affects blocking
  # socket operations like Socket#accept and Socket#connect.
  #
  # Some operations like File#open and IO#close are not affected by the timeout. A
  # timeout during a write operation may leave the IO in an inconsistent state,
  # e.g. data was partially written. Generally speaking, a timeout is a last ditch
  # effort to prevent an application from hanging on slow I/O operations, such as
  # those that occur during a slowloris attack.
  #
  def timeout=: (io_timeout duration) -> void

  # <!--
  #   rdoc-file=io.c
  #   - to_io -> self
  # -->
  # Returns `self`.
  #
  def to_io: () -> self

  # <!-- rdoc-file=io.c -->
  # Returns `true` if the stream is associated with a terminal device (tty),
  # `false` otherwise:
  #
  #     f = File.new('t.txt').isatty    #=> false
  #     f.close
  #     f = File.new('/dev/tty').isatty #=> true
  #     f.close
  #
  alias tty? isatty

  # <!--
  #   rdoc-file=io.c
  #   - ungetbyte(integer) -> nil
  #   - ungetbyte(string)  -> nil
  # -->
  # Pushes back ("unshifts") the given data onto the stream's buffer, placing the
  # data so that it is next to be read; returns `nil`. See [Byte
  # IO](rdoc-ref:IO@Byte+IO).
  #
  # Note that:
  #
  # *   Calling the method has no effect with unbuffered reads (such as
  #     IO#sysread).
  # *   Calling #rewind on the stream discards the pushed-back data.
  #
  # When argument `integer` is given, uses only its low-order byte:
  #
  #     File.write('t.tmp', '012')
  #     f = File.open('t.tmp')
  #     f.ungetbyte(0x41)   # => nil
  #     f.read              # => "A012"
  #     f.rewind
  #     f.ungetbyte(0x4243) # => nil
  #     f.read              # => "C012"
  #     f.close
  #
  # When argument `string` is given, uses all bytes:
  #
  #     File.write('t.tmp', '012')
  #     f = File.open('t.tmp')
  #     f.ungetbyte('A')    # => nil
  #     f.read              # => "A012"
  #     f.rewind
  #     f.ungetbyte('BCDE') # => nil
  #     f.read              # => "BCDE012"
  #     f.close
  #
  def ungetbyte: (String | Integer object) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - ungetc(integer) -> nil
  #   - ungetc(string)  -> nil
  # -->
  # Pushes back ("unshifts") the given data onto the stream's buffer, placing the
  # data so that it is next to be read; returns `nil`. See [Character
  # IO](rdoc-ref:IO@Character+IO).
  #
  # Note that:
  #
  # *   Calling the method has no effect with unbuffered reads (such as
  #     IO#sysread).
  # *   Calling #rewind on the stream discards the pushed-back data.
  #
  # When argument `integer` is given, interprets the integer as a character:
  #
  #     File.write('t.tmp', '012')
  #     f = File.open('t.tmp')
  #     f.ungetc(0x41)     # => nil
  #     f.read             # => "A012"
  #     f.rewind
  #     f.ungetc(0x0442)   # => nil
  #     f.getc.ord         # => 1090
  #     f.close
  #
  # When argument `string` is given, uses all characters:
  #
  #     File.write('t.tmp', '012')
  #     f = File.open('t.tmp')
  #     f.ungetc('A')      # => nil
  #     f.read      # => "A012"
  #     f.rewind
  #     f.ungetc("\u0442\u0435\u0441\u0442") # => nil
  #     f.getc.ord      # => 1090
  #     f.getc.ord      # => 1077
  #     f.getc.ord      # => 1089
  #     f.getc.ord      # => 1090
  #     f.close
  #
  def ungetc: (String object) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - write(*objects) -> integer
  # -->
  # Writes each of the given `objects` to `self`, which must be opened for writing
  # (see [Access Modes](rdoc-ref:File@Access+Modes)); returns the total number
  # bytes written; each of `objects` that is not a string is converted via method
  # `to_s`:
  #
  #     $stdout.write('Hello', ', ', 'World!', "\n") # => 14
  #     $stdout.write('foo', :bar, 2, "\n")          # => 8
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  # Related: IO#read.
  #
  def write: (*_ToS string) -> Integer

  # <!--
  #   rdoc-file=io.rb
  #   - ios.write_nonblock(string)   -> integer
  #   - ios.write_nonblock(string [, options])   -> integer
  # -->
  # Writes the given string to *ios* using the write(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # It returns the number of bytes written.
  #
  # write_nonblock just calls the write(2) system call. It causes all errors the
  # write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result
  # may also be smaller than string.length (partial write). The caller should care
  # such errors and partial write.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for
  # retrying write_nonblock.
  #
  #     # Creates a pipe.
  #     r, w = IO.pipe
  #
  #     # write_nonblock writes only 65536 bytes and return 65536.
  #     # (The pipe size is 65536 bytes on this environment.)
  #     s = "a" * 100000
  #     p w.write_nonblock(s)     #=> 65536
  #
  #     # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
  #     p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)
  #
  # If the write buffer is not empty, it is flushed at first.
  #
  # When write_nonblock raises an exception kind of IO::WaitWritable,
  # write_nonblock should not be called until io is writable for avoiding busy
  # loop. This can be done as follows.
  #
  #     begin
  #       result = io.write_nonblock(string)
  #     rescue IO::WaitWritable, Errno::EINTR
  #       IO.select(nil, [io])
  #       retry
  #     end
  #
  # Note that this doesn't guarantee to write all data in string. The length
  # written is reported as result and it should be checked later.
  #
  # On some platforms such as Windows, write_nonblock is not supported according
  # to the kind of the IO object. In such cases, write_nonblock raises
  # `Errno::EBADF`.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # write_nonblock should not raise an IO::WaitWritable exception, but return the
  # symbol `:wait_writable` instead.
  #
  def write_nonblock: (_ToS s, ?exception: true) -> Integer
                    | (_ToS s, exception: false) -> (Integer | :wait_writable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - IO.binread(path, length = nil, offset = 0)    -> string or nil
  # -->
  # Behaves like IO.read, except that the stream is opened in binary mode with
  # ASCII-8BIT encoding.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  def self.binread: (String name, ?Integer length, ?Integer offset) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.binwrite(path, string, offset = 0)    -> integer
  # -->
  # Behaves like IO.write, except that the stream is opened in binary mode with
  # ASCII-8BIT encoding.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  def self.binwrite: (String name, _ToS string, ?Integer offset, ?mode: String mode) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.copy_stream(src, dst, src_length = nil, src_offset = 0) -> integer
  # -->
  # Copies from the given `src` to the given `dst`, returning the number of bytes
  # copied.
  #
  # *   The given `src` must be one of the following:
  #
  #     *   The path to a readable file, from which source data is to be read.
  #     *   An IO-like object, opened for reading and capable of responding to
  #         method `:readpartial` or method `:read`.
  #
  # *   The given `dst` must be one of the following:
  #
  #     *   The path to a writable file, to which data is to be written.
  #     *   An IO-like object, opened for writing and capable of responding to
  #         method `:write`.
  #
  # The examples here use file `t.txt` as source:
  #
  #     File.read('t.txt')
  #     # => "First line\nSecond line\n\nThird line\nFourth line\n"
  #     File.read('t.txt').size # => 47
  #
  # If only arguments `src` and `dst` are given, the entire source stream is
  # copied:
  #
  #     # Paths.
  #     IO.copy_stream('t.txt', 't.tmp')  # => 47
  #
  #     # IOs (recall that a File is also an IO).
  #     src_io = File.open('t.txt', 'r') # => #<File:t.txt>
  #     dst_io = File.open('t.tmp', 'w') # => #<File:t.tmp>
  #     IO.copy_stream(src_io, dst_io)   # => 47
  #     src_io.close
  #     dst_io.close
  #
  # With argument `src_length` a non-negative integer, no more than that many
  # bytes are copied:
  #
  #     IO.copy_stream('t.txt', 't.tmp', 10) # => 10
  #     File.read('t.tmp')                   # => "First line"
  #
  # With argument `src_offset` also given, the source stream is read beginning at
  # that offset:
  #
  #     IO.copy_stream('t.txt', 't.tmp', 11, 11) # => 11
  #     IO.read('t.tmp')                         # => "Second line"
  #
  def self.copy_stream: (String | _Reader | _ReaderPartial src, String | _Writer dst, ?Integer copy_length, ?Integer src_offset) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.popen(env = {}, cmd, mode = 'r', **opts) -> io
  #   - IO.popen(env = {}, cmd, mode = 'r', **opts) {|io| ... } -> object
  # -->
  # Executes the given command `cmd` as a subprocess whose $stdin and $stdout are
  # connected to a new stream `io`.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # If no block is given, returns the new stream, which depending on given `mode`
  # may be open for reading, writing, or both. The stream should be explicitly
  # closed (eventually) to avoid resource leaks.
  #
  # If a block is given, the stream is passed to the block (again, open for
  # reading, writing, or both); when the block exits, the stream is closed, and
  # the block's value is assigned to global variable `$?` and returned.
  #
  # Optional argument `mode` may be any valid IO mode. See [Access
  # Modes](rdoc-ref:File@Access+Modes).
  #
  # Required argument `cmd` determines which of the following occurs:
  #
  # *   The process forks.
  # *   A specified program runs in a shell.
  # *   A specified program runs with specified arguments.
  # *   A specified program runs with specified arguments and a specified `argv0`.
  #
  # Each of these is detailed below.
  #
  # The optional hash argument `env` specifies name/value pairs that are to be
  # added to the environment variables for the subprocess:
  #
  #     IO.popen({'FOO' => 'bar'}, 'ruby', 'r+') do |pipe|
  #       pipe.puts 'puts ENV["FOO"]'
  #       pipe.close_write
  #       pipe.gets
  #     end => "bar\n"
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  # *   Options for Kernel#spawn.
  #
  # **Forked \Process**
  #
  # When argument `cmd` is the 1-character string `'-'`, causes the process to
  # fork:
  #     IO.popen('-') do |pipe|
  #       if pipe
  #         $stderr.puts "In parent, child pid is #{pipe.pid}\n"
  #       else
  #         $stderr.puts "In child, pid is #{$$}\n"
  #       end
  #     end
  #
  # Output:
  #
  #     In parent, child pid is 26253
  #     In child, pid is 26253
  #
  # Note that this is not supported on all platforms.
  #
  # **Shell Subprocess**
  #
  # When argument `cmd` is a single string (but not `'-'`), the program named
  # `cmd` is run as a shell command:
  #
  #     IO.popen('uname') do |pipe|
  #       pipe.readlines
  #     end
  #
  # Output:
  #
  #     ["Linux\n"]
  #
  # Another example:
  #
  #     IO.popen('/bin/sh', 'r+') do |pipe|
  #       pipe.puts('ls')
  #       pipe.close_write
  #       $stderr.puts pipe.readlines.size
  #     end
  #
  # Output:
  #
  #     213
  #
  # **Program Subprocess**
  #
  # When argument `cmd` is an array of strings, the program named `cmd[0]` is run
  # with all elements of `cmd` as its arguments:
  #
  #     IO.popen(['du', '..', '.']) do |pipe|
  #       $stderr.puts pipe.readlines.size
  #     end
  #
  # Output:
  #
  #     1111
  #
  # **Program Subprocess with `argv0`**
  #
  # When argument `cmd` is an array whose first element is a 2-element string
  # array and whose remaining elements (if any) are strings:
  #
  # *   `cmd[0][0]` (the first string in the nested array) is the name of a
  #     program that is run.
  # *   `cmd[0][1]` (the second string in the nested array) is set as the
  #     program's `argv[0]`.
  # *   `cmd[1..-1]` (the strings in the outer array) are the program's arguments.
  #
  # Example (sets `$0` to 'foo'):
  #
  #     IO.popen([['/bin/sh', 'foo'], '-c', 'echo $0']).read # => "foo\n"
  #
  # **Some Special Examples**
  #
  #     # Set IO encoding.
  #     IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|
  #       euc_jp_string = nkf_io.read
  #     }
  #
  #     # Merge standard output and standard error using Kernel#spawn option. See Kernel#spawn.
  #     IO.popen(["ls", "/", :err=>[:child, :out]]) do |io|
  #       ls_result_with_error = io.read
  #     end
  #
  #     # Use mixture of spawn options and IO options.
  #     IO.popen(["ls", "/"], :err=>[:child, :out]) do |io|
  #       ls_result_with_error = io.read
  #     end
  #
  #      f = IO.popen("uname")
  #      p f.readlines
  #      f.close
  #      puts "Parent is #{Process.pid}"
  #      IO.popen("date") {|f| puts f.gets }
  #      IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}
  #      p $?
  #      IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|
  #        f.puts "bar"; f.close_write; puts f.gets
  #      }
  #
  # Output (from last section):
  #
  #     ["Linux\n"]
  #     Parent is 21346
  #     Thu Jan 15 22:41:19 JST 2009
  #     21346 is here, f is #<IO:fd 3>
  #     21352 is here, f is nil
  #     #<Process::Status: pid 21352 exit 0>
  #     <foo>bar;zot;
  #
  # Raises exceptions that IO.pipe and Kernel.spawn raise.
  #
  def self.popen: (string | cmd_array cmd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: Kernel::redirect_fd, ?out: Kernel::redirect_fd, ?err: Kernel::redirect_fd, ?close_others: boolish, ?chdir: String) -> instance
                | (Hash[string, string?] env, string | cmd_array cmd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: Kernel::redirect_fd, ?out: Kernel::redirect_fd, ?err: Kernel::redirect_fd, ?close_others: boolish, ?chdir: String) -> instance
                | [X] (string | cmd_array cmd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: Kernel::redirect_fd, ?out: Kernel::redirect_fd, ?err: Kernel::redirect_fd, ?close_others: boolish, ?chdir: String) { (instance) -> X } -> X
                | [X] (Hash[string, string?] env, string | cmd_array cmd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: Kernel::redirect_fd, ?out: Kernel::redirect_fd, ?err: Kernel::redirect_fd, ?close_others: boolish, ?chdir: String) { (instance) -> X } -> X

  # The command can be given as:
  #
  # * Array of string `["ruby", "-v"]`, or
  # * Array of string with the first element of array `[["ruby", "RUBY"], "-v"]`
  #
  # But RBS cannot define such a type. So this is simply a union of `string` or `[String, String]`.
  #
  type cmd_array = array[string | [String, String]]

  # <!--
  #   rdoc-file=io.c
  #   - IO.foreach(path, sep = $/, **opts) {|line| block }       -> nil
  #   - IO.foreach(path, limit, **opts) {|line| block }          -> nil
  #   - IO.foreach(path, sep, limit, **opts) {|line| block }     -> nil
  #   - IO.foreach(...)                                          -> an_enumerator
  # -->
  # Calls the block with each successive line read from the stream.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # The first argument must be a string that is the path to a file.
  #
  # With only argument `path` given, parses lines from the file at the given
  # `path`, as determined by the default line separator, and calls the block with
  # each successive line:
  #
  #     File.foreach('t.txt') {|line| p line }
  #
  # Output: the same as above.
  #
  # For both forms, command and path, the remaining arguments are the same.
  #
  # With argument `sep` given, parses lines as determined by that line separator
  # (see [Line Separator](rdoc-ref:IO@Line+Separator)):
  #
  #     File.foreach('t.txt', 'li') {|line| p line }
  #
  # Output:
  #
  #     "First li"
  #     "ne\nSecond li"
  #     "ne\n\nThird li"
  #     "ne\nFourth li"
  #     "ne\n"
  #
  # Each paragraph:
  #
  #     File.foreach('t.txt', '') {|paragraph| p paragraph }
  #
  # Output:
  #
  #     "First line\nSecond line\n\n"
  #     "Third line\nFourth line\n"
  #
  # With argument `limit` given, parses lines as determined by the default line
  # separator and the given line-length limit (see [Line
  # Separator](rdoc-ref:IO@Line+Separator) and [Line
  # Limit](rdoc-ref:IO@Line+Limit)):
  #
  #     File.foreach('t.txt', 7) {|line| p line }
  #
  # Output:
  #
  #     "First l"
  #     "ine\n"
  #     "Second "
  #     "line\n"
  #     "\n"
  #     "Third l"
  #     "ine\n"
  #     "Fourth l"
  #     "line\n"
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  # *   [Line Options](rdoc-ref:IO@Line+IO).
  #
  # Returns an Enumerator if no block is given.
  #
  def self.foreach: (string | _ToPath path, ?String sep, ?Integer limit, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?chomp: boolish) { (String line) -> void } -> nil
                  | (string | _ToPath path, ?String sep, ?Integer limit, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?chomp: boolish) -> ::Enumerator[String, nil]

  # <!--
  #   rdoc-file=io.c
  #   - IO.pipe(**opts) -> [read_io, write_io]
  #   - IO.pipe(enc, **opts) -> [read_io, write_io]
  #   - IO.pipe(ext_enc, int_enc, **opts) -> [read_io, write_io]
  #   - IO.pipe(**opts) {|read_io, write_io| ...} -> object
  #   - IO.pipe(enc, **opts) {|read_io, write_io| ...} -> object
  #   - IO.pipe(ext_enc, int_enc, **opts) {|read_io, write_io| ...} -> object
  # -->
  # Creates a pair of pipe endpoints, `read_io` and `write_io`, connected to each
  # other.
  #
  # If argument `enc_string` is given, it must be a string containing one of:
  #
  # *   The name of the encoding to be used as the external encoding.
  # *   The colon-separated names of two encodings to be used as the external and
  #     internal encodings.
  #
  # If argument `int_enc` is given, it must be an Encoding object or encoding name
  # string that specifies the internal encoding to be used; if argument `ext_enc`
  # is also given, it must be an Encoding object or encoding name string that
  # specifies the external encoding to be used.
  #
  # The string read from `read_io` is tagged with the external encoding; if an
  # internal encoding is also specified, the string is converted to, and tagged
  # with, that encoding.
  #
  # If any encoding is specified, optional hash arguments specify the conversion
  # option.
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding Options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  # With no block given, returns the two endpoints in an array:
  #
  #     IO.pipe # => [#<IO:fd 4>, #<IO:fd 5>]
  #
  # With a block given, calls the block with the two endpoints; closes both
  # endpoints and returns the value of the block:
  #
  #     IO.pipe {|read_io, write_io| p read_io; p write_io }
  #
  # Output:
  #
  #     #<IO:fd 6>
  #     #<IO:fd 7>
  #
  # Not available on all platforms.
  #
  # In the example below, the two processes close the ends of the pipe that they
  # are not using. This is not just a cosmetic nicety. The read end of a pipe will
  # not generate an end of file condition if there are any writers with the pipe
  # still open. In the case of the parent process, the `rd.read` will never return
  # if it does not first issue a `wr.close`:
  #
  #     rd, wr = IO.pipe
  #
  #     if fork
  #       wr.close
  #       puts "Parent got: <#{rd.read}>"
  #       rd.close
  #       Process.wait
  #     else
  #       rd.close
  #       puts 'Sending message to parent'
  #       wr.write "Hi Dad"
  #       wr.close
  #     end
  #
  # *produces:*
  #
  #     Sending message to parent
  #     Parent got: <Hi Dad>
  #
  def self.pipe: (?String | Encoding | nil ext_or_ext_int_enc, ?String | Encoding | nil int_enc, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?chomp: boolish) -> [IO, IO]
               | [X] (?String | Encoding | nil ext_or_ext_int_enc, ?String | Encoding | nil int_enc, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?chomp: boolish) { (IO read_io, IO write_io) -> X } -> X

  # <!--
  #   rdoc-file=io.c
  #   - IO.read(path, length = nil, offset = 0, **opts)    -> string or nil
  # -->
  # Opens the stream, reads and returns some or all of its content, and closes the
  # stream; returns `nil` if no bytes were read.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # The first argument must be a string that is the path to a file.
  #
  # With only argument `path` given, reads in text mode and returns the entire
  # content of the file at the given path:
  #
  #     IO.read('t.txt')
  #     # => "First line\nSecond line\n\nThird line\nFourth line\n"
  #
  # On Windows, text mode can terminate reading and leave bytes in the file unread
  # when encountering certain special bytes. Consider using IO.binread if all
  # bytes in the file should be read.
  #
  # With argument `length`, returns `length` bytes if available:
  #
  #     IO.read('t.txt', 7) # => "First l"
  #     IO.read('t.txt', 700)
  #     # => "First line\r\nSecond line\r\n\r\nFourth line\r\nFifth line\r\n"
  #
  # With arguments `length` and `offset`, returns `length` bytes if available,
  # beginning at the given `offset`:
  #
  #     IO.read('t.txt', 10, 2)   # => "rst line\nS"
  #     IO.read('t.txt', 10, 200) # => nil
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def self.read: (String name, ?Integer length, ?Integer offset, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.readlines(path, sep = $/, **opts)     -> array
  #   - IO.readlines(path, limit, **opts)      -> array
  #   - IO.readlines(path, sep, limit, **opts) -> array
  # -->
  # Returns an array of all lines read from the stream.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # The first argument must be a string that is the path to a file.
  #
  # With only argument `path` given, parses lines from the file at the given
  # `path`, as determined by the default line separator, and returns those lines
  # in an array:
  #
  #     IO.readlines('t.txt')
  #     # => ["First line\n", "Second line\n", "\n", "Third line\n", "Fourth line\n"]
  #
  # With argument `sep` given, parses lines as determined by that line separator
  # (see [Line Separator](rdoc-ref:IO@Line+Separator)):
  #
  #     # Ordinary separator.
  #     IO.readlines('t.txt', 'li')
  #     # =>["First li", "ne\nSecond li", "ne\n\nThird li", "ne\nFourth li", "ne\n"]
  #     # Get-paragraphs separator.
  #     IO.readlines('t.txt', '')
  #     # => ["First line\nSecond line\n\n", "Third line\nFourth line\n"]
  #     # Get-all separator.
  #     IO.readlines('t.txt', nil)
  #     # => ["First line\nSecond line\n\nThird line\nFourth line\n"]
  #
  # With argument `limit` given, parses lines as determined by the default line
  # separator and the given line-length limit (see [Line
  # Separator](rdoc-ref:IO@Line+Separator) and [Line
  # Limit](rdoc-ref:IO@Line+Limit):
  #
  #     IO.readlines('t.txt', 7)
  #     # => ["First l", "ine\n", "Second ", "line\n", "\n", "Third l", "ine\n", "Fourth ", "line\n"]
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  # *   [Line Options](rdoc-ref:IO@Line+IO).
  #
  def self.readlines: (String | _ToPath name, ?String sep, ?Integer limit, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String, ?chomp: boolish) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_ios, write_ios = [], error_ios = [], timeout = nil) -> array or nil
  # -->
  # Invokes system call [select(2)](https://linux.die.net/man/2/select), which
  # monitors multiple file descriptors, waiting until one or more of the file
  # descriptors becomes ready for some class of I/O operation.
  #
  # Not implemented on all platforms.
  #
  # Each of the arguments `read_ios`, `write_ios`, and `error_ios` is an array of
  # IO objects.
  #
  # Argument `timeout` is a numeric value (such as integer or float) timeout
  # interval in seconds.
  #
  # The method monitors the IO objects given in all three arrays, waiting for some
  # to be ready; returns a 3-element array whose elements are:
  #
  # *   An array of the objects in `read_ios` that are ready for reading.
  # *   An array of the objects in `write_ios` that are ready for writing.
  # *   An array of the objects in `error_ios` have pending exceptions.
  #
  # If no object becomes ready within the given `timeout`, `nil` is returned.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after non-blocking methods such
  # as #read_nonblock, #write_nonblock, etc.  The methods raise an exception which
  # is extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how
  # the caller should wait with IO.select.  If IO::WaitReadable is raised, the
  # caller should wait for reading.  If IO::WaitWritable is raised, the caller
  # should wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of non-blocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of non-blocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process; see
  # [select(2)](https://linux.die.net/man/2/select)
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # Example:
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # Output:
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self.select: [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array) -> [ Array[X], Array[Y], Array[Z] ]
                 | [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array, Time::_Timeout? timeout) -> [ Array[X], Array[Y], Array[Z] ]?

  # <!--
  #   rdoc-file=io.c
  #   - IO.sysopen(path, mode = 'r', perm = 0666) -> integer
  # -->
  # Opens the file at the given path with the given mode and permissions; returns
  # the integer file descriptor.
  #
  # If the file is to be readable, it must exist; if the file is to be writable
  # and does not exist, it is created with the given permissions:
  #
  #     File.write('t.tmp', '')  # => 0
  #     IO.sysopen('t.tmp')      # => 8
  #     IO.sysopen('t.tmp', 'w') # => 9
  #
  def self.sysopen: (String path, ?String mode, ?String perm) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.try_convert(object) -> new_io or nil
  # -->
  # Attempts to convert `object` into an IO object via method `to_io`; returns the
  # new IO object if successful, or `nil` otherwise:
  #
  #     IO.try_convert(STDOUT)   # => #<IO:<STDOUT>>
  #     IO.try_convert(ARGF)     # => #<IO:<STDIN>>
  #     IO.try_convert('STDOUT') # => nil
  #
  def self.try_convert: (_ToIO obj) -> IO
                      | (untyped obj) -> IO?

  # <!--
  #   rdoc-file=io.c
  #   - IO.write(path, data, offset = 0, **opts)    -> integer
  # -->
  # Opens the stream, writes the given `data` to it, and closes the stream;
  # returns the number of bytes written.
  #
  # When called from class IO (but not subclasses of IO), this method has
  # potential security vulnerabilities if called with untrusted input; see
  # [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # The first argument must be a string that is the path to a file.
  #
  # With only argument `path` given, writes the given `data` to the file at that
  # path:
  #
  #     IO.write('t.tmp', 'abc')    # => 3
  #     File.read('t.tmp')          # => "abc"
  #
  # If `offset` is zero (the default), the file is overwritten:
  #
  #     IO.write('t.tmp', 'A')      # => 1
  #     File.read('t.tmp')          # => "A"
  #
  # If `offset` in within the file content, the file is partly overwritten:
  #
  #     IO.write('t.tmp', 'abcdef') # => 3
  #     File.read('t.tmp')          # => "abcdef"
  #     # Offset within content.
  #     IO.write('t.tmp', '012', 2) # => 3
  #     File.read('t.tmp')          # => "ab012f"
  #
  # If `offset` is outside the file content, the file is padded with null
  # characters `"\u0000"`:
  #
  #     IO.write('t.tmp', 'xyz', 10) # => 3
  #     File.read('t.tmp')           # => "ab012f\u0000\u0000\u0000\u0000xyz"
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def self.write: (String path, _ToS data, ?Integer offset, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.for_fd(fd, mode = 'r', **opts) -> io
  # -->
  # Synonym for IO.new.
  #
  alias self.for_fd self.new

  # <!--
  #   rdoc-file=io.c
  #   - IO.open(fd, mode = 'r', **opts)             -> io
  #   - IO.open(fd, mode = 'r', **opts) {|io| ... } -> object
  # -->
  # Creates a new IO object, via IO.new with the given arguments.
  #
  # With no block given, returns the IO object.
  #
  # With a block given, calls the block with the IO object and returns the block's
  # value.
  #
  def self.open: (int fd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String) -> instance
               | [X] (int fd, ?string | int mode, ?path: string?, ?external_encoding: String | Encoding | nil, ?internal_encoding: String | Encoding | nil, ?encoding: String | Encoding | nil, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?mode: String) { (instance) -> X } -> X

  # <!-- rdoc-file=io.c -->
  # Calls the block with each remaining line read from the stream; returns `self`.
  # Does nothing if already at end-of-stream; See [Line IO](rdoc-ref:IO@Line+IO).
  #
  # With no arguments given, reads lines as determined by line separator `$/`:
  #
  #     f = File.new('t.txt')
  #     f.each_line {|line| p line }
  #     f.each_line {|line| fail 'Cannot happen' }
  #     f.close
  #
  # Output:
  #
  #     "First line\n"
  #     "Second line\n"
  #     "\n"
  #     "Fourth line\n"
  #     "Fifth line\n"
  #
  # With only string argument `sep` given, reads lines as determined by line
  # separator `sep`; see [Line Separator](rdoc-ref:IO@Line+Separator):
  #
  #     f = File.new('t.txt')
  #     f.each_line('li') {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First li"
  #     "ne\nSecond li"
  #     "ne\n\nFourth li"
  #     "ne\nFifth li"
  #     "ne\n"
  #
  # The two special values for `sep` are honored:
  #
  #     f = File.new('t.txt')
  #     # Get all into one string.
  #     f.each_line(nil) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First line\nSecond line\n\nFourth line\nFifth line\n"
  #
  #     f.rewind
  #     # Get paragraphs (up to two line separators).
  #     f.each_line('') {|line| p line }
  #
  # Output:
  #
  #     "First line\nSecond line\n\n"
  #     "Fourth line\nFifth line\n"
  #
  # With only integer argument `limit` given, limits the number of bytes in each
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     f = File.new('t.txt')
  #     f.each_line(8) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First li"
  #     "ne\n"
  #     "Second l"
  #     "ine\n"
  #     "\n"
  #     "Fourth l"
  #     "ine\n"
  #     "Fifth li"
  #     "ne\n"
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     f = File.new('t.txt')
  #     f.each_line(chomp: true) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First line"
  #     "Second line"
  #     ""
  #     "Fourth line"
  #     "Fifth line"
  #
  # Returns an Enumerator if no block is given.
  #
  def each_line: (?string sep, ?int limit, ?chomp: boolish) { (String line) -> void } -> self
               | (?string sep, ?int limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - each_line(sep = $/, chomp: false) {|line| ... }   -> self
  #   - each_line(limit, chomp: false) {|line| ... }      -> self
  #   - each_line(sep, limit, chomp: false) {|line| ... } -> self
  #   - each_line                                   -> enumerator
  # -->
  # Calls the block with each remaining line read from the stream; returns `self`.
  # Does nothing if already at end-of-stream; See [Line IO](rdoc-ref:IO@Line+IO).
  #
  # With no arguments given, reads lines as determined by line separator `$/`:
  #
  #     f = File.new('t.txt')
  #     f.each_line {|line| p line }
  #     f.each_line {|line| fail 'Cannot happen' }
  #     f.close
  #
  # Output:
  #
  #     "First line\n"
  #     "Second line\n"
  #     "\n"
  #     "Fourth line\n"
  #     "Fifth line\n"
  #
  # With only string argument `sep` given, reads lines as determined by line
  # separator `sep`; see [Line Separator](rdoc-ref:IO@Line+Separator):
  #
  #     f = File.new('t.txt')
  #     f.each_line('li') {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First li"
  #     "ne\nSecond li"
  #     "ne\n\nFourth li"
  #     "ne\nFifth li"
  #     "ne\n"
  #
  # The two special values for `sep` are honored:
  #
  #     f = File.new('t.txt')
  #     # Get all into one string.
  #     f.each_line(nil) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First line\nSecond line\n\nFourth line\nFifth line\n"
  #
  #     f.rewind
  #     # Get paragraphs (up to two line separators).
  #     f.each_line('') {|line| p line }
  #
  # Output:
  #
  #     "First line\nSecond line\n\n"
  #     "Fourth line\nFifth line\n"
  #
  # With only integer argument `limit` given, limits the number of bytes in each
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     f = File.new('t.txt')
  #     f.each_line(8) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First li"
  #     "ne\n"
  #     "Second l"
  #     "ine\n"
  #     "\n"
  #     "Fourth l"
  #     "ine\n"
  #     "Fifth li"
  #     "ne\n"
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     f = File.new('t.txt')
  #     f.each_line(chomp: true) {|line| p line }
  #     f.close
  #
  # Output:
  #
  #     "First line"
  #     "Second line"
  #     ""
  #     "Fourth line"
  #     "Fifth line"
  #
  # Returns an Enumerator if no block is given.
  #
  alias each each_line

  # <!-- rdoc-file=io.c -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](rdoc-ref:IO@Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #     f.close
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](rdoc-ref:File@Access+Modes).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  alias eof? eof

  # <!-- rdoc-file=io.c -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #     f.close
  #
  alias to_i fileno
end

IO::APPEND: Integer

IO::BINARY: Integer

IO::CREAT: Integer

IO::DIRECT: Integer

IO::DSYNC: Integer

IO::EXCL: Integer

IO::FNM_CASEFOLD: Integer

IO::FNM_DOTMATCH: Integer

IO::FNM_EXTGLOB: Integer

IO::FNM_NOESCAPE: Integer

IO::FNM_PATHNAME: Integer

IO::FNM_SHORTNAME: Integer

IO::FNM_SYSCASE: Integer

IO::LOCK_EX: Integer

IO::LOCK_NB: Integer

IO::LOCK_SH: Integer

IO::LOCK_UN: Integer

IO::NOATIME: Integer

IO::NOCTTY: Integer

IO::NOFOLLOW: Integer

IO::NONBLOCK: Integer

IO::NULL: String

IO::RDONLY: Integer

IO::RDWR: Integer

IO::RSYNC: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the current position
#
IO::SEEK_CUR: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next location containing data
#
IO::SEEK_DATA: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the end
#
IO::SEEK_END: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next hole
#
IO::SEEK_HOLE: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the beginning
#
IO::SEEK_SET: Integer

IO::SHARE_DELETE: Integer

IO::SYNC: Integer

IO::TMPFILE: Integer

IO::TRUNC: Integer

IO::WRONLY: Integer

# <!-- rdoc-file=io.c -->
# Readable event mask for IO#wait.
#
IO::READABLE: Integer

# <!-- rdoc-file=io.c -->
# Writable event mask for IO#wait.
#
IO::WRITABLE: Integer

# <!-- rdoc-file=io.c -->
# Priority event mask for IO#wait.
#
IO::PRIORITY: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EAGAIN. see IO.select.
#
class IO::EAGAINWaitReadable < Errno::EAGAIN
  include IO::WaitReadable
end

IO::EAGAINWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EAGAIN. see IO.select.
#
class IO::EAGAINWaitWritable < Errno::EAGAIN
  include IO::WaitWritable
end

IO::EAGAINWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitReadable < Errno::EINPROGRESS
  include IO::WaitReadable
end

IO::EINPROGRESSWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitWritable < Errno::EINPROGRESS
  include IO::WaitWritable
end

IO::EINPROGRESSWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading. see IO.select.
#
module IO::WaitReadable
end

# <!-- rdoc-file=io.c -->
# exception to wait for writing. see IO.select.
#
module IO::WaitWritable
end
# <!-- rdoc-file=numeric.c -->
# Numeric is the class from which all higher-level numeric classes should
# inherit.
#
# Numeric allows instantiation of heap-allocated objects. Other core numeric
# classes such as Integer are implemented as immediates, which means that each
# Integer is a single immutable object which is always passed by value.
#
#     a = 1
#     1.object_id == a.object_id   #=> true
#
# There can only ever be one instance of the integer `1`, for example. Ruby
# ensures this by preventing instantiation. If duplication is attempted, the
# same instance is returned.
#
#     Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
#     1.dup                            #=> 1
#     1.object_id == 1.dup.object_id   #=> true
#
# For this reason, Numeric should be used when defining other numeric classes.
#
# Classes which inherit from Numeric must implement `coerce`, which returns a
# two-member Array containing an object that has been coerced into an instance
# of the new class and `self` (see #coerce).
#
# Inheriting classes should also implement arithmetic operator methods (`+`,
# `-`, `*` and `/`) and the `<=>` operator (see Comparable). These methods may
# rely on `coerce` to ensure interoperability with instances of other numeric
# classes.
#
#     class Tally < Numeric
#       def initialize(string)
#         @string = string
#       end
#
#       def to_s
#         @string
#       end
#
#       def to_i
#         @string.size
#       end
#
#       def coerce(other)
#         [self.class.new('|' * other.to_i), self]
#       end
#
#       def <=>(other)
#         to_i <=> other.to_i
#       end
#
#       def +(other)
#         self.class.new('|' * (to_i + other.to_i))
#       end
#
#       def -(other)
#         self.class.new('|' * (to_i - other.to_i))
#       end
#
#       def *(other)
#         self.class.new('|' * (to_i * other.to_i))
#       end
#
#       def /(other)
#         self.class.new('|' * (to_i / other.to_i))
#       end
#     end
#
#     tally = Tally.new('||')
#     puts tally * 2            #=> "||||"
#     puts tally > 1            #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class Numeric:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class Numeric provides methods for:
#
# *   [Querying](rdoc-ref:Numeric@Querying)
# *   [Comparing](rdoc-ref:Numeric@Comparing)
# *   [Converting](rdoc-ref:Numeric@Converting)
# *   [Other](rdoc-ref:Numeric@Other)
#
# ### Querying
#
# *   #finite?: Returns true unless `self` is infinite or not a number.
# *   #infinite?: Returns -1, `nil` or +1, depending on whether `self` is
#     `-Infinity<tt>, finite, or <tt>+Infinity`.
# *   #integer?: Returns whether `self` is an integer.
# *   #negative?: Returns whether `self` is negative.
# *   #nonzero?: Returns whether `self` is not zero.
# *   #positive?: Returns whether `self` is positive.
# *   #real?: Returns whether `self` is a real value.
# *   #zero?: Returns whether `self` is zero.
#
# ### Comparing
#
# *   #<=>: Returns:
#
#     *   -1 if  `self` is less than the given value.
#     *   0 if `self` is equal to the given value.
#     *   1 if `self` is greater than the given value.
#     *   `nil` if `self` and the given value are not comparable.
#
# *   #eql?: Returns whether `self` and the given value have the same value and
#     type.
#
# ### Converting
#
# *   #% (aliased as #modulo): Returns the remainder of `self` divided by the
#     given value.
# *   #-@: Returns the value of `self`, negated.
# *   #abs (aliased as #magnitude): Returns the absolute value of `self`.
# *   #abs2: Returns the square of `self`.
# *   #angle (aliased as #arg and #phase): Returns 0 if `self` is positive,
#     Math::PI otherwise.
# *   #ceil: Returns the smallest number greater than or equal to `self`, to a
#     given precision.
# *   #coerce: Returns array `[coerced_self, coerced_other]` for the given other
#     value.
# *   #conj (aliased as #conjugate): Returns the complex conjugate of `self`.
# *   #denominator: Returns the denominator (always positive) of the Rational
#     representation of `self`.
# *   #div: Returns the value of `self` divided by the given value and converted
#     to an integer.
# *   #divmod: Returns array `[quotient, modulus]` resulting from dividing
#     `self` the given divisor.
# *   #fdiv: Returns the Float result of dividing `self` by the given divisor.
# *   #floor: Returns the largest number less than or equal to `self`, to a
#     given precision.
# *   #i: Returns the Complex object `Complex(0, self)`. the given value.
# *   #imaginary (aliased as #imag): Returns the imaginary part of the `self`.
# *   #numerator: Returns the numerator of the Rational representation of
#     `self`; has the same sign as `self`.
# *   #polar: Returns the array `[self.abs, self.arg]`.
# *   #quo: Returns the value of `self` divided by the given value.
# *   #real: Returns the real part of `self`.
# *   #rect (aliased as #rectangular): Returns the array `[self, 0]`.
# *   #remainder: Returns `self-arg*(self/arg).truncate` for the given `arg`.
# *   #round: Returns the value of `self` rounded to the nearest value for the
#     given a precision.
# *   #to_c: Returns the Complex representation of `self`.
# *   #to_int: Returns the Integer representation of `self`, truncating if
#     necessary.
# *   #truncate: Returns `self` truncated (toward zero) to a given precision.
#
# ### Other
#
# *   #clone: Returns `self`; does not allow freezing.
# *   #dup (aliased as #+@): Returns `self`.
# *   #step: Invokes the given block with the sequence of specified numbers.
#
class Numeric
  include Comparable

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_numeric
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     r % n
  #     r-n*(r/n).floor
  #     r.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  def %: (Numeric) -> Numeric

  # Performs addition: the class of the resulting object depends on the class of
  # `numeric`.
  #
  def +: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - +self -> self
  # -->
  # Returns `self`.
  #
  def +@: () -> Numeric

  # Performs subtraction: the class of the resulting object depends on the class
  # of `numeric`.
  #
  def -: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - -self -> numeric
  # -->
  # Unary Minus---Returns the receiver, negated.
  #
  def -@: () -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other -> zero or nil
  # -->
  # Returns zero if `self` is the same as `other`, `nil` otherwise.
  #
  # No subclass in the Ruby Core or Standard Library uses this implementation.
  #
  def <=>: (Numeric other) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - abs -> numeric
  # -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - abs2 -> real
  # -->
  # Returns the square of `self`.
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns zero if `self` is positive, Math::PI otherwise.
  #
  def angle: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - arg -> 0 or Math::PI
  # -->
  # Returns zero if `self` is positive, Math::PI otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> float or integer
  # -->
  # Returns the smallest float or integer that is greater than or equal to `self`,
  # as specified by the given `ndigits`, which must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  #
  # Equivalent to `self.to_f.ceil(ndigits)`.
  #
  # Related: #floor, Float#ceil.
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing two numeric elements, formed from the two
  # operands `self` and `other`, of a common compatible type.
  #
  # Of the Core and Standard Library classes, Integer, Rational, and Complex use
  # this implementation.
  #
  # Examples:
  #
  #     i = 2                    # => 2
  #     i.coerce(3)              # => [3, 2]
  #     i.coerce(3.0)            # => [3.0, 2.0]
  #     i.coerce(Rational(1, 2)) # => [0.5, 2.0]
  #     i.coerce(Complex(3, 4))  # Raises RangeError.
  #
  #     r = Rational(5, 2)       # => (5/2)
  #     r.coerce(2)              # => [(2/1), (5/2)]
  #     r.coerce(2.0)            # => [2.0, 2.5]
  #     r.coerce(Rational(2, 3)) # => [(2/3), (5/2)]
  #     r.coerce(Complex(3, 4))  # => [(3+4i), ((5/2)+0i)]
  #
  #     c = Complex(2, 3)        # => (2+3i)
  #     c.coerce(2)              # => [(2+0i), (2+3i)]
  #     c.coerce(2.0)            # => [(2.0+0i), (2+3i)]
  #     c.coerce(Rational(1, 2)) # => [((1/2)+0i), (2+3i)]
  #     c.coerce(Complex(3, 4))  # => [(3+4i), (2+3i)]
  #
  # Raises an exception if any type conversion fails.
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.rb
  #   - conj()
  # -->
  #
  def conj: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - conj -> self
  # -->
  # Returns `self`.
  #
  def conjugate: () -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - num.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - div(other) -> integer
  # -->
  # Returns the quotient `self/other` as an integer (via `floor`), using method
  # `/` in the derived class of `self`. (Numeric itself does not define method
  # `/`.)
  #
  # Of the Core and Standard Library classes, Only Float and Rational use this
  # implementation.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor                  # Quotient
  #     r = self % other                        # Remainder
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # Examples:
  #
  #     Rational(11, 1).divmod(4)               # => [2, (3/1)]
  #     Rational(11, 1).divmod(-4)              # => [-3, (-1/1)]
  #     Rational(-11, 1).divmod(4)              # => [-3, (1/1)]
  #     Rational(-11, 1).divmod(-4)             # => [2, (-3/1)]
  #
  #     Rational(12, 1).divmod(4)               # => [3, (0/1)]
  #     Rational(12, 1).divmod(-4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(-4)             # => [3, (0/1)]
  #
  #     Rational(13, 1).divmod(4.0)             # => [3, 1.0]
  #     Rational(13, 1).divmod(Rational(4, 11)) # => [35, (3/11)]
  #
  def divmod: (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `self` and `other` are the same type and have equal values.
  #
  # Of the Core and Standard Library classes, only Integer, Rational, and Complex
  # use this implementation.
  #
  # Examples:
  #
  #     1.eql?(1)              # => true
  #     1.eql?(1.0)            # => false
  #     1.eql?(Rational(1, 1)) # => false
  #     1.eql?(Complex(1, 0))  # => false
  #
  # Method `eql?` is different from `==` in that `eql?` requires matching types,
  # while `==` does not.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(other) -> float
  # -->
  # Returns the quotient `self/other` as a float, using method `/` in the derived
  # class of `self`. (Numeric itself does not define method `/`.)
  #
  # Of the Core and Standard Library classes, only BigDecimal uses this
  # implementation.
  #
  def fdiv: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - finite? -> true or false
  # -->
  # Returns `true` if `self` is a finite number, `false` otherwise.
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> float or integer
  # -->
  # Returns the largest float or integer that is less than or equal to `self`, as
  # specified by the given `ndigits`, which must be an [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  #
  # Equivalent to `self.to_f.floor(ndigits)`.
  #
  # Related: #ceil, Float#floor.
  #
  def floor: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - i -> complex
  # -->
  # Returns `Complex(0, self)`:
  #
  #     2.i              # => (0+2i)
  #     -2.i             # => (0-2i)
  #     2.0.i            # => (0+2.0i)
  #     Rational(1, 2).i # => (0+(1/2)*i)
  #     Complex(3, 4).i  # Raises NoMethodError.
  #
  def i: () -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - imag()
  # -->
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - imag -> 0
  # -->
  # Returns zero.
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - infinite? -> -1, 1, or nil
  # -->
  # Returns `nil`, -1, or 1 depending on whether `self` is finite, `-Infinity`, or
  # `+Infinity`.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=numeric.rb
  #   - integer? -> true or false
  # -->
  # Returns `true` if `self` is an Integer.
  #
  #     1.0.integer? # => false
  #     1.integer?   # => true
  #
  def integer?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     r % n
  #     r-n*(r/n).floor
  #     r.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  def modulo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - negative? -> true or false
  # -->
  # Returns `true` if `self` is less than 0, `false` otherwise.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - nonzero?  ->  self or nil
  # -->
  # Returns +self+ if +self+ is not a zero value, +nil+ otherwise;
  #     uses method <tt>zero?</tt> for the evaluation.
  #
  #     The returned +self+ allows the method to be chained:
  #
  #       a = %w[z Bb bB bb BB a aA Aa AA A]
  #       a.sort {|a, b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #       # => ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  #     Of the Core and Standard Library classes,
  #     Integer, Float, Rational, and Complex use this implementation.
  #
  # Related: #zero?
  #
  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - num.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  def numerator: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns zero if `self` is positive, Math::PI otherwise.
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - polar -> array
  # -->
  # Returns array `[self.abs, self.arg]`.
  #
  def polar: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - positive? -> true or false
  # -->
  # Returns `true` if `self` is greater than 0, `false` otherwise.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - num.quo(int_or_rat)   ->  rat
  #   - num.quo(flo)          ->  flo
  # -->
  # Returns the most exact division (rational for integers, float for floats).
  #
  def quo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - real -> self
  # -->
  # Returns `self`.
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - real? -> true or false
  # -->
  # Returns `true` if `self` is a real number (i.e. not Complex).
  #
  def real?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns array `[self, 0]`.
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - rect -> array
  # -->
  # Returns array `[self, 0]`.
  #
  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Of the Core and Standard Library classes, only Float and Rational use this
  # implementation.
  #
  # Examples:
  #
  #     11.0.remainder(4)              # => 3.0
  #     11.0.remainder(-4)             # => 3.0
  #     -11.0.remainder(4)             # => -3.0
  #     -11.0.remainder(-4)            # => -3.0
  #
  #     12.0.remainder(4)              # => 0.0
  #     12.0.remainder(-4)             # => 0.0
  #     -12.0.remainder(4)             # => -0.0
  #     -12.0.remainder(-4)            # => -0.0
  #
  #     13.0.remainder(4.0)            # => 1.0
  #     13.0.remainder(Rational(4, 1)) # => 1.0
  #
  #     Rational(13, 1).remainder(4)   # => (1/1)
  #     Rational(13, 1).remainder(-4)  # => (1/1)
  #     Rational(-13, 1).remainder(4)  # => (-1/1)
  #     Rational(-13, 1).remainder(-4) # => (-1/1)
  #
  def remainder: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(digits = 0) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `digits`
  # decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#round.
  #
  def round: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - step(to = nil, by = 1) {|n| ... } ->  self
  #   - step(to = nil, by = 1)            ->  enumerator
  #   - step(to = nil, by: 1) {|n| ... }  ->  self
  #   - step(to = nil, by: 1)             ->  enumerator
  #   - step(by: 1, to: ) {|n| ... }      ->  self
  #   - step(by: 1, to: )                 ->  enumerator
  #   - step(by: , to: nil) {|n| ... }    ->  self
  #   - step(by: , to: nil)               ->  enumerator
  # -->
  # Generates a sequence of numbers; with a block given, traverses the sequence.
  #
  # Of the Core and Standard Library classes, Integer, Float, and Rational use
  # this implementation.
  #
  # A quick example:
  #
  #     squares = []
  #     1.step(by: 2, to: 10) {|i| squares.push(i*i) }
  #     squares # => [1, 9, 25, 49, 81]
  #
  # The generated sequence:
  #
  # *   Begins with `self`.
  # *   Continues at intervals of `by` (which may not be zero).
  # *   Ends with the last number that is within or equal to `to`; that is, less
  #     than or equal to `to` if `by` is positive, greater than or equal to `to`
  #     if `by` is negative. If `to` is `nil`, the sequence is of infinite length.
  #
  # If a block is given, calls the block with each number in the sequence; returns
  # `self`. If no block is given, returns an Enumerator::ArithmeticSequence.
  #
  # **Keyword Arguments**
  #
  # With keyword arguments `by` and `to`, their values (or defaults) determine the
  # step and limit:
  #
  #     # Both keywords given.
  #     squares = []
  #     4.step(by: 2, to: 10) {|i| squares.push(i*i) }    # => 4
  #     squares # => [16, 36, 64, 100]
  #     cubes = []
  #     3.step(by: -1.5, to: -3) {|i| cubes.push(i*i*i) } # => 3
  #     cubes   # => [27.0, 3.375, 0.0, -3.375, -27.0]
  #     squares = []
  #     1.2.step(by: 0.2, to: 2.0) {|f| squares.push(f*f) }
  #     squares # => [1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #     squares = []
  #     Rational(6/5).step(by: 0.2, to: 2.0) {|r| squares.push(r*r) }
  #     squares # => [1.0, 1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #     # Only keyword to given.
  #     squares = []
  #     4.step(to: 10) {|i| squares.push(i*i) }           # => 4
  #     squares # => [16, 25, 36, 49, 64, 81, 100]
  #     # Only by given.
  #
  #     # Only keyword by given
  #     squares = []
  #     4.step(by:2) {|i| squares.push(i*i); break if i > 10 }
  #     squares # => [16, 36, 64, 100, 144]
  #
  #     # No block given.
  #     e = 3.step(by: -1.5, to: -3) # => (3.step(by: -1.5, to: -3))
  #     e.class                      # => Enumerator::ArithmeticSequence
  #
  # **Positional Arguments**
  #
  # With optional positional arguments `to` and `by`, their values (or defaults)
  # determine the step and limit:
  #
  #     squares = []
  #     4.step(10, 2) {|i| squares.push(i*i) }    # => 4
  #     squares # => [16, 36, 64, 100]
  #     squares = []
  #     4.step(10) {|i| squares.push(i*i) }
  #     squares # => [16, 25, 36, 49, 64, 81, 100]
  #     squares = []
  #     4.step {|i| squares.push(i*i); break if i > 10 }  # => nil
  #     squares # => [16, 25, 36, 49, 64, 81, 100, 121]
  #
  # **Implementation Notes**
  #
  # If all the arguments are integers, the loop operates using an integer counter.
  #
  # If any of the arguments are floating point numbers, all are converted to
  # floats, and the loop is executed *floor(n + n*Float::EPSILON) + 1* times,
  # where *n = (limit - self)/step*.
  #
  def step: (?Numeric limit, ?Numeric step) { (Numeric) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Numeric, self]
          | (?by: Numeric, ?to: Numeric) { (Numeric) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Numeric, self]

  # <!--
  #   rdoc-file=complex.c
  #   - to_c -> complex
  # -->
  # Returns `self` as a Complex object.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_int -> integer
  # -->
  # Returns `self` as an integer; converts using method `to_i` in the derived
  # class.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  # Examples:
  #
  #     Rational(1, 2).to_int # => 0
  #     Rational(2, 1).to_int # => 2
  #     Complex(2, 0).to_int  # => 2
  #     Complex(2, 1).to_int  # Raises RangeError (non-zero imaginary part)
  #
  def to_int: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(digits = 0) -> integer or float
  # -->
  # Returns `self` truncated (toward zero) to a precision of `digits` decimal
  # digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#truncate.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - zero? -> true or false
  # -->
  # Returns `true` if `zero` has a zero value, `false` otherwise.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - clone(freeze: true) -> self
  # -->
  # Returns `self`.
  #
  # Raises an exception if the value for `freeze` is neither `true` nor `nil`.
  #
  # Related: Numeric#dup.
  #
  def clone: (?freeze: true?) -> self
end
# <!-- rdoc-file=re.c -->
# A [regular expression](https://en.wikipedia.org/wiki/Regular_expression) (also
# called a *regexp*) is a *match pattern* (also simply called a *pattern*).
#
# A common notation for a regexp uses enclosing slash characters:
#
#     /foo/
#
# A regexp may be applied to a *target string*; The part of the string (if any)
# that matches the pattern is called a *match*, and may be said *to match*:
#
#     re = /red/
#     re.match?('redirect') # => true   # Match at beginning of target.
#     re.match?('bored')    # => true   # Match at end of target.
#     re.match?('credit')   # => true   # Match within target.
#     re.match?('foo')      # => false  # No match.
#
# ## Regexp Uses
#
# A regexp may be used:
#
# *   To extract substrings based on a given pattern:
#
#         re = /foo/              # => /foo/
#         re.match('food')        # => #<MatchData "foo">
#         re.match('good')        # => nil
#
#     See sections [Method match](rdoc-ref:Regexp@Method+match) and [Operator
#     =~](rdoc-ref:Regexp@Operator+-3D~).
#
# *   To determine whether a string matches a given pattern:
#
#         re.match?('food') # => true
#         re.match?('good') # => false
#
#     See section [Method match?](rdoc-ref:Regexp@Method+match-3F).
#
# *   As an argument for calls to certain methods in other classes and modules;
#     most such methods accept an argument that may be either a string or the
#     (much more powerful) regexp.
#
#     See [Regexp Methods](rdoc-ref:regexp/methods.rdoc).
#
# ## Regexp Objects
#
# A regexp object has:
#
# *   A source; see [Sources](rdoc-ref:Regexp@Sources).
#
# *   Several modes; see [Modes](rdoc-ref:Regexp@Modes).
#
# *   A timeout; see [Timeouts](rdoc-ref:Regexp@Timeouts).
#
# *   An encoding; see [Encodings](rdoc-ref:Regexp@Encodings).
#
# ## Creating a Regexp
#
# A regular expression may be created with:
#
# *   A regexp literal using slash characters (see [Regexp
#     Literals](rdoc-ref:syntax/literals.rdoc@Regexp+Literals)):
#
#         # This is a very common usage.
#         /foo/ # => /foo/
#
# *   A `%r` regexp literal (see [%r: Regexp
#     Literals](rdoc-ref:syntax/literals.rdoc@25r-3A+Regexp+Literals)):
#
#         # Same delimiter character at beginning and end;
#         # useful for avoiding escaping characters
#         %r/name\/value pair/ # => /name\/value pair/
#         %r:name/value pair:  # => /name\/value pair/
#         %r|name/value pair|  # => /name\/value pair/
#
#         # Certain "paired" characters can be delimiters.
#         %r[foo] # => /foo/
#         %r{foo} # => /foo/
#         %r(foo) # => /foo/
#         %r<foo> # => /foo/
#
# *   Method Regexp.new.
#
# ## Method `match`
#
# Each of the methods Regexp#match, String#match, and Symbol#match returns a
# MatchData object if a match was found, `nil` otherwise; each also sets [global
# variables](rdoc-ref:Regexp@Global+Variables):
#
#     'food'.match(/foo/) # => #<MatchData "foo">
#     'food'.match(/bar/) # => nil
#
# ## Operator `=~`
#
# Each of the operators Regexp#=~, String#=~, and Symbol#=~ returns an integer
# offset if a match was found, `nil` otherwise; each also sets [global
# variables](rdoc-ref:Regexp@Global+Variables):
#
#     /bar/ =~ 'foo bar' # => 4
#     'foo bar' =~ /bar/ # => 4
#     /baz/ =~ 'foo bar' # => nil
#
# ## Method `match?`
#
# Each of the methods Regexp#match?, String#match?, and Symbol#match? returns
# `true` if a match was found, `false` otherwise; none sets [global
# variables](rdoc-ref:Regexp@Global+Variables):
#
#     'food'.match?(/foo/) # => true
#     'food'.match?(/bar/) # => false
#
# ## Global Variables
#
# Certain regexp-oriented methods assign values to global variables:
#
# *   `#match`: see [Method match](rdoc-ref:Regexp@Method+match).
# *   `#=~`: see [Operator =~](rdoc-ref:Regexp@Operator+-3D~).
#
# The affected global variables are:
#
# *   `$~`: Returns a MatchData object, or `nil`.
# *   `$&`: Returns the matched part of the string, or `nil`.
# *   `$``: Returns the part of the string to the left of the match, or `nil`.
# *   `$'`: Returns the part of the string to the right of the match, or `nil`.
# *   `$+`: Returns the last group matched, or `nil`.
# *   `$1`, `$2`, etc.: Returns the first, second, etc., matched group, or
#     `nil`. Note that `$0` is quite different; it returns the name of the
#     currently executing program.
#
# Examples:
#
#     # Matched string, but no matched groups.
#     'foo bar bar baz'.match('bar')
#     $~ # => #<MatchData "bar">
#     $& # => "bar"
#     $` # => "foo "
#     $' # => " bar baz"
#     $+ # => nil
#     $1 # => nil
#
#     # Matched groups.
#     /s(\w{2}).*(c)/.match('haystack')
#     $~ # => #<MatchData "stac" 1:"ta" 2:"c">
#     $& # => "stac"
#     $` # => "hay"
#     $' # => "k"
#     $+ # => "c"
#     $1 # => "ta"
#     $2 # => "c"
#     $3 # => nil
#
#     # No match.
#     'foo'.match('bar')
#     $~ # => nil
#     $& # => nil
#     $` # => nil
#     $' # => nil
#     $+ # => nil
#     $1 # => nil
#
# Note that Regexp#match?, String#match?, and Symbol#match? do not set global
# variables.
#
# ## Sources
#
# As seen above, the simplest regexp uses a literal expression as its source:
#
#     re = /foo/              # => /foo/
#     re.match('food')        # => #<MatchData "foo">
#     re.match('good')        # => nil
#
# A rich collection of available *subexpressions* gives the regexp great power
# and flexibility:
#
# *   [Special characters](rdoc-ref:Regexp@Special+Characters)
# *   [Source literals](rdoc-ref:Regexp@Source+Literals)
# *   [Character classes](rdoc-ref:Regexp@Character+Classes)
# *   [Shorthand character classes](rdoc-ref:Regexp@Shorthand+Character+Classes)
# *   [Anchors](rdoc-ref:Regexp@Anchors)
# *   [Alternation](rdoc-ref:Regexp@Alternation)
# *   [Quantifiers](rdoc-ref:Regexp@Quantifiers)
# *   [Groups and captures](rdoc-ref:Regexp@Groups+and+Captures)
# *   [Unicode](rdoc-ref:Regexp@Unicode)
# *   [POSIX Bracket Expressions](rdoc-ref:Regexp@POSIX+Bracket+Expressions)
# *   [Comments](rdoc-ref:Regexp@Comments)
#
# ### Special Characters
#
# Regexp special characters, called *metacharacters*, have special meanings in
# certain contexts; depending on the context, these are sometimes
# metacharacters:
#
#     . ? - + * ^ \ | $ ( ) [ ] { }
#
# To match a metacharacter literally, backslash-escape it:
#
#     # Matches one or more 'o' characters.
#     /o+/.match('foo')  # => #<MatchData "oo">
#     # Would match 'o+'.
#     /o\+/.match('foo') # => nil
#
# To match a backslash literally, backslash-escape it:
#
#     /\./.match('\.')  # => #<MatchData ".">
#     /\\./.match('\.') # => #<MatchData "\\.">
#
# Method Regexp.escape returns an escaped string:
#
#     Regexp.escape('.?-+*^\|$()[]{}')
#     # => "\\.\\?\\-\\+\\*\\^\\\\\\|\\$\\(\\)\\[\\]\\{\\}"
#
# ### Source Literals
#
# The source literal largely behaves like a double-quoted string; see
# [Double-Quoted String
# Literals](rdoc-ref:syntax/literals.rdoc@Double-Quoted+String+Literals).
#
# In particular, a source literal may contain interpolated expressions:
#
#     s = 'foo'         # => "foo"
#     /#{s}/            # => /foo/
#     /#{s.capitalize}/ # => /Foo/
#     /#{2 + 2}/        # => /4/
#
# There are differences between an ordinary string literal and a source literal;
# see [Shorthand Character
# Classes](rdoc-ref:Regexp@Shorthand+Character+Classes).
#
# *   `\s` in an ordinary string literal is equivalent to a space character; in
#     a source literal, it's shorthand for matching a whitespace character.
# *   In an ordinary string literal, these are (needlessly) escaped characters;
#     in a source literal, they are shorthands for various matching characters:
#
#         \w \W \d \D \h \H \S \R
#
# ### Character Classes
#
# A *character class* is delimited by square brackets; it specifies that certain
# characters match at a given point in the target string:
#
#     # This character class will match any vowel.
#     re = /B[aeiou]rd/
#     re.match('Bird') # => #<MatchData "Bird">
#     re.match('Bard') # => #<MatchData "Bard">
#     re.match('Byrd') # => nil
#
# A character class may contain hyphen characters to specify ranges of
# characters:
#
#     # These regexps have the same effect.
#     /[abcdef]/.match('foo') # => #<MatchData "f">
#     /[a-f]/.match('foo')    # => #<MatchData "f">
#     /[a-cd-f]/.match('foo') # => #<MatchData "f">
#
# When the first character of a character class is a caret (`^`), the sense of
# the class is inverted: it matches any character *except* those specified.
#
#     /[^a-eg-z]/.match('f') # => #<MatchData "f">
#
# A character class may contain another character class. By itself this isn't
# useful because `[a-z[0-9]]` describes the same set as `[a-z0-9]`.
#
# However, character classes also support the `&&` operator, which performs set
# intersection on its arguments. The two can be combined as follows:
#
#     /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))
#
# This is equivalent to:
#
#     /[abh-w]/
#
# ### Shorthand Character Classes
#
# Each of the following metacharacters serves as a shorthand for a character
# class:
#
# *   `/./`: Matches any character except a newline:
#
#         /./.match('foo') # => #<MatchData "f">
#         /./.match("\n")  # => nil
#
# *   `/./m`: Matches any character, including a newline; see [Multiline
#     Mode](rdoc-ref:Regexp@Multiline+Mode):
#
#         /./m.match("\n") # => #<MatchData "\n">
#
# *   `/\w/`: Matches a word character: equivalent to `[a-zA-Z0-9_]`:
#
#         /\w/.match(' foo') # => #<MatchData "f">
#         /\w/.match(' _')   # => #<MatchData "_">
#         /\w/.match(' ')    # => nil
#
# *   `/\W/`: Matches a non-word character: equivalent to `[^a-zA-Z0-9_]`:
#
#         /\W/.match(' ') # => #<MatchData " ">
#         /\W/.match('_') # => nil
#
# *   `/\d/`: Matches a digit character: equivalent to `[0-9]`:
#
#         /\d/.match('THX1138') # => #<MatchData "1">
#         /\d/.match('foo')     # => nil
#
# *   `/\D/`: Matches a non-digit character: equivalent to `[^0-9]`:
#
#         /\D/.match('123Jump!') # => #<MatchData "J">
#         /\D/.match('123')      # => nil
#
# *   `/\h/`: Matches a hexdigit character: equivalent to `[0-9a-fA-F]`:
#
#         /\h/.match('xyz fedcba9876543210') # => #<MatchData "f">
#         /\h/.match('xyz')                  # => nil
#
# *   `/\H/`: Matches a non-hexdigit character: equivalent to `[^0-9a-fA-F]`:
#
#         /\H/.match('fedcba9876543210xyz') # => #<MatchData "x">
#         /\H/.match('fedcba9876543210')    # => nil
#
# *   `/\s/`: Matches a whitespace character: equivalent to `/[ \t\r\n\f\v]/`:
#
#         /\s/.match('foo bar') # => #<MatchData " ">
#         /\s/.match('foo')     # => nil
#
# *   `/\S/`: Matches a non-whitespace character: equivalent to `/[^
#     \t\r\n\f\v]/`:
#
#         /\S/.match(" \t\r\n\f\v foo") # => #<MatchData "f">
#         /\S/.match(" \t\r\n\f\v")     # => nil
#
# *   `/\R/`: Matches a linebreak, platform-independently:
#
#         /\R/.match("\r")     # => #<MatchData "\r">     # Carriage return (CR)
#         /\R/.match("\n")     # => #<MatchData "\n">     # Newline (LF)
#         /\R/.match("\f")     # => #<MatchData "\f">     # Formfeed (FF)
#         /\R/.match("\v")     # => #<MatchData "\v">     # Vertical tab (VT)
#         /\R/.match("\r\n")   # => #<MatchData "\r\n">   # CRLF
#         /\R/.match("\u0085") # => #<MatchData "\u0085"> # Next line (NEL)
#         /\R/.match("\u2028") # => #<MatchData "\u2028"> # Line separator (LSEP)
#         /\R/.match("\u2029") # => #<MatchData "\u2029"> # Paragraph separator (PSEP)
#
# ### Anchors
#
# An anchor is a metasequence that matches a zero-width position between
# characters in the target string.
#
# For a subexpression with no anchor, matching may begin anywhere in the target
# string:
#
#     /real/.match('surrealist') # => #<MatchData "real">
#
# For a subexpression with an anchor, matching must begin at the matched anchor.
#
# #### Boundary Anchors
#
# Each of these anchors matches a boundary:
#
# *   `^`: Matches the beginning of a line:
#
#         /^bar/.match("foo\nbar") # => #<MatchData "bar">
#         /^ar/.match("foo\nbar")  # => nil
#
# *   `$`: Matches the end of a line:
#
#         /bar$/.match("foo\nbar") # => #<MatchData "bar">
#         /ba$/.match("foo\nbar")  # => nil
#
# *   `\A`: Matches the beginning of the string:
#
#         /\Afoo/.match('foo bar')  # => #<MatchData "foo">
#         /\Afoo/.match(' foo bar') # => nil
#
# *   `\Z`: Matches the end of the string; if string ends with a single newline,
#     it matches just before the ending newline:
#
#         /foo\Z/.match('bar foo')     # => #<MatchData "foo">
#         /foo\Z/.match('foo bar')     # => nil
#         /foo\Z/.match("bar foo\n")   # => #<MatchData "foo">
#         /foo\Z/.match("bar foo\n\n") # => nil
#
# *   `\z`: Matches the end of the string:
#
#         /foo\z/.match('bar foo')   # => #<MatchData "foo">
#         /foo\z/.match('foo bar')   # => nil
#         /foo\z/.match("bar foo\n") # => nil
#
# *   `\b`: Matches word boundary when not inside brackets; matches backspace
#     (`"0x08"`) when inside brackets:
#
#         /foo\b/.match('foo bar') # => #<MatchData "foo">
#         /foo\b/.match('foobar')  # => nil
#
# *   `\B`: Matches non-word boundary:
#
#         /foo\B/.match('foobar')  # => #<MatchData "foo">
#         /foo\B/.match('foo bar') # => nil
#
# *   `\G`: Matches first matching position:
#
#     In methods like String#gsub and String#scan, it changes on each iteration.
#     It initially matches the beginning of subject, and in each following
#     iteration it matches where the last match finished.
#
#         "    a b c".gsub(/ /, '_')   # => "____a_b_c"
#         "    a b c".gsub(/\G /, '_') # => "____a b c"
#
#     In methods like Regexp#match and String#match that take an optional
#     offset, it matches where the search begins.
#
#         "hello, world".match(/,/, 3)   # => #<MatchData ",">
#         "hello, world".match(/\G,/, 3) # => nil
#
# #### Lookaround Anchors
#
# Lookahead anchors:
#
# *   `(?=*pat*)`: Positive lookahead assertion: ensures that the following
#     characters match *pat*, but doesn't include those characters in the
#     matched substring.
#
# *   `(?!*pat*)`: Negative lookahead assertion: ensures that the following
#     characters *do not* match *pat*, but doesn't include those characters in
#     the matched substring.
#
# Lookbehind anchors:
#
# *   `(?<=*pat*)`: Positive lookbehind assertion: ensures that the preceding
#     characters match *pat*, but doesn't include those characters in the
#     matched substring.
#
# *   `(?<!*pat*)`: Negative lookbehind assertion: ensures that the preceding
#     characters do not match *pat*, but doesn't include those characters in the
#     matched substring.
#
# The pattern below uses positive lookahead and positive lookbehind to match
# text appearing in **...** tags without including the tags in the match:
#
#     /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favors the <b>bold</b>.")
#     # => #<MatchData "bold">
#
# #### Match-Reset Anchor
#
# *   `\K`: Match reset: the matched content preceding `\K` in the regexp is
#     excluded from the result. For example, the following two regexps are
#     almost equivalent:
#
#         /ab\Kc/.match('abc')    # => #<MatchData "c">
#         /(?<=ab)c/.match('abc') # => #<MatchData "c">
#
#     These match same string and `$&` equals `'c'`, while the matched position
#     is different.
#
#     As are the following two regexps:
#
#         /(a)\K(b)\Kc/
#         /(?<=(?<=(a))(b))c/
#
# ### Alternation
#
# The vertical bar metacharacter (`|`) may be used within parentheses to express
# alternation: two or more subexpressions any of which may match the target
# string.
#
# Two alternatives:
#
#     re = /(a|b)/
#     re.match('foo') # => nil
#     re.match('bar') # => #<MatchData "b" 1:"b">
#
# Four alternatives:
#
#     re = /(a|b|c|d)/
#     re.match('shazam') # => #<MatchData "a" 1:"a">
#     re.match('cold')   # => #<MatchData "c" 1:"c">
#
# Each alternative is a subexpression, and may be composed of other
# subexpressions:
#
#     re = /([a-c]|[x-z])/
#     re.match('bar') # => #<MatchData "b" 1:"b">
#     re.match('ooz') # => #<MatchData "z" 1:"z">
#
# Method Regexp.union provides a convenient way to construct a regexp with
# alternatives.
#
# ### Quantifiers
#
# A simple regexp matches one character:
#
#     /\w/.match('Hello')  # => #<MatchData "H">
#
# An added *quantifier* specifies how many matches are required or allowed:
#
# *   `*` - Matches zero or more times:
#
#         /\w*/.match('')
#         # => #<MatchData "">
#         /\w*/.match('x')
#         # => #<MatchData "x">
#         /\w*/.match('xyz')
#         # => #<MatchData "yz">
#
# *   `+` - Matches one or more times:
#
#         /\w+/.match('')    # => nil
#         /\w+/.match('x')   # => #<MatchData "x">
#         /\w+/.match('xyz') # => #<MatchData "xyz">
#
# *   `?` - Matches zero or one times:
#
#         /\w?/.match('')    # => #<MatchData "">
#         /\w?/.match('x')   # => #<MatchData "x">
#         /\w?/.match('xyz') # => #<MatchData "x">
#
# *   `{`*n*`}` - Matches exactly *n* times:
#
#         /\w{2}/.match('')    # => nil
#         /\w{2}/.match('x')   # => nil
#         /\w{2}/.match('xyz') # => #<MatchData "xy">
#
# *   `{`*min*`,}` - Matches *min* or more times:
#
#         /\w{2,}/.match('')    # => nil
#         /\w{2,}/.match('x')   # => nil
#         /\w{2,}/.match('xy')  # => #<MatchData "xy">
#         /\w{2,}/.match('xyz') # => #<MatchData "xyz">
#
# *   `{,`*max*`}` - Matches *max* or fewer times:
#
#         /\w{,2}/.match('')    # => #<MatchData "">
#         /\w{,2}/.match('x')   # => #<MatchData "x">
#         /\w{,2}/.match('xyz') # => #<MatchData "xy">
#
# *   `{`*min*`,`*max*`}` - Matches at least *min* times and at most *max*
#     times:
#
#         /\w{1,2}/.match('')    # => nil
#         /\w{1,2}/.match('x')   # => #<MatchData "x">
#         /\w{1,2}/.match('xyz') # => #<MatchData "xy">
#
# #### Greedy, Lazy, or Possessive Matching
#
# Quantifier matching may be greedy, lazy, or possessive:
#
# *   In *greedy* matching, as many occurrences as possible are matched while
#     still allowing the overall match to succeed. Greedy quantifiers: `*`, `+`,
#     `?`, `{min, max}` and its variants.
# *   In *lazy* matching, the minimum number of occurrences are matched. Lazy
#     quantifiers: `*?`, `+?`, `??`, `{min, max}?` and its variants.
# *   In *possessive* matching, once a match is found, there is no backtracking;
#     that match is retained, even if it jeopardises the overall match.
#     Possessive quantifiers: `*+`, `++`, `?+`. Note that `{min, max}` and its
#     variants do *not* support possessive matching.
#
# More:
#
# *   About greedy and lazy matching, see [Choosing Minimal or Maximal
#     Repetition](https://doc.lagout.org/programmation/Regular%20Expressions/Reg
#     ular%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Progr
#     amming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%20201
#     2-09-06%5D.pdf#tutorial-backtrack).
# *   About possessive matching, see [Eliminate Needless
#     Backtracking](https://doc.lagout.org/programmation/Regular%20Expressions/R
#     egular%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Pro
#     gramming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%202
#     012-09-06%5D.pdf#tutorial-backtrack).
#
# ### Groups and Captures
#
# A simple regexp has (at most) one match:
#
#     re = /\d\d\d\d-\d\d-\d\d/
#     re.match('1943-02-04')      # => #<MatchData "1943-02-04">
#     re.match('1943-02-04').size # => 1
#     re.match('foo')             # => nil
#
# Adding one or more pairs of parentheses, `(*subexpression*)`, defines
# *groups*, which may result in multiple matched substrings, called *captures*:
#
#     re = /(\d\d\d\d)-(\d\d)-(\d\d)/
#     re.match('1943-02-04')      # => #<MatchData "1943-02-04" 1:"1943" 2:"02" 3:"04">
#     re.match('1943-02-04').size # => 4
#
# The first capture is the entire matched string; the other captures are the
# matched substrings from the groups.
#
# A group may have a [quantifier](rdoc-ref:Regexp@Quantifiers):
#
#     re = /July 4(th)?/
#     re.match('July 4')   # => #<MatchData "July 4" 1:nil>
#     re.match('July 4th') # => #<MatchData "July 4th" 1:"th">
#
#     re = /(foo)*/
#     re.match('')       # => #<MatchData "" 1:nil>
#     re.match('foo')    # => #<MatchData "foo" 1:"foo">
#     re.match('foofoo') # => #<MatchData "foofoo" 1:"foo">
#
#     re = /(foo)+/
#     re.match('')       # => nil
#     re.match('foo')    # => #<MatchData "foo" 1:"foo">
#     re.match('foofoo') # => #<MatchData "foofoo" 1:"foo">
#
# The returned MatchData object gives access to the matched substrings:
#
#     re = /(\d\d\d\d)-(\d\d)-(\d\d)/
#     md = re.match('1943-02-04')
#     # => #<MatchData "1943-02-04" 1:"1943" 2:"02" 3:"04">
#     md[0] # => "1943-02-04"
#     md[1] # => "1943"
#     md[2] # => "02"
#     md[3] # => "04"
#
# #### Non-Capturing Groups
#
# A group may be made non-capturing; it is still a group (and, for example, can
# have a quantifier), but its matching substring is not included among the
# captures.
#
# A non-capturing group begins with `?:` (inside the parentheses):
#
#     # Don't capture the year.
#     re = /(?:\d\d\d\d)-(\d\d)-(\d\d)/
#     md = re.match('1943-02-04') # => #<MatchData "1943-02-04" 1:"02" 2:"04">
#
# #### Backreferences
#
# A group match may also be referenced within the regexp itself; such a
# reference is called a `backreference`:
#
#     /[csh](..) [csh]\1 in/.match('The cat sat in the hat')
#     # => #<MatchData "cat sat in" 1:"at">
#
# This table shows how each subexpression in the regexp above matches a
# substring in the target string:
#
#     | Subexpression in Regexp   | Matching Substring in Target String |
#     |---------------------------|-------------------------------------|
#     |       First '[csh]'       |            Character 'c'            |
#     |          '(..)'           |        First substring 'at'         |
#     |      First space ' '      |      First space character ' '      |
#     |       Second '[csh]'      |            Character 's'            |
#     | '\1' (backreference 'at') |        Second substring 'at'        |
#     |           ' in'           |            Substring ' in'          |
#
# A regexp may contain any number of groups:
#
# *   For a large number of groups:
#
#     *   The ordinary `\*n`* notation applies only for *n* in range (1..9).
#     *   The `MatchData[*n*]` notation applies for any non-negative *n*.
#
# *   `\0` is a special backreference, referring to the entire matched string;
#     it may not be used within the regexp itself, but may be used outside it
#     (for example, in a substitution method call):
#
#         'The cat sat in the hat'.gsub(/[csh]at/, '\0s')
#         # => "The cats sats in the hats"
#
# #### Named Captures
#
# As seen above, a capture can be referred to by its number. A capture can also
# have a name, prefixed as `?<*name*>` or `?'*name*'`, and the name (symbolized)
# may be used as an index in `MatchData[]`:
#
#     md = /\$(?<dollars>\d+)\.(?'cents'\d+)/.match("$3.67")
#     # => #<MatchData "$3.67" dollars:"3" cents:"67">
#     md[:dollars]  # => "3"
#     md[:cents]    # => "67"
#     # The capture numbers are still valid.
#     md[2]         # => "67"
#
# When a regexp contains a named capture, there are no unnamed captures:
#
#     /\$(?<dollars>\d+)\.(\d+)/.match("$3.67")
#     # => #<MatchData "$3.67" dollars:"3">
#
# A named group may be backreferenced as `\k<*name*>`:
#
#     /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
#     # => #<MatchData "ototo" vowel:"o">
#
# When (and only when) a regexp contains named capture groups and appears before
# the `=~` operator, the captured substrings are assigned to local variables
# with corresponding names:
#
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ '$3.67'
#     dollars # => "3"
#     cents   # => "67"
#
# Method Regexp#named_captures returns a hash of the capture names and
# substrings; method Regexp#names returns an array of the capture names.
#
# #### Atomic Grouping
#
# A group may be made *atomic* with `(?>`*subexpression*`)`.
#
# This causes the subexpression to be matched independently of the rest of the
# expression, so that the matched substring becomes fixed for the remainder of
# the match, unless the entire subexpression must be abandoned and subsequently
# revisited.
#
# In this way *subexpression* is treated as a non-divisible whole. Atomic
# grouping is typically used to optimise patterns to prevent needless
# backtracking .
#
# Example (without atomic grouping):
#
#     /".*"/.match('"Quote"') # => #<MatchData "\"Quote\"">
#
# Analysis:
#
# 1.  The leading subexpression `"` in the pattern matches the first character
#     `"` in the target string.
# 2.  The next subexpression `.*` matches the next substring `Quote` (including
#     the trailing double-quote).
# 3.  Now there is nothing left in the target string to match the trailing
#     subexpression `"` in the pattern; this would cause the overall match to
#     fail.
# 4.  The matched substring is backtracked by one position: `Quote`.
# 5.  The final subexpression `"` now matches the final substring `"`, and the
#     overall match succeeds.
#
# If subexpression `.*` is grouped atomically, the backtracking is disabled, and
# the overall match fails:
#
#     /"(?>.*)"/.match('"Quote"') # => nil
#
# Atomic grouping can affect performance; see [Atomic
# Group](https://www.regular-expressions.info/atomic.html).
#
# #### Subexpression Calls
#
# As seen above, a backreference number (`\*n`*) or name (`\k<*name*>`) gives
# access to a captured *substring*; the corresponding regexp *subexpression* may
# also be accessed, via the number (`\\g*n`*) or name (`\g<*name*>`):
#
#     /\A(?<paren>\(\g<paren>*\))*\z/.match('(())')
#     # ^1
#     #      ^2
#     #           ^3
#     #                 ^4
#     #      ^5
#     #           ^6
#     #                      ^7
#     #                       ^8
#     #                       ^9
#     #                           ^10
#
# The pattern:
#
# 1.  Matches at the beginning of the string, i.e. before the first character.
# 2.  Enters a named group `paren`.
# 3.  Matches the first character in the string, `'('`.
# 4.  Calls the `paren` group again, i.e. recurses back to the  second step.
# 5.  Re-enters the `paren` group.
# 6.  Matches the second character in the string, `'('`.
# 7.  Attempts to call `paren` a third time, but fails because doing so would
#     prevent an overall successful match.
# 8.  Matches the third character in the string, `')'`; marks the end of the
#     second recursive call
# 9.  Matches the fourth character in the string, `')'`.
# 10. Matches the end of the string.
#
# See [Subexpression
# calls](https://learnbyexample.github.io/Ruby_Regexp/groupings-and-backreferenc
# es.html?highlight=subexpression#subexpression-calls).
#
# #### Conditionals
#
# The conditional construct takes the form `(?(*cond*)*yes*|*no*)`, where:
#
# *   *cond* may be a capture number or name.
# *   The match to be applied is *yes* if *cond* is captured; otherwise the
#     match to be applied is *no*.
# *   If not needed, `|*no`* may be omitted.
#
# Examples:
#
#     re = /\A(foo)?(?(1)(T)|(F))\z/
#     re.match('fooT') # => #<MatchData "fooT" 1:"foo" 2:"T" 3:nil>
#     re.match('F')    # => #<MatchData "F" 1:nil 2:nil 3:"F">
#     re.match('fooF') # => nil
#     re.match('T')    # => nil
#
#     re = /\A(?<xyzzy>foo)?(?(<xyzzy>)(T)|(F))\z/
#     re.match('fooT') # => #<MatchData "fooT" xyzzy:"foo">
#     re.match('F')    # => #<MatchData "F" xyzzy:nil>
#     re.match('fooF') # => nil
#     re.match('T')    # => nil
#
# #### Absence Operator
#
# The absence operator is a special group that matches anything which does *not*
# match the contained subexpressions.
#
#     /(?~real)/.match('surrealist') # => #<MatchData "surrea">
#     /(?~real)ist/.match('surrealist') # => #<MatchData "ealist">
#     /sur(?~real)ist/.match('surrealist') # => nil
#
# ### Unicode
#
# #### Unicode Properties
#
# The `/\p{*property_name*}/` construct (with lowercase `p`) matches characters
# using a Unicode property name, much like a character class; property `Alpha`
# specifies alphabetic characters:
#
#     /\p{Alpha}/.match('a') # => #<MatchData "a">
#     /\p{Alpha}/.match('1') # => nil
#
# A property can be inverted by prefixing the name with a caret character (`^`):
#
#     /\p{^Alpha}/.match('1') # => #<MatchData "1">
#     /\p{^Alpha}/.match('a') # => nil
#
# Or by using `\P` (uppercase `P`):
#
#     /\P{Alpha}/.match('1') # => #<MatchData "1">
#     /\P{Alpha}/.match('a') # => nil
#
# See [Unicode Properties](rdoc-ref:regexp/unicode_properties.rdoc) for regexps
# based on the numerous properties.
#
# Some commonly-used properties correspond to POSIX bracket expressions:
#
# *   `/\p{Alnum}/`: Alphabetic and numeric character
# *   `/\p{Alpha}/`: Alphabetic character
# *   `/\p{Blank}/`: Space or tab
# *   `/\p{Cntrl}/`: Control character
# *   `/\p{Digit}/`: Digit characters, and similar)
# *   `/\p{Lower}/`: Lowercase alphabetical character
# *   `/\p{Print}/`: Like `\p{Graph}`, but includes the space character
# *   `/\p{Punct}/`: Punctuation character
# *   `/\p{Space}/`: Whitespace character (`[:blank:]`, newline, carriage
#     return, etc.)
# *   `/\p{Upper}/`: Uppercase alphabetical
# *   `/\p{XDigit}/`: Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
#
# These are also commonly used:
#
# *   `/\p{Emoji}/`: Unicode emoji.
# *   `/\p{Graph}/`: Non-blank character (excludes spaces, control characters,
#     and similar).
# *   `/\p{Word}/`: A member in one of these Unicode character categories (see
#     below) or having one of these Unicode properties:
#
#     *   Unicode categories:
#         *   `Mark` (`M`).
#         *   `Decimal Number` (`Nd`)
#         *   `Connector Punctuation` (`Pc`).
#
#     *   Unicode properties:
#         *   `Alpha`
#         *   `Join_Control`
#
# *   `/\p{ASCII}/`: A character in the ASCII character set.
# *   `/\p{Any}/`: Any Unicode character (including unassigned characters).
# *   `/\p{Assigned}/`: An assigned character.
#
# #### Unicode Character Categories
#
# A Unicode character category name:
#
# *   May be either its full name or its abbreviated name.
# *   Is case-insensitive.
# *   Treats a space, a hyphen, and an underscore as equivalent.
#
# Examples:
#
#     /\p{lu}/                # => /\p{lu}/
#     /\p{LU}/                # => /\p{LU}/
#     /\p{Uppercase Letter}/  # => /\p{Uppercase Letter}/
#     /\p{Uppercase_Letter}/  # => /\p{Uppercase_Letter}/
#     /\p{UPPERCASE-LETTER}/  # => /\p{UPPERCASE-LETTER}/
#
# Below are the Unicode character category abbreviations and names. Enumerations
# of characters in each category are at the links.
#
# Letters:
#
# *   `L`, `Letter`: `LC`, `Lm`, or `Lo`.
# *   `LC`, `Cased_Letter`: `Ll`, `Lt`, or `Lu`.
# *   [Lu, Lowercase_Letter](https://www.compart.com/en/unicode/category/Ll).
# *   [Lu, Modifier_Letter](https://www.compart.com/en/unicode/category/Lm).
# *   [Lu, Other_Letter](https://www.compart.com/en/unicode/category/Lo).
# *   [Lu, Titlecase_Letter](https://www.compart.com/en/unicode/category/Lt).
# *   [Lu, Uppercase_Letter](https://www.compart.com/en/unicode/category/Lu).
#
# Marks:
#
# *   `M`, `Mark`: `Mc`, `Me`, or `Mn`.
# *   [Mc, Spacing_Mark](https://www.compart.com/en/unicode/category/Mc).
# *   [Me, Enclosing_Mark](https://www.compart.com/en/unicode/category/Me).
# *   [Mn, Nonapacing_Mark](https://www.compart.com/en/unicode/category/Mn).
#
# Numbers:
#
# *   `N`, `Number`: `Nd`, `Nl`, or `No`.
# *   [Nd, Decimal_Number](https://www.compart.com/en/unicode/category/Nd).
# *   [Nl, Letter_Number](https://www.compart.com/en/unicode/category/Nl).
# *   [No, Other_Number](https://www.compart.com/en/unicode/category/No).
#
# Punctuation:
#
# *   `P`, `Punctuation`: `Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, or `Ps`.
# *   [Pc,
#     Connector_Punctuation](https://www.compart.com/en/unicode/category/Pc).
# *   [Pd, Dash_Punctuation](https://www.compart.com/en/unicode/category/Pd).
# *   [Pe, Close_Punctuation](https://www.compart.com/en/unicode/category/Pe).
# *   [Pf, Final_Punctuation](https://www.compart.com/en/unicode/category/Pf).
# *   [Pi, Initial_Punctuation](https://www.compart.com/en/unicode/category/Pi).
# *   [Po, Other_Punctuation](https://www.compart.com/en/unicode/category/Po).
# *   [Ps, Open_Punctuation](https://www.compart.com/en/unicode/category/Ps).
#
# *   `S`, `Symbol`: `Sc`, `Sk`, `Sm`, or `So`.
# *   [Sc, Currency_Symbol](https://www.compart.com/en/unicode/category/Sc).
# *   [Sk, Modifier_Symbol](https://www.compart.com/en/unicode/category/Sk).
# *   [Sm, Math_Symbol](https://www.compart.com/en/unicode/category/Sm).
# *   [So, Other_Symbol](https://www.compart.com/en/unicode/category/So).
#
# *   `Z`, `Separator`: `Zl`, `Zp`, or `Zs`.
# *   [Zl, Line_Separator](https://www.compart.com/en/unicode/category/Zl).
# *   [Zp, Paragraph_Separator](https://www.compart.com/en/unicode/category/Zp).
# *   [Zs, Space_Separator](https://www.compart.com/en/unicode/category/Zs).
#
# *   `C`, `Other`: `Cc`, `Cf`, `Cn`, `Co`, or `Cs`.
# *   [Cc, Control](https://www.compart.com/en/unicode/category/Cc).
# *   [Cf, Format](https://www.compart.com/en/unicode/category/Cf).
# *   [Cn, Unassigned](https://www.compart.com/en/unicode/category/Cn).
# *   [Co, Private_Use](https://www.compart.com/en/unicode/category/Co).
# *   [Cs, Surrogate](https://www.compart.com/en/unicode/category/Cs).
#
# #### Unicode Scripts and Blocks
#
# Among the Unicode properties are:
#
# *   [Unicode scripts](https://en.wikipedia.org/wiki/Script_(Unicode)); see
#     [supported scripts](https://www.unicode.org/standard/supported.html).
# *   [Unicode blocks](https://en.wikipedia.org/wiki/Unicode_block); see
#     [supported blocks](http://www.unicode.org/Public/UNIDATA/Blocks.txt).
#
# ### POSIX Bracket Expressions
#
# A POSIX *bracket expression* is also similar to a character class. These
# expressions provide a portable alternative to the above, with the added
# benefit of encompassing non-ASCII characters:
#
# *   `/\d/` matches only ASCII decimal digits `0` through `9`.
# *   `/[[:digit:]]/` matches any character in the Unicode `Decimal Number`
#     (`Nd`) category; see below.
#
# The POSIX bracket expressions:
#
# *   `/[[:digit:]]/`: Matches a [Unicode
#     digit](https://www.compart.com/en/unicode/category/Nd):
#
#         /[[:digit:]]/.match('9')       # => #<MatchData "9">
#         /[[:digit:]]/.match("\u1fbf9") # => #<MatchData "9">
#
# *   `/[[:xdigit:]]/`: Matches a digit allowed in a hexadecimal number;
#     equivalent to `[0-9a-fA-F]`.
#
# *   `/[[:upper:]]/`: Matches a [Unicode uppercase
#     letter](https://www.compart.com/en/unicode/category/Lu):
#
#         /[[:upper:]]/.match('A')      # => #<MatchData "A">
#         /[[:upper:]]/.match("\u00c6") # => #<MatchData "">
#
# *   `/[[:lower:]]/`: Matches a [Unicode lowercase
#     letter](https://www.compart.com/en/unicode/category/Ll):
#
#         /[[:lower:]]/.match('a')      # => #<MatchData "a">
#         /[[:lower:]]/.match("\u01fd") # => #<MatchData "">
#
# *   `/[[:alpha:]]/`: Matches `/[[:upper:]]/` or `/[[:lower:]]/`.
#
# *   `/[[:alnum:]]/`: Matches `/[[:alpha:]]/` or `/[[:digit:]]/`.
#
# *   `/[[:space:]]/`: Matches [Unicode space
#     character](https://www.compart.com/en/unicode/category/Zs):
#
#         /[[:space:]]/.match(' ')      # => #<MatchData " ">
#         /[[:space:]]/.match("\u2005") # => #<MatchData "">
#
# *   `/[[:blank:]]/`: Matches `/[[:space:]]/` or tab character:
#
#         /[[:blank:]]/.match(' ')      # => #<MatchData " ">
#         /[[:blank:]]/.match("\u2005") # => #<MatchData "">
#         /[[:blank:]]/.match("\t")     # => #<MatchData "\t">
#
# *   `/[[:cntrl:]]/`: Matches [Unicode control
#     character](https://www.compart.com/en/unicode/category/Cc):
#
#         /[[:cntrl:]]/.match("\u0000") # => #<MatchData "\u0000">
#         /[[:cntrl:]]/.match("\u009f") # => #<MatchData "\u009F">
#
# *   `/[[:graph:]]/`: Matches any character except `/[[:space:]]/` or
#     `/[[:cntrl:]]/`.
#
# *   `/[[:print:]]/`: Matches `/[[:graph:]]/` or space character.
#
# *   `/[[:punct:]]/`: Matches any (Unicode punctuation
#     character}[https://www.compart.com/en/unicode/category/Po]:
#
# Ruby also supports these (non-POSIX) bracket expressions:
#
# *   `/[[:ascii:]]/`: Matches a character in the ASCII character set.
# *   `/[[:word:]]/`: Matches a character in one of these Unicode character
#     categories or having one of these Unicode properties:
#
#     *   Unicode categories:
#         *   `Mark` (`M`).
#         *   `Decimal Number` (`Nd`)
#         *   `Connector Punctuation` (`Pc`).
#
#     *   Unicode properties:
#         *   `Alpha`
#         *   `Join_Control`
#
# ### Comments
#
# A comment may be included in a regexp pattern using the `(?#`*comment*`)`
# construct, where *comment* is a substring that is to be ignored. arbitrary
# text ignored by the regexp engine:
#
#     /foo(?#Ignore me)bar/.match('foobar') # => #<MatchData "foobar">
#
# The comment may not include an unescaped terminator character.
#
# See also [Extended Mode](rdoc-ref:Regexp@Extended+Mode).
#
# ## Modes
#
# Each of these modifiers sets a mode for the regexp:
#
# *   `i`: `/*pattern*/i` sets [Case-Insensitive
#     Mode](rdoc-ref:Regexp@Case-Insensitive+Mode).
# *   `m`: `/*pattern*/m` sets [Multiline Mode](rdoc-ref:Regexp@Multiline+Mode).
# *   `x`: `/*pattern*/x` sets [Extended Mode](rdoc-ref:Regexp@Extended+Mode).
# *   `o`: `/*pattern*/o` sets [Interpolation
#     Mode](rdoc-ref:Regexp@Interpolation+Mode).
#
# Any, all, or none of these may be applied.
#
# Modifiers `i`, `m`, and `x` may be applied to subexpressions:
#
# *   `(?*modifier*)` turns the mode "on" for ensuing subexpressions
# *   `(?-*modifier*)` turns the mode "off" for ensuing subexpressions
# *   `(?*modifier*:*subexp*)` turns the mode "on" for *subexp* within the group
# *   `(?-*modifier*:*subexp*)` turns the mode "off" for *subexp* within the
#     group
#
# Example:
#
#     re = /(?i)te(?-i)st/
#     re.match('test') # => #<MatchData "test">
#     re.match('TEst') # => #<MatchData "TEst">
#     re.match('TEST') # => nil
#     re.match('teST') # => nil
#
#     re = /t(?i:e)st/
#     re.match('test') # => #<MatchData "test">
#     re.match('tEst') # => #<MatchData "tEst">
#     re.match('tEST') # => nil
#
# Method Regexp#options returns an integer whose value showing the settings for
# case-insensitivity mode, multiline mode, and extended mode.
#
# ### Case-Insensitive Mode
#
# By default, a regexp is case-sensitive:
#
#     /foo/.match('FOO')  # => nil
#
# Modifier `i` enables case-insensitive mode:
#
#     /foo/i.match('FOO')
#     # => #<MatchData "FOO">
#
# Method Regexp#casefold? returns whether the mode is case-insensitive.
#
# ### Multiline Mode
#
# The multiline-mode in Ruby is what is commonly called a "dot-all mode":
#
# *   Without the `m` modifier, the subexpression `.` does not match newlines:
#
#         /a.c/.match("a\nc")  # => nil
#
# *   With the modifier, it does match:
#
#         /a.c/m.match("a\nc") # => #<MatchData "a\nc">
#
# Unlike other languages, the modifier `m` does not affect the anchors `^` and
# `$`. These anchors always match at line-boundaries in Ruby.
#
# ### Extended Mode
#
# Modifier `x` enables extended mode, which means that:
#
# *   Literal white space in the pattern is to be ignored.
# *   Character `#` marks the remainder of its containing line as a comment,
#     which is also to be ignored for matching purposes.
#
# In extended mode, whitespace and comments may be used to form a
# self-documented regexp.
#
# Regexp not in extended mode (matches some Roman numerals):
#
#     pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'
#     re = /#{pattern}/
#     re.match('MCMXLIII') # => #<MatchData "MCMXLIII" 1:"CM" 2:"XL" 3:"III">
#
# Regexp in extended mode:
#
#     pattern = <<-EOT
#       ^                   # beginning of string
#       M{0,3}              # thousands - 0 to 3 Ms
#       (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
#                           #            or 500-800 (D, followed by 0 to 3 Cs)
#       (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
#                           #        or 50-80 (L, followed by 0 to 3 Xs)
#       (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
#                           #        or 5-8 (V, followed by 0 to 3 Is)
#       $                   # end of string
#     EOT
#     re = /#{pattern}/x
#     re.match('MCMXLIII') # => #<MatchData "MCMXLIII" 1:"CM" 2:"XL" 3:"III">
#
# ### Interpolation Mode
#
# Modifier `o` means that the first time a literal regexp with interpolations is
# encountered, the generated Regexp object is saved and used for all future
# evaluations of that literal regexp. Without modifier `o`, the generated Regexp
# is not saved, so each evaluation of the literal regexp generates a new Regexp
# object.
#
# Without modifier `o`:
#
#     def letters; sleep 5; /[A-Z][a-z]/; end
#     words = %w[abc def xyz]
#     start = Time.now
#     words.each {|word| word.match(/\A[#{letters}]+\z/) }
#     Time.now - start # => 15.0174892
#
# With modifier `o`:
#
#     start = Time.now
#     words.each {|word| word.match(/\A[#{letters}]+\z/o) }
#     Time.now - start # => 5.0010866
#
# Note that if the literal regexp does not have interpolations, the `o` behavior
# is the default.
#
# ## Encodings
#
# By default, a regexp with only US-ASCII characters has US-ASCII encoding:
#
#     re = /foo/
#     re.source.encoding # => #<Encoding:US-ASCII>
#     re.encoding        # => #<Encoding:US-ASCII>
#
# A regular expression containing non-US-ASCII characters is assumed to use the
# source encoding. This can be overridden with one of the following modifiers.
#
# *   `/*pat*/n`: US-ASCII if only containing US-ASCII characters, otherwise
#     ASCII-8BIT:
#
#         /foo/n.encoding     # => #<Encoding:US-ASCII>
#         /foo\xff/n.encoding # => #<Encoding:ASCII-8BIT>
#         /foo\x7f/n.encoding # => #<Encoding:US-ASCII>
#
# *   `/*pat*/u`: UTF-8
#
#         /foo/u.encoding # => #<Encoding:UTF-8>
#
# *   `/*pat*/e`: EUC-JP
#
#         /foo/e.encoding # => #<Encoding:EUC-JP>
#
# *   `/*pat*/s`: Windows-31J
#
#         /foo/s.encoding # => #<Encoding:Windows-31J>
#
# A regexp can be matched against a target string when either:
#
# *   They have the same encoding.
# *   The regexp's encoding is a fixed encoding and the string contains only
#     ASCII characters. Method Regexp#fixed_encoding? returns whether the regexp
#     has a *fixed* encoding.
#
# If a match between incompatible encodings is attempted an
# `Encoding::CompatibilityError` exception is raised.
#
# Example:
#
#     re = eval("# encoding: ISO-8859-1\n/foo\\xff?/")
#     re.encoding                 # => #<Encoding:ISO-8859-1>
#     re =~ "foo".encode("UTF-8") # => 0
#     re =~ "foo\u0100"           # Raises Encoding::CompatibilityError
#
# The encoding may be explicitly fixed by including Regexp::FIXEDENCODING in the
# second argument for Regexp.new:
#
#     # Regexp with encoding ISO-8859-1.
#     re = Regexp.new("a".force_encoding('iso-8859-1'), Regexp::FIXEDENCODING)
#     re.encoding  # => #<Encoding:ISO-8859-1>
#     # Target string with encoding UTF-8.
#     s = "a\u3042"
#     s.encoding   # => #<Encoding:UTF-8>
#     re.match(s)  # Raises Encoding::CompatibilityError.
#
# ## Timeouts
#
# When either a regexp source or a target string comes from untrusted input,
# malicious values could become a denial-of-service attack; to prevent such an
# attack, it is wise to set a timeout.
#
# Regexp has two timeout values:
#
# *   A class default timeout, used for a regexp whose instance timeout is
#     `nil`; this default is initially `nil`, and may be set by method
#     Regexp.timeout=:
#
#         Regexp.timeout # => nil
#         Regexp.timeout = 3.0
#         Regexp.timeout # => 3.0
#
# *   An instance timeout, which defaults to `nil` and may be set in Regexp.new:
#
#         re = Regexp.new('foo', timeout: 5.0)
#         re.timeout # => 5.0
#
# When regexp.timeout is `nil`, the timeout "falls through" to Regexp.timeout;
# when regexp.timeout is non-`nil`, that value controls timing out:
#
#     | regexp.timeout Value | Regexp.timeout Value |            Result           |
#     |----------------------|----------------------|-----------------------------|
#     |         nil          |          nil         |       Never times out.      |
#     |         nil          |         Float        | Times out in Float seconds. |
#     |        Float         |          Any         | Times out in Float seconds. |
#
# ## Optimization
#
# For certain values of the pattern and target string, matching time can grow
# polynomially or exponentially in relation to the input size; the potential
# vulnerability arising from this is the [regular expression
# denial-of-service](https://en.wikipedia.org/wiki/ReDoS) (ReDoS) attack.
#
# Regexp matching can apply an optimization to prevent ReDoS attacks. When the
# optimization is applied, matching time increases linearly (not polynomially or
# exponentially) in relation to the input size, and a ReDoS attach is not
# possible.
#
# This optimization is applied if the pattern meets these criteria:
#
# *   No backreferences.
# *   No subexpression calls.
# *   No nested lookaround anchors or atomic groups.
# *   No nested quantifiers with counting (i.e. no nested `{n}`, `{min,}`,
#     `{,max}`, or `{min,max}` style quantifiers)
#
# You can use method Regexp.linear_time? to determine whether a pattern meets
# these criteria:
#
#     Regexp.linear_time?(/a*/)     # => true
#     Regexp.linear_time?('a*')     # => true
#     Regexp.linear_time?(/(a*)\1/) # => false
#
# However, an untrusted source may not be safe even if the method returns
# `true`, because the optimization uses memoization (which may invoke large
# memory consumption).
#
# ## References
#
# Read (online PDF books):
#
# *   [Mastering Regular
#     Expressions](https://ia902508.us.archive.org/10/items/allitebooks-02/Maste
#     ring%20Regular%20Expressions%2C%203rd%20Edition.pdf) by Jeffrey E.F.
#     Friedl.
# *   [Regular Expressions
#     Cookbook](https://doc.lagout.org/programmation/Regular%20Expressions/Regul
#     ar%20Expressions%20Cookbook_%20Detailed%20Solutions%20in%20Eight%20Program
#     ming%20Languages%20%282nd%20ed.%29%20%5BGoyvaerts%20%26%20Levithan%202012-
#     09-06%5D.pdf) by Jan Goyvaerts & Steven Levithan.
#
# Explore, test (interactive online editor):
#
# *   [Rubular](https://rubular.com/).
#
class Regexp
  # Represents an object's ability to be converted to a `Regexp`.
  #
  # This is only used in `Regexp.try_convert` and `Regexp.union` within the standard library.
  interface _ToRegexp
    # Converts `self` to a `Regexp`.
    def to_regexp: () -> Regexp
  end

  class TimeoutError < RegexpError
  end

  # <!-- rdoc-file=re.c -->
  # see Regexp.options and Regexp.new
  #
  EXTENDED: Integer

  # <!-- rdoc-file=re.c -->
  # see Regexp.options and Regexp.new
  #
  FIXEDENCODING: Integer

  # <!-- rdoc-file=re.c -->
  # see Regexp.options and Regexp.new
  #
  IGNORECASE: Integer

  # <!-- rdoc-file=re.c -->
  # see Regexp.options and Regexp.new
  #
  MULTILINE: Integer

  # <!-- rdoc-file=re.c -->
  # see Regexp.options and Regexp.new
  #
  NOENCODING: Integer

  # <!--
  #   rdoc-file=re.c
  #   - compile(*args)
  # -->
  # Alias for Regexp.new
  #
  alias self.compile self.new

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(string) -> new_string
  # -->
  # Returns a new string that escapes any characters that have special meaning in
  # a regular expression:
  #
  #     s = Regexp.escape('\*?{}.')      # => "\\\\\\*\\?\\{\\}\\."
  #
  # For any string `s`, this call returns a MatchData object:
  #
  #     r = Regexp.new(Regexp.escape(s)) # => /\\\\\\\*\\\?\\\{\\\}\\\./
  #     r.match(s)                       # => #<MatchData "\\\\\\*\\?\\{\\}\\.">
  #
  def self.escape: (interned str) -> String

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.last_match -> matchdata or nil
  #   - Regexp.last_match(n) -> string or nil
  #   - Regexp.last_match(name) -> string or nil
  # -->
  # With no argument, returns the value of `$~`, which is the result of the most
  # recent pattern match (see [Regexp global
  # variables](rdoc-ref:Regexp@Global+Variables)):
  #
  #     /c(.)t/ =~ 'cat'  # => 0
  #     Regexp.last_match # => #<MatchData "cat" 1:"a">
  #     /a/ =~ 'foo'      # => nil
  #     Regexp.last_match # => nil
  #
  # With non-negative integer argument `n`, returns the _n_th field in the
  # matchdata, if any, or nil if none:
  #
  #     /c(.)t/ =~ 'cat'     # => 0
  #     Regexp.last_match(0) # => "cat"
  #     Regexp.last_match(1) # => "a"
  #     Regexp.last_match(2) # => nil
  #
  # With negative integer argument `n`, counts backwards from the last field:
  #
  #     Regexp.last_match(-1)       # => "a"
  #
  # With string or symbol argument `name`, returns the string value for the named
  # capture, if any:
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ 'var = val'
  #     Regexp.last_match        # => #<MatchData "var = val" lhs:"var"rhs:"val">
  #     Regexp.last_match(:lhs)  # => "var"
  #     Regexp.last_match('rhs') # => "val"
  #     Regexp.last_match('foo') # Raises IndexError.
  #
  def self.last_match: () -> MatchData?
                     | (MatchData::capture capture) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.linear_time?(re)
  #   - Regexp.linear_time?(string, options = 0)
  # -->
  # Returns `true` if matching against `re` can be done in linear time to the
  # input string.
  #
  #     Regexp.linear_time?(/re/) # => true
  #
  # Note that this is a property of the ruby interpreter, not of the argument
  # regular expression.  Identical regexp can or cannot run in linear time
  # depending on your ruby binary.  Neither forward nor backward compatibility is
  # guaranteed about the return value of this method.  Our current algorithm is
  # (*1) but this is subject to change in the future.  Alternative implementations
  # can also behave differently.  They might always return false for everything.
  #
  # (*1): https://doi.org/10.1109/SP40001.2021.00032
  #
  def self.linear_time?: (Regexp regex, ?nil, ?timeout: untyped) -> bool
                       | (string regex, ?int | string | bool | nil options, ?timeout: untyped) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(string) -> new_string
  # -->
  # Returns a new string that escapes any characters that have special meaning in
  # a regular expression:
  #
  #     s = Regexp.escape('\*?{}.')      # => "\\\\\\*\\?\\{\\}\\."
  #
  # For any string `s`, this call returns a MatchData object:
  #
  #     r = Regexp.new(Regexp.escape(s)) # => /\\\\\\\*\\\?\\\{\\\}\\\./
  #     r.match(s)                       # => #<MatchData "\\\\\\*\\?\\{\\}\\.">
  #
  alias self.quote self.escape

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.try_convert(object) -> regexp or nil
  # -->
  # Returns `object` if it is a regexp:
  #
  #     Regexp.try_convert(/re/) # => /re/
  #
  # Otherwise if `object` responds to `:to_regexp`, calls `object.to_regexp` and
  # returns the result.
  #
  # Returns `nil` if `object` does not respond to `:to_regexp`.
  #
  #     Regexp.try_convert('re') # => nil
  #
  # Raises an exception unless `object.to_regexp` returns a regexp.
  #
  def self.try_convert: (Regexp | _ToRegexp regexp_like) -> Regexp
                      | (untyped other) -> Regexp?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.timeout  -> float or nil
  # -->
  # It returns the current default timeout interval for Regexp matching in second.
  # `nil` means no default timeout configuration.
  #
  def self.timeout: () -> Float?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.timeout = float or nil
  # -->
  # It sets the default timeout interval for Regexp matching in second. `nil`
  # means no default timeout configuration. This configuration is process-global.
  # If you want to set timeout for each Regexp, use `timeout` keyword for
  # `Regexp.new`.
  #
  #     Regexp.timeout = 1
  #     /^a*b?a*$/ =~ "a" * 100000 + "x" #=> regexp match timeout (RuntimeError)
  #
  def self.timeout=: [T < _ToF] (T timeout) -> T

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.union(*patterns) -> regexp
  #   - Regexp.union(array_of_patterns) -> regexp
  # -->
  # Returns a new regexp that is the union of the given patterns:
  #
  #     r = Regexp.union(%w[cat dog])      # => /cat|dog/
  #     r.match('cat')      # => #<MatchData "cat">
  #     r.match('dog')      # => #<MatchData "dog">
  #     r.match('cog')      # => nil
  #
  # For each pattern that is a string, `Regexp.new(pattern)` is used:
  #
  #     Regexp.union('penzance')             # => /penzance/
  #     Regexp.union('a+b*c')                # => /a\+b\*c/
  #     Regexp.union('skiing', 'sledding')   # => /skiing|sledding/
  #     Regexp.union(['skiing', 'sledding']) # => /skiing|sledding/
  #
  # For each pattern that is a regexp, it is used as is, including its flags:
  #
  #     Regexp.union(/foo/i, /bar/m, /baz/x)
  #     # => /(?i-mx:foo)|(?m-ix:bar)|(?x-mi:baz)/
  #     Regexp.union([/foo/i, /bar/m, /baz/x])
  #     # => /(?i-mx:foo)|(?m-ix:bar)|(?x-mi:baz)/
  #
  # With no arguments, returns `/(?!)/`:
  #
  #     Regexp.union # => /(?!)/
  #
  # If any regexp pattern contains captures, the behavior is unspecified.
  #
  def self.union: (*Regexp | _ToRegexp | string patterns) -> Regexp
                | (array[Regexp | _ToRegexp | string] patterns) -> Regexp
                | (Symbol | [Symbol] symbol_pattern) -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.new(string, options = 0, timeout: nil) -> regexp
  #   - Regexp.new(regexp, timeout: nil) -> regexp
  # -->
  # With argument `string` given, returns a new regexp with the given string and
  # options:
  #
  #     r = Regexp.new('foo') # => /foo/
  #     r.source              # => "foo"
  #     r.options             # => 0
  #
  # Optional argument `options` is one of the following:
  #
  # *   A String of options:
  #
  #         Regexp.new('foo', 'i')  # => /foo/i
  #         Regexp.new('foo', 'im') # => /foo/im
  #
  # *   The bit-wise OR of one or more of the constants Regexp::EXTENDED,
  #     Regexp::IGNORECASE, Regexp::MULTILINE, and Regexp::NOENCODING:
  #
  #         Regexp.new('foo', Regexp::IGNORECASE) # => /foo/i
  #         Regexp.new('foo', Regexp::EXTENDED)   # => /foo/x
  #         Regexp.new('foo', Regexp::MULTILINE)  # => /foo/m
  #         Regexp.new('foo', Regexp::NOENCODING)  # => /foo/n
  #         flags = Regexp::IGNORECASE | Regexp::EXTENDED |  Regexp::MULTILINE
  #         Regexp.new('foo', flags)              # => /foo/mix
  #
  # *   `nil` or `false`, which is ignored.
  # *   Any other truthy value, in which case the regexp will be case-insensitive.
  #
  # If optional keyword argument `timeout` is given, its float value overrides the
  # timeout interval for the class, Regexp.timeout. If `nil` is passed as
  # +timeout, it uses the timeout interval for the class, Regexp.timeout.
  #
  # With argument `regexp` given, returns a new regexp. The source, options,
  # timeout are the same as `regexp`. `options` and `n_flag` arguments are
  # ineffective.  The timeout can be overridden by `timeout` keyword.
  #
  #     options = Regexp::MULTILINE
  #     r = Regexp.new('foo', options, timeout: 1.1) # => /foo/m
  #     r2 = Regexp.new(r)                           # => /foo/m
  #     r2.timeout                                   # => 1.1
  #     r3 = Regexp.new(r, timeout: 3.14)            # => /foo/m
  #     r3.timeout                                   # => 3.14
  #
  def initialize: (Regexp regexp, ?timeout: _ToF?) -> void
                | (string pattern, ?int | string | bool | nil options, ?timeout: _ToF?) -> void

  def initialize_copy: (self object) -> self

  # <!-- rdoc-file=re.c -->
  # Returns `true` if `object` is another Regexp whose pattern, flags, and
  # encoding are the same as `self`, `false` otherwise:
  #
  #     /foo/ == Regexp.new('foo')                          # => true
  #     /foo/ == /foo/i                                     # => false
  #     /foo/ == Regexp.new('food')                         # => false
  #     /foo/ == Regexp.new("abc".force_encoding("euc-jp")) # => false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - regexp === string -> true or false
  # -->
  # Returns `true` if `self` finds a match in `string`:
  #
  #     /^[a-z]*$/ === 'HELLO' # => false
  #     /^[A-Z]*$/ === 'HELLO' # => true
  #
  # This method is called in case statements:
  #
  #     s = 'HELLO'
  #     case s
  #     when /\A[a-z]*\z/; print "Lower case\n"
  #     when /\A[A-Z]*\z/; print "Upper case\n"
  #     else               print "Mixed case\n"
  #     end # => "Upper case"
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - regexp =~ string -> integer or nil
  # -->
  # Returns the integer index (in characters) of the first match for `self` and
  # `string`, or `nil` if none; also sets the [rdoc-ref:Regexp global
  # variables](rdoc-ref:Regexp@Global+Variables):
  #
  #     /at/ =~ 'input data' # => 7
  #     $~                   # => #<MatchData "at">
  #     /ax/ =~ 'input data' # => nil
  #     $~                   # => nil
  #
  # Assigns named captures to local variables of the same names if and only if
  # `self`:
  #
  # *   Is a regexp literal; see [Regexp
  #     Literals](rdoc-ref:syntax/literals.rdoc@Regexp+Literals).
  # *   Does not contain interpolations; see [Regexp
  #     interpolation](rdoc-ref:Regexp@Interpolation+Mode).
  # *   Is at the left of the expression.
  #
  # Example:
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ '  x = y  '
  #     p lhs # => "x"
  #     p rhs # => "y"
  #
  # Assigns `nil` if not matched:
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ '  x = '
  #     p lhs # => nil
  #     p rhs # => nil
  #
  # Does not make local variable assignments if `self` is not a regexp literal:
  #
  #     r = /(?<foo>\w+)\s*=\s*(?<foo>\w+)/
  #     r =~ '  x = y  '
  #     p foo # Undefined local variable
  #     p bar # Undefined local variable
  #
  # The assignment does not occur if the regexp is not at the left:
  #
  #     '  x = y  ' =~ /(?<foo>\w+)\s*=\s*(?<foo>\w+)/
  #     p foo, foo # Undefined local variables
  #
  # A regexp interpolation, `#{}`, also disables the assignment:
  #
  #     r = /(?<foo>\w+)/
  #     /(?<foo>\w+)\s*=\s*#{r}/ =~ 'x = y'
  #     p foo # Undefined local variable
  #
  def =~: (interned? string) -> Integer?
        | (nil) -> nil

  # <!--
  #   rdoc-file=re.c
  #   - casefold?-> true or false
  # -->
  # Returns `true` if the case-insensitivity flag in `self` is set, `false`
  # otherwise:
  #
  #     /a/.casefold?           # => false
  #     /a/i.casefold?          # => true
  #     /(?i:a)/.casefold?      # => false
  #
  def casefold?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=re.c
  #   - regexp == object -> true or false
  # -->
  # Returns `true` if `object` is another Regexp whose pattern, flags, and
  # encoding are the same as `self`, `false` otherwise:
  #
  #     /foo/ == Regexp.new('foo')                          # => true
  #     /foo/ == /foo/i                                     # => false
  #     /foo/ == Regexp.new('food')                         # => false
  #     /foo/ == Regexp.new("abc".force_encoding("euc-jp")) # => false
  #
  alias eql? ==

  # <!--
  #   rdoc-file=re.c
  #   - fixed_encoding?   -> true or false
  # -->
  # Returns `false` if `self` is applicable to a string with any ASCII-compatible
  # encoding; otherwise returns `true`:
  #
  #     r = /a/                                          # => /a/
  #     r.fixed_encoding?                               # => false
  #     r.match?("\u{6666} a")                          # => true
  #     r.match?("\xa1\xa2 a".force_encoding("euc-jp")) # => true
  #     r.match?("abc".force_encoding("euc-jp"))        # => true
  #
  #     r = /a/u                                        # => /a/
  #     r.fixed_encoding?                               # => true
  #     r.match?("\u{6666} a")                          # => true
  #     r.match?("\xa1\xa2".force_encoding("euc-jp"))   # Raises exception.
  #     r.match?("abc".force_encoding("euc-jp"))        # => true
  #
  #     r = /\u{6666}/                                  # => /\u{6666}/
  #     r.fixed_encoding?                               # => true
  #     r.encoding                                      # => #<Encoding:UTF-8>
  #     r.match?("\u{6666} a")                          # => true
  #     r.match?("\xa1\xa2".force_encoding("euc-jp"))   # Raises exception.
  #     r.match?("abc".force_encoding("euc-jp"))        # => false
  #
  def fixed_encoding?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - inspect -> string
  # -->
  # Returns a nicely-formatted string representation of `self`:
  #
  #     /ab+c/ix.inspect # => "/ab+c/ix"
  #
  # Related: Regexp#to_s.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - match(string, offset = 0) -> matchdata or nil
  #   - match(string, offset = 0) {|matchdata| ... } -> object
  # -->
  # With no block given, returns the MatchData object that describes the match, if
  # any, or `nil` if none; the search begins at the given character `offset` in
  # `string`:
  #
  #     /abra/.match('abracadabra')      # => #<MatchData "abra">
  #     /abra/.match('abracadabra', 4)   # => #<MatchData "abra">
  #     /abra/.match('abracadabra', 8)   # => nil
  #     /abra/.match('abracadabra', 800) # => nil
  #
  #     string = "\u{5d0 5d1 5e8 5d0}cadabra"
  #     /abra/.match(string, 7)          #=> #<MatchData "abra">
  #     /abra/.match(string, 8)          #=> nil
  #     /abra/.match(string.b, 8)        #=> #<MatchData "abra">
  #
  # With a block given, calls the block if and only if a match is found; returns
  # the block's value:
  #
  #     /abra/.match('abracadabra') {|matchdata| p matchdata }
  #     # => #<MatchData "abra">
  #     /abra/.match('abracadabra', 4) {|matchdata| p matchdata }
  #     # => #<MatchData "abra">
  #     /abra/.match('abracadabra', 8) {|matchdata| p matchdata }
  #     # => nil
  #     /abra/.match('abracadabra', 8) {|marchdata| fail 'Cannot happen' }
  #     # => nil
  #
  # Output (from the first two blocks above):
  #
  #     #<MatchData "abra">
  #     #<MatchData "abra">
  #
  #      /(.)(.)(.)/.match("abc")[2] # => "b"
  #      /(.)(.)/.match("abc", 1)[2] # => "c"
  #
  def match: (interned? str, ?int offset) -> MatchData?
           | [T] (interned? str, ?int offset) { (MatchData matchdata) -> T } -> T?
           | (nil, ?int offset) ?{ (MatchData matchdata) -> void } -> nil

  # <!--
  #   rdoc-file=re.c
  #   - match?(string) -> true or false
  #   - match?(string, offset = 0) -> true or false
  # -->
  # Returns `true` or `false` to indicate whether the regexp is matched or not
  # without updating $~ and other related variables. If the second parameter is
  # present, it specifies the position in the string to begin the search.
  #
  #     /R.../.match?("Ruby")    # => true
  #     /R.../.match?("Ruby", 1) # => false
  #     /P.../.match?("Ruby")    # => false
  #     $&                       # => nil
  #
  def match?: (interned str, ?int offset) -> bool
            | (nil, ?int offset) -> false

  # <!--
  #   rdoc-file=re.c
  #   - named_captures  -> hash
  # -->
  # Returns a hash representing named captures of `self` (see [Named
  # Captures](rdoc-ref:Regexp@Named+Captures)):
  #
  # *   Each key is the name of a named capture.
  # *   Each value is an array of integer indexes for that named capture.
  #
  # Examples:
  #
  #     /(?<foo>.)(?<bar>.)/.named_captures # => {"foo"=>[1], "bar"=>[2]}
  #     /(?<foo>.)(?<foo>.)/.named_captures # => {"foo"=>[1, 2]}
  #     /(.)(.)/.named_captures             # => {}
  #
  def named_captures: () -> Hash[String, Array[Integer]]

  # <!--
  #   rdoc-file=re.c
  #   - names -> array_of_names
  # -->
  # Returns an array of names of captures (see [Named
  # Captures](rdoc-ref:Regexp@Named+Captures)):
  #
  #     /(?<foo>.)(?<bar>.)(?<baz>.)/.names # => ["foo", "bar", "baz"]
  #     /(?<foo>.)(?<foo>.)/.names          # => ["foo"]
  #     /(.)(.)/.names                      # => []
  #
  def names: () -> Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - options -> integer
  # -->
  # Returns an integer whose bits show the options set in `self`.
  #
  # The option bits are:
  #
  #     Regexp::IGNORECASE # => 1
  #     Regexp::EXTENDED   # => 2
  #     Regexp::MULTILINE  # => 4
  #
  # Examples:
  #
  #     /foo/.options    # => 0
  #     /foo/i.options   # => 1
  #     /foo/x.options   # => 2
  #     /foo/m.options   # => 4
  #     /foo/mix.options # => 7
  #
  # Note that additional bits may be set in the returned integer; these are
  # maintained internally in `self`, are ignored if passed to Regexp.new, and may
  # be ignored by the caller:
  #
  # Returns the set of bits corresponding to the options used when creating this
  # regexp (see Regexp::new for details). Note that additional bits may be set in
  # the returned options: these are used internally by the regular expression
  # code. These extra bits are ignored if the options are passed to Regexp::new:
  #
  #     r = /\xa1\xa2/e                 # => /\xa1\xa2/
  #     r.source                        # => "\\xa1\\xa2"
  #     r.options                       # => 16
  #     Regexp.new(r.source, r.options) # => /\xa1\xa2/
  #
  def options: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - source -> string
  # -->
  # Returns the original string of `self`:
  #
  #     /ab+c/ix.source # => "ab+c"
  #
  # Regexp escape sequences are retained:
  #
  #     /\x20\+/.source  # => "\\x20\\+"
  #
  # Lexer escape characters are not retained:
  #
  #     /\//.source  # => "/"
  #
  def source: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - to_s -> string
  # -->
  # Returns a string showing the options and string of `self`:
  #
  #     r0 = /ab+c/ix
  #     s0 = r0.to_s # => "(?ix-m:ab+c)"
  #
  # The returned string may be used as an argument to Regexp.new, or as
  # interpolated text for a [Regexp
  # interpolation](rdoc-ref:Regexp@Interpolation+Mode):
  #
  #     r1 = Regexp.new(s0) # => /(?ix-m:ab+c)/
  #     r2 = /#{s0}/        # => /(?ix-m:ab+c)/
  #
  # Note that `r1` and `r2` are not equal to `r0` because their original strings
  # are different:
  #
  #     r0 == r1  # => false
  #     r0.source # => "ab+c"
  #     r1.source # => "(?ix-m:ab+c)"
  #
  # Related: Regexp#inspect.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - rxp.timeout  -> float or nil
  # -->
  # It returns the timeout interval for Regexp matching in second. `nil` means no
  # default timeout configuration.
  #
  # This configuration is per-object. The global configuration set by
  # Regexp.timeout= is ignored if per-object configuration is set.
  #
  #     re = Regexp.new("^a*b?a*$", timeout: 1)
  #     re.timeout               #=> 1.0
  #     re =~ "a" * 100000 + "x" #=> regexp match timeout (RuntimeError)
  #
  %a{pure}
  def timeout: () -> Float?

  # <!--
  #   rdoc-file=re.c
  #   - ~ rxp -> integer or nil
  # -->
  # Equivalent to *`rxp* =~ $_`:
  #
  #     $_ = "input data"
  #     ~ /at/ # => 7
  #
  def ~: () -> Integer?
end
# <!-- rdoc-file=object.c -->
# Object is the default root of all Ruby objects.  Object inherits from
# BasicObject which allows creating alternate object hierarchies.  Methods on
# Object are available to all classes unless explicitly overridden.
#
# Object mixes in the Kernel module, making the built-in kernel functions
# globally accessible.  Although the instance methods of Object are defined by
# the Kernel module, we have chosen to document them here for clarity.
#
# When referencing constants in classes inheriting from Object you do not need
# to use the full namespace.  For example, referencing `File` inside `YourClass`
# will find the top-level File class.
#
# In the descriptions of Object's methods, the parameter *symbol* refers to a
# symbol, which is either a quoted string or a Symbol (such as `:name`).
#
# ## What's Here
#
# First, what's elsewhere. Class Object:
#
# *   Inherits from [class BasicObject](rdoc-ref:BasicObject@What-27s+Here).
# *   Includes [module Kernel](rdoc-ref:Kernel@What-27s+Here).
#
# Here, class Object provides methods for:
#
# *   [Querying](rdoc-ref:Object@Querying)
# *   [Instance Variables](rdoc-ref:Object@Instance+Variables)
# *   [Other](rdoc-ref:Object@Other)
#
# ### Querying
#
# *   #!~: Returns `true` if `self` does not match the given object, otherwise
#     `false`.
# *   #<=>: Returns 0 if `self` and the given object `object` are the same
#     object, or if `self == object`; otherwise returns `nil`.
# *   #===: Implements case equality, effectively the same as calling #==.
# *   #eql?: Implements hash equality, effectively the same as calling #==.
# *   #kind_of? (aliased as #is_a?): Returns whether given argument is an
#     ancestor of the singleton class of `self`.
# *   #instance_of?: Returns whether `self` is an instance of the given class.
# *   #instance_variable_defined?: Returns whether the given instance variable
#     is defined in `self`.
# *   #method: Returns the Method object for the given method in `self`.
# *   #methods: Returns an array of symbol names of public and protected methods
#     in `self`.
# *   #nil?: Returns `false`. (Only `nil` responds `true` to method `nil?`.)
# *   #object_id: Returns an integer corresponding to `self` that is unique for
#     the current process
# *   #private_methods: Returns an array of the symbol names of the private
#     methods in `self`.
# *   #protected_methods: Returns an array of the symbol names of the protected
#     methods in `self`.
# *   #public_method: Returns the Method object for the given public method in
#     `self`.
# *   #public_methods: Returns an array of the symbol names of the public
#     methods in `self`.
# *   #respond_to?: Returns whether `self` responds to the given method.
# *   #singleton_class: Returns the singleton class of `self`.
# *   #singleton_method: Returns the Method object for the given singleton
#     method in `self`.
# *   #singleton_methods: Returns an array of the symbol names of the singleton
#     methods in `self`.
#
# *   #define_singleton_method: Defines a singleton method in `self` for the
#     given symbol method-name and block or proc.
# *   #extend: Includes the given modules in the singleton class of `self`.
# *   #public_send: Calls the given public method in `self` with the given
#     argument.
# *   #send: Calls the given method in `self` with the given argument.
#
# ### Instance Variables
#
# *   #instance_variable_get: Returns the value of the given instance variable
#     in `self`, or `nil` if the instance variable is not set.
# *   #instance_variable_set: Sets the value of the given instance variable in
#     `self` to the given object.
# *   #instance_variables: Returns an array of the symbol names of the instance
#     variables in `self`.
# *   #remove_instance_variable: Removes the named instance variable from
#     `self`.
#
# ### Other
#
# *   #clone:  Returns a shallow copy of `self`, including singleton class and
#     frozen state.
# *   #define_singleton_method: Defines a singleton method in `self` for the
#     given symbol method-name and block or proc.
# *   #display: Prints `self` to the given IO stream or `$stdout`.
# *   #dup: Returns a shallow unfrozen copy of `self`.
# *   #enum_for (aliased as #to_enum): Returns an Enumerator for `self` using
#     the using the given method, arguments, and block.
# *   #extend: Includes the given modules in the singleton class of `self`.
# *   #freeze: Prevents further modifications to `self`.
# *   #hash: Returns the integer hash value for `self`.
# *   #inspect: Returns a human-readable  string representation of `self`.
# *   #itself: Returns `self`.
# *   #method_missing: Method called when an undefined method is called on
#     `self`.
# *   #public_send: Calls the given public method in `self` with the given
#     argument.
# *   #send: Calls the given method in `self` with the given argument.
# *   #to_s: Returns a string representation of `self`.
#
class Object < BasicObject
  include Kernel
end

# A previous incarnation of `interned` for backward-compatibility (see #1499)
%a{steep:deprecated}
type Object::name = interned
# <!-- rdoc-file=lib/rubygems/user_interaction.rb -->
# Gem::StreamUI implements a simple stream based user interface.
#
class Gem::StreamUI
end
# <!-- rdoc-file=lib/rubygems/installer.rb -->
# The installer installs the files contained in the .gem into the Gem.home.
#
# Gem::Installer does the work of putting files in all the right places on the
# filesystem including unpacking the gem into its gem dir, installing the
# gemspec in the specifications dir, storing the cached gem in the cache dir,
# and installing either wrappers or symlinks for executables.
#
# The installer invokes pre and post install hooks.  Hooks can be added either
# through a rubygems_plugin.rb file in an installed gem or via a
# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
# file.  See Gem.pre_install and Gem.post_install for details.
#
class Gem::Installer
end
%a{annotate:rdoc:skip}
module Gem
  # <!-- rdoc-file=lib/rubygems/version.rb -->
  # The Version class processes string versions into comparable values. A version
  # string should normally be a series of numbers separated by periods. Each part
  # (digits separated by periods) is considered its own number, and these are used
  # for sorting. So for instance, 3.10 sorts higher than 3.2 because ten is
  # greater than two.
  #
  # If any part contains letters (currently only a-z are supported) then that
  # version is considered prerelease. Versions with a prerelease part in the Nth
  # part sort less than versions with N-1 parts. Prerelease parts are sorted
  # alphabetically using the normal Ruby string sorting rules. If a prerelease
  # part contains both letters and numbers, it will be broken into multiple parts
  # to provide expected sort behavior (1.0.a10 becomes 1.0.a.10, and is greater
  # than 1.0.a9).
  #
  # Prereleases sort between real releases (newest to oldest):
  #
  # 1.  1.0
  # 2.  1.0.b1
  # 3.  1.0.a.2
  # 4.  0.9
  #
  # If you want to specify a version restriction that includes both prereleases
  # and regular releases of the 1.x series this is the best way:
  #
  #     s.add_dependency 'example', '>= 1.0.0.a', '< 2.0.0'
  #
  # ## How Software Changes
  #
  # Users expect to be able to specify a version constraint that gives them some
  # reasonable expectation that new versions of a library will work with their
  # software if the version constraint is true, and not work with their software
  # if the version constraint is false.  In other words, the perfect system will
  # accept all compatible versions of the library and reject all incompatible
  # versions.
  #
  # Libraries change in 3 ways (well, more than 3, but stay focused here!).
  #
  # 1.  The change may be an implementation detail only and have no effect on the
  #     client software.
  # 2.  The change may add new features, but do so in a way that client software
  #     written to an earlier version is still compatible.
  # 3.  The change may change the public interface of the library in such a way
  #     that old software is no longer compatible.
  #
  # Some examples are appropriate at this point.  Suppose I have a Stack class
  # that supports a `push` and a `pop` method.
  #
  # ### Examples of Category 1 changes:
  #
  # *   Switch from an array based implementation to a linked-list based
  #     implementation.
  # *   Provide an automatic (and transparent) backing store for large stacks.
  #
  # ### Examples of Category 2 changes might be:
  #
  # *   Add a `depth` method to return the current depth of the stack.
  # *   Add a `top` method that returns the current top of stack (without changing
  #     the stack).
  # *   Change `push` so that it returns the item pushed (previously it had no
  #     usable return value).
  #
  # ### Examples of Category 3 changes might be:
  #
  # *   Changes `pop` so that it no longer returns a value (you must use `top` to
  #     get the top of the stack).
  # *   Rename the methods to `push_item` and `pop_item`.
  #
  # ## RubyGems Rational Versioning
  #
  # *   Versions shall be represented by three non-negative integers, separated by
  #     periods (e.g. 3.1.4).  The first integers is the "major" version number,
  #     the second integer is the "minor" version number, and the third integer is
  #     the "build" number.
  #
  # *   A category 1 change (implementation detail) will increment the build
  #     number.
  #
  # *   A category 2 change (backwards compatible) will increment the minor
  #     version number and reset the build number.
  #
  # *   A category 3 change (incompatible) will increment the major build number
  #     and reset the minor and build numbers.
  #
  # *   Any "public" release of a gem should have a different version.  Normally
  #     that means incrementing the build number.  This means a developer can
  #     generate builds all day long, but as soon as they make a public release,
  #     the version must be updated.
  #
  # ### Examples
  #
  # Let's work through a project lifecycle using our Stack example from above.
  #
  # Version 0.0.1
  # :   The initial Stack class is release.
  #
  # Version 0.0.2
  # :   Switched to a linked=list implementation because it is cooler.
  #
  # Version 0.1.0
  # :   Added a `depth` method.
  #
  # Version 1.0.0
  # :   Added `top` and made `pop` return nil (`pop` used to return the  old top
  #     item).
  #
  # Version 1.1.0
  # :   `push` now returns the value pushed (it used it return nil).
  #
  # Version 1.1.1
  # :   Fixed a bug in the linked list implementation.
  #
  # Version 1.1.2
  # :   Fixed a bug introduced in the last fix.
  #
  #
  # Client A needs a stack with basic push/pop capability.  They write to the
  # original interface (no `top`), so their version constraint looks like:
  #
  #     gem 'stack', '>= 0.0'
  #
  # Essentially, any version is OK with Client A.  An incompatible change to the
  # library will cause them grief, but they are willing to take the chance (we
  # call Client A optimistic).
  #
  # Client B is just like Client A except for two things: (1) They use the `depth`
  # method and (2) they are worried about future incompatibilities, so they write
  # their version constraint like this:
  #
  #     gem 'stack', '~> 0.1'
  #
  # The `depth` method was introduced in version 0.1.0, so that version or
  # anything later is fine, as long as the version stays below version 1.0 where
  # incompatibilities are introduced.  We call Client B pessimistic because they
  # are worried about incompatible future changes (it is OK to be pessimistic!).
  #
  # ## Preventing Version Catastrophe:
  #
  # From:
  # https://www.zenspider.com/ruby/2008/10/rubygems-how-to-preventing-catastrophe.
  # html
  #
  # Let's say you're depending on the fnord gem version 2.y.z. If you specify your
  # dependency as ">= 2.0.0" then, you're good, right? What happens if fnord 3.0
  # comes out and it isn't backwards compatible with 2.y.z? Your stuff will break
  # as a result of using ">=". The better route is to specify your dependency with
  # an "approximate" version specifier ("~>"). They're a tad confusing, so here is
  # how the dependency specifiers work:
  #
  #     Specification From  ... To (exclusive)
  #     ">= 3.0"      3.0   ... &infin;
  #     "~> 3.0"      3.0   ... 4.0
  #     "~> 3.0.0"    3.0.0 ... 3.1
  #     "~> 3.5"      3.5   ... 4.0
  #     "~> 3.5.0"    3.5.0 ... 3.6
  #     "~> 3"        3.0   ... 4.0
  #
  # For the last example, single-digit versions are automatically extended with a
  # zero to give a sensible result.
  #
  class Version
    include Comparable

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - correct?(version)
    # -->
    # True if the `version` string matches RubyGems' requirements.
    #
    def self.correct?: (_ToS version) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - create(input)
    # -->
    # Factory method to create a Version object. Input may be a Version or a String.
    # Intended to simplify client code.
    #
    #     ver1 = Version.create('1.3.17')   # -> (Version object)
    #     ver2 = Version.create(ver1)       # -> (ver1)
    #     ver3 = Version.create(nil)        # -> nil
    #
    def self.create: (_ToS | Version input) -> instance
                   | (nil input) -> nil

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - new(version)
    # -->
    # Constructs a Version from the `version` string.  A version string is a series
    # of digits or ASCII letters separated by dots.
    #
    def initialize: (_ToS version) -> void

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - <=>(other)
    # -->
    # Compares this version with `other` returning -1, 0, or 1 if the other version
    # is larger, the same, or smaller than this one. Attempts to compare to
    # something that's not a `Gem::Version` or a valid version String return `nil`.
    #
    def <=>: (untyped other) -> Integer?

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - approximate_recommendation()
    # -->
    # A recommended version for use with a ~> Requirement.
    #
    def approximate_recommendation: () -> String

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - bump()
    # -->
    # Return a new version object where the next to the last revision number is one
    # greater (e.g., 5.3.1 => 5.4).
    #
    # Pre-release (alpha) parts, e.g, 5.3.1.b.2 => 5.4, are ignored.
    #
    def bump: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - canonical_segments()
    # -->
    # remove trailing zeros segments before first letter or at the end of the
    # version
    #
    def canonical_segments: () -> Array[Integer | String]

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - eql?(other)
    # -->
    # A Version is only eql? to another version if it's specified to the same
    # precision. Version "1.0" is not the same as version "1".
    #
    def eql?: (untyped other) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - marshal_dump()
    # -->
    # Dump only the raw version string, not the complete object. It's a string for
    # backwards (RubyGems 1.3.5 and earlier) compatibility.
    #
    def marshal_dump: () -> Array[String]

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - marshal_load(array)
    # -->
    # Load custom marshal format. It's a string for backwards (RubyGems 1.3.5 and
    # earlier) compatibility.
    #
    def marshal_load: (Array[String] array) -> void

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - prerelease?()
    # -->
    # A version is considered a prerelease if it contains a letter.
    #
    def prerelease?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - release()
    # -->
    # The release for this version (e.g. 1.2.0.a -> 1.2.0). Non-prerelease versions
    # return themselves.
    #
    def release: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - version()
    # -->
    # A string representation of this Version.
    #
    def version: () -> String

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - to_s()
    # -->
    #
    alias to_s version
  end
end
# <!-- rdoc-file=lib/rubygems.rb -->
# RubyGems is the Ruby standard for publishing and managing third party
# libraries.
#
# For user documentation, see:
#
# *   `gem help` and `gem help [command]`
# *   [RubyGems User Guide](https://guides.rubygems.org/)
# *   [Frequently Asked Questions](https://guides.rubygems.org/faqs)
#
# For gem developer documentation see:
#
# *   [Creating Gems](https://guides.rubygems.org/make-your-own-gem)
# *   Gem::Specification
# *   Gem::Version for version dependency notes
#
# Further RubyGems documentation can be found at:
#
# *   [RubyGems Guides](https://guides.rubygems.org)
# *   [RubyGems API](https://www.rubydoc.info/github/rubygems/rubygems) (also
#     available from `gem server`)
#
# ## RubyGems Plugins
#
# RubyGems will load plugins in the latest version of each installed gem or
# $LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
# placed at the root of your gem's #require_path.  Plugins are installed at a
# special location and loaded on boot.
#
# For an example plugin, see the [Graph gem](https://github.com/seattlerb/graph)
# which adds a `gem graph` command.
#
# ## RubyGems Defaults, Packaging
#
# RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
# RubyGems or implementing Ruby you can change RubyGems' defaults.
#
# For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# If you need RubyGems to perform extra work on install or uninstall, your
# defaults override file can set pre/post install and uninstall hooks. See
# Gem::pre_install, Gem::pre_uninstall, Gem::post_install, Gem::post_uninstall.
#
# ## Bugs
#
# You can submit bugs to the [RubyGems bug
# tracker](https://github.com/rubygems/rubygems/issues) on GitHub
#
# ## Credits
#
# RubyGems is currently maintained by Eric Hodel.
#
# RubyGems was originally developed at RubyConf 2003 by:
#
# *   Rich Kilmer  -- rich(at)infoether.com
# *   Chad Fowler  -- chad(at)chadfowler.com
# *   David Black  -- dblack(at)wobblini.net
# *   Paul Brannan -- paul(at)atdesk.com
# *   Jim Weirich   -- jim(at)weirichhouse.org
#
# Contributors:
#
# *   Gavin Sinclair     -- gsinclair(at)soyabean.com.au
# *   George Marrows     -- george.marrows(at)ntlworld.com
# *   Dick Davies        -- rasputnik(at)hellooperator.net
# *   Mauricio Fernandez -- batsman.geo(at)yahoo.com
# *   Simon Strandgaard  -- neoneye(at)adslhome.dk
# *   Dave Glasser       -- glasser(at)mit.edu
# *   Paul Duncan        -- pabs(at)pablotron.org
# *   Ville Aine         -- vaine(at)cs.helsinki.fi
# *   Eric Hodel         -- drbrain(at)segment7.net
# *   Daniel Berger      -- djberg96(at)gmail.com
# *   Phil Hagelberg     -- technomancy(at)gmail.com
# *   Ryan Davis         -- ryand-ruby(at)zenspider.com
# *   Evan Phoenix       -- evan(at)fallingsnow.net
# *   Steve Klabnik      -- steve(at)steveklabnik.com
#
# (If your name is missing, PLEASE let us know!)
#
# ## License
#
# See
# [LICENSE.txt](https://github.com/rubygems/rubygems/blob/master/LICENSE.txt)
# for permissions.
#
# Thanks!
#
# -The RubyGems Team
#
# <!-- rdoc-file=lib/rubygems/deprecate.rb -->
# Provides 3 methods for declaring when something is going away.
#
# +deprecate(name, repl, year, month)+:
#     Indicate something may be removed on/after a certain date.
#
# +rubygems_deprecate(name, replacement=:none)+:
#     Indicate something will be removed in the next major RubyGems version,
#     and (optionally) a replacement for it.
#
# `rubygems_deprecate_command`:
#     Indicate a RubyGems command (in +lib/rubygems/commands/*.rb+) will be
#     removed in the next RubyGems version.
#
# Also provides `skip_during` for temporarily turning off deprecation warnings.
# This is intended to be used in the test suite, so deprecation warnings don't
# cause test failures if you need to make sure stderr is otherwise empty.
#
# Example usage of `deprecate` and `rubygems_deprecate`:
#
#     class Legacy
#       def self.some_class_method
#         # ...
#       end
#
#       def some_instance_method
#         # ...
#       end
#
#       def some_old_method
#         # ...
#       end
#
#       extend Gem::Deprecate
#       deprecate :some_instance_method, "X.z", 2011, 4
#       rubygems_deprecate :some_old_method, "Modern#some_new_method"
#
#       class << self
#         extend Gem::Deprecate
#         deprecate :some_class_method, :none, 2011, 4
#       end
#     end
#
# Example usage of `rubygems_deprecate_command`:
#
#     class Gem::Commands::QueryCommand < Gem::Command
#       extend Gem::Deprecate
#       rubygems_deprecate_command
#
#       # ...
#     end
#
# Example usage of `skip_during`:
#
#     class TestSomething < Gem::Testcase
#       def test_some_thing_with_deprecations
#         Gem::Deprecate.skip_during do
#           actual_stdout, actual_stderr = capture_output do
#             Gem.something_deprecated
#           end
#           assert_empty actual_stdout
#           assert_equal(expected, actual_stderr)
#         end
#       end
#     end
#
module Gem
  interface _HashLike[K, V]
    def each_pair: () { ([ K, V ]) -> untyped } -> self
  end

  DEFAULT_HOST: String

  GEM_DEP_FILES: Array[String]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # When https://bugs.ruby-lang.org/issues/17259 is available, there is no need to
  # override Kernel#warn
  #
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES: bool

  LOADED_SPECS_MUTEX: Thread::Mutex

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Location of Marshal quick gemspecs on remote repositories
  #
  MARSHAL_SPEC_DIR: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Exception classes used in a Gem.read_binary `rescue` statement
  #
  READ_BINARY_ERRORS: Array[Class]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Subdirectories in a gem repository for default gems
  #
  REPOSITORY_DEFAULT_GEM_SUBDIRECTORIES: Array[String]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Subdirectories in a gem repository
  #
  REPOSITORY_SUBDIRECTORIES: Array[String]

  RUBYGEMS_DIR: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Taint support is deprecated in Ruby 2.7. This allows switching ".untaint" to
  # ".tap(&Gem::UNTAINT)", to avoid deprecation warnings in Ruby 2.7.
  #
  UNTAINT: Proc

  VERSION: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # An Array of Regexps that match windows Ruby platforms.
  #
  WIN_PATTERNS: Array[Regexp]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Exception classes used in Gem.write_binary `rescue` statement
  #
  WRITE_BINARY_ERRORS: Array[Class]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - activated_gem_paths()
  # -->
  # The number of paths in the +$LOAD_PATH+ from activated gems. Used to
  # prioritize `-I` and `ENV['RUBYLIB']` entries during `require`.
  #
  def self.activated_gem_paths: () -> Integer

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - add_to_load_path(*paths)
  # -->
  # Add a list of paths to the $LOAD_PATH at the proper place.
  #
  def self.add_to_load_path: (*String paths) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - bin_path(name, exec_name = nil, *requirements)
  # -->
  # Find the full path to the executable for gem `name`.  If the `exec_name` is
  # not given, an exception will be raised, otherwise the specified executable's
  # path is returned.  `requirements` allows you to specify specific gem versions.
  #
  def self.bin_path: (String name, String exec_name, ?Array[Requirement] requirements) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - binary_mode()
  # -->
  # The mode needed to read a file as straight binary.
  #
  def self.binary_mode: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - bindir(install_dir=Gem.dir)
  # -->
  # The path where gem executables are to be installed.
  #
  def self.bindir: (?String install_dir) -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - cache_home()
  # -->
  # The path to standard location of the user's cache directory.
  #
  def self.cache_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - clear_default_specs()
  # -->
  # Clear default gem related variables. It is for test
  #
  def self.clear_default_specs: () -> void

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - clear_paths()
  # -->
  # Reset the `dir` and `path` values.  The next time `dir` or `path` is
  # requested, the values will be calculated from scratch.  This is mainly used by
  # the unit tests to provide test isolation.
  #
  def self.clear_paths: () -> void

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - config_file()
  # -->
  # The path to standard location of the user's .gemrc file.
  #
  def self.config_file: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - config_home()
  # -->
  # The path to standard location of the user's configuration directory.
  #
  def self.config_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - configuration()
  # -->
  # The standard configuration object for gems.
  #
  def self.configuration: () -> ConfigFile

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - configuration=(config)
  # -->
  # Use the given configuration object (which implements the ConfigFile protocol)
  # as the standard configuration object.
  #
  def self.configuration=: (ConfigFile config) -> ConfigFile

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - data_home()
  # -->
  # The path to standard location of the user's data directory.
  #
  def self.data_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_bindir()
  # -->
  # The default directory for binaries
  #
  def self.default_bindir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_cert_path()
  # -->
  # The default signing certificate chain path
  #
  def self.default_cert_path: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_dir()
  # -->
  # Default home directory path to be used if an alternate value is not specified
  # in the environment
  #
  def self.default_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_exec_format()
  # -->
  # Deduce Ruby's --program-prefix and --program-suffix from its install name
  #
  def self.default_exec_format: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_ext_dir_for(base_dir)
  # -->
  # Returns binary extensions dir for specified RubyGems base dir or nil if such
  # directory cannot be determined.
  #
  # By default, the binary extensions are located side by side with their Ruby
  # counterparts, therefore nil is returned
  #
  def self.default_ext_dir_for: (String base_dir) -> String?

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_key_path()
  # -->
  # The default signing key path
  #
  def self.default_key_path: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_path()
  # -->
  # Default gem load path
  #
  def self.default_path: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_rubygems_dirs()
  # -->
  # Paths where RubyGems' .rb files and bin files are installed
  #
  def self.default_rubygems_dirs: () -> Array[String]?

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_sources()
  # -->
  # An Array of the default sources that come with RubyGems
  #
  def self.default_sources: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_spec_cache_dir()
  # -->
  # Default spec directory path to be used if an alternate value is not specified
  # in the environment
  #
  def self.default_spec_cache_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_specifications_dir()
  # -->
  # Path to specification files of default gems.
  #
  def self.default_specifications_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - deflate(data)
  # -->
  # A Zlib::Deflate.deflate wrapper
  #
  def self.deflate: (String data) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - dir()
  # -->
  # The path where gems are to be installed.
  #
  def self.dir: () -> String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # RubyGems distributors (like operating system package managers) can disable
  # RubyGems update by setting this to error message printed to end-users on gem
  # update --system instead of actual update.
  #
  def self.disable_system_update_message: () -> String?

  # <!-- rdoc-file=lib/rubygems.rb -->
  # RubyGems distributors (like operating system package managers) can disable
  # RubyGems update by setting this to error message printed to end-users on gem
  # update --system instead of actual update.
  #
  def self.disable_system_update_message=: (String?) -> String?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - done_installing(&hook)
  # -->
  # Adds a post-installs hook that will be passed a Gem::DependencyInstaller and a
  # list of installed specifications when Gem::DependencyInstaller#install is
  # complete
  #
  def self.done_installing: () { (DependencyInstaller, Array[Specification]) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::DependencyInstaller installs a set of
  # gems
  #
  def self.done_installing_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ensure_default_gem_subdirectories(dir = Gem.dir, mode = nil)
  # -->
  # Quietly ensure the Gem directory `dir` contains all the proper subdirectories
  # for handling default gems.  If we can't create a directory due to a permission
  # problem, then we will silently continue.
  #
  # If `mode` is given, missing directories are created with this mode.
  #
  # World-writable directories will never be created.
  #
  def self.ensure_default_gem_subdirectories: (?String dir, ?Integer | String mode) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ensure_gem_subdirectories(dir = Gem.dir, mode = nil)
  # -->
  # Quietly ensure the Gem directory `dir` contains all the proper subdirectories.
  #  If we can't create a directory due to a permission problem, then we will
  # silently continue.
  #
  # If `mode` is given, missing directories are created with this mode.
  #
  # World-writable directories will never be created.
  #
  def self.ensure_gem_subdirectories: (?String dir, ?Integer | String mode) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - env_requirement(gem_name)
  # -->
  #
  def self.env_requirement: (String gem_name) -> Requirement

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - find_config_file()
  # -->
  # Finds the user's config file
  #
  def self.find_config_file: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_files(glob, check_load_path=true)
  # -->
  # Returns a list of paths matching `glob` that can be used by a gem to pick up
  # features from other gems.  For example:
  #
  #     Gem.find_files('rdoc/discover').each do |path| load path end
  #
  # if `check_load_path` is true (the default), then find_files also searches
  # $LOAD_PATH for files as well as gems.
  #
  # Note that find_files will return all files even if they are from different
  # versions of the same gem.  See also find_latest_files
  #
  def self.find_files: (String glob, ?boolish check_load_path) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_latest_files(glob, check_load_path=true)
  # -->
  # Returns a list of paths matching `glob` from the latest gems that can be used
  # by a gem to pick up features from other gems.  For example:
  #
  #     Gem.find_latest_files('rdoc/discover').each do |path| load path end
  #
  # if `check_load_path` is true (the default), then find_latest_files also
  # searches $LOAD_PATH for files as well as gems.
  #
  # Unlike find_files, find_latest_files will return only files from the latest
  # version of a gem.
  #
  def self.find_latest_files: (String glob, ?boolish check_load_path) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_unresolved_default_spec(path)
  # -->
  # Find an unresolved Gem::Specification of default gem from `path`
  #
  def self.find_unresolved_default_spec: (String path) -> Specification?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - finish_resolve(request_set=Gem::RequestSet.new)
  # -->
  #
  def self.finish_resolve: (?RequestSet request_set) -> void

  # <!-- rdoc-file=lib/rubygems.rb -->
  # GemDependencyAPI object, which is set when .use_gemdeps is called. This
  # contains all the information from the Gemfile.
  #
  def self.gemdeps: () -> RequestSet::GemDependencyAPI?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - host()
  # -->
  # Get the default RubyGems API host. This is normally `https://rubygems.org`.
  #
  def self.host: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - host=(host)
  # -->
  # Set the default RubyGems API host.
  #
  def self.host=: (String host) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - install(name, version = Gem::Requirement.default, *options)
  # -->
  # Top level install helper method. Allows you to install gems interactively:
  #
  #     % irb
  #     >> Gem.install "minitest"
  #     Fetching: minitest-5.14.0.gem (100%)
  #     => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]
  #
  def self.install: (String name, ?Gem::Requirement version, *DependencyInstaller::options options) -> Array[Specification]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - java_platform?()
  # -->
  # Is this a java platform?
  #
  def self.java_platform?: () -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_rubygems_version()
  # -->
  # Returns the latest release version of RubyGems.
  #
  def self.latest_rubygems_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_spec_for(name)
  # -->
  # Returns the latest release-version specification for the gem `name`.
  #
  def self.latest_spec_for: (String name) -> Specification?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_version_for(name)
  # -->
  # Returns the version of the latest release-version of gem `name`
  #
  def self.latest_version_for: (String name) -> Version?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_env_plugins()
  # -->
  # Find all 'rubygems_plugin' files in $LOAD_PATH and load them
  #
  def self.load_env_plugins: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_path_insert_index()
  # -->
  # The index to insert activated gem paths into the $LOAD_PATH. The activated
  # gem's paths are inserted before site lib directory by default.
  #
  def self.load_path_insert_index: () -> Integer

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_plugins()
  # -->
  # Find rubygems plugin files in the standard location and load them
  #
  def self.load_plugins: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_yaml()
  # -->
  # Loads YAML, preferring Psych
  #
  def self.load_yaml: () -> bool?

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Hash of loaded Gem::Specification keyed by name
  #
  def self.loaded_specs: () -> Hash[String, BasicSpecification]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - location_of_caller(depth = 1)
  # -->
  # The file name and line number of the caller of the caller of this method.
  #
  # `depth` is how many layers up the call stack it should go.
  #
  # e.g.,
  #
  # def a; Gem.location_of_caller; end a #=> ["x.rb", 2]  # (it'll vary depending
  # on file name and line number)
  #
  # def b; c; end def c; Gem.location_of_caller(2); end b #=> ["x.rb", 6]  #
  # (it'll vary depending on file name and line number)
  #
  def self.location_of_caller: (?Integer depth) -> [ String, Integer ]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - marshal_version()
  # -->
  # The version of the Marshal format for your Ruby.
  #
  def self.marshal_version: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - needs() { |rs| ... }
  # -->
  #
  def self.needs: () { (RequestSet) -> void } -> void

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - operating_system_defaults()
  # -->
  # Default options for gem commands for Ruby packagers.
  #
  # The options here should be structured as an array of string "gem" command
  # names as keys and a string of the default options as values.
  #
  # Example:
  #
  # def self.operating_system_defaults
  #     {
  #         'install' => '--no-rdoc --no-ri --env-shebang',
  #         'update' => '--no-rdoc --no-ri --env-shebang'
  #     }
  #
  # end
  #
  def self.operating_system_defaults: () -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - path()
  # -->
  #
  def self.path: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - path_separator()
  # -->
  # How String Gem paths should be split.  Overridable for esoteric platforms.
  #
  def self.path_separator: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - paths()
  # -->
  # Retrieve the PathSupport object that RubyGems uses to lookup files.
  #
  def self.paths: () -> PathSupport

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - paths=(env)
  # -->
  # Initialize the filesystem paths to use from `env`. `env` is a hash-like object
  # (typically ENV) that is queried for 'GEM_HOME', 'GEM_PATH', and
  # 'GEM_SPEC_CACHE' Keys for the `env` hash should be Strings, and values of the
  # hash should be Strings or `nil`.
  #
  def self.paths=: (_HashLike[String, String?] env) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - platform_defaults()
  # -->
  # Default options for gem commands for Ruby implementers.
  #
  # The options here should be structured as an array of string "gem" command
  # names as keys and a string of the default options as values.
  #
  # Example:
  #
  # def self.platform_defaults
  #     {
  #         'install' => '--no-rdoc --no-ri --env-shebang',
  #         'update' => '--no-rdoc --no-ri --env-shebang'
  #     }
  #
  # end
  #
  def self.platform_defaults: () -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - platforms()
  # -->
  # Array of platforms this RubyGems supports.
  #
  def self.platforms: () -> Array[String | Platform]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - platforms=(platforms)
  # -->
  # Set array of platforms this RubyGems supports (primarily for testing).
  #
  def self.platforms=: (Array[String | Platform] platforms) -> Array[String | Platform]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugin_suffix_pattern()
  # -->
  # Glob pattern for require-able plugin suffixes.
  #
  def self.plugin_suffix_pattern: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugin_suffix_regexp()
  # -->
  # Regexp for require-able plugin suffixes.
  #
  def self.plugin_suffix_regexp: () -> Regexp

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugindir(install_dir=Gem.dir)
  # -->
  # The path were rubygems plugins are to be installed.
  #
  def self.plugindir: (?String install_dir) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_build(&hook)
  # -->
  # Adds a post-build hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called.  The hook is called after the gem has been
  # extracted and extensions have been built but before the executables or gemspec
  # has been written.  If the hook returns `false` then the gem's files will be
  # removed and the install will be aborted.
  #
  def self.post_build: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Installer#install extracts files and
  # builds extensions
  #
  def self.post_build_hooks: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_install(&hook)
  # -->
  # Adds a post-install hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called
  #
  def self.post_install: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Installer#install completes
  # installation
  #
  def self.post_install_hooks: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_reset(&hook)
  # -->
  # Adds a hook that will get run after Gem::Specification.reset is run.
  #
  def self.post_reset: () { () -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Specification.reset is run.
  #
  def self.post_reset_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_uninstall(&hook)
  # -->
  # Adds a post-uninstall hook that will be passed a Gem::Uninstaller instance and
  # the spec that was uninstalled when Gem::Uninstaller#uninstall is called
  #
  def self.post_uninstall: () { (Uninstaller) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Uninstaller#uninstall completes
  # installation
  #
  def self.post_uninstall_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_install(&hook)
  # -->
  # Adds a pre-install hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called.  If the hook returns `false` then the
  # install will be aborted.
  #
  def self.pre_install: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Installer#install does any work
  #
  def self.pre_install_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_reset(&hook)
  # -->
  # Adds a hook that will get run before Gem::Specification.reset is run.
  #
  def self.pre_reset: () { () -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Specification.reset is run.
  #
  def self.pre_reset_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_uninstall(&hook)
  # -->
  # Adds a pre-uninstall hook that will be passed an Gem::Uninstaller instance and
  # the spec that will be uninstalled when Gem::Uninstaller#uninstall is called
  #
  def self.pre_uninstall: () { (Uninstaller) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Uninstaller#uninstall does any work
  #
  def self.pre_uninstall_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - prefix()
  # -->
  # The directory prefix this RubyGems was installed at. If your prefix is in a
  # standard location (ie, rubygems is installed where you'd expect it to be),
  # then prefix returns nil.
  #
  def self.prefix: () -> String?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - read_binary(path)
  # -->
  # Safely read a file in binary mode on all platforms.
  #
  def self.read_binary: (String path) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - refresh()
  # -->
  # Refresh available gems from disk.
  #
  def self.refresh: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - register_default_spec(spec)
  # -->
  # Register a Gem::Specification for default gem.
  #
  # Two formats for the specification are supported:
  #
  # *   MRI 2.0 style, where spec.files contains unprefixed require names. The
  #     spec's filenames will be registered as-is.
  # *   New style, where spec.files contains files prefixed with paths from
  #     spec.require_paths. The prefixes are stripped before registering the
  #     spec's filenames. Unprefixed files are omitted.
  #
  def self.register_default_spec: (Specification spec) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby()
  # -->
  # The path to the running Ruby interpreter.
  #
  def self.ruby: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby_api_version()
  # -->
  # Returns a String containing the API compatibility version of Ruby
  #
  def self.ruby_api_version: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - ruby_engine()
  # -->
  #
  def self.ruby_engine: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby_version()
  # -->
  # A Gem::Version for the currently running Ruby.
  #
  def self.ruby_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - rubygems_version()
  # -->
  # A Gem::Version for the currently running RubyGems
  #
  def self.rubygems_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - source_date_epoch()
  # -->
  # Returns the value of Gem.source_date_epoch_string, as a Time object.
  #
  # This is used throughout RubyGems for enabling reproducible builds.
  #
  def self.source_date_epoch: () -> Time

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - source_date_epoch_string()
  # -->
  # If the SOURCE_DATE_EPOCH environment variable is set, returns it's value.
  # Otherwise, returns the time that `Gem.source_date_epoch_string` was first
  # called in the same format as SOURCE_DATE_EPOCH.
  #
  # NOTE(@duckinator): The implementation is a tad weird because we want to:
  #     1. Make builds reproducible by default, by having this function always
  #        return the same result during a given run.
  #     2. Allow changing ENV['SOURCE_DATE_EPOCH'] at runtime, since multiple
  #        tests that set this variable will be run in a single process.
  #
  # If you simplify this function and a lot of tests fail, that is likely due to
  # #2 above.
  #
  # Details on SOURCE_DATE_EPOCH:
  # https://reproducible-builds.org/specs/source-date-epoch/
  #
  def self.source_date_epoch_string: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - sources()
  # -->
  # Returns an Array of sources to fetch remote gems from. Uses default_sources if
  # the sources list is empty.
  #
  def self.sources: () -> SourceList

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - sources=(new_sources)
  # -->
  # Need to be able to set the sources without calling Gem.sources.replace since
  # that would cause an infinite loop.
  #
  # DOC: This comment is not documentation about the method itself, it's more of a
  # code comment about the implementation.
  #
  def self.sources=: (SourceList? new_sources) -> SourceList?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - spec_cache_dir()
  # -->
  #
  def self.spec_cache_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffix_pattern()
  # -->
  # Glob pattern for require-able path suffixes.
  #
  def self.suffix_pattern: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffix_regexp()
  # -->
  # Regexp for require-able path suffixes.
  #
  def self.suffix_regexp: () -> Regexp

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffixes()
  # -->
  # Suffixes for require-able paths.
  #
  def self.suffixes: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - time(msg, width = 0, display = Gem.configuration.verbose) { || ... }
  # -->
  # Prints the amount of time the supplied block takes to run using the debug UI
  # output.
  #
  def self.time: [T] (String msg, ?Integer width, ?boolish display) { () -> T } -> T

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - try_activate(path)
  # -->
  # Try to activate a gem containing `path`. Returns true if activation succeeded
  # or wasn't needed because it was already activated. Returns false if it can't
  # find the path in a gem.
  #
  def self.try_activate: (String path) -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ui()
  # -->
  # Lazily loads DefaultUserInteraction and returns the default UI.
  #
  def self.ui: () -> StreamUI

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - use_gemdeps(path = nil)
  # -->
  # Looks for a gem dependency file at `path` and activates the gems in the file
  # if found.  If the file is not found an ArgumentError is raised.
  #
  # If `path` is not given the RUBYGEMS_GEMDEPS environment variable is used, but
  # if no file is found no exception is raised.
  #
  # If '-' is given for `path` RubyGems searches up from the current working
  # directory for gem dependency files (gem.deps.rb, Gemfile, Isolate) and
  # activates the gems in the first one found.
  #
  # You can run this automatically when rubygems starts.  To enable, set the
  # `RUBYGEMS_GEMDEPS` environment variable to either the path of your gem
  # dependencies file or "-" to auto-discover in parent directories.
  #
  # NOTE: Enabling automatic discovery on multiuser systems can lead to execution
  # of arbitrary code when used from directories outside your control.
  #
  def self.use_gemdeps: (?String path) -> void

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - use_paths(home, *paths)
  # -->
  # Use the `home` and `paths` values for Gem.dir and Gem.path.  Used mainly by
  # the unit tests to provide environment isolation.
  #
  def self.use_paths: (String home, *String paths) -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - user_dir()
  # -->
  # Path for gems in the user's home directory
  #
  def self.user_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - user_home()
  # -->
  # The home directory for the user.
  #
  def self.user_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - win_platform?()
  # -->
  # Is this a windows platform?
  #
  def self.win_platform?: () -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - write_binary(path, data)
  # -->
  # Safely write a file in binary mode on all platforms.
  #
  def self.write_binary: (String path, String data) -> Integer
end
# <!-- rdoc-file=lib/rubygems/dependency_installer.rb -->
# Installs a gem along with all its dependencies from local and remote gems.
#
class Gem::DependencyInstaller
  type options = Hash[Symbol, untyped]
end
# <!-- rdoc-file=lib/rubygems/request_set.rb -->
# A RequestSet groups a request to activate a set of dependencies.
#
#     nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
#     pg = Gem::Dependency.new 'pg', '~> 0.14'
#
#     set = Gem::RequestSet.new nokogiri, pg
#
#     requests = set.resolve
#
#     p requests.map { |r| r.full_name }
#     #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
#
class Gem::RequestSet
end

# <!-- rdoc-file=lib/rubygems/request_set/gem_dependency_api.rb -->
# A semi-compatible DSL for the Bundler Gemfile and Isolate gem dependencies
# files.
#
# To work with both the Bundler Gemfile and Isolate formats this implementation
# takes some liberties to allow compatibility with each, most notably in
# #source.
#
# A basic gem dependencies file will look like the following:
#
#     source 'https://rubygems.org'
#
#     gem 'rails', '3.2.14a
#     gem 'devise', '~> 2.1', '>= 2.1.3'
#     gem 'cancan'
#     gem 'airbrake'
#     gem 'pg'
#
# RubyGems recommends saving this as gem.deps.rb over Gemfile or Isolate.
#
# To install the gems in this Gemfile use `gem install -g` to install it and
# create a lockfile.  The lockfile will ensure that when you make changes to
# your gem dependencies file a minimum amount of change is made to the
# dependencies of your gems.
#
# RubyGems can activate all the gems in your dependencies file at startup using
# the RUBYGEMS_GEMDEPS environment variable or through Gem.use_gemdeps. See
# Gem.use_gemdeps for details and warnings.
#
# See `gem help install` and `gem help gem_dependencies` for further details.
#
class Gem::RequestSet::GemDependencyAPI
end
# <!-- rdoc-file=lib/rubygems/source_list.rb -->
# The SourceList represents the sources rubygems has been configured to use. A
# source may be created from an array of sources:
#
#     Gem::SourceList.from %w[https://rubygems.example https://internal.example]
#
# Or by adding them:
#
#     sources = Gem::SourceList.new
#     sources << 'https://rubygems.example'
#
# The most common way to get a SourceList is Gem.sources.
#
class Gem::SourceList
end
# <!-- rdoc-file=lib/rubygems/platform.rb -->
# Available list of platforms for targeting Gem installations.
#
# See `gem help platform` for information on platform matching.
#
class Gem::Platform
end
# <!-- rdoc-file=lib/rubygems/config_file.rb -->
# Gem::ConfigFile RubyGems options and gem command options from gemrc.
#
# gemrc is a YAML file that uses strings to match gem command arguments and
# symbols to match RubyGems options.
#
# Gem command arguments use a String key that matches the command name and allow
# you to specify default arguments:
#
#     install: --no-rdoc --no-ri
#     update: --no-rdoc --no-ri
#
# You can use `gem:` to set default arguments for all commands.
#
# RubyGems options use symbol keys.  Valid options are:
#
# `:backtrace`
# :   See #backtrace
#
# `:sources`
# :   Sets Gem::sources
#
# `:verbose`
# :   See #verbose
#
# `:concurrent_downloads`
# :   See #concurrent_downloads
#
#
# gemrc files may exist in various locations and are read and merged in the
# following order:
#
# *   system wide (/etc/gemrc)
# *   per user (~/.gemrc)
# *   per environment (gemrc files listed in the GEMRC environment variable)
#
class Gem::ConfigFile
end
# <!-- rdoc-file=lib/rubygems.rb -->
# RubyGems is the Ruby standard for publishing and managing third party
# libraries.
#
# For user documentation, see:
#
# *   `gem help` and `gem help [command]`
# *   [RubyGems User Guide](https://guides.rubygems.org/)
# *   [Frequently Asked Questions](https://guides.rubygems.org/faqs)
#
# For gem developer documentation see:
#
# *   [Creating Gems](https://guides.rubygems.org/make-your-own-gem)
# *   Gem::Specification
# *   Gem::Version for version dependency notes
#
# Further RubyGems documentation can be found at:
#
# *   [RubyGems Guides](https://guides.rubygems.org)
# *   [RubyGems API](https://www.rubydoc.info/github/rubygems/rubygems) (also
#     available from `gem server`)
#
# ## RubyGems Plugins
#
# RubyGems will load plugins in the latest version of each installed gem or
# $LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
# placed at the root of your gem's #require_path.  Plugins are installed at a
# special location and loaded on boot.
#
# For an example plugin, see the [Graph gem](https://github.com/seattlerb/graph)
# which adds a `gem graph` command.
#
# ## RubyGems Defaults, Packaging
#
# RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
# RubyGems or implementing Ruby you can change RubyGems' defaults.
#
# For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# If you need RubyGems to perform extra work on install or uninstall, your
# defaults override file can set pre/post install and uninstall hooks. See
# Gem::pre_install, Gem::pre_uninstall, Gem::post_install, Gem::post_uninstall.
#
# ## Bugs
#
# You can submit bugs to the [RubyGems bug
# tracker](https://github.com/rubygems/rubygems/issues) on GitHub
#
# ## Credits
#
# RubyGems is currently maintained by Eric Hodel.
#
# RubyGems was originally developed at RubyConf 2003 by:
#
# *   Rich Kilmer  -- rich(at)infoether.com
# *   Chad Fowler  -- chad(at)chadfowler.com
# *   David Black  -- dblack(at)wobblini.net
# *   Paul Brannan -- paul(at)atdesk.com
# *   Jim Weirich   -- jim(at)weirichhouse.org
#
# Contributors:
#
# *   Gavin Sinclair     -- gsinclair(at)soyabean.com.au
# *   George Marrows     -- george.marrows(at)ntlworld.com
# *   Dick Davies        -- rasputnik(at)hellooperator.net
# *   Mauricio Fernandez -- batsman.geo(at)yahoo.com
# *   Simon Strandgaard  -- neoneye(at)adslhome.dk
# *   Dave Glasser       -- glasser(at)mit.edu
# *   Paul Duncan        -- pabs(at)pablotron.org
# *   Ville Aine         -- vaine(at)cs.helsinki.fi
# *   Eric Hodel         -- drbrain(at)segment7.net
# *   Daniel Berger      -- djberg96(at)gmail.com
# *   Phil Hagelberg     -- technomancy(at)gmail.com
# *   Ryan Davis         -- ryand-ruby(at)zenspider.com
# *   Evan Phoenix       -- evan(at)fallingsnow.net
# *   Steve Klabnik      -- steve(at)steveklabnik.com
#
# (If your name is missing, PLEASE let us know!)
#
# ## License
#
# See
# [LICENSE.txt](https://github.com/rubygems/rubygems/blob/master/LICENSE.txt)
# for permissions.
#
# Thanks!
#
# -The RubyGems Team
#
# <!-- rdoc-file=lib/rubygems/deprecate.rb -->
# Provides 3 methods for declaring when something is going away.
#
# +deprecate(name, repl, year, month)+:
#     Indicate something may be removed on/after a certain date.
#
# +rubygems_deprecate(name, replacement=:none)+:
#     Indicate something will be removed in the next major RubyGems version,
#     and (optionally) a replacement for it.
#
# `rubygems_deprecate_command`:
#     Indicate a RubyGems command (in +lib/rubygems/commands/*.rb+) will be
#     removed in the next RubyGems version.
#
# Also provides `skip_during` for temporarily turning off deprecation warnings.
# This is intended to be used in the test suite, so deprecation warnings don't
# cause test failures if you need to make sure stderr is otherwise empty.
#
# Example usage of `deprecate` and `rubygems_deprecate`:
#
#     class Legacy
#       def self.some_class_method
#         # ...
#       end
#
#       def some_instance_method
#         # ...
#       end
#
#       def some_old_method
#         # ...
#       end
#
#       extend Gem::Deprecate
#       deprecate :some_instance_method, "X.z", 2011, 4
#       rubygems_deprecate :some_old_method, "Modern#some_new_method"
#
#       class << self
#         extend Gem::Deprecate
#         deprecate :some_class_method, :none, 2011, 4
#       end
#     end
#
# Example usage of `rubygems_deprecate_command`:
#
#     class Gem::Commands::QueryCommand < Gem::Command
#       extend Gem::Deprecate
#       rubygems_deprecate_command
#
#       # ...
#     end
#
# Example usage of `skip_during`:
#
#     class TestSomething < Gem::Testcase
#       def test_some_thing_with_deprecations
#         Gem::Deprecate.skip_during do
#           actual_stdout, actual_stderr = capture_output do
#             Gem.something_deprecated
#           end
#           assert_empty actual_stdout
#           assert_equal(expected, actual_stderr)
#         end
#       end
#     end
#
module Gem
  # <!-- rdoc-file=lib/rubygems/errors.rb -->
  # Raised when RubyGems is unable to load or activate a gem.  Contains the name
  # and version requirements of the gem that either conflicts with already
  # activated gems or that RubyGems is otherwise unable to activate.
  #
  class LoadError < ::LoadError
  end

  # <!-- rdoc-file=lib/rubygems/errors.rb -->
  # Raised when trying to activate a gem, and that gem does not exist on the
  # system.  Instead of rescuing from this class, make sure to rescue from the
  # superclass Gem::LoadError to catch all types of load errors.
  #
  class MissingSpecError
  end
end
# <!-- rdoc-file=lib/rubygems/basic_specification.rb -->
# BasicSpecification is an abstract class which implements some common code used
# by both Specification and StubSpecification.
#
class Gem::BasicSpecification
end
# <!-- rdoc-file=lib/rubygems/specification.rb -->
# The Specification class contains the information for a gem.  Typically defined
# in a .gemspec file or a Rakefile, and looks like this:
#
#     Gem::Specification.new do |s|
#       s.name        = 'example'
#       s.version     = '0.1.0'
#       s.licenses    = ['MIT']
#       s.summary     = "This is an example!"
#       s.description = "Much longer explanation of the example!"
#       s.authors     = ["Ruby Coder"]
#       s.email       = 'rubycoder@example.com'
#       s.files       = ["lib/example.rb"]
#       s.homepage    = 'https://rubygems.org/gems/example'
#       s.metadata    = { "source_code_uri" => "https://github.com/example/example" }
#     end
#
# Starting in RubyGems 2.0, a Specification can hold arbitrary metadata.  See
# #metadata for restrictions on the format and size of metadata items you may
# add to a specification.
#
class Gem::Specification < Gem::BasicSpecification
end
%a{annotate:rdoc:skip}
module Gem
  # <!-- rdoc-file=lib/rubygems/requirement.rb -->
  # A Requirement is a set of one or more version restrictions. It supports a few
  # (`=, !=, >, <, >=, <=, ~>`) different restriction operators.
  #
  # See Gem::Version for a description on how versions and requirements work
  # together in RubyGems.
  #
  class Requirement
    type operator = "=" | "!=" | ">" | "<" | ">=" | "<=" | "~>"

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # Raised when a bad requirement is encountered
    #
    class BadRequirementError < ArgumentError
    end

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # The default requirement matches any version
    #
    DefaultPrereleaseRequirement: [ operator, Gem::Version ]

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # The default requirement matches any non-prerelease version
    #
    DefaultRequirement: [ operator, Gem::Version ]

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # A regular expression that matches a requirement
    #
    PATTERN: Regexp

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - create(*inputs)
    # -->
    # Factory method to create a Gem::Requirement object.  Input may be a Version, a
    # String, or nil.  Intended to simplify client code.
    #
    # If the input is "weird", the default version requirement is returned.
    #
    def self.create: (*String | Gem::Version | Gem::Requirement | nil inputs) -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - default()
    # -->
    #
    def self.default: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - default_prerelease()
    # -->
    #
    def self.default_prerelease: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - parse(obj)
    # -->
    # Parse `obj`, returning an `[op, version]` pair. `obj` can be a String or a
    # Gem::Version.
    #
    # If `obj` is a String, it can be either a full requirement specification, like
    # `">= 1.2"`, or a simple version number, like `"1.2"`.
    #
    #     parse("> 1.0")                 # => [">", Gem::Version.new("1.0")]
    #     parse("1.0")                   # => ["=", Gem::Version.new("1.0")]
    #     parse(Gem::Version.new("1.0")) # => ["=,  Gem::Version.new("1.0")]
    #
    def self.parse: (String | Gem::Version obj) -> [ operator, Gem::Version ]

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - new(*requirements)
    # -->
    # Constructs a requirement from `requirements`. Requirements can be Strings,
    # Gem::Versions, or Arrays of those. `nil` and duplicate requirements are
    # ignored. An empty set of `requirements` is the same as `">= 0"`.
    #
    def initialize: (*String | Gem::Version requirements) -> void

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - concat(new)
    # -->
    # Concatenates the `new` requirements onto this requirement.
    #
    def concat: (Array[String | Gem::Version] new) -> void

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - exact?()
    # -->
    # true if the requirement is for only an exact version
    #
    def exact?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - none?()
    # -->
    # true if this gem has no requirements.
    #
    def none?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - prerelease?()
    # -->
    # A requirement is a prerelease if any of the versions inside of it are
    # prereleases
    #
    def prerelease?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - satisfied_by?(version)
    # -->
    # True if `version` satisfies this Requirement.
    #
    def satisfied_by?: (Gem::Version version) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - ===(version)
    # -->
    #
    alias === satisfied_by?

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - =~(version)
    # -->
    #
    alias =~ satisfied_by?

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - specific?()
    # -->
    # True if the requirement will not always match the latest version.
    #
    def specific?: () -> bool
  end
end
# <!-- rdoc-file=lib/rubygems/path_support.rb -->
# Gem::PathSupport facilitates the GEM_HOME and GEM_PATH environment settings to
# the rest of RubyGems.
#
class Gem::PathSupport
end
# <!-- rdoc-file=lib/rubygems/uninstaller.rb -->
# An Uninstaller.
#
# The uninstaller fires pre and post uninstall hooks.  Hooks can be added either
# through a rubygems_plugin.rb file in an installed gem or via a
# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
# file.  See Gem.pre_uninstall and Gem.post_uninstall for details.
#
class Gem::Uninstaller
end
# <!-- rdoc-file=re.c -->
# MatchData encapsulates the result of matching a Regexp against string. It is
# returned by Regexp#match and String#match, and also stored in a global
# variable returned by Regexp.last_match.
#
# Usage:
#
#     url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
#     m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
#     m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
#     m.regexp                    # => /(\d\.?)+/
#     # entire matched substring:
#     m[0]                        # => "2.5.0"
#
#     # Working with unnamed captures
#     m = url.match(%r{([^/]+)/([^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
#     # Working with named captures
#     m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
#     m[:version]                 # => "2.5.0"
#     m.values_at(:version, :module)
#                                 # => ["2.5.0", "MatchData"]
#     # Numerical indexes are working, too
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
# ## Global variables equivalence
#
# Parts of last MatchData (returned by Regexp.last_match) are also aliased as
# global variables:
#
# *   `$~` is Regexp.last_match;
# *   `$&` is Regexp.last_match`[ 0 ]`;
# *   `$1`, `$2`, and so on are Regexp.last_match`[ i ]` (captures by number);
# *   `$`` is Regexp.last_match`.pre_match`;
# *   `$'` is Regexp.last_match`.post_match`;
# *   `$+` is Regexp.last_match`[ -1 ]` (the last capture).
#
# See also "Special global variables" section in Regexp documentation.
#
class MatchData
  type capture = String | Symbol | int

  def initialize_copy: (MatchData instance) -> self

  # <!-- rdoc-file=re.c -->
  # Returns `true` if `object` is another MatchData object whose target string,
  # regexp, match, and captures are the same as `self`, `false` otherwise.
  #
  def ==: (MatchData other) -> bool
        | (untyped) -> false

  # <!--
  #   rdoc-file=re.c
  #   - matchdata[index] -> string or nil
  #   - matchdata[start, length] -> array
  #   - matchdata[range] -> array
  #   - matchdata[name] -> string or nil
  # -->
  # When arguments `index`, +start and `length`, or `range` are given, returns
  # match and captures in the style of Array#[]:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0] # => "HX1138"
  #     m[1, 2]  # => ["H", "X"]
  #     m[1..3]  # => ["H", "X", "113"]
  #     m[-3, 2] # => ["X", "113"]
  #
  # When string or symbol argument `name` is given, returns the matched substring
  # for the given name:
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" bar:"ge">
  #     m['foo'] # => "h"
  #     m[:bar]  # => "ge"
  #
  # If multiple captures have the same name, returns the last matched substring.
  #
  #     m = /(?<foo>.)(?<foo>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" foo:"oge">
  #     m[:foo] #=> "oge"
  #
  #     m = /\W(?<foo>.+)|\w(?<foo>.+)|(?<foo>.+)/.match("hoge")
  #     #<MatchData "hoge" foo:nil foo:"oge" foo:nil>
  #     m[:foo] #=> "oge"
  #
  def []: (capture backref, ?nil) -> String?
        | (int start, int length) -> Array[String?]
        | (range[int?] range) -> Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - begin(n) -> integer
  #   - begin(name) -> integer
  # -->
  # Returns the offset (in characters) of the beginning of the specified match.
  #
  # When non-negative integer argument `n` is given, returns the offset of the
  # beginning of the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       # => "HX1138"
  #     m.begin(0) # => 1
  #     m[3]       # => "113"
  #     m.begin(3) # => 3
  #
  #     m = /()()()/.match('')
  #     # => #<MatchData "" 1:"" 2:"" 3:"">
  #     m[0]       # => ""
  #     m.begin(0) # => 0
  #     m[3]       # => ""
  #     m.begin(3) # => 2
  #
  # When string or symbol argument `name` is given, returns the offset of the
  # beginning for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"g">
  #     m[:foo]        # => "h"
  #     m.begin('foo') # => 0
  #     m[:bar]        # => "g"
  #     m.begin(:bar)  # => 2
  #
  # Related: MatchData#end, MatchData#offset, MatchData#byteoffset.
  #
  def begin: (capture backref) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - bytebegin(n) -> integer
  #   - bytebegin(name) -> integer
  # -->
  # Returns the offset (in bytes) of the beginning of the specified match.
  #
  # When non-negative integer argument `n` is given, returns the offset of the
  # beginning of the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       # => "HX1138"
  #     m.bytebegin(0) # => 1
  #     m[3]       # => "113"
  #     m.bytebegin(3) # => 3
  #
  #     m = /()()()/.match('')
  #     # => #<MatchData "" 1:"" 2:"" 3:"">
  #     m[0]       # => ""
  #     m.bytebegin(0) # => 0
  #     m[3]       # => ""
  #     m.bytebegin(3) # => 4
  #
  # When string or symbol argument `name` is given, returns the offset of the
  # beginning for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"g">
  #     m[:foo]        # => "h"
  #     m.bytebegin('foo') # => 0
  #     m[:bar]        # => "g"
  #     m.bytebegin(:bar)  # => 2
  #
  # Related: MatchData#byteend, MatchData#byteoffset.
  #
  def bytebegin: (capture backref) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - byteend(n) -> integer
  #   - byteend(name) -> integer
  # -->
  # Returns the offset (in bytes) of the end of the specified match.
  #
  # When non-negative integer argument `n` is given, returns the offset of the end
  # of the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]     # => "HX1138"
  #     m.byteend(0) # => 7
  #     m[3]     # => "113"
  #     m.byteend(3) # => 6
  #
  #     m = /()()()/.match('')
  #     # => #<MatchData "" 1:"" 2:"" 3:"">
  #     m[0]     # => ""
  #     m.byteend(0) # => 6
  #     m[3]     # => ""
  #     m.byteend(3) # => 6
  #
  # When string or symbol argument `name` is given, returns the offset of the end
  # for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"g">
  #     m[:foo]      # => "h"
  #     m.byteend('foo') # => 1
  #     m[:bar]      # => "g"
  #     m.byteend(:bar)  # => 3
  #
  # Related: MatchData#bytebegin, MatchData#byteoffset.
  #
  def byteend: (capture backref) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.byteoffset(n)   -> array
  # -->
  # Returns a two-element array containing the beginning and ending byte-based
  # offsets of the *n*th match. *n* can be a string or symbol to reference a named
  # capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.byteoffset(0)      #=> [1, 7]
  #     m.byteoffset(4)      #=> [6, 7]
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.byteoffset(:foo) #=> [0, 1]
  #     p m.byteoffset(:bar) #=> [2, 3]
  #
  def byteoffset: (capture backref) -> ([Integer, Integer] | [nil, nil])

  # <!--
  #   rdoc-file=re.c
  #   - captures -> array
  # -->
  # Returns the array of captures, which are all matches except `m[0]`:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       # => "HX1138"
  #     m.captures # => ["H", "X", "113", "8"]
  #
  # Related: MatchData.to_a.
  #
  def captures: () -> Array[String?]

  # <!-- rdoc-file=re.c -->
  # Returns the array of captures, which are all matches except `m[0]`:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       # => "HX1138"
  #     m.captures # => ["H", "X", "113", "8"]
  #
  # Related: MatchData.to_a.
  #
  alias deconstruct captures

  # <!--
  #   rdoc-file=re.c
  #   - deconstruct_keys(array_of_names) -> hash
  # -->
  # Returns a hash of the named captures for the given names.
  #
  #     m = /(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})/.match("18:37:22")
  #     m.deconstruct_keys([:hours, :minutes]) # => {:hours => "18", :minutes => "37"}
  #     m.deconstruct_keys(nil) # => {:hours => "18", :minutes => "37", :seconds => "22"}
  #
  # Returns an empty hash if no named captures were defined:
  #
  #     m = /(\d{2}):(\d{2}):(\d{2})/.match("18:37:22")
  #     m.deconstruct_keys(nil) # => {}
  #
  def deconstruct_keys: (Array[Symbol]? array_of_names) -> Hash[Symbol, String?]

  # <!--
  #   rdoc-file=re.c
  #   - end(n) -> integer
  #   - end(name) -> integer
  # -->
  # Returns the offset (in characters) of the end of the specified match.
  #
  # When non-negative integer argument `n` is given, returns the offset of the end
  # of the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]     # => "HX1138"
  #     m.end(0) # => 7
  #     m[3]     # => "113"
  #     m.end(3) # => 6
  #
  #     m = /()()()/.match('')
  #     # => #<MatchData "" 1:"" 2:"" 3:"">
  #     m[0]     # => ""
  #     m.end(0) # => 3
  #     m[3]     # => ""
  #     m.end(3) # => 3
  #
  # When string or symbol argument `name` is given, returns the offset of the end
  # for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"g">
  #     m[:foo]      # => "h"
  #     m.end('foo') # => 1
  #     m[:bar]      # => "g"
  #     m.end(:bar)  # => 3
  #
  # Related: MatchData#begin, MatchData#offset, MatchData#byteoffset.
  #
  def end: (capture backref) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - matchdata == object -> true or false
  # -->
  # Returns `true` if `object` is another MatchData object whose target string,
  # regexp, match, and captures are the same as `self`, `false` otherwise.
  #
  alias eql? ==

  # <!--
  #   rdoc-file=re.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`, based on the target string, regexp,
  # match, and captures.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     m = /.$/.match("foo")
  #     # => #<MatchData "o">
  #     m.inspect # => "#<MatchData \"o\">"
  #
  #     m = /(.)(.)(.)/.match("foo")
  #     # => #<MatchData "foo" 1:"f" 2:"o" 3:"o">
  #     m.inspect # => "#<MatchData \"foo\" 1:\"f\" 2:\"o\
  #
  #     m = /(.)(.)?(.)/.match("fo")
  #     # => #<MatchData "fo" 1:"f" 2:nil 3:"o">
  #     m.inspect # => "#<MatchData \"fo\" 1:\"f\" 2:nil 3:\"o\">"
  #
  # Related: MatchData#to_s.
  #
  def inspect: () -> String

  # <!-- rdoc-file=re.c -->
  # Returns size of the match array:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.size # => 5
  #
  alias length size

  # <!--
  #   rdoc-file=re.c
  #   - named_captures(symbolize_names: false) -> hash
  # -->
  # Returns a hash of the named captures; each key is a capture name; each value
  # is its captured string or `nil`:
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" bar:"ge">
  #     m.named_captures # => {"foo"=>"h", "bar"=>"ge"}
  #
  #     m = /(?<a>.)(?<b>.)/.match("01")
  #     # => #<MatchData "01" a:"0" b:"1">
  #     m.named_captures #=> {"a" => "0", "b" => "1"}
  #
  #     m = /(?<a>.)(?<b>.)?/.match("0")
  #     # => #<MatchData "0" a:"0" b:nil>
  #     m.named_captures #=> {"a" => "0", "b" => nil}
  #
  #     m = /(?<a>.)(?<a>.)/.match("01")
  #     # => #<MatchData "01" a:"0" a:"1">
  #     m.named_captures #=> {"a" => "1"}
  #
  # If keyword argument `symbolize_names` is given a true value, the keys in the
  # resulting hash are Symbols:
  #
  #     m = /(?<a>.)(?<a>.)/.match("01")
  #     # => #<MatchData "01" a:"0" a:"1">
  #     m.named_captures(symbolize_names: true) #=> {:a => "1"}
  #
  def named_captures: () -> Hash[String, String?]
                    | (symbolize_names: true) -> Hash[Symbol, String?]
                    | (symbolize_names: boolish) -> Hash[String | Symbol, String?]

  # <!--
  #   rdoc-file=re.c
  #   - names -> array_of_names
  # -->
  # Returns an array of the capture names (see [Named
  # Captures](rdoc-ref:Regexp@Named+Captures)):
  #
  #     m = /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"o" baz:"g">
  #     m.names # => ["foo", "bar", "baz"]
  #
  #     m = /foo/.match('foo') # => #<MatchData "foo">
  #     m.names # => [] # No named captures.
  #
  # Equivalent to:
  #
  #     m = /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge")
  #     m.regexp.names # => ["foo", "bar", "baz"]
  #
  def names: () -> Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - match(n) -> string or nil
  #   - match(name) -> string or nil
  # -->
  # Returns the matched substring corresponding to the given argument.
  #
  # When non-negative argument `n` is given, returns the matched substring for the
  # `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8" 5:nil>
  #     m.match(0) # => "HX1138"
  #     m.match(4) # => "8"
  #     m.match(5) # => nil
  #
  # When string or symbol argument `name` is given, returns the matched substring
  # for the given name:
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" bar:"ge">
  #     m.match('foo') # => "h"
  #     m.match(:bar)  # => "ge"
  #
  def match: (capture backref) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - match_length(n) -> integer or nil
  #   - match_length(name) -> integer or nil
  # -->
  # Returns the length (in characters) of the matched substring corresponding to
  # the given argument.
  #
  # When non-negative argument `n` is given, returns the length of the matched
  # substring for the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8" 5:nil>
  #     m.match_length(0) # => 6
  #     m.match_length(4) # => 1
  #     m.match_length(5) # => nil
  #
  # When string or symbol argument `name` is given, returns the length of the
  # matched substring for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" bar:"ge">
  #     m.match_length('foo') # => 1
  #     m.match_length(:bar)  # => 2
  #
  def match_length: (capture backref) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - offset(n) -> [start_offset, end_offset]
  #   - offset(name) -> [start_offset, end_offset]
  # -->
  # Returns a 2-element array containing the beginning and ending offsets (in
  # characters) of the specified match.
  #
  # When non-negative integer argument `n` is given, returns the starting and
  # ending offsets of the `n`th match:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]        # => "HX1138"
  #     m.offset(0) # => [1, 7]
  #     m[3]        # => "113"
  #     m.offset(3) # => [3, 6]
  #
  #     m = /()()()/.match('')
  #     # => #<MatchData "" 1:"" 2:"" 3:"">
  #     m[0]        # => ""
  #     m.offset(0) # => [0, 3]
  #     m[3]        # => ""
  #     m.offset(3) # => [2, 3]
  #
  # When string or symbol argument `name` is given, returns the starting and
  # ending offsets for the named match:
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     # => #<MatchData "hog" foo:"h" bar:"g">
  #     m[:foo]         # => "h"
  #     m.offset('foo') # => [0, 1]
  #     m[:bar]         # => "g"
  #     m.offset(:bar)  # => [2, 3]
  #
  # Related: MatchData#byteoffset, MatchData#begin, MatchData#end.
  #
  def offset: (capture backref) -> ([Integer, Integer] | [nil, nil])

  # <!--
  #   rdoc-file=re.c
  #   - post_match   -> str
  # -->
  # Returns the substring of the target string from the end of the first match in
  # `self` (that is, `self[0]`) to the end of the string; equivalent to regexp
  # global variable `$'`:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]         # => "HX1138"
  #     m.post_match # => ": The Movie"\
  #
  # Related: MatchData.pre_match.
  #
  def post_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - pre_match -> string
  # -->
  # Returns the substring of the target string from its beginning up to the first
  # match in `self` (that is, `self[0]`); equivalent to regexp global variable
  # `$``:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]        # => "HX1138"
  #     m.pre_match # => "T"
  #
  # Related: MatchData#post_match.
  #
  def pre_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - regexp -> regexp
  # -->
  # Returns the regexp that produced the match:
  #
  #     m = /a.*b/.match("abc") # => #<MatchData "ab">
  #     m.regexp                # => /a.*b/
  #
  def regexp: () -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - size -> integer
  # -->
  # Returns size of the match array:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.size # => 5
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - string -> string
  # -->
  # Returns the target string if it was frozen; otherwise, returns a frozen copy
  # of the target string:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.string # => "THX1138."
  #
  def string: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - to_a -> array
  # -->
  # Returns the array of matches:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.to_a # => ["HX1138", "H", "X", "113", "8"]
  #
  # Related: MatchData#captures.
  #
  def to_a: () -> Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - to_s -> string
  # -->
  # Returns the matched string:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.to_s # => "HX1138"
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     # => #<MatchData "hoge" foo:"h" bar:"ge">
  #     m.to_s # => "hoge"
  #
  # Related: MatchData.inspect.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - values_at(*indexes) -> array
  # -->
  # Returns match and captures at the given `indexes`, which may include any
  # mixture of:
  #
  # *   Integers.
  # *   Ranges.
  # *   Names (strings and symbols).
  #
  # Examples:
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     # => #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m.values_at(0, 2, -2) # => ["HX1138", "X", "113"]
  #     m.values_at(1..2, -1) # => ["H", "X", "8"]
  #
  #     m = /(?<a>\d+) *(?<op>[+\-*\/]) *(?<b>\d+)/.match("1 + 2")
  #     # => #<MatchData "1 + 2" a:"1" op:"+" b:"2">
  #     m.values_at(0, 1..2, :a, :b, :op)
  #     # => ["1 + 2", "1", "+", "1", "2", "+"]
  #
  def values_at: (*capture | range[int?] backrefs) -> Array[String?]
end
# <!-- rdoc-file=io.c -->
# ARGF is a stream designed for use in scripts that process files given as
# command-line arguments or passed in via STDIN.
#
# See ARGF (the class) for more details.
#
ARGF: RBS::Unnamed::ARGFClass

# <!-- rdoc-file=ruby.c -->
# ARGV contains the command line arguments used to run ruby.
#
# A library like OptionParser can be used to process command-line arguments.
#
ARGV: Array[String]

CROSS_COMPILING: true?

# <!-- rdoc-file=ruby.c -->
# DATA is a File that contains the data section of the executed file. To create
# a data section use `__END__`:
#
#     $ cat t.rb
#     puts DATA.gets
#     __END__
#     hello world!
#
#     $ ruby t.rb
#     hello world!
#
DATA: File

# <!-- rdoc-file=version.c -->
# The copyright string for ruby
#
RUBY_COPYRIGHT: String

# <!-- rdoc-file=version.c -->
# The full ruby version string, like `ruby -v` prints
#
RUBY_DESCRIPTION: String

# <!-- rdoc-file=version.c -->
# The engine or interpreter this ruby uses.
#
RUBY_ENGINE: String

# <!-- rdoc-file=version.c -->
# The version of the engine or interpreter this ruby uses.
#
RUBY_ENGINE_VERSION: String

# <!-- rdoc-file=version.c -->
# The patchlevel for this ruby.  If this is a development build of ruby the
# patchlevel will be -1
#
RUBY_PATCHLEVEL: Integer

# <!-- rdoc-file=version.c -->
# The platform for this ruby
#
RUBY_PLATFORM: String

# <!-- rdoc-file=version.c -->
# The date this ruby was released
#
RUBY_RELEASE_DATE: String

# <!-- rdoc-file=version.c -->
# The GIT commit hash for this ruby.
#
RUBY_REVISION: String

# <!-- rdoc-file=version.c -->
# The running version of ruby
#
RUBY_VERSION: String

# <!-- rdoc-file=io.c -->
# Holds the original stderr
#
STDERR: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdin
#
STDIN: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdout
#
STDOUT: IO

# <!-- rdoc-file=vm.c -->
# The Binding of the top level scope
#
TOPLEVEL_BINDING: Binding
# <!-- rdoc-file=trace_point.rb -->
# A class that provides the functionality of Kernel#set_trace_func in a
# well-structured Object-Oriented API.
#
# ## Example
#
# Use TracePoint to gather information specifically for exceptions:
#
#     trace = TracePoint.new(:raise) do |tp|
#       p [tp.lineno, tp.event, tp.raised_exception]
#     end
#     #=> #<TracePoint:disabled>
#
#     trace.enable  #=> false
#
#     0 / 0
#     #=> [5, :raise, #<ZeroDivisionError: divided by 0>]
#
# ## Events
#
# If you don't specify the types of events you want to listen for, TracePoint
# will include all available events.
#
# **Note:** Do not depend on the current event set, as this list is subject to
# change. Instead, it is recommended to specify the types of events you want to
# use.
#
# To filter what is traced, you can pass any of the following as `events`:
#
# `:line`
# :   Execute an expression or statement on a new line.
#
# `:class`
# :   Start a class or module definition.
#
# `:end`
# :   Finish a class or module definition.
#
# `:call`
# :   Call a Ruby method.
#
# `:return`
# :   Return from a Ruby method.
#
# `:c_call`
# :   Call a C-language routine.
#
# `:c_return`
# :   Return from a C-language routine.
#
# `:raise`
# :   Raise an exception.
#
# `:rescue`
# :   Rescue an exception.
#
# `:b_call`
# :   Event hook at block entry.
#
# `:b_return`
# :   Event hook at block ending.
#
# `:a_call`
# :   Event hook at all calls (`call`, `b_call`, and `c_call`).
#
# `:a_return`
# :   Event hook at all returns (`return`, `b_return`, and `c_return`).
#
# `:thread_begin`
# :   Event hook at thread beginning.
#
# `:thread_end`
# :   Event hook at thread ending.
#
# `:fiber_switch`
# :   Event hook at fiber switch.
#
# `:script_compiled`
# :   New Ruby code compiled (with `eval`, `load`, or `require`).
#
class TracePoint
  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.new(*events) { |tp| block } -> tp
  # -->
  # Returns a new TracePoint object, not enabled by default.
  #
  # To activate the TracePoint object, use TracePoint#enable:
  #
  #     trace = TracePoint.new(:call) do |tp|
  #       p [tp.lineno, tp.defined_class, tp.method_id, tp.event]
  #     end
  #     #=> #<TracePoint:disabled>
  #
  #     trace.enable  #=> false
  #
  #     puts "Hello, TracePoint!"
  #     # ...
  #     # [48, IRB::Notifier::AbstractNotifier, :printf, :call]
  #     # ...
  #
  # To deactivate the trace, use TracePoint#disable.
  #
  #     trace.disable
  #
  # See TracePoint@Events for possible events and more information.
  #
  # A block must be given; otherwise, an ArgumentError is raised.
  #
  # If the trace method isn't included in the given events filter, a RuntimeError
  # is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #       p tp.raised_exception
  #     end
  #     #=> RuntimeError: 'raised_exception' not supported by this event
  #
  # If the trace method is called outside a block, a RuntimeError is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #       $tp = tp
  #     end
  #     $tp.lineno #=> access from outside (RuntimeError)
  #
  # Access from other threads is also forbidden.
  #
  def self.new: (*_ToSym events) { (instance tp) -> void } -> instance

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.allow_reentry { block }
  # -->
  # Generally, while a TracePoint callback is running, other registered callbacks
  # are not called to avoid confusion from reentrance. This method allows
  # reentrance within a given block. Use this method carefully to avoid infinite
  # callback invocation.
  #
  # If called when reentrance is already allowed, it raises a RuntimeError.
  #
  # **Example:**
  #
  #     # Without reentry
  #     # ---------------
  #
  #     line_handler = TracePoint.new(:line) do |tp|
  #       next if tp.path != __FILE__ # Only works in this file
  #       puts "Line handler"
  #       binding.eval("class C; end")
  #     end.enable
  #
  #     class_handler = TracePoint.new(:class) do |tp|
  #       puts "Class handler"
  #     end.enable
  #
  #     class B
  #     end
  #
  #     # This script will print "Class handler" only once: when inside the :line
  #     # handler, all other handlers are ignored.
  #
  #     # With reentry
  #     # ------------
  #
  #     line_handler = TracePoint.new(:line) do |tp|
  #       next if tp.path != __FILE__ # Only works in this file
  #       next if (__LINE__..__LINE__+3).cover?(tp.lineno) # Prevent infinite calls
  #       puts "Line handler"
  #       TracePoint.allow_reentry { binding.eval("class C; end") }
  #     end.enable
  #
  #     class_handler = TracePoint.new(:class) do |tp|
  #       puts "Class handler"
  #     end.enable
  #
  #     class B
  #     end
  #
  #     # This will print "Class handler" twice: inside the allow_reentry block in the :line
  #     # handler, other handlers are enabled.
  #
  # Note that the example shows the principal effect of the method, but its
  # practical usage is for debugging libraries that sometimes require other
  # libraries' hooks to not be affected by the debugger being inside trace point
  # handling. Precautions should be taken against infinite recursion in this case
  # (note that we needed to filter out calls by itself from the :line handler,
  # otherwise it would call itself infinitely).
  #
  def self.allow_reentry: [T] () { (nil) -> T } -> T

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.stat -> obj
  # -->
  # Returns internal information of TracePoint.
  #
  # The contents of the returned value are implementation-specific and may change
  # in the future.
  #
  # This method is only for debugging TracePoint itself.
  #
  def self.stat: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.trace(*events) { |tp| block } -> obj
  # -->
  # A convenience method for TracePoint.new that activates the trace
  # automatically.
  #
  #     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] }
  #     #=> #<TracePoint:enabled>
  #
  #     trace.enabled?  #=> true
  #
  def self.trace: (*_ToSym events) { (instance tp) -> void } -> instance

  # <!--
  #   rdoc-file=trace_point.rb
  #   - binding()
  # -->
  # Returns the generated binding object from the event.
  #
  # Note that for `:c_call` and `:c_return` events, the method returns `nil`,
  # since C methods themselves do not have bindings.
  #
  def binding: () -> Binding?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - callee_id()
  # -->
  # Returns the called name of the method being called.
  #
  def callee_id: () -> Symbol?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - defined_class()
  # -->
  # Returns the class or module of the method being called.
  #
  #     class C; def foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> C
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # If the method is defined by a module, then that module is returned.
  #
  #     module M; def foo; end; end
  #     class C; include M; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> M
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # **Note:** #defined_class returns the singleton class.
  #
  # The 6th block parameter of Kernel#set_trace_func passes the original class
  # attached by the singleton class.
  #
  # **This is a difference between Kernel#set_trace_func and TracePoint.**
  #
  #     class C; def self.foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> #<Class:C>
  #     end.enable do
  #       C.foo
  #     end
  #
  def defined_class: () -> (Class | Module)?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.disable -> true or false
  #   - trace.disable { block } -> obj
  # -->
  # Deactivates the trace.
  #
  # Returns `true` if the trace was enabled. Returns `false` if the trace was
  # disabled.
  #
  #     trace.enabled?  #=> true
  #     trace.disable   #=> true (previous status)
  #     trace.enabled?  #=> false
  #     trace.disable   #=> false
  #
  # If a block is given, the trace will only be disabled within the scope of the
  # block.
  #
  #     trace.enabled?  #=> true
  #
  #     trace.disable do
  #       trace.enabled?
  #       # Only disabled for this block
  #     end
  #
  #     trace.enabled?  #=> true
  #
  # Note: You cannot access event hooks within the block.
  #
  #     trace.disable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def disable: () -> bool
             | [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enable(target: nil, target_line: nil, target_thread: nil) -> true or false
  #   - trace.enable(target: nil, target_line: nil, target_thread: :default) { block } -> obj
  # -->
  # Activates the trace.
  #
  # Returns `true` if the trace was enabled. Returns `false` if the trace was
  # disabled.
  #
  #     trace.enabled?  #=> false
  #     trace.enable    #=> false (previous state)
  #                     #   trace is enabled
  #     trace.enabled?  #=> true
  #     trace.enable    #=> true (previous state)
  #                     #   trace is still enabled
  #
  # If a block is given, the trace will only be enabled during the block
  # execution. If target and target_line are both nil, then target_thread will
  # default to the current thread if a block is given.
  #
  #     trace.enabled?  #=> false
  #
  #     trace.enable do
  #       trace.enabled?
  #       # Only enabled for this block and thread
  #     end
  #
  #     trace.enabled?  #=> false
  #
  # The `target`, `target_line`, and `target_thread` parameters are used to limit
  # tracing to specified code objects. `target` should be a code object for which
  # RubyVM::InstructionSequence.of will return an instruction sequence.
  #
  #     t = TracePoint.new(:line) { |tp| p tp }
  #
  #     def m1
  #       p 1
  #     end
  #
  #     def m2
  #       p 2
  #     end
  #
  #     t.enable(target: method(:m1))
  #
  #     m1
  #     # Prints #<TracePoint:line test.rb:4 in `m1'>
  #     m2
  #     # Prints nothing
  #
  # Note: You cannot access event hooks within the `enable` block.
  #
  #     trace.enable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def enable: (?target: Method | UnboundMethod | RubyVM::InstructionSequence | Proc | nil, ?target_line: int?, ?target_thread: Thread | :default | nil) -> bool
            | [T] (?target: Method | UnboundMethod | RubyVM::InstructionSequence | Proc | nil, ?target_line: int?, ?target_thread: Thread | :default | nil) { () -> T } -> T

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enabled? -> true or false
  # -->
  # Returns the current status of the trace.
  #
  def enabled?: () -> bool

  # <!--
  #   rdoc-file=trace_point.rb
  #   - event()
  # -->
  # Returns the type of event.
  #
  # See TracePoint@Events for more information.
  #
  def event: () -> ::Symbol

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.inspect -> string
  # -->
  # Returns a string containing a human-readable TracePoint status.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - lineno()
  # -->
  # Returns the line number of the event.
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=trace_point.rb
  #   - method_id()
  # -->
  # Returns the name at the definition of the method being called.
  #
  def method_id: () -> Symbol?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - path()
  # -->
  # Returns the path of the file being executed.
  #
  def path: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - parameters()
  # -->
  # Returns the parameter definitions of the method or block that the current hook
  # belongs to. The format is the same as for Method#parameters.
  #
  def parameters: () -> Method::param_types?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - raised_exception()
  # -->
  # Returns the exception raised on the `:raise` event or rescued on the `:rescue`
  # event.
  #
  def raised_exception: () -> Exception

  # <!--
  #   rdoc-file=trace_point.rb
  #   - return_value()
  # -->
  # Returns the return value from `:return`, `:c_return`, and `:b_return` events.
  #
  def return_value: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - self()
  # -->
  # Returns the trace object during the event.
  #
  # Similar to the following, but it returns the correct object (the method
  # receiver) for `:c_call` and `:c_return` events:
  #
  #     trace.binding.eval('self')
  #
  def self: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - eval_script()
  # -->
  # Returns the compiled source code (String) from eval methods on the
  # `:script_compiled` event. If loaded from a file, it returns `nil`.
  #
  def eval_script: () -> String?

  # <!--
  #   rdoc-file=trace_point.rb
  #   - instruction_sequence()
  # -->
  # Returns the compiled instruction sequence represented by a
  # RubyVM::InstructionSequence instance on the `:script_compiled` event.
  #
  # Note that this method is CRuby-specific.
  #
  def instruction_sequence: () -> RubyVM::InstructionSequence
end
# <!-- rdoc-file=object.c -->
# The class of the singleton object `true`.
#
# Several of its methods act as operators:
#
# *   #&
# *   #|
# *   #===
# *   #^
#
# One other method:
#
# *   #to_s and its alias #inspect.
#
class TrueClass
  def !: () -> false

  # <!--
  #   rdoc-file=object.c
  #   - true & object -> true or false
  # -->
  # Returns `false` if `object` is `false` or `nil`, `true` otherwise:
  #
  # true & Object.new # => true true & false      # => false true & nil        #
  # => false
  #
  def &: (false | nil) -> false
       | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - true === other -> true or false
  #   - false === other -> true or false
  #   - nil === other -> true or false
  # -->
  # Returns `true` or `false`.
  #
  # Like Object#==, if `object` is an instance of Object (and not an instance of
  # one of its many subclasses).
  #
  # This method is commonly overridden by those subclasses, to provide meaningful
  # semantics in `case` statements.
  #
  def ===: (true) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - true ^ object -> !object
  # -->
  # Returns `true` if `object` is `false` or `nil`, `false` otherwise:
  #
  #     true ^ Object.new # => false
  #     true ^ false      # => true
  #     true ^ nil        # => true
  #
  def ^: (false | nil) -> true
       | (untyped obj) -> bool

  # <!-- rdoc-file=object.c -->
  # Returns string `'true'`:
  #
  #     true.to_s # => "true"
  #
  # TrueClass#inspect is an alias for TrueClass#to_s.
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - true.to_s -> 'true'
  # -->
  # Returns string `'true'`:
  #
  #     true.to_s # => "true"
  #
  # TrueClass#inspect is an alias for TrueClass#to_s.
  #
  def to_s: () -> "true"

  # <!--
  #   rdoc-file=object.c
  #   - true | object -> true
  # -->
  # Returns `true`:
  #
  #     true | Object.new # => true
  #     true | false      # => true
  #     true | nil        # => true
  #
  # Argument `object` is evaluated. This is different from `true` with the
  # short-circuit operator, whose operand is evaluated only if necessary:
  #
  #     true | raise # => Raises RuntimeError.
  #     true || raise # => true
  #
  def |: (untyped obj) -> true
end
# <!-- rdoc-file=process.c -->
# Module `Process` represents a process in the underlying operating system. Its
# methods support management of the current process and its child processes.
#
# ## Process Creation
#
# Each of the following methods executes a given command in a new process or
# subshell, or multiple commands in new processes and/or subshells. The choice
# of process or subshell depends on the form of the command; see [Argument
# command_line or exe_path](rdoc-ref:Process@Argument+command_line+or+exe_path).
#
# *   Process.spawn, Kernel#spawn: Executes the command; returns the new pid
#     without waiting for completion.
# *   Process.exec: Replaces the current process by executing the command.
#
# In addition:
#
# *   Method Kernel#system executes a given command-line (string) in a subshell;
#     returns `true`, `false`, or `nil`.
# *   Method Kernel#` executes a given command-line (string) in a subshell;
#     returns its $stdout string.
# *   Module Open3 supports creating child processes with access to their
#     $stdin, $stdout, and $stderr streams.
#
# ### Execution Environment
#
# Optional leading argument `env` is a hash of name/value pairs, where each name
# is a string and each value is a string or `nil`; each name/value pair is added
# to ENV in the new process.
#
#     Process.spawn(                'ruby -e "p ENV[\"Foo\"]"')
#     Process.spawn({'Foo' => '0'}, 'ruby -e "p ENV[\"Foo\"]"')
#
# Output:
#
#     "0"
#
# The effect is usually similar to that of calling ENV#update with argument
# `env`, where each named environment variable is created or updated (if the
# value is non-`nil`), or deleted (if the value is `nil`).
#
# However, some modifications to the calling process may remain if the new
# process fails. For example, hard resource limits are not restored.
#
# ### Argument `command_line` or `exe_path`
#
# The required string argument is one of the following:
#
# *   `command_line` if it begins with a shell reserved word or special
#     built-in, or if it contains one or more meta characters.
# *   `exe_path` otherwise.
#
# #### Argument `command_line`
#
# String argument `command_line` is a command line to be passed to a shell; it
# must begin with a shell reserved word, begin with a special built-in, or
# contain meta characters:
#
#     system('if true; then echo "Foo"; fi')          # => true  # Shell reserved word.
#     system('exit')                                  # => true  # Built-in.
#     system('date > /tmp/date.tmp')                  # => true  # Contains meta character.
#     system('date > /nop/date.tmp')                  # => false
#     system('date > /nop/date.tmp', exception: true) # Raises RuntimeError.
#
# The command line may also contain arguments and options for the command:
#
#     system('echo "Foo"') # => true
#
# Output:
#
#     Foo
#
# See [Execution Shell](rdoc-ref:Process@Execution+Shell) for details about the
# shell.
#
# #### Argument `exe_path`
#
# Argument `exe_path` is one of the following:
#
# *   The string path to an executable file to be called:
#
#     Example:
#
#         system('/usr/bin/date') # => true # Path to date on Unix-style system.
#         system('foo')           # => nil  # Command execlution failed.
#
#     Output:
#
#         Thu Aug 31 10:06:48 AM CDT 2023
#
#     A path or command name containing spaces without arguments cannot be
#     distinguished from `command_line` above, so you must quote or escape the
#     entire command name using a shell in platform dependent manner, or use the
#     array form below.
#
#     If `exe_path` does not contain any path separator, an executable file is
#     searched from directories specified with the `PATH` environment variable.
#     What the word "executable" means here is depending on platforms.
#
#     Even if the file considered "executable", its content may not be in proper
#     executable format.  In that case, Ruby tries to run it by using `/bin/sh`
#     on a Unix-like system, like system(3) does.
#
#         File.write('shell_command', 'echo $SHELL', perm: 0o755)
#         system('./shell_command')        # prints "/bin/sh" or something.
#
# *   A 2-element array containing the path to an executable and the string to
#     be used as the name of the executing process:
#
#     Example:
#
#         pid = spawn(['sleep', 'Hello!'], '1') # 2-element array.
#         p `ps -p #{pid} -o command=`
#
#     Output:
#
#         "Hello! 1\n"
#
# ### Arguments `args`
#
# If `command_line` does not contain shell meta characters except for spaces and
# tabs, or `exe_path` is given, Ruby invokes the executable directly.  This form
# does not use the shell:
#
#     spawn("doesnt_exist")       # Raises Errno::ENOENT
#     spawn("doesnt_exist", "\n") # Raises Errno::ENOENT
#
#     spawn("doesnt_exist\n")     # => false
#     # sh: 1: doesnot_exist: not found
#
# The error message is from a shell and would vary depending on your system.
#
# If one or more `args` is given after `exe_path`, each is an argument or option
# to be passed to the executable:
#
# Example:
#
#     system('echo', '<', 'C*', '|', '$SHELL', '>')   # => true
#
# Output:
#
#     < C* | $SHELL >
#
# However, there are exceptions on Windows.  See [Execution Shell on
# Windows](rdoc-ref:Process@Execution+Shell+on+Windows).
#
# If you want to invoke a path containing spaces with no arguments without
# shell, you will need to use a 2-element array `exe_path`.
#
# Example:
#
#     path = '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
#     spawn(path) # Raises Errno::ENOENT; No such file or directory - /Applications/Google
#     spawn([path] * 2)
#
# ### Execution Options
#
# Optional trailing argument `options` is a hash of execution options.
#
# #### Working Directory (`:chdir`)
#
# By default, the working directory for the new process is the same as that of
# the current process:
#
#     Dir.chdir('/var')
#     Process.spawn('ruby -e "puts Dir.pwd"')
#
# Output:
#
#     /var
#
# Use option `:chdir` to set the working directory for the new process:
#
#     Process.spawn('ruby -e "puts Dir.pwd"', {chdir: '/tmp'})
#
# Output:
#
#     /tmp
#
# The working directory of the current process is not changed:
#
#     Dir.pwd # => "/var"
#
# #### File Redirection (File Descriptor)
#
# Use execution options for file redirection in the new process.
#
# The key for such an option may be an integer file descriptor (fd), specifying
# a source, or an array of fds, specifying multiple sources.
#
# An integer source fd may be specified as:
#
# *   *n*: Specifies file descriptor *n*.
#
# There are these shorthand symbols for fds:
#
# *   `:in`: Specifies file descriptor 0 (STDIN).
# *   `:out`: Specifies file descriptor 1 (STDOUT).
# *   `:err`: Specifies file descriptor 2 (STDERR).
#
# The value given with a source is one of:
#
# *   *n*: Redirects to fd *n* in the parent process.
# *   `filepath`: Redirects from or to the file at `filepath` via
#     `open(filepath, mode, 0644)`, where `mode` is `'r'` for source `:in`, or
#     `'w'` for source `:out` or `:err`.
# *   `[filepath]`: Redirects from the file at `filepath` via `open(filepath,
#     'r', 0644)`.
# *   `[filepath, mode]`: Redirects from or to the file at `filepath` via
#     `open(filepath, mode, 0644)`.
# *   `[filepath, mode, perm]`: Redirects from or to the file at `filepath` via
#     `open(filepath, mode, perm)`.
# *   `[:child, fd]`: Redirects to the redirected `fd`.
# *   `:close`: Closes the file descriptor in child process.
#
# See [Access Modes](rdoc-ref:File@Access+Modes) and [File
# Permissions](rdoc-ref:File@File+Permissions).
#
# #### Environment Variables (`:unsetenv_others`)
#
# By default, the new process inherits environment variables from the parent
# process; use execution option key `:unsetenv_others` with value `true` to
# clear environment variables in the new process.
#
# Any changes specified by execution option `env` are made after the new process
# inherits or clears its environment variables; see [Execution
# Environment](rdoc-ref:Process@Execution+Environment).
#
# #### File-Creation Access (`:umask`)
#
# Use execution option `:umask` to set the file-creation access for the new
# process; see [Access Modes](rdoc-ref:File@Access+Modes):
#
#     command = 'ruby -e "puts sprintf(\"0%o\", File.umask)"'
#     options = {:umask => 0644}
#     Process.spawn(command, options)
#
# Output:
#
#     0644
#
# #### Process Groups (`:pgroup` and `:new_pgroup`)
#
# By default, the new process belongs to the same [process
# group](https://en.wikipedia.org/wiki/Process_group) as the parent process.
#
# To specify a different process group. use execution option `:pgroup` with one
# of the following values:
#
# *   `true`: Create a new process group for the new process.
# *   *pgid*: Create the new process in the process group whose id is *pgid*.
#
# On Windows only, use execution option `:new_pgroup` with value `true` to
# create a new process group for the new process.
#
# #### Resource Limits
#
# Use execution options to set resource limits.
#
# The keys for these options are symbols of the form `:rlimit_*resource_name`*,
# where *resource_name* is the downcased form of one of the string resource
# names described at method Process.setrlimit. For example, key `:rlimit_cpu`
# corresponds to resource limit `'CPU'`.
#
# The value for such as key is one of:
#
# *   An integer, specifying both the current and maximum limits.
# *   A 2-element array of integers, specifying the current and maximum limits.
#
# #### File Descriptor Inheritance
#
# By default, the new process inherits file descriptors from the parent process.
#
# Use execution option `:close_others => true` to modify that inheritance by
# closing non-standard fds (3 and greater) that are not otherwise redirected.
#
# ### Execution Shell
#
# On a Unix-like system, the shell invoked is `/bin/sh`; the entire string
# `command_line` is passed as an argument to [shell option
# -c](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/sh.
# html).
#
# The shell performs normal shell expansion on the command line:
#
# Example:
#
#     system('echo $SHELL: C*') # => true
#
# Output:
#
#     /bin/bash: CONTRIBUTING.md COPYING COPYING.ja
#
# #### Execution Shell on Windows
#
# On Windows, the shell invoked is determined by environment variable
# `RUBYSHELL`, if defined, or `COMSPEC` otherwise; the entire string
# `command_line` is passed as an argument to `-c` option for `RUBYSHELL`, as
# well as `/bin/sh`, and [/c
# option](https://learn.microsoft.com/en-us/windows-server/administration/window
# s-commands/cmd) for `COMSPEC`.  The shell is invoked automatically in the
# following cases:
#
# *   The command is a built-in of `cmd.exe`, such as `echo`.
# *   The executable file is a batch file; its name ends with `.bat` or `.cmd`.
#
# Note that the command will still be invoked as `command_line` form even when
# called in `exe_path` form, because `cmd.exe` does not accept a script name
# like `/bin/sh` does but only works with `/c` option.
#
# The standard shell `cmd.exe` performs environment variable expansion but does
# not have globbing functionality:
#
# Example:
#
#     system("echo %COMSPEC%: C*")' # => true
#
# Output:
#
#     C:\WINDOWS\system32\cmd.exe: C*
#
# ## What's Here
#
# ### Current-Process Getters
#
# *   ::argv0: Returns the process name as a frozen string.
# *   ::egid: Returns the effective group ID.
# *   ::euid: Returns the effective user ID.
# *   ::getpgrp: Return the process group ID.
# *   ::getrlimit: Returns the resource limit.
# *   ::gid: Returns the (real) group ID.
# *   ::pid: Returns the process ID.
# *   ::ppid: Returns the process ID of the parent process.
# *   ::uid: Returns the (real) user ID.
#
# ### Current-Process Setters
#
# *   ::egid=: Sets the effective group ID.
# *   ::euid=: Sets the effective user ID.
# *   ::gid=: Sets the (real) group ID.
# *   ::setproctitle: Sets the process title.
# *   ::setpgrp: Sets the process group ID of the process to zero.
# *   ::setrlimit: Sets a resource limit.
# *   ::setsid: Establishes the process as a new session and process group
#     leader, with no controlling tty.
# *   ::uid=: Sets the user ID.
#
# ### Current-Process Execution
#
# *   ::abort: Immediately terminates the process.
# *   ::daemon: Detaches the process from its controlling terminal and continues
#     running it in the background as system daemon.
# *   ::exec: Replaces the process by running a given external command.
# *   ::exit: Initiates process termination by raising exception SystemExit
#     (which may be caught).
# *   ::exit!: Immediately exits the process.
# *   ::warmup: Notifies the Ruby virtual machine that the boot sequence for the
#     application is completed, and that the VM may begin optimizing the
#     application.
#
# ### Child Processes
#
# *   ::detach: Guards against a child process becoming a zombie.
# *   ::fork: Creates a child process.
# *   ::kill: Sends a given signal to processes.
# *   ::spawn: Creates a child process.
# *   ::wait, ::waitpid: Waits for a child process to exit; returns its process
#     ID.
# *   ::wait2, ::waitpid2: Waits for a child process to exit; returns its
#     process ID and status.
# *   ::waitall: Waits for all child processes to exit; returns their process
#     IDs and statuses.
#
# ### Process Groups
#
# *   ::getpgid: Returns the process group ID for a process.
# *   ::getpriority: Returns the scheduling priority for a process, process
#     group, or user.
# *   ::getsid: Returns the session ID for a process.
# *   ::groups: Returns an array of the group IDs in the supplemental group
#     access list for this process.
# *   ::groups=: Sets the supplemental group access list to the given array of
#     group IDs.
# *   ::initgroups: Initializes the supplemental group access list.
# *   ::last_status: Returns the status of the last executed child process in
#     the current thread.
# *   ::maxgroups: Returns the maximum number of group IDs allowed in the
#     supplemental group access list.
# *   ::maxgroups=: Sets the maximum number of group IDs allowed in the
#     supplemental group access list.
# *   ::setpgid: Sets the process group ID of a process.
# *   ::setpriority: Sets the scheduling priority for a process, process group,
#     or user.
#
# ### Timing
#
# *   ::clock_getres: Returns the resolution of a system clock.
# *   ::clock_gettime: Returns the time from a system clock.
# *   ::times: Returns a Process::Tms object containing times for the current
#     process and its child processes.
#
module Process
  # <!--
  #   rdoc-file=process.c
  #   - Process._fork   -> integer
  # -->
  # An internal API for fork. Do not call this method directly. Currently, this is
  # called via Kernel#fork, Process.fork, and IO.popen with `"-"`.
  #
  # This method is not for casual code but for application monitoring libraries.
  # You can add custom code before and after fork events by overriding this
  # method.
  #
  # Note: Process.daemon may be implemented using fork(2) BUT does not go through
  # this method. Thus, depending on your reason to hook into this method, you may
  # also want to hook into that one. See [this
  # issue](https://bugs.ruby-lang.org/issues/18911) for a more detailed discussion
  # of this.
  #
  def self._fork: () -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.argv0  -> frozen_string
  # -->
  # Returns the name of the script being executed.  The value is not affected by
  # assigning a new value to $0.
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to get the script name.
  #
  def self.argv0: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_getres(clock_id, unit = :float_second)  -> number
  # -->
  # Returns a clock resolution as determined by POSIX function
  # [clock_getres()](https://man7.org/linux/man-pages/man3/clock_getres.3.html):
  #
  #     Process.clock_getres(:CLOCK_REALTIME) # => 1.0e-09
  #
  # See Process.clock_gettime for the values of `clock_id` and `unit`.
  #
  # Examples:
  #
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :float_microsecond) # => 0.001
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :float_millisecond) # => 1.0e-06
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :float_second)      # => 1.0e-09
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :microsecond)       # => 0
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :millisecond)       # => 0
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :nanosecond)        # => 1
  #     Process.clock_getres(:CLOCK_PROCESS_CPUTIME_ID, :second)            # => 0
  #
  # In addition to the values for `unit` supported in Process.clock_gettime, this
  # method supports `:hertz`, the integer number of clock ticks per second (which
  # is the reciprocal of `:float_second`):
  #
  #     Process.clock_getres(:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)        # => 100.0
  #     Process.clock_getres(:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID, :float_second) # => 0.01
  #
  # **Accuracy**: Note that the returned resolution may be inaccurate on some
  # platforms due to underlying bugs. Inaccurate resolutions have been reported
  # for various clocks including `:CLOCK_MONOTONIC` and `:CLOCK_MONOTONIC_RAW` on
  # Linux, macOS, BSD or AIX platforms, when using ARM processors, or when using
  # virtualization.
  #
  def self.clock_getres: (Symbol | Integer clock_id, ?Symbol unit) -> (Float | Integer)

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_gettime(clock_id, unit = :float_second) -> number
  # -->
  # Returns a clock time as determined by POSIX function
  # [clock_gettime()](https://man7.org/linux/man-pages/man3/clock_gettime.3.html):
  #
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID) # => 198.650379677
  #
  # Argument `clock_id` should be a symbol or a constant that specifies the clock
  # whose time is to be returned; see below.
  #
  # Optional argument `unit` should be a symbol that specifies the unit to be used
  # in the returned clock time; see below.
  #
  # **Argument `clock_id`**
  #
  # Argument `clock_id` specifies the clock whose time is to be returned; it may
  # be a constant such as `Process::CLOCK_REALTIME`, or a symbol shorthand such as
  # `:CLOCK_REALTIME`.
  #
  # The supported clocks depend on the underlying operating system; this method
  # supports the following clocks on the indicated platforms (raises Errno::EINVAL
  # if called with an unsupported clock):
  #
  # *   `:CLOCK_BOOTTIME`: Linux 2.6.39.
  # *   `:CLOCK_BOOTTIME_ALARM`: Linux 3.0.
  # *   `:CLOCK_MONOTONIC`: SUSv3 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0,
  #     OpenBSD 3.4, macOS 10.12, Windows-2000.
  # *   `:CLOCK_MONOTONIC_COARSE`: Linux 2.6.32.
  # *   `:CLOCK_MONOTONIC_FAST`: FreeBSD 8.1.
  # *   `:CLOCK_MONOTONIC_PRECISE`: FreeBSD 8.1.
  # *   `:CLOCK_MONOTONIC_RAW`: Linux 2.6.28, macOS 10.12.
  # *   `:CLOCK_MONOTONIC_RAW_APPROX`: macOS 10.12.
  # *   `:CLOCK_PROCESS_CPUTIME_ID`: SUSv3 to 4, Linux 2.5.63, FreeBSD 9.3,
  #     OpenBSD 5.4, macOS 10.12.
  # *   `:CLOCK_PROF`: FreeBSD 3.0, OpenBSD 2.1.
  # *   `:CLOCK_REALTIME`: SUSv2 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0,
  #     OpenBSD 2.1, macOS 10.12, Windows-8/Server-2012. Time.now is recommended
  #     over +:CLOCK_REALTIME:.
  # *   `:CLOCK_REALTIME_ALARM`: Linux 3.0.
  # *   `:CLOCK_REALTIME_COARSE`: Linux 2.6.32.
  # *   `:CLOCK_REALTIME_FAST`: FreeBSD 8.1.
  # *   `:CLOCK_REALTIME_PRECISE`: FreeBSD 8.1.
  # *   `:CLOCK_SECOND`: FreeBSD 8.1.
  # *   `:CLOCK_TAI`: Linux 3.10.
  # *   `:CLOCK_THREAD_CPUTIME_ID`: SUSv3 to 4, Linux 2.5.63, FreeBSD 7.1, OpenBSD
  #     5.4, macOS 10.12.
  # *   `:CLOCK_UPTIME`: FreeBSD 7.0, OpenBSD 5.5.
  # *   `:CLOCK_UPTIME_FAST`: FreeBSD 8.1.
  # *   `:CLOCK_UPTIME_PRECISE`: FreeBSD 8.1.
  # *   `:CLOCK_UPTIME_RAW`: macOS 10.12.
  # *   `:CLOCK_UPTIME_RAW_APPROX`: macOS 10.12.
  # *   `:CLOCK_VIRTUAL`: FreeBSD 3.0, OpenBSD 2.1.
  #
  # Note that SUS stands for Single Unix Specification. SUS contains POSIX and
  # clock_gettime is defined in the POSIX part. SUS defines `:CLOCK_REALTIME` as
  # mandatory but `:CLOCK_MONOTONIC`, `:CLOCK_PROCESS_CPUTIME_ID`, and
  # `:CLOCK_THREAD_CPUTIME_ID` are optional.
  #
  # Certain emulations are used when the given `clock_id` is not supported
  # directly:
  #
  # *   Emulations for `:CLOCK_REALTIME`:
  #
  #     *   `:GETTIMEOFDAY_BASED_CLOCK_REALTIME`: Use gettimeofday() defined by
  #         SUS (deprecated in SUSv4). The resolution is 1 microsecond.
  #     *   `:TIME_BASED_CLOCK_REALTIME`: Use time() defined by ISO C. The
  #         resolution is 1 second.
  #
  # *   Emulations for `:CLOCK_MONOTONIC`:
  #
  #     *   `:MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC`: Use mach_absolute_time(),
  #         available on Darwin. The resolution is CPU dependent.
  #     *   `:TIMES_BASED_CLOCK_MONOTONIC`: Use the result value of times()
  #         defined by POSIX, thus:
  # > Upon successful completion, times() shall return the elapsed real
  #           time, in clock ticks, since an arbitrary point in the past (for
  #           example, system start-up time).
  #
  # > For example, GNU/Linux returns a value based on jiffies and it is
  #         monotonic. However, 4.4BSD uses gettimeofday() and it is not
  #         monotonic. (FreeBSD uses `:CLOCK_MONOTONIC` instead, though.)
  #
  #         The resolution is the clock tick. "getconf CLK_TCK" command shows the
  #         clock ticks per second. (The clock ticks-per-second is defined by HZ
  #         macro in older systems.) If it is 100 and clock_t is 32 bits integer
  #         type, the resolution is 10 millisecond and cannot represent over 497
  #         days.
  #
  # *   Emulations for `:CLOCK_PROCESS_CPUTIME_ID`:
  #
  #     *   `:GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID`: Use getrusage() defined
  #         by SUS. getrusage() is used with RUSAGE_SELF to obtain the time only
  #         for the calling process (excluding the time for child processes). The
  #         result is addition of user time (ru_utime) and system time (ru_stime).
  #         The resolution is 1 microsecond.
  #     *   `:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID`: Use times() defined by POSIX.
  #         The result is addition of user time (tms_utime) and system time
  #         (tms_stime). tms_cutime and tms_cstime are ignored to exclude the time
  #         for child processes. The resolution is the clock tick. "getconf
  #         CLK_TCK" command shows the clock ticks per second. (The clock ticks
  #         per second is defined by HZ macro in older systems.) If it is 100, the
  #         resolution is 10 millisecond.
  #     *   `:CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID`: Use clock() defined by ISO C.
  #         The resolution is `1/CLOCKS_PER_SEC`. `CLOCKS_PER_SEC` is the C-level
  #         macro defined by time.h. SUS defines `CLOCKS_PER_SEC` as 1000000;
  #         other systems may define it differently. If `CLOCKS_PER_SEC` is
  #         1000000 (as in SUS), the resolution is 1 microsecond. If
  #         `CLOCKS_PER_SEC` is 1000000 and clock_t is a 32-bit integer type, it
  #         cannot represent over 72 minutes.
  #
  # **Argument `unit`**
  #
  # Optional argument `unit` (default `:float_second`) specifies the unit for the
  # returned value.
  #
  # *   `:float_microsecond`: Number of microseconds as a float.
  # *   `:float_millisecond`: Number of milliseconds as a float.
  # *   `:float_second`: Number of seconds as a float.
  # *   `:microsecond`: Number of microseconds as an integer.
  # *   `:millisecond`: Number of milliseconds as an integer.
  # *   `:nanosecond`: Number of nanoseconds as an integer.
  # *   `::second`: Number of seconds as an integer.
  #
  # Examples:
  #
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :float_microsecond)
  #     # => 203605054.825
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :float_millisecond)
  #     # => 203643.696848
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :float_second)
  #     # => 203.762181929
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :microsecond)
  #     # => 204123212
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :millisecond)
  #     # => 204298
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :nanosecond)
  #     # => 204602286036
  #     Process.clock_gettime(:CLOCK_PROCESS_CPUTIME_ID, :second)
  #     # => 204
  #
  # The underlying function, clock_gettime(), returns a number of nanoseconds.
  # Float object (IEEE 754 double) is not enough to represent the return value for
  # `:CLOCK_REALTIME`. If the exact nanoseconds value is required, use
  # `:nanosecond` as the `unit`.
  #
  # The origin (time zero) of the returned value is system-dependent, and may be,
  # for example, system start up time, process start up time, the Epoch, etc.
  #
  # The origin in `:CLOCK_REALTIME` is defined as the Epoch: `1970-01-01 00:00:00
  # UTC`; some systems count leap seconds and others don't, so the result may vary
  # across systems.
  #
  def self.clock_gettime: (Symbol | Integer clock_id) -> Float
                        | (Symbol | Integer clock_id, :float_second | :float_millisecond | :float_microsecond unit) -> Float
                        | (Symbol | Integer clock_id, :second | :millisecond | :microsecond | :nanosecond unit) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.daemon(nochdir = nil, noclose = nil) -> 0
  # -->
  # Detaches the current process from its controlling terminal and runs it in the
  # background as system daemon; returns zero.
  #
  # By default:
  #
  # *   Changes the current working directory to the root directory.
  # *   Redirects $stdin, $stdout, and $stderr to the null device.
  #
  # If optional argument `nochdir` is `true`, does not change the current working
  # directory.
  #
  # If optional argument `noclose` is `true`, does not redirect $stdin, $stdout,
  # or $stderr.
  #
  def self.daemon: (?untyped nochdir, ?untyped noclose) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.detach(pid) -> thread
  # -->
  # Avoids the potential for a child process to become a [zombie
  # process](https://en.wikipedia.org/wiki/Zombie_process). Process.detach
  # prevents this by setting up a separate Ruby thread whose sole job is to reap
  # the status of the process *pid* when it terminates.
  #
  # This method is needed only when the parent process will never wait for the
  # child process.
  #
  # This example does not reap the second child process; that process appears as a
  # zombie in the process status (`ps`) output:
  #
  #     pid = Process.spawn('ruby', '-e', 'exit 13') # => 312691
  #     sleep(1)
  #     # Find zombies.
  #     system("ps -ho pid,state -p #{pid}")
  #
  # Output:
  #
  #     312716 Z
  #
  # This example also does not reap the second child process, but it does detach
  # the process so that it does not become a zombie:
  #
  #     pid = Process.spawn('ruby', '-e', 'exit 13') # => 313213
  #     thread = Process.detach(pid)
  #     sleep(1)
  #     # => #<Process::Waiter:0x00007f038f48b838 run>
  #     system("ps -ho pid,state -p #{pid}")        # Finds no zombies.
  #
  # The waiting thread can return the pid of the detached child process:
  #
  #     thread.join.pid                       # => 313262
  #
  def self.detach: (Integer pid) -> Process::Waiter

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid        -> integer
  #   - Process::GID.eid    -> integer
  #   - Process::Sys.geteid -> integer
  # -->
  # Returns the effective group ID for the current process:
  #
  #     Process.egid # => 500
  #
  # Not available on all platforms.
  #
  def self.egid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid = new_egid -> new_egid
  # -->
  # Sets the effective group ID for the current process.
  #
  # Not available on all platforms.
  #
  def self.egid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid         -> integer
  #   - Process::UID.eid     -> integer
  #   - Process::Sys.geteuid -> integer
  # -->
  # Returns the effective user ID for the current process.
  #
  #     Process.euid # => 501
  #
  def self.euid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid = new_euid -> new_euid
  # -->
  # Sets the effective user ID for the current process.
  #
  # Not available on all platforms.
  #
  def self.euid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgid(pid) -> integer
  # -->
  # Returns the process group ID for the given process ID +pid+:
  #
  #       Process.getpgid(Process.ppid) # => 25527
  #
  # Not available on all platforms.
  #
  def self.getpgid: (Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgrp -> integer
  # -->
  # Returns the process group ID for the current process:
  #
  #     Process.getpgid(0) # => 25527
  #     Process.getpgrp    # => 25527
  #
  def self.getpgrp: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpriority(kind, id)   -> integer
  # -->
  # Returns the scheduling priority for specified process, process group, or user.
  #
  # Argument `kind` is one of:
  #
  # *   Process::PRIO_PROCESS: return priority for process.
  # *   Process::PRIO_PGRP: return priority for process group.
  # *   Process::PRIO_USER: return priority for user.
  #
  # Argument `id` is the ID for the process, process group, or user; zero
  # specified the current ID for `kind`.
  #
  # Examples:
  #
  #     Process.getpriority(Process::PRIO_USER, 0)    # => 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0) # => 19
  #
  # Not available on all platforms.
  #
  def self.getpriority: (Integer kind, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getrlimit(resource) -> [cur_limit, max_limit]
  # -->
  # Returns a 2-element array of the current (soft) limit and maximum (hard) limit
  # for the given `resource`.
  #
  # Argument `resource` specifies the resource whose limits are to be returned;
  # see Process.setrlimit.
  #
  # Each of the returned values `cur_limit` and `max_limit` is an integer; see
  # Process.setrlimit.
  #
  # Example:
  #
  #     Process.getrlimit(:CORE) # => [0, 18446744073709551615]
  #
  # See Process.setrlimit.
  #
  # Not available on all platforms.
  #
  def self.getrlimit: (interned | Integer resource) -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.getsid(pid = nil) -> integer
  # -->
  # Returns the session ID of the given process ID `pid`, or of the current
  # process if not given:
  #
  #     Process.getsid                # => 27422
  #     Process.getsid(0)             # => 27422
  #     Process.getsid(Process.pid()) # => 27422
  #
  # Not available on all platforms.
  #
  def self.getsid: (?Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid         -> integer
  #   - Process::GID.rid    -> integer
  #   - Process::Sys.getgid -> integer
  # -->
  # Returns the (real) group ID for the current process:
  #
  #     Process.gid # => 1000
  #
  def self.gid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid = new_gid -> new_gid
  # -->
  # Sets the group ID for the current process to `new_gid`:
  #
  #     Process.gid = 1000 # => 1000
  #
  def self.gid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups -> array
  # -->
  # Returns an array of the group IDs in the supplemental group access list for
  # the current process:
  #
  #     Process.groups # => [4, 24, 27, 30, 46, 122, 135, 136, 1000]
  #
  # These properties of the returned array are system-dependent:
  #
  # *   Whether (and how) the array is sorted.
  # *   Whether the array includes effective group IDs.
  # *   Whether the array includes duplicate group IDs.
  # *   Whether the array size exceeds the value of Process.maxgroups.
  #
  # Use this call to get a sorted and unique array:
  #
  #     Process.groups.uniq.sort
  #
  def self.groups: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups = new_groups -> new_groups
  # -->
  # Sets the supplemental group access list to the given array of group IDs.
  #
  #     Process.groups                     # => [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.groups = [27, 6, 10, 11]   # => [27, 6, 10, 11]
  #     Process.groups                     # => [27, 6, 10, 11]
  #
  def self.groups=: (::Array[Integer] arg0) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.initgroups(username, gid) -> array
  # -->
  # Sets the supplemental group access list; the new list includes:
  #
  # *   The group IDs of those groups to which the user given by `username`
  #     belongs.
  # *   The group ID `gid`.
  #
  # Example:
  #
  #     Process.groups                # => [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.initgroups('me', 30)  # => [30, 6, 10, 11]
  #     Process.groups                # => [30, 6, 10, 11]
  #
  # Not available on all platforms.
  #
  def self.initgroups: (String username, Integer gid) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.kill(signal, *ids) -> count
  # -->
  # Sends a signal to each process specified by `ids` (which must specify at least
  # one ID); returns the count of signals sent.
  #
  # For each given `id`, if `id` is:
  #
  # *   Positive, sends the signal to the process whose process ID is `id`.
  # *   Zero, send the signal to all processes in the current process group.
  # *   Negative, sends the signal to a system-dependent collection of processes.
  #
  # Argument `signal` specifies the signal to be sent; the argument may be:
  #
  # *   An integer signal number: e.g., `-29`, `0`, `29`.
  # *   A signal name (string), with or without leading `'SIG'`, and with or
  #     without a further prefixed minus sign (`'-'`): e.g.:
  #
  #     *   `'SIGPOLL'`.
  #     *   `'POLL'`,
  #     *   `'-SIGPOLL'`.
  #     *   `'-POLL'`.
  #
  # *   A signal symbol, with or without leading `'SIG'`, and with or without a
  #     further prefixed minus sign (`'-'`): e.g.:
  #
  #     *   `:SIGPOLL`.
  #     *   `:POLL`.
  #     *   `:'-SIGPOLL'`.
  #     *   `:'-POLL'`.
  #
  # If `signal` is:
  #
  # *   A non-negative integer, or a signal name or symbol without prefixed `'-'`,
  #     each process with process ID `id` is signalled.
  # *   A negative integer, or a signal name or symbol with prefixed `'-'`, each
  #     process group with group ID `id` is signalled.
  #
  # Use method Signal.list to see which signals are supported by Ruby on the
  # underlying platform; the method returns a hash of the string names and
  # non-negative integer values of the supported signals. The size and content of
  # the returned hash varies widely among platforms.
  #
  # Additionally, signal `0` is useful to determine if the process exists.
  #
  # Example:
  #
  #     pid = fork do
  #       Signal.trap('HUP') { puts 'Ouch!'; exit }
  #       # ... do some work ...
  #     end
  #     # ...
  #     Process.kill('HUP', pid)
  #     Process.wait
  #
  # Output:
  #
  #     Ouch!
  #
  # Exceptions:
  #
  # *   Raises Errno::EINVAL or RangeError if `signal` is an integer but invalid.
  # *   Raises ArgumentError if `signal` is a string or symbol but invalid.
  # *   Raises Errno::ESRCH or RangeError if one of `ids` is invalid.
  # *   Raises Errno::EPERM if needed permissions are not in force.
  #
  # In the last two cases, signals may have been sent to some processes.
  #
  def self.kill: (Integer | interned signal, *Integer pids) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups -> integer
  # -->
  # Returns the maximum number of group IDs allowed in the supplemental group
  # access list:
  #
  #     Process.maxgroups # => 32
  #
  def self.maxgroups: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups = new_max -> new_max
  # -->
  # Sets the maximum number of group IDs allowed in the supplemental group access
  # list.
  #
  def self.maxgroups=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.pid -> integer
  # -->
  # Returns the process ID of the current process:
  #
  #     Process.pid # => 15668
  #
  def self.pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.ppid -> integer
  # -->
  # Returns the process ID of the parent of the current process:
  #
  #     puts "Pid is #{Process.pid}."
  #     fork { puts "Parent pid is #{Process.ppid}." }
  #
  # Output:
  #
  #     Pid is 271290.
  #     Parent pid is 271290.
  #
  # May not return a trustworthy value on certain platforms.
  #
  def self.ppid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpgid(pid, pgid) -> 0
  # -->
  # Sets the process group ID for the process given by process ID `pid` to `pgid`.
  #
  # Not available on all platforms.
  #
  def self.setpgid: (Integer pid, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpriority(kind, integer, priority) -> 0
  # -->
  # See Process.getpriority.
  #
  # Examples:
  #
  #     Process.setpriority(Process::PRIO_USER, 0, 19)    # => 0
  #     Process.setpriority(Process::PRIO_PROCESS, 0, 19) # => 0
  #     Process.getpriority(Process::PRIO_USER, 0)        # => 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0)     # => 19
  #
  # Not available on all platforms.
  #
  def self.setpriority: (Integer kind, Integer arg0, Integer priority) -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.setproctitle(string)  -> string
  # -->
  # Sets the process title that appears on the ps(1) command.  Not necessarily
  # effective on all platforms.  No exception will be raised regardless of the
  # result, nor will NotImplementedError be raised even if the platform does not
  # support the feature.
  #
  # Calling this method does not affect the value of $0.
  #
  #     Process.setproctitle('myapp: worker #%d' % worker_id)
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to change the process title.
  #
  def self.setproctitle: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.setrlimit(resource, cur_limit, max_limit = cur_limit) -> nil
  # -->
  # Sets limits for the current process for the given `resource` to `cur_limit`
  # (soft limit) and `max_limit` (hard limit); returns `nil`.
  #
  # Argument `resource` specifies the resource whose limits are to be set; the
  # argument may be given as a symbol, as a string, or as a constant beginning
  # with `Process::RLIMIT_` (e.g., `:CORE`, `'CORE'`, or `Process::RLIMIT_CORE`.
  #
  # The resources available and supported are system-dependent, and may include
  # (here expressed as symbols):
  #
  # *   `:AS`: Total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD
  #     except 4.4BSD-Lite).
  # *   `:CORE`: Core size (bytes) (SUSv3).
  # *   `:CPU`: CPU time (seconds) (SUSv3).
  # *   `:DATA`: Data segment (bytes) (SUSv3).
  # *   `:FSIZE`: File size (bytes) (SUSv3).
  # *   `:MEMLOCK`: Total size for mlock(2) (bytes) (4.4BSD, GNU/Linux).
  # *   `:MSGQUEUE`: Allocation for POSIX message queues (bytes) (GNU/Linux).
  # *   `:NICE`: Ceiling on process's nice(2) value (number) (GNU/Linux).
  # *   `:NOFILE`: File descriptors (number) (SUSv3).
  # *   `:NPROC`: Number of processes for the user (number) (4.4BSD, GNU/Linux).
  # *   `:NPTS`: Number of pseudo terminals (number) (FreeBSD).
  # *   `:RSS`: Resident memory size (bytes) (4.2BSD, GNU/Linux).
  # *   `:RTPRIO`: Ceiling on the process's real-time priority (number)
  #     (GNU/Linux).
  # *   `:RTTIME`: CPU time for real-time process (us) (GNU/Linux).
  # *   `:SBSIZE`: All socket buffers (bytes) (NetBSD, FreeBSD).
  # *   `:SIGPENDING`: Number of queued signals allowed (signals) (GNU/Linux).
  # *   `:STACK`: Stack size (bytes) (SUSv3).
  #
  # Arguments `cur_limit` and `max_limit` may be:
  #
  # *   Integers (`max_limit` should not be smaller than `cur_limit`).
  # *   Symbol `:SAVED_MAX`, string `'SAVED_MAX'`, or constant
  #     `Process::RLIM_SAVED_MAX`: saved maximum limit.
  # *   Symbol `:SAVED_CUR`, string `'SAVED_CUR'`, or constant
  #     `Process::RLIM_SAVED_CUR`: saved current limit.
  # *   Symbol `:INFINITY`, string `'INFINITY'`, or constant
  #     `Process::RLIM_INFINITY`: no limit on resource.
  #
  # This example raises the soft limit of core size to the hard limit to try to
  # make core dump possible:
  #
  #     Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])
  #
  # Not available on all platforms.
  #
  def self.setrlimit: (interned | Integer resource, Integer cur_limit, ?Integer max_limit) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process.setsid -> integer
  # -->
  # Establishes the current process as a new session and process group leader,
  # with no controlling tty; returns the session ID:
  #
  #     Process.setsid # => 27422
  #
  # Not available on all platforms.
  #
  def self.setsid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.times -> process_tms
  # -->
  # Returns a Process::Tms structure that contains user and system CPU times for
  # the current process, and for its children processes:
  #
  #     Process.times
  #     # => #<struct Process::Tms utime=55.122118, stime=35.533068, cutime=0.0, cstime=0.002846>
  #
  # The precision is platform-defined.
  #
  def self.times: () -> Process::Tms

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid         -> integer
  #   - Process::UID.rid    -> integer
  #   - Process::Sys.getuid -> integer
  # -->
  # Returns the (real) user ID of the current process.
  #
  #     Process.uid # => 1000
  #
  def self.uid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid = new_uid -> new_uid
  # -->
  # Sets the (user) user ID for the current process to `new_uid`:
  #
  #     Process.uid = 1000 # => 1000
  #
  # Not available on all platforms.
  #
  def self.uid=: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait(pid = -1, flags = 0) -> integer
  # -->
  # Waits for a suitable child process to exit, returns its process ID, and sets
  # `$?` to a Process::Status object containing information on that process. Which
  # child it waits for depends on the value of the given `pid`:
  #
  # *   Positive integer: Waits for the child process whose process ID is `pid`:
  #
  #         pid0 = Process.spawn('ruby', '-e', 'exit 13') # => 230866
  #         pid1 = Process.spawn('ruby', '-e', 'exit 14') # => 230891
  #         Process.wait(pid0)                            # => 230866
  #         $?                                            # => #<Process::Status: pid 230866 exit 13>
  #         Process.wait(pid1)                            # => 230891
  #         $?                                            # => #<Process::Status: pid 230891 exit 14>
  #         Process.wait(pid0)                            # Raises Errno::ECHILD
  #
  # *   `0`: Waits for any child process whose group ID is the same as that of the
  #     current process:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #         end
  #         retrieved_pid = Process.wait(0)
  #         puts "Process.wait(0) returned pid #{retrieved_pid}, which is child 0 pid."
  #         begin
  #           Process.wait(0)
  #         rescue Errno::ECHILD => x
  #           puts "Raised #{x.class}, because child 1 process group ID differs from parent process group ID."
  #         end
  #
  #     Output:
  #
  #         Parent process group ID is 225764.
  #         Child 0 pid is 225788
  #         Child 0 process group ID is 225764 (same as parent's).
  #         Child 1 pid is 225789
  #         Child 1 process group ID is 225789 (different from parent's).
  #         Process.wait(0) returned pid 225788, which is child 0 pid.
  #         Raised Errno::ECHILD, because child 1 process group ID differs from parent process group ID.
  #
  # *   `-1` (default): Waits for any child process:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #           sleep 3 # To force child 1 to exit later than child 0 exit.
  #         end
  #         child_pids = [child0_pid, child1_pid]
  #         retrieved_pid = Process.wait(-1)
  #         puts child_pids.include?(retrieved_pid)
  #         retrieved_pid = Process.wait(-1)
  #         puts child_pids.include?(retrieved_pid)
  #
  #     Output:
  #
  #         Parent process group ID is 228736.
  #         Child 0 pid is 228758
  #         Child 0 process group ID is 228736 (same as parent's).
  #         Child 1 pid is 228759
  #         Child 1 process group ID is 228759 (different from parent's).
  #         true
  #         true
  #
  # *   Less than `-1`: Waits for any child whose process group ID is `-pid`:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #         end
  #         sleep 1
  #         retrieved_pid = Process.wait(-child1_pid)
  #         puts "Process.wait(-child1_pid) returned pid #{retrieved_pid}, which is child 1 pid."
  #         begin
  #           Process.wait(-child1_pid)
  #         rescue Errno::ECHILD => x
  #           puts "Raised #{x.class}, because there's no longer a child with process group id #{child1_pid}."
  #         end
  #
  #     Output:
  #
  #         Parent process group ID is 230083.
  #         Child 0 pid is 230108
  #         Child 0 process group ID is 230083 (same as parent's).
  #         Child 1 pid is 230109
  #         Child 1 process group ID is 230109 (different from parent's).
  #         Process.wait(-child1_pid) returned pid 230109, which is child 1 pid.
  #         Raised Errno::ECHILD, because there's no longer a child with process group id 230109.
  #
  # Argument `flags` should be given as one of the following constants, or as the
  # logical OR of both:
  #
  # *   Process::WNOHANG: Does not block if no child process is available.
  # *   Process::WUNTRACED: May return a stopped child process, even if not yet
  #     reported.
  #
  # Not all flags are available on all platforms.
  #
  # Raises Errno::ECHILD if there is no suitable child process.
  #
  # Not available on all platforms.
  #
  # Process.waitpid is an alias for Process.wait.
  #
  def self.wait: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid = -1, flags = 0) -> [pid, status]
  # -->
  # Like Process.waitpid, but returns an array containing the child process `pid`
  # and Process::Status `status`:
  #
  #     pid = Process.spawn('ruby', '-e', 'exit 13') # => 309581
  #     Process.wait2(pid)
  #     # => [309581, #<Process::Status: pid 309581 exit 13>]
  #
  # Process.waitpid2 is an alias for Process.wait2.
  #
  def self.wait2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.waitall -> array
  # -->
  # Waits for all children, returns an array of 2-element arrays; each subarray
  # contains the integer pid and Process::Status status for one of the reaped
  # child processes:
  #
  #     pid0 = Process.spawn('ruby', '-e', 'exit 13') # => 325470
  #     pid1 = Process.spawn('ruby', '-e', 'exit 14') # => 325495
  #     Process.waitall
  #     # => [[325470, #<Process::Status: pid 325470 exit 13>], [325495, #<Process::Status: pid 325495 exit 14>]]
  #
  def self.waitall: () -> ::Array[[ Integer, Process::Status ]]

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait(pid = -1, flags = 0) -> integer
  # -->
  # Waits for a suitable child process to exit, returns its process ID, and sets
  # `$?` to a Process::Status object containing information on that process. Which
  # child it waits for depends on the value of the given `pid`:
  #
  # *   Positive integer: Waits for the child process whose process ID is `pid`:
  #
  #         pid0 = Process.spawn('ruby', '-e', 'exit 13') # => 230866
  #         pid1 = Process.spawn('ruby', '-e', 'exit 14') # => 230891
  #         Process.wait(pid0)                            # => 230866
  #         $?                                            # => #<Process::Status: pid 230866 exit 13>
  #         Process.wait(pid1)                            # => 230891
  #         $?                                            # => #<Process::Status: pid 230891 exit 14>
  #         Process.wait(pid0)                            # Raises Errno::ECHILD
  #
  # *   `0`: Waits for any child process whose group ID is the same as that of the
  #     current process:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #         end
  #         retrieved_pid = Process.wait(0)
  #         puts "Process.wait(0) returned pid #{retrieved_pid}, which is child 0 pid."
  #         begin
  #           Process.wait(0)
  #         rescue Errno::ECHILD => x
  #           puts "Raised #{x.class}, because child 1 process group ID differs from parent process group ID."
  #         end
  #
  #     Output:
  #
  #         Parent process group ID is 225764.
  #         Child 0 pid is 225788
  #         Child 0 process group ID is 225764 (same as parent's).
  #         Child 1 pid is 225789
  #         Child 1 process group ID is 225789 (different from parent's).
  #         Process.wait(0) returned pid 225788, which is child 0 pid.
  #         Raised Errno::ECHILD, because child 1 process group ID differs from parent process group ID.
  #
  # *   `-1` (default): Waits for any child process:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #           sleep 3 # To force child 1 to exit later than child 0 exit.
  #         end
  #         child_pids = [child0_pid, child1_pid]
  #         retrieved_pid = Process.wait(-1)
  #         puts child_pids.include?(retrieved_pid)
  #         retrieved_pid = Process.wait(-1)
  #         puts child_pids.include?(retrieved_pid)
  #
  #     Output:
  #
  #         Parent process group ID is 228736.
  #         Child 0 pid is 228758
  #         Child 0 process group ID is 228736 (same as parent's).
  #         Child 1 pid is 228759
  #         Child 1 process group ID is 228759 (different from parent's).
  #         true
  #         true
  #
  # *   Less than `-1`: Waits for any child whose process group ID is `-pid`:
  #
  #         parent_pgpid = Process.getpgid(Process.pid)
  #         puts "Parent process group ID is #{parent_pgpid}."
  #         child0_pid = fork do
  #           puts "Child 0 pid is #{Process.pid}"
  #           child0_pgid = Process.getpgid(Process.pid)
  #           puts "Child 0 process group ID is #{child0_pgid} (same as parent's)."
  #         end
  #         child1_pid = fork do
  #           puts "Child 1 pid is #{Process.pid}"
  #           Process.setpgid(0, Process.pid)
  #           child1_pgid = Process.getpgid(Process.pid)
  #           puts "Child 1 process group ID is #{child1_pgid} (different from parent's)."
  #         end
  #         sleep 1
  #         retrieved_pid = Process.wait(-child1_pid)
  #         puts "Process.wait(-child1_pid) returned pid #{retrieved_pid}, which is child 1 pid."
  #         begin
  #           Process.wait(-child1_pid)
  #         rescue Errno::ECHILD => x
  #           puts "Raised #{x.class}, because there's no longer a child with process group id #{child1_pid}."
  #         end
  #
  #     Output:
  #
  #         Parent process group ID is 230083.
  #         Child 0 pid is 230108
  #         Child 0 process group ID is 230083 (same as parent's).
  #         Child 1 pid is 230109
  #         Child 1 process group ID is 230109 (different from parent's).
  #         Process.wait(-child1_pid) returned pid 230109, which is child 1 pid.
  #         Raised Errno::ECHILD, because there's no longer a child with process group id 230109.
  #
  # Argument `flags` should be given as one of the following constants, or as the
  # logical OR of both:
  #
  # *   Process::WNOHANG: Does not block if no child process is available.
  # *   Process::WUNTRACED: May return a stopped child process, even if not yet
  #     reported.
  #
  # Not all flags are available on all platforms.
  #
  # Raises Errno::ECHILD if there is no suitable child process.
  #
  # Not available on all platforms.
  #
  # Process.waitpid is an alias for Process.wait.
  #
  def self.waitpid: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid = -1, flags = 0) -> [pid, status]
  # -->
  # Like Process.waitpid, but returns an array containing the child process `pid`
  # and Process::Status `status`:
  #
  #     pid = Process.spawn('ruby', '-e', 'exit 13') # => 309581
  #     Process.wait2(pid)
  #     # => [309581, #<Process::Status: pid 309581 exit 13>]
  #
  # Process.waitpid2 is an alias for Process.wait2.
  #
  def self.waitpid2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.warmup    -> true
  # -->
  # Notify the Ruby virtual machine that the boot sequence is finished, and that
  # now is a good time to optimize the application. This is useful for long
  # running applications.
  #
  # This method is expected to be called at the end of the application boot. If
  # the application is deployed using a pre-forking model, `Process.warmup` should
  # be called in the original process before the first fork.
  #
  # The actual optimizations performed are entirely implementation specific and
  # may change in the future without notice.
  #
  # On CRuby, `Process.warmup`:
  #
  # *   Performs a major GC.
  # *   Compacts the heap.
  # *   Promotes all surviving objects to the old generation.
  # *   Precomputes the coderange of all strings.
  # *   Frees all empty heap pages and increments the allocatable pages counter by
  #     the number of pages freed.
  # *   Invoke `malloc_trim` if available to free empty malloc pages.
  #
  def self.warmup: () -> bool
end

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_RAW: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_PROCESS_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_THREAD_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PGRP: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PROCESS: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_USER: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's virtual memory (address space) in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_AS: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the core file.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CORE: Integer

# <!-- rdoc-file=process.c -->
# CPU time limit in seconds.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CPU: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's data segment.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_DATA: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of files that the process may create.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_FSIZE: Integer

# <!-- rdoc-file=process.c -->
# Maximum number of bytes of memory that may be locked into RAM.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MEMLOCK: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit on the number of bytes that can be allocated for POSIX
# message queues for the real user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MSGQUEUE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling to which the process's nice value can be raised.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NICE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a value one greater than the maximum file descriptor number that can
# be opened by this process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NOFILE: Integer

# <!-- rdoc-file=process.c -->
# The maximum number of processes that can be created for the real user ID of
# the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NPROC: Integer

# <!-- rdoc-file=process.c -->
# The maximum number of pseudo-terminals that can be created for the real user
# ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NPTS: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit (in pages) of the process's resident set.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RSS: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling on the real-time priority that may be set for this
# process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTPRIO: Integer

# <!-- rdoc-file=process.c -->
# Specifies limit on CPU time this process scheduled under a real-time
# scheduling policy can consume.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTTIME: Integer

# <!-- rdoc-file=process.c -->
# Specifies a limit on the number of signals that may be queued for the real
# user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_SIGPENDING: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the stack, in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_STACK: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_INFINITY: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_CUR: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_MAX: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WNOHANG: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WUNTRACED: Integer

# <!-- rdoc-file=process.c -->
# The Process::GID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved group IDs.
#
module Process::GID
  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.change_privilege(group)   -> integer
  # -->
  # Change the current process's real and effective group ID to that specified by
  # *group*. Returns the new group ID. Not available on all platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.change_privilege(33)    #=> 33
  #     [Process.gid, Process.egid]          #=> [33, 33]
  #
  def self.change_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid        -> integer
  #   - Process::GID.eid    -> integer
  #   - Process::Sys.geteid -> integer
  # -->
  # Returns the effective group ID for the current process:
  #
  #     Process.egid # => 500
  #
  # Not available on all platforms.
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.from_name(name)   -> gid
  # -->
  # Get the group ID by the *name*. If the group is not found, `ArgumentError`
  # will be raised.
  #
  #     Process::GID.from_name("wheel") #=> 0
  #     Process::GID.from_name("nosuchgroup") #=> can't find group for nosuchgroup (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.grant_privilege(group)    -> integer
  #   - Process::GID.eid = group               -> integer
  # -->
  # Set the effective group ID, and if possible, the saved group ID of the process
  # to the given *group*. Returns the new effective group ID. Not available on all
  # platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.grant_privilege(31)     #=> 33
  #     [Process.gid, Process.egid]          #=> [0, 33]
  #
  def self.grant_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchange   -> integer
  # -->
  # Exchange real and effective group IDs and return the new effective group ID.
  # Not available on all platforms.
  #
  #     [Process.gid, Process.egid]   #=> [0, 33]
  #     Process::GID.re_exchange      #=> 0
  #     [Process.gid, Process.egid]   #=> [33, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective group IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid         -> integer
  #   - Process::GID.rid    -> integer
  #   - Process::Sys.getgid -> integer
  # -->
  # Returns the (real) group ID for the current process:
  #
  #     Process.gid # => 1000
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved group ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.switch              -> integer
  #   - Process::GID.switch {|| block}   -> object
  # -->
  # Switch the effective and real group IDs of the current process. If a *block*
  # is given, the group IDs will be switched back after the block is executed.
  # Returns the new effective group ID if called without a block, and the return
  # value of the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer group) -> Integer
end

# <!-- rdoc-file=process.c -->
# A Process::Status contains information about a system process.
#
# Thread-local variable `$?` is initially `nil`. Some methods assign to it a
# Process::Status object that represents a system process (either running or
# terminated):
#
#     `ruby -e "exit 99"`
#     stat = $?       # => #<Process::Status: pid 1262862 exit 99>
#     stat.class      # => Process::Status
#     stat.to_i       # => 25344
#     stat.stopped?   # => false
#     stat.exited?    # => true
#     stat.exitstatus # => 99
#
class Process::Status < Object
  # <!--
  #   rdoc-file=process.c
  #   - stat & mask -> integer
  # -->
  # This method is deprecated as #to_i value is system-specific; use predicate
  # methods like #exited? or #stopped?, or getters like #exitstatus or #stopsig.
  #
  # Returns the logical AND of the value of #to_i with `mask`:
  #
  #     `cat /nop`
  #     stat = $?                 # => #<Process::Status: pid 1155508 exit 1>
  #     sprintf('%x', stat.to_i)  # => "100"
  #     stat & 0x00               # => 0
  #
  # ArgumentError is raised if `mask` is negative.
  #
  def &: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat == other -> true or false
  # -->
  # Returns whether the value of #to_i == `other`:
  #
  #     `cat /nop`
  #     stat = $?                # => #<Process::Status: pid 1170366 exit 1>
  #     sprintf('%x', stat.to_i) # => "100"
  #     stat == 0x100            # => true
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat >> places -> integer
  # -->
  # This method is deprecated as #to_i value is system-specific; use predicate
  # methods like #exited? or #stopped?, or getters like #exitstatus or #stopsig.
  #
  # Returns the value of #to_i, shifted `places` to the right:
  #
  #     `cat /nop`
  #     stat = $?                 # => #<Process::Status: pid 1155508 exit 1>
  #     stat.to_i                 # => 256
  #     stat >> 1                 # => 128
  #     stat >> 2                 # => 64
  #
  # ArgumentError is raised if `places` is negative.
  #
  def >>: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - coredump? -> true or false
  # -->
  # Returns `true` if the process generated a coredump when it terminated, `false`
  # if not.
  #
  # Not available on all platforms.
  #
  def coredump?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - exited? -> true or false
  # -->
  # Returns `true` if the process exited normally (for example using an `exit()`
  # call or finishing the program), `false` if not.
  #
  def exited?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - exitstatus -> integer or nil
  # -->
  # Returns the least significant eight bits of the return code of the process if
  # it has exited; `nil` otherwise:
  #
  #     `exit 99`
  #     $?.exitstatus # => 99
  #
  def exitstatus: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     system("false")
  #     $?.inspect # => "#<Process::Status: pid 1303494 exit 1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - pid -> integer
  # -->
  # Returns the process ID of the process:
  #
  #     system("false")
  #     $?.pid # => 1247002
  #
  def pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - signaled? -> true or false
  # -->
  # Returns `true` if the process terminated because of an uncaught signal,
  # `false` otherwise.
  #
  def signaled?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stopped? -> true or false
  # -->
  # Returns `true` if this process is stopped, and if the corresponding #wait call
  # had the Process::WUNTRACED flag set, `false` otherwise.
  #
  def stopped?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stopsig -> integer or nil
  # -->
  # Returns the number of the signal that caused the process to stop, or `nil` if
  # the process is not stopped.
  #
  def stopsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - success? -> true, false, or nil
  # -->
  # Returns:
  #
  # *   `true` if the process has completed successfully and exited.
  # *   `false` if the process has completed unsuccessfully and exited.
  # *   `nil` if the process has not exited.
  #
  def success?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - termsig -> integer or nil
  # -->
  # Returns the number of the signal that caused the process to terminate or `nil`
  # if the process was not terminated by an uncaught signal.
  #
  def termsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - to_i     -> integer
  # -->
  # Returns the system-dependent integer status of `self`:
  #
  #     `cat /nop`
  #     $?.to_i # => 256
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     `cat /nop`
  #     $?.to_s # => "pid 1262141 exit 1"
  #
  def to_s: () -> String
end

# <!-- rdoc-file=process.c -->
# The Process::Sys module contains UID and GID functions which provide direct
# bindings to the system calls of the same names instead of the more-portable
# versions of the same functionality found in the Process, Process::UID, and
# Process::GID modules.
#
module Process::Sys
  # <!--
  #   rdoc-file=process.c
  #   - Process.euid         -> integer
  #   - Process::UID.eid     -> integer
  #   - Process::Sys.geteuid -> integer
  # -->
  # Returns the effective user ID for the current process.
  #
  #     Process.euid # => 501
  #
  def self.geteuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid         -> integer
  #   - Process::GID.rid    -> integer
  #   - Process::Sys.getgid -> integer
  # -->
  # Returns the (real) group ID for the current process:
  #
  #     Process.gid # => 1000
  #
  def self.getgid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid         -> integer
  #   - Process::UID.rid    -> integer
  #   - Process::Sys.getuid -> integer
  # -->
  # Returns the (real) user ID of the current process.
  #
  #     Process.uid # => 1000
  #
  def self.getuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.issetugid   -> true or false
  # -->
  # Returns `true` if the process was created as a result of an execve(2) system
  # call which had either of the setuid or setgid bits set (and extra privileges
  # were given as a result) or if it has changed any of its real, effective or
  # saved user or group IDs since it began execution.
  #
  def self.issetugid: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setegid(group)   -> nil
  # -->
  # Set the effective group ID of the calling process to *group*.  Not available
  # on all platforms.
  #
  def self.setegid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.seteuid(user)   -> nil
  # -->
  # Set the effective user ID of the calling process to *user*.  Not available on
  # all platforms.
  #
  def self.seteuid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setgid(group)   -> nil
  # -->
  # Set the group ID of the current process to *group*. Not available on all
  # platforms.
  #
  def self.setgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setregid(rid, eid)   -> nil
  # -->
  # Sets the (group) real and/or effective group IDs of the current process to
  # *rid* and *eid*, respectively. A value of `-1` for either means to leave that
  # ID unchanged. Not available on all platforms.
  #
  def self.setregid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresgid(rid, eid, sid)   -> nil
  # -->
  # Sets the (group) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresgid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresuid(rid, eid, sid)   -> nil
  # -->
  # Sets the (user) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresuid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setreuid(rid, eid)   -> nil
  # -->
  # Sets the (user) real and/or effective user IDs of the current process to *rid*
  # and *eid*, respectively. A value of `-1` for either means to leave that ID
  # unchanged. Not available on all platforms.
  #
  def self.setreuid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setrgid(group)   -> nil
  # -->
  # Set the real group ID of the calling process to *group*. Not available on all
  # platforms.
  #
  def self.setrgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setruid(user)   -> nil
  # -->
  # Set the real user ID of the calling process to *user*. Not available on all
  # platforms.
  #
  def self.setruid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setuid(user)   -> nil
  # -->
  # Set the user ID of the current process to *user*. Not available on all
  # platforms.
  #
  def self.setuid: (Integer user) -> nil
end

# <!-- rdoc-file=process.c -->
# The Process::UID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved user IDs.
#
module Process::UID
  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.change_privilege(user)   -> integer
  # -->
  # Change the current process's real and effective user ID to that specified by
  # *user*. Returns the new user ID. Not available on all platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.change_privilege(31)    #=> 31
  #     [Process.uid, Process.euid]          #=> [31, 31]
  #
  def self.change_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid         -> integer
  #   - Process::UID.eid     -> integer
  #   - Process::Sys.geteuid -> integer
  # -->
  # Returns the effective user ID for the current process.
  #
  #     Process.euid # => 501
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.from_name(name)   -> uid
  # -->
  # Get the user ID by the *name*. If the user is not found, `ArgumentError` will
  # be raised.
  #
  #     Process::UID.from_name("root") #=> 0
  #     Process::UID.from_name("nosuchuser") #=> can't find user for nosuchuser (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.grant_privilege(user)   -> integer
  #   - Process::UID.eid= user               -> integer
  # -->
  # Set the effective user ID, and if possible, the saved user ID of the process
  # to the given *user*. Returns the new effective user ID. Not available on all
  # platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.grant_privilege(31)     #=> 31
  #     [Process.uid, Process.euid]          #=> [0, 31]
  #
  def self.grant_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchange   -> integer
  # -->
  # Exchange real and effective user IDs and return the new effective user ID. Not
  # available on all platforms.
  #
  #     [Process.uid, Process.euid]   #=> [0, 31]
  #     Process::UID.re_exchange      #=> 0
  #     [Process.uid, Process.euid]   #=> [31, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective user IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid         -> integer
  #   - Process::UID.rid    -> integer
  #   - Process::Sys.getuid -> integer
  # -->
  # Returns the (real) user ID of the current process.
  #
  #     Process.uid # => 1000
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved user ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.switch              -> integer
  #   - Process::UID.switch {|| block}   -> object
  # -->
  # Switch the effective and real user IDs of the current process. If a *block* is
  # given, the user IDs will be switched back after the block is executed. Returns
  # the new effective user ID if called without a block, and the return value of
  # the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer user) -> Integer
end

# <!-- rdoc-file=process.c -->
# Placeholder for rusage
#
class Process::Tms < Struct[Float]
end

class Process::Waiter < Thread
  def pid: () -> Integer
end
# <!-- rdoc-file=struct.c -->
# Class Struct provides a convenient way to create a simple class that can store
# and fetch values.
#
# This example creates a subclass of `Struct`, `Struct::Customer`; the first
# argument, a string, is the name of the subclass; the other arguments, symbols,
# determine the *members* of the new subclass.
#
#     Customer = Struct.new('Customer', :name, :address, :zip)
#     Customer.name       # => "Struct::Customer"
#     Customer.class      # => Class
#     Customer.superclass # => Struct
#
# Corresponding to each member are two methods, a writer and a reader, that
# store and fetch values:
#
#     methods = Customer.instance_methods false
#     methods # => [:zip, :address=, :zip=, :address, :name, :name=]
#
# An instance of the subclass may be created, and its members assigned values,
# via method `::new`:
#
#     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
#     joe # => #<struct Struct::Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=12345>
#
# The member values may be managed thus:
#
#     joe.name    # => "Joe Smith"
#     joe.name = 'Joseph Smith'
#     joe.name    # => "Joseph Smith"
#
# And thus; note that member name may be expressed as either a string or a
# symbol:
#
#     joe[:name]  # => "Joseph Smith"
#     joe[:name] = 'Joseph Smith, Jr.'
#     joe['name'] # => "Joseph Smith, Jr."
#
# See Struct::new.
#
# ## What's Here
#
# First, what's elsewhere. Class Struct:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Enumerable](rdoc-ref:Enumerable@What-27s+Here), which
#     provides dozens of additional methods.
#
# See also Data, which is a somewhat similar, but stricter concept for defining
# immutable value objects.
#
# Here, class Struct provides methods that are useful for:
#
# *   [Creating a Struct
#     Subclass](rdoc-ref:Struct@Methods+for+Creating+a+Struct+Subclass)
# *   [Querying](rdoc-ref:Struct@Methods+for+Querying)
# *   [Comparing](rdoc-ref:Struct@Methods+for+Comparing)
# *   [Fetching](rdoc-ref:Struct@Methods+for+Fetching)
# *   [Assigning](rdoc-ref:Struct@Methods+for+Assigning)
# *   [Iterating](rdoc-ref:Struct@Methods+for+Iterating)
# *   [Converting](rdoc-ref:Struct@Methods+for+Converting)
#
# ### Methods for Creating a Struct Subclass
#
# *   ::new: Returns a new subclass of Struct.
#
# ### Methods for Querying
#
# *   #hash: Returns the integer hash code.
# *   #size (aliased as #length): Returns the number of members.
#
# ### Methods for Comparing
#
# *   #==: Returns whether a given object is equal to `self`, using `==` to
#     compare member values.
# *   #eql?: Returns whether a given object is equal to `self`, using `eql?` to
#     compare member values.
#
# ### Methods for Fetching
#
# *   #[]: Returns the value associated with a given member name.
# *   #to_a (aliased as #values, #deconstruct): Returns the member values in
#     `self` as an array.
# *   #deconstruct_keys: Returns a hash of the name/value pairs for given member
#     names.
# *   #dig: Returns the object in nested objects that is specified by a given
#     member name and additional arguments.
# *   #members: Returns an array of the member names.
# *   #select (aliased as #filter): Returns an array of member values from
#     `self`, as selected by the given block.
# *   #values_at: Returns an array containing values for given member names.
#
# ### Methods for Assigning
#
# *   #[]=: Assigns a given value to a given member name.
#
# ### Methods for Iterating
#
# *   #each: Calls a given block with each member name.
# *   #each_pair: Calls a given block with each member name/value pair.
#
# ### Methods for Converting
#
# *   #inspect (aliased as #to_s): Returns a string representation of `self`.
# *   #to_h: Returns a hash of the member name/value pairs in `self`.
#
class Struct[Elem]
  include Enumerable[Elem]

  # The types that can be used when "indexing" into a `Struct` via `[]`, `[]=`, `dig`, and
  # `deconstruct_keys`.
  #
  type index = String | Symbol | int

  # <!--
  #   rdoc-file=struct.c
  #   - Struct.new(*member_names, keyword_init: nil){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct.new(class_name, *member_names, keyword_init: nil){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct_subclass.new(*member_names) -> Struct_subclass_instance
  #   - Struct_subclass.new(**member_names) -> Struct_subclass_instance
  # -->
  # `Struct.new` returns a new subclass of `Struct`.  The new subclass:
  #
  # *   May be anonymous, or may have the name given by `class_name`.
  # *   May have members as given by `member_names`.
  # *   May have initialization via ordinary arguments, or via keyword arguments
  #
  # The new subclass has its own method `::new`; thus:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     f = Foo.new(0, 1)                   # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **\Class Name**
  #
  # With string argument `class_name`, returns a new subclass of `Struct` named
  # `Struct::*class_name`*:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     Foo.name                            # => "Struct::Foo"
  #     Foo.superclass                      # => Struct
  #
  # Without string argument `class_name`, returns a new anonymous subclass of
  # `Struct`:
  #
  #     Struct.new(:foo, :bar).name # => nil
  #
  # **Block**
  #
  # With a block given, the created subclass is yielded to the block:
  #
  #     Customer = Struct.new('Customer', :name, :address) do |new_class|
  #       p "The new subclass is #{new_class}"
  #       def greeting
  #         "Hello #{name} at #{address}"
  #       end
  #     end           # => Struct::Customer
  #     dave = Customer.new('Dave', '123 Main')
  #     dave # =>     #<struct Struct::Customer name="Dave", address="123 Main">
  #     dave.greeting # => "Hello Dave at 123 Main"
  #
  # Output, from `Struct.new`:
  #
  #     "The new subclass is Struct::Customer"
  #
  # **Member Names**
  #
  # Symbol arguments `member_names` determines the members of the new subclass:
  #
  #     Struct.new(:foo, :bar).members        # => [:foo, :bar]
  #     Struct.new('Foo', :foo, :bar).members # => [:foo, :bar]
  #
  # The new subclass has instance methods corresponding to `member_names`:
  #
  #     Foo = Struct.new('Foo', :foo, :bar)
  #     Foo.instance_methods(false) # => [:foo, :bar, :foo=, :bar=]
  #     f = Foo.new                 # => #<struct Struct::Foo foo=nil, bar=nil>
  #     f.foo                       # => nil
  #     f.foo = 0                   # => 0
  #     f.bar                       # => nil
  #     f.bar = 1                   # => 1
  #     f                           # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **Singleton Methods**
  #
  # A subclass returned by Struct.new has these singleton methods:
  #
  # *   Method `::new ` creates an instance of the subclass:
  #
  #         Foo.new          # => #<struct Struct::Foo foo=nil, bar=nil>
  #         Foo.new(0)       # => #<struct Struct::Foo foo=0, bar=nil>
  #         Foo.new(0, 1)    # => #<struct Struct::Foo foo=0, bar=1>
  #         Foo.new(0, 1, 2) # Raises ArgumentError: struct size differs
  #
  #         # Initialization with keyword arguments:
  #         Foo.new(foo: 0)         # => #<struct Struct::Foo foo=0, bar=nil>
  #         Foo.new(foo: 0, bar: 1) # => #<struct Struct::Foo foo=0, bar=1>
  #         Foo.new(foo: 0, bar: 1, baz: 2)
  #         # Raises ArgumentError: unknown keywords: baz
  #
  # *   Method `:inspect` returns a string representation of the subclass:
  #
  #         Foo.inspect
  #         # => "Struct::Foo"
  #
  # *   Method `::members` returns an array of the member names:
  #
  #         Foo.members # => [:foo, :bar]
  #
  # **Keyword Argument**
  #
  # By default, the arguments for initializing an instance of the new subclass can
  # be both positional and keyword arguments.
  #
  # Optional keyword argument `keyword_init:` allows to force only one type of
  # arguments to be accepted:
  #
  #     KeywordsOnly = Struct.new(:foo, :bar, keyword_init: true)
  #     KeywordsOnly.new(bar: 1, foo: 0)
  #     # => #<struct KeywordsOnly foo=0, bar=1>
  #     KeywordsOnly.new(0, 1)
  #     # Raises ArgumentError: wrong number of arguments
  #
  #     PositionalOnly = Struct.new(:foo, :bar, keyword_init: false)
  #     PositionalOnly.new(0, 1)
  #     # => #<struct PositionalOnly foo=0, bar=1>
  #     PositionalOnly.new(bar: 1, foo: 0)
  #     # => #<struct PositionalOnly foo={:foo=>1, :bar=>2}, bar=nil>
  #     # Note that no error is raised, but arguments treated as one hash value
  #
  #     # Same as not providing keyword_init:
  #     Any = Struct.new(:foo, :bar, keyword_init: nil)
  #     Any.new(foo: 1, bar: 2)
  #     # => #<struct Any foo=1, bar=2>
  #     Any.new(1, 2)
  #     # => #<struct Any foo=1, bar=2>
  #
  def self.new: (string? classname, *interned fields, ?keyword_init: boolish?) ?{ (singleton(Struct)) [self: singleton(Struct)] -> void } -> untyped
              | (Symbol field1, *interned fields, ?keyword_init: boolish?) ?{ (singleton(Struct)) [self: singleton(Struct)] -> void } -> untyped

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::members -> array_of_symbols
  # -->
  # Returns the member names of the Struct descendant as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     Customer.members # => [:name, :address, :zip]
  #
  def self.members: () -> Array[Symbol]

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::keyword_init? -> true or falsy value
  # -->
  # Returns `true` if the class was initialized with `keyword_init: true`.
  # Otherwise returns `nil` or `false`.
  #
  # Examples:
  #     Foo = Struct.new(:a)
  #     Foo.keyword_init? # => nil
  #     Bar = Struct.new(:a, keyword_init: true)
  #     Bar.keyword_init? # => true
  #     Baz = Struct.new(:a, keyword_init: false)
  #     Baz.keyword_init? # => false
  #
  def self.keyword_init?: () -> bool?

  # <!--
  #   rdoc-file=struct.c
  #   - self == other -> true or false
  # -->
  # Returns  `true` if and only if the following are true; otherwise returns
  # `false`:
  #
  # *   `other.class == self.class`.
  # *   For each member name `name`, `other.name == self.name`.
  #
  # Examples:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe_jr == joe # => true
  #     joe_jr[:name] = 'Joe Smith, Jr.'
  #     # => "Joe Smith, Jr."
  #     joe_jr == joe # => false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=struct.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if and only if the following are true; otherwise returns
  # `false`:
  #
  # *   `other.class == self.class`.
  # *   For each member name `name`, `other.name.eql?(self.name)`.
  #
  #         Customer = Struct.new(:name, :address, :zip)
  #         joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #         joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #         joe_jr.eql?(joe) # => true
  #         joe_jr[:name] = 'Joe Smith, Jr.'
  #         joe_jr.eql?(joe) # => false
  #
  # Related: Object#==.
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=struct.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two structs of the same class and with the same content will have the same
  # hash code (and will compare using Struct#eql?):
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe    = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe_jr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.hash == joe_jr.hash # => true
  #     joe_jr[:name] = 'Joe Smith, Jr.'
  #     joe.hash == joe_jr.hash # => false
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=struct.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip) # => Customer
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.inspect # => "#<struct Customer name=\"Joe Smith\", address=\"123 Maple, Anytown NC\", zip=12345>"
  #
  def inspect: () -> String

  # <!-- rdoc-file=struct.c -->
  # Returns a string representation of `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip) # => Customer
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.inspect # => "#<struct Customer name=\"Joe Smith\", address=\"123 Maple, Anytown NC\", zip=12345>"
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=struct.c
  #   - to_a     -> array
  # -->
  # Returns the values in `self` as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.to_a # => ["Joe Smith", "123 Maple, Anytown NC", 12345]
  #
  # Related: #members.
  #
  def to_a: () -> Array[Elem]

  # <!--
  #   rdoc-file=struct.c
  #   - to_h -> hash
  #   - to_h {|name, value| ... } -> hash
  # -->
  # Returns a hash containing the name and value for each member:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     h = joe.to_h
  #     h # => {:name=>"Joe Smith", :address=>"123 Maple, Anytown NC", :zip=>12345}
  #
  # If a block is given, it is called with each name/value pair; the block should
  # return a 2-element array whose elements will become a key/value pair in the
  # returned hash:
  #
  #     h = joe.to_h{|name, value| [name.upcase, value.to_s.upcase]}
  #     h # => {:NAME=>"JOE SMITH", :ADDRESS=>"123 MAPLE, ANYTOWN NC", :ZIP=>"12345"}
  #
  # Raises ArgumentError if the block returns an inappropriate value.
  #
  def to_h: () -> Hash[Symbol, Elem]
          | [K, V] () { (Symbol key, Elem value) -> [K, V] } -> Hash[K, V]

  # <!-- rdoc-file=struct.c -->
  # Returns the values in `self` as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.to_a # => ["Joe Smith", "123 Maple, Anytown NC", 12345]
  #
  # Related: #members.
  #
  alias values to_a

  # <!--
  #   rdoc-file=struct.c
  #   - size -> integer
  # -->
  # Returns the number of members.
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.size #=> 3
  #
  def size: () -> Integer

  # <!-- rdoc-file=struct.c -->
  # Returns the number of members.
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.size #=> 3
  #
  alias length size

  # <!--
  #   rdoc-file=struct.c
  #   - each {|value| ... } -> self
  #   - each -> enumerator
  # -->
  # Calls the given block with the value of each member; returns `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.each {|value| p value }
  #
  # Output:
  #
  #     "Joe Smith"
  #     "123 Maple, Anytown NC"
  #     12345
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #each_pair.
  #
  def each: () -> Enumerator[Elem, self]
          | () { (Elem value) -> void } -> self

  # <!--
  #   rdoc-file=struct.c
  #   - each_pair {|(name, value)| ... } -> self
  #   - each_pair -> enumerator
  # -->
  # Calls the given block with each member name/value pair; returns `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip) # => Customer
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.each_pair {|(name, value)| p "#{name} => #{value}" }
  #
  # Output:
  #
  #     "name => Joe Smith"
  #     "address => 123 Maple, Anytown NC"
  #     "zip => 12345"
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #each.
  #
  def each_pair: () -> Enumerator[[Symbol, Elem], self]
               | () { ([Symbol, Elem] key_value) -> void } -> self

  # <!--
  #   rdoc-file=struct.c
  #   - struct[name] -> object
  #   - struct[n] -> object
  # -->
  # Returns a value from `self`.
  #
  # With symbol or string argument `name` given, returns the value for the named
  # member:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe[:zip] # => 12345
  #
  # Raises NameError if `name` is not the name of a member.
  #
  # With integer argument `n` given, returns `self.values[n]` if `n` is in range;
  # see Array@Array+Indexes:
  #
  #     joe[2]  # => 12345
  #     joe[-2] # => "123 Maple, Anytown NC"
  #
  # Raises IndexError if `n` is out of range.
  #
  def []: (index name_or_position) -> Elem

  # <!--
  #   rdoc-file=struct.c
  #   - struct[name] = value -> value
  #   - struct[n] = value -> value
  # -->
  # Assigns a value to a member.
  #
  # With symbol or string argument `name` given, assigns the given `value` to the
  # named member; returns `value`:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe[:zip] = 54321 # => 54321
  #     joe # => #<struct Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=54321>
  #
  # Raises NameError if `name` is not the name of a member.
  #
  # With integer argument `n` given, assigns the given `value` to the `n`-th
  # member if `n` is in range; see Array@Array+Indexes:
  #
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe[2] = 54321           # => 54321
  #     joe[-3] = 'Joseph Smith' # => "Joseph Smith"
  #     joe # => #<struct Customer name="Joseph Smith", address="123 Maple, Anytown NC", zip=54321>
  #
  # Raises IndexError if `n` is out of range.
  #
  def []=: (index name_or_position, Elem value) -> Elem

  # <!--
  #   rdoc-file=struct.c
  #   - select {|value| ... } -> array
  #   - select -> enumerator
  # -->
  # With a block given, returns an array of values from `self` for which the block
  # returns a truthy value:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     a = joe.select {|value| value.is_a?(String) }
  #     a # => ["Joe Smith", "123 Maple, Anytown NC"]
  #     a = joe.select {|value| value.is_a?(Integer) }
  #     a # => [12345]
  #
  # With no block given, returns an Enumerator.
  #
  def select: () -> Enumerator[Elem, Array[Elem]]
            | () { (Elem value) -> boolish } -> Array[Elem]

  # <!-- rdoc-file=struct.c -->
  # With a block given, returns an array of values from `self` for which the block
  # returns a truthy value:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     a = joe.select {|value| value.is_a?(String) }
  #     a # => ["Joe Smith", "123 Maple, Anytown NC"]
  #     a = joe.select {|value| value.is_a?(Integer) }
  #     a # => [12345]
  #
  # With no block given, returns an Enumerator.
  #
  alias filter select

  # <!--
  #   rdoc-file=struct.c
  #   - values_at(*integers) -> array
  #   - values_at(integer_range) -> array
  # -->
  # Returns an array of values from `self`.
  #
  # With integer arguments `integers` given, returns an array containing each
  # value given by one of `integers`:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.values_at(0, 2)    # => ["Joe Smith", 12345]
  #     joe.values_at(2, 0)    # => [12345, "Joe Smith"]
  #     joe.values_at(2, 1, 0) # => [12345, "123 Maple, Anytown NC", "Joe Smith"]
  #     joe.values_at(0, -3)   # => ["Joe Smith", "Joe Smith"]
  #
  # Raises IndexError if any of `integers` is out of range; see
  # Array@Array+Indexes.
  #
  # With integer range argument `integer_range` given, returns an array containing
  # each value given by the elements of the range; fills with `nil` values for
  # range elements larger than the structure:
  #
  #     joe.values_at(0..2)
  #     # => ["Joe Smith", "123 Maple, Anytown NC", 12345]
  #     joe.values_at(-3..-1)
  #     # => ["Joe Smith", "123 Maple, Anytown NC", 12345]
  #     joe.values_at(1..4) # => ["123 Maple, Anytown NC", 12345, nil, nil]
  #
  # Raises RangeError if any element of the range is negative and out of range;
  # see Array@Array+Indexes.
  #
  def values_at: (*int | range[int?] positions) -> Array[Elem]

  # <!--
  #   rdoc-file=struct.c
  #   - members -> array_of_symbols
  # -->
  # Returns the member names from `self` as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     Customer.new.members # => [:name, :address, :zip]
  #
  # Related: #to_a.
  #
  def members: () -> Array[Symbol]

  # <!--
  #   rdoc-file=struct.c
  #   - dig(name, *identifiers) -> object
  #   - dig(n, *identifiers) -> object
  # -->
  # Finds and returns an object among nested objects. The nested objects may be
  # instances of various classes. See [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Given symbol or string argument `name`, returns the object that is specified
  # by `name` and `identifiers`:
  #
  #     Foo = Struct.new(:a)
  #     f = Foo.new(Foo.new({b: [1, 2, 3]}))
  #     f.dig(:a) # => #<struct Foo a={:b=>[1, 2, 3]}>
  #     f.dig(:a, :a) # => {:b=>[1, 2, 3]}
  #     f.dig(:a, :a, :b) # => [1, 2, 3]
  #     f.dig(:a, :a, :b, 0) # => 1
  #     f.dig(:b, 0) # => nil
  #
  # Given integer argument `n`, returns the object that is specified by `n` and
  # `identifiers`:
  #
  #     f.dig(0) # => #<struct Foo a={:b=>[1, 2, 3]}>
  #     f.dig(0, 0) # => {:b=>[1, 2, 3]}
  #     f.dig(0, 0, :b) # => [1, 2, 3]
  #     f.dig(0, 0, :b, 0) # => 1
  #     f.dig(:b, 0) # => nil
  #
  def dig: (index name_or_position) -> Elem
         | (index name_or_position, untyped, *untyped) -> untyped

  # <!-- rdoc-file=struct.c -->
  # Returns the values in `self` as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.to_a # => ["Joe Smith", "123 Maple, Anytown NC", 12345]
  #
  # Related: #members.
  #
  alias deconstruct to_a

  # <!--
  #   rdoc-file=struct.c
  #   - deconstruct_keys(array_of_names) -> hash
  # -->
  # Returns a hash of the name/value pairs for the given member names.
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     h = joe.deconstruct_keys([:zip, :address])
  #     h # => {:zip=>12345, :address=>"123 Maple, Anytown NC"}
  #
  # Returns all names and values if `array_of_names` is `nil`:
  #
  #     h = joe.deconstruct_keys(nil)
  #     h # => {:name=>"Joseph Smith, Jr.", :address=>"123 Maple, Anytown NC", :zip=>12345}
  #
  def deconstruct_keys: (Array[index & Hash::_Key]? indices) -> Hash[index & Hash::_Key, Elem]
end
# <!-- rdoc-file=timev.rb -->
# A `Time` object represents a date and time:
#
#     Time.new(2000, 1, 1, 0, 0, 0) # => 2000-01-01 00:00:00 -0600
#
# Although its value can be expressed as a single numeric (see [Epoch
# Seconds](rdoc-ref:Time@Epoch+Seconds) below), it can be convenient to deal
# with the value by parts:
#
#     t = Time.new(-2000, 1, 1, 0, 0, 0.0)
#     # => -2000-01-01 00:00:00 -0600
#     t.year # => -2000
#     t.month # => 1
#     t.mday # => 1
#     t.hour # => 0
#     t.min # => 0
#     t.sec # => 0
#     t.subsec # => 0
#
#     t = Time.new(2000, 12, 31, 23, 59, 59.5)
#     # => 2000-12-31 23:59:59.5 -0600
#     t.year # => 2000
#     t.month # => 12
#     t.mday # => 31
#     t.hour # => 23
#     t.min # => 59
#     t.sec # => 59
#     t.subsec # => (1/2)
#
# ## Epoch Seconds
#
# *Epoch seconds* is the exact number of seconds (including fractional
# subseconds) since the Unix Epoch, January 1, 1970.
#
# You can retrieve that value exactly using method Time.to_r:
#
#     Time.at(0).to_r        # => (0/1)
#     Time.at(0.999999).to_r # => (9007190247541737/9007199254740992)
#
# Other retrieval methods such as Time#to_i and Time#to_f may return a value
# that rounds or truncates subseconds.
#
# ## Time Resolution
#
# A `Time` object derived from the system clock (for example, by method
# Time.now) has the resolution supported by the system.
#
# ## Time Internal Representation
#
# Time implementation uses a signed 63 bit integer, Integer, or Rational. It is
# a number of nanoseconds since the *Epoch*. The signed 63 bit integer can
# represent 1823-11-12 to 2116-02-20. When Integer or Rational is used (before
# 1823, after 2116, under nanosecond), Time works slower than when the signed 63
# bit integer is used.
#
# Ruby uses the C function `localtime` and `gmtime` to map between the number
# and 6-tuple (year,month,day,hour,minute,second). `localtime` is used for local
# time and "gmtime" is used for UTC.
#
# Integer and Rational has no range limit, but the localtime and gmtime has
# range limits due to the C types `time_t` and `struct tm`. If that limit is
# exceeded, Ruby extrapolates the localtime function.
#
# The Time class always uses the Gregorian calendar. I.e. the proleptic
# Gregorian calendar is used. Other calendars, such as Julian calendar, are not
# supported.
#
# `time_t` can represent 1901-12-14 to 2038-01-19 if it is 32 bit signed
# integer, -292277022657-01-27 to 292277026596-12-05 if it is 64 bit signed
# integer. However `localtime` on some platforms doesn't supports negative
# `time_t` (before 1970).
#
# `struct tm` has *tm_year* member to represent years. (`tm_year = 0` means the
# year 1900.) It is defined as `int` in the C standard. *tm_year* can represent
# between -2147481748 to 2147485547 if `int` is 32 bit.
#
# Ruby supports leap seconds as far as if the C function `localtime` and
# `gmtime` supports it. They use the tz database in most Unix systems. The tz
# database has timezones which supports leap seconds. For example, "Asia/Tokyo"
# doesn't support leap seconds but "right/Asia/Tokyo" supports leap seconds. So,
# Ruby supports leap seconds if the TZ environment variable is set to
# "right/Asia/Tokyo" in most Unix systems.
#
# ## Examples
#
# All of these examples were done using the EST timezone which is GMT-5.
#
# ### Creating a New `Time` Instance
#
# You can create a new instance of Time with Time.new. This will use the current
# system time. Time.now is an alias for this. You can also pass parts of the
# time to Time.new such as year, month, minute, etc. When you want to construct
# a time this way you must pass at least a year. If you pass the year with
# nothing else time will default to January 1 of that year at 00:00:00 with the
# current system timezone. Here are some examples:
#
#     Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
#     Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
#     Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500
#
# You can pass a UTC offset:
#
#     Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200
#
# Or [a timezone object](rdoc-ref:Time@Timezone+Objects):
#
#     zone = timezone("Europe/Athens")      # Eastern European Time, UTC+2
#     Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200
#
# You can also use Time.local and Time.utc to infer local and UTC timezones
# instead of using the current system setting.
#
# You can also create a new time using Time.at which takes the number of seconds
# (with subsecond) since the [Unix
# Epoch](https://en.wikipedia.org/wiki/Unix_time).
#
#     Time.at(628232400) #=> 1989-11-28 00:00:00 -0500
#
# ### Working with an Instance of `Time`
#
# Once you have an instance of Time there is a multitude of things you can do
# with it. Below are some examples. For all of the following examples, we will
# work on the assumption that you have done the following:
#
#     t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")
#
# Was that a monday?
#
#     t.monday? #=> false
#
# What year was that again?
#
#     t.year #=> 1993
#
# Was it daylight savings at the time?
#
#     t.dst? #=> false
#
# What's the day a year later?
#
#     t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900
#
# How many seconds was that since the Unix Epoch?
#
#     t.to_i #=> 730522800
#
# You can also do standard functions like compare two times.
#
#     t1 = Time.new(2010)
#     t2 = Time.new(2011)
#
#     t1 == t2 #=> false
#     t1 == t1 #=> true
#     t1 <  t2 #=> true
#     t1 >  t2 #=> false
#
#     Time.new(2010,10,31).between?(t1, t2) #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class `Time`:
#
# *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class `Time` provides methods that are useful for:
#
# *   [Creating Time objects](rdoc-ref:Time@Methods+for+Creating).
# *   [Fetching Time values](rdoc-ref:Time@Methods+for+Fetching).
# *   [Querying a Time object](rdoc-ref:Time@Methods+for+Querying).
# *   [Comparing Time objects](rdoc-ref:Time@Methods+for+Comparing).
# *   [Converting a Time object](rdoc-ref:Time@Methods+for+Converting).
# *   [Rounding a Time](rdoc-ref:Time@Methods+for+Rounding).
#
# ### Methods for Creating
#
# *   ::new: Returns a new time from specified arguments (year, month, etc.),
#     including an optional timezone value.
# *   ::local (aliased as ::mktime): Same as ::new, except the timezone is the
#     local timezone.
# *   ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC.
# *   ::at: Returns a new time based on seconds since epoch.
# *   ::now: Returns a new time based on the current system time.
# *   #+ (plus): Returns a new time increased by the given number of seconds.
# *   #- (minus): Returns a new time decreased by the given number of seconds.
#
# ### Methods for Fetching
#
# *   #year: Returns the year of the time.
# *   #month (aliased as #mon): Returns the month of the time.
# *   #mday (aliased as #day): Returns the day of the month.
# *   #hour: Returns the hours value for the time.
# *   #min: Returns the minutes value for the time.
# *   #sec: Returns the seconds value for the time.
# *   #usec (aliased as #tv_usec): Returns the number of microseconds in the
#     subseconds value of the time.
# *   #nsec (aliased as #tv_nsec: Returns the number of nanoseconds in the
#     subsecond part of the time.
# *   #subsec: Returns the subseconds value for the time.
# *   #wday: Returns the integer weekday value of the time (0 == Sunday).
# *   #yday: Returns the integer yearday value of the time (1 == January 1).
# *   #hash: Returns the integer hash value for the time.
# *   #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset in
#     seconds between time and UTC.
# *   #to_f: Returns the float number of seconds since epoch for the time.
# *   #to_i (aliased as #tv_sec): Returns the integer number of seconds since
#     epoch for the time.
# *   #to_r: Returns the Rational number of seconds since epoch for the time.
# *   #zone: Returns a string representation of the timezone of the time.
#
# ### Methods for Querying
#
# *   #utc? (aliased as #gmt?): Returns whether the time is UTC.
# *   #dst? (aliased as #isdst): Returns whether the time is DST (daylight
#     saving time).
# *   #sunday?: Returns whether the time is a Sunday.
# *   #monday?: Returns whether the time is a Monday.
# *   #tuesday?: Returns whether the time is a Tuesday.
# *   #wednesday?: Returns whether the time is a Wednesday.
# *   #thursday?: Returns whether the time is a Thursday.
# *   #friday?: Returns whether time is a Friday.
# *   #saturday?: Returns whether the time is a Saturday.
#
# ### Methods for Comparing
#
# *   #<=>: Compares `self` to another time.
# *   #eql?: Returns whether the time is equal to another time.
#
# ### Methods for Converting
#
# *   #asctime (aliased as #ctime): Returns the time as a string.
# *   #inspect: Returns the time in detail as a string.
# *   #strftime: Returns the time as a string, according to a given format.
# *   #to_a: Returns a 10-element array of values from the time.
# *   #to_s: Returns a string representation of the time.
# *   #getutc (aliased as #getgm): Returns a new time converted to UTC.
# *   #getlocal: Returns a new time converted to local time.
# *   #utc (aliased as #gmtime): Converts time to UTC in place.
# *   #localtime: Converts time to local time in place.
# *   #deconstruct_keys: Returns a hash of time components used in
#     pattern-matching.
#
# ### Methods for Rounding
#
# *   #round:Returns a new time with subseconds rounded.
# *   #ceil: Returns a new time with subseconds raised to a ceiling.
# *   #floor: Returns a new time with subseconds lowered to a floor.
#
# For the forms of argument `zone`, see [Timezone
# Specifiers](rdoc-ref:Time@Timezone+Specifiers).
#
# ## Timezone Specifiers
#
# Certain `Time` methods accept arguments that specify timezones:
#
# *   Time.at: keyword argument `in:`.
# *   Time.new: positional argument `zone` or keyword argument `in:`.
# *   Time.now: keyword argument `in:`.
# *   Time#getlocal: positional argument `zone`.
# *   Time#localtime: positional argument `zone`.
#
# The value given with any of these must be one of the following (each detailed
# below):
#
# *   [Hours/minutes offset](rdoc-ref:Time@Hours-2FMinutes+Offsets).
# *   [Single-letter offset](rdoc-ref:Time@Single-Letter+Offsets).
# *   [Integer offset](rdoc-ref:Time@Integer+Offsets).
# *   [Timezone object](rdoc-ref:Time@Timezone+Objects).
# *   [Timezone name](rdoc-ref:Time@Timezone+Names).
#
# ### Hours/Minutes Offsets
#
# The zone value may be a string offset from UTC in the form `'+HH:MM'` or
# `'-HH:MM'`, where:
#
# *   `HH` is the 2-digit hour in the range `0..23`.
# *   `MM` is the 2-digit minute in the range `0..59`.
#
# Examples:
#
#     t = Time.utc(2000, 1, 1, 20, 15, 1) # => 2000-01-01 20:15:01 UTC
#     Time.at(t, in: '-23:59')            # => 1999-12-31 20:16:01 -2359
#     Time.at(t, in: '+23:59')            # => 2000-01-02 20:14:01 +2359
#
# ### Single-Letter Offsets
#
# The zone value may be a  letter in the range `'A'..'I'` or `'K'..'Z'`; see
# [List of military time
# zones](https://en.wikipedia.org/wiki/List_of_military_time_zones):
#
#     t = Time.utc(2000, 1, 1, 20, 15, 1) # => 2000-01-01 20:15:01 UTC
#     Time.at(t, in: 'A')                 # => 2000-01-01 21:15:01 +0100
#     Time.at(t, in: 'I')                 # => 2000-01-02 05:15:01 +0900
#     Time.at(t, in: 'K')                 # => 2000-01-02 06:15:01 +1000
#     Time.at(t, in: 'Y')                 # => 2000-01-01 08:15:01 -1200
#     Time.at(t, in: 'Z')                 # => 2000-01-01 20:15:01 UTC
#
# ### Integer Offsets
#
# The zone value may be an integer number of seconds in the range
# `-86399..86399`:
#
#     t = Time.utc(2000, 1, 1, 20, 15, 1) # => 2000-01-01 20:15:01 UTC
#     Time.at(t, in: -86399)              # => 1999-12-31 20:15:02 -235959
#     Time.at(t, in: 86399)               # => 2000-01-02 20:15:00 +235959
#
# ### Timezone Objects
#
# The zone value may be an object responding to certain timezone methods, an
# instance of [Timezone](https://github.com/panthomakos/timezone) and
# [TZInfo](https://tzinfo.github.io) for example.
#
# The timezone methods are:
#
# *   `local_to_utc`:
#
#     Called when Time.new is invoked with `tz` as the value of positional
#     argument `zone` or keyword argument `in:`.
#
#     Argument
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects).
#
#     Returns
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects) in the UTC
#         timezone.
#
#
# *   `utc_to_local`:
#
#     Called when Time.at or Time.now is invoked with `tz` as the value for
#     keyword argument `in:`, and when Time#getlocal or Time#localtime is called
#     with `tz` as the value for positional argument `zone`.
#
#     The UTC offset will be calculated as the difference between the original
#     time and the returned object as an `Integer`. If the object is in fixed
#     offset, its `utc_offset` is also counted.
#
#     Argument
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects).
#
#     Returns
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects) in the local
#         timezone.
#
#
# A custom timezone class may have these instance methods, which will be called
# if defined:
#
# *   `abbr`:
#
#     Called when Time#strftime is invoked with a format involving `%Z`.
#
#     Argument
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects).
#
#     Returns
# :       a string abbreviation for the timezone name.
#
#
# *   `dst?`:
#
#     Called when Time.at or Time.now is invoked with `tz` as the value for
#     keyword argument `in:`, and when Time#getlocal or Time#localtime is called
#     with `tz` as the value for positional argument `zone`.
#
#     Argument
# :       a [Time-like object](rdoc-ref:Time@Time-Like+Objects).
#
#     Returns
# :       whether the time is daylight saving time.
#
#
# *   `name`:
#
#     Called when `Marshal.dump(t)` is invoked
#
#     Argument
# :       none.
#
#     Returns
# :       the string name of the timezone.
#
#
# #### `Time`-Like Objects
#
# A `Time`-like object is a container object capable of interfacing with
# timezone libraries for timezone conversion.
#
# The argument to the timezone conversion methods above will have attributes
# similar to Time, except that timezone related attributes are meaningless.
#
# The objects returned by `local_to_utc` and `utc_to_local` methods of the
# timezone object may be of the same class as their arguments, of arbitrary
# object classes, or of class Integer.
#
# For a returned class other than `Integer`, the class must have the following
# methods:
#
# *   `year`
# *   `mon`
# *   `mday`
# *   `hour`
# *   `min`
# *   `sec`
# *   `isdst`
# *   `to_i`
#
# For a returned `Integer`, its components, decomposed in UTC, are interpreted
# as times in the specified timezone.
#
# ### Timezone Names
#
# If the class (the receiver of class methods, or the class of the receiver of
# instance methods) has `find_timezone` singleton method, this method is called
# to achieve the corresponding timezone object from a timezone name.
#
# For example, using [Timezone](https://github.com/panthomakos/timezone):
#     class TimeWithTimezone < Time
#       require 'timezone'
#       def self.find_timezone(z) = Timezone[z]
#     end
#
#     TimeWithTimezone.now(in: "America/New_York")        #=> 2023-12-25 00:00:00 -0500
#     TimeWithTimezone.new("2023-12-25 America/New_York") #=> 2023-12-25 00:00:00 -0500
#
# Or, using [TZInfo](https://tzinfo.github.io):
#     class TimeWithTZInfo < Time
#       require 'tzinfo'
#       def self.find_timezone(z) = TZInfo::Timezone.get(z)
#     end
#
#     TimeWithTZInfo.now(in: "America/New_York")          #=> 2023-12-25 00:00:00 -0500
#     TimeWithTZInfo.new("2023-12-25 America/New_York")   #=> 2023-12-25 00:00:00 -0500
#
# You can define this method per subclasses, or on the toplevel Time class.
#
class Time < Object
  # A type that's used for timeouts.
  #
  # All numeric types implement this, but custom classes can also implement it if desired.
  #
  # Usage of `Time::_Timeout` is fairly common throughout the stdlib, such as in `Kernel#sleep`,
  # `IO#timeout=`, and `TCPSocket#new`'s `connet_timeout` field.
  interface _Timeout
    # Returns `[seconds, nanoseconds]`.
    #
    # The `seconds` should be a whole number of seconds, whereas the `nanoseconds` should be smaller
    # than one. For example, `3.125.divmod(1)` would yield `[3, 0.125]`
    def divmod: (1) -> [int, _TimeoutNSecs]
  end

  # The nanoseconds part of `Time::_Timeout`'s return value. See it for details
  interface _TimeoutNSecs
    # Convert `self` into a whole number of seconds.
    def *: (1_000_000_000) -> int
  end

  include Comparable

  # <!--
  #   rdoc-file=timev.rb
  #   - at(time, subsec = false, unit = :microsecond, in: nil)
  # -->
  # Returns a new `Time` object based on the given arguments.
  #
  # Required argument `time` may be either of:
  #
  # *   A `Time` object, whose value is the basis for the returned time; also
  #     influenced by optional keyword argument `in:` (see below).
  # *   A numeric number of [Epoch seconds](rdoc-ref:Time@Epoch+Seconds) for the
  #     returned time.
  #
  # Examples:
  #
  #     t = Time.new(2000, 12, 31, 23, 59, 59) # => 2000-12-31 23:59:59 -0600
  #     secs = t.to_i                          # => 978328799
  #     Time.at(secs)                          # => 2000-12-31 23:59:59 -0600
  #     Time.at(secs + 0.5)                    # => 2000-12-31 23:59:59.5 -0600
  #     Time.at(1000000000)                    # => 2001-09-08 20:46:40 -0500
  #     Time.at(0)                             # => 1969-12-31 18:00:00 -0600
  #     Time.at(-1000000000)                   # => 1938-04-24 17:13:20 -0500
  #
  # Optional numeric argument `subsec` and optional symbol argument `units` work
  # together to specify subseconds for the returned time; argument `units`
  # specifies the units for `subsec`:
  #
  # *   `:millisecond`: `subsec` in milliseconds:
  #
  #         Time.at(secs, 0, :millisecond)     # => 2000-12-31 23:59:59 -0600
  #         Time.at(secs, 500, :millisecond)   # => 2000-12-31 23:59:59.5 -0600
  #         Time.at(secs, 1000, :millisecond)  # => 2001-01-01 00:00:00 -0600
  #         Time.at(secs, -1000, :millisecond) # => 2000-12-31 23:59:58 -0600
  #
  # *   `:microsecond` or `:usec`: `subsec` in microseconds:
  #
  #         Time.at(secs, 0, :microsecond)        # => 2000-12-31 23:59:59 -0600
  #         Time.at(secs, 500000, :microsecond)   # => 2000-12-31 23:59:59.5 -0600
  #         Time.at(secs, 1000000, :microsecond)  # => 2001-01-01 00:00:00 -0600
  #         Time.at(secs, -1000000, :microsecond) # => 2000-12-31 23:59:58 -0600
  #
  # *   `:nanosecond` or `:nsec`: `subsec` in nanoseconds:
  #
  #         Time.at(secs, 0, :nanosecond)           # => 2000-12-31 23:59:59 -0600
  #         Time.at(secs, 500000000, :nanosecond)   # => 2000-12-31 23:59:59.5 -0600
  #         Time.at(secs, 1000000000, :nanosecond)  # => 2001-01-01 00:00:00 -0600
  #         Time.at(secs, -1000000000, :nanosecond) # => 2000-12-31 23:59:58 -0600
  #
  # Optional keyword argument `in: zone` specifies the timezone for the returned
  # time:
  #
  #     Time.at(secs, in: '+12:00') # => 2001-01-01 17:59:59 +1200
  #     Time.at(secs, in: '-12:00') # => 2000-12-31 17:59:59 -1200
  #
  # For the forms of argument `zone`, see [Timezone
  # Specifiers](rdoc-ref:Time@Timezone+Specifiers).
  #
  def self.at: (Time, ?in: String | Integer | nil) -> Time
             | (Numeric, ?in: String | Integer | nil) -> Time
             | (Integer sec_i, Numeric msec, subsec_unit msec, ?in: String | Integer | nil) -> Time

  type subsec_unit = :msec | :millisecond | :usec | :microsecond | :nsec | :nanosecond

  # <!-- rdoc-file=time.c -->
  # Returns a new `Time` object based the on given arguments, in the UTC timezone.
  #
  # With one to seven arguments given, the arguments are interpreted as in the
  # first calling sequence above:
  #
  #     Time.utc(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0)
  #
  # Examples:
  #
  #     Time.utc(2000)  # => 2000-01-01 00:00:00 UTC
  #     Time.utc(-2000) # => -2000-01-01 00:00:00 UTC
  #
  # There are no minimum and maximum values for the required argument `year`.
  #
  # For the optional arguments:
  #
  # *   `month`: Month in range (1..12), or case-insensitive 3-letter month name:
  #
  #         Time.utc(2000, 1)     # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 12)    # => 2000-12-01 00:00:00 UTC
  #         Time.utc(2000, 'jan') # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 'JAN') # => 2000-01-01 00:00:00 UTC
  #
  # *   `mday`: Month day in range(1..31):
  #
  #         Time.utc(2000, 1, 1)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 31) # => 2000-01-31 00:00:00 UTC
  #
  # *   `hour`: Hour in range (0..23), or 24 if `min`, `sec`, and `usec` are zero:
  #
  #         Time.utc(2000, 1, 1, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 23) # => 2000-01-01 23:00:00 UTC
  #         Time.utc(2000, 1, 1, 24) # => 2000-01-02 00:00:00 UTC
  #
  # *   `min`: Minute in range (0..59):
  #
  #         Time.utc(2000, 1, 1, 0, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 59) # => 2000-01-01 00:59:00 UTC
  #
  # *   `sec`: Second in range (0..59), or 60 if `usec` is zero:
  #
  #         Time.utc(2000, 1, 1, 0, 0, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 59) # => 2000-01-01 00:00:59 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 60) # => 2000-01-01 00:01:00 UTC
  #
  # *   `usec`: Microsecond in range (0..999999):
  #
  #         Time.utc(2000, 1, 1, 0, 0, 0, 0)      # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 0, 999999) # => 2000-01-01 00:00:00.999999 UTC
  #
  # The values may be:
  #
  # *   Integers, as above.
  # *   Numerics convertible to integers:
  #
  #         Time.utc(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0, 0.0)
  #         # => 0000-01-01 00:00:00 UTC
  #
  # *   String integers:
  #
  #         a = %w[0 1 1 0 0 0 0 0]
  #         # => ["0", "1", "1", "0", "0", "0", "0", "0"]
  #         Time.utc(*a) # => 0000-01-01 00:00:00 UTC
  #
  # When exactly ten arguments are given, the arguments are interpreted as in the
  # second calling sequence above:
  #
  #     Time.utc(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy)
  #
  # where the `dummy` arguments are ignored:
  #
  #     a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     Time.utc(*a) # => 0005-04-03 02:01:00 UTC
  #
  # This form is useful for creating a `Time` object from a 10-element array
  # returned by Time.to_a:
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6) # => 2000-01-02 03:04:05 +000006
  #     a = t.to_a   # => [5, 4, 3, 2, 1, 2000, 0, 2, false, nil]
  #     Time.utc(*a) # => 2000-01-02 03:04:05 UTC
  #
  # The two forms have their first six arguments in common, though in different
  # orders; the ranges of these common arguments are the same for both forms; see
  # above.
  #
  # Raises an exception if the number of arguments is eight, nine, or greater than
  # ten.
  #
  # Related: Time.local.
  #
  def self.gm: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.local(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0) -> new_time
  #   - Time.local(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Like Time.utc, except that the returned `Time` object has the local timezone,
  # not the UTC timezone:
  #
  #     # With seven arguments.
  #     Time.local(0, 1, 2, 3, 4, 5, 6)
  #     # => 0000-01-02 03:04:05.000006 -0600
  #     # With exactly ten arguments.
  #     Time.local(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  #     # => 0005-04-03 02:01:00 -0600
  #
  def self.local: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=timev.rb
  #   - now(in: nil)
  # -->
  # Creates a new `Time` object from the current system time. This is the same as
  # Time.new without arguments.
  #
  #     Time.now               # => 2009-06-24 12:39:54 +0900
  #     Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400
  #
  # For forms of argument `zone`, see [Timezone
  # Specifiers](rdoc-ref:Time@Timezone+Specifiers).
  #
  def self.now: (?in: String | Integer | nil) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.utc(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0) -> new_time
  #   - Time.utc(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Returns a new `Time` object based the on given arguments, in the UTC timezone.
  #
  # With one to seven arguments given, the arguments are interpreted as in the
  # first calling sequence above:
  #
  #     Time.utc(year, month = 1, mday = 1, hour = 0, min = 0, sec = 0, usec = 0)
  #
  # Examples:
  #
  #     Time.utc(2000)  # => 2000-01-01 00:00:00 UTC
  #     Time.utc(-2000) # => -2000-01-01 00:00:00 UTC
  #
  # There are no minimum and maximum values for the required argument `year`.
  #
  # For the optional arguments:
  #
  # *   `month`: Month in range (1..12), or case-insensitive 3-letter month name:
  #
  #         Time.utc(2000, 1)     # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 12)    # => 2000-12-01 00:00:00 UTC
  #         Time.utc(2000, 'jan') # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 'JAN') # => 2000-01-01 00:00:00 UTC
  #
  # *   `mday`: Month day in range(1..31):
  #
  #         Time.utc(2000, 1, 1)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 31) # => 2000-01-31 00:00:00 UTC
  #
  # *   `hour`: Hour in range (0..23), or 24 if `min`, `sec`, and `usec` are zero:
  #
  #         Time.utc(2000, 1, 1, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 23) # => 2000-01-01 23:00:00 UTC
  #         Time.utc(2000, 1, 1, 24) # => 2000-01-02 00:00:00 UTC
  #
  # *   `min`: Minute in range (0..59):
  #
  #         Time.utc(2000, 1, 1, 0, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 59) # => 2000-01-01 00:59:00 UTC
  #
  # *   `sec`: Second in range (0..59), or 60 if `usec` is zero:
  #
  #         Time.utc(2000, 1, 1, 0, 0, 0)  # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 59) # => 2000-01-01 00:00:59 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 60) # => 2000-01-01 00:01:00 UTC
  #
  # *   `usec`: Microsecond in range (0..999999):
  #
  #         Time.utc(2000, 1, 1, 0, 0, 0, 0)      # => 2000-01-01 00:00:00 UTC
  #         Time.utc(2000, 1, 1, 0, 0, 0, 999999) # => 2000-01-01 00:00:00.999999 UTC
  #
  # The values may be:
  #
  # *   Integers, as above.
  # *   Numerics convertible to integers:
  #
  #         Time.utc(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0, 0.0)
  #         # => 0000-01-01 00:00:00 UTC
  #
  # *   String integers:
  #
  #         a = %w[0 1 1 0 0 0 0 0]
  #         # => ["0", "1", "1", "0", "0", "0", "0", "0"]
  #         Time.utc(*a) # => 0000-01-01 00:00:00 UTC
  #
  # When exactly ten arguments are given, the arguments are interpreted as in the
  # second calling sequence above:
  #
  #     Time.utc(sec, min, hour, mday, month, year, dummy, dummy, dummy, dummy)
  #
  # where the `dummy` arguments are ignored:
  #
  #     a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  #     Time.utc(*a) # => 0005-04-03 02:01:00 UTC
  #
  # This form is useful for creating a `Time` object from a 10-element array
  # returned by Time.to_a:
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6) # => 2000-01-02 03:04:05 +000006
  #     a = t.to_a   # => [5, 4, 3, 2, 1, 2000, 0, 2, false, nil]
  #     Time.utc(*a) # => 2000-01-02 03:04:05 UTC
  #
  # The two forms have their first six arguments in common, though in different
  # orders; the ranges of these common arguments are the same for both forms; see
  # above.
  #
  # Raises an exception if the number of arguments is eight, nine, or greater than
  # ten.
  #
  # Related: Time.local.
  #
  def self.utc: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - self + numeric -> new_time
  # -->
  # Returns a new `Time` object whose value is the sum of the numeric value of
  # `self` and the given `numeric`:
  #
  #     t = Time.new(2000) # => 2000-01-01 00:00:00 -0600
  #     t + (60 * 60 * 24) # => 2000-01-02 00:00:00 -0600
  #     t + 0.5            # => 2000-01-01 00:00:00.5 -0600
  #
  # Related: Time#-.
  #
  def +: (Numeric arg0) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - self - numeric -> new_time
  #   - self - other_time -> float
  # -->
  # When `numeric` is given, returns a new `Time` object whose value is the
  # difference of the numeric value of `self` and `numeric`:
  #
  #     t = Time.new(2000) # => 2000-01-01 00:00:00 -0600
  #     t - (60 * 60 * 24) # => 1999-12-31 00:00:00 -0600
  #     t - 0.5            # => 1999-12-31 23:59:59.5 -0600
  #
  # When `other_time` is given, returns a Float whose value is the difference of
  # the numeric values of `self` and `other_time` in seconds:
  #
  #     t - t # => 0.0
  #
  # Related: Time#+.
  #
  def -: (Time arg0) -> Float
       | (Numeric arg0) -> Time

  def <: (Time arg0) -> bool

  def <=: (Time arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - self <=> other_time -> -1, 0, +1, or nil
  # -->
  # Compares `self` with `other_time`; returns:
  #
  # *   `-1`, if `self` is less than `other_time`.
  # *   `0`, if `self` is equal to `other_time`.
  # *   `1`, if `self` is greater then `other_time`.
  # *   `nil`, if `self` and `other_time` are incomparable.
  #
  # Examples:
  #
  #     t = Time.now     # => 2007-11-19 08:12:12 -0600
  #     t2 = t + 2592000 # => 2007-12-19 08:12:12 -0600
  #     t <=> t2         # => -1
  #     t2 <=> t         # => 1
  #
  #     t = Time.now     # => 2007-11-19 08:13:38 -0600
  #     t2 = t + 0.1     # => 2007-11-19 08:13:38 -0600
  #     t.nsec           # => 98222999
  #     t2.nsec          # => 198222999
  #     t <=> t2         # => -1
  #     t2 <=> t         # => 1
  #     t <=> t          # => 0
  #
  def <=>: (Time other) -> Integer
         | (untyped other) -> Integer?

  def >: (Time arg0) -> bool

  def >=: (Time arg0) -> bool

  # <!-- rdoc-file=time.c -->
  # Returns a string representation of `self`, formatted by `strftime('%a %b %e %T
  # %Y')` or its shorthand version `strftime('%c')`; see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc):
  #
  #     t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
  #     t.ctime                      # => "Sun Dec 31 23:59:59 2000"
  #     t.strftime('%a %b %e %T %Y') # => "Sun Dec 31 23:59:59 2000"
  #     t.strftime('%c')             # => "Sun Dec 31 23:59:59 2000"
  #
  # Related: Time#to_s, Time#inspect:
  #
  #     t.inspect                    # => "2000-12-31 23:59:59.5 +000001"
  #     t.to_s                       # => "2000-12-31 23:59:59 +0000"
  #
  def asctime: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - ctime -> string
  # -->
  # Returns a string representation of `self`, formatted by `strftime('%a %b %e %T
  # %Y')` or its shorthand version `strftime('%c')`; see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc):
  #
  #     t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
  #     t.ctime                      # => "Sun Dec 31 23:59:59 2000"
  #     t.strftime('%a %b %e %T %Y') # => "Sun Dec 31 23:59:59 2000"
  #     t.strftime('%c')             # => "Sun Dec 31 23:59:59 2000"
  #
  # Related: Time#to_s, Time#inspect:
  #
  #     t.inspect                    # => "2000-12-31 23:59:59.5 +000001"
  #     t.to_s                       # => "2000-12-31 23:59:59 +0000"
  #
  def ctime: () -> String

  # <!-- rdoc-file=time.c -->
  # Returns the integer day of the month for `self`, in range (1..31):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.mday # => 2
  #
  # Related: Time#year, Time#hour, Time#min.
  #
  def day: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - deconstruct_keys(array_of_names_or_nil) -> hash
  # -->
  # Returns a hash of the name/value pairs, to use in pattern matching. Possible
  # keys are: `:year`, `:month`, `:day`, `:yday`, `:wday`, `:hour`, `:min`,
  # `:sec`, `:subsec`, `:dst`, `:zone`.
  #
  # Possible usages:
  #
  #     t = Time.utc(2022, 10, 5, 21, 25, 30)
  #
  #     if t in wday: 3, day: ..7  # uses deconstruct_keys underneath
  #       puts "first Wednesday of the month"
  #     end
  #     #=> prints "first Wednesday of the month"
  #
  #     case t
  #     in year: ...2022
  #       puts "too old"
  #     in month: ..9
  #       puts "quarter 1-3"
  #     in wday: 1..5, month:
  #       puts "working day in month #{month}"
  #     end
  #     #=> prints "working day in month 10"
  #
  # Note that deconstruction by pattern can also be combined with class check:
  #
  #     if t in Time(wday: 3, day: ..7)
  #       puts "first Wednesday of the month"
  #     end
  #
  def deconstruct_keys: (Array[Symbol]?) -> Hash[Symbol, Integer]

  # <!-- rdoc-file=time.c -->
  # Returns `true` if `self` is in daylight saving time, `false` otherwise:
  #
  #     t = Time.local(2000, 1, 1) # => 2000-01-01 00:00:00 -0600
  #     t.zone                     # => "Central Standard Time"
  #     t.dst?                     # => false
  #     t = Time.local(2000, 7, 1) # => 2000-07-01 00:00:00 -0500
  #     t.zone                     # => "Central Daylight Time"
  #     t.dst?                     # => true
  #
  def dst?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - eql?(other_time)
  # -->
  # Returns `true` if `self` and `other_time` are both `Time` objects with the
  # exact same time value.
  #
  def eql?: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - friday? -> true or false
  # -->
  # Returns `true` if `self` represents a Friday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 7) # => 2000-01-07 00:00:00 UTC
  #     t.friday?                # => true
  #
  # Related: Time#saturday?, Time#sunday?, Time#monday?.
  #
  def friday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - getutc -> new_time
  # -->
  # Returns a new `Time` object representing the value of `self` converted to the
  # UTC timezone:
  #
  #     local = Time.local(2000) # => 2000-01-01 00:00:00 -0600
  #     local.utc?               # => false
  #     utc = local.getutc       # => 2000-01-01 06:00:00 UTC
  #     utc.utc?                 # => true
  #     utc == local             # => true
  #
  def getgm: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - getlocal(zone = nil) -> new_time
  # -->
  # Returns a new `Time` object representing the value of `self` converted to a
  # given timezone; if `zone` is `nil`, the local timezone is used:
  #
  #     t = Time.utc(2000)                    # => 2000-01-01 00:00:00 UTC
  #     t.getlocal                            # => 1999-12-31 18:00:00 -0600
  #     t.getlocal('+12:00')                  # => 2000-01-01 12:00:00 +1200
  #
  # For forms of argument `zone`, see [Timezone
  # Specifiers](rdoc-ref:Time@Timezone+Specifiers).
  #
  def getlocal: (?Integer utc_offset) -> Time

  # <!-- rdoc-file=time.c -->
  # Returns a new `Time` object representing the value of `self` converted to the
  # UTC timezone:
  #
  #     local = Time.local(2000) # => 2000-01-01 00:00:00 -0600
  #     local.utc?               # => false
  #     utc = local.getutc       # => 2000-01-01 06:00:00 UTC
  #     utc.utc?                 # => true
  #     utc == local             # => true
  #
  def getutc: () -> Time

  # <!-- rdoc-file=time.c -->
  # Returns `true` if `self` represents a time in UTC (GMT):
  #
  #     now = Time.now
  #     # => 2022-08-18 10:24:13.5398485 -0500
  #     now.utc? # => false
  #     utc = Time.utc(2000, 1, 1, 20, 15, 1)
  #     # => 2000-01-01 20:15:01 UTC
  #     utc.utc? # => true
  #
  # Related: Time.utc.
  #
  def gmt?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezones of UTC and `self`:
  #
  #     Time.utc(2000, 1, 1).utc_offset   # => 0
  #     Time.local(2000, 1, 1).utc_offset # => -21600 # -6*3600, or minus six hours.
  #
  def gmt_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - utc -> self
  # -->
  # Returns `self`, converted to the UTC timezone:
  #
  #     t = Time.new(2000) # => 2000-01-01 00:00:00 -0600
  #     t.utc?             # => false
  #     t.utc              # => 2000-01-01 06:00:00 UTC
  #     t.utc?             # => true
  #
  # Related: Time#getutc (returns a new converted `Time` object).
  #
  def gmtime: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - hash -> integer
  # -->
  # Returns the integer hash code for `self`.
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - hour -> integer
  # -->
  # Returns the integer hour of the day for `self`, in range (0..23):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.hour # => 3
  #
  # Related: Time#year, Time#mon, Time#min.
  #
  def hour: () -> Integer

  # <!--
  #   rdoc-file=timev.rb
  #   - Time.new(year = nil, mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil, precision: 9)
  # -->
  # Returns a new `Time` object based on the given arguments, by default in the
  # local timezone.
  #
  # With no positional arguments, returns the value of Time.now:
  #
  #     Time.new # => 2021-04-24 17:27:46.0512465 -0500
  #
  # With one string argument that represents a time, returns a new `Time` object
  # based on the given argument, in the local timezone.
  #
  #     Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600
  #     Time.new('2000-12-31 23:59:59.5 +0900')        # => 2000-12-31 23:59:59.5 +0900
  #     Time.new('2000-12-31 23:59:59.5', in: '+0900') # => 2000-12-31 23:59:59.5 +0900
  #     Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600
  #     Time.new('2000-12-31 23:59:59.56789', precision: 3) # => 2000-12-31 23:59:59.567 -0600
  #
  # With one to six arguments, returns a new `Time` object based on the given
  # arguments, in the local timezone.
  #
  #     Time.new(2000, 1, 2, 3, 4, 5) # => 2000-01-02 03:04:05 -0600
  #
  # For the positional arguments (other than `zone`):
  #
  # *   `year`: Year, with no range limits:
  #
  #         Time.new(999999999)  # => 999999999-01-01 00:00:00 -0600
  #         Time.new(-999999999) # => -999999999-01-01 00:00:00 -0600
  #
  # *   `month`: Month in range (1..12), or case-insensitive 3-letter month name:
  #
  #         Time.new(2000, 1)     # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 12)    # => 2000-12-01 00:00:00 -0600
  #         Time.new(2000, 'jan') # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 'JAN') # => 2000-01-01 00:00:00 -0600
  #
  # *   `mday`: Month day in range(1..31):
  #
  #         Time.new(2000, 1, 1)  # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 1, 31) # => 2000-01-31 00:00:00 -0600
  #
  # *   `hour`: Hour in range (0..23), or 24 if `min`, `sec`, and `usec` are zero:
  #
  #         Time.new(2000, 1, 1, 0)  # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 1, 1, 23) # => 2000-01-01 23:00:00 -0600
  #         Time.new(2000, 1, 1, 24) # => 2000-01-02 00:00:00 -0600
  #
  # *   `min`: Minute in range (0..59):
  #
  #         Time.new(2000, 1, 1, 0, 0)  # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 1, 1, 0, 59) # => 2000-01-01 00:59:00 -0600
  #
  # *   `sec`: Second in range (0...61):
  #
  #         Time.new(2000, 1, 1, 0, 0, 0)  # => 2000-01-01 00:00:00 -0600
  #         Time.new(2000, 1, 1, 0, 0, 59) # => 2000-01-01 00:00:59 -0600
  #         Time.new(2000, 1, 1, 0, 0, 60) # => 2000-01-01 00:01:00 -0600
  #
  #     `sec` may be Float or Rational.
  #
  #         Time.new(2000, 1, 1, 0, 0, 59.5)  # => 2000-12-31 23:59:59.5 +0900
  #         Time.new(2000, 1, 1, 0, 0, 59.7r) # => 2000-12-31 23:59:59.7 +0900
  #
  # These values may be:
  #
  # *   Integers, as above.
  # *   Numerics convertible to integers:
  #
  #         Time.new(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0)
  #         # => 0000-01-01 00:00:00 -0600
  #
  # *   String integers:
  #
  #         a = %w[0 1 1 0 0 0]
  #         # => ["0", "1", "1", "0", "0", "0"]
  #         Time.new(*a) # => 0000-01-01 00:00:00 -0600
  #
  # When positional argument `zone` or keyword argument `in:` is given, the new
  # `Time` object is in the specified timezone. For the forms of argument `zone`,
  # see [Timezone Specifiers](rdoc-ref:Time@Timezone+Specifiers):
  #
  #     Time.new(2000, 1, 1, 0, 0, 0, '+12:00')
  #     # => 2000-01-01 00:00:00 +1200
  #     Time.new(2000, 1, 1, 0, 0, 0, in: '-12:00')
  #     # => 2000-01-01 00:00:00 -1200
  #     Time.new(in: '-12:00')
  #     # => 2022-08-23 08:49:26.1941467 -1200
  #
  # Since `in:` keyword argument just provides the default, so if the first
  # argument in single string form contains time zone information, this keyword
  # argument will be silently ignored.
  #
  #     Time.new('2000-01-01 00:00:00 +0100', in: '-0500').utc_offset  # => 3600
  #
  # *   `precision`: maximum effective digits in sub-second part, default is 9.
  #     More digits will be truncated, as other operations of `Time`. Ignored
  #     unless the first argument is a string.
  #
  def initialize: (?Integer year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, ?String | Integer | nil) -> void
                | (?Integer year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, in: String | Integer | nil) -> void
                | (String, ?in: string | int | nil, ?precision: int) -> void

  # <!--
  #   rdoc-file=time.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self` with subseconds:
  #
  #     t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
  #     t.inspect # => "2000-12-31 23:59:59.5 +000001"
  #
  # Related: Time#ctime, Time#to_s:
  #
  #     t.ctime   # => "Sun Dec 31 23:59:59 2000"
  #     t.to_s    # => "2000-12-31 23:59:59 +0000"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - dst?  -> true or false
  # -->
  # Returns `true` if `self` is in daylight saving time, `false` otherwise:
  #
  #     t = Time.local(2000, 1, 1) # => 2000-01-01 00:00:00 -0600
  #     t.zone                     # => "Central Standard Time"
  #     t.dst?                     # => false
  #     t = Time.local(2000, 7, 1) # => 2000-07-01 00:00:00 -0500
  #     t.zone                     # => "Central Daylight Time"
  #     t.dst?                     # => true
  #
  def isdst: () -> bool

  # <!-- rdoc-file=lib/time.rb -->
  # Parses `time` as a dateTime defined by the XML Schema and converts it to a
  # Time object.  The format is a restricted version of the format defined by ISO
  # 8601.
  #
  # ArgumentError is raised if `time` is not compliant with the format or if the
  # Time class cannot represent the specified time.
  #
  # See #xmlschema for more information on this format.
  #
  #     require 'time'
  #
  #     Time.xmlschema("2011-10-05T22:26:12-04:00")
  #     #=> 2011-10-05 22:26:12-04:00
  #
  # You must require 'time' to use this method.
  #
  alias iso8601 xmlschema

  # <!--
  #   rdoc-file=time.c
  #   - localtime -> self or new_time
  #   - localtime(zone) -> new_time
  # -->
  # With no argument given:
  #
  # *   Returns `self` if `self` is a local time.
  # *   Otherwise returns a new `Time` in the user's local timezone:
  #
  #         t = Time.utc(2000, 1, 1, 20, 15, 1) # => 2000-01-01 20:15:01 UTC
  #         t.localtime                         # => 2000-01-01 14:15:01 -0600
  #
  # With argument `zone` given, returns the new `Time` object created by
  # converting `self` to the given time zone:
  #
  #     t = Time.utc(2000, 1, 1, 20, 15, 1) # => 2000-01-01 20:15:01 UTC
  #     t.localtime("-09:00")               # => 2000-01-01 11:15:01 -0900
  #
  # For forms of argument `zone`, see [Timezone
  # Specifiers](rdoc-ref:Time@Timezone+Specifiers).
  #
  def localtime: (?String utc_offset) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - mday -> integer
  # -->
  # Returns the integer day of the month for `self`, in range (1..31):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.mday # => 2
  #
  # Related: Time#year, Time#hour, Time#min.
  #
  def mday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - min -> integer
  # -->
  # Returns the integer minute of the hour for `self`, in range (0..59):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.min # => 4
  #
  # Related: Time#year, Time#mon, Time#sec.
  #
  def min: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - mon -> integer
  # -->
  # Returns the integer month of the year for `self`, in range (1..12):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.mon # => 1
  #
  # Related: Time#year, Time#hour, Time#min.
  #
  def mon: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - monday? -> true or false
  # -->
  # Returns `true` if `self` represents a Monday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 3) # => 2000-01-03 00:00:00 UTC
  #     t.monday?                # => true
  #
  # Related: Time#tuesday?, Time#wednesday?, Time#thursday?.
  #
  def monday?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the number of nanoseconds in the subseconds part of `self` in the
  # range (0..999_999_999); lower-order digits are truncated, not rounded:
  #
  #     t = Time.now # => 2022-07-11 15:04:53.3219637 -0500
  #     t.nsec       # => 321963700
  #
  # Related: Time#subsec (returns exact subseconds).
  #
  def nsec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - round(ndigits = 0) -> new_time
  # -->
  # Returns a new `Time` object whose numeric value is that of `self`, with its
  # seconds value rounded to precision `ndigits`:
  #
  #     t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
  #     t          # => 2010-03-30 05:43:25.123456789 UTC
  #     t.round    # => 2010-03-30 05:43:25 UTC
  #     t.round(0) # => 2010-03-30 05:43:25 UTC
  #     t.round(1) # => 2010-03-30 05:43:25.1 UTC
  #     t.round(2) # => 2010-03-30 05:43:25.12 UTC
  #     t.round(3) # => 2010-03-30 05:43:25.123 UTC
  #     t.round(4) # => 2010-03-30 05:43:25.1235 UTC
  #
  #     t = Time.utc(1999, 12,31, 23, 59, 59)
  #     t                # => 1999-12-31 23:59:59 UTC
  #     (t + 0.4).round  # => 1999-12-31 23:59:59 UTC
  #     (t + 0.49).round # => 1999-12-31 23:59:59 UTC
  #     (t + 0.5).round  # => 2000-01-01 00:00:00 UTC
  #     (t + 1.4).round  # => 2000-01-01 00:00:00 UTC
  #     (t + 1.49).round # => 2000-01-01 00:00:00 UTC
  #     (t + 1.5).round  # => 2000-01-01 00:00:01 UTC
  #
  # Related: Time#ceil, Time#floor.
  #
  def round: (?int ndigits) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - saturday? -> true or false
  # -->
  # Returns `true` if `self` represents a Saturday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 1) # => 2000-01-01 00:00:00 UTC
  #     t.saturday?              # => true
  #
  # Related: Time#sunday?, Time#monday?, Time#tuesday?.
  #
  def saturday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - sec -> integer
  # -->
  # Returns the integer second of the minute for `self`, in range (0..60):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.sec # => 5
  #
  # Note: the second value may be 60 when there is a [leap
  # second](https://en.wikipedia.org/wiki/Leap_second).
  #
  # Related: Time#year, Time#mon, Time#min.
  #
  def sec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - strftime(format_string) -> string
  # -->
  # Returns a string representation of `self`, formatted according to the given
  # string `format`. See [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc).
  #
  def strftime: (String arg0) -> String

  # <!--
  #   rdoc-file=time.c
  #   - subsec -> numeric
  # -->
  # Returns the exact subseconds for `self` as a Numeric (Integer or Rational):
  #
  #     t = Time.now # => 2022-07-11 15:11:36.8490302 -0500
  #     t.subsec     # => (4245151/5000000)
  #
  # If the subseconds is zero, returns integer zero:
  #
  #     t = Time.new(2000, 1, 1, 2, 3, 4) # => 2000-01-01 02:03:04 -0600
  #     t.subsec                          # => 0
  #
  def subsec: () -> (0 | Rational)

  # <!--
  #   rdoc-file=time.c
  #   - sunday? -> true or false
  # -->
  # Returns `true` if `self` represents a Sunday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 2) # => 2000-01-02 00:00:00 UTC
  #     t.sunday?                # => true
  #
  # Related: Time#monday?, Time#tuesday?, Time#wednesday?.
  #
  def sunday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - thursday? -> true or false
  # -->
  # Returns `true` if `self` represents a Thursday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 6) # => 2000-01-06 00:00:00 UTC
  #     t.thursday?              # => true
  #
  # Related: Time#friday?, Time#saturday?, Time#sunday?.
  #
  def thursday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - to_a -> array
  # -->
  # Returns a 10-element array of values representing `self`:
  #
  #     Time.utc(2000, 1, 1).to_a
  #     # => [0,   0,   0,    1,   1,   2000, 6,    1,    false, "UTC"]
  #     #    [sec, min, hour, day, mon, year, wday, yday, dst?,   zone]
  #
  # The returned array is suitable for use as an argument to Time.utc or
  # Time.local to create a new `Time` object.
  #
  def to_a: () -> [ Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, bool, String? ]

  # <!--
  #   rdoc-file=time.c
  #   - to_f -> float
  # -->
  # Returns the value of `self` as a Float number [Epoch
  # seconds](rdoc-ref:Time@Epoch+Seconds); subseconds are included.
  #
  # The stored value of `self` is a [Rational](rdoc-ref:Rational@#method-i-to_f),
  # which means that the returned value may be approximate:
  #
  #     Time.utc(1970, 1, 1, 0, 0, 0).to_f         # => 0.0
  #     Time.utc(1970, 1, 1, 0, 0, 0, 999999).to_f # => 0.999999
  #     Time.utc(1950, 1, 1, 0, 0, 0).to_f         # => -631152000.0
  #     Time.utc(1990, 1, 1, 0, 0, 0).to_f         # => 631152000.0
  #
  # Related: Time#to_i, Time#to_r.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=time.c
  #   - to_i -> integer
  # -->
  # Returns the value of `self` as integer [Epoch
  # seconds](rdoc-ref:Time@Epoch+Seconds); subseconds are truncated (not rounded):
  #
  #     Time.utc(1970, 1, 1, 0, 0, 0).to_i         # => 0
  #     Time.utc(1970, 1, 1, 0, 0, 0, 999999).to_i # => 0
  #     Time.utc(1950, 1, 1, 0, 0, 0).to_i         # => -631152000
  #     Time.utc(1990, 1, 1, 0, 0, 0).to_i         # => 631152000
  #
  # Related: Time#to_f Time#to_r.
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - to_r -> rational
  # -->
  # Returns the value of `self` as a Rational exact number of [Epoch
  # seconds](rdoc-ref:Time@Epoch+Seconds);
  #
  #     Time.now.to_r # => (16571402750320203/10000000)
  #
  # Related: Time#to_f, Time#to_i.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=time.c
  #   - to_s    -> string
  # -->
  # Returns a string representation of `self`, without subseconds:
  #
  #     t = Time.new(2000, 12, 31, 23, 59, 59, 0.5)
  #     t.to_s    # => "2000-12-31 23:59:59 +0000"
  #
  # Related: Time#ctime, Time#inspect:
  #
  #     t.ctime   # => "Sun Dec 31 23:59:59 2000"
  #     t.inspect # => "2000-12-31 23:59:59.5 +000001"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - tuesday? -> true or false
  # -->
  # Returns `true` if `self` represents a Tuesday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 4) # => 2000-01-04 00:00:00 UTC
  #     t.tuesday?               # => true
  #
  # Related: Time#wednesday?, Time#thursday?, Time#friday?.
  #
  def tuesday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - nsec -> integer
  # -->
  # Returns the number of nanoseconds in the subseconds part of `self` in the
  # range (0..999_999_999); lower-order digits are truncated, not rounded:
  #
  #     t = Time.now # => 2022-07-11 15:04:53.3219637 -0500
  #     t.nsec       # => 321963700
  #
  # Related: Time#subsec (returns exact subseconds).
  #
  def tv_nsec: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns the value of `self` as integer [Epoch
  # seconds](rdoc-ref:Time@Epoch+Seconds); subseconds are truncated (not rounded):
  #
  #     Time.utc(1970, 1, 1, 0, 0, 0).to_i         # => 0
  #     Time.utc(1970, 1, 1, 0, 0, 0, 999999).to_i # => 0
  #     Time.utc(1950, 1, 1, 0, 0, 0).to_i         # => -631152000
  #     Time.utc(1990, 1, 1, 0, 0, 0).to_i         # => 631152000
  #
  # Related: Time#to_f Time#to_r.
  #
  def tv_sec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - usec -> integer
  # -->
  # Returns the number of microseconds in the subseconds part of `self` in the
  # range (0..999_999); lower-order digits are truncated, not rounded:
  #
  #     t = Time.now # => 2022-07-11 14:59:47.5484697 -0500
  #     t.usec       # => 548469
  #
  # Related: Time#subsec (returns exact subseconds).
  #
  def tv_usec: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns the number of microseconds in the subseconds part of `self` in the
  # range (0..999_999); lower-order digits are truncated, not rounded:
  #
  #     t = Time.now # => 2022-07-11 14:59:47.5484697 -0500
  #     t.usec       # => 548469
  #
  # Related: Time#subsec (returns exact subseconds).
  #
  def usec: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns `self`, converted to the UTC timezone:
  #
  #     t = Time.new(2000) # => 2000-01-01 00:00:00 -0600
  #     t.utc?             # => false
  #     t.utc              # => 2000-01-01 06:00:00 UTC
  #     t.utc?             # => true
  #
  # Related: Time#getutc (returns a new converted `Time` object).
  #
  def utc: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - utc? -> true or false
  # -->
  # Returns `true` if `self` represents a time in UTC (GMT):
  #
  #     now = Time.now
  #     # => 2022-08-18 10:24:13.5398485 -0500
  #     now.utc? # => false
  #     utc = Time.utc(2000, 1, 1, 20, 15, 1)
  #     # => 2000-01-01 20:15:01 UTC
  #     utc.utc? # => true
  #
  # Related: Time.utc.
  #
  def utc?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezones of UTC and `self`:
  #
  #     Time.utc(2000, 1, 1).utc_offset   # => 0
  #     Time.local(2000, 1, 1).utc_offset # => -21600 # -6*3600, or minus six hours.
  #
  def utc_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - wday -> integer
  # -->
  # Returns the integer day of the week for `self`, in range (0..6), with Sunday
  # as zero.
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.wday    # => 0
  #     t.sunday? # => true
  #
  # Related: Time#year, Time#hour, Time#min.
  #
  def wday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - wednesday? -> true or false
  # -->
  # Returns `true` if `self` represents a Wednesday, `false` otherwise:
  #
  #     t = Time.utc(2000, 1, 5) # => 2000-01-05 00:00:00 UTC
  #     t.wednesday?             # => true
  #
  # Related: Time#thursday?, Time#friday?, Time#saturday?.
  #
  def wednesday?: () -> bool

  # <!--
  #   rdoc-file=lib/time.rb
  #   - xmlschema(fraction_digits=0)
  # -->
  # Returns a string which represents the time as a dateTime defined by XML
  # Schema:
  #
  #     CCYY-MM-DDThh:mm:ssTZD
  #     CCYY-MM-DDThh:mm:ss.sssTZD
  #
  # where TZD is Z or [+-]hh:mm.
  #
  # If self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.
  #
  # `fraction_digits` specifies a number of digits to use for fractional seconds.
  # Its default value is 0.
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.iso8601  # => "2011-10-05T22:26:12-04:00"
  #
  # You must require 'time' to use this method.
  #
  def xmlschema: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - yday -> integer
  # -->
  # Returns the integer day of the year of `self`, in range (1..366).
  #
  #     Time.new(2000, 1, 1).yday   # => 1
  #     Time.new(2000, 12, 31).yday # => 366
  #
  def yday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - year -> integer
  # -->
  # Returns the integer year for `self`:
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.year # => 2000
  #
  # Related: Time#mon, Time#hour, Time#min.
  #
  def year: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.zone -> string or timezone
  # -->
  # Returns the string name of the time zone for `self`:
  #
  #     Time.utc(2000, 1, 1).zone # => "UTC"
  #     Time.new(2000, 1, 1).zone # => "Central Standard Time"
  #
  def zone: () -> String?

  # <!-- rdoc-file=time.c -->
  # Like Time.utc, except that the returned `Time` object has the local timezone,
  # not the UTC timezone:
  #
  #     # With seven arguments.
  #     Time.local(0, 1, 2, 3, 4, 5, 6)
  #     # => 0000-01-02 03:04:05.000006 -0600
  #     # With exactly ten arguments.
  #     Time.local(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  #     # => 0005-04-03 02:01:00 -0600
  #
  def self.mktime: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - utc_offset -> integer
  # -->
  # Returns the offset in seconds between the timezones of UTC and `self`:
  #
  #     Time.utc(2000, 1, 1).utc_offset   # => 0
  #     Time.local(2000, 1, 1).utc_offset # => -21600 # -6*3600, or minus six hours.
  #
  def gmtoff: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns the integer month of the year for `self`, in range (1..12):
  #
  #     t = Time.new(2000, 1, 2, 3, 4, 5, 6)
  #     # => 2000-01-02 03:04:05 +000006
  #     t.mon # => 1
  #
  # Related: Time#year, Time#hour, Time#min.
  #
  def month: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - floor(ndigits = 0) -> new_time
  # -->
  # Returns a new `Time` object whose numerical value is less than or equal to
  # `self` with its seconds truncated to precision `ndigits`:
  #
  #     t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
  #     t           # => 2010-03-30 05:43:25.123456789 UTC
  #     t.floor     # => 2010-03-30 05:43:25 UTC
  #     t.floor(2)  # => 2010-03-30 05:43:25.12 UTC
  #     t.floor(4)  # => 2010-03-30 05:43:25.1234 UTC
  #     t.floor(6)  # => 2010-03-30 05:43:25.123456 UTC
  #     t.floor(8)  # => 2010-03-30 05:43:25.12345678 UTC
  #     t.floor(10) # => 2010-03-30 05:43:25.123456789 UTC
  #
  #     t = Time.utc(1999, 12, 31, 23, 59, 59)
  #     t               # => 1999-12-31 23:59:59 UTC
  #     (t + 0.4).floor # => 1999-12-31 23:59:59 UTC
  #     (t + 0.9).floor # => 1999-12-31 23:59:59 UTC
  #     (t + 1.4).floor # => 2000-01-01 00:00:00 UTC
  #     (t + 1.9).floor # => 2000-01-01 00:00:00 UTC
  #
  # Related: Time#ceil, Time#round.
  #
  def floor: (?int ndigits) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - ceil(ndigits = 0)   -> new_time
  # -->
  # Returns a new `Time` object whose numerical value is greater than or equal to
  # `self` with its seconds truncated to precision `ndigits`:
  #
  #     t = Time.utc(2010, 3, 30, 5, 43, 25.123456789r)
  #     t          # => 2010-03-30 05:43:25.123456789 UTC
  #     t.ceil     # => 2010-03-30 05:43:26 UTC
  #     t.ceil(2)  # => 2010-03-30 05:43:25.13 UTC
  #     t.ceil(4)  # => 2010-03-30 05:43:25.1235 UTC
  #     t.ceil(6)  # => 2010-03-30 05:43:25.123457 UTC
  #     t.ceil(8)  # => 2010-03-30 05:43:25.12345679 UTC
  #     t.ceil(10) # => 2010-03-30 05:43:25.123456789 UTC
  #
  #     t = Time.utc(1999, 12, 31, 23, 59, 59)
  #     t              # => 1999-12-31 23:59:59 UTC
  #     (t + 0.4).ceil # => 2000-01-01 00:00:00 UTC
  #     (t + 0.9).ceil # => 2000-01-01 00:00:00 UTC
  #     (t + 1.4).ceil # => 2000-01-01 00:00:01 UTC
  #     (t + 1.9).ceil # => 2000-01-01 00:00:01 UTC
  #
  # Related: Time#floor, Time#round.
  #
  def ceil: (?int ndigits) -> Time
end

Time::RFC2822_DAY_NAME: Array[String]

Time::RFC2822_MONTH_NAME: Array[String]
module RBS
  module Unnamed
    # <!-- rdoc-file=hash.c -->
    # `ENV` is a hash-like accessor for environment variables.
    #
    # ### Interaction with the Operating System
    #
    # The `ENV` object interacts with the operating system's environment variables:
    #
    # *   When you get the value for a name in `ENV`, the value is retrieved from
    #     among the current environment variables.
    # *   When you create or set a name-value pair in `ENV`, the name and value are
    #     immediately set in the environment variables.
    # *   When you delete a name-value pair in `ENV`, it is immediately deleted from
    #     the environment variables.
    #
    # ### Names and Values
    #
    # Generally, a name or value is a String.
    #
    # #### Valid Names and Values
    #
    # Each name or value must be one of the following:
    #
    # *   A String.
    # *   An object that responds to #to_str by returning a String, in which case
    #     that String will be used as the name or value.
    #
    # #### Invalid Names and Values
    #
    # A new name:
    #
    # *   May not be the empty string:
    #         ENV[''] = '0'
    #         # Raises Errno::EINVAL (Invalid argument - ruby_setenv())
    #
    # *   May not contain character `"="`:
    #         ENV['='] = '0'
    #         # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))
    #
    # A new name or value:
    #
    # *   May not be a non-String that does not respond to #to_str:
    #
    #         ENV['foo'] = Object.new
    #         # Raises TypeError (no implicit conversion of Object into String)
    #         ENV[Object.new] = '0'
    #         # Raises TypeError (no implicit conversion of Object into String)
    #
    # *   May not contain the NUL character `"\0"`:
    #
    #         ENV['foo'] = "\0"
    #         # Raises ArgumentError (bad environment variable value: contains null byte)
    #         ENV["\0"] == '0'
    #         # Raises ArgumentError (bad environment variable name: contains null byte)
    #
    # *   May not have an ASCII-incompatible encoding such as UTF-16LE or
    #     ISO-2022-JP:
    #
    #         ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
    #         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
    #         ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
    #         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
    #
    # ### About Ordering
    #
    # `ENV` enumerates its name/value pairs in the order found in the operating
    # system's environment variables. Therefore the ordering of `ENV` content is
    # OS-dependent, and may be indeterminate.
    #
    # This will be seen in:
    # *   A Hash returned by an `ENV` method.
    # *   An Enumerator returned by an `ENV` method.
    # *   An Array returned by ENV.keys, ENV.values, or ENV.to_a.
    # *   The String returned by ENV.inspect.
    # *   The Array returned by ENV.shift.
    # *   The name returned by ENV.key.
    #
    # ### About the Examples
    # Some methods in `ENV` return `ENV` itself. Typically, there are many
    # environment variables. It's not useful to display a large `ENV` in the
    # examples here, so most example snippets begin by resetting the contents of
    # `ENV`:
    # *   ENV.replace replaces `ENV` with a new collection of entries.
    # *   ENV.clear empties `ENV`.
    #
    # ### What's Here
    #
    # First, what's elsewhere. Class `ENV`:
    #
    # *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
    # *   Extends [module Enumerable](rdoc-ref:Enumerable@What-27s+Here),
    #
    # Here, class `ENV` provides methods that are useful for:
    #
    # *   [Querying](rdoc-ref:ENV@Methods+for+Querying)
    # *   [Assigning](rdoc-ref:ENV@Methods+for+Assigning)
    # *   [Deleting](rdoc-ref:ENV@Methods+for+Deleting)
    # *   [Iterating](rdoc-ref:ENV@Methods+for+Iterating)
    # *   [Converting](rdoc-ref:ENV@Methods+for+Converting)
    # *   [And more ....](rdoc-ref:ENV@More+Methods)
    #
    # #### Methods for Querying
    #
    # *   ::[]: Returns the value for the given environment variable name if it
    #     exists:
    # *   ::empty?: Returns whether `ENV` is empty.
    # *   ::has_value?, ::value?: Returns whether the given value is in `ENV`.
    # *   ::include?, ::has_key?, ::key?, ::member?: Returns whether the given name
    #     is in `ENV`.
    # *   ::key: Returns the name of the first entry with the given value.
    # *   ::size, ::length: Returns the number of entries.
    # *   ::value?: Returns whether any entry has the given value.
    #
    # #### Methods for Assigning
    #
    # *   ::[]=, ::store: Creates, updates, or deletes the named environment
    #     variable.
    # *   ::clear: Removes every environment variable; returns `ENV`:
    # *   ::update, ::merge!: Adds to `ENV` each key/value pair in the given hash.
    # *   ::replace: Replaces the entire content of the `ENV` with the name/value
    #     pairs in the given hash.
    #
    # #### Methods for Deleting
    #
    # *   ::delete: Deletes the named environment variable name if it exists.
    # *   ::delete_if: Deletes entries selected by the block.
    # *   ::keep_if: Deletes entries not selected by the block.
    # *   ::reject!: Similar to #delete_if, but returns `nil` if no change was made.
    # *   ::select!, ::filter!: Deletes entries selected by the block.
    # *   ::shift: Removes and returns the first entry.
    #
    # #### Methods for Iterating
    #
    # *   ::each, ::each_pair: Calls the block with each name/value pair.
    # *   ::each_key: Calls the block with each name.
    # *   ::each_value: Calls the block with each value.
    #
    # #### Methods for Converting
    #
    # *   ::assoc: Returns a 2-element array containing the name and value of the
    #     named environment variable if it exists:
    # *   ::clone: Returns `ENV` (and issues a warning).
    # *   ::except: Returns a hash of all name/value pairs except those given.
    # *   ::fetch: Returns the value for the given name.
    # *   ::inspect: Returns the contents of `ENV` as a string.
    # *   ::invert: Returns a hash whose keys are the `ENV` values, and whose values
    #     are the corresponding `ENV` names.
    # *   ::keys: Returns an array of all names.
    # *   ::rassoc: Returns the name and value of the first found entry that has the
    #     given value.
    # *   ::reject: Returns a hash of those entries not rejected by the block.
    # *   ::select, ::filter: Returns a hash of name/value pairs selected by the
    #     block.
    # *   ::slice: Returns a hash of the given names and their corresponding values.
    # *   ::to_a: Returns the entries as an array of 2-element Arrays.
    # *   ::to_h: Returns a hash of entries selected by the block.
    # *   ::to_hash: Returns a hash of all entries.
    # *   ::to_s: Returns the string `'ENV'`.
    # *   ::values: Returns all values as an array.
    # *   ::values_at: Returns an array of the values for the given name.
    #
    # #### More Methods
    #
    # *   ::dup: Raises an exception.
    # *   ::freeze: Raises an exception.
    # *   ::rehash: Returns `nil`, without modifying `ENV`.
    #
    %a{annotate:rdoc:copy:ENV}
    class ENVClass
      include Enumerable[[ String, String ]]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV[name] -> value
      # -->
      # Returns the value for the environment variable `name` if it exists:
      #     ENV['foo'] = '0'
      #     ENV['foo'] # => "0"
      #
      # Returns `nil` if the named variable does not exist.
      #
      # Raises an exception if `name` is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.[]}
      def []: (String name) -> String?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.fetch(name)                  -> value
      #   - ENV.fetch(name, default)         -> value
      #   - ENV.fetch(name) { |name| block } -> value
      # -->
      # If `name` is the name of an environment variable, returns its value:
      #     ENV['foo'] = '0'
      #     ENV.fetch('foo') # => '0'
      #
      # Otherwise if a block is given (but not a default value), yields `name` to the
      # block and returns the block's return value:
      #     ENV.fetch('foo') { |name| :need_not_return_a_string } # => :need_not_return_a_string
      #
      # Otherwise if a default value is given (but not a block), returns the default
      # value:
      #     ENV.delete('foo')
      #     ENV.fetch('foo', :default_need_not_be_a_string) # => :default_need_not_be_a_string
      #
      # If the environment variable does not exist and both default and block are
      # given, issues a warning ("warning: block supersedes default value argument"),
      # yields `name` to the block, and returns the block's return value:
      #     ENV.fetch('foo', :default) { |name| :block_return } # => :block_return
      #
      # Raises KeyError if `name` is valid, but not found, and neither default value
      # nor block is given:
      #     ENV.fetch('foo') # Raises KeyError (key not found: "foo")
      #
      # Raises an exception if `name` is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.fetch}
      def fetch: (String name) -> String
               | [X] (String name, X default) -> (String | X)
               | [X] (String name) { (String) -> X } -> (String | X)

      # <!--
      #   rdoc-file=hash.c
      #   - ENV[name] = value      -> value
      #   - ENV.store(name, value) -> value
      # -->
      # Creates, updates, or deletes the named environment variable, returning the
      # value. Both `name` and `value` may be instances of String. See [Valid Names
      # and Values](rdoc-ref:ENV@Valid+Names+and+Values).
      #
      # *   If the named environment variable does not exist:
      #     *   If `value` is `nil`, does nothing.
      #             ENV.clear
      #             ENV['foo'] = nil # => nil
      #             ENV.include?('foo') # => false
      #             ENV.store('bar', nil) # => nil
      #             ENV.include?('bar') # => false
      #
      #     *   If `value` is not `nil`, creates the environment variable with `name`
      #         and `value`:
      #             # Create 'foo' using ENV.[]=.
      #             ENV['foo'] = '0' # => '0'
      #             ENV['foo'] # => '0'
      #             # Create 'bar' using ENV.store.
      #             ENV.store('bar', '1') # => '1'
      #             ENV['bar'] # => '1'
      #
      # *   If the named environment variable exists:
      #     *   If `value` is not `nil`, updates the environment variable with value
      #         `value`:
      #             # Update 'foo' using ENV.[]=.
      #             ENV['foo'] = '2' # => '2'
      #             ENV['foo'] # => '2'
      #             # Update 'bar' using ENV.store.
      #             ENV.store('bar', '3') # => '3'
      #             ENV['bar'] # => '3'
      #
      #     *   If `value` is `nil`, deletes the environment variable:
      #             # Delete 'foo' using ENV.[]=.
      #             ENV['foo'] = nil # => nil
      #             ENV.include?('foo') # => false
      #             # Delete 'bar' using ENV.store.
      #             ENV.store('bar', nil) # => nil
      #             ENV.include?('bar') # => false
      #
      # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.[]=}
      def []=: (String name, String? value) -> String?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV[name] = value      -> value
      #   - ENV.store(name, value) -> value
      # -->
      # Creates, updates, or deletes the named environment variable, returning the
      # value. Both `name` and `value` may be instances of String. See [Valid Names
      # and Values](rdoc-ref:ENV@Valid+Names+and+Values).
      #
      # *   If the named environment variable does not exist:
      #     *   If `value` is `nil`, does nothing.
      #             ENV.clear
      #             ENV['foo'] = nil # => nil
      #             ENV.include?('foo') # => false
      #             ENV.store('bar', nil) # => nil
      #             ENV.include?('bar') # => false
      #
      #     *   If `value` is not `nil`, creates the environment variable with `name`
      #         and `value`:
      #             # Create 'foo' using ENV.[]=.
      #             ENV['foo'] = '0' # => '0'
      #             ENV['foo'] # => '0'
      #             # Create 'bar' using ENV.store.
      #             ENV.store('bar', '1') # => '1'
      #             ENV['bar'] # => '1'
      #
      # *   If the named environment variable exists:
      #     *   If `value` is not `nil`, updates the environment variable with value
      #         `value`:
      #             # Update 'foo' using ENV.[]=.
      #             ENV['foo'] = '2' # => '2'
      #             ENV['foo'] # => '2'
      #             # Update 'bar' using ENV.store.
      #             ENV.store('bar', '3') # => '3'
      #             ENV['bar'] # => '3'
      #
      #     *   If `value` is `nil`, deletes the environment variable:
      #             # Delete 'foo' using ENV.[]=.
      #             ENV['foo'] = nil # => nil
      #             ENV.include?('foo') # => false
      #             # Delete 'bar' using ENV.store.
      #             ENV.store('bar', nil) # => nil
      #             ENV.include?('bar') # => false
      #
      # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.store}
      alias store []=

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.each      { |name, value| block } -> ENV
      #   - ENV.each                              -> an_enumerator
      #   - ENV.each_pair { |name, value| block } -> ENV
      #   - ENV.each_pair                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array:
      #     h = {}
      #     ENV.each_pair { |name, value| h[name] = value } # => ENV
      #     h # => {"bar"=>"1", "foo"=>"0"}
      #
      # Returns an Enumerator if no block given:
      #     h = {}
      #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
      #     e.each { |name, value| h[name] = value } # => ENV
      #     h # => {"bar"=>"1", "foo"=>"0"}
      #
      %a{annotate:rdoc:copy:ENV.each}
      def each: () -> ::Enumerator[[ String, String ], self]
              | () { ([ String, String ]) -> void } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.each      { |name, value| block } -> ENV
      #   - ENV.each                              -> an_enumerator
      #   - ENV.each_pair { |name, value| block } -> ENV
      #   - ENV.each_pair                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array:
      #     h = {}
      #     ENV.each_pair { |name, value| h[name] = value } # => ENV
      #     h # => {"bar"=>"1", "foo"=>"0"}
      #
      # Returns an Enumerator if no block given:
      #     h = {}
      #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
      #     e.each { |name, value| h[name] = value } # => ENV
      #     h # => {"bar"=>"1", "foo"=>"0"}
      #
      %a{annotate:rdoc:copy:ENV.each_pair}
      def each_pair: () -> ::Enumerator[[ String, String ], self]
                   | () { ([ String, String ]) -> void } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.each_key { |name| block } -> ENV
      #   - ENV.each_key                  -> an_enumerator
      # -->
      # Yields each environment variable name:
      #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
      #     names = []
      #     ENV.each_key { |name| names.push(name) } # => ENV
      #     names # => ["bar", "foo"]
      #
      # Returns an Enumerator if no block given:
      #     e = ENV.each_key # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_key>
      #     names = []
      #     e.each { |name| names.push(name) } # => ENV
      #     names # => ["bar", "foo"]
      #
      %a{annotate:rdoc:copy:ENV.each_key}
      def each_key: () -> ::Enumerator[[ String ], self]
                  | () { (String name) -> void } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.each_value { |value| block } -> ENV
      #   - ENV.each_value                   -> an_enumerator
      # -->
      # Yields each environment variable value:
      #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
      #     values = []
      #     ENV.each_value { |value| values.push(value) } # => ENV
      #     values # => ["1", "0"]
      #
      # Returns an Enumerator if no block given:
      #     e = ENV.each_value # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_value>
      #     values = []
      #     e.each { |value| values.push(value) } # => ENV
      #     values # => ["1", "0"]
      #
      %a{annotate:rdoc:copy:ENV.each_value}
      def each_value: () -> ::Enumerator[[ String ], self]
                    | () { (String value) -> void } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.delete(name)                           -> value
      #   - ENV.delete(name) { |name| block }          -> value
      #   - ENV.delete(missing_name)                   -> nil
      #   - ENV.delete(missing_name) { |name| block }  -> block_value
      # -->
      # Deletes the environment variable with `name` if it exists and returns its
      # value:
      #     ENV['foo'] = '0'
      #     ENV.delete('foo') # => '0'
      #
      # If a block is not given and the named environment variable does not exist,
      # returns `nil`.
      #
      # If a block given and the environment variable does not exist, yields `name` to
      # the block and returns the value of the block:
      #     ENV.delete('foo') { |name| name * 2 } # => "foofoo"
      #
      # If a block given and the environment variable exists, deletes the environment
      # variable and returns its value (ignoring the block):
      #     ENV['foo'] = '0'
      #     ENV.delete('foo') { |name| raise 'ignored' } # => "0"
      #
      # Raises an exception if `name` is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.delete}
      def delete: (String name) -> String?
                | (String name) { (String) -> String } -> String

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.delete_if { |name, value| block } -> ENV
      #   - ENV.delete_if                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # deleting each environment variable for which the block returns a truthy value,
      # and returning ENV (regardless of whether any deletions):
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"foo"=>"0"}
      #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
      #
      # Returns an Enumerator if no block given:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.delete_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:delete_if!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"foo"=>"0"}
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #
      %a{annotate:rdoc:copy:ENV.delete_if}
      def delete_if: () -> ::Enumerator[[ String, String ], self]
                   | () { (String name, String value) -> boolish } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.keep_if { |name, value| block } -> ENV
      #   - ENV.keep_if                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # deleting each environment variable for which the block returns `false` or
      # `nil`, and returning ENV:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.keep_if { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #
      # Returns an Enumerator if no block given:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.keep_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:keep_if>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #
      %a{annotate:rdoc:copy:ENV.keep_if}
      def keep_if: () -> ::Enumerator[[ String, String ], self]
                 | () { (String name, String value) -> boolish } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.slice(*names) -> hash of name/value pairs
      # -->
      # Returns a Hash of the given ENV names and their corresponding values:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2', 'bat' => '3')
      #     ENV.slice('foo', 'baz') # => {"foo"=>"0", "baz"=>"2"}
      #     ENV.slice('baz', 'foo') # => {"baz"=>"2", "foo"=>"0"}
      #
      # Raises an exception if any of the `names` is invalid (see [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values)):
      #     ENV.slice('foo', 'bar', :bat) # Raises TypeError (no implicit conversion of Symbol into String)
      #
      %a{annotate:rdoc:copy:ENV.slice}
      def slice: (*String names) -> ::Hash[String, String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.except(*keys) -> a_hash
      # -->
      # Returns a hash except the given keys from ENV and their values.
      #
      #     ENV                       #=> {"LANG"=>"en_US.UTF-8", "TERM"=>"xterm-256color", "HOME"=>"/Users/rhc"}
      #     ENV.except("TERM","HOME") #=> {"LANG"=>"en_US.UTF-8"}
      #
      %a{annotate:rdoc:copy:ENV.except}
      def except: (*String names) -> ::Hash[String, String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.clear -> ENV
      # -->
      # Removes every environment variable; returns ENV:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.size # => 2
      #     ENV.clear # => ENV
      #     ENV.size # => 0
      #
      %a{annotate:rdoc:copy:ENV.clear}
      def clear: () -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.reject { |name, value| block } -> hash of name/value pairs
      #   - ENV.reject                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array.
      # Returns a Hash whose items are determined by the block. When the block returns
      # a truthy value, the name/value pair is added to the return Hash; otherwise the
      # pair is ignored:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.reject { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
      #
      # Returns an Enumerator if no block given:
      #     e = ENV.reject
      #     e.each { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
      #
      %a{annotate:rdoc:copy:ENV.reject}
      def reject: () -> ::Enumerator[[ String, String ], self]
                | () { (String name, String value) -> boolish } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.reject! { |name, value| block } -> ENV or nil
      #   - ENV.reject!                         -> an_enumerator
      # -->
      # Similar to ENV.delete_if, but returns `nil` if no changes were made.
      #
      # Yields each environment variable name and its value as a 2-element Array,
      # deleting each environment variable for which the block returns a truthy value,
      # and returning ENV (if any deletions) or `nil` (if not):
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.reject! { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"foo"=>"0"}
      #     ENV.reject! { |name, value| name.start_with?('b') } # => nil
      #
      # Returns an Enumerator if no block given:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.reject! # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:reject!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"foo"=>"0"}
      #     e.each { |name, value| name.start_with?('b') } # => nil
      #
      %a{annotate:rdoc:copy:ENV.reject!}
      def reject!: () -> ::Enumerator[[ String, String ], self?]
                 | () { (String name, String value) -> boolish } -> self?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.select { |name, value| block } -> hash of name/value pairs
      #   - ENV.select                         -> an_enumerator
      #   - ENV.filter { |name, value| block } -> hash of name/value pairs
      #   - ENV.filter                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # returning a Hash of the names and values for which the block returns a truthy
      # value:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #
      # Returns an Enumerator if no block given:
      #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
      #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
      #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #
      %a{annotate:rdoc:copy:ENV.select}
      def select: () -> ::Enumerator[[ String, String ], ::Hash[String, String]]
                | () { (String name, String value) -> boolish } -> ::Hash[String, String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.select { |name, value| block } -> hash of name/value pairs
      #   - ENV.select                         -> an_enumerator
      #   - ENV.filter { |name, value| block } -> hash of name/value pairs
      #   - ENV.filter                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # returning a Hash of the names and values for which the block returns a truthy
      # value:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #
      # Returns an Enumerator if no block given:
      #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
      #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
      #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
      #
      %a{annotate:rdoc:copy:ENV.filter}
      alias filter select

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.select! { |name, value| block } -> ENV or nil
      #   - ENV.select!                         -> an_enumerator
      #   - ENV.filter! { |name, value| block } -> ENV or nil
      #   - ENV.filter!                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # deleting each entry for which the block returns `false` or `nil`, and
      # returning ENV if any deletions made, or `nil` otherwise:
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.select! { |name, value| true } # => nil
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.filter! { |name, value| true } # => nil
      #
      # Returns an Enumerator if no block given:
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     e.each { |name, value| true } # => nil
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     e.each { |name, value| true } # => nil
      #
      %a{annotate:rdoc:copy:ENV.select!}
      def select!: () -> ::Enumerator[[ String, String ], self?]
                 | () { (String name, String value) -> boolish } -> self?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.select! { |name, value| block } -> ENV or nil
      #   - ENV.select!                         -> an_enumerator
      #   - ENV.filter! { |name, value| block } -> ENV or nil
      #   - ENV.filter!                         -> an_enumerator
      # -->
      # Yields each environment variable name and its value as a 2-element Array,
      # deleting each entry for which the block returns `false` or `nil`, and
      # returning ENV if any deletions made, or `nil` otherwise:
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.select! { |name, value| true } # => nil
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     ENV.filter! { |name, value| true } # => nil
      #
      # Returns an Enumerator if no block given:
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     e.each { |name, value| true } # => nil
      #
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
      #     e.each { |name, value| name.start_with?('b') } # => ENV
      #     ENV # => {"bar"=>"1", "baz"=>"2"}
      #     e.each { |name, value| true } # => nil
      #
      %a{annotate:rdoc:copy:ENV.filter!}
      alias filter! select!

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.shift -> [name, value] or nil
      # -->
      # Removes the first environment variable from ENV and returns a 2-element Array
      # containing its name and value:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.to_hash # => {'bar' => '1', 'foo' => '0'}
      #     ENV.shift # => ['bar', '1']
      #     ENV.to_hash # => {'foo' => '0'}
      #
      # Exactly which environment variable is "first" is OS-dependent. See [About
      # Ordering](rdoc-ref:ENV@About+Ordering).
      #
      # Returns `nil` if the environment is empty.
      #
      %a{annotate:rdoc:copy:ENV.shift}
      def shift: () -> [ String, String ]?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.invert -> hash of value/name pairs
      # -->
      # Returns a Hash whose keys are the ENV values, and whose values are the
      # corresponding ENV names:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.invert # => {"1"=>"bar", "0"=>"foo"}
      #
      # For a duplicate ENV value, overwrites the hash entry:
      #     ENV.replace('foo' => '0', 'bar' => '0')
      #     ENV.invert # => {"0"=>"foo"}
      #
      # Note that the order of the ENV processing is OS-dependent, which means that
      # the order of overwriting is also OS-dependent. See [About
      # Ordering](rdoc-ref:ENV@About+Ordering).
      #
      %a{annotate:rdoc:copy:ENV.invert}
      def invert: () -> ::Hash[String, String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.replace(hash) -> ENV
      # -->
      # Replaces the entire content of the environment variables with the name/value
      # pairs in the given `hash`; returns ENV.
      #
      # Replaces the content of ENV with the given pairs:
      #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
      #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
      #
      # Raises an exception if a name or value is invalid (see [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values)):
      #     ENV.replace('foo' => '0', :bar => '1') # Raises TypeError (no implicit conversion of Symbol into String)
      #     ENV.replace('foo' => '0', 'bar' => 1) # Raises TypeError (no implicit conversion of Integer into String)
      #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
      #
      %a{annotate:rdoc:copy:ENV.replace}
      def replace: (Hash[String, String]) -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.update                                              -> ENV
      #   - ENV.update(*hashes)                                     -> ENV
      #   - ENV.update(*hashes) { |name, env_val, hash_val| block } -> ENV
      #   - ENV.merge!                                              -> ENV
      #   - ENV.merge!(*hashes)                                     -> ENV
      #   - ENV.merge!(*hashes) { |name, env_val, hash_val| block } -> ENV
      # -->
      # Adds to ENV each key/value pair in the given `hash`; returns ENV:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
      #
      # Deletes the ENV entry for a hash value that is `nil`:
      #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
      #
      # For an already-existing name, if no block given, overwrites the ENV value:
      #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
      #
      # For an already-existing name, if block given, yields the name, its ENV value,
      # and its hash value; the block's return value becomes the new name:
      #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
      #
      # Raises an exception if a name or value is invalid (see [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values));
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
      #     ENV # => {"bar"=>"1", "foo"=>"6"}
      #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
      #     ENV # => {"bar"=>"1", "foo"=>"7"}
      #
      # Raises an exception if the block returns an invalid name: (see [Invalid Names
      # and Values](rdoc-ref:ENV@Invalid+Names+and+Values)):
      #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
      #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
      #
      # Note that for the exceptions above, hash pairs preceding an invalid name or
      # value are processed normally; those following are ignored.
      #
      %a{annotate:rdoc:copy:ENV.update}
      def update: (Hash[String, String?]) -> self
                | (Hash[String, String?]) { (String name, String env_val, String? hash_val) -> String } -> self

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.update                                              -> ENV
      #   - ENV.update(*hashes)                                     -> ENV
      #   - ENV.update(*hashes) { |name, env_val, hash_val| block } -> ENV
      #   - ENV.merge!                                              -> ENV
      #   - ENV.merge!(*hashes)                                     -> ENV
      #   - ENV.merge!(*hashes) { |name, env_val, hash_val| block } -> ENV
      # -->
      # Adds to ENV each key/value pair in the given `hash`; returns ENV:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
      #
      # Deletes the ENV entry for a hash value that is `nil`:
      #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
      #
      # For an already-existing name, if no block given, overwrites the ENV value:
      #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
      #
      # For an already-existing name, if block given, yields the name, its ENV value,
      # and its hash value; the block's return value becomes the new name:
      #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
      #
      # Raises an exception if a name or value is invalid (see [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values));
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
      #     ENV # => {"bar"=>"1", "foo"=>"6"}
      #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
      #     ENV # => {"bar"=>"1", "foo"=>"7"}
      #
      # Raises an exception if the block returns an invalid name: (see [Invalid Names
      # and Values](rdoc-ref:ENV@Invalid+Names+and+Values)):
      #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
      #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
      #
      # Note that for the exceptions above, hash pairs preceding an invalid name or
      # value are processed normally; those following are ignored.
      #
      %a{annotate:rdoc:copy:ENV.merge!}
      alias merge! update

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.rehash -> nil
      # -->
      # (Provided for compatibility with Hash.)
      #
      # Does not modify ENV; returns `nil`.
      #
      %a{annotate:rdoc:copy:ENV.rehash}
      def rehash: () -> nil

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.to_a -> array of 2-element arrays
      # -->
      # Returns the contents of ENV as an Array of 2-element Arrays, each of which is
      # a name/value pair:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.to_a # => [["bar", "1"], ["foo", "0"]]
      #
      %a{annotate:rdoc:copy:ENV.to_a}
      def to_a: () -> ::Array[[ String, String ]]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.to_s -> "ENV"
      # -->
      # Returns String 'ENV':
      #     ENV.to_s # => "ENV"
      #
      %a{annotate:rdoc:copy:ENV.to_s}
      def to_s: () -> "ENV"

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.key(value) -> name or nil
      # -->
      # Returns the name of the first environment variable with `value`, if it exists:
      #     ENV.replace('foo' => '0', 'bar' => '0')
      #     ENV.key('0') # => "foo"
      #
      # The order in which environment variables are examined is OS-dependent. See
      # [About Ordering](rdoc-ref:ENV@About+Ordering).
      #
      # Returns `nil` if there is no such value.
      #
      # Raises an exception if `value` is invalid:
      #     ENV.key(Object.new) # raises TypeError (no implicit conversion of Object into String)
      #
      # See [Invalid Names and Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.key}
      def key: (String value) -> String?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.length -> an_integer
      #   - ENV.size   -> an_integer
      # -->
      # Returns the count of environment variables:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.length # => 2
      #     ENV.size # => 2
      #
      %a{annotate:rdoc:copy:ENV.size}
      def size: () -> Integer

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.length -> an_integer
      #   - ENV.size   -> an_integer
      # -->
      # Returns the count of environment variables:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.length # => 2
      #     ENV.size # => 2
      #
      %a{annotate:rdoc:copy:ENV.length}
      alias length size

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.empty? -> true or false
      # -->
      # Returns `true` when there are no environment variables, `false` otherwise:
      #     ENV.clear
      #     ENV.empty? # => true
      #     ENV['foo'] = '0'
      #     ENV.empty? # => false
      #
      %a{annotate:rdoc:copy:ENV.empty?}
      def empty?: () -> bool

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.keys -> array of names
      # -->
      # Returns all variable names in an Array:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.keys # => ['bar', 'foo']
      #
      # The order of the names is OS-dependent. See [About
      # Ordering](rdoc-ref:ENV@About+Ordering).
      #
      # Returns the empty Array if ENV is empty.
      #
      %a{annotate:rdoc:copy:ENV.keys}
      def keys: () -> ::Array[String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.values -> array of values
      # -->
      # Returns all environment variable values in an Array:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.values # => ['1', '0']
      #
      # The order of the values is OS-dependent. See [About
      # Ordering](rdoc-ref:ENV@About+Ordering).
      #
      # Returns the empty Array if ENV is empty.
      #
      %a{annotate:rdoc:copy:ENV.values}
      def values: () -> ::Array[String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.values_at(*names) -> array of values
      # -->
      # Returns an Array containing the environment variable values associated with
      # the given names:
      #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
      #     ENV.values_at('foo', 'baz') # => ["0", "2"]
      #
      # Returns `nil` in the Array for each name that is not an ENV name:
      #     ENV.values_at('foo', 'bat', 'bar', 'bam') # => ["0", nil, "1", nil]
      #
      # Returns an empty Array if no names given.
      #
      # Raises an exception if any name is invalid. See [Invalid Names and
      # Values](rdoc-ref:ENV@Invalid+Names+and+Values).
      #
      %a{annotate:rdoc:copy:ENV.values_at}
      def values_at: (*String names) -> ::Array[String?]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.include?(name) -> true or false
      #   - ENV.has_key?(name) -> true or false
      #   - ENV.member?(name)  -> true or false
      #   - ENV.key?(name)     -> true or false
      # -->
      # Returns `true` if there is an environment variable with the given `name`:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.include?('foo') # => true
      #
      # Returns `false` if `name` is a valid String and there is no such environment
      # variable:
      #     ENV.include?('baz') # => false
      #
      # Returns `false` if `name` is the empty String or is a String containing
      # character `'='`:
      #     ENV.include?('') # => false
      #     ENV.include?('=') # => false
      #
      # Raises an exception if `name` is a String containing the NUL character `"\0"`:
      #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
      #
      # Raises an exception if `name` has an encoding that is not ASCII-compatible:
      #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
      #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
      #
      # Raises an exception if `name` is not a String:
      #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
      #
      %a{annotate:rdoc:copy:ENV.include?}
      def include?: (String name) -> bool

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.include?(name) -> true or false
      #   - ENV.has_key?(name) -> true or false
      #   - ENV.member?(name)  -> true or false
      #   - ENV.key?(name)     -> true or false
      # -->
      # Returns `true` if there is an environment variable with the given `name`:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.include?('foo') # => true
      #
      # Returns `false` if `name` is a valid String and there is no such environment
      # variable:
      #     ENV.include?('baz') # => false
      #
      # Returns `false` if `name` is the empty String or is a String containing
      # character `'='`:
      #     ENV.include?('') # => false
      #     ENV.include?('=') # => false
      #
      # Raises an exception if `name` is a String containing the NUL character `"\0"`:
      #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
      #
      # Raises an exception if `name` has an encoding that is not ASCII-compatible:
      #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
      #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
      #
      # Raises an exception if `name` is not a String:
      #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
      #
      %a{annotate:rdoc:copy:ENV.member?}
      alias member? include?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.include?(name) -> true or false
      #   - ENV.has_key?(name) -> true or false
      #   - ENV.member?(name)  -> true or false
      #   - ENV.key?(name)     -> true or false
      # -->
      # Returns `true` if there is an environment variable with the given `name`:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.include?('foo') # => true
      #
      # Returns `false` if `name` is a valid String and there is no such environment
      # variable:
      #     ENV.include?('baz') # => false
      #
      # Returns `false` if `name` is the empty String or is a String containing
      # character `'='`:
      #     ENV.include?('') # => false
      #     ENV.include?('=') # => false
      #
      # Raises an exception if `name` is a String containing the NUL character `"\0"`:
      #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
      #
      # Raises an exception if `name` has an encoding that is not ASCII-compatible:
      #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
      #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
      #
      # Raises an exception if `name` is not a String:
      #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
      #
      %a{annotate:rdoc:copy:ENV.has_key?}
      alias has_key? include?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.value?(value)     -> true or false
      #   - ENV.has_value?(value) -> true or false
      # -->
      # Returns `true` if `value` is the value for some environment variable name,
      # `false` otherwise:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.value?('0') # => true
      #     ENV.has_value?('0') # => true
      #     ENV.value?('2') # => false
      #     ENV.has_value?('2') # => false
      #
      %a{annotate:rdoc:copy:ENV.has_value?}
      def has_value?: (String value) -> bool

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.value?(value)     -> true or false
      #   - ENV.has_value?(value) -> true or false
      # -->
      # Returns `true` if `value` is the value for some environment variable name,
      # `false` otherwise:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.value?('0') # => true
      #     ENV.has_value?('0') # => true
      #     ENV.value?('2') # => false
      #     ENV.has_value?('2') # => false
      #
      %a{annotate:rdoc:copy:ENV.value?}
      alias value? has_value?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.include?(name) -> true or false
      #   - ENV.has_key?(name) -> true or false
      #   - ENV.member?(name)  -> true or false
      #   - ENV.key?(name)     -> true or false
      # -->
      # Returns `true` if there is an environment variable with the given `name`:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.include?('foo') # => true
      #
      # Returns `false` if `name` is a valid String and there is no such environment
      # variable:
      #     ENV.include?('baz') # => false
      #
      # Returns `false` if `name` is the empty String or is a String containing
      # character `'='`:
      #     ENV.include?('') # => false
      #     ENV.include?('=') # => false
      #
      # Raises an exception if `name` is a String containing the NUL character `"\0"`:
      #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
      #
      # Raises an exception if `name` has an encoding that is not ASCII-compatible:
      #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
      #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
      #
      # Raises an exception if `name` is not a String:
      #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
      #
      %a{annotate:rdoc:copy:ENV.key?}
      alias key? include?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.to_hash -> hash of name/value pairs
      # -->
      # Returns a Hash containing all name/value pairs from ENV:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
      #
      %a{annotate:rdoc:copy:ENV.to_hash}
      def to_hash: () -> ::Hash[String, String]

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.assoc(name) -> [name, value] or nil
      # -->
      # Returns a 2-element Array containing the name and value of the environment
      # variable for `name` if it exists:
      #     ENV.replace('foo' => '0', 'bar' => '1')
      #     ENV.assoc('foo') # => ['foo', '0']
      #
      # Returns `nil` if `name` is a valid String and there is no such environment
      # variable.
      #
      # Returns `nil` if `name` is the empty String or is a String containing
      # character `'='`.
      #
      # Raises an exception if `name` is a String containing the NUL character `"\0"`:
      #     ENV.assoc("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
      #
      # Raises an exception if `name` has an encoding that is not ASCII-compatible:
      #     ENV.assoc("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
      #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
      #
      # Raises an exception if `name` is not a String:
      #     ENV.assoc(Object.new) # TypeError (no implicit conversion of Object into String)
      #
      %a{annotate:rdoc:copy:ENV.assoc}
      def assoc: (String name) -> [ String, String ]?

      # <!--
      #   rdoc-file=hash.c
      #   - ENV.rassoc(value) -> [name, value] or nil
      # -->
      # Returns a 2-element Array containing the name and value of the **first**
      # **found** environment variable that has value `value`, if one exists:
      #     ENV.replace('foo' => '0', 'bar' => '0')
      #     ENV.rassoc('0') # => ["bar", "0"]
      #
      # The order in which environment variables are examined is OS-dependent. See
      # [About Ordering](rdoc-ref:ENV@About+Ordering).
      #
      # Returns `nil` if there is no such environment variable.
      #
      %a{annotate:rdoc:copy:ENV.rassoc}
      def rassoc: (String value) -> [ String, String ]?
    end
  end
end
module RBS
  module Unnamed
    # <!-- rdoc-file=io.c -->
    # ## ARGF and `ARGV`
    #
    # The ARGF object works with the array at global variable `ARGV` to make
    # `$stdin` and file streams available in the Ruby program:
    #
    # *   **ARGV** may be thought of as the **argument vector** array.
    #
    #     Initially, it contains the command-line arguments and options that are
    #     passed to the Ruby program; the program can modify that array as it likes.
    #
    # *   **ARGF** may be thought of as the **argument files** object.
    #
    #     It can access file streams and/or the `$stdin` stream, based on what it
    #     finds in `ARGV`. This provides a convenient way for the command line to
    #     specify streams for a Ruby program to read.
    #
    # ## Reading
    #
    # ARGF may read from *source* streams, which at any particular time are
    # determined by the content of `ARGV`.
    #
    # ### Simplest Case
    #
    # When the *very first* ARGF read occurs with an empty `ARGV` (`[]`), the source
    # is `$stdin`:
    #
    # *   File `t.rb`:
    #
    #         p ['ARGV', ARGV]
    #         p ['ARGF.read', ARGF.read]
    #
    # *   Commands and outputs (see below for the content of files `foo.txt` and
    #     `bar.txt`):
    #
    #         $ echo "Open the pod bay doors, Hal." | ruby t.rb
    #         ["ARGV", []]
    #         ["ARGF.read", "Open the pod bay doors, Hal.\n"]
    #
    #         $ cat foo.txt bar.txt | ruby t.rb
    #         ["ARGV", []]
    #         ["ARGF.read", "Foo 0\nFoo 1\nBar 0\nBar 1\nBar 2\nBar 3\n"]
    #
    # ### About the Examples
    #
    # Many examples here assume the existence of files `foo.txt` and `bar.txt`:
    #
    #     $ cat foo.txt
    #     Foo 0
    #     Foo 1
    #     $ cat bar.txt
    #     Bar 0
    #     Bar 1
    #     Bar 2
    #     Bar 3
    #
    # ### Sources in `ARGV`
    #
    # For any ARGF read *except* the [simplest case](rdoc-ref:ARGF@Simplest+Case)
    # (that is, *except* for the *very first* ARGF read with an empty `ARGV`), the
    # sources are found in `ARGV`.
    #
    # ARGF assumes that each element in array `ARGV` is a potential source, and is
    # one of:
    #
    # *   The string path to a file that may be opened as a stream.
    # *   The character `'-'`, meaning stream `$stdin`.
    #
    # Each element that is *not* one of these should be removed from `ARGV` before
    # ARGF accesses that source.
    #
    # In the following example:
    #
    # *   Filepaths `foo.txt` and `bar.txt` may be retained as potential sources.
    # *   Options `--xyzzy` and `--mojo` should be removed.
    #
    # Example:
    #
    # *   File `t.rb`:
    #
    #         # Print arguments (and options, if any) found on command line.
    #         p ['ARGV', ARGV]
    #
    # *   Command and output:
    #
    #         $ ruby t.rb --xyzzy --mojo foo.txt bar.txt
    #         ["ARGV", ["--xyzzy", "--mojo", "foo.txt", "bar.txt"]]
    #
    # ARGF's stream access considers the elements of `ARGV`, left to right:
    #
    # *   File `t.rb`:
    #
    #         p "ARGV: #{ARGV}"
    #         p "Line: #{ARGF.read}" # Read everything from all specified streams.
    #
    # *   Command and output:
    #
    #         $ ruby t.rb foo.txt bar.txt
    #         "ARGV: [\"foo.txt\", \"bar.txt\"]"
    #         "Read: Foo 0\nFoo 1\nBar 0\nBar 1\nBar 2\nBar 3\n"
    #
    # Because the value at `ARGV` is an ordinary array, you can manipulate it to
    # control which sources ARGF considers:
    #
    # *   If you remove an element from `ARGV`, ARGF will not consider the
    #     corresponding source.
    # *   If you add an element to `ARGV`, ARGF will consider the corresponding
    #     source.
    #
    # Each element in `ARGV` is removed when its corresponding source is accessed;
    # when all sources have been accessed, the array is empty:
    #
    # *   File `t.rb`:
    #
    #         until ARGV.empty? && ARGF.eof?
    #           p "ARGV: #{ARGV}"
    #           p "Line: #{ARGF.readline}" # Read each line from each specified stream.
    #         end
    #
    # *   Command and output:
    #
    #         $ ruby t.rb foo.txt bar.txt
    #         "ARGV: [\"foo.txt\", \"bar.txt\"]"
    #         "Line: Foo 0\n"
    #         "ARGV: [\"bar.txt\"]"
    #         "Line: Foo 1\n"
    #         "ARGV: [\"bar.txt\"]"
    #         "Line: Bar 0\n"
    #         "ARGV: []"
    #         "Line: Bar 1\n"
    #         "ARGV: []"
    #         "Line: Bar 2\n"
    #         "ARGV: []"
    #         "Line: Bar 3\n"
    #
    # #### Filepaths in `ARGV`
    #
    # The `ARGV` array may contain filepaths the specify sources for ARGF reading.
    #
    # This program prints what it reads from files at the paths specified on the
    # command line:
    #
    # *   File `t.rb`:
    #
    #         p ['ARGV', ARGV]
    #         # Read and print all content from the specified sources.
    #         p ['ARGF.read', ARGF.read]
    #
    # *   Command and output:
    #
    #         $ ruby t.rb foo.txt bar.txt
    #         ["ARGV", [foo.txt, bar.txt]
    #         ["ARGF.read", "Foo 0\nFoo 1\nBar 0\nBar 1\nBar 2\nBar 3\n"]
    #
    # #### Specifying `$stdin` in `ARGV`
    #
    # To specify stream `$stdin` in `ARGV`, us the character `'-'`:
    #
    # *   File `t.rb`:
    #
    #         p ['ARGV', ARGV]
    #         p ['ARGF.read', ARGF.read]
    #
    # *   Command and output:
    #
    #         $ echo "Open the pod bay doors, Hal." | ruby t.rb -
    #         ["ARGV", ["-"]]
    #         ["ARGF.read", "Open the pod bay doors, Hal.\n"]
    #
    # When no character `'-'` is given, stream `$stdin` is ignored (exception: see
    # [Specifying $stdin in ARGV](rdoc-ref:ARGF@Specifying+-24stdin+in+ARGV)):
    #
    # *   Command and output:
    #
    #         $ echo "Open the pod bay doors, Hal." | ruby t.rb foo.txt bar.txt
    #         "ARGV: [\"foo.txt\", \"bar.txt\"]"
    #         "Read: Foo 0\nFoo 1\nBar 0\nBar 1\nBar 2\nBar 3\n"
    #
    # #### Mixtures and Repetitions in `ARGV`
    #
    # For an ARGF reader, `ARGV` may contain any mixture of filepaths and character
    # `'-'`, including repetitions.
    #
    # #### Modifications to `ARGV`
    #
    # The running Ruby program may make any modifications to the `ARGV` array; the
    # current value of `ARGV` affects ARGF reading.
    #
    # #### Empty `ARGV`
    #
    # For an empty `ARGV`, an ARGF read method either returns `nil` or raises an
    # exception, depending on the specific method.
    #
    # ### More Read Methods
    #
    # As seen above, method ARGF#read reads the content of all sources into a single
    # string. Other ARGF methods provide other ways to access that content; these
    # include:
    #
    # *   Byte access: #each_byte, #getbyte, #readbyte.
    # *   Character access: #each_char, #getc, #readchar.
    # *   Codepoint access: #each_codepoint.
    # *   Line access: #each_line, #gets, #readline, #readlines.
    # *   Source access: #read, #read_nonblock, #readpartial.
    #
    # ### About Enumerable
    #
    # ARGF includes module Enumerable. Virtually all methods in Enumerable call
    # method `#each` in the including class.
    #
    # **Note well**: In ARGF, method #each returns data from the *sources*, *not*
    # from `ARGV`; therefore, for example, `ARGF#entries` returns an array of lines
    # from the sources, not an array of the strings from `ARGV`:
    #
    # *   File `t.rb`:
    #
    #         p ['ARGV', ARGV]
    #         p ['ARGF.entries', ARGF.entries]
    #
    # *   Command and output:
    #
    #         $ ruby t.rb foo.txt bar.txt
    #         ["ARGV", ["foo.txt", "bar.txt"]]
    #         ["ARGF.entries", ["Foo 0\n", "Foo 1\n", "Bar 0\n", "Bar 1\n", "Bar 2\n", "Bar 3\n"]]
    #
    # ## Writing
    #
    # If *inplace mode* is in effect, ARGF may write to target streams, which at any
    # particular time are determined by the content of ARGV.
    #
    # Methods about inplace mode:
    #
    # *   #inplace_mode
    # *   #inplace_mode=
    # *   #to_write_io
    #
    # Methods for writing:
    #
    # *   #print
    # *   #printf
    # *   #putc
    # *   #puts
    # *   #write
    #
    %a{annotate:rdoc:copy:ARGF}
    class ARGFClass
      include Enumerable[String]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.argv  -> ARGV
      # -->
      # Returns the `ARGV` array, which contains the arguments passed to your script,
      # one per element.
      #
      # For example:
      #
      #     $ ruby argf.rb -v glark.txt
      #
      #     ARGF.argv   #=> ["-v", "glark.txt"]
      #
      %a{annotate:rdoc:copy:ARGF#argv}
      def argv: () -> ::Array[String]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.binmode  -> ARGF
      # -->
      # Puts ARGF into binary mode. Once a stream is in binary mode, it cannot be
      # reset to non-binary mode. This option has the following effects:
      #
      # *   Newline conversion is disabled.
      # *   Encoding conversion is disabled.
      # *   Content is treated as ASCII-8BIT.
      #
      %a{annotate:rdoc:copy:ARGF#binmode}
      def binmode: () -> self

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.binmode?  -> true or false
      # -->
      # Returns true if ARGF is being read in binary mode; false otherwise. To enable
      # binary mode use ARGF.binmode.
      #
      # For example:
      #
      #     ARGF.binmode?  #=> false
      #     ARGF.binmode
      #     ARGF.binmode?  #=> true
      #
      %a{annotate:rdoc:copy:ARGF#binmode?}
      def binmode?: () -> bool

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.close  -> ARGF
      # -->
      # Closes the current file and skips to the next file in ARGV. If there are no
      # more files to open, just closes the current file. STDIN will not be closed.
      #
      # For example:
      #
      #     $ ruby argf.rb foo bar
      #
      #     ARGF.filename  #=> "foo"
      #     ARGF.close
      #     ARGF.filename  #=> "bar"
      #     ARGF.close
      #
      %a{annotate:rdoc:copy:ARGF#close}
      def close: () -> self

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.closed?  -> true or false
      # -->
      # Returns *true* if the current file has been closed; *false* otherwise. Use
      # ARGF.close to actually close the current file.
      #
      %a{annotate:rdoc:copy:ARGF#closed?}
      def closed?: () -> bool

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.each(sep=$/)             {|line| block }  -> ARGF
      #   - ARGF.each(sep=$/, limit)      {|line| block }  -> ARGF
      #   - ARGF.each(...)                                 -> an_enumerator
      #   - ARGF.each_line(sep=$/)        {|line| block }  -> ARGF
      #   - ARGF.each_line(sep=$/, limit) {|line| block }  -> ARGF
      #   - ARGF.each_line(...)                            -> an_enumerator
      # -->
      # Returns an enumerator which iterates over each line (separated by *sep*, which
      # defaults to your platform's newline character) of each file in `ARGV`. If a
      # block is supplied, each line in turn will be yielded to the block, otherwise
      # an enumerator is returned. The optional *limit* argument is an Integer
      # specifying the maximum length of each line; longer lines will be split
      # according to this limit.
      #
      # This method allows you to treat the files supplied on the command line as a
      # single file consisting of the concatenation of each named file. After the last
      # line of the first file has been returned, the first line of the second file is
      # returned. The ARGF.filename and ARGF.lineno methods can be used to determine
      # the filename of the current line and line number of the whole input,
      # respectively.
      #
      # For example, the following code prints out each line of each named file
      # prefixed with its line number, displaying the filename once per file:
      #
      #     ARGF.each_line do |line|
      #       puts ARGF.filename if ARGF.file.lineno == 1
      #       puts "#{ARGF.file.lineno}: #{line}"
      #     end
      #
      # While the following code prints only the first file's name at first, and the
      # contents with line number counted through all named files.
      #
      #     ARGF.each_line do |line|
      #       puts ARGF.filename if ARGF.lineno == 1
      #       puts "#{ARGF.lineno}: #{line}"
      #     end
      #
      %a{annotate:rdoc:copy:ARGF#each}
      def each: (?String sep, ?Integer limit) { (String line) -> untyped } -> self
              | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.each_byte {|byte| block }  -> ARGF
      #   - ARGF.each_byte                  -> an_enumerator
      # -->
      # Iterates over each byte of each file in `ARGV`. A byte is returned as an
      # Integer in the range 0..255.
      #
      # This method allows you to treat the files supplied on the command line as a
      # single file consisting of the concatenation of each named file. After the last
      # byte of the first file has been returned, the first byte of the second file is
      # returned. The ARGF.filename method can be used to determine the filename of
      # the current byte.
      #
      # If no block is given, an enumerator is returned instead.
      #
      # For example:
      #
      #     ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]
      #
      %a{annotate:rdoc:copy:ARGF#each_byte}
      def each_byte: () { (Integer byte) -> untyped } -> self
                   | () -> ::Enumerator[Integer, self]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.each_char {|char| block }  -> ARGF
      #   - ARGF.each_char                  -> an_enumerator
      # -->
      # Iterates over each character of each file in ARGF.
      #
      # This method allows you to treat the files supplied on the command line as a
      # single file consisting of the concatenation of each named file. After the last
      # character of the first file has been returned, the first character of the
      # second file is returned. The ARGF.filename method can be used to determine the
      # name of the file in which the current character appears.
      #
      # If no block is given, an enumerator is returned instead.
      #
      %a{annotate:rdoc:copy:ARGF#each_char}
      def each_char: () { (String char) -> untyped } -> self
                   | () -> ::Enumerator[String, self]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.each_codepoint {|codepoint| block }  -> ARGF
      #   - ARGF.each_codepoint                       -> an_enumerator
      # -->
      # Iterates over each codepoint of each file in ARGF.
      #
      # This method allows you to treat the files supplied on the command line as a
      # single file consisting of the concatenation of each named file. After the last
      # codepoint of the first file has been returned, the first codepoint of the
      # second file is returned. The ARGF.filename method can be used to determine the
      # name of the file in which the current codepoint appears.
      #
      # If no block is given, an enumerator is returned instead.
      #
      %a{annotate:rdoc:copy:ARGF#each_codepoint}
      def each_codepoint: () { (Integer codepoint) -> untyped } -> self
                        | () -> ::Enumerator[Integer, self]

      # <!-- rdoc-file=io.c -->
      # Returns an enumerator which iterates over each line (separated by *sep*, which
      # defaults to your platform's newline character) of each file in `ARGV`. If a
      # block is supplied, each line in turn will be yielded to the block, otherwise
      # an enumerator is returned. The optional *limit* argument is an Integer
      # specifying the maximum length of each line; longer lines will be split
      # according to this limit.
      #
      # This method allows you to treat the files supplied on the command line as a
      # single file consisting of the concatenation of each named file. After the last
      # line of the first file has been returned, the first line of the second file is
      # returned. The ARGF.filename and ARGF.lineno methods can be used to determine
      # the filename of the current line and line number of the whole input,
      # respectively.
      #
      # For example, the following code prints out each line of each named file
      # prefixed with its line number, displaying the filename once per file:
      #
      #     ARGF.each_line do |line|
      #       puts ARGF.filename if ARGF.file.lineno == 1
      #       puts "#{ARGF.file.lineno}: #{line}"
      #     end
      #
      # While the following code prints only the first file's name at first, and the
      # contents with line number counted through all named files.
      #
      #     ARGF.each_line do |line|
      #       puts ARGF.filename if ARGF.lineno == 1
      #       puts "#{ARGF.lineno}: #{line}"
      #     end
      #
      %a{annotate:rdoc:copy:ARGF#each_line}
      def each_line: (?String sep, ?Integer limit) { (String line) -> untyped } -> self
                   | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.eof?  -> true or false
      #   - ARGF.eof   -> true or false
      # -->
      # Returns true if the current file in ARGF is at end of file, i.e. it has no
      # data to read. The stream must be opened for reading or an IOError will be
      # raised.
      #
      #     $ echo "eof" | ruby argf.rb
      #
      #     ARGF.eof?                 #=> false
      #     3.times { ARGF.readchar }
      #     ARGF.eof?                 #=> false
      #     ARGF.readchar             #=> "\n"
      #     ARGF.eof?                 #=> true
      #
      %a{annotate:rdoc:copy:ARGF#eof}
      def eof: () -> bool

      # <!-- rdoc-file=io.c -->
      # Returns true if the current file in ARGF is at end of file, i.e. it has no
      # data to read. The stream must be opened for reading or an IOError will be
      # raised.
      #
      #     $ echo "eof" | ruby argf.rb
      #
      #     ARGF.eof?                 #=> false
      #     3.times { ARGF.readchar }
      #     ARGF.eof?                 #=> false
      #     ARGF.readchar             #=> "\n"
      #     ARGF.eof?                 #=> true
      #
      %a{annotate:rdoc:copy:ARGF#eof?}
      def eof?: () -> bool

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.external_encoding   -> encoding
      # -->
      # Returns the external encoding for files read from ARGF as an Encoding object.
      # The external encoding is the encoding of the text as stored in a file.
      # Contrast with ARGF.internal_encoding, which is the encoding used to represent
      # this text within Ruby.
      #
      # To set the external encoding use ARGF.set_encoding.
      #
      # For example:
      #
      #     ARGF.external_encoding  #=>  #<Encoding:UTF-8>
      #
      %a{annotate:rdoc:copy:ARGF#external_encoding}
      def external_encoding: () -> Encoding

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.file  -> IO or File object
      # -->
      # Returns the current file as an IO or File object. `$stdin` is returned when
      # the current file is STDIN.
      #
      # For example:
      #
      #     $ echo "foo" > foo
      #     $ echo "bar" > bar
      #
      #     $ ruby argf.rb foo bar
      #
      #     ARGF.file      #=> #<File:foo>
      #     ARGF.read(5)   #=> "foo\nb"
      #     ARGF.file      #=> #<File:bar>
      #
      %a{annotate:rdoc:copy:ARGF#file}
      def file: () -> (IO | File)

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.filename  -> String
      #   - ARGF.path      -> String
      # -->
      # Returns the current filename. "-" is returned when the current file is STDIN.
      #
      # For example:
      #
      #     $ echo "foo" > foo
      #     $ echo "bar" > bar
      #     $ echo "glark" > glark
      #
      #     $ ruby argf.rb foo bar glark
      #
      #     ARGF.filename  #=> "foo"
      #     ARGF.read(5)   #=> "foo\nb"
      #     ARGF.filename  #=> "bar"
      #     ARGF.skip
      #     ARGF.filename  #=> "glark"
      #
      %a{annotate:rdoc:copy:ARGF#filename}
      def filename: () -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.fileno    -> integer
      #   - ARGF.to_i      -> integer
      # -->
      # Returns an integer representing the numeric file descriptor for the current
      # file. Raises an ArgumentError if there isn't a current file.
      #
      #     ARGF.fileno    #=> 3
      #
      %a{annotate:rdoc:copy:ARGF#fileno}
      def fileno: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.getbyte  -> Integer or nil
      # -->
      # Gets the next 8-bit byte (0..255) from ARGF. Returns `nil` if called at the
      # end of the stream.
      #
      # For example:
      #
      #     $ echo "foo" > file
      #     $ ruby argf.rb file
      #
      #     ARGF.getbyte #=> 102
      #     ARGF.getbyte #=> 111
      #     ARGF.getbyte #=> 111
      #     ARGF.getbyte #=> 10
      #     ARGF.getbyte #=> nil
      #
      %a{annotate:rdoc:copy:ARGF#getbyte}
      def getbyte: () -> Integer?

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.getc  -> String or nil
      # -->
      # Reads the next character from ARGF and returns it as a String. Returns `nil`
      # at the end of the stream.
      #
      # ARGF treats the files named on the command line as a single file created by
      # concatenating their contents. After returning the last character of the first
      # file, it returns the first character of the second file, and so on.
      #
      # For example:
      #
      #     $ echo "foo" > file
      #     $ ruby argf.rb file
      #
      #     ARGF.getc  #=> "f"
      #     ARGF.getc  #=> "o"
      #     ARGF.getc  #=> "o"
      #     ARGF.getc  #=> "\n"
      #     ARGF.getc  #=> nil
      #     ARGF.getc  #=> nil
      #
      %a{annotate:rdoc:copy:ARGF#getc}
      def getc: () -> String?

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.gets(sep=$/ [, getline_args])     -> string or nil
      #   - ARGF.gets(limit [, getline_args])      -> string or nil
      #   - ARGF.gets(sep, limit [, getline_args]) -> string or nil
      # -->
      # Returns the next line from the current file in ARGF.
      #
      # By default lines are assumed to be separated by `$/`; to use a different
      # character as a separator, supply it as a String for the *sep* argument.
      #
      # The optional *limit* argument specifies how many characters of each line to
      # return. By default all characters are returned.
      #
      # See IO.readlines for details about getline_args.
      #
      %a{annotate:rdoc:copy:ARGF#gets}
      def gets: (?String sep, ?Integer limit) -> String?

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.inplace_mode  -> String
      # -->
      # Returns the file extension appended to the names of backup copies of modified
      # files under in-place edit mode. This value can be set using ARGF.inplace_mode=
      # or passing the `-i` switch to the Ruby binary.
      #
      %a{annotate:rdoc:copy:ARGF#inplace_mode}
      def inplace_mode: () -> String?

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.inplace_mode = ext  -> ARGF
      # -->
      # Sets the filename extension for in-place editing mode to the given String. The
      # backup copy of each file being edited has this value appended to its filename.
      #
      # For example:
      #
      #     $ ruby argf.rb file.txt
      #
      #     ARGF.inplace_mode = '.bak'
      #     ARGF.each_line do |line|
      #       print line.sub("foo","bar")
      #     end
      #
      # First, *file.txt.bak* is created as a backup copy of *file.txt*. Then, each
      # line of *file.txt* has the first occurrence of "foo" replaced with "bar".
      #
      %a{annotate:rdoc:copy:ARGF#inplace_mode=}
      def inplace_mode=: (String) -> self

      alias inspect to_s

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.internal_encoding   -> encoding
      # -->
      # Returns the internal encoding for strings read from ARGF as an Encoding
      # object.
      #
      # If ARGF.set_encoding has been called with two encoding names, the second is
      # returned. Otherwise, if `Encoding.default_external` has been set, that value
      # is returned. Failing that, if a default external encoding was specified on the
      # command-line, that value is used. If the encoding is unknown, `nil` is
      # returned.
      #
      %a{annotate:rdoc:copy:ARGF#internal_encoding}
      def internal_encoding: () -> Encoding

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.lineno  -> integer
      # -->
      # Returns the current line number of ARGF as a whole. This value can be set
      # manually with ARGF.lineno=.
      #
      # For example:
      #
      #     ARGF.lineno   #=> 0
      #     ARGF.readline #=> "This is line 1\n"
      #     ARGF.lineno   #=> 1
      #
      %a{annotate:rdoc:copy:ARGF#lineno}
      def lineno: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.lineno = integer  -> integer
      # -->
      # Sets the line number of ARGF as a whole to the given Integer.
      #
      # ARGF sets the line number automatically as you read data, so normally you will
      # not need to set it explicitly. To access the current line number use
      # ARGF.lineno.
      #
      # For example:
      #
      #     ARGF.lineno      #=> 0
      #     ARGF.readline    #=> "This is line 1\n"
      #     ARGF.lineno      #=> 1
      #     ARGF.lineno = 0  #=> 0
      #     ARGF.lineno      #=> 0
      #
      %a{annotate:rdoc:copy:ARGF#lineno=}
      def lineno=: (Integer) -> untyped

      # <!-- rdoc-file=io.c -->
      # Returns the current filename. "-" is returned when the current file is STDIN.
      #
      # For example:
      #
      #     $ echo "foo" > foo
      #     $ echo "bar" > bar
      #     $ echo "glark" > glark
      #
      #     $ ruby argf.rb foo bar glark
      #
      #     ARGF.filename  #=> "foo"
      #     ARGF.read(5)   #=> "foo\nb"
      #     ARGF.filename  #=> "bar"
      #     ARGF.skip
      #     ARGF.filename  #=> "glark"
      #
      %a{annotate:rdoc:copy:ARGF#path}
      def path: () -> String

      # <!-- rdoc-file=io.c -->
      # Returns the current offset (in bytes) of the current file in ARGF.
      #
      #     ARGF.pos    #=> 0
      #     ARGF.gets   #=> "This is line one\n"
      #     ARGF.pos    #=> 17
      #
      %a{annotate:rdoc:copy:ARGF#pos}
      def pos: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.pos = position  -> Integer
      # -->
      # Seeks to the position given by *position* (in bytes) in ARGF.
      #
      # For example:
      #
      #     ARGF.pos = 17
      #     ARGF.gets   #=> "This is line two\n"
      #
      %a{annotate:rdoc:copy:ARGF#pos=}
      def pos=: (Integer) -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - print(*objects) -> nil
      # -->
      # Writes the given objects to the stream; returns `nil`. Appends the output
      # record separator `$OUTPUT_RECORD_SEPARATOR` (`$\`), if it is not `nil`. See
      # [Line IO](rdoc-ref:IO@Line+IO).
      #
      # With argument `objects` given, for each object:
      #
      # *   Converts via its method `to_s` if not a string.
      # *   Writes to the stream.
      # *   If not the last object, writes the output field separator
      #     `$OUTPUT_FIELD_SEPARATOR` (`$,`) if it is not `nil`.
      #
      # With default separators:
      #
      #     f = File.open('t.tmp', 'w+')
      #     objects = [0, 0.0, Rational(0, 1), Complex(0, 0), :zero, 'zero']
      #     p $OUTPUT_RECORD_SEPARATOR
      #     p $OUTPUT_FIELD_SEPARATOR
      #     f.print(*objects)
      #     f.rewind
      #     p f.read
      #     f.close
      #
      # Output:
      #
      #     nil
      #     nil
      #     "00.00/10+0izerozero"
      #
      # With specified separators:
      #
      #     $\ = "\n"
      #     $, = ','
      #     f.rewind
      #     f.print(*objects)
      #     f.rewind
      #     p f.read
      #
      # Output:
      #
      #     "0,0.0,0/1,0+0i,zero,zero\n"
      #
      # With no argument given, writes the content of `$_` (which is usually the most
      # recent user input):
      #
      #     f = File.open('t.tmp', 'w+')
      #     gets # Sets $_ to the most recent user input.
      #     f.print
      #     f.close
      #
      %a{annotate:rdoc:copy:ARGF#print}
      def print: (*untyped args) -> nil

      # <!--
      #   rdoc-file=io.c
      #   - printf(format_string, *objects) -> nil
      # -->
      # Formats and writes `objects` to the stream.
      #
      # For details on `format_string`, see [Format
      # Specifications](rdoc-ref:format_specifications.rdoc).
      #
      %a{annotate:rdoc:copy:ARGF#printf}
      def printf: (String format_string, *untyped args) -> nil

      # <!--
      #   rdoc-file=io.c
      #   - putc(object) -> object
      # -->
      # Writes a character to the stream. See [Character
      # IO](rdoc-ref:IO@Character+IO).
      #
      # If `object` is numeric, converts to integer if necessary, then writes the
      # character whose code is the least significant byte; if `object` is a string,
      # writes the first character:
      #
      #     $stdout.putc "A"
      #     $stdout.putc 65
      #
      # Output:
      #
      #     AA
      #
      %a{annotate:rdoc:copy:ARGF#putc}
      def putc: (Numeric | String obj) -> untyped

      # <!--
      #   rdoc-file=io.c
      #   - puts(*objects) -> nil
      # -->
      # Writes the given `objects` to the stream, which must be open for writing;
      # returns `nil`.\ Writes a newline after each that does not already end with a
      # newline sequence. If called without arguments, writes a newline. See [Line
      # IO](rdoc-ref:IO@Line+IO).
      #
      # Note that each added newline is the character `"\n"<//tt>, not the output
      # record separator (<tt>$\`).
      #
      # Treatment for each object:
      #
      # *   String: writes the string.
      # *   Neither string nor array: writes `object.to_s`.
      # *   Array: writes each element of the array; arrays may be nested.
      #
      # To keep these examples brief, we define this helper method:
      #
      #     def show(*objects)
      #       # Puts objects to file.
      #       f = File.new('t.tmp', 'w+')
      #       f.puts(objects)
      #       # Return file content.
      #       f.rewind
      #       p f.read
      #       f.close
      #     end
      #
      #     # Strings without newlines.
      #     show('foo', 'bar', 'baz')     # => "foo\nbar\nbaz\n"
      #     # Strings, some with newlines.
      #     show("foo\n", 'bar', "baz\n") # => "foo\nbar\nbaz\n"
      #
      #     # Neither strings nor arrays:
      #     show(0, 0.0, Rational(0, 1), Complex(9, 0), :zero)
      #     # => "0\n0.0\n0/1\n9+0i\nzero\n"
      #
      #     # Array of strings.
      #     show(['foo', "bar\n", 'baz']) # => "foo\nbar\nbaz\n"
      #     # Nested arrays.
      #     show([[[0, 1], 2, 3], 4, 5])  # => "0\n1\n2\n3\n4\n5\n"
      #
      %a{annotate:rdoc:copy:ARGF#puts}
      def puts: (*untyped obj) -> nil

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.read([length [, outbuf]])    -> string, outbuf, or nil
      # -->
      # Reads *length* bytes from ARGF. The files named on the command line are
      # concatenated and treated as a single file by this method, so when called
      # without arguments the contents of this pseudo file are returned in their
      # entirety.
      #
      # *length* must be a non-negative integer or `nil`.
      #
      # If *length* is a positive integer, `read` tries to read *length* bytes without
      # any conversion (binary mode). It returns `nil` if an EOF is encountered before
      # anything can be read. Fewer than *length* bytes are returned if an EOF is
      # encountered during the read. In the case of an integer *length*, the resulting
      # string is always in ASCII-8BIT encoding.
      #
      # If *length* is omitted or is `nil`, it reads until EOF and the encoding
      # conversion is applied, if applicable. A string is returned even if EOF is
      # encountered before any data is read.
      #
      # If *length* is zero, it returns an empty string (`""`).
      #
      # If the optional *outbuf* argument is present, it must reference a String,
      # which will receive the data. The *outbuf* will contain only the received data
      # after the method call even if it is not empty at the beginning.
      #
      # For example:
      #
      #     $ echo "small" > small.txt
      #     $ echo "large" > large.txt
      #     $ ./glark.rb small.txt large.txt
      #
      #     ARGF.read      #=> "small\nlarge"
      #     ARGF.read(200) #=> "small\nlarge"
      #     ARGF.read(2)   #=> "sm"
      #     ARGF.read(0)   #=> ""
      #
      # Note that this method behaves like the fread() function in C. This means it
      # retries to invoke read(2) system calls to read data with the specified length.
      # If you need the behavior like a single read(2) system call, consider
      # ARGF#readpartial or ARGF#read_nonblock.
      #
      %a{annotate:rdoc:copy:ARGF#read}
      def read: (?int? length, ?string outbuf) -> String?

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.read_nonblock(maxlen[, options])              -> string
      #   - ARGF.read_nonblock(maxlen, outbuf[, options])      -> outbuf
      # -->
      # Reads at most *maxlen* bytes from the ARGF stream in non-blocking mode.
      #
      %a{annotate:rdoc:copy:ARGF#read_nonblock}
      def read_nonblock: (int maxlen, ?string buf, **untyped options) -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.readbyte  -> Integer
      # -->
      # Reads the next 8-bit byte from ARGF and returns it as an Integer. Raises an
      # EOFError after the last byte of the last file has been read.
      #
      # For example:
      #
      #     $ echo "foo" > file
      #     $ ruby argf.rb file
      #
      #     ARGF.readbyte  #=> 102
      #     ARGF.readbyte  #=> 111
      #     ARGF.readbyte  #=> 111
      #     ARGF.readbyte  #=> 10
      #     ARGF.readbyte  #=> end of file reached (EOFError)
      #
      %a{annotate:rdoc:copy:ARGF#readbyte}
      def readbyte: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.readchar  -> String or nil
      # -->
      # Reads the next character from ARGF and returns it as a String. Raises an
      # EOFError after the last character of the last file has been read.
      #
      # For example:
      #
      #     $ echo "foo" > file
      #     $ ruby argf.rb file
      #
      #     ARGF.readchar  #=> "f"
      #     ARGF.readchar  #=> "o"
      #     ARGF.readchar  #=> "o"
      #     ARGF.readchar  #=> "\n"
      #     ARGF.readchar  #=> end of file reached (EOFError)
      #
      %a{annotate:rdoc:copy:ARGF#readchar}
      def readchar: () -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.readline(sep=$/)     -> string
      #   - ARGF.readline(limit)      -> string
      #   - ARGF.readline(sep, limit) -> string
      # -->
      # Returns the next line from the current file in ARGF.
      #
      # By default lines are assumed to be separated by `$/`; to use a different
      # character as a separator, supply it as a String for the *sep* argument.
      #
      # The optional *limit* argument specifies how many characters of each line to
      # return. By default all characters are returned.
      #
      # An EOFError is raised at the end of the file.
      #
      %a{annotate:rdoc:copy:ARGF#readline}
      def readline: (?String sep, ?Integer limit) -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.readlines(sep = $/, chomp: false)   -> array
      #   - ARGF.readlines(limit, chomp: false)      -> array
      #   - ARGF.readlines(sep, limit, chomp: false) -> array
      #   - ARGF.to_a(sep = $/, chomp: false)   -> array
      #   - ARGF.to_a(limit, chomp: false)      -> array
      #   - ARGF.to_a(sep, limit, chomp: false) -> array
      # -->
      # Reads each file in ARGF in its entirety, returning an Array containing lines
      # from the files. Lines are assumed to be separated by *sep*.
      #
      #     lines = ARGF.readlines
      #     lines[0]                #=> "This is line one\n"
      #
      # See `IO.readlines` for a full description of all options.
      #
      %a{annotate:rdoc:copy:ARGF#readlines}
      def readlines: (?String sep, ?Integer limit) -> ::Array[String]

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.readpartial(maxlen)              -> string
      #   - ARGF.readpartial(maxlen, outbuf)      -> outbuf
      # -->
      # Reads at most *maxlen* bytes from the ARGF stream.
      #
      # If the optional *outbuf* argument is present, it must reference a String,
      # which will receive the data. The *outbuf* will contain only the received data
      # after the method call even if it is not empty at the beginning.
      #
      # It raises EOFError on end of ARGF stream. Since ARGF stream is a concatenation
      # of multiple files, internally EOF is occur for each file. ARGF.readpartial
      # returns empty strings for EOFs except the last one and raises EOFError for the
      # last one.
      #
      %a{annotate:rdoc:copy:ARGF#readpartial}
      def readpartial: (int maxlen, ?string outbuf) -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.rewind   -> 0
      # -->
      # Positions the current file to the beginning of input, resetting ARGF.lineno to
      # zero.
      #
      #     ARGF.readline   #=> "This is line one\n"
      #     ARGF.rewind     #=> 0
      #     ARGF.lineno     #=> 0
      #     ARGF.readline   #=> "This is line one\n"
      #
      %a{annotate:rdoc:copy:ARGF#rewind}
      def rewind: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.seek(amount, whence=IO::SEEK_SET)  -> 0
      # -->
      # Seeks to offset *amount* (an Integer) in the ARGF stream according to the
      # value of *whence*. See IO#seek for further details.
      #
      %a{annotate:rdoc:copy:ARGF#seek}
      def seek: (Integer amount, ?Integer whence) -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.set_encoding(ext_enc)                -> ARGF
      #   - ARGF.set_encoding("ext_enc:int_enc")      -> ARGF
      #   - ARGF.set_encoding(ext_enc, int_enc)       -> ARGF
      #   - ARGF.set_encoding("ext_enc:int_enc", opt) -> ARGF
      #   - ARGF.set_encoding(ext_enc, int_enc, opt)  -> ARGF
      # -->
      # If single argument is specified, strings read from ARGF are tagged with the
      # encoding specified.
      #
      # If two encoding names separated by a colon are given, e.g. "ascii:utf-8", the
      # read string is converted from the first encoding (external encoding) to the
      # second encoding (internal encoding), then tagged with the second encoding.
      #
      # If two arguments are specified, they must be encoding objects or encoding
      # names. Again, the first specifies the external encoding; the second specifies
      # the internal encoding.
      #
      # If the external encoding and the internal encoding are specified, the optional
      # Hash argument can be used to adjust the conversion process. The structure of
      # this hash is explained in the String#encode documentation.
      #
      # For example:
      #
      #     ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text
      #     ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text
      #     ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII
      #                                        # to UTF-8.
      #
      %a{annotate:rdoc:copy:ARGF#set_encoding}
      def set_encoding: (String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.skip  -> ARGF
      # -->
      # Sets the current file to the next file in ARGV. If there aren't any more files
      # it has no effect.
      #
      # For example:
      #
      #     $ ruby argf.rb foo bar
      #     ARGF.filename  #=> "foo"
      #     ARGF.skip
      #     ARGF.filename  #=> "bar"
      #
      %a{annotate:rdoc:copy:ARGF#skip}
      def skip: () -> self

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.tell  -> Integer
      #   - ARGF.pos   -> Integer
      # -->
      # Returns the current offset (in bytes) of the current file in ARGF.
      #
      #     ARGF.pos    #=> 0
      #     ARGF.gets   #=> "This is line one\n"
      #     ARGF.pos    #=> 17
      #
      %a{annotate:rdoc:copy:ARGF#tell}
      def tell: () -> Integer

      # <!-- rdoc-file=io.c -->
      # Reads each file in ARGF in its entirety, returning an Array containing lines
      # from the files. Lines are assumed to be separated by *sep*.
      #
      #     lines = ARGF.readlines
      #     lines[0]                #=> "This is line one\n"
      #
      # See `IO.readlines` for a full description of all options.
      #
      %a{annotate:rdoc:copy:ARGF#to_a}
      def to_a: (?String sep, ?Integer limit) -> ::Array[String]

      # <!-- rdoc-file=io.c -->
      # Returns an integer representing the numeric file descriptor for the current
      # file. Raises an ArgumentError if there isn't a current file.
      #
      #     ARGF.fileno    #=> 3
      #
      %a{annotate:rdoc:copy:ARGF#to_i}
      def to_i: () -> Integer

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.to_io     -> IO
      # -->
      # Returns an IO object representing the current file. This will be a File object
      # unless the current file is a stream such as STDIN.
      #
      # For example:
      #
      #     ARGF.to_io    #=> #<File:glark.txt>
      #     ARGF.to_io    #=> #<IO:<STDIN>>
      #
      %a{annotate:rdoc:copy:ARGF#to_io}
      def to_io: () -> IO

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.to_s  -> String
      # -->
      # Returns "ARGF".
      #
      %a{annotate:rdoc:copy:ARGF#to_s}
      def to_s: () -> String

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.to_write_io  -> io
      # -->
      # Returns IO instance tied to *ARGF* for writing if inplace mode is enabled.
      #
      %a{annotate:rdoc:copy:ARGF#to_write_io}
      def to_write_io: () -> IO

      # <!--
      #   rdoc-file=io.c
      #   - ARGF.write(*objects)  -> integer
      # -->
      # Writes each of the given `objects` if inplace mode.
      #
      %a{annotate:rdoc:copy:ARGF#write}
      def write: (_ToS string) -> Integer

      private

      %a{annotate:rdoc:copy:ARGF#initialize}
      def initialize: (*String argv) -> void

      %a{annotate:rdoc:copy:ARGF#initialize_copy}
      def initialize_copy: (self orig) -> self
    end
  end
end
module RBS
  module Unnamed
    %a{annotate:rdoc:copy:Random::Base}
    class Random_Base
      include Random_Formatter
      extend Random_Formatter

      # <!--
      #   rdoc-file=random.c
      #   - Random.new(seed = Random.new_seed) -> prng
      # -->
      # Creates a new PRNG using `seed` to set the initial state. If `seed` is
      # omitted, the generator is initialized with Random.new_seed.
      #
      # See Random.srand for more information on the use of seed values.
      #
      %a{annotate:rdoc:copy:Random.new}
      def initialize: (?Integer seed) -> void

      # <!--
      #   rdoc-file=random.c
      #   - prng.rand -> float
      #   - prng.rand(max) -> number
      #   - prng.rand(range) -> number
      # -->
      # When `max` is an Integer, `rand` returns a random integer greater than or
      # equal to zero and less than `max`. Unlike Kernel.rand, when `max` is a
      # negative integer or zero, `rand` raises an ArgumentError.
      #
      #     prng = Random.new
      #     prng.rand(100)       # => 42
      #
      # When `max` is a Float, `rand` returns a random floating point number between
      # 0.0 and `max`, including 0.0 and excluding `max`.
      #
      #     prng.rand(1.5)       # => 1.4600282860034115
      #
      # When `range` is a Range, `rand` returns a random number where
      # `range.member?(number) == true`.
      #
      #     prng.rand(5..9)      # => one of [5, 6, 7, 8, 9]
      #     prng.rand(5...9)     # => one of [5, 6, 7, 8]
      #     prng.rand(5.0..9.0)  # => between 5.0 and 9.0, including 9.0
      #     prng.rand(5.0...9.0) # => between 5.0 and 9.0, excluding 9.0
      #
      # Both the beginning and ending values of the range must respond to subtract
      # (`-`) and add (`+`)methods, or rand will raise an ArgumentError.
      #
      %a{annotate:rdoc:copy:Random#rand}
      def rand: (?0) -> Float
              | (Integer | ::Range[Integer] max) -> Integer
              | (Float | ::Range[Float] max) -> Float

      # <!--
      #   rdoc-file=random.c
      #   - prng.bytes(size) -> string
      # -->
      # Returns a random binary string containing `size` bytes.
      #
      #     random_string = Random.new.bytes(10) # => "\xD7:R\xAB?\x83\xCE\xFAkO"
      #     random_string.size                   # => 10
      #
      %a{annotate:rdoc:copy:Random#bytes}
      def bytes: (Integer size) -> String

      # <!--
      #   rdoc-file=random.c
      #   - prng.seed -> integer
      # -->
      # Returns the seed value used to initialize the generator. This may be used to
      # initialize another generator with the same state at a later time, causing it
      # to produce the same sequence of numbers.
      #
      #     prng1 = Random.new(1234)
      #     prng1.seed       #=> 1234
      #     prng1.rand(100)  #=> 47
      #
      #     prng2 = Random.new(prng1.seed)
      #     prng2.rand(100)  #=> 47
      #
      %a{annotate:rdoc:copy:Random#seed}
      def seed: () -> Integer
    end

    # <!-- rdoc-file=lib/random/formatter.rb -->
    # ## Random number formatter.
    #
    # Formats generated random numbers in many manners. When `'random/formatter'` is
    # required, several methods are added to empty core module `Random::Formatter`,
    # making them available as Random's instance and module methods.
    #
    # Standard library SecureRandom is also extended with the module, and the
    # methods described below are available as a module methods in it.
    #
    # ### Examples
    #
    # Generate random hexadecimal strings:
    #
    #     require 'random/formatter'
    #
    #     prng = Random.new
    #     prng.hex(10) #=> "52750b30ffbc7de3b362"
    #     prng.hex(10) #=> "92b15d6c8dc4beb5f559"
    #     prng.hex(13) #=> "39b290146bea6ce975c37cfc23"
    #     # or just
    #     Random.hex #=> "1aed0c631e41be7f77365415541052ee"
    #
    # Generate random base64 strings:
    #
    #     prng.base64(10) #=> "EcmTPZwWRAozdA=="
    #     prng.base64(10) #=> "KO1nIU+p9DKxGg=="
    #     prng.base64(12) #=> "7kJSM/MzBJI+75j8"
    #     Random.base64(4) #=> "bsQ3fQ=="
    #
    # Generate random binary strings:
    #
    #     prng.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
    #     prng.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"
    #     Random.random_bytes(6) #=> "\xA1\xE6Lr\xC43"
    #
    # Generate alphanumeric strings:
    #
    #     prng.alphanumeric(10) #=> "S8baxMJnPl"
    #     prng.alphanumeric(10) #=> "aOxAg8BAJe"
    #     Random.alphanumeric #=> "TmP9OsJHJLtaZYhP"
    #
    # Generate UUIDs:
    #
    #     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
    #     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
    #     Random.uuid #=> "f14e0271-de96-45cc-8911-8910292a42cd"
    #
    # All methods are available in the standard library SecureRandom, too:
    #
    #     SecureRandom.hex #=> "05b45376a30c67238eb93b16499e50cf"
    #
    # <!-- rdoc-file=random.c -->
    # Generate a random number in the given range as Random does
    #
    #     prng.random_number       #=> 0.5816771641321361
    #     prng.random_number(1000) #=> 485
    #     prng.random_number(1..6) #=> 3
    #     prng.rand                #=> 0.5816771641321361
    #     prng.rand(1000)          #=> 485
    #     prng.rand(1..6)          #=> 3
    #
    %a{annotate:rdoc:copy:Random::Formatter}
    module Random_Formatter
      # <!--
      #   rdoc-file=lib/random/formatter.rb
      #   - base64(n=nil)
      # -->
      # Generate a random base64 string.
      #
      # The argument *n* specifies the length, in bytes, of the random number to be
      # generated. The length of the result string is about 4/3 of *n*.
      #
      # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
      # future.
      #
      # The result may contain A-Z, a-z, 0-9, "+", "/" and "=".
      #
      #     require 'random/formatter'
      #
      #     Random.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="
      #     # or
      #     prng = Random.new
      #     prng.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="
      #
      # See RFC 3548 for the definition of base64.
      #
      %a{annotate:rdoc:copy:Random::Formatter#base64}
      def base64: (?Integer? n) -> String

      # <!--
      #   rdoc-file=lib/random/formatter.rb
      #   - hex(n=nil)
      # -->
      # Generate a random hexadecimal string.
      #
      # The argument *n* specifies the length, in bytes, of the random number to be
      # generated. The length of the resulting hexadecimal string is twice of *n*.
      #
      # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
      # future.
      #
      # The result may contain 0-9 and a-f.
      #
      #     require 'random/formatter'
      #
      #     Random.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"
      #     # or
      #     prng = Random.new
      #     prng.hex #=> "91dc3bfb4de5b11d029d376634589b61"
      #
      %a{annotate:rdoc:copy:Random::Formatter#hex}
      def hex: (?Integer? n) -> String

      # <!-- rdoc-file=random.c -->
      # Generates formatted random number from raw random bytes. See Random#rand.
      #
      %a{annotate:rdoc:copy:Random::Formatter#rand}
      def rand: (?0) -> Float
              | (Float? n) -> Float
              | (Integer n) -> Integer
              | (Numeric n) -> Numeric
              | (::Range[Float] n) -> Float
              | (::Range[Integer] n) -> Integer
              | (::Range[Numeric] n) -> Numeric

      %a{annotate:rdoc:copy:Random::Formatter#random_byte}
      def random_bytes: (?Integer? n) -> String

      # <!--
      #   rdoc-file=random.c
      #   - prng.random_number        -> float
      #   - prng.random_number(max)   -> number
      #   - prng.random_number(range) -> number
      #   - prng.rand                 -> float
      #   - prng.rand(max)            -> number
      #   - prng.rand(range)          -> number
      # -->
      # Generates formatted random number from raw random bytes. See Random#rand.
      #
      %a{annotate:rdoc:copy:Random::Formatter#random_number}
      def random_number: () -> Float
                       | (?Float? n) -> Float
                       | (?Integer? n) -> Integer
                       | (?Numeric? n) -> Numeric
                       | (?::Range[Float]? n) -> Float
                       | (?::Range[Integer]? n) -> Integer
                       | (?::Range[Numeric]? n) -> Numeric

      # <!--
      #   rdoc-file=lib/random/formatter.rb
      #   - urlsafe_base64(n=nil, padding=false)
      # -->
      # Generate a random URL-safe base64 string.
      #
      # The argument *n* specifies the length, in bytes, of the random number to be
      # generated. The length of the result string is about 4/3 of *n*.
      #
      # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
      # future.
      #
      # The boolean argument *padding* specifies the padding. If it is false or nil,
      # padding is not generated. Otherwise padding is generated. By default, padding
      # is not generated because "=" may be used as a URL delimiter.
      #
      # The result may contain A-Z, a-z, 0-9, "-" and "_". "=" is also used if
      # *padding* is true.
      #
      #     require 'random/formatter'
      #
      #     Random.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"
      #     # or
      #     prng = Random.new
      #     prng.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"
      #
      #     prng.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="
      #     prng.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="
      #
      # See RFC 3548 for the definition of URL-safe base64.
      #
      %a{annotate:rdoc:copy:Random::Formatter#urlsafe_base64}
      def urlsafe_base64: (?Integer? n, ?boolish padding) -> String

      # <!--
      #   rdoc-file=lib/random/formatter.rb
      #   - uuid()
      # -->
      # Generate a random v4 UUID (Universally Unique IDentifier).
      #
      #     require 'random/formatter'
      #
      #     Random.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
      #     Random.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
      #     # or
      #     prng = Random.new
      #     prng.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"
      #
      # The version 4 UUID is purely random (except the version). It doesn't contain
      # meaningful information such as MAC addresses, timestamps, etc.
      #
      # The result contains 122 random bits (15.25 random bytes).
      #
      # See [RFC9562](https://www.rfc-editor.org/rfc/rfc9562) for details of UUIDv4.
      #
      %a{annotate:rdoc:copy:Random::Formatter#uuid}
      def uuid: () -> String
    end
  end
end
# <!-- rdoc-file=random.c -->
# Random provides an interface to Ruby's pseudo-random number generator, or
# PRNG.  The PRNG produces a deterministic sequence of bits which approximate
# true randomness. The sequence may be represented by integers, floats, or
# binary strings.
#
# The generator may be initialized with either a system-generated or
# user-supplied seed value by using Random.srand.
#
# The class method Random.rand provides the base functionality of Kernel.rand
# along with better handling of floating point values. These are both interfaces
# to the Ruby system PRNG.
#
# Random.new will create a new PRNG with a state independent of the Ruby system
# PRNG, allowing multiple generators with different seed values or sequence
# positions to exist simultaneously. Random objects can be marshaled, allowing
# sequences to be saved and resumed.
#
# PRNGs are currently implemented as a modified Mersenne Twister with a period
# of 2**19937-1.  As this algorithm is *not* for cryptographical use, you must
# use SecureRandom for security purpose, instead of this PRNG.
#
# See also Random::Formatter module that adds convenience methods to generate
# various forms of random data.
#
class Random < RBS::Unnamed::Random_Base
  # <!--
  #   rdoc-file=random.c
  #   - Random.new(seed = Random.new_seed) -> prng
  # -->
  # Creates a new PRNG using `seed` to set the initial state. If `seed` is
  # omitted, the generator is initialized with Random.new_seed.
  #
  # See Random.srand for more information on the use of seed values.
  #
  def initialize: (?Integer seed) -> void

  # <!--
  #   rdoc-file=random.c
  #   - Random.bytes(size) -> string
  # -->
  # Returns a random binary string. The argument `size` specifies the length of
  # the returned string.
  #
  def self.bytes: (Integer size) -> String

  # <!--
  #   rdoc-file=random.c
  #   - prng1 == prng2 -> true or false
  # -->
  # Returns true if the two generators have the same internal state, otherwise
  # false.  Equivalent generators will return the same sequence of pseudo-random
  # numbers.  Two generators will generally have the same state only if they were
  # initialized with the same seed
  #
  #     Random.new == Random.new             # => false
  #     Random.new(1234) == Random.new(1234) # => true
  #
  # and have the same invocation history.
  #
  #     prng1 = Random.new(1234)
  #     prng2 = Random.new(1234)
  #     prng1 == prng2 # => true
  #
  #     prng1.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => false
  #
  #     prng2.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => true
  #
  def ==: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=random.c
  #   - Random.new_seed -> integer
  # -->
  # Returns an arbitrary seed value. This is used by Random.new when no seed value
  # is specified as an argument.
  #
  #     Random.new_seed  #=> 115032730400174366788466674494640623225
  #
  def self.new_seed: () -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.rand -> float
  #   - Random.rand(max) -> number
  #   - Random.rand(range) -> number
  # -->
  # Returns a random number using the Ruby system PRNG.
  #
  # See also Random#rand.
  #
  def self.rand: (?0) -> Float
               | (Integer | ::Range[Integer] max) -> Integer
               | (Float | ::Range[Float] max) -> Float
               | [T < Numeric] (::Range[T]) -> T

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self.srand: (?Integer number) -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.urandom(size) -> string
  # -->
  # Returns a string, using platform providing features. Returned value is
  # expected to be a cryptographically secure pseudo-random number in binary form.
  # This method raises a RuntimeError if the feature provided by platform failed
  # to prepare the result.
  #
  # In 2017, Linux manpage random(7) writes that "no cryptographic primitive
  # available today can hope to promise more than 256 bits of security".  So it
  # might be questionable to pass size > 32 to this method.
  #
  #     Random.urandom(8)  #=> "\x78\x41\xBA\xAF\x7D\xEA\xD8\xEA"
  #
  def self.urandom: (Integer) -> String

  # <!--
  #   rdoc-file=random.c
  #   - prng.seed -> integer
  # -->
  # Returns the seed value used to initialize the generator. This may be used to
  # initialize another generator with the same state at a later time, causing it
  # to produce the same sequence of numbers.
  #
  #     prng1 = Random.new(1234)
  #     prng1.seed       #=> 1234
  #     prng1.rand(100)  #=> 47
  #
  #     prng2 = Random.new(prng1.seed)
  #     prng2.rand(100)  #=> 47
  #
  def seed: () -> Integer

  private

  def initialize_copy: (self object) -> self

  def left: () -> untyped

  def marshal_dump: () -> untyped

  def marshal_load: (untyped) -> untyped

  def state: () -> untyped
end

class Random::Base < RBS::Unnamed::Random_Base
end

# <!-- rdoc-file=lib/random/formatter.rb -->
# ## Random number formatter.
#
# Formats generated random numbers in many manners. When `'random/formatter'` is
# required, several methods are added to empty core module `Random::Formatter`,
# making them available as Random's instance and module methods.
#
# Standard library SecureRandom is also extended with the module, and the
# methods described below are available as a module methods in it.
#
# ### Examples
#
# Generate random hexadecimal strings:
#
#     require 'random/formatter'
#
#     prng = Random.new
#     prng.hex(10) #=> "52750b30ffbc7de3b362"
#     prng.hex(10) #=> "92b15d6c8dc4beb5f559"
#     prng.hex(13) #=> "39b290146bea6ce975c37cfc23"
#     # or just
#     Random.hex #=> "1aed0c631e41be7f77365415541052ee"
#
# Generate random base64 strings:
#
#     prng.base64(10) #=> "EcmTPZwWRAozdA=="
#     prng.base64(10) #=> "KO1nIU+p9DKxGg=="
#     prng.base64(12) #=> "7kJSM/MzBJI+75j8"
#     Random.base64(4) #=> "bsQ3fQ=="
#
# Generate random binary strings:
#
#     prng.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
#     prng.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"
#     Random.random_bytes(6) #=> "\xA1\xE6Lr\xC43"
#
# Generate alphanumeric strings:
#
#     prng.alphanumeric(10) #=> "S8baxMJnPl"
#     prng.alphanumeric(10) #=> "aOxAg8BAJe"
#     Random.alphanumeric #=> "TmP9OsJHJLtaZYhP"
#
# Generate UUIDs:
#
#     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
#     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
#     Random.uuid #=> "f14e0271-de96-45cc-8911-8910292a42cd"
#
# All methods are available in the standard library SecureRandom, too:
#
#     SecureRandom.hex #=> "05b45376a30c67238eb93b16499e50cf"
#
# <!-- rdoc-file=random.c -->
# Generate a random number in the given range as Random does
#
#     prng.random_number       #=> 0.5816771641321361
#     prng.random_number(1000) #=> 485
#     prng.random_number(1..6) #=> 3
#     prng.rand                #=> 0.5816771641321361
#     prng.rand(1000)          #=> 485
#     prng.rand(1..6)          #=> 3
#
module Random::Formatter
  include RBS::Unnamed::Random_Formatter
end
# <!-- rdoc-file=object.c -->
# The global value `false` is the only instance of class FalseClass and
# represents a logically false value in boolean expressions. The class provides
# operators allowing `false` to participate correctly in logical expressions.
#
class FalseClass
  def !: () -> true

  # <!--
  #   rdoc-file=object.c
  #   - false & object -> false
  #   - nil & object   -> false
  # -->
  # Returns `false`:
  #
  #     false & true       # => false
  #     false & Object.new # => false
  #
  # Argument `object` is evaluated:
  #
  #     false & raise # Raises RuntimeError.
  #
  def &: (untyped obj) -> false

  # <!--
  #   rdoc-file=object.c
  #   - true === other -> true or false
  #   - false === other -> true or false
  #   - nil === other -> true or false
  # -->
  # Returns `true` or `false`.
  #
  # Like Object#==, if `object` is an instance of Object (and not an instance of
  # one of its many subclasses).
  #
  # This method is commonly overridden by those subclasses, to provide meaningful
  # semantics in `case` statements.
  #
  def ===: (false) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - false ^ object -> true or false
  #   - nil ^ object   -> true or false
  # -->
  # Returns `false` if `object` is `nil` or `false`, `true` otherwise:
  #
  #     nil ^ nil        # => false
  #     nil ^ false      # => false
  #     nil ^ Object.new # => true
  #
  def ^: (false | nil) -> false
       | (untyped obj) -> bool

  # <!-- rdoc-file=object.c -->
  # The string representation of `false` is "false".
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - false.to_s   ->  "false"
  # -->
  # The string representation of `false` is "false".
  #
  def to_s: () -> "false"

  # <!--
  #   rdoc-file=object.c
  #   - false | object -> true or false
  #   - nil   | object -> true or false
  # -->
  # Returns `false` if `object` is `nil` or `false`, `true` otherwise:
  #
  #     nil | nil        # => false
  #     nil | false      # => false
  #     nil | Object.new # => true
  #
  def |: (nil | false) -> false
       | (untyped obj) -> bool
end
# <!-- rdoc-file=rbconfig.rb -->
# The module storing Ruby interpreter configurations on building.
#
# This file was created by mkconfig.rb when ruby was built.  It contains build
# information for ruby which is used e.g. by mkmf to build compatible native
# extensions.  Any changes made to this file will be lost the next time ruby is
# built.
#
module RbConfig
  # <!-- rdoc-file=rbconfig.rb -->
  # The hash configurations stored.
  #
  CONFIG: Hash[String, String]

  # <!-- rdoc-file=rbconfig.rb -->
  # DESTDIR on make install.
  #
  DESTDIR: String

  # <!-- rdoc-file=rbconfig.rb -->
  # Almost same with CONFIG. MAKEFILE_CONFIG has other variable reference like
  # below.
  #
  #     MAKEFILE_CONFIG["bindir"] = "$(exec_prefix)/bin"
  #
  # The values of this constant is used for creating Makefile.
  #
  #     require 'rbconfig'
  #
  #     print <<-END_OF_MAKEFILE
  #     prefix = #{RbConfig::MAKEFILE_CONFIG['prefix']}
  #     exec_prefix = #{RbConfig::MAKEFILE_CONFIG['exec_prefix']}
  #     bindir = #{RbConfig::MAKEFILE_CONFIG['bindir']}
  #     END_OF_MAKEFILE
  #
  #     => prefix = /usr/local
  #        exec_prefix = $(prefix)
  #        bindir = $(exec_prefix)/bin  MAKEFILE_CONFIG = {}
  #
  # RbConfig.expand is used for resolving references like above in rbconfig.
  #
  #     require 'rbconfig'
  #     p RbConfig.expand(RbConfig::MAKEFILE_CONFIG["bindir"])
  #     # => "/usr/local/bin"
  #
  MAKEFILE_CONFIG: Hash[String, String]

  # <!-- rdoc-file=rbconfig.rb -->
  # Ruby installed directory.
  #
  TOPDIR: String

  # <!--
  #   rdoc-file=rbconfig.rb
  #   - RbConfig.expand(val)         -> string
  #   - RbConfig.expand(val, config) -> string
  # -->
  # expands variable with given `val` value.
  #
  #     RbConfig.expand("$(bindir)") # => /home/foobar/all-ruby/ruby19x/bin
  #
  def self.expand: (String val, ?Hash[String, String] config) -> String

  # <!--
  #   rdoc-file=rbconfig.rb
  #   - RbConfig.fire_update!(key, val)               -> array
  #   - RbConfig.fire_update!(key, val, mkconf, conf) -> array
  # -->
  # updates `key+ in `mkconf` with `val`, and all values depending on
  # the `key` in `mkconf`.
  #
  #   RbConfig::MAKEFILE_CONFIG.values_at("CC", "LDSHARED") # => ["gcc", "$(CC) -shared"]
  #   RbConfig::CONFIG.values_at("CC", "LDSHARED")          # => ["gcc", "gcc -shared"]
  #   RbConfig.fire_update!("CC", "gcc-8")                  # => ["CC", "LDSHARED"]
  #   RbConfig::MAKEFILE_CONFIG.values_at("CC", "LDSHARED") # => ["gcc-8", "$(CC) -shared"]
  #   RbConfig::CONFIG.values_at("CC", "LDSHARED")          # => ["gcc-8", "gcc-8 -shared"]
  #
  # returns updated keys list, or `nil` if nothing changed.
  def self.fire_update!: (String key, String val, ?Hash[String, String] mkconf, ?Hash[String, String] conf) -> Array[String]?

  # <!--
  #   rdoc-file=rbconfig.rb
  #   - RbConfig.ruby -> path
  # -->
  #
  # returns the absolute pathname of the ruby command.
  def self.ruby: () -> String
end
# <!-- rdoc-file=signal.c -->
# Many operating systems allow signals to be sent to running processes. Some
# signals have a defined effect on the process, while others may be trapped at
# the code level and acted upon. For example, your process may trap the USR1
# signal and use it to toggle debugging, and may use TERM to initiate a
# controlled shutdown.
#
#     pid = fork do
#       Signal.trap("USR1") do
#         $debug = !$debug
#         puts "Debug now: #$debug"
#       end
#       Signal.trap("TERM") do
#         puts "Terminating..."
#         shutdown()
#       end
#       # . . . do some work . . .
#     end
#
#     Process.detach(pid)
#
#     # Controlling program:
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("TERM", pid)
#
# *produces:*
#     Debug now: true
#     Debug now: false
#     Terminating...
#
# The list of available signal names and their interpretation is system
# dependent. Signal delivery semantics may also vary between systems; in
# particular signal delivery may not always be reliable.
#
module Signal
  # <!--
  #   rdoc-file=signal.c
  #   - Signal.list -> a_hash
  # -->
  # Returns a list of signal names mapped to the corresponding underlying signal
  # numbers.
  #
  #     Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4, "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11, "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19, "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22, "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28, "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}
  #
  def self?.list: () -> Hash[String, Integer]

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.signame(signo)  ->  string or nil
  # -->
  # Convert signal number to signal name. Returns `nil` if the signo is an invalid
  # signal number.
  #
  #     Signal.trap("INT") { |signo| puts Signal.signame(signo) }
  #     Process.kill("INT", 0)
  #
  # *produces:*
  #
  #     INT
  #
  def self?.signame: (int signo) -> String?

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.trap( signal, command ) -> obj
  #   - Signal.trap( signal ) {| | block } -> obj
  # -->
  # Specifies the handling of signals. The first parameter is a signal name (a
  # string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The
  # characters ``SIG'' may be omitted from the signal name. The command or block
  # specifies code to be run when the signal is raised. If the command is the
  # string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command
  # is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler will be invoked. If
  # the command is ``EXIT'', the script will be terminated by the signal. If the
  # command is ``SYSTEM_DEFAULT'', the operating system's default handler will be
  # invoked. Otherwise, the given command or block will be run. The special signal
  # name ``EXIT'' or signal number zero will be invoked just prior to program
  # termination. trap returns the previous handler for the given signal.
  #
  #     Signal.trap(0, proc { puts "Terminating: #{$$}" })
  #     Signal.trap("CLD")  { puts "Child died" }
  #     fork && Process.wait
  #
  # *produces:*
  #     Terminating: 27461
  #     Child died
  #     Terminating: 27460
  #
  def self?.trap: (Integer | interned signal) { (Integer) -> void } -> trap_command
                | (Integer | interned signal, trap_command command) -> trap_command

  type trap_command = string | bool | nil | _TrapCommand

  interface _TrapCommand
    def call: (Integer signo) -> void
  end
end
%a{annotate:rdoc:skip}
module ObjectSpace
  # <!-- rdoc-file=weakmap.c -->
  # An ObjectSpace::WeakKeyMap is a key-value map that holds weak references to
  # its keys, so they can be garbage collected when there is no more references.
  #
  # Unlike ObjectSpace::WeakMap:
  #
  # *   references to values are *strong*, so they aren't garbage collected while
  #     they are in the map;
  # *   keys are compared by value (using Object#eql?), not by identity;
  # *   only garbage-collectable objects can be used as keys.
  #
  #         map = ObjectSpace::WeakKeyMap.new
  #         val = Time.new(2023, 12, 7)
  #         key = "name"
  #         map[key] = val
  #
  #         # Value is fetched by equality: the instance of string "name" is
  #         # different here, but it is equal to the key
  #         map["name"] #=> 2023-12-07 00:00:00 +0200
  #
  #         val = nil
  #         GC.start
  #         # There are no more references to `val`, yet the pair isn't
  #         # garbage-collected.
  #         map["name"] #=> 2023-12-07 00:00:00 +0200
  #
  #         key = nil
  #         GC.start
  #         # There are no more references to `key`, key and value are
  #         # garbage-collected.
  #         map["name"] #=> nil
  #
  # (Note that GC.start is used here only for demonstrational purposes and might
  # not always lead to demonstrated results.)
  #
  # The collection is especially useful for implementing caches of lightweight
  # value objects, so that only one copy of each value representation would be
  # stored in memory, but the copies that aren't used would be garbage-collected.
  #
  #     CACHE = ObjectSpace::WeakKeyMap
  #
  #     def make_value(**)
  #        val = ValueObject.new(**)
  #        if (existing = @cache.getkey(val))
  #           # if the object with this value exists, we return it
  #           existing
  #        else
  #           # otherwise, put it in the cache
  #           @cache[val] = true
  #           val
  #        end
  #     end
  #
  # This will result in `make_value` returning the same object for same set of
  # attributes always, but the values that aren't needed anymore wouldn't be
  # sitting in the cache forever.
  #
  class WeakKeyMap[Key, Value]
    # <!--
    #   rdoc-file=weakmap.c
    #   - map[key] -> value
    # -->
    # Returns the value associated with the given `key` if found.
    #
    # If `key` is not found, returns `nil`.
    #
    def []: (Key) -> Value?

    # <!--
    #   rdoc-file=weakmap.c
    #   - map[key] = value -> value
    # -->
    # Associates the given `value` with the given `key`
    #
    # The reference to `key` is weak, so when there is no other reference to `key`
    # it may be garbage collected.
    #
    # If the given `key` exists, replaces its value with the given `value`; the
    # ordering is not affected
    #
    def []=: (Key, Value?) -> Value?

    # <!--
    #   rdoc-file=weakmap.c
    #   - map.clear -> self
    # -->
    # Removes all map entries; returns `self`.
    #
    def clear: () -> self

    # <!--
    #   rdoc-file=weakmap.c
    #   - map.delete(key) -> value or nil
    #   - map.delete(key) {|key| ... } -> object
    # -->
    # Deletes the entry for the given `key` and returns its associated value.
    #
    # If no block is given and `key` is found, deletes the entry and returns the
    # associated value:
    #     m = ObjectSpace::WeakKeyMap.new
    #     key = "foo" # to hold reference to the key
    #     m[key] = 1
    #     m.delete("foo") # => 1
    #     m["foo"] # => nil
    #
    # If no block given and `key` is not found, returns `nil`.
    #
    # If a block is given and `key` is found, ignores the block, deletes the entry,
    # and returns the associated value:
    #     m = ObjectSpace::WeakKeyMap.new
    #     key = "foo" # to hold reference to the key
    #     m[key] = 2
    #     m.delete("foo") { |key| raise 'Will never happen'} # => 2
    #
    # If a block is given and `key` is not found, yields the `key` to the block and
    # returns the block's return value:
    #     m = ObjectSpace::WeakKeyMap.new
    #     m.delete("nosuch") { |key| "Key #{key} not found" } # => "Key nosuch not found"
    #
    def delete: (Key) -> Value?
              | [T] (Key) { (Key) -> T } -> (Value | T)

    # <!--
    #   rdoc-file=weakmap.c
    #   - map.getkey(key) -> existing_key or nil
    # -->
    # Returns the existing equal key if it exists, otherwise returns `nil`.
    #
    # This might be useful for implementing caches, so that only one copy of some
    # object would be used everywhere in the program:
    #
    #     value = {amount: 1, currency: 'USD'}
    #
    #     # Now if we put this object in a cache:
    #     cache = ObjectSpace::WeakKeyMap.new
    #     cache[value] = true
    #
    #     # ...we can always extract from there and use the same object:
    #     copy = cache.getkey({amount: 1, currency: 'USD'})
    #     copy.object_id == value.object_id #=> true
    #
    def getkey: (untyped) -> Key?

    # <!--
    #   rdoc-file=weakmap.c
    #   - map.inspect -> new_string
    # -->
    # Returns a new String containing informations about the map:
    #
    #     m = ObjectSpace::WeakKeyMap.new
    #     m[key] = value
    #     m.inspect # => "#<ObjectSpace::WeakKeyMap:0x00000001028dcba8 size=1>"
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=weakmap.c
    #   - map.key?(key) -> true or false
    # -->
    # Returns `true` if `key` is a key in `self`, otherwise `false`.
    #
    def key?: (Key) -> bool
  end
end
# <!-- rdoc-file=class.c -->
# Refinement is a class of the `self` (current context) inside `refine`
# statement. It allows to import methods from other modules, see
# #import_methods.
#
class Refinement < Module
  # <!--
  #   rdoc-file=eval.c
  #   - target    -> class_or_module
  # -->
  # Return the class or module refined by the receiver.
  #
  #     module M
  #       refine String do
  #       end
  #     end
  #
  #     M.refinements[0].target # => String
  #
  def target: () -> Module?

  private

  # <!--
  #   rdoc-file=class.c
  #   - import_methods(module, ...)    -> self
  # -->
  # Imports methods from modules. Unlike Module#include, Refinement#import_methods
  # copies methods and adds them into the refinement, so the refinement is
  # activated in the imported methods.
  #
  # Note that due to method copying, only methods defined in Ruby code can be
  # imported.
  #
  #     module StrUtils
  #       def indent(level)
  #         ' ' * level + self
  #       end
  #     end
  #
  #     module M
  #       refine String do
  #         import_methods StrUtils
  #       end
  #     end
  #
  #     using M
  #     "foo".indent(3)
  #     #=> "   foo"
  #
  #     module M
  #       refine String do
  #         import_methods Enumerable
  #         # Can't import method which is not defined with Ruby code: Enumerable#drop
  #       end
  #     end
  #
  def import_methods: (Module module, *Module extra_modules) -> self
end
# <!-- rdoc-file=numeric.c -->
# An Integer object represents an integer value.
#
# You can create an Integer object explicitly with:
#
# *   An [integer literal](rdoc-ref:syntax/literals.rdoc@Integer+Literals).
#
# You can convert certain objects to Integers with:
#
# *   Method #Integer.
#
# An attempt to add a singleton method to an instance of this class causes an
# exception to be raised.
#
# ## What's Here
#
# First, what's elsewhere. Class Integer:
#
# *   Inherits from [class Numeric](rdoc-ref:Numeric@What-27s+Here) and [class
#     Object](rdoc-ref:Object@What-27s+Here).
# *   Includes [module Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class Integer provides methods for:
#
# *   [Querying](rdoc-ref:Integer@Querying)
# *   [Comparing](rdoc-ref:Integer@Comparing)
# *   [Converting](rdoc-ref:Integer@Converting)
# *   [Other](rdoc-ref:Integer@Other)
#
# ### Querying
#
# *   #allbits?: Returns whether all bits in `self` are set.
# *   #anybits?: Returns whether any bits in `self` are set.
# *   #nobits?: Returns whether no bits in `self` are set.
#
# ### Comparing
#
# *   #<: Returns whether `self` is less than the given value.
# *   #<=: Returns whether `self` is less than or equal to the given value.
# *   #<=>: Returns a number indicating whether `self` is less than, equal to,
#     or greater than the given value.
# *   #== (aliased as #===): Returns whether `self` is equal to the given
#         value.
#
# *   #>: Returns whether `self` is greater than the given value.
# *   #>=: Returns whether `self` is greater than or equal to the given value.
#
# ### Converting
#
# *   ::sqrt: Returns the integer square root of the given value.
# *   ::try_convert: Returns the given value converted to an Integer.
# *   #% (aliased as #modulo): Returns `self` modulo the given value.
# *   #&: Returns the bitwise AND of `self` and the given value.
# *   #*: Returns the product of `self` and the given value.
# *   #**: Returns the value of `self` raised to the power of the given value.
# *   #+: Returns the sum of `self` and the given value.
# *   #-: Returns the difference of `self` and the given value.
# *   #/: Returns the quotient of `self` and the given value.
# *   #<<: Returns the value of `self` after a leftward bit-shift.
# *   #>>: Returns the value of `self` after a rightward bit-shift.
# *   #[]: Returns a slice of bits from `self`.
# *   #^: Returns the bitwise EXCLUSIVE OR of `self` and the given value.
# *   #|: Returns the bitwise OR of `self` and the given value.
# *   #ceil: Returns the smallest number greater than or equal to `self`.
# *   #chr: Returns a 1-character string containing the character represented by
#     the value of `self`.
# *   #digits: Returns an array of integers representing the base-radix digits
#     of `self`.
# *   #div: Returns the integer result of dividing `self` by the given value.
# *   #divmod: Returns a 2-element array containing the quotient and remainder
#     results of dividing `self` by the given value.
# *   #fdiv: Returns the Float result of dividing `self` by the given value.
# *   #floor: Returns the greatest number smaller than or equal to `self`.
# *   #pow: Returns the modular exponentiation of `self`.
# *   #pred: Returns the integer predecessor of `self`.
# *   #remainder: Returns the remainder after dividing `self` by the given
#     value.
# *   #round: Returns `self` rounded to the nearest value with the given
#     precision.
# *   #succ (aliased as #next): Returns the integer successor of `self`.
# *   #to_f: Returns `self` converted to a Float.
# *   #to_s (aliased as #inspect): Returns a string containing the place-value
#     representation of `self` in the given radix.
# *   #truncate: Returns `self` truncated to the given precision.
#
# ### Other
#
# *   #downto: Calls the given block with each integer value from `self` down to
#     the given value.
# *   #times: Calls the given block `self` times with each integer in
#     `(0..self-1)`.
# *   #upto: Calls the given block with each integer value from `self` up to the
#     given value.
#
class Integer < Numeric
  # <!--
  #   rdoc-file=numeric.c
  #   - Integer.sqrt(numeric) -> integer
  # -->
  # Returns the integer square root of the non-negative integer `n`, which is the
  # largest non-negative integer less than or equal to the square root of
  # `numeric`.
  #
  #     Integer.sqrt(0)       # => 0
  #     Integer.sqrt(1)       # => 1
  #     Integer.sqrt(24)      # => 4
  #     Integer.sqrt(25)      # => 5
  #     Integer.sqrt(10**400) # => 10**200
  #
  # If `numeric` is not an Integer, it is converted to an Integer:
  #
  #     Integer.sqrt(Complex(4, 0))  # => 2
  #     Integer.sqrt(Rational(4, 1)) # => 2
  #     Integer.sqrt(4.0)            # => 2
  #     Integer.sqrt(3.14159)        # => 1
  #
  # This method is equivalent to `Math.sqrt(numeric).floor`, except that the
  # result of the latter code may differ from the true value due to the limited
  # precision of floating point arithmetic.
  #
  #     Integer.sqrt(10**46)    # => 100000000000000000000000
  #     Math.sqrt(10**46).floor # => 99999999999999991611392
  #
  # Raises an exception if `numeric` is negative.
  #
  def self.sqrt: (int n) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - Integer.try_convert(object) -> object, integer, or nil
  # -->
  # If `object` is an Integer object, returns `object`.
  #     Integer.try_convert(1) # => 1
  #
  # Otherwise if `object` responds to `:to_int`, calls `object.to_int` and returns
  # the result.
  #     Integer.try_convert(1.25) # => 1
  #
  # Returns `nil` if `object` does not respond to `:to_int`
  #     Integer.try_convert([]) # => nil
  #
  # Raises an exception unless `object.to_int` returns an Integer object.
  #
  def self.try_convert: (int) -> Integer
                      | (untyped) -> Integer?

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_number
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  def %: (Float) -> Float
       | (Rational) -> Rational
       | (Integer) -> Integer
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self & other ->  integer
  # -->
  # Bitwise AND; each bit in the result is 1 if both corresponding bits in `self`
  # and `other` are 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 & 0b0110) # => "0100"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#| (bitwise OR), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def &: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self * numeric -> numeric_result
  # -->
  # Performs multiplication:
  #
  #     4 * 2              # => 8
  #     4 * -2             # => -8
  #     -4 * 2             # => -8
  #     4 * 2.0            # => 8.0
  #     4 * Rational(1, 3) # => (4/3)
  #     4 * Complex(2, 0)  # => (8+0i)
  #
  def *: (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex
       | (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** numeric -> numeric_result
  # -->
  # Raises `self` to the power of `numeric`:
  #
  #     2 ** 3              # => 8
  #     2 ** -3             # => (1/8)
  #     -2 ** 3             # => -8
  #     -2 ** -3            # => (-1/8)
  #     2 ** 3.3            # => 9.849155306759329
  #     2 ** Rational(3, 1) # => (8/1)
  #     2 ** Complex(3, 0)  # => (8+0i)
  #
  def **: (Integer) -> Numeric
        | (Float) -> Numeric
        | (Rational) -> Numeric
        | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self + numeric -> numeric_result
  # -->
  # Performs addition:
  #
  #     2 + 2              # => 4
  #     -2 + 2             # => 0
  #     -2 + -2            # => -4
  #     2 + 2.0            # => 4.0
  #     2 + Rational(2, 1) # => (4/1)
  #     2 + Complex(2, 0)  # => (4+0i)
  #
  def +: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  def +@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self - numeric -> numeric_result
  # -->
  # Performs subtraction:
  #
  #     4 - 2              # => 2
  #     -4 - 2             # => -6
  #     -4 - -2            # => -2
  #     4 - 2.0            # => 2.0
  #     4 - Rational(2, 1) # => (2/1)
  #     4 - Complex(2, 0)  # => (2+0i)
  #
  def -: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - -int -> integer
  # -->
  # Returns `self`, negated.
  #
  def -@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self / numeric -> numeric_result
  # -->
  # Performs division; for integer `numeric`, truncates the result to an integer:
  #
  #      4 / 3              # => 1
  #      4 / -3             # => -2
  #      -4 / 3             # => -2
  #      -4 / -3            # => 1
  #
  #     For other +numeric+, returns non-integer result:
  #
  #      4 / 3.0            # => 1.3333333333333333
  #      4 / Rational(3, 1) # => (4/3)
  #      4 / Complex(3, 0)  # => ((4/3)+0i)
  #
  def /: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if the value of `self` is less than that of `other`:
  #
  #       1 < 0              # => false
  #       1 < 1              # => false
  #       1 < 2              # => true
  #       1 < 0.5            # => false
  #       1 < Rational(1, 2) # => false
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self << count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the left, or to the
  # right if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n << 1)  # => "111100000"
  #     "%08b" % (n << 3)  # => "11110000000"
  #     "%08b" % (n << -1) # => "01111000"
  #     "%08b" % (n << -3) # => "00011110"
  #
  # Related: Integer#>>.
  #
  def <<: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= real -> true or false
  # -->
  # Returns `true` if the value of `self` is less than or equal to that of
  # `other`:
  #
  #     1 <= 0              # => false
  #     1 <= 1              # => true
  #     1 <= 2              # => true
  #     1 <= 0.5            # => false
  #     1 <= Rational(1, 2) # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other  ->  -1, 0, +1, or nil
  # -->
  # Returns:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater then `other`.
  # *   `nil`, if `self` and `other` are incomparable.
  #
  # Examples:
  #
  #     1 <=> 2              # => -1
  #     1 <=> 1              # => 0
  #     1 <=> 0              # => 1
  #     1 <=> 'foo'          # => nil
  #
  #     1 <=> 1.0            # => 0
  #     1 <=> Rational(1, 1) # => 0
  #     1 <=> Complex(1, 0)  # => 0
  #
  # This method is the basis for comparisons in module Comparable.
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than that of `other`:
  #
  #       1 > 0              # => true
  #       1 > 1              # => false
  #       1 > 2              # => false
  #       1 > 0.5            # => true
  #       1 > Rational(1, 2) # => true
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= real -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than or equal to that of
  # `other`:
  #
  #     1 >= 0              # => true
  #     1 >= 1              # => true
  #     1 >= 2              # => false
  #     1 >= 0.5            # => true
  #     1 >= Rational(1, 2) # => true
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >> count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the right, or to the
  # left if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n >> 1)  # => "01111000"
  #     "%08b" % (n >> 3)  # => "00011110"
  #     "%08b" % (n >> -1) # => "111100000"
  #     "%08b" % (n >> -3) # => "11110000000"
  #
  # Related: Integer#<<.
  #
  def >>: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self[offset]    -> 0 or 1
  #   - self[offset, size] -> integer
  #   - self[range] -> integer
  # -->
  # Returns a slice of bits from `self`.
  #
  # With argument `offset`, returns the bit at the given offset, where offset 0
  # refers to the least significant bit:
  #
  #     n = 0b10 # => 2
  #     n[0]     # => 0
  #     n[1]     # => 1
  #     n[2]     # => 0
  #     n[3]     # => 0
  #
  # In principle, `n[i]` is equivalent to `(n >> i) & 1`. Thus, negative index
  # always returns zero:
  #
  #     255[-1] # => 0
  #
  # With arguments `offset` and `size`, returns `size` bits from `self`, beginning
  # at `offset` and including bits of greater significance:
  #
  #     n = 0b111000       # => 56
  #     "%010b" % n[0, 10] # => "0000111000"
  #     "%010b" % n[4, 10] # => "0000000011"
  #
  # With argument `range`, returns `range.size` bits from `self`, beginning at
  # `range.begin` and including bits of greater significance:
  #
  #     n = 0b111000      # => 56
  #     "%010b" % n[0..9] # => "0000111000"
  #     "%010b" % n[4..9] # => "0000000011"
  #
  # Raises an exception if the slice cannot be constructed.
  #
  def []: (int) -> Integer
        | (int i, int len) -> Integer
        | (Range[int]) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ^ other -> integer
  # -->
  # Bitwise EXCLUSIVE OR; each bit in the result is 1 if the corresponding bits in
  # `self` and `other` are different, 0 otherwise:
  #
  #     "%04b" % (0b0101 ^ 0b0110) # => "0011"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#| (bitwise OR).
  #
  def ^: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - abs -> integer
  # -->
  # Returns the absolute value of `self`.
  #
  #     (-12345).abs # => 12345
  #     -12345.abs   # => 12345
  #     12345.abs    # => 12345
  #
  def abs: () -> Integer

  def abs2: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - allbits?(mask) -> true or false
  # -->
  # Returns `true` if all bits that are set (=1) in `mask` are also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b1010101  self
  #     0b1010100  mask
  #     0b1010100  self & mask
  #          true  self.allbits?(mask)
  #
  #     0b1010100  self
  #     0b1010101  mask
  #     0b1010100  self & mask
  #         false  self.allbits?(mask)
  #
  # Related: Integer#anybits?, Integer#nobits?.
  #
  def allbits?: (int mask) -> bool

  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - anybits?(mask) -> true or false
  # -->
  # Returns `true` if any bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b10000010  self
  #     0b11111111  mask
  #     0b10000010  self & mask
  #           true  self.anybits?(mask)
  #
  #     0b00000000  self
  #     0b11111111  mask
  #     0b00000000  self & mask
  #          false  self.anybits?(mask)
  #
  # Related: Integer#allbits?, Integer#nobits?.
  #
  def anybits?: (int mask) -> bool

  alias arg angle

  # <!--
  #   rdoc-file=numeric.rb
  #   - bit_length -> integer
  # -->
  # Returns the number of bits of the value of `self`, which is the bit position
  # of the highest-order bit that is different from the sign bit (where the least
  # significant bit has bit position 1). If there is no such bit (zero or minus
  # one), returns zero.
  #
  # This method returns `ceil(log2(self < 0 ? -self : self + 1))`>.
  #
  #     (-2**1000-1).bit_length   # => 1001
  #     (-2**1000).bit_length     # => 1000
  #     (-2**1000+1).bit_length   # => 1000
  #     (-2**12-1).bit_length     # => 13
  #     (-2**12).bit_length       # => 12
  #     (-2**12+1).bit_length     # => 12
  #     -0x101.bit_length         # => 9
  #     -0x100.bit_length         # => 8
  #     -0xff.bit_length          # => 8
  #     -2.bit_length             # => 1
  #     -1.bit_length             # => 0
  #     0.bit_length              # => 0
  #     1.bit_length              # => 1
  #     0xff.bit_length           # => 8
  #     0x100.bit_length          # => 9
  #     (2**12-1).bit_length      # => 12
  #     (2**12).bit_length        # => 13
  #     (2**12+1).bit_length      # => 13
  #     (2**1000-1).bit_length    # => 1000
  #     (2**1000).bit_length      # => 1001
  #     (2**1000+1).bit_length    # => 1001
  #
  # For Integer *n*, this method can be used to detect overflow in Array#pack:
  #
  #     if n.bit_length < 32
  #       [n].pack('l') # No overflow.
  #     else
  #       raise 'Overflow'
  #     end
  #
  def bit_length: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> integer
  # -->
  # Returns an integer that is a "ceiling" value for `self`,
  # as specified by the given `ndigits`,
  # which must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  # *   When `self` is zero, returns zero (regardless of the value of `ndigits`):
  #         0.ceil(2)  # => 0
  # 0.ceil(-2) # => 0
  #
  # *   When `self` is non-zero and `ndigits` is non-negative, returns `self`:
  #         555.ceil     # => 555
  # 555.ceil(50) # => 555
  #
  # *   When `self` is non-zero and `ndigits` is negative,
  #      returns a value based on a computed granularity:
  #     *   The granularity is `10 ** ndigits.abs`.
  #     *   The returned value is the smallest multiple of the granularity
  #          that is greater than or equal to `self`.
  #     Examples with positive `self`:
  # ndigits|Granularity|1234.ceil(ndigits)
  # -------|-----------|------------------
  #      -1|         10|              1240
  #      -2|        100|              1300
  #      -3|       1000|              2000
  #      -4|      10000|             10000
  #      -5|     100000|            100000
  #     Examples with negative `self`:
  # ndigits|Granularity|-1234.ceil(ndigits)
  # -------|-----------|-------------------
  #      -1|         10|              -1230
  #      -2|        100|              -1200
  #      -3|       1000|              -1000
  #      -4|      10000|                  0
  #      -5|     100000|                  0
  # Related: Integer#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - ceildiv(numeric) -> integer
  # -->
  # Returns the result of division `self` by `numeric`. rounded up to the nearest
  # integer.
  #
  #     3.ceildiv(3)   # => 1
  #     4.ceildiv(3)   # => 2
  #
  #     4.ceildiv(-3)  # => -1
  #     -4.ceildiv(3)  # => -1
  #     -4.ceildiv(-3) # => 2
  #
  #     3.ceildiv(1.2) # => 3
  #
  def ceildiv: (Numeric other) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - chr           -> string
  #   - chr(encoding) -> string
  # -->
  # Returns a 1-character string containing the character represented by the value
  # of `self`, according to the given `encoding`.
  #
  #     65.chr                   # => "A"
  #     0.chr                    # => "\x00"
  #     255.chr                  # => "\xFF"
  #     string = 255.chr(Encoding::UTF_8)
  #     string.encoding          # => Encoding::UTF_8
  #
  # Raises an exception if `self` is negative.
  #
  # Related: Integer#ord.
  #
  def chr: (?encoding) -> String

  # <!--
  #   rdoc-file=bignum.c
  #   - int.coerce(numeric)  ->  array
  # -->
  # Returns an array with both a `numeric` and a `int` represented as Integer
  # objects or Float objects.
  #
  # This is achieved by converting `numeric` to an Integer or a Float.
  #
  # A TypeError is raised if the `numeric` is not an Integer or a Float type.
  #
  #     (0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=> [42, 4611686018427387904]
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Integer

  def conjugate: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - denominator -> 1
  # -->
  # Returns `1`.
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - digits(base = 10) -> array_of_integers
  # -->
  # Returns an array of integers representing the `base`-radix digits of `self`;
  # the first element of the array represents the least significant digit:
  #
  #     12345.digits      # => [5, 4, 3, 2, 1]
  #     12345.digits(7)   # => [4, 6, 6, 0, 5]
  #     12345.digits(100) # => [45, 23, 1]
  #
  # Raises an exception if `self` is negative or `base` is less than 2.
  #
  def digits: (?int base) -> ::Array[Integer]

  # <!--
  #   rdoc-file=numeric.c
  #   - div(numeric)  -> integer
  # -->
  # Performs integer division; returns the integer result of dividing `self` by
  # `numeric`:
  #
  #     4.div(3)              # => 1
  #     4.div(-3)             # => -2
  #     -4.div(3)             # => -2
  #     -4.div(-3)            # => 1
  #     4.div(3.0)            # => 1
  #     4.div(Rational(3, 1)) # => 1
  #
  # Raises an exception if `numeric` does not have method `div`.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor    # Quotient
  #     r = self % other          # Remainder
  #
  # Examples:
  #
  #     11.divmod(4)              # => [2, 3]
  #     11.divmod(-4)             # => [-3, -1]
  #     -11.divmod(4)             # => [-3, 1]
  #     -11.divmod(-4)            # => [2, -3]
  #
  #     12.divmod(4)              # => [3, 0]
  #     12.divmod(-4)             # => [-3, 0]
  #     -12.divmod(4)             # => [-3, 0]
  #     -12.divmod(-4)            # => [3, 0]
  #
  #     13.divmod(4.0)            # => [3, 1.0]
  #     13.divmod(Rational(4, 1)) # => [3, (1/1)]
  #
  def divmod: (Integer) -> [ Integer, Integer ]
            | (Float) -> [ Integer, Float ]
            | (Rational) -> [ Integer, Rational ]
            | (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - downto(limit) {|i| ... } -> self
  #   - downto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` down to `limit`;
  # returns `self`:
  #
  #     a = []
  #     10.downto(5) {|i| a << i }              # => 10
  #     a                                       # => [10, 9, 8, 7, 6, 5]
  #     a = []
  #     0.downto(-5) {|i| a << i }              # => 0
  #     a                                       # => [0, -1, -2, -3, -4, -5]
  #     4.downto(5) {|i| fail 'Cannot happen' } # => 4
  #
  # With no block given, returns an Enumerator.
  #
  def downto: (Numeric limit) { (Integer) -> void } -> Integer
            | (Numeric limit) -> ::Enumerator[Integer, self]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - even? -> true or false
  # -->
  # Returns `true` if `self` is an even number, `false` otherwise.
  #
  def even?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(numeric) -> float
  # -->
  # Returns the Float result of dividing `self` by `numeric`:
  #
  #     4.fdiv(2)      # => 2.0
  #     4.fdiv(-2)      # => -2.0
  #     -4.fdiv(2)      # => -2.0
  #     4.fdiv(2.0)      # => 2.0
  #     4.fdiv(Rational(3, 4))      # => 5.333333333333333
  #
  # Raises an exception if `numeric` cannot be converted to a Float.
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> integer
  # -->
  # Returns an integer that is a "floor" value for `self`,
  # as specified by the given `ndigits`,
  # which must be an
  # [integer-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects).
  # *   When `self` is zero, returns zero (regardless of the value of `ndigits`):
  #         0.floor(2)  # => 0
  # 0.floor(-2) # => 0
  #
  # *   When `self` is non-zero and `ndigits` is non-negative, returns `self`:
  #         555.floor     # => 555
  # 555.floor(50) # => 555
  #
  # *   When `self` is non-zero and `ndigits` is negative,
  #      returns a value based on a computed granularity:
  #     *   The granularity is `10 ** ndigits.abs`.
  #     *   The returned value is the largest multiple of the granularity
  #          that is less than or equal to `self`.
  #     Examples with positive `self`:
  # ndigits|Granularity|1234.floor(ndigits)
  # -------|-----------|-------------------
  #      -1|         10|               1230
  #      -2|        100|               1200
  #      -3|       1000|               1000
  #      -4|      10000|                  0
  #      -5|     100000|                  0
  #     Examples with negative `self`:
  # ndigits|Granularity|-1234.floor(ndigits)
  # -------|-----------|--------------------
  #      -1|         10|               -1240
  #      -2|        100|               -1300
  #      -3|       1000|               -2000
  #      -4|      10000|              -10000
  #      -5|     100000|             -100000
  # Related: Integer#ceil.
  #
  def floor: (?int digits) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcd(other_int)  ->  integer
  # -->
  # Returns the greatest common divisor of the two integers. The result is always
  # positive. 0.gcd(x) and x.gcd(0) return x.abs.
  #
  #     36.gcd(60)                  #=> 12
  #     2.gcd(2)                    #=> 2
  #     3.gcd(-7)                   #=> 1
  #     ((1<<31)-1).gcd((1<<61)-1)  #=> 1
  #
  def gcd: (Integer) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcdlcm(other_int)  ->  array
  # -->
  # Returns an array with the greatest common divisor and the least common
  # multiple of the two integers, [gcd, lcm].
  #
  #     36.gcdlcm(60)                  #=> [12, 180]
  #     2.gcdlcm(2)                    #=> [2, 2]
  #     3.gcdlcm(-7)                   #=> [1, 21]
  #     ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]
  #
  def gcdlcm: (Integer) -> [ Integer, Integer ]

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=numeric.rb
  #   - integer? -> true
  # -->
  # Since `self` is already an Integer, always returns `true`.
  #
  def integer?: () -> true

  # <!--
  #   rdoc-file=rational.c
  #   - int.lcm(other_int)  ->  integer
  # -->
  # Returns the least common multiple of the two integers. The result is always
  # positive. 0.lcm(x) and x.lcm(0) return zero.
  #
  #     36.lcm(60)                  #=> 180
  #     2.lcm(2)                    #=> 2
  #     3.lcm(-7)                   #=> 21
  #     ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297
  #
  def lcm: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  def magnitude: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  alias modulo %

  def negative?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Related: Integer#pred (predecessor value).
  #
  def next: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - nobits?(mask) -> true or false
  # -->
  # Returns `true` if no bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b11110000  self
  #     0b00001111  mask
  #     0b00000000  self & mask
  #           true  self.nobits?(mask)
  #
  #     0b00000001  self
  #     0b11111111  mask
  #     0b00000001  self & mask
  #          false  self.nobits?(mask)
  #
  # Related: Integer#allbits?, Integer#anybits?.
  #
  def nobits?: (int mask) -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=numeric.rb
  #   - numerator -> self
  # -->
  # Returns `self`.
  #
  def numerator: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - odd? -> true or false
  # -->
  # Returns `true` if `self` is an odd number, `false` otherwise.
  #
  def odd?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - ord -> self
  # -->
  # Returns `self`; intended for compatibility to character literals in Ruby 1.9.
  #
  def ord: () -> Integer

  alias phase angle

  def polar: () -> [ Integer, Integer | Float ]

  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - integer.pow(numeric)           ->  numeric
  #   - integer.pow(integer, integer)  ->  integer
  # -->
  # Returns (modular) exponentiation as:
  #
  #     a.pow(b)     #=> same as a**b
  #     a.pow(b, m)  #=> same as (a**b) % m, but avoids huge temporary values
  #
  def pow: (Integer other) -> (Integer | Rational)
         | (Integer other, Integer modulo) -> Integer
         | (Float) -> (Float | Complex)
         | (Rational) -> (Float | Rational | Complex)
         | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - pred -> next_integer
  # -->
  # Returns the predecessor of `self` (equivalent to `self - 1`):
  #
  #     1.pred  #=> 0
  #     -1.pred #=> -2
  #
  # Related: Integer#succ (successor value).
  #
  def pred: () -> Integer

  def quo: (Integer) -> Rational
         | (Float) -> Float
         | (Rational) -> Rational
         | (Complex) -> Complex
         | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - int.rationalize([eps])  ->  rational
  # -->
  # Returns the value as a rational.  The optional argument `eps` is always
  # ignored.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> self

  def real?: () -> true

  def rect: () -> [ Integer, Numeric ]

  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Examples:
  #
  #     11.remainder(4)              # => 3
  #     11.remainder(-4)             # => 3
  #     -11.remainder(4)             # => -3
  #     -11.remainder(-4)            # => -3
  #
  #     12.remainder(4)              # => 0
  #     12.remainder(-4)             # => 0
  #     -12.remainder(4)             # => 0
  #     -12.remainder(-4)            # => 0
  #
  #     13.remainder(4.0)            # => 1.0
  #     13.remainder(Rational(4, 1)) # => (1/1)
  #
  def remainder: (Integer) -> Integer
               | (Float) -> Float
               | (Rational) -> Rational
               | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits= 0, half: :up) -> integer
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.round(-1)      # => 560
  #     555.round(-2)      # => 600
  #     555.round(-3)      # => 1000
  #     -555.round(-2)     # => -600
  #     555.round(-4)      # => 0
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.round     # => 555
  #     555.round(1)  # => 555
  #     555.round(50) # => 555
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate  values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         25.round(-1, half: :up)      # => 30
  #         (-25).round(-1, half: :up)   # => -30
  #
  # *   `:down`: round toward zero:
  #
  #         25.round(-1, half: :down)    # => 20
  #         (-25).round(-1, half: :down) # => -20
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         25.round(-1, half: :even)    # => 20
  #         15.round(-1, half: :even)    # => 20
  #         (-25).round(-1, half: :even) # => -20
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Integer#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - size -> integer
  # -->
  # Returns the number of bytes in the machine representation of `self`; the value
  # is system-dependent:
  #
  #     1.size             # => 8
  #     -1.size            # => 8
  #     2147483647.size    # => 8
  #     (256**10 - 1).size # => 10
  #     (256**20 - 1).size # => 20
  #     (256**40 - 1).size # => 40
  #
  def size: () -> Integer

  def step: () { (Integer) -> void } -> void
          | (Numeric limit, ?Integer step) { (Integer) -> void } -> void
          | (Numeric limit, ?Numeric step) { (Numeric) -> void } -> void
          | (to: Numeric, ?by: Integer) { (Integer) -> void } -> void
          | (by: Numeric, ?to: Numeric) { (Numeric) -> void } -> void
          | () -> Enumerator[Integer, bot]
          | (Numeric limit, ?Integer step) -> Enumerator[Integer]
          | (Numeric limit, ?Numeric step) -> Enumerator[Numeric]
          | (to: Numeric, ?by: Integer) -> Enumerator[Integer]
          | (by: Numeric, ?to: Numeric) -> Enumerator[Numeric]

  # <!--
  #   rdoc-file=numeric.c
  #   - succ -> next_integer
  # -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Related: Integer#pred (predecessor value).
  #
  def succ: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - times {|i| ... } -> self
  #   - times            -> enumerator
  # -->
  # Calls the given block `self` times with each integer in `(0..self-1)`:
  #
  #     a = []
  #     5.times {|i| a.push(i) } # => 5
  #     a                        # => [0, 1, 2, 3, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def times: () { (Integer) -> void } -> self
           | () -> ::Enumerator[Integer, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_f -> float
  # -->
  # Converts `self` to a Float:
  #
  #     1.to_f  # => 1.0
  #     -1.to_f # => -1.0
  #
  # If the value of `self` does not fit in a Float, the result is infinity:
  #
  #     (10**400).to_f  # => Infinity
  #     (-10**400).to_f # => -Infinity
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - to_i -> self
  # -->
  # Returns `self` (which is already an Integer).
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - to_int -> self
  # -->
  # Returns `self` (which is already an Integer).
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - int.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     1.to_r        #=> (1/1)
  #     (1<<64).to_r  #=> (18446744073709551616/1)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s(base = 10)  ->  string
  # -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  def to_s: () -> String
          | (2) -> String
          | (3) -> String
          | (4) -> String
          | (5) -> String
          | (6) -> String
          | (7) -> String
          | (8) -> String
          | (9) -> String
          | (10) -> String
          | (11) -> String
          | (12) -> String
          | (13) -> String
          | (14) -> String
          | (15) -> String
          | (16) -> String
          | (17) -> String
          | (18) -> String
          | (19) -> String
          | (20) -> String
          | (21) -> String
          | (22) -> String
          | (23) -> String
          | (24) -> String
          | (25) -> String
          | (26) -> String
          | (27) -> String
          | (28) -> String
          | (29) -> String
          | (30) -> String
          | (31) -> String
          | (32) -> String
          | (33) -> String
          | (34) -> String
          | (35) -> String
          | (36) -> String
          | (int base) -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.truncate(-1)  # => 550
  #     555.truncate(-2)  # => 500
  #     -555.truncate(-2) # => -500
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.truncate     # => 555
  #     555.truncate(50) # => 555
  #
  # Related: Integer#round.
  #
  def truncate: () -> Integer
              | (int ndigits) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - upto(limit) {|i| ... } -> self
  #   - upto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` up to `limit`;
  # returns `self`:
  #
  #     a = []
  #     5.upto(10) {|i| a << i }              # => 5
  #     a                                     # => [5, 6, 7, 8, 9, 10]
  #     a = []
  #     -5.upto(0) {|i| a << i }              # => -5
  #     a                                     # => [-5, -4, -3, -2, -1, 0]
  #     5.upto(4) {|i| fail 'Cannot happen' } # => 5
  #
  # With no block given, returns an Enumerator.
  #
  def upto: (Numeric limit) { (Integer) -> void } -> Integer
          | (Numeric limit) -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=numeric.rb
  #   - zero? -> true or false
  # -->
  # Returns `true` if `self` has a zero value, `false` otherwise.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self | other -> integer
  # -->
  # Bitwise OR; each bit in the result is 1 if either corresponding bit in `self`
  # or `other` is 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 | 0b0110) # => "0111"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def |: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - ~int -> integer
  # -->
  # One's complement: returns the value of `self` with each bit inverted.
  #
  # Because an integer value is conceptually of infinite length, the result acts
  # as if it had an infinite number of one bits to the left. In hex
  # representations, this is displayed as two periods to the left of the digits:
  #
  #     sprintf("%X", ~0x1122334455)    # => "..FEEDDCCBBAA"
  #
  def ~: () -> Integer
end
# <!-- rdoc-file=object.c -->
# The class of the singleton object `nil`.
#
# Several of its methods act as operators:
#
# *   #&
# *   #|
# *   #===
# *   #=~
# *   #^
#
# Others act as converters, carrying the concept of *nullity* to other classes:
#
# *   #rationalize
# *   #to_a
# *   #to_c
# *   #to_h
# *   #to_r
# *   #to_s
#
# While `nil` doesn't have an explicitly defined #to_hash method, it can be used
# in `**` unpacking, not adding any keyword arguments.
#
# Another method provides inspection:
#
# *   #inspect
#
# Finally, there is this query method:
#
# *   #nil?
#
class NilClass
  def !: () -> true

  # <!--
  #   rdoc-file=object.c
  #   - false & object -> false
  #   - nil & object   -> false
  # -->
  # Returns `false`:
  #
  #     false & true       # => false
  #     false & Object.new # => false
  #
  # Argument `object` is evaluated:
  #
  #     false & raise # Raises RuntimeError.
  #
  def &: (untyped obj) -> false

  # <!--
  #   rdoc-file=object.c
  #   - true === other -> true or false
  #   - false === other -> true or false
  #   - nil === other -> true or false
  # -->
  # Returns `true` or `false`.
  #
  # Like Object#==, if `object` is an instance of Object (and not an instance of
  # one of its many subclasses).
  #
  # This method is commonly overridden by those subclasses, to provide meaningful
  # semantics in `case` statements.
  #
  def ===: (nil) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - nil =~ object -> nil
  # -->
  # Returns `nil`.
  #
  # This method makes it useful to write:
  #
  #     while gets =~ /re/
  #       # ...
  #     end
  #
  def =~: (untyped obj) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - false ^ object -> true or false
  #   - nil ^ object   -> true or false
  # -->
  # Returns `false` if `object` is `nil` or `false`, `true` otherwise:
  #
  #     nil ^ nil        # => false
  #     nil ^ false      # => false
  #     nil ^ Object.new # => true
  #
  def ^: (false | nil) -> false
       | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - inspect -> 'nil'
  # -->
  # Returns string `'nil'`:
  #
  #     nil.inspect # => "nil"
  #
  def inspect: () -> "nil"

  # <!--
  #   rdoc-file=object.c
  #   - nil.nil?  -> true
  # -->
  # Returns `true`. For all other objects, method `nil?` returns `false`.
  #
  def nil?: () -> true

  # <!--
  #   rdoc-file=rational.c
  #   - rationalize(eps = nil)  ->  (0/1)
  # -->
  # Returns zero as a Rational:
  #
  #     nil.rationalize # => (0/1)
  #
  # Argument `eps` is ignored.
  #
  def rationalize: (?untyped eps) -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - to_a -> []
  # -->
  # Returns an empty Array.
  #
  #     nil.to_a # => []
  #
  def to_a: () -> []

  # <!--
  #   rdoc-file=complex.c
  #   - to_c -> (0+0i)
  # -->
  # Returns zero as a Complex:
  #
  #     nil.to_c # => (0+0i)
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_f    -> 0.0
  # -->
  # Always returns zero.
  #
  #     nil.to_f   #=> 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=object.c
  #   - to_h -> {}
  # -->
  # Returns an empty Hash.
  #
  #     nil.to_h   #=> {}
  #
  def to_h: () -> {}

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_i -> 0
  # -->
  # Always returns zero.
  #
  #     nil.to_i   #=> 0
  #
  def to_i: () -> 0

  # <!--
  #   rdoc-file=rational.c
  #   - to_r  ->  (0/1)
  # -->
  # Returns zero as a Rational:
  #
  #     nil.to_r # => (0/1)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - to_s -> ''
  # -->
  # Returns an empty String:
  #
  #     nil.to_s # => ""
  #
  def to_s: () -> ""

  # <!--
  #   rdoc-file=object.c
  #   - false | object -> true or false
  #   - nil   | object -> true or false
  # -->
  # Returns `false` if `object` is `nil` or `false`, `true` otherwise:
  #
  #     nil | nil        # => false
  #     nil | false      # => false
  #     nil | Object.new # => true
  #
  def |: (nil | false) -> false
       | (untyped obj) -> bool
end
# <!-- rdoc-file=error.c -->
# Raised when the arguments are wrong and there isn't a more specific Exception
# class.
#
# Ex: passing the wrong number of arguments
#
#     [1, 2, 3].first(4, 5)
#
# *raises the exception:*
#
#     ArgumentError: wrong number of arguments (given 2, expected 1)
#
# Ex: passing an argument that is not acceptable:
#
#     [1, 2, 3].first(-4)
#
# *raises the exception:*
#
#     ArgumentError: negative array size
#
class ArgumentError < StandardError
end

# <!-- rdoc-file=thread_sync.c -->
# The exception class which will be raised when pushing into a closed Queue.
# See Thread::Queue#close and Thread::SizedQueue#close.
#
class ClosedQueueError < StopIteration
end

# <!-- rdoc-file=error.c -->
# EncodingError is the base class for encoding errors.
#
class EncodingError < StandardError
end

# <!-- rdoc-file=io.c -->
# Raised by some IO operations when reaching the end of file. Many IO methods
# exist in two forms,
#
# one that returns `nil` when the end of file is reached, the other raises
# EOFError.
#
# EOFError is a subclass of IOError.
#
#     file = File.open("/etc/hosts")
#     file.read
#     file.gets     #=> nil
#     file.readline #=> EOFError: end of file reached
#     file.close
#
class EOFError < IOError
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to convert special float values (in particular
# `Infinity` or `NaN`) to numerical classes which don't support them.
#
#     Float::INFINITY.to_r   #=> FloatDomainError: Infinity
#
class FloatDomainError < RangeError
end

# <!-- rdoc-file=error.c -->
# Raised when there is an attempt to modify a frozen object.
#
#     [1, 2, 3].freeze << 4
#
# *raises the exception:*
#
#     FrozenError: can't modify frozen Array
#
class FrozenError[T] < RuntimeError
  # <!--
  #   rdoc-file=error.c
  #   - FrozenError.new(msg=nil, receiver: nil)  -> frozen_error
  # -->
  # Construct a new FrozenError exception. If given the *receiver* parameter may
  # subsequently be examined using the FrozenError#receiver method.
  #
  #     a = [].freeze
  #     raise FrozenError.new("can't modify frozen array", receiver: a)
  #
  def initialize: (?string? msg, ?receiver: T?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - frozen_error.receiver  -> object
  # -->
  # Return the receiver associated with this FrozenError exception.
  #
  def receiver: () -> T?
end

# <!-- rdoc-file=error.c -->
# Raised when the given index is invalid.
#
#     a = [:foo, :bar]
#     a.fetch(0)   #=> :foo
#     a[4]         #=> nil
#     a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2
#
class IndexError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the interrupt signal is received, typically because the user has
# pressed Control-C (on most posix platforms). As such, it is a subclass of
# `SignalException`.
#
#     begin
#       puts "Press ctrl-C when you get bored"
#       loop {}
#     rescue Interrupt => e
#       puts "Note: You will typically use Signal.trap instead."
#     end
#
# *produces:*
#
#     Press ctrl-C when you get bored
#
# *then waits until it is interrupted with Control-C and then prints:*
#
#     Note: You will typically use Signal.trap instead.
#
class Interrupt < SignalException
  def initialize: (?string) -> void
end

# <!-- rdoc-file=io.c -->
# Raised when an IO operation fails.
#
#     File.open("/etc/hosts") {|f| f << "example"}
#       #=> IOError: not opened for writing
#
#     File.open("/etc/hosts") {|f| f.close; f.read }
#       #=> IOError: closed stream
#
# Note that some IO failures raise `SystemCallError`s and these are not
# subclasses of IOError:
#
#     File.open("does/not/exist")
#       #=> Errno::ENOENT: No such file or directory - does/not/exist
#
class IOError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the specified key is not found. It is a subclass of IndexError.
#
#     h = {"foo" => :bar}
#     h.fetch("foo") #=> :bar
#     h.fetch("baz") #=> KeyError: key not found: "baz"
#
class KeyError[K, R] < IndexError
  # <!--
  #   rdoc-file=error.c
  #   - KeyError.new(message=nil, receiver: nil, key: nil) -> key_error
  # -->
  # Construct a new `KeyError` exception with the given message, receiver and key.
  #
  def initialize: (?string msg, ?receiver: R?, ?key: K?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - key_error.key  -> object
  # -->
  # Return the key caused this KeyError exception.
  #
  def key: () -> K?

  # <!--
  #   rdoc-file=error.c
  #   - key_error.receiver  -> object
  # -->
  # Return the receiver associated with this KeyError exception.
  #
  def receiver: () -> R?
end

# <!-- rdoc-file=error.c -->
# Raised when a file required (a Ruby script, extension library, ...) fails to
# load.
#
#     require 'this/file/does/not/exist'
#
# *raises the exception:*
#
#     LoadError: no such file to load -- this/file/does/not/exist
#
# <!-- rdoc-file=lib/bundled_gems.rb -->
# for RubyGems without Bundler environment. If loading library is not part of
# the default gems and the bundled gems, warn it.
#
class LoadError < ScriptError
  # <!-- rdoc-file=error.c -->
  # the path that failed to load
  #
  def path: () -> String?
end

# <!-- rdoc-file=proc.c -->
# Raised when Ruby can't yield as requested.
#
# A typical scenario is attempting to yield when no block is given:
#
#     def call_block
#       yield 42
#     end
#     call_block
#
# *raises the exception:*
#
#     LocalJumpError: no block given (yield)
#
# A more subtle example:
#
#     def get_me_a_return
#       Proc.new { return 42 }
#     end
#     get_me_a_return.call
#
# *raises the exception:*
#
#     LocalJumpError: unexpected return
#
class LocalJumpError < StandardError
  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.exit_value  -> obj
  # -->
  # Returns the exit value associated with this `LocalJumpError`.
  #
  def exit_value: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.reason   -> symbol
  # -->
  # The reason this block was terminated: :break, :redo, :retry, :next, :return,
  # or :noreason.
  #
  def reason: () -> Symbol
end

# <!-- rdoc-file=error.c -->
# Raised when a given name is invalid or undefined.
#
#     puts foo
#
# *raises the exception:*
#
#     NameError: undefined local variable or method `foo' for main:Object
#
# Since constant names must start with a capital:
#
#     Integer.const_set :answer, 42
#
# *raises the exception:*
#
#     NameError: wrong constant name answer
#
class NameError[T] < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - NameError.new(msg=nil, name=nil, receiver: nil)  -> name_error
  # -->
  # Construct a new NameError exception. If given the *name* parameter may
  # subsequently be examined using the NameError#name method. *receiver* parameter
  # allows to pass object in context of which the error happened. Example:
  #
  #     [1, 2, 3].method(:rject) # NameError with name "rject" and receiver: Array
  #     [1, 2, 3].singleton_method(:rject) # NameError with name "rject" and receiver: [1, 2, 3]
  #
  def initialize: (?string msg, ?String? name, ?receiver: T?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - name_error.local_variables  ->  array
  # -->
  # Return a list of the local variable names defined where this NameError
  # exception was raised.
  #
  # Internal use only.
  #
  def local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=error.c
  #   - name_error.name    ->  string or nil
  # -->
  # Return the name associated with this NameError exception.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=error.c
  #   - name_error.receiver  -> object
  # -->
  # Return the receiver associated with this NameError exception.
  #
  def receiver: () -> T?
end

class NoMatchingPatternError < StandardError
end

class NoMatchingPatternKeyError[M, K] < NoMatchingPatternError
  # <!--
  #   rdoc-file=error.c
  #   - NoMatchingPatternKeyError.new(message=nil, matchee: nil, key: nil) -> no_matching_pattern_key_error
  # -->
  # Construct a new `NoMatchingPatternKeyError` exception with the given message,
  # matchee and key.
  #
  def initialize: (?string message, matchee: M, key: K) -> void

  # <!--
  #   rdoc-file=error.c
  #   - no_matching_pattern_key_error.matchee  -> object
  # -->
  # Return the matchee associated with this NoMatchingPatternKeyError exception.
  #
  def matchee: () -> M

  # <!--
  #   rdoc-file=error.c
  #   - no_matching_pattern_key_error.key  -> object
  # -->
  # Return the key caused this NoMatchingPatternKeyError exception.
  #
  def key: () -> K
end

# <!-- rdoc-file=error.c -->
# Raised when memory allocation fails.
#
class NoMemoryError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a method is called on a receiver which doesn't have it defined and
# also fails to respond with `method_missing`.
#
#     "hello".to_ary
#
# *raises the exception:*
#
#     NoMethodError: undefined method `to_ary' for an instance of String
#
class NoMethodError[T] < NameError[T]
  # <!--
  #   rdoc-file=error.c
  #   - NoMethodError.new(msg=nil, name=nil, args=nil, private=false, receiver: nil)  -> no_method_error
  # -->
  # Construct a NoMethodError exception for a method of the given name called with
  # the given arguments. The name may be accessed using the `#name` method on the
  # resulting object, and the arguments using the `#args` method.
  #
  # If *private* argument were passed, it designates method was attempted to call
  # in private context, and can be accessed with `#private_call?` method.
  #
  # *receiver* argument stores an object whose method was called.
  #
  def initialize: (?string? msg, ?String? name, ?Array[untyped] args, ?boolish `private`, ?receiver: T?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.args  -> obj
  # -->
  # Return the arguments passed in as the third parameter to the constructor.
  #
  def args: () -> Array[untyped]

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.private_call?  -> true or false
  # -->
  # Return true if the caused method was called as private.
  #
  def private_call?: () -> bool
end

# <!-- rdoc-file=error.c -->
# Raised when a feature is not implemented on the current platform. For example,
# methods depending on the `fsync` or `fork` system calls may raise this
# exception if the underlying operating system or Ruby runtime does not support
# them.
#
# Note that if `fork` raises a `NotImplementedError`, then `respond_to?(:fork)`
# returns `false`.
#
class NotImplementedError < ScriptError
end

# <!-- rdoc-file=error.c -->
# Raised when a given numerical value is out of range.
#
#     [1, 2, 3].drop(1 << 100)
#
# *raises the exception:*
#
#     RangeError: bignum too big to convert into `long'
#
class RangeError < StandardError
end

# <!-- rdoc-file=re.c -->
# Raised when given an invalid regexp expression.
#
#     Regexp.new("?")
#
# *raises the exception:*
#
#     RegexpError: target of repeat operator is not specified: /?/
#
class RegexpError < StandardError
end

# <!-- rdoc-file=error.c -->
# A generic error class raised when an invalid operation is attempted.
# Kernel#raise will raise a RuntimeError if no Exception class is specified.
#
#     raise "ouch"
#
# *raises the exception:*
#
#     RuntimeError: ouch
#
class RuntimeError < StandardError
end

# <!-- rdoc-file=error.c -->
# ScriptError is the superclass for errors raised when a script can not be
# executed because of a `LoadError`, `NotImplementedError` or a `SyntaxError`.
# Note these type of `ScriptErrors` are not `StandardError` and will not be
# rescued unless it is specified explicitly (or its ancestor `Exception`).
#
class ScriptError < Exception
end

# <!-- rdoc-file=error.c -->
# No longer used by internal code.
#
class SecurityError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a signal is received.
#
#     begin
#       Process.kill('HUP',Process.pid)
#       sleep # wait for receiver to handle signal sent by Process.kill
#     rescue SignalException => e
#       puts "received Exception #{e}"
#     end
#
# *produces:*
#
#     received Exception SIGHUP
#
class SignalException < Exception
  # <!--
  #   rdoc-file=signal.c
  #   - SignalException.new(sig_name)              ->  signal_exception
  #   - SignalException.new(sig_number [, name])   ->  signal_exception
  # -->
  # Construct a new SignalException object.  `sig_name` should be a known signal
  # name.
  #
  def initialize: (?string sig_name) -> void
                | (int sig_number, ?string sig_name) -> void

  def signm: () -> String

  # <!--
  #   rdoc-file=signal.c
  #   - signal_exception.signo   ->  num
  # -->
  # Returns a signal number.
  #
  def signo: () -> Integer
end

# <!-- rdoc-file=error.c -->
# The most standard error types are subclasses of StandardError. A rescue clause
# without an explicit Exception class will rescue all StandardErrors (and only
# those).
#
#     def foo
#       raise "Oups"
#     end
#     foo rescue "Hello"   #=> "Hello"
#
# On the other hand:
#
#     require 'does/not/exist' rescue "Hi"
#
# *raises the exception:*
#
#     LoadError: no such file to load -- does/not/exist
#
class StandardError < Exception
end

# <!-- rdoc-file=enumerator.c -->
# Raised to stop the iteration, in particular by Enumerator#next. It is rescued
# by Kernel#loop.
#
#     loop do
#       puts "Hello"
#       raise StopIteration
#       puts "World"
#     end
#     puts "Done!"
#
# *produces:*
#
#     Hello
#     Done!
#
class StopIteration < IndexError
  # <!--
  #   rdoc-file=enumerator.c
  #   - result       -> value
  # -->
  # Returns the return value of the iterator.
  #
  #     o = Object.new
  #     def o.each
  #       yield 1
  #       yield 2
  #       yield 3
  #       100
  #     end
  #
  #     e = o.to_enum
  #
  #     puts e.next                   #=> 1
  #     puts e.next                   #=> 2
  #     puts e.next                   #=> 3
  #
  #     begin
  #       e.next
  #     rescue StopIteration => ex
  #       puts ex.result              #=> 100
  #     end
  #
  def result: () -> untyped
end

# <!-- rdoc-file=error.c -->
# Raised when encountering Ruby code with an invalid syntax.
#
#     eval("1+1=2")
#
# *raises the exception:*
#
#     SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end
#
class SyntaxError < ScriptError
  # <!--
  #   rdoc-file=error.c
  #   - SyntaxError.new([msg])  -> syntax_error
  # -->
  # Construct a SyntaxError exception.
  #
  def initialize: (?string msg) -> void

  # <!-- rdoc-file=error.c -->
  # the path that failed to parse
  #
  def path: () -> String?
end

# <!-- rdoc-file=error.c -->
# SystemCallError is the base class for all low-level platform-dependent errors.
#
# The errors available on the current platform are subclasses of SystemCallError
# and are defined in the Errno module.
#
#     File.open("does/not/exist")
#
# *raises the exception:*
#
#     Errno::ENOENT: No such file or directory - does/not/exist
#
class SystemCallError < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - SystemCallError.new(msg, errno)  -> system_call_error_subclass
  # -->
  # If *errno* corresponds to a known system error code, constructs the
  # appropriate Errno class for that error, otherwise constructs a generic
  # SystemCallError object. The error number is subsequently available via the
  # #errno method.
  #
  def initialize: (string msg, Integer errno) -> void

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error === other  -> true or false
  # -->
  # Return `true` if the receiver is a generic `SystemCallError`, or if the error
  # numbers `self` and *other* are the same.
  #
  def self.===: (untyped other) -> bool

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error.errno   -> integer
  # -->
  # Return this SystemCallError's error number.
  #
  def errno: () -> Integer
end

# <!-- rdoc-file=error.c -->
# Raised by `exit` to initiate the termination of the script.
#
class SystemExit < Exception
  # <!--
  #   rdoc-file=error.c
  #   - SystemExit.new              -> system_exit
  #   - SystemExit.new(status)      -> system_exit
  #   - SystemExit.new(status, msg) -> system_exit
  #   - SystemExit.new(msg)         -> system_exit
  # -->
  # Create a new `SystemExit` exception with the given status and message. Status
  # is true, false, or an integer. If status is not given, true is used.
  #
  def initialize: () -> void
                | (string msg) -> void
                | (true | false | int status, ?string msg) -> void

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.status   -> integer
  # -->
  # Return the status value associated with this system exit.
  #
  def status: () -> Integer

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.success?  -> true or false
  # -->
  # Returns `true` if exiting successful, `false` if not.
  #
  def success?: () -> bool
end

# <!-- rdoc-file=proc.c -->
# Raised in case of a stack overflow.
#
#     def me_myself_and_i
#       me_myself_and_i
#     end
#     me_myself_and_i
#
# *raises the exception:*
#
#     SystemStackError: stack level too deep
#
class SystemStackError < Exception
end

# <!-- rdoc-file=thread.c -->
# Raised when an invalid operation is attempted on a thread.
#
# For example, when no other thread has been started:
#
#     Thread.stop
#
# This will raises the following exception:
#
#     ThreadError: stopping only thread
#     note: use sleep to stop forever
#
class ThreadError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when encountering an object that is not of the expected type.
#
#     [1, 2, 3].first("two")
#
# *raises the exception:*
#
#     TypeError: no implicit conversion of String into Integer
#
class TypeError < StandardError
end

# <!-- rdoc-file=vm_eval.c -->
# Raised when `throw` is called with a *tag* which does not have corresponding
# `catch` block.
#
#     throw "foo", "bar"
#
# *raises the exception:*
#
#     UncaughtThrowError: uncaught throw "foo"
#
class UncaughtThrowError < ArgumentError
  # <!--
  #   rdoc-file=vm_eval.c
  #   - new(*args)
  # -->
  # Document-class: UncaughtThrowError
  #
  # Raised when `throw` is called with a *tag* which does not have corresponding
  # `catch` block.
  #
  #     throw "foo", "bar"
  #
  # *raises the exception:*
  #
  #     UncaughtThrowError: uncaught throw "foo"
  #
  def initialize: (untyped tag, untyped value) -> void

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.tag   -> obj
  # -->
  # Return the tag object which was called for.
  #
  def tag: () -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.to_s   ->  string
  # -->
  # Returns formatted message with the inspected tag.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.value   -> obj
  # -->
  # Return the return value which was called for.
  #
  def value: () -> untyped
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to divide an integer by 0.
#
#     42 / 0   #=> ZeroDivisionError: divided by 0
#
# Note that only division by an exact 0 will raise the exception:
#
#     42 /  0.0   #=> Float::INFINITY
#     42 / -0.0   #=> -Float::INFINITY
#     0  /  0.0   #=> NaN
#
class ZeroDivisionError < StandardError
end
# <!-- rdoc-file=cont.c -->
# Raised when an invalid operation is attempted on a Fiber, in particular when
# attempting to call/resume a dead fiber, attempting to yield from the root
# fiber, or calling a fiber across threads.
#
#     fiber = Fiber.new{}
#     fiber.resume #=> nil
#     fiber.resume #=> FiberError: dead fiber called
#
class FiberError < StandardError
end
# <!-- rdoc-file=vm.c -->
# Threads are the Ruby implementation for a concurrent programming model.
#
# Programs that require multiple threads of execution are a perfect candidate
# for Ruby's Thread class.
#
# For example, we can create a new thread separate from the main thread's
# execution using ::new.
#
#     thr = Thread.new { puts "What's the big deal" }
#
# Then we are able to pause the execution of the main thread and allow our new
# thread to finish, using #join:
#
#     thr.join #=> "What's the big deal"
#
# If we don't call `thr.join` before the main thread terminates, then all other
# threads including `thr` will be killed.
#
# Alternatively, you can use an array for handling multiple threads at once,
# like in the following example:
#
#     threads = []
#     threads << Thread.new { puts "What's the big deal" }
#     threads << Thread.new { 3.times { puts "Threads are fun!" } }
#
# After creating a few threads we wait for them all to finish consecutively.
#
#     threads.each { |thr| thr.join }
#
# To retrieve the last value of a thread, use #value
#
#     thr = Thread.new { sleep 1; "Useful value" }
#     thr.value #=> "Useful value"
#
# ### Thread initialization
#
# In order to create new threads, Ruby provides ::new, ::start, and ::fork. A
# block must be provided with each of these methods, otherwise a ThreadError
# will be raised.
#
# When subclassing the Thread class, the `initialize` method of your subclass
# will be ignored by ::start and ::fork. Otherwise, be sure to call super in
# your `initialize` method.
#
# ### Thread termination
#
# For terminating threads, Ruby provides a variety of ways to do this.
#
# The class method ::kill, is meant to exit a given thread:
#
#     thr = Thread.new { sleep }
#     Thread.kill(thr) # sends exit() to thr
#
# Alternatively, you can use the instance method #exit, or any of its aliases
# #kill or #terminate.
#
#     thr.exit
#
# ### Thread status
#
# Ruby provides a few instance methods for querying the state of a given thread.
# To get a string with the current thread's state use #status
#
#     thr = Thread.new { sleep }
#     thr.status # => "sleep"
#     thr.exit
#     thr.status # => false
#
# You can also use #alive? to tell if the thread is running or sleeping, and
# #stop? if the thread is dead or sleeping.
#
# ### Thread variables and scope
#
# Since threads are created with blocks, the same rules apply to other Ruby
# blocks for variable scope. Any local variables created within this block are
# accessible to only this thread.
#
# #### Fiber-local vs. Thread-local
#
# Each fiber has its own bucket for Thread#[] storage. When you set a new
# fiber-local it is only accessible within this Fiber. To illustrate:
#
#     Thread.new {
#       Thread.current[:foo] = "bar"
#       Fiber.new {
#         p Thread.current[:foo] # => nil
#       }.resume
#     }.join
#
# This example uses #[] for getting and #[]= for setting fiber-locals, you can
# also use #keys to list the fiber-locals for a given thread and #key? to check
# if a fiber-local exists.
#
# When it comes to thread-locals, they are accessible within the entire scope of
# the thread. Given the following example:
#
#     Thread.new{
#       Thread.current.thread_variable_set(:foo, 1)
#       p Thread.current.thread_variable_get(:foo) # => 1
#       Fiber.new{
#         Thread.current.thread_variable_set(:foo, 2)
#         p Thread.current.thread_variable_get(:foo) # => 2
#       }.resume
#       p Thread.current.thread_variable_get(:foo)   # => 2
#     }.join
#
# You can see that the thread-local `:foo` carried over into the fiber and was
# changed to `2` by the end of the thread.
#
# This example makes use of #thread_variable_set to create new thread-locals,
# and #thread_variable_get to reference them.
#
# There is also #thread_variables to list all thread-locals, and
# #thread_variable? to check if a given thread-local exists.
#
# ### Exception handling
#
# When an unhandled exception is raised inside a thread, it will terminate. By
# default, this exception will not propagate to other threads. The exception is
# stored and when another thread calls #value or #join, the exception will be
# re-raised in that thread.
#
#     t = Thread.new{ raise 'something went wrong' }
#     t.value #=> RuntimeError: something went wrong
#
# An exception can be raised from outside the thread using the Thread#raise
# instance method, which takes the same parameters as Kernel#raise.
#
# Setting Thread.abort_on_exception = true, Thread#abort_on_exception = true, or
# $DEBUG = true will cause a subsequent unhandled exception raised in a thread
# to be automatically re-raised in the main thread.
#
# With the addition of the class method ::handle_interrupt, you can now handle
# exceptions asynchronously with threads.
#
# ### Scheduling
#
# Ruby provides a few ways to support scheduling threads in your program.
#
# The first way is by using the class method ::stop, to put the current running
# thread to sleep and schedule the execution of another thread.
#
# Once a thread is asleep, you can use the instance method #wakeup to mark your
# thread as eligible for scheduling.
#
# You can also try ::pass, which attempts to pass execution to another thread
# but is dependent on the OS whether a running thread will switch or not. The
# same goes for #priority, which lets you hint to the thread scheduler which
# threads you want to take precedence when passing execution. This method is
# also dependent on the OS and may be ignored on some platforms.
#
class Thread < Object
  # <!--
  #   rdoc-file=thread.c
  #   - Thread.current   -> thread
  # -->
  # Returns the currently executing thread.
  #
  #     Thread.current   #=> #<Thread:0x401bdf4c run>
  #
  def self.current: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.main   -> thread
  # -->
  # Returns the main thread.
  #
  def self.main: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym]   -> obj or nil
  # -->
  # Attribute Reference---Returns the value of a fiber-local variable (current
  # thread's root fiber if not explicitly inside a Fiber), using either a symbol
  # or a string name. If the specified variable does not exist, returns `nil`.
  #
  #     [
  #       Thread.new { Thread.current["name"] = "A" },
  #       Thread.new { Thread.current[:name]  = "B" },
  #       Thread.new { Thread.current["name"] = "C" }
  #     ].each do |th|
  #       th.join
  #       puts "#{th.inspect}: #{th[:name]}"
  #     end
  #
  # This will produce:
  #
  #     #<Thread:0x00000002a54220 dead>: A
  #     #<Thread:0x00000002a541a8 dead>: B
  #     #<Thread:0x00000002a54130 dead>: C
  #
  # Thread#[] and Thread#[]= are not thread-local but fiber-local. This confusion
  # did not exist in Ruby 1.8 because fibers are only available since Ruby 1.9.
  # Ruby 1.9 chooses that the methods behaves fiber-local to save following idiom
  # for dynamic scope.
  #
  #     def meth(newvalue)
  #       begin
  #         oldvalue = Thread.current[:name]
  #         Thread.current[:name] = newvalue
  #         yield
  #       ensure
  #         Thread.current[:name] = oldvalue
  #       end
  #     end
  #
  # The idiom may not work as dynamic scope if the methods are thread-local and a
  # given block switches fiber.
  #
  #     f = Fiber.new {
  #       meth(1) {
  #         Fiber.yield
  #       }
  #     }
  #     meth(2) {
  #       f.resume
  #     }
  #     f.resume
  #     p Thread.current[:name]
  #     #=> nil if fiber-local
  #     #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)
  #
  # For thread-local variables, please see #thread_variable_get and
  # #thread_variable_set.
  #
  def []: (interned key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym] = obj   -> obj
  # -->
  # Attribute Assignment---Sets or creates the value of a fiber-local variable,
  # using either a symbol or a string.
  #
  # See also Thread#[].
  #
  # For thread-local variables, please see #thread_variable_set and
  # #thread_variable_get.
  #
  def []=: (interned key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.alive?   -> true or false
  # -->
  # Returns `true` if `thr` is running or sleeping.
  #
  #     thr = Thread.new { }
  #     thr.join                #=> #<Thread:0x401b3fb0 dead>
  #     Thread.current.alive?   #=> true
  #     thr.alive?              #=> false
  #
  # See also #stop? and #status.
  #
  def alive?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.exit        -> thr
  #   - thr.kill        -> thr
  #   - thr.terminate   -> thr
  # -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def kill: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``abort on exception'' condition for
  # this `thr`.
  #
  # The default is `false`.
  #
  # See also #abort_on_exception=.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception.
  #
  def abort_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if this `thr` is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # See also #abort_on_exception.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception=.
  #
  def abort_on_exception=: (boolish abort_on_exception) -> untyped

  # <!--
  #   rdoc-file=vm_trace.c
  #   - thr.add_trace_func(proc)    -> proc
  # -->
  # Adds *proc* as a handler for tracing.
  #
  # See Thread#set_trace_func and Kernel#set_trace_func.
  #
  def add_trace_func: (untyped proc) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace    -> array or nil
  # -->
  # Returns the current backtrace of the target thread.
  #
  def backtrace: (*untyped args) -> ::Array[untyped]

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace_locations(*args)   -> array or nil
  # -->
  # Returns the execution stack for the target thread---an array containing
  # backtrace location objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # This method behaves similarly to Kernel#caller_locations except it applies to
  # a specific thread.
  #
  def backtrace_locations: (*untyped args) -> ::Array[untyped]?

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def exit: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.fetch(sym)           -> obj
  #   - thr.fetch(sym) { }       -> obj
  #   - thr.fetch(sym, default)  -> obj
  # -->
  # Returns a fiber-local for the given key. If the key can't be found, there are
  # several options: With no other arguments, it will raise a KeyError exception;
  # if *default* is given, then that will be returned; if the optional code block
  # is specified, then that will be run and its result returned.  See Thread#[]
  # and Hash#fetch.
  #
  def fetch: (*untyped sym) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.group   -> thgrp or nil
  # -->
  # Returns the ThreadGroup which contains the given thread.
  #
  #     Thread.main.group   #=> #<ThreadGroup:0x4029d914>
  #
  def group: () -> ThreadGroup?

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.new { ... }                  -> thread
  #   - Thread.new(*args, &proc)            -> thread
  #   - Thread.new(*args) { |args| ... }    -> thread
  # -->
  # Creates a new thread executing the given block.
  #
  # Any `args` given to ::new will be passed to the block:
  #
  #     arr = []
  #     a, b, c = 1, 2, 3
  #     Thread.new(a,b,c) { |d,e,f| arr << d << e << f }.join
  #     arr #=> [1, 2, 3]
  #
  # A ThreadError exception is raised if ::new is called without a block.
  #
  # If you're going to subclass Thread, be sure to call super in your `initialize`
  # method, otherwise a ThreadError will be raised.
  #
  def initialize: (*untyped) { (?) -> void } -> void

  # <!--
  #   rdoc-file=thread.c
  #   - thr.join          -> thr
  #   - thr.join(limit)   -> thr
  # -->
  # The calling thread will suspend execution and run this `thr`.
  #
  # Does not return until `thr` exits or until the given `limit` seconds have
  # passed.
  #
  # If the time limit expires, `nil` will be returned, otherwise `thr` is
  # returned.
  #
  # Any threads not joined will be killed when the main program exits.
  #
  # If `thr` had previously raised an exception and the ::abort_on_exception or
  # $DEBUG flags are not set, (so the exception has not yet been processed), it
  # will be processed at this time.
  #
  #     a = Thread.new { print "a"; sleep(10); print "b"; print "c" }
  #     x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }
  #     x.join # Let thread x finish, thread a will be killed on exit.
  #     #=> "axyz"
  #
  # The following example illustrates the `limit` parameter.
  #
  #     y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}
  #     puts "Waiting" until y.join(0.15)
  #
  # This will produce:
  #
  #     tick...
  #     Waiting
  #     tick...
  #     Waiting
  #     tick...
  #     tick...
  #
  def join: (*untyped limit) -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr.key?(sym)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a fiber-local
  # variable.
  #
  #     me = Thread.current
  #     me[:oliver] = "a"
  #     me.key?(:oliver)    #=> true
  #     me.key?(:stanley)   #=> false
  #
  def key?: (Symbol sym) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.keys   -> array
  # -->
  # Returns an array of the names of the fiber-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current[:cat] = 'meow'
  #       Thread.current["dog"] = 'woof'
  #     end
  #     thr.join   #=> #<Thread:0x401b3f10 dead>
  #     thr.keys   #=> [:dog, :cat]
  #
  def keys: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name   -> string
  # -->
  # show the name of the thread.
  #
  def name: () -> String

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name=(name)   -> string
  # -->
  # set given name to the ruby thread. On some platform, it may set the name to
  # pthread and/or kernel.
  #
  def name=: (untyped name) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.native_thread_id   -> integer
  # -->
  # Return the native thread ID which is used by the Ruby thread.
  #
  # The ID depends on the OS. (not POSIX thread ID returned by pthread_self(3))
  # *   On Linux it is TID returned by gettid(2).
  # *   On macOS it is the system-wide unique integral ID of thread returned by
  #     pthread_threadid_np(3).
  # *   On FreeBSD it is the unique integral ID of the thread returned by
  #     pthread_getthreadid_np(3).
  # *   On Windows it is the thread identifier returned by GetThreadId().
  # *   On other platforms, it raises NotImplementedError.
  #
  # NOTE: If the thread is not associated yet or already deassociated with a
  # native thread, it returns *nil*. If the Ruby implementation uses M:N thread
  # model, the ID may change depending on the timing.
  #
  def native_thread_id: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - target_thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty for the target thread.
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # See ::pending_interrupt? for more information.
  #
  def pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority   -> integer
  # -->
  # Returns the priority of *thr*. Default is inherited from the current thread
  # which creating the new thread, or zero for the initial main thread;
  # higher-priority thread will run more frequently than lower-priority threads
  # (but lower-priority threads can also run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     Thread.current.priority   #=> 0
  #
  def priority: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority= integer   -> thr
  # -->
  # Sets the priority of *thr* to *integer*. Higher-priority threads will run more
  # frequently than lower-priority threads (but lower-priority threads can also
  # run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     count1 = count2 = 0
  #     a = Thread.new do
  #           loop { count1 += 1 }
  #         end
  #     a.priority = -1
  #
  #     b = Thread.new do
  #           loop { count2 += 1 }
  #         end
  #     b.priority = -2
  #     sleep 1   #=> 1
  #     count1    #=> 622504
  #     count2    #=> 5832
  #
  def priority=: (Integer priority) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``report on exception'' condition for
  # this `thr`.
  #
  # The default value when creating a Thread is the value of the global flag
  # Thread.report_on_exception.
  #
  # See also #report_on_exception=.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, a message is printed on $stderr if an exception kills this
  # `thr`.  See ::report_on_exception for details.
  #
  # See also #report_on_exception.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception=: (boolish report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.run   -> thr
  # -->
  # Wakes up `thr`, making it eligible for scheduling.
  #
  #     a = Thread.new { puts "a"; Thread.stop; puts "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     puts "Got here"
  #     a.run
  #     a.join
  #
  # This will produce:
  #
  #     a
  #     Got here
  #     c
  #
  # See also the instance method #wakeup.
  #
  def run: () -> Thread

  # Returns the safe level.
  #
  # This method is obsolete because $SAFE is a process global state. Simply
  # check $SAFE.
  def safe_level: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.status   -> string, false or nil
  # -->
  # Returns the status of `thr`.
  #
  # `"sleep"`
  # :   Returned if this thread is sleeping or waiting on I/O
  #
  # `"run"`
  # :   When this thread is executing
  #
  # `"aborting"`
  # :   If this thread is aborting
  #
  # `false`
  # :   When this thread is terminated normally
  #
  # `nil`
  # :   If terminated with an exception.
  #
  #
  #     a = Thread.new { raise("die now") }
  #     b = Thread.new { Thread.stop }
  #     c = Thread.new { Thread.exit }
  #     d = Thread.new { sleep }
  #     d.kill                  #=> #<Thread:0x401b3678 aborting>
  #     a.status                #=> nil
  #     b.status                #=> "sleep"
  #     c.status                #=> false
  #     d.status                #=> "aborting"
  #     Thread.current.status   #=> "run"
  #
  # See also the instance methods #alive? and #stop?
  #
  def status: () -> (String | bool)?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.stop?   -> true or false
  # -->
  # Returns `true` if `thr` is dead or sleeping.
  #
  #     a = Thread.new { Thread.stop }
  #     b = Thread.current
  #     a.stop?   #=> true
  #     b.stop?   #=> false
  #
  # See also #alive? and #status.
  #
  def stop?: () -> bool

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def terminate: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable?(key)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a thread-local
  # variable.
  #
  #     me = Thread.current
  #     me.thread_variable_set(:oliver, "a")
  #     me.thread_variable?(:oliver)    #=> true
  #     me.thread_variable?(:stanley)   #=> false
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variable?: (interned key) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_get(key)  -> obj or nil
  # -->
  # Returns the value of a thread local variable that has been set.  Note that
  # these are different than fiber local values.  For fiber local values, please
  # see Thread#[] and Thread#[]=.
  #
  # Thread local values are carried along with threads, and do not respect fibers.
  #  For example:
  #
  #     Thread.new {
  #       Thread.current.thread_variable_set("foo", "bar") # set a thread local
  #       Thread.current["foo"] = "bar"                    # set a fiber local
  #
  #       Fiber.new {
  #         Fiber.yield [
  #           Thread.current.thread_variable_get("foo"), # get the thread local
  #           Thread.current["foo"],                     # get the fiber local
  #         ]
  #       }.resume
  #     }.join.value # => ['bar', nil]
  #
  # The value "bar" is returned for the thread local, where nil is returned for
  # the fiber local.  The fiber is executed in the same thread, so the thread
  # local values are available.
  #
  def thread_variable_get: (untyped key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_set(key, value)
  # -->
  # Sets a thread local with `key` to `value`.  Note that these are local to
  # threads, and not to fibers.  Please see Thread#thread_variable_get and
  # Thread#[] for more information.
  #
  def thread_variable_set: (untyped key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variables   -> array
  # -->
  # Returns an array of the names of the thread-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current.thread_variable_set(:cat, 'meow')
  #       Thread.current.thread_variable_set("dog", 'woof')
  #     end
  #     thr.join               #=> #<Thread:0x401b3f10 dead>
  #     thr.thread_variables   #=> [:dog, :cat]
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.value   -> obj
  # -->
  # Waits for `thr` to complete, using #join, and returns its value or raises the
  # exception which terminated the thread.
  #
  #     a = Thread.new { 2 + 2 }
  #     a.value   #=> 4
  #
  #     b = Thread.new { raise 'something went wrong' }
  #     b.value   #=> RuntimeError: something went wrong
  #
  def value: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.wakeup   -> thr
  # -->
  # Marks a given thread as eligible for scheduling, however it may still remain
  # blocked on I/O.
  #
  # **Note:** This does not invoke the scheduler, see #run for more information.
  #
  #     c = Thread.new { Thread.stop; puts "hey!" }
  #     sleep 0.1 while c.status!='sleep'
  #     c.wakeup
  #     c.join
  #     #=> "hey!"
  #
  def wakeup: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception   -> true or false
  # -->
  # Returns the status of the global ``abort on exception'' condition.
  #
  # The default is `false`.
  #
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # Can also be specified by the global $DEBUG flag or command line option `-d`.
  #
  # See also ::abort_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception.
  #
  def self.abort_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread. Returns the new state.
  #
  #     Thread.abort_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "not reached"
  #
  # This will produce:
  #
  #     In new thread
  #     prog.rb:4: Exception from thread (RuntimeError)
  #      from prog.rb:2:in `initialize'
  #      from prog.rb:2:in `new'
  #      from prog.rb:2
  #
  # See also ::abort_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception=.
  #
  def self.abort_on_exception=: (untyped abort_on_exception) -> untyped

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - Thread.each_caller_location(...) { |loc| ... } -> nil
  # -->
  # Yields each frame of the current execution stack as a backtrace location
  # object.
  #
  def self.each_caller_location: () { (Backtrace::Location) -> void } -> nil

  # Wraps the block in a single, VM-global
  # [Mutex\#synchronize](https://ruby-doc.org/core-2.6.3/Mutex.html#method-i-synchronize)
  # , returning the value of the block. A thread executing inside the
  # exclusive section will only block other threads which also use the
  # [::exclusive](Thread.downloaded.ruby_doc#method-c-exclusive) mechanism.
  def self.exclusive: () { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.exit   -> thread
  # -->
  # Terminates the currently running thread and schedules another thread to be
  # run.
  #
  # If this thread is already marked to be killed, ::exit returns the Thread.
  #
  # If this is the main thread, or the last  thread, exit the process.
  #
  def self.exit: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.fork: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.handle_interrupt(hash) { ... } -> result of the block
  # -->
  # Changes asynchronous interrupt timing.
  #
  # *interrupt* means asynchronous event and corresponding procedure by
  # Thread#raise, Thread#kill, signal trap (not supported yet) and main thread
  # termination (if main thread terminates, then all other thread will be killed).
  #
  # The given `hash` has pairs like `ExceptionClass => :TimingSymbol`. Where the
  # ExceptionClass is the interrupt handled by the given block. The TimingSymbol
  # can be one of the following symbols:
  #
  # `:immediate`
  # :   Invoke interrupts immediately.
  #
  # `:on_blocking`
  # :   Invoke interrupts while *BlockingOperation*.
  #
  # `:never`
  # :   Never invoke all interrupts.
  #
  #
  # *BlockingOperation* means that the operation will block the calling thread,
  # such as read and write.  On CRuby implementation, *BlockingOperation* is any
  # operation executed without GVL.
  #
  # Masked asynchronous interrupts are delayed until they are enabled. This method
  # is similar to sigprocmask(3).
  #
  # ### NOTE
  #
  # Asynchronous interrupts are difficult to use.
  #
  # If you need to communicate between threads, please consider to use another way
  # such as Queue.
  #
  # Or use them with deep understanding about this method.
  #
  # ### Usage
  #
  # In this example, we can guard from Thread#raise exceptions.
  #
  # Using the `:never` TimingSymbol the RuntimeError exception will always be
  # ignored in the first block of the main thread. In the second
  # ::handle_interrupt block we can purposefully handle RuntimeError exceptions.
  #
  #     th = Thread.new do
  #       Thread.handle_interrupt(RuntimeError => :never) {
  #         begin
  #           # You can write resource allocation code safely.
  #           Thread.handle_interrupt(RuntimeError => :immediate) {
  #             # ...
  #           }
  #         ensure
  #           # You can write resource deallocation code safely.
  #         end
  #       }
  #     end
  #     Thread.pass
  #     # ...
  #     th.raise "stop"
  #
  # While we are ignoring the RuntimeError exception, it's safe to write our
  # resource allocation code. Then, the ensure block is where we can safely
  # deallocate your resources.
  #
  # #### Stack control settings
  #
  # It's possible to stack multiple levels of ::handle_interrupt blocks in order
  # to control more than one ExceptionClass and TimingSymbol at a time.
  #
  #     Thread.handle_interrupt(FooError => :never) {
  #       Thread.handle_interrupt(BarError => :never) {
  #          # FooError and BarError are prohibited.
  #       }
  #     }
  #
  # #### Inheritance with ExceptionClass
  #
  # All exceptions inherited from the ExceptionClass parameter will be considered.
  #
  #     Thread.handle_interrupt(Exception => :never) {
  #       # all exceptions inherited from Exception are prohibited.
  #     }
  #
  # For handling all interrupts, use `Object` and not `Exception` as the
  # ExceptionClass, as kill/terminate interrupts are not handled by `Exception`.
  #
  def self.handle_interrupt: (untyped hash) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.raise
  #   - thr.raise(string)
  #   - thr.raise(exception [, string [, array]])
  # -->
  # Raises an exception from the given thread. The caller does not have to be
  # `thr`. See Kernel#raise for more information.
  #
  #     Thread.abort_on_exception = true
  #     a = Thread.new { sleep(200) }
  #     a.raise("Gotcha")
  #
  # This will produce:
  #
  #     prog.rb:3: Gotcha (RuntimeError)
  #      from prog.rb:2:in `initialize'
  #      from prog.rb:2:in `new'
  #      from prog.rb:2
  #
  def raise: (?String message) -> nil
           | (_Exception, ?_ToS message, ?Array[Thread::Backtrace::Location] | Array[String] | nil backtrace) -> nil

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.kill(thread)   -> thread
  # -->
  # Causes the given `thread` to exit, see also Thread::exit.
  #
  #     count = 0
  #     a = Thread.new { loop { count += 1 } }
  #     sleep(0.1)       #=> 0
  #     Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>
  #     count            #=> 93947
  #     a.alive?         #=> false
  #
  def self.kill: (Thread thread) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.list   -> array
  # -->
  # Returns an array of Thread objects for all threads that are either runnable or
  # stopped.
  #
  #     Thread.new { sleep(200) }
  #     Thread.new { 1000000.times {|i| i*i } }
  #     Thread.new { Thread.stop }
  #     Thread.list.each {|t| p t}
  #
  # This will produce:
  #
  #     #<Thread:0x401b3e84 sleep>
  #     #<Thread:0x401b3f38 run>
  #     #<Thread:0x401b3fb0 sleep>
  #     #<Thread:0x401bdf4c run>
  #
  def self.list: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pass   -> nil
  # -->
  # Give the thread scheduler a hint to pass execution to another thread. A
  # running thread may or may not switch, it depends on OS and processor.
  #
  def self.pass: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty.
  #
  # Since Thread::handle_interrupt can be used to defer asynchronous events, this
  # method can be used to determine if there are any deferred events.
  #
  # If you find this method returns true, then you may finish `:never` blocks.
  #
  # For example, the following method processes deferred asynchronous events
  # immediately.
  #
  #     def Thread.kick_interrupt_immediately
  #       Thread.handle_interrupt(Object => :immediate) {
  #         Thread.pass
  #       }
  #     end
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # ### Usage
  #
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           if Thread.pending_interrupt?
  #             Thread.handle_interrupt(Object => :immediate){}
  #           end
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     th.raise # stop thread
  #
  # This example can also be written as the following, which you should use to
  # avoid asynchronous interrupts.
  #
  #     flag = true
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           break if flag == false
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     flag = false # stop thread
  #
  def self.pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception   -> true or false
  # -->
  # Returns the status of the global ``report on exception'' condition.
  #
  # The default is `true` since Ruby 2.5.
  #
  # All threads created when this flag is true will report a message on $stderr if
  # an exception kills the thread.
  #
  #     Thread.new { 1.times { raise } }
  #
  # will produce this output on $stderr:
  #
  #     #<Thread:...> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #             2: from -e:1:in `block in <main>'
  #             1: from -e:1:in `times'
  #
  # This is done to catch errors in threads early. In some cases, you might not
  # want this output. There are multiple ways to avoid the extra output:
  #
  # *   If the exception is not intended, the best is to fix the cause of the
  #     exception so it does not happen anymore.
  # *   If the exception is intended, it might be better to rescue it closer to
  #     where it is raised rather then let it kill the Thread.
  # *   If it is guaranteed the Thread will be joined with Thread#join or
  #     Thread#value, then it is safe to disable this report with
  #     `Thread.current.report_on_exception = false` when starting the Thread.
  #     However, this might handle the exception much later, or not at all if the
  #     Thread is never joined due to the parent thread being blocked, etc.
  #
  # See also ::report_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception= boolean   -> true or false
  # -->
  # Returns the new state. When set to `true`, all threads created afterwards will
  # inherit the condition and report a message on $stderr if an exception kills a
  # thread:
  #
  #     Thread.report_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "In the main thread"
  #
  # This will produce:
  #
  #     In new thread
  #     #<Thread:...prog.rb:2> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #     prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)
  #     In the main thread
  #
  # See also ::report_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception=: (untyped report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.start: (*untyped args) { (?) -> void } -> instance

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.stop   -> nil
  # -->
  # Stops execution of the current thread, putting it into a ``sleep'' state, and
  # schedules execution of another thread.
  #
  #     a = Thread.new { print "a"; Thread.stop; print "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     print "b"
  #     a.run
  #     a.join
  #     #=> "abc"
  #
  def self.stop: () -> untyped
end

# <!-- rdoc-file=vm_backtrace.c -->
# An internal representation of the backtrace. The user will never interact with
# objects of this class directly, but class methods can be used to get backtrace
# settings of the current session.
#
class Thread::Backtrace < Object
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - Thread::Backtrace::limit -> integer
  # -->
  # Returns maximum backtrace length set by `--backtrace-limit` command-line
  # option. The default is `-1` which means unlimited backtraces. If the value is
  # zero or positive, the error backtraces, produced by Exception#full_message,
  # are abbreviated and the extra lines are replaced by `... 3 levels... `
  #
  #     $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     - 1
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #         from -e:1:in `<main>'
  #
  #     $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     2
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #
  #     $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     0
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #          ... 9 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #          ... 9 levels...
  #
  def self.limit: () -> Integer
end

# <!-- rdoc-file=vm_backtrace.c -->
# An object representation of a stack frame, initialized by
# Kernel#caller_locations.
#
# For example:
#
#     # caller_locations.rb
#     def a(skip)
#       caller_locations(skip)
#     end
#     def b(skip)
#       a(skip)
#     end
#     def c(skip)
#       b(skip)
#     end
#
#     c(0..2).map do |call|
#       puts call.to_s
#     end
#
# Running `ruby caller_locations.rb` will produce:
#
#     caller_locations.rb:2:in `a'
#     caller_locations.rb:5:in `b'
#     caller_locations.rb:8:in `c'
#
# Here's another example with a slightly different result:
#
#     # foo.rb
#     class Foo
#       attr_accessor :locations
#       def initialize(skip)
#         @locations = caller_locations(skip)
#       end
#     end
#
#     Foo.new(0..2).locations.map do |call|
#       puts call.to_s
#     end
#
# Now run `ruby foo.rb` and you should see:
#
#     init.rb:4:in `initialize'
#     init.rb:8:in `new'
#     init.rb:8:in `<main>'
#
class Thread::Backtrace::Location
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - absolute_path()
  # -->
  # Returns the full file path of this frame.
  #
  # Same as #path, except that it will return absolute path even if the frame is
  # in the main script.
  #
  def absolute_path: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - base_label()
  # -->
  # Returns the base label of this frame, which is usually equal to the label,
  # without decoration.
  #
  # Consider the following example:
  #
  #     def foo
  #       puts caller_locations(0).first.base_label
  #
  #       1.times do
  #         puts caller_locations(0).first.base_label
  #
  #         1.times do
  #           puts caller_locations(0).first.base_label
  #         end
  #       end
  #     end
  #
  # The result of calling `foo` is this:
  #
  #     foo
  #     foo
  #     foo
  #
  def base_label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - label()
  # -->
  # Returns the label of this frame.
  #
  # Usually consists of method, class, module, etc names with decoration.
  #
  # Consider the following example:
  #
  #     def foo
  #       puts caller_locations(0).first.label
  #
  #       1.times do
  #         puts caller_locations(0).first.label
  #
  #         1.times do
  #           puts caller_locations(0).first.label
  #         end
  #       end
  #     end
  #
  # The result of calling `foo` is this:
  #
  #     foo
  #     block in foo
  #     block (2 levels) in foo
  #
  def label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - lineno()
  # -->
  # Returns the line number of this frame.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.lineno #=> 2
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - path()
  # -->
  # Returns the file name of this frame. This will generally be an absolute path,
  # unless the frame is in the main script, in which case it will be the script
  # location passed on the command line.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.path #=> caller_locations.rb
  #
  def path: () -> String?
end

# <!-- rdoc-file=thread_sync.c -->
# ConditionVariable objects augment class Mutex. Using condition variables, it
# is possible to suspend while in the middle of a critical section until a
# resource becomes available.
#
# Example:
#
#     mutex = Thread::Mutex.new
#     resource = Thread::ConditionVariable.new
#
#     a = Thread.new {
#        mutex.synchronize {
#          # Thread 'a' now needs the resource
#          resource.wait(mutex)
#          # 'a' can now have the resource
#        }
#     }
#
#     b = Thread.new {
#        mutex.synchronize {
#          # Thread 'b' has finished using the resource
#          resource.signal
#        }
#     }
#
class Thread::ConditionVariable < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - broadcast()
  # -->
  # Wakes up all threads waiting for this lock.
  #
  def broadcast: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - signal()
  # -->
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - wait(mutex, timeout=nil)
  # -->
  # Releases the lock held in `mutex` and waits; reacquires the lock on wakeup.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed,
  # even if no other thread doesn't signal.
  #
  # Returns the slept result on `mutex`.
  #
  def wait: (Thread::Mutex mutex, ?Time::_Timeout? timeout) -> Integer?
end

# <!-- rdoc-file=thread_sync.c -->
# Thread::Mutex implements a simple semaphore that can be used to coordinate
# access to shared data from multiple concurrent threads.
#
# Example:
#
#     semaphore = Thread::Mutex.new
#
#     a = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
#     b = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
class Thread::Mutex < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.lock  -> self
  # -->
  # Attempts to grab the lock and waits if it isn't available. Raises
  # `ThreadError` if `mutex` was locked by the current thread.
  #
  def lock: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.locked?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by some thread.
  #
  def locked?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.owned?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by current thread.
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.synchronize { ... }    -> result of the block
  # -->
  # Obtains a lock, runs the block, and releases the lock when the block
  # completes.  See the example under Thread::Mutex.
  #
  def synchronize: [X] () { () -> X } -> X

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.try_lock  -> true or false
  # -->
  # Attempts to obtain the lock and returns immediately. Returns `true` if the
  # lock was granted.
  #
  def try_lock: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.unlock    -> self
  # -->
  # Releases the lock. Raises `ThreadError` if `mutex` wasn't locked by the
  # current thread.
  #
  def unlock: () -> self
end

# <!-- rdoc-file=thread_sync.c -->
# The Thread::Queue class implements multi-producer, multi-consumer queues.  It
# is especially useful in threaded programming when information must be
# exchanged safely between multiple threads. The Thread::Queue class implements
# all the required locking semantics.
#
# The class implements FIFO (first in, first out) type of queue. In a FIFO
# queue, the first tasks added are the first retrieved.
#
# Example:
#
#     queue = Thread::Queue.new
#
#     producer = Thread.new do
#       5.times do |i|
#         sleep rand(i) # simulate expense
#         queue << i
#         puts "#{i} produced"
#       end
#     end
#
#     consumer = Thread.new do
#       5.times do |i|
#         value = queue.pop
#         sleep rand(i/2) # simulate expense
#         puts "consumed #{value}"
#       end
#     end
#
#     consumer.join
#
class Thread::Queue[Elem = untyped] < Object
  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias << push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - clear()
  # -->
  # Removes all objects from the queue.
  #
  def clear: () -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - close
  # -->
  # Closes the queue. A closed queue cannot be re-opened.
  #
  # After the call to close completes, the following are true:
  #
  # *   `closed?` will return true
  #
  # *   `close` will be ignored.
  #
  # *   calling enq/push/<< will raise a `ClosedQueueError`.
  #
  # *   when `empty?` is false, calling deq/pop/shift will return an object from
  #     the queue as usual.
  # *   when `empty?` is true, deq(false) will not suspend the thread and will
  #     return nil. deq(true) will raise a `ThreadError`.
  #
  # ClosedQueueError is inherited from StopIteration, so that you can break loop
  # block.
  #
  # Example:
  #
  #     q = Thread::Queue.new
  #     Thread.new{
  #       while e = q.deq # wait for nil to break loop
  #         # ...
  #       end
  #     }
  #     q.close
  #
  def close: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - closed?
  # -->
  # Returns `true` if the queue is closed.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.rb
  #   - deq(non_block = false, timeout: nil)
  # -->
  #
  alias deq pop

  # <!--
  #   rdoc-file=thread_sync.c
  #   - empty?
  # -->
  # Returns `true` if the queue is empty.
  #
  def empty?: () -> bool

  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - freeze
  # -->
  # The queue can't be frozen, so this method raises an exception:
  #     Thread::Queue.new.freeze # Raises TypeError (cannot freeze #<Thread::Queue:0x...>)
  #
  def freeze: () -> bot

  # <!--
  #   rdoc-file=thread_sync.c
  #   - length
  #   - size
  # -->
  # Returns the length of the queue.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - num_waiting()
  # -->
  # Returns the number of threads waiting on the queue.
  #
  def num_waiting: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.rb
  #   - pop(non_block=false, timeout: nil)
  # -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  # If `timeout` seconds have passed and no data is available `nil` is returned.
  # If `timeout` is `0` it returns immediately.
  #
  def pop: (?boolish non_block, ?timeout: _ToF?) -> Elem?

  # <!--
  #   rdoc-file=thread_sync.c
  #   - push(object)
  #   - enq(object)
  #   - <<(object)
  # -->
  # Pushes the given `object` to the queue.
  #
  def push: (Elem obj) -> void

  # <!--
  #   rdoc-file=thread_sync.rb
  #   - shift(non_block = false, timeout: nil)
  # -->
  #
  alias shift pop

  # <!-- rdoc-file=thread_sync.c -->
  # Returns the length of the queue.
  #
  alias size length
end

# <!-- rdoc-file=thread_sync.c -->
# This class represents queues of specified size capacity.  The push operation
# may be blocked if the capacity is full.
#
# See Thread::Queue for an example of how a Thread::SizedQueue works.
#
class Thread::SizedQueue[Elem = untyped] < Thread::Queue[Elem]
  # <!--
  #   rdoc-file=thread_sync.rb
  #   - <<(object, non_block = false, timeout: nil)
  # -->
  #
  alias << push

  # <!--
  #   rdoc-file=thread_sync.rb
  #   - enq(object, non_block = false, timeout: nil)
  # -->
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - freeze
  # -->
  # The queue can't be frozen, so this method raises an exception:
  #     Thread::Queue.new.freeze # Raises TypeError (cannot freeze #<Thread::Queue:0x...>)
  #
  def freeze: () -> bot

  # <!--
  #   rdoc-file=thread_sync.c
  #   - new(max)
  # -->
  # Creates a fixed-length queue with a maximum size of `max`.
  #
  def initialize: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max()
  # -->
  # Returns the maximum size of the queue.
  #
  def max: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max=(number)
  # -->
  # Sets the maximum size of the queue to the given `number`.
  #
  def max=: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.rb
  #   - push(object, non_block=false, timeout: nil)
  #   - enq(object, non_block=false, timeout: nil)
  #   - <<(object)
  # -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  # If `timeout` seconds have passed and no space is available `nil` is returned.
  # If `timeout` is `0` it returns immediately. Otherwise it returns `self`.
  #
  def push: (Elem obj, ?boolish non_block) -> void
          | (Elem obj, timeout: _ToF?) -> self?
end

class ConditionVariable = Thread::ConditionVariable

class Mutex = Thread::Mutex

class Queue = Thread::Queue

class SizedQueue = Thread::SizedQueue
# <!-- rdoc-file=proc.c -->
# Method objects are created by Object#method, and are associated with a
# particular object (not just with a class).  They may be used to invoke the
# method within the object, and as a block associated with an iterator.  They
# may also be unbound from one object (creating an UnboundMethod) and bound to
# another.
#
#     class Thing
#       def square(n)
#         n*n
#       end
#     end
#     thing = Thing.new
#     meth  = thing.method(:square)
#
#     meth.call(9)                 #=> 81
#     [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]
#
#     [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3
#
#     require 'date'
#     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
#     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
#
class Method
  # The return type from `#parameters` methods (such as those defined on `Method`, `Proc`, and `UnboundMethod`).
  type param_types = Array[[:req | :opt | :rest | :keyreq | :key | :keyrest | :block, Symbol] | [:rest | :keyrest | :nokey]]

  # <!--
  #   rdoc-file=proc.c
  #   - meth.eql?(other_meth)  -> true or false
  #   - meth == other_meth  -> true or false
  # -->
  # Two method objects are equal if they are bound to the same object and refer to
  # the same method definition and the classes defining the methods are the same
  # class or module.
  #
  def ==: (untyped other) -> bool

  # <!-- rdoc-file=proc.c -->
  # Two method objects are equal if they are bound to the same object and refer to
  # the same method definition and the classes defining the methods are the same
  # class or module.
  #
  alias eql? ==

  # <!--
  #   rdoc-file=proc.c
  #   - meth.hash   -> integer
  # -->
  # Returns a hash value corresponding to the method object.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  def dup: () -> instance

  # <!--
  #   rdoc-file=proc.c
  #   - meth.to_s      ->  string
  #   - meth.inspect   ->  string
  # -->
  # Returns a human-readable description of the underlying method.
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     (1..3).method(:map).inspect    #=> "#<Method: Range(Enumerable)#map()>"
  #
  # In the latter case, the method description includes the "owner" of the
  # original method (`Enumerable` module, which is included into `Range`).
  #
  # `inspect` also provides, when possible, method argument names (call sequence)
  # and source location.
  #
  #     require 'net/http'
  #     Net::HTTP.method(:get).inspect
  #     #=> "#<Method: Net::HTTP.get(uri_or_host, path=..., port=...) <skip>/lib/ruby/2.7.0/net/http.rb:457>"
  #
  # `...` in argument definition means argument is optional (has some default
  # value).
  #
  # For methods defined in C (language core and extensions), location and argument
  # names can't be extracted, and only generic information is provided in form of
  # `*` (any number of arguments) or `_` (some positional argument).
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     "cat".method(:+).inspect       #=> "#<Method: String#+(_)>""
  #
  def inspect: () -> String

  # <!-- rdoc-file=proc.c -->
  # Returns a human-readable description of the underlying method.
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     (1..3).method(:map).inspect    #=> "#<Method: Range(Enumerable)#map()>"
  #
  # In the latter case, the method description includes the "owner" of the
  # original method (`Enumerable` module, which is included into `Range`).
  #
  # `inspect` also provides, when possible, method argument names (call sequence)
  # and source location.
  #
  #     require 'net/http'
  #     Net::HTTP.method(:get).inspect
  #     #=> "#<Method: Net::HTTP.get(uri_or_host, path=..., port=...) <skip>/lib/ruby/2.7.0/net/http.rb:457>"
  #
  # `...` in argument definition means argument is optional (has some default
  # value).
  #
  # For methods defined in C (language core and extensions), location and argument
  # names can't be extracted, and only generic information is provided in form of
  # `*` (any number of arguments) or `_` (some positional argument).
  #
  #     "cat".method(:count).inspect   #=> "#<Method: String#count(*)>"
  #     "cat".method(:+).inspect       #=> "#<Method: String#+(_)>""
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=proc.c
  #   - meth.to_proc    -> proc
  # -->
  # Returns a Proc object corresponding to this method.
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.call(args, ...)    -> obj
  # -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  def call: (?) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth << g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls *g* with them then
  # calls this method with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f << g).call(2) #=> 16
  #
  def <<: (Proc::_Callable g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias === call

  # <!--
  #   rdoc-file=proc.c
  #   - meth >> g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls this method with
  # them then calls *g* with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f >> g).call(2) #=> 8
  #
  def >>: (Proc::_Callable g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias [] call

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> instance

  # <!--
  #   rdoc-file=proc.c
  #   - meth.curry        -> proc
  #   - meth.curry(arity) -> proc
  # -->
  # Returns a curried proc based on the method. When the proc is called with a
  # number of arguments that is lower than the method's arity, then another
  # curried proc is returned. Only when enough arguments have been supplied to
  # satisfy the method signature, will the method actually be called.
  #
  # The optional *arity* argument should be supplied when currying methods with
  # variable arguments to determine how many arguments are needed before the
  # method is called.
  #
  #     def foo(a,b,c)
  #       [a, b, c]
  #     end
  #
  #     proc  = self.method(:foo).curry
  #     proc2 = proc.call(1, 2)          #=> #<Proc>
  #     proc2.call(3)                    #=> [1,2,3]
  #
  #     def vararg(*args)
  #       args
  #     end
  #
  #     proc = self.method(:vararg).curry(4)
  #     proc2 = proc.call(:x)      #=> #<Proc>
  #     proc3 = proc2.call(:y, :z) #=> #<Proc>
  #     proc3.call(:a)             #=> [:x, :y, :z, :a]
  #
  def curry: (?int? arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module on which this method is defined. In other words,
  #
  #     meth.owner.instance_methods(false).include?(meth.name) # => true
  #
  # holds as long as the method is not removed/undefined/replaced, (with
  # private_instance_methods instead of instance_methods if the method is
  # private).
  #
  # See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> (Class | Module)

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> param_types

  # <!--
  #   rdoc-file=proc.c
  #   - meth.receiver    -> object
  # -->
  # Returns the bound receiver of the method object.
  #
  #     (1..3).method(:map).receiver # => 1..3
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [String, Integer]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> Method?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.unbind    -> unbound_method
  # -->
  # Dissociates *meth* from its current receiver. The resulting UnboundMethod can
  # subsequently be bound to a new object of the same class (see UnboundMethod).
  #
  def unbind: () -> UnboundMethod
end
# <!-- rdoc-file=rational.c -->
# A rational number can be represented as a pair of integer numbers: a/b (b>0),
# where a is the numerator and b is the denominator. Integer a equals rational
# a/1 mathematically.
#
# You can create a Rational object explicitly with:
#
# *   A [rational literal](rdoc-ref:syntax/literals.rdoc@Rational+Literals).
#
# You can convert certain objects to Rationals with:
#
# *   Method #Rational.
#
# Examples
#
#     Rational(1)      #=> (1/1)
#     Rational(2, 3)   #=> (2/3)
#     Rational(4, -6)  #=> (-2/3) # Reduced.
#     3.to_r           #=> (3/1)
#     2/3r             #=> (2/3)
#
# You can also create rational objects from floating-point numbers or strings.
#
#     Rational(0.3)    #=> (5404319552844595/18014398509481984)
#     Rational('0.3')  #=> (3/10)
#     Rational('2/3')  #=> (2/3)
#
#     0.3.to_r         #=> (5404319552844595/18014398509481984)
#     '0.3'.to_r       #=> (3/10)
#     '2/3'.to_r       #=> (2/3)
#     0.3.rationalize  #=> (3/10)
#
# A rational object is an exact number, which helps you to write programs
# without any rounding errors.
#
#     10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
#     10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)
#
# However, when an expression includes an inexact component (numerical value or
# operation), it will produce an inexact result.
#
#     Rational(10) / 3   #=> (10/3)
#     Rational(10) / 3.0 #=> 3.3333333333333335
#
#     Rational(-8) ** Rational(1, 3)
#                        #=> (1.0000000000000002+1.7320508075688772i)
#
class Rational < Numeric
  def %: (Integer) -> Rational
       | (Float) -> Float
       | (Rational) -> Rational
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat * numeric  ->  numeric
  # -->
  # Performs multiplication.
  #
  #     Rational(2, 3)  * Rational(2, 3)   #=> (4/9)
  #     Rational(900)   * Rational(1)      #=> (900/1)
  #     Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)
  #     Rational(9, 8)  * 4                #=> (9/2)
  #     Rational(20, 9) * 9.8              #=> 21.77777777777778
  #
  def *: (Integer) -> Rational
       | (Rational) -> Rational
       | [T < Numeric](T) -> T

  # <!--
  #   rdoc-file=rational.c
  #   - rat ** numeric  ->  numeric
  # -->
  # Performs exponentiation.
  #
  #     Rational(2)    ** Rational(3)     #=> (8/1)
  #     Rational(10)   ** -2              #=> (1/100)
  #     Rational(10)   ** -2.0            #=> 0.01
  #     Rational(-4)   ** Rational(1, 2)  #=> (0.0+2.0i)
  #     Rational(1, 2) ** 0               #=> (1/1)
  #     Rational(1, 2) ** 0.0             #=> 1.0
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat + numeric  ->  numeric
  # -->
  # Performs addition.
  #
  #     Rational(2, 3)  + Rational(2, 3)   #=> (4/3)
  #     Rational(900)   + Rational(1)      #=> (901/1)
  #     Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)
  #     Rational(9, 8)  + 4                #=> (41/8)
  #     Rational(20, 9) + 9.8              #=> 12.022222222222222
  #
  def +: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  def +@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat - numeric  ->  numeric
  # -->
  # Performs subtraction.
  #
  #     Rational(2, 3)  - Rational(2, 3)   #=> (0/1)
  #     Rational(900)   - Rational(1)      #=> (899/1)
  #     Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)
  #     Rational(9, 8)  - 4                #=> (-23/8)
  #     Rational(20, 9) - 9.8              #=> -7.577777777777778
  #
  def -: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - -rat  ->  rational
  # -->
  # Negates `rat`.
  #
  def -@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat / numeric     ->  numeric
  #   - rat.quo(numeric)  ->  numeric
  # -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def /: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rational <=> numeric  ->  -1, 0, +1, or nil
  # -->
  # Returns -1, 0, or +1 depending on whether `rational` is less than, equal to,
  # or greater than `numeric`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  #     Rational(2, 3) <=> Rational(2, 3)  #=> 0
  #     Rational(5)    <=> 5               #=> 0
  #     Rational(2, 3) <=> Rational(1, 3)  #=> 1
  #     Rational(1, 3) <=> 1               #=> -1
  #     Rational(1, 3) <=> 0.3             #=> 1
  #
  #     Rational(1, 3) <=> "0.3"           #=> nil
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat == object  ->  true or false
  # -->
  # Returns `true` if `rat` equals `object` numerically.
  #
  #     Rational(2, 3)  == Rational(2, 3)   #=> true
  #     Rational(5)     == 5                #=> true
  #     Rational(0)     == 0.0              #=> true
  #     Rational('1/3') == 0.33             #=> false
  #     Rational('1/2') == '1/2'            #=> false
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.abs        ->  rational
  #   - rat.magnitude  ->  rational
  # -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  def abs: () -> Rational

  def abs2: () -> Rational

  def angle: () -> (Integer | Float)

  alias arg angle

  # <!--
  #   rdoc-file=rational.c
  #   - rat.ceil([ndigits])  ->  integer or rational
  # -->
  # Returns the smallest number greater than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).ceil      #=> 3
  #     Rational(2, 3).ceil   #=> 1
  #     Rational(-3, 2).ceil  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').ceil(+1).to_f  #=> -123.4
  #     Rational('-123.456').ceil(-1)       #=> -120
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Rational)

  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Rational

  def conjugate: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  #     Rational(7).denominator             #=> 1
  #     Rational(7, 1).denominator          #=> 1
  #     Rational(9, -4).denominator         #=> 4
  #     Rational(-2, -10).denominator       #=> 5
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  def divmod: (Integer | Float | Rational) -> [ Integer, Rational ]
            | (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.fdiv(numeric)  ->  float
  # -->
  # Performs division and returns the value as a Float.
  #
  #     Rational(2, 3).fdiv(1)       #=> 0.6666666666666666
  #     Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333
  #     Rational(2).fdiv(3)          #=> 0.6666666666666666
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.floor([ndigits])  ->  integer or rational
  # -->
  # Returns the largest number less than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).floor      #=> 3
  #     Rational(2, 3).floor   #=> 0
  #     Rational(-3, 2).floor  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').floor(+1).to_f  #=> -123.5
  #     Rational('-123.456').floor(-1)       #=> -130
  #
  def floor: () -> Integer
           | (Integer digits) -> (Integer | Rational)

  # <!--
  #   rdoc-file=rational.c
  #   - hash()
  # -->
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Rational(2).inspect      #=> "(2/1)"
  #     Rational(-8, 6).inspect  #=> "(-4/3)"
  #     Rational('1/2').inspect  #=> "(1/2)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  alias magnitude abs

  def modulo: (Float) -> Float
            | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.negative?  ->  true or false
  # -->
  # Returns `true` if `rat` is less than 0.
  #
  def negative?: () -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  #     Rational(7).numerator        #=> 7
  #     Rational(7, 1).numerator     #=> 7
  #     Rational(9, -4).numerator    #=> -9
  #     Rational(-2, -10).numerator  #=> 1
  #
  def numerator: () -> Integer

  alias phase angle

  def polar: () -> [ Rational, Integer | Float ]

  # <!--
  #   rdoc-file=rational.c
  #   - rat.positive?  ->  true or false
  # -->
  # Returns `true` if `rat` is greater than 0.
  #
  def positive?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def quo: (Float) -> Float
         | (Complex) -> Complex
         | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.rationalize       ->  self
  #   - rat.rationalize(eps)  ->  rational
  # -->
  # Returns a simpler approximation of the value if the optional argument `eps` is
  # given (rat-|eps| <= result <= rat+|eps|), self otherwise.
  #
  #     r = Rational(5033165, 16777216)
  #     r.rationalize                    #=> (5033165/16777216)
  #     r.rationalize(Rational('0.01'))  #=> (3/10)
  #     r.rationalize(Rational('0.1'))   #=> (1/3)
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Rational

  def real?: () -> true

  def rect: () -> [ Rational, Numeric ]

  alias rectangular rect

  def remainder: (Float) -> Float
               | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.round([ndigits] [, half: mode])  ->  integer or rational
  # -->
  # Returns `rat` rounded to the nearest value with a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).round      #=> 3
  #     Rational(2, 3).round   #=> 1
  #     Rational(-3, 2).round  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').round(+1).to_f  #=> -123.5
  #     Rational('-123.456').round(-1)       #=> -120
  #
  # The optional `half` keyword argument is available similar to Float#round.
  #
  #     Rational(25, 100).round(1, half: :up)    #=> (3/10)
  #     Rational(25, 100).round(1, half: :down)  #=> (1/5)
  #     Rational(25, 100).round(1, half: :even)  #=> (1/5)
  #     Rational(35, 100).round(1, half: :up)    #=> (2/5)
  #     Rational(35, 100).round(1, half: :down)  #=> (3/10)
  #     Rational(35, 100).round(1, half: :even)  #=> (2/5)
  #     Rational(-25, 100).round(1, half: :up)   #=> (-3/10)
  #     Rational(-25, 100).round(1, half: :down) #=> (-1/5)
  #     Rational(-25, 100).round(1, half: :even) #=> (-1/5)
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (Integer digits, ?half: :up | :down | :even) -> (Integer | Rational)

  def step: (?Numeric limit, ?Numeric step) { (Rational) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Rational, self]
          | (?by: Numeric, ?to: Numeric) { (Rational) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Rational, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_f  ->  float
  # -->
  # Returns the value as a Float.
  #
  #     Rational(2).to_f      #=> 2.0
  #     Rational(9, 4).to_f   #=> 2.25
  #     Rational(-3, 4).to_f  #=> -0.75
  #     Rational(20, 3).to_f  #=> 6.666666666666667
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_i  ->  integer
  # -->
  # Returns the truncated value as an integer.
  #
  # Equivalent to Rational#truncate.
  #
  #     Rational(2, 3).to_i    #=> 0
  #     Rational(3).to_i       #=> 3
  #     Rational(300.6).to_i   #=> 300
  #     Rational(98, 71).to_i  #=> 1
  #     Rational(-31, 2).to_i  #=> -15
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_r  ->  self
  # -->
  # Returns self.
  #
  #     Rational(2).to_r      #=> (2/1)
  #     Rational(-8, 6).to_r  #=> (-4/3)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_s  ->  string
  # -->
  # Returns the value as a string.
  #
  #     Rational(2).to_s      #=> "2/1"
  #     Rational(-8, 6).to_s  #=> "-4/3"
  #     Rational('1/2').to_s  #=> "1/2"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=rational.c
  #   - rat.truncate([ndigits])  ->  integer or rational
  # -->
  # Returns `rat` truncated (toward zero) to a precision of `ndigits` decimal
  # digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).truncate      #=> 3
  #     Rational(2, 3).truncate   #=> 0
  #     Rational(-3, 2).truncate  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').truncate(+1).to_f  #=> -123.4
  #     Rational('-123.456').truncate(-1)       #=> -120
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Rational)

  def zero?: () -> bool
end
# <!-- rdoc-file=string.rb -->
# A `String` object has an arbitrary sequence of bytes, typically representing
# text or binary data. A `String` object may be created using String::new or as
# literals.
#
# String objects differ from Symbol objects in that Symbol objects are designed
# to be used as identifiers, instead of text or data.
#
# You can create a `String` object explicitly with:
#
# *   A [string literal](rdoc-ref:syntax/literals.rdoc@String+Literals).
# *   A [heredoc literal](rdoc-ref:syntax/literals.rdoc@Here+Document+Literals).
#
# You can convert certain objects to Strings with:
#
# *   Method #String.
#
# Some `String` methods modify `self`. Typically, a method whose name ends with
# `!` modifies `self` and returns `self`; often, a similarly named method
# (without the `!`) returns a new string.
#
# In general, if both bang and non-bang versions of a method exist, the bang
# method mutates and the non-bang method does not. However, a method without a
# bang can also mutate, such as String#replace.
#
# ## Substitution Methods
#
# These methods perform substitutions:
#
# *   String#sub: One substitution (or none); returns a new string.
# *   String#sub!: One substitution (or none); returns `self` if any changes,
#     `nil` otherwise.
# *   String#gsub: Zero or more substitutions; returns a new string.
# *   String#gsub!: Zero or more substitutions; returns `self` if any changes,
#     `nil` otherwise.
#
# Each of these methods takes:
#
# *   A first argument, `pattern` (String or Regexp), that specifies the
#     substring(s) to be replaced.
#
# *   Either of the following:
#
#     *   A second argument, `replacement` (String or Hash), that determines the
#         replacing string.
#     *   A block that will determine the replacing string.
#
# The examples in this section mostly use the String#sub and String#gsub
# methods; the principles illustrated apply to all four substitution methods.
#
# **Argument `pattern`**
#
# Argument `pattern` is commonly a regular expression:
#
#     s = 'hello'
#     s.sub(/[aeiou]/, '*') # => "h*llo"
#     s.gsub(/[aeiou]/, '*') # => "h*ll*"
#     s.gsub(/[aeiou]/, '')  # => "hll"
#     s.sub(/ell/, 'al')     # => "halo"
#     s.gsub(/xyzzy/, '*')   # => "hello"
#     'THX1138'.gsub(/\d+/, '00') # => "THX00"
#
# When `pattern` is a string, all its characters are treated as ordinary
# characters (not as Regexp special characters):
#
#     'THX1138'.gsub('\d+', '00') # => "THX1138"
#
# **`String` `replacement`**
#
# If `replacement` is a string, that string determines the replacing string that
# is substituted for the matched text.
#
# Each of the examples above uses a simple string as the replacing string.
#
# `String` `replacement` may contain back-references to the pattern's captures:
#
# *   `\n` (*n* is a non-negative integer) refers to `$n`.
# *   `\k<name>` refers to the named capture `name`.
#
# See Regexp for details.
#
# Note that within the string `replacement`, a character combination such as
# `$&` is treated as ordinary text, not as a special match variable. However,
# you may refer to some special match variables using these combinations:
#
# *   `\&` and `\0` correspond to `$&`, which contains the complete matched
#     text.
# *   `\'` corresponds to `$'`, which contains the string after the match.
# *   `\`` corresponds to `$``, which contains the string before the match.
# *   `\+` corresponds to `$+`, which contains the last capture group.
#
# See Regexp for details.
#
# Note that `\\\` is interpreted as an escape, i.e., a single backslash.
#
# Note also that a string literal consumes backslashes. See [String
# Literals](rdoc-ref:syntax/literals.rdoc@String+Literals) for details about
# string literals.
#
# A back-reference is typically preceded by an additional backslash. For
# example, if you want to write a back-reference `\&` in `replacement` with a
# double-quoted string literal, you need to write `"..\\\\&.."`.
#
# If you want to write a non-back-reference string `\&` in `replacement`, you
# need to first escape the backslash to prevent this method from interpreting it
# as a back-reference, and then you need to escape the backslashes again to
# prevent a string literal from consuming them: `"..\\\\\\\\&.."`.
#
# You may want to use the block form to avoid excessive backslashes.
#
# **\Hash `replacement`**
#
# If the argument `replacement` is a hash, and `pattern` matches one of its
# keys, the replacing string is the value for that key:
#
#     h = {'foo' => 'bar', 'baz' => 'bat'}
#     'food'.sub('foo', h) # => "bard"
#
# Note that a symbol key does not match:
#
#     h = {foo: 'bar', baz: 'bat'}
#     'food'.sub('foo', h) # => "d"
#
# **Block**
#
# In the block form, the current match string is passed to the block; the
# block's return value becomes the replacing string:
#
#     s = '@'
#     '1234'.gsub(/\d/) { |match| s.succ! } # => "ABCD"
#
# Special match variables such as `$1`, `$2`, `$``, `$&`, and `$'` are set
# appropriately.
#
# ## Whitespace in Strings
#
# In the class `String`, *whitespace* is defined as a contiguous sequence of
# characters consisting of any mixture of the following:
#
# *   NL (null): `"\x00"`, `"\u0000"`.
# *   HT (horizontal tab): `"\x09"`, `"\t"`.
# *   LF (line feed): `"\x0a"`, `"\n"`.
# *   VT (vertical tab): `"\x0b"`, `"\v"`.
# *   FF (form feed): `"\x0c"`, `"\f"`.
# *   CR (carriage return): `"\x0d"`, `"\r"`.
# *   SP (space): `"\x20"`, `" "`.
#
# Whitespace is relevant for the following methods:
#
# *   #lstrip, #lstrip!: Strip leading whitespace.
# *   #rstrip, #rstrip!: Strip trailing whitespace.
# *   #strip, #strip!: Strip leading and trailing whitespace.
#
# ## `String` Slices
#
# A *slice* of a string is a substring selected by certain criteria.
#
# These instance methods utilize slicing:
#
# *   String#[] (aliased as String#slice): Returns a slice copied from `self`.
# *   String#[]=: Mutates `self` with the slice replaced.
# *   String#slice!: Mutates `self` with the slice removed and returns the
#     removed slice.
#
# Each of the above methods takes arguments that determine the slice to be
# copied or replaced.
#
# The arguments have several forms. For a string `string`, the forms are:
#
# *   `string[index]`
# *   `string[start, length]`
# *   `string[range]`
# *   `string[regexp, capture = 0]`
# *   `string[substring]`
#
# **`string[index]`**
#
# When a non-negative integer argument `index` is given, the slice is the
# 1-character substring found in `self` at character offset `index`:
#
#     'bar'[0]      # => "b"
#     'bar'[2]      # => "r"
#     'bar'[20]     # => nil
#     ''[2]     # => ""
#     ''[4] # => ""
#
# When a negative integer `index` is given, the slice begins at the offset given
# by counting backward from the end of `self`:
#
#     'bar'[-3]      # => "b"
#     'bar'[-1]      # => "r"
#     'bar'[-20]     # => nil
#
# **`string[start, length]`**
#
# When non-negative integer arguments `start` and `length` are given, the slice
# begins at character offset `start`, if it exists, and continues for `length`
# characters, if available:
#
#     'foo'[0, 2]      # => "fo"
#     ''[1, 2]     # => ""
#     ''[2, 2] # => ""
#     # Zero length.
#     'foo'[2, 0]      # => ""
#     # Length not entirely available.
#     'foo'[1, 200]    # => "oo"
#     # Start out of range.
#     'foo'[4, 2]      # => nil
#
# Special case: if `start` equals the length of `self`, the slice is a new empty
# string:
#
#     'foo'[3, 2]    # => ""
#     'foo'[3, 200]  # => ""
#
# When a negative `start` and non-negative `length` are given, the slice begins
# by counting backward from the end of `self`, and continues for `length`
# characters, if available:
#
#     'foo'[-2, 2]     # => "oo"
#     'foo'[-2, 200]   # => "oo"
#     # Start out of range.
#     'foo'[-4, 2]     # => nil
#
# When a negative `length` is given, there is no slice:
#
#     'foo'[1, -1]   # => nil
#     'foo'[-2, -1]  # => nil
#
# **`string[range]`**
#
# When a Range argument `range` is given, it creates a substring of `string`
# using the indices in `range`. The slice is then determined as above:
#
#     'foo'[0..1]     # => "fo"
#     'foo'[0, 2]     # => "fo"
#
#     'foo'[2...2]    # => ""
#     'foo'[2, 0]     # => ""
#
#     'foo'[1..200]   # => "oo"
#     'foo'[1, 200]   # => "oo"
#
#     'foo'[4..5]     # => nil
#     'foo'[4, 2]     # => nil
#
#     'foo'[-4..-3]   # => nil
#     'foo'[-4, 2]    # => nil
#
#     'foo'[3..4]     # => ""
#     'foo'[3, 2]     # => ""
#
#     'foo'[-2..-1]   # => "oo"
#     'foo'[-2, 2]    # => "oo"
#
#     'foo'[-2..197]  # => "oo"
#     'foo'[-2, 200]  # => "oo"
#
# **`string[regexp, capture = 0]`**
#
# When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
# the slice is the first matching substring found in `self`:
#
#     'foo'[/o/]                # => "o"
#     'foo'[/x/]                # => nil
#     s = 'hello there'
#     s[/[aeiou](.)\1/]        # => "ell"
#     s[/[aeiou](.)\1/, 0]     # => "ell"
#
# If the argument `capture` is provided and not `0`, it should be either a
# capture group index (integer) or a capture group name (String or Symbol); the
# slice is the specified capture (see Regexp@Groups and Captures):
#
#     s = 'hello there'
#     s[/[aeiou](.)\1/, 1] # => "l"
#     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
#     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel]      # => "e"
#
# If an invalid capture group index is given, there is no slice. If an invalid
# capture group name is given, `IndexError` is raised.
#
# **`string[substring]`**
#
# When the single `String` argument `substring` is given, it returns the
# substring from `self` if found, otherwise `nil`:
#
#     'foo'['oo'] # => "oo"
#     'foo'['xx'] # => nil
#
# ## What's Here
#
# First, what's elsewhere. Class `String`:
#
# *   Inherits from the [Object class](rdoc-ref:Object@What-27s+Here).
# *   Includes the [Comparable module](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class `String` provides methods that are useful for:
#
# *   [Creating a String](rdoc-ref:String@Methods+for+Creating+a+String)
# *   [Frozen/Unfrozen
#     Strings](rdoc-ref:String@Methods+for+a+Frozen-2FUnfrozen+String)
# *   [Querying](rdoc-ref:String@Methods+for+Querying)
# *   [Comparing](rdoc-ref:String@Methods+for+Comparing)
# *   [Modifying a String](rdoc-ref:String@Methods+for+Modifying+a+String)
# *   [Converting to New
#     String](rdoc-ref:String@Methods+for+Converting+to+New+String)
# *   [Converting to
#     Non-String](rdoc-ref:String@Methods+for+Converting+to+Non-String)
# *   [Iterating](rdoc-ref:String@Methods+for+Iterating)
#
# ### Methods for Creating a `String`
#
# *   ::new: Returns a new string.
# *   ::try_convert: Returns a new string created from a given object.
#
# ### Methods for a Frozen/Unfrozen String
#
# *   #+@: Returns a string that is not frozen: `self` if not frozen; `self.dup`
#     otherwise.
# *   #-@ (aliased as #dedup): Returns a string that is frozen: `self` if
#     already frozen; `self.freeze` otherwise.
# *   #freeze: Freezes `self` if not already frozen; returns `self`.
#
# ### Methods for Querying
#
# *Counts*
#
# *   #length (aliased as #size): Returns the count of characters (not bytes).
# *   #empty?: Returns `true` if `self.length` is zero; `false` otherwise.
# *   #bytesize: Returns the count of bytes.
# *   #count: Returns the count of substrings matching given strings.
#
# *Substrings*
#
# *   #=~: Returns the index of the first substring that matches a given Regexp
#     or other object; returns `nil` if no match is found.
# *   #index: Returns the index of the *first* occurrence of a given substring;
#     returns `nil` if none found.
# *   #rindex: Returns the index of the *last* occurrence of a given substring;
#     returns `nil` if none found.
# *   #include?: Returns `true` if the string contains a given substring;
#     `false` otherwise.
# *   #match: Returns a MatchData object if the string matches a given Regexp;
#     `nil` otherwise.
# *   #match?: Returns `true` if the string matches a given Regexp; `false`
#     otherwise.
# *   #start_with?: Returns `true` if the string begins with any of the given
#     substrings.
# *   #end_with?: Returns `true` if the string ends with any of the given
#     substrings.
#
# *Encodings*
#
# *   #encoding: Returns the Encoding object that represents the encoding of the
#     string.
# *   #unicode_normalized?: Returns `true` if the string is in Unicode
#     normalized form; `false` otherwise.
# *   #valid_encoding?: Returns `true` if the string contains only characters
#     that are valid for its encoding.
# *   #ascii_only?: Returns `true` if the string has only ASCII characters;
#     `false` otherwise.
#
# *Other*
#
# *   #sum: Returns a basic checksum for the string: the sum of each byte.
# *   #hash: Returns the integer hash code.
#
# ### Methods for Comparing
#
# *   #== (aliased as #===): Returns `true` if a given other string has the same
#     content as `self`.
# *   #eql?: Returns `true` if the content is the same as the given other
#     string.
# *   #<=>: Returns -1, 0, or 1 as a given other string is smaller than, equal
#     to, or larger than `self`.
# *   #casecmp: Ignoring case, returns -1, 0, or 1 as a given other string is
#     smaller than, equal to, or larger than `self`.
# *   #casecmp?: Returns `true` if the string is equal to a given string after
#     Unicode case folding; `false` otherwise.
#
# ### Methods for Modifying a `String`
#
# Each of these methods modifies `self`.
#
# *Insertion*
#
# *   #insert: Returns `self` with a given string inserted at a specified
#     offset.
# *   #<<: Returns `self` concatenated with a given string or integer.
# *   #append_as_bytes: Returns `self` concatenated with strings without
#     performing any encoding validation or conversion.
#
# *Substitution*
#
# *   #sub!: Replaces the first substring that matches a given pattern with a
#     given replacement string; returns `self` if any changes, `nil` otherwise.
# *   #gsub!: Replaces each substring that matches a given pattern with a given
#     replacement string; returns `self` if any changes, `nil` otherwise.
# *   #succ! (aliased as #next!): Returns `self` modified to become its own
#     successor.
# *   #initialize_copy (aliased as #replace): Returns `self` with its entire
#     content replaced by a given string.
# *   #reverse!: Returns `self` with its characters in reverse order.
# *   #setbyte: Sets the byte at a given integer offset to a given value;
#     returns the argument.
# *   #tr!: Replaces specified characters in `self` with specified replacement
#     characters; returns `self` if any changes, `nil` otherwise.
# *   #tr_s!: Replaces specified characters in `self` with specified replacement
#     characters, removing duplicates from the substrings that were modified;
#     returns `self` if any changes, `nil` otherwise.
#
# *Casing*
#
# *   #capitalize!: Upcases the initial character and downcases all others;
#     returns `self` if any changes, `nil` otherwise.
# *   #downcase!: Downcases all characters; returns `self` if any changes, `nil`
#     otherwise.
# *   #upcase!: Upcases all characters; returns `self` if any changes, `nil`
#     otherwise.
# *   #swapcase!: Upcases each downcase character and downcases each upcase
#     character; returns `self` if any changes, `nil` otherwise.
#
# *Encoding*
#
# *   #encode!: Returns `self` with all characters transcoded from one encoding
#     to another.
# *   #unicode_normalize!: Unicode-normalizes `self`; returns `self`.
# *   #scrub!: Replaces each invalid byte with a given character; returns
#     `self`.
# *   #force_encoding: Changes the encoding to a given encoding; returns `self`.
#
# *Deletion*
#
# *   #clear: Removes all content, so that `self` is empty; returns `self`.
# *   #slice!, #[]=: Removes a substring determined by a given index,
#     start/length, range, regexp, or substring.
# *   #squeeze!: Removes contiguous duplicate characters; returns `self`.
# *   #delete!: Removes characters as determined by the intersection of
#     substring arguments.
# *   #lstrip!: Removes leading whitespace; returns `self` if any changes, `nil`
#     otherwise.
# *   #rstrip!: Removes trailing whitespace; returns `self` if any changes,
#     `nil` otherwise.
# *   #strip!: Removes leading and trailing whitespace; returns `self` if any
#     changes, `nil` otherwise.
# *   #chomp!: Removes the trailing record separator, if found; returns `self`
#     if any changes, `nil` otherwise.
# *   #chop!: Removes trailing newline characters if found; otherwise removes
#     the last character; returns `self` if any changes, `nil` otherwise.
#
# ### Methods for Converting to New `String`
#
# Each of these methods returns a new `String` based on `self`, often just a
# modified copy of `self`.
#
# *Extension*
#
# *   #*: Returns the concatenation of multiple copies of `self`.
# *   #+: Returns the concatenation of `self` and a given other string.
# *   #center: Returns a copy of `self` centered between pad substrings.
# *   #concat: Returns the concatenation of `self` with given other strings.
# *   #prepend: Returns the concatenation of a given other string with `self`.
# *   #ljust: Returns a copy of `self` of a given length, right-padded with a
#     given other string.
# *   #rjust: Returns a copy of `self` of a given length, left-padded with a
#     given other string.
#
# *Encoding*
#
# *   #b: Returns a copy of `self` with ASCII-8BIT encoding.
# *   #scrub: Returns a copy of `self` with each invalid byte replaced with a
#     given character.
# *   #unicode_normalize: Returns a copy of `self` with each character
#     Unicode-normalized.
# *   #encode: Returns a copy of `self` with all characters transcoded from one
#     encoding to another.
#
# *Substitution*
#
# *   #dump: Returns a copy of `self` with all non-printing characters replaced
#     by xHH notation and all special characters escaped.
# *   #undump: Returns a copy of `self` with all `\xNN` notations replaced by
#     `\uNNNN` notations and all escaped characters unescaped.
# *   #sub: Returns a copy of `self` with the first substring matching a given
#     pattern replaced with a given replacement string.
# *   #gsub: Returns a copy of `self` with each substring that matches a given
#     pattern replaced with a given replacement string.
# *   #succ (aliased as #next): Returns the string that is the successor to
#     `self`.
# *   #reverse: Returns a copy of `self` with its characters in reverse order.
# *   #tr: Returns a copy of `self` with specified characters replaced with
#     specified replacement characters.
# *   #tr_s: Returns a copy of `self` with specified characters replaced with
#     specified replacement characters, removing duplicates from the substrings
#     that were modified.
# *   #%: Returns the string resulting from formatting a given object into
#     `self`.
#
# *Casing*
#
# *   #capitalize: Returns a copy of `self` with the first character upcased and
#     all other characters downcased.
# *   #downcase: Returns a copy of `self` with all characters downcased.
# *   #upcase: Returns a copy of `self` with all characters upcased.
# *   #swapcase: Returns a copy of `self` with all upcase characters downcased
#     and all downcase characters upcased.
#
# *Deletion*
#
# *   #delete: Returns a copy of `self` with characters removed.
# *   #delete_prefix: Returns a copy of `self` with a given prefix removed.
# *   #delete_suffix: Returns a copy of `self` with a given suffix removed.
# *   #lstrip: Returns a copy of `self` with leading whitespace removed.
# *   #rstrip: Returns a copy of `self` with trailing whitespace removed.
# *   #strip: Returns a copy of `self` with leading and trailing whitespace
#     removed.
# *   #chomp: Returns a copy of `self` with a trailing record separator removed,
#     if found.
# *   #chop: Returns a copy of `self` with trailing newline characters or the
#     last character removed.
# *   #squeeze: Returns a copy of `self` with contiguous duplicate characters
#     removed.
# *   #[] (aliased as #slice): Returns a substring determined by a given index,
#     start/length, range, regexp, or string.
# *   #byteslice: Returns a substring determined by a given index, start/length,
#     or range.
# *   #chr: Returns the first character.
#
# *Duplication*
#
# *   #to_s (aliased as #to_str): If `self` is a subclass of `String`, returns
#     `self` copied into a `String`; otherwise, returns `self`.
#
# ### Methods for Converting to Non-`String`
#
# Each of these methods converts the contents of `self` to a non-`String`.
#
# *Characters, Bytes, and Clusters*
#
# *   #bytes: Returns an array of the bytes in `self`.
# *   #chars: Returns an array of the characters in `self`.
# *   #codepoints: Returns an array of the integer ordinals in `self`.
# *   #getbyte: Returns the integer byte at the given index in `self`.
# *   #grapheme_clusters: Returns an array of the grapheme clusters in `self`.
#
# *Splitting*
#
# *   #lines: Returns an array of the lines in `self`, as determined by a given
#     record separator.
# *   #partition: Returns a 3-element array determined by the first substring
#     that matches a given substring or regexp.
# *   #rpartition: Returns a 3-element array determined by the last substring
#     that matches a given substring or regexp.
# *   #split: Returns an array of substrings determined by a given delimiter --
#     regexp or string -- or, if a block is given, passes those substrings to
#     the block.
#
# *Matching*
#
# *   #scan: Returns an array of substrings matching a given regexp or string,
#     or, if a block is given, passes each matching substring to the block.
# *   #unpack: Returns an array of substrings extracted from `self` according to
#     a given format.
# *   #unpack1: Returns the first substring extracted from `self` according to a
#     given format.
#
# *Numerics*
#
# *   #hex: Returns the integer value of the leading characters, interpreted as
#     hexadecimal digits.
# *   #oct: Returns the integer value of the leading characters, interpreted as
#     octal digits.
# *   #ord: Returns the integer ordinal of the first character in `self`.
# *   #to_i: Returns the integer value of leading characters, interpreted as an
#     integer.
# *   #to_f: Returns the floating-point value of leading characters, interpreted
#     as a floating-point number.
#
# *Strings and Symbols*
#
# *   #inspect: Returns a copy of `self`, enclosed in double quotes, with
#     special characters escaped.
# *   #intern (aliased as #to_sym): Returns the symbol corresponding to `self`.
#
# ### Methods for Iterating
#
# *   #each_byte: Calls the given block with each successive byte in `self`.
# *   #each_char: Calls the given block with each successive character in
#     `self`.
# *   #each_codepoint: Calls the given block with each successive integer
#     codepoint in `self`.
# *   #each_grapheme_cluster: Calls the given block with each successive
#     grapheme cluster in `self`.
# *   #each_line: Calls the given block with each successive line in `self`, as
#     determined by a given record separator.
# *   #upto: Calls the given block with each string value returned by successive
#     calls to #succ.
#
class String
  include Comparable

  # A `selector` is a special type of string, used within methods like `String#tr`.
  type selector = string

  # <!--
  #   rdoc-file=string.c
  #   - String.try_convert(object) -> object, new_string, or nil
  # -->
  # If `object` is a `String` object, returns `object`.
  #
  # Otherwise if `object` responds to `:to_str`, calls `object.to_str` and returns
  # the result.
  #
  # Returns `nil` if `object` does not respond to `:to_str`.
  #
  # Raises an exception unless `object.to_str` returns a `String` object.
  #
  def self.try_convert: (String object) -> String # technically will return `object` unchanged.
                      | (_ToStr object) -> String
                      | (untyped object) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - String.new(string = '', **opts) -> new_string
  # -->
  # Returns a new String that is a copy of `string`.
  #
  # With no arguments, returns the empty string with the Encoding `ASCII-8BIT`:
  #
  #     s = String.new
  #     s # => ""
  #     s.encoding # => #<Encoding:ASCII-8BIT>
  #
  # With optional argument `string` and no keyword arguments, returns a copy of
  # `string` with the same encoding:
  #
  #     String.new('foo')               # => "foo"
  #     String.new('')              # => ""
  #     String.new('')          # => ""
  #
  # (Unlike String.new, a [string
  # literal](rdoc-ref:syntax/literals.rdoc@String+Literals) like `''` or a [here
  # document literal](rdoc-ref:syntax/literals.rdoc@Here+Document+Literals) always
  # has [script encoding](rdoc-ref:encodings.rdoc@Script+Encoding).)
  #
  # With optional keyword argument `encoding`, returns a copy of `string` with the
  # specified encoding; the `encoding` may be an Encoding object, an encoding
  # name, or an encoding name alias:
  #
  #     String.new('foo', encoding: Encoding::US_ASCII).encoding # => #<Encoding:US-ASCII>
  #     String.new('foo', encoding: 'US-ASCII').encoding         # => #<Encoding:US-ASCII>
  #     String.new('foo', encoding: 'ASCII').encoding            # => #<Encoding:US-ASCII>
  #
  # The given encoding need not be valid for the string's content, and that
  # validity is not checked:
  #
  #     s = String.new('', encoding: 'ascii')
  #     s.valid_encoding? # => false
  #
  # But the given `encoding` itself is checked:
  #
  #     String.new('foo', encoding: 'bar') # Raises ArgumentError.
  #
  # With optional keyword argument `capacity`, returns a copy of `string` (or an
  # empty string, if `string` is not given); the given `capacity` is advisory
  # only, and may or may not set the size of the internal buffer, which may in
  # turn affect performance:
  #
  #     String.new(capacity: 1)
  #     String.new('foo', capacity: 4096)
  #
  # Note that Ruby strings are null-terminated internally, so the internal buffer
  # size will be one or more bytes larger than the requested capacity depending on
  # the encoding.
  #
  # The `string`, `encoding`, and `capacity` arguments may all be used together:
  #
  #     String.new('hello', encoding: 'UTF-8', capacity: 25)
  #
  def initialize: (?string source, ?encoding: encoding, ?capacity: int) -> void

  # <!--
  #   rdoc-file=string.c
  #   - replace(other_string) -> self
  # -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  alias initialize_copy replace

  # <!--
  #   rdoc-file=string.c
  #   - string % object -> new_string
  # -->
  # Returns the result of formatting `object` into the format specification `self`
  # (see Kernel#sprintf for formatting details):
  #
  #     "%05d" % 123 # => "00123"
  #
  # If `self` contains multiple substitutions, `object` must be an Array or Hash
  # containing the values to be substituted:
  #
  #     "%-5s: %016x" % [ "ID", self.object_id ] # => "ID   : 00002b054ec93168"
  #     "foo = %{foo}" % {foo: 'bar'} # => "foo = bar"
  #     "foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'} # => "foo = bar, baz = bat"
  #
  def %: (array[untyped] positional_args) -> String
       | (hash[Symbol, untyped] named_args) -> String
       | (untyped arg) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string * integer -> new_string
  # -->
  # Returns a new `String` containing `integer` copies of `self`:
  #
  #     "Ho! " * 3 # => "Ho! Ho! Ho! "
  #     "Ho! " * 0 # => ""
  #
  def *: (int amount) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string + other_string -> new_string
  # -->
  # Returns a new `String` containing `other_string` concatenated to `self`:
  #
  #     "Hello from " + self.to_s # => "Hello from main"
  #
  def +: (string other_string) -> String

  # <!--
  #   rdoc-file=string.c
  #   - +string -> new_string or self
  # -->
  # Returns `self` if `self` is not frozen and can be mutated without warning
  # issuance.
  #
  # Otherwise returns `self.dup`, which is not frozen.
  #
  def +@: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - -string -> frozen_string
  #   - dedup -> frozen_string
  # -->
  # Returns a frozen, possibly pre-existing copy of the string.
  #
  # The returned `String` will be deduplicated as long as it does not have any
  # instance variables set on it and is not a String subclass.
  #
  # Note that `-string` variant is more convenient for defining constants:
  #
  #     FILENAME = -'config/database.yml'
  #
  # while `dedup` is better suitable for using the method in chains of
  # calculations:
  #
  #     @url_list.concat(urls.map(&:dedup))
  #
  def -@: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - string << object -> string
  # -->
  # Concatenates `object` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s << 'bar' # => "foobar"
  #     s          # => "foobar"
  #
  # If `object` is an Integer, the value is considered a codepoint and converted
  # to a character before concatenation:
  #
  #     s = 'foo'
  #     s << 33 # => "foo!"
  #
  # If that codepoint is not representable in the encoding of *string*, RangeError
  # is raised.
  #
  #     s = 'foo'
  #     s.encoding              # => <Encoding:UTF-8>
  #     s << 0x00110000         # 1114112 out of char range (RangeError)
  #     s = 'foo'.encode('EUC-JP')
  #     s << 0x00800080         # invalid codepoint 0x800080 in EUC-JP (RangeError)
  #
  # If the encoding is US-ASCII and the codepoint is 0..0xff, *string* is
  # automatically promoted to ASCII-8BIT.
  #
  #     s = 'foo'.encode('US-ASCII')
  #     s << 0xff
  #     s.encoding              # => #<Encoding:BINARY (ASCII-8BIT)>
  #
  # Related: String#concat, which takes multiple arguments.
  #
  def <<: (string | Integer str_or_codepoint) -> self

  # <!--
  #   rdoc-file=string.c
  #   - string <=> other_string -> -1, 0, 1, or nil
  # -->
  # Compares `self` and `other_string`, returning:
  #
  # *   -1 if `other_string` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string` is smaller.
  # *   `nil` if the two are incomparable.
  #
  # Examples:
  #
  #     'foo' <=> 'foo' # => 0
  #     'foo' <=> 'food' # => -1
  #     'food' <=> 'foo' # => 1
  #     'FOO' <=> 'foo' # => -1
  #     'foo' <=> 'FOO' # => 1
  #     'foo' <=> 1 # => nil
  #
  def <=>: (string) -> (-1 | 0 | 1)
         | (untyped) -> (-1 | 0 | 1)?

  # <!--
  #   rdoc-file=string.c
  #   - string == object -> true or false
  #   - string === object -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of `String` but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  def ==: (untyped other) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of `String` but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  alias === ==

  # <!--
  #   rdoc-file=string.c
  #   - string =~ regexp -> integer or nil
  #   - string =~ object -> integer or nil
  # -->
  # Returns the Integer index of the first substring that matches the given
  # `regexp`, or `nil` if no match found:
  #
  #     'foo' =~ /f/ # => 0
  #     'foo' =~ /o/ # => 1
  #     'foo' =~ /x/ # => nil
  #
  # Note: also updates Regexp@Global+Variables.
  #
  # If the given `object` is not a Regexp, returns the value returned by `object
  # =~ self`.
  #
  # Note that `string =~ regexp` is different from `regexp =~ string` (see
  # Regexp#=~):
  #
  #     number= nil
  #     "no. 9" =~ /(?<number>\d+)/
  #     number # => nil (not assigned)
  #     /(?<number>\d+)/ =~ "no. 9"
  #     number #=> "9"
  #
  def =~: (Regexp regex) -> Integer?
        | [T] (_MatchAgainst[self, T] object) -> T

  interface _MatchAgainst[O, T]
    def =~: (O string) -> T
  end

  # <!--
  #   rdoc-file=string.c
  #   - string[index] -> new_string or nil
  #   - string[start, length] -> new_string or nil
  #   - string[range] -> new_string or nil
  #   - string[regexp, capture = 0] -> new_string or nil
  #   - string[substring] -> new_string or nil
  # -->
  # Returns the substring of `self` specified by the arguments. See examples at
  # [String Slices](rdoc-ref:String@String+Slices).
  #
  def []: (int start, ?int length) -> String?
        | (range[int?] range) -> String?
        | (Regexp regexp, ?MatchData::capture backref) -> String?
        | (String substring) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - string[index] = new_string
  #   - string[start, length] = new_string
  #   - string[range] = new_string
  #   - string[regexp, capture = 0] = new_string
  #   - string[substring] = new_string
  # -->
  # Replaces all, some, or none of the contents of `self`; returns `new_string`.
  # See [String Slices](rdoc-ref:String@String+Slices).
  #
  # A few examples:
  #
  #     s = 'foo'
  #     s[2] = 'rtune'     # => "rtune"
  #     s                  # => "fortune"
  #     s[1, 5] = 'init'   # => "init"
  #     s                  # => "finite"
  #     s[3..4] = 'al'     # => "al"
  #     s                  # => "finale"
  #     s[/e$/] = 'ly'     # => "ly"
  #     s                  # => "finally"
  #     s['lly'] = 'ncial' # => "ncial"
  #     s                  # => "financial"
  #
  def []=: [T < _ToStr] (int index, T replacement) -> T
         | [T < _ToStr] (int start, int length, T replacement) -> T
         | [T < _ToStr] (range[int?] range, T replacement) -> T
         | [T < _ToStr] (Regexp regexp, T replacement) -> T
         | [T < _ToStr] (Regexp regexp, MatchData::capture backref, T replacement) -> T
         | [T < _ToStr] (String substring, T replacement) -> T

  # <!--
  #   rdoc-file=string.c
  #   - append_as_bytes(*objects) -> string
  # -->
  # Concatenates each object in `objects` into `self` without any encoding
  # validation or conversion and returns `self`:
  #
  #     s = 'foo'
  #     s.append_as_bytes(" \xE2\x82")  # => "foo \xE2\x82"
  #     s.valid_encoding?               # => false
  #     s.append_as_bytes("\xAC 12")
  #     s.valid_encoding?               # => true
  #
  # For each given object `object` that is an Integer, the value is considered a
  # Byte. If the Integer is bigger than one byte, only the lower byte is
  # considered, similar to String#setbyte:
  #
  #     s = ""
  #     s.append_as_bytes(0, 257)             # =>  "\u0000\u0001"
  #
  # Related: String#<<, String#concat, which do an encoding aware concatenation.
  #
  def append_as_bytes: (String) -> String

  # <!--
  #   rdoc-file=string.c
  #   - ascii_only? -> true or false
  # -->
  # Returns `true` if `self` contains only ASCII characters, `false` otherwise:
  #
  #     'abc'.ascii_only?         # => true
  #     "abc\u{6666}".ascii_only? # => false
  #
  def ascii_only?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - b -> string
  # -->
  # Returns a copy of `self` that has ASCII-8BIT encoding; the underlying bytes
  # are not modified:
  #
  #     s = "\x99"
  #     s.encoding   # => #<Encoding:UTF-8>
  #     t = s.b      # => "\x99"
  #     t.encoding   # => #<Encoding:ASCII-8BIT>
  #
  #     s = "\u4095" # => ""
  #     s.encoding   # => #<Encoding:UTF-8>
  #     s.bytes      # => [228, 130, 149]
  #     t = s.b      # => "\xE4\x82\x95"
  #     t.encoding   # => #<Encoding:ASCII-8BIT>
  #     t.bytes      # => [228, 130, 149]
  #
  def b: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - byteindex(substring, offset = 0) -> integer or nil
  #   - byteindex(regexp, offset = 0) -> integer or nil
  # -->
  # Returns the Integer byte-based index of the first occurrence of the given
  # `substring`, or `nil` if none found:
  #
  #     'foo'.byteindex('f') # => 0
  #     'foo'.byteindex('o') # => 1
  #     'foo'.byteindex('oo') # => 1
  #     'foo'.byteindex('ooo') # => nil
  #
  # Returns the Integer byte-based index of the first match for the given Regexp
  # `regexp`, or `nil` if none found:
  #
  #     'foo'.byteindex(/f/) # => 0
  #     'foo'.byteindex(/o/) # => 1
  #     'foo'.byteindex(/oo/) # => 1
  #     'foo'.byteindex(/ooo/) # => nil
  #
  # Integer argument `offset`, if given, specifies the byte-based position in the
  # string to begin the search:
  #
  #     'foo'.byteindex('o', 1) # => 1
  #     'foo'.byteindex('o', 2) # => 2
  #     'foo'.byteindex('o', 3) # => nil
  #
  # If `offset` is negative, counts backward from the end of `self`:
  #
  #     'foo'.byteindex('o', -1) # => 2
  #     'foo'.byteindex('o', -2) # => 1
  #     'foo'.byteindex('o', -3) # => 1
  #     'foo'.byteindex('o', -4) # => nil
  #
  # If `offset` does not land on character (codepoint) boundary, `IndexError` is
  # raised.
  #
  # Related: String#index, String#byterindex.
  #
  def byteindex: (Regexp | string pattern, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - byterindex(substring, offset = self.bytesize) -> integer or nil
  #   - byterindex(regexp, offset = self.bytesize) -> integer or nil
  # -->
  # Returns the Integer byte-based index of the *last* occurrence of the given
  # `substring`, or `nil` if none found:
  #
  #     'foo'.byterindex('f') # => 0
  #     'foo'.byterindex('o') # => 2
  #     'foo'.byterindex('oo') # => 1
  #     'foo'.byterindex('ooo') # => nil
  #
  # Returns the Integer byte-based index of the *last* match for the given Regexp
  # `regexp`, or `nil` if none found:
  #
  #     'foo'.byterindex(/f/) # => 0
  #     'foo'.byterindex(/o/) # => 2
  #     'foo'.byterindex(/oo/) # => 1
  #     'foo'.byterindex(/ooo/) # => nil
  #
  # The *last* match means starting at the possible last position, not the last of
  # longest matches.
  #
  #     'foo'.byterindex(/o+/) # => 2
  #     $~ #=> #<MatchData "o">
  #
  # To get the last longest match, needs to combine with negative lookbehind.
  #
  #     'foo'.byterindex(/(?<!o)o+/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Or String#byteindex with negative lookforward.
  #
  #     'foo'.byteindex(/o+(?!.*o)/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Integer argument `offset`, if given and non-negative, specifies the maximum
  # starting byte-based position in the string to *end* the search:
  #
  #     'foo'.byterindex('o', 0) # => nil
  #     'foo'.byterindex('o', 1) # => 1
  #     'foo'.byterindex('o', 2) # => 2
  #     'foo'.byterindex('o', 3) # => 2
  #
  # If `offset` is a negative Integer, the maximum starting position in the string
  # to *end* the search is the sum of the string's length and `offset`:
  #
  #     'foo'.byterindex('o', -1) # => 2
  #     'foo'.byterindex('o', -2) # => 1
  #     'foo'.byterindex('o', -3) # => nil
  #     'foo'.byterindex('o', -4) # => nil
  #
  # If `offset` does not land on character (codepoint) boundary, `IndexError` is
  # raised.
  #
  # Related: String#byteindex.
  #
  def byterindex: (Regexp | string pattern, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - bytes -> array_of_bytes
  # -->
  # Returns an array of the bytes in `self`:
  #
  #     'hello'.bytes # => [104, 101, 108, 108, 111]
  #     ''.bytes  # => [209, 130, 208, 181, 209, 129, 209, 130]
  #     ''.bytes
  #     # => [227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175]
  #
  def bytes: () -> Array[Integer]
           | () { (Integer byte) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - bytesize -> integer
  # -->
  # Returns the count of bytes (not characters) in `self`:
  #
  #     'foo'.bytesize        # => 3
  #     ''.bytesize       # => 8
  #     ''.bytesize   # => 15
  #
  # Contrast with String#length:
  #
  #     'foo'.length       # => 3
  #     ''.length      # => 4
  #     ''.length  # => 5
  #
  def bytesize: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - byteslice(index, length = 1) -> string or nil
  #   - byteslice(range)             -> string or nil
  # -->
  # Returns a substring of `self`, or `nil` if the substring cannot be
  # constructed.
  #
  # With integer arguments `index` and `length` given, returns the substring
  # beginning at the given `index` of the given `length` (if possible), or `nil`
  # if `length` is negative or `index` falls outside of `self`:
  #
  #     s = '0123456789' # => "0123456789"
  #     s.byteslice(2)   # => "2"
  #     s.byteslice(200) # => nil
  #     s.byteslice(4, 3)  # => "456"
  #     s.byteslice(4, 30) # => "456789"
  #     s.byteslice(4, -1) # => nil
  #     s.byteslice(40, 2) # => nil
  #
  # In either case above, counts backwards from the end of `self` if `index` is
  # negative:
  #
  #     s = '0123456789'   # => "0123456789"
  #     s.byteslice(-4)    # => "6"
  #     s.byteslice(-4, 3) # => "678"
  #
  # With Range argument `range` given, returns `byteslice(range.begin,
  # range.size)`:
  #
  #     s = '0123456789'    # => "0123456789"
  #     s.byteslice(4..6)   # => "456"
  #     s.byteslice(-6..-4) # => "456"
  #     s.byteslice(5..2)   # => "" # range.size is zero.
  #     s.byteslice(40..42) # => nil
  #
  # In all cases, a returned string has the same encoding as `self`:
  #
  #     s.encoding              # => #<Encoding:UTF-8>
  #     s.byteslice(4).encoding # => #<Encoding:UTF-8>
  #
  def byteslice: (int start, ?int length) -> String?
               | (range[int?] range) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - bytesplice(index, length, str) -> string
  #   - bytesplice(index, length, str, str_index, str_length) -> string
  #   - bytesplice(range, str) -> string
  #   - bytesplice(range, str, str_range) -> string
  # -->
  # Replaces some or all of the content of `self` with `str`, and returns `self`.
  # The portion of the string affected is determined using the same criteria as
  # String#byteslice, except that `length` cannot be omitted. If the replacement
  # string is not the same length as the text it is replacing, the string will be
  # adjusted accordingly.
  #
  # If `str_index` and `str_length`, or `str_range` are given, the content of
  # `self` is replaced by str.byteslice(str_index, str_length) or
  # str.byteslice(str_range); however the substring of `str` is not allocated as a
  # new string.
  #
  # The form that take an Integer will raise an IndexError if the value is out of
  # range; the Range form will raise a RangeError. If the beginning or ending
  # offset does not land on character (codepoint) boundary, an IndexError will be
  # raised.
  #
  def bytesplice: (Integer start, int length, string str) -> String
                | (int start, int length, string str, int str_start, int str_length) -> String
                | (range[int?] range, string str, ?range[int?] str_range) -> String

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> string
  # -->
  # Returns a string containing the characters in `self`; the first character is
  # upcased; the remaining characters are downcased:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize       # => "Hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#capitalize!.
  #
  def capitalize: () -> String
                | (:ascii | :lithuanian | :turkic) -> String
                | (:lithuanian, :turkic) -> String
                | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - capitalize!(*options) -> self or nil
  # -->
  # Upcases the first character in `self`; downcases the remaining characters;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize!      # => "Hello world!"
  #     s                  # => "Hello world!"
  #     s.capitalize!      # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#capitalize.
  #
  def capitalize!: () -> self?
                 | (:ascii | :lithuanian | :turkic) -> self?
                 | (:lithuanian, :turkic) -> self?
                 | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(other_string) -> -1, 0, 1, or nil
  # -->
  # Compares `self.downcase` and `other_string.downcase`; returns:
  #
  # *   -1 if `other_string.downcase` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string.downcase` is smaller.
  # *   `nil` if the two are incomparable.
  #
  # Examples:
  #
  #     'foo'.casecmp('foo') # => 0
  #     'foo'.casecmp('food') # => -1
  #     'food'.casecmp('foo') # => 1
  #     'FOO'.casecmp('foo') # => 0
  #     'foo'.casecmp('FOO') # => 0
  #     'foo'.casecmp(1) # => nil
  #
  # See [Case Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#casecmp?.
  #
  def casecmp: (string other) -> (-1 | 0 | 1)
             | (untyped) -> (-1 | 0 | 1)?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(other_string) -> true, false, or nil
  # -->
  # Returns `true` if `self` and `other_string` are equal after Unicode case
  # folding, otherwise `false`:
  #
  #     'foo'.casecmp?('foo') # => true
  #     'foo'.casecmp?('food') # => false
  #     'food'.casecmp?('foo') # => false
  #     'FOO'.casecmp?('foo') # => true
  #     'foo'.casecmp?('FOO') # => true
  #
  # Returns `nil` if the two values are incomparable:
  #
  #     'foo'.casecmp?(1) # => nil
  #
  # See [Case Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#casecmp.
  #
  def casecmp?: (string other) -> bool
              | (untyped) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - center(size, pad_string = ' ') -> new_string
  # -->
  # Returns a centered copy of `self`.
  #
  # If integer argument `size` is greater than the size (in characters) of `self`,
  # returns a new string of length `size` that is a copy of `self`, centered and
  # padded on both ends with `pad_string`:
  #
  #     'hello'.center(10)       # => "  hello   "
  #     '  hello'.center(10)     # => "   hello  "
  #     'hello'.center(10, 'ab') # => "abhelloaba"
  #     ''.center(10)        # => "      "
  #     ''.center(10)    # => "     "
  #
  # If `size` is not greater than the size of `self`, returns a copy of `self`:
  #
  #     'hello'.center(5)  # => "hello"
  #     'hello'.center(1)  # => "hello"
  #
  # Related: String#ljust, String#rjust.
  #
  def center: (int width, ?string pad_string) -> String

  # <!--
  #   rdoc-file=string.c
  #   - chars -> array_of_characters
  # -->
  # Returns an array of the characters in `self`:
  #
  #     'hello'.chars     # => ["h", "e", "l", "l", "o"]
  #     ''.chars      # => ["", "", "", ""]
  #     ''.chars # => ["", "", "", "", ""]
  #
  def chars: () -> Array[String]
           | () { (String char) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - chomp(line_sep = $/) -> new_string
  # -->
  # Returns a new string copied from `self`, with trailing characters possibly
  # removed:
  #
  # When `line_sep` is `"\n"`, removes the last one or two characters if they are
  # `"\r"`, `"\n"`, or `"\r\n"` (but not `"\n\r"`):
  #
  #     $/                    # => "\n"
  #     "abc\r".chomp         # => "abc"
  #     "abc\n".chomp         # => "abc"
  #     "abc\r\n".chomp       # => "abc"
  #     "abc\n\r".chomp       # => "abc\n"
  #     "\r\n".chomp      # => ""
  #     "\r\n".chomp  # => ""
  #
  # When `line_sep` is `''` (an empty string), removes multiple trailing
  # occurrences of `"\n"` or `"\r\n"` (but not `"\r"` or `"\n\r"`):
  #
  #     "abc\n\n\n".chomp('')           # => "abc"
  #     "abc\r\n\r\n\r\n".chomp('')     # => "abc"
  #     "abc\n\n\r\n\r\n\n\n".chomp('') # => "abc"
  #     "abc\n\r\n\r\n\r".chomp('')     # => "abc\n\r\n\r\n\r"
  #     "abc\r\r\r".chomp('')           # => "abc\r\r\r"
  #
  # When `line_sep` is neither `"\n"` nor `''`, removes a single trailing line
  # separator if there is one:
  #
  #     'abcd'.chomp('d')  # => "abc"
  #     'abcdd'.chomp('d') # => "abcd"
  #
  def chomp: (?string? separator) -> String

  # <!--
  #   rdoc-file=string.c
  #   - chomp!(line_sep = $/) -> self or nil
  # -->
  # Like String#chomp, but modifies `self` in place; returns `nil` if no
  # modification made, `self` otherwise.
  #
  def chomp!: (nil) -> nil
          # | (?string separator) -> self? # https://github.com/ruby/rbs/pull/1672#discussion_r1423324796
            | (?string? separator) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - chop -> new_string
  # -->
  # Returns a new string copied from `self`, with trailing characters possibly
  # removed.
  #
  # Removes `"\r\n"` if those are the last two characters.
  #
  #     "abc\r\n".chop      # => "abc"
  #     "\r\n".chop     # => ""
  #     "\r\n".chop # => ""
  #
  # Otherwise removes the last character if it exists.
  #
  #     'abcd'.chop     # => "abc"
  #     ''.chop     # => ""
  #     ''.chop # => ""
  #     ''.chop         # => ""
  #
  # If you only need to remove the newline separator at the end of the string,
  # String#chomp is a better alternative.
  #
  def chop: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - chop! -> self or nil
  # -->
  # Like String#chop, but modifies `self` in place; returns `nil` if `self` is
  # empty, `self` otherwise.
  #
  # Related: String#chomp!.
  #
  def chop!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - chr -> string
  # -->
  # Returns a string containing the first character of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.chr     # => "f"
  #
  def chr: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - clear -> self
  # -->
  # Removes the contents of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.clear   # => ""
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - codepoints -> array_of_integers
  # -->
  # Returns an array of the codepoints in `self`; each codepoint is the integer
  # value for a character:
  #
  #     'hello'.codepoints     # => [104, 101, 108, 108, 111]
  #     ''.codepoints      # => [1090, 1077, 1089, 1090]
  #     ''.codepoints # => [12371, 12435, 12395, 12385, 12399]
  #
  def codepoints: () -> Array[Integer]
                | () { (Integer codepoint) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - concat(*objects) -> string
  # -->
  # Concatenates each object in `objects` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.concat('bar', 'baz') # => "foobarbaz"
  #     s                      # => "foobarbaz"
  #
  # For each given object `object` that is an Integer, the value is considered a
  # codepoint and converted to a character before concatenation:
  #
  #     s = 'foo'
  #     s.concat(32, 'bar', 32, 'baz') # => "foo bar baz"
  #
  # Related: String#<<, which takes a single argument.
  #
  def concat: (*string | Integer string_or_codepoints) -> self

  # <!--
  #   rdoc-file=string.c
  #   - count(*selectors) -> integer
  # -->
  # Returns the total number of characters in `self` that are specified by the
  # given `selectors` (see [Multiple Character
  # Selectors](rdoc-ref:character_selectors.rdoc@Multiple+Character+Selectors)):
  #
  #     a = "hello world"
  #     a.count "lo"                   #=> 5
  #     a.count "lo", "o"              #=> 2
  #     a.count "hello", "^l"          #=> 4
  #     a.count "ej-m"                 #=> 4
  #
  #     "hello^world".count "\\^aeiou" #=> 4
  #     "hello-world".count "a\\-eo"   #=> 4
  #
  #     c = "hello world\\r\\n"
  #     c.count "\\"                   #=> 2
  #     c.count "\\A"                  #=> 0
  #     c.count "X-\\w"                #=> 3
  #
  def count: (selector selector_0, *selector more_selectors) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - crypt(salt_str) -> new_string
  # -->
  # Returns the string generated by calling `crypt(3)` standard library function
  # with `str` and `salt_str`, in this order, as its arguments.  Please do not use
  # this method any longer.  It is legacy; provided only for backward
  # compatibility with ruby scripts in earlier days.  It is bad to use in
  # contemporary programs for several reasons:
  #
  # *   Behaviour of C's `crypt(3)` depends on the OS it is run.  The generated
  #     string lacks data portability.
  #
  # *   On some OSes such as Mac OS, `crypt(3)` never fails (i.e. silently ends up
  #     in unexpected results).
  #
  # *   On some OSes such as Mac OS, `crypt(3)` is not thread safe.
  #
  # *   So-called "traditional" usage of `crypt(3)` is very very very weak.
  #     According to its manpage, Linux's traditional `crypt(3)` output has only
  #     2**56 variations; too easy to brute force today.  And this is the default
  #     behaviour.
  #
  # *   In order to make things robust some OSes implement so-called "modular"
  #     usage. To go through, you have to do a complex build-up of the `salt_str`
  #     parameter, by hand. Failure in generation of a proper salt string tends
  #     not to yield any errors; typos in parameters are normally not detectable.
  #
  #     *   For instance, in the following example, the second invocation of
  #         String#crypt is wrong; it has a typo in "round=" (lacks "s").  However
  #         the call does not fail and something unexpected is generated.
  #
  #             "foo".crypt("$5$rounds=1000$salt$") # OK, proper usage
  #             "foo".crypt("$5$round=1000$salt$")  # Typo not detected
  #
  # *   Even in the "modular" mode, some hash functions are considered archaic and
  #     no longer recommended at all; for instance module `$1$` is officially
  #     abandoned by its author: see http://phk.freebsd.dk/sagas/md5crypt_eol/ .
  #     For another instance module `$3$` is considered completely broken: see the
  #     manpage of FreeBSD.
  #
  # *   On some OS such as Mac OS, there is no modular mode. Yet, as written
  #     above, `crypt(3)` on Mac OS never fails. This means even if you build up a
  #     proper salt string it generates a traditional DES hash anyways, and there
  #     is no way for you to be aware of.
  #
  #         "foo".crypt("$5$rounds=1000$salt$") # => "$5fNPQMxC5j6."
  #
  # If for some reason you cannot migrate to other secure contemporary password
  # hashing algorithms, install the string-crypt gem and `require 'string/crypt'`
  # to continue using it.
  #
  def crypt: (string salt_str) -> String

  # <!-- rdoc-file=string.c -->
  # Returns a frozen, possibly pre-existing copy of the string.
  #
  # The returned `String` will be deduplicated as long as it does not have any
  # instance variables set on it and is not a String subclass.
  #
  # Note that `-string` variant is more convenient for defining constants:
  #
  #     FILENAME = -'config/database.yml'
  #
  # while `dedup` is better suitable for using the method in chains of
  # calculations:
  #
  #     @url_list.concat(urls.map(&:dedup))
  #
  alias dedup -@

  # <!--
  #   rdoc-file=string.c
  #   - delete(*selectors) -> new_string
  # -->
  # Returns a copy of `self` with characters specified by `selectors` removed (see
  # [Multiple Character
  # Selectors](rdoc-ref:character_selectors.rdoc@Multiple+Character+Selectors)):
  #
  #     "hello".delete "l","lo"        #=> "heo"
  #     "hello".delete "lo"            #=> "he"
  #     "hello".delete "aeiou", "^e"   #=> "hell"
  #     "hello".delete "ej-m"          #=> "ho"
  #
  def delete: (selector selector_0, *selector more_selectors) -> String

  # <!--
  #   rdoc-file=string.c
  #   - delete!(*selectors) -> self or nil
  # -->
  # Like String#delete, but modifies `self` in place. Returns `self` if any
  # changes were made, `nil` otherwise.
  #
  def delete!: (selector selector_0, *selector more_selectors) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - delete_prefix(prefix) -> new_string
  # -->
  # Returns a copy of `self` with leading substring `prefix` removed:
  #
  #     'hello'.delete_prefix('hel')      # => "lo"
  #     'hello'.delete_prefix('llo')      # => "hello"
  #     ''.delete_prefix('')        # => ""
  #     ''.delete_prefix('')  # => ""
  #
  # Related: String#delete_prefix!, String#delete_suffix.
  #
  def delete_prefix: (string prefix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - delete_prefix!(prefix) -> self or nil
  # -->
  # Like String#delete_prefix, except that `self` is modified in place. Returns
  # `self` if the prefix is removed, `nil` otherwise.
  #
  def delete_prefix!: (string prefix) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - delete_suffix(suffix) -> new_string
  # -->
  # Returns a copy of `self` with trailing substring `suffix` removed:
  #
  #     'hello'.delete_suffix('llo')      # => "he"
  #     'hello'.delete_suffix('hel')      # => "hello"
  #     ''.delete_suffix('')        # => ""
  #     ''.delete_suffix('')  # => ""
  #
  # Related: String#delete_suffix!, String#delete_prefix.
  #
  def delete_suffix: (string suffix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - delete_suffix!(suffix) -> self or nil
  # -->
  # Like String#delete_suffix, except that `self` is modified in place. Returns
  # `self` if the suffix is removed, `nil` otherwise.
  #
  def delete_suffix!: (string suffix) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> string
  # -->
  # Returns a string containing the downcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase         # => "hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#downcase!, String#upcase, String#upcase!.
  #
  def downcase: () -> String
              | (:ascii | :fold | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - downcase!(*options) -> self or nil
  # -->
  # Downcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase!        # => "hello world!"
  #     s                  # => "hello world!"
  #     s.downcase!        # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#downcase, String#upcase, String#upcase!.
  #
  def downcase!: () -> self?
               | (:ascii | :fold | :lithuanian | :turkic) -> self?
               | (:lithuanian, :turkic) -> self?
               | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - dump -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, with special
  # characters escaped, and with non-printing characters replaced by hexadecimal
  # notation:
  #
  #     "hello \n ''".dump    # => "\"hello \\n ''\""
  #     "\f\x00\xff\\\"".dump # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #
  # Related: String#undump (inverse of String#dump).
  #
  def dump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - each_byte {|byte| ... } -> self
  #   - each_byte               -> enumerator
  # -->
  # Calls the given block with each successive byte from `self`; returns `self`:
  #
  #     'hello'.each_byte {|byte| print byte, ' ' }
  #     print "\n"
  #     ''.each_byte {|byte| print byte, ' ' }
  #     print "\n"
  #     ''.each_byte {|byte| print byte, ' ' }
  #     print "\n"
  #
  # Output:
  #
  #     104 101 108 108 111
  #     209 130 208 181 209 129 209 130
  #     227 129 147 227 130 147 227 129 171 227 129 161 227 129 175
  #
  # Returns an enumerator if no block is given.
  #
  def each_byte: () -> Enumerator[Integer, self]
               | () { (Integer byte) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - each_char {|c| ... } -> self
  #   - each_char            -> enumerator
  # -->
  # Calls the given block with each successive character from `self`; returns
  # `self`:
  #
  #     'hello'.each_char {|char| print char, ' ' }
  #     print "\n"
  #     ''.each_char {|char| print char, ' ' }
  #     print "\n"
  #     ''.each_char {|char| print char, ' ' }
  #     print "\n"
  #
  # Output:
  #
  #     h e l l o
  #        
  #         
  #
  # Returns an enumerator if no block is given.
  #
  def each_char: () -> Enumerator[String, self]
               | () { (String char) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - each_codepoint {|integer| ... } -> self
  #   - each_codepoint                  -> enumerator
  # -->
  # Calls the given block with each successive codepoint from `self`; each
  # codepoint is the integer value for a character; returns `self`:
  #
  #     'hello'.each_codepoint {|codepoint| print codepoint, ' ' }
  #     print "\n"
  #     ''.each_codepoint {|codepoint| print codepoint, ' ' }
  #     print "\n"
  #     ''.each_codepoint {|codepoint| print codepoint, ' ' }
  #     print "\n"
  #
  # Output:
  #
  #     104 101 108 108 111
  #     1090 1077 1089 1090
  #     12371 12435 12395 12385 12399
  #
  # Returns an enumerator if no block is given.
  #
  def each_codepoint: () -> Enumerator[Integer, self]
                    | () { (Integer codepoint) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - each_grapheme_cluster {|gc| ... } -> self
  #   - each_grapheme_cluster             -> enumerator
  # -->
  # Calls the given block with each successive grapheme cluster from `self` (see
  # [Unicode Grapheme Cluster
  # Boundaries](https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)
  # ); returns `self`:
  #
  #     s = "\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308" # => "a-pqr-b-xyz-c"
  #     s.each_grapheme_cluster {|gc| print gc, ' ' }
  #
  # Output:
  #
  #     a - p q r - b - x y z - c
  #
  # Returns an enumerator if no block is given.
  #
  def each_grapheme_cluster: () -> Enumerator[String, self]
                           | () { (String grapheme_cluter) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - each_line(line_sep = $/, chomp: false) {|substring| ... } -> self
  #   - each_line(line_sep = $/, chomp: false)                    -> enumerator
  # -->
  # With a block given, forms the substrings ("lines") that are the result of
  # splitting `self` at each occurrence of the given line separator `line_sep`;
  # passes each line to the block; returns `self`:
  #
  #     s = <<~EOT
  #     This is the first line.
  #     This is line two.
  #
  #     This is line four.
  #     This is line five.
  #     EOT
  #
  #     s.each_line {|line| p line }
  #
  # Output:
  #
  #     "This is the first line.\n"
  #     "This is line two.\n"
  #     "\n"
  #     "This is line four.\n"
  #     "This is line five.\n"
  #
  # With a different `line_sep`:
  #
  #     s.each_line(' is ') {|line| p line }
  #
  # Output:
  #
  #     "This is "
  #     "the first line.\nThis is "
  #     "line two.\n\nThis is "
  #     "line four.\nThis is "
  #     "line five.\n"
  #
  # With `chomp` as `true`, removes the trailing `line_sep` from each line:
  #
  #     s.each_line(chomp: true) {|line| p line }
  #
  # Output:
  #
  #     "This is the first line."
  #     "This is line two."
  #     ""
  #     "This is line four."
  #     "This is line five."
  #
  # With an empty string as `line_sep`, forms and passes "paragraphs" by splitting
  # at each occurrence of two or more newlines:
  #
  #     s.each_line('') {|line| p line }
  #
  # Output:
  #
  #     "This is the first line.\nThis is line two.\n\n"
  #     "This is line four.\nThis is line five.\n"
  #
  # With no block given, returns an enumerator.
  #
  def each_line: (?string? separator, ?chomp: boolish) -> Enumerator[String, self]
               | (?string? separator, ?chomp: boolish) { (String line) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - empty? -> true or false
  # -->
  # Returns `true` if the length of `self` is zero, `false` otherwise:
  #
  #     "hello".empty? # => false
  #     " ".empty? # => false
  #     "".empty? # => true
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=transcode.c
  #   - encode(dst_encoding = Encoding.default_internal, **enc_opts) -> string
  #   - encode(dst_encoding, src_encoding, **enc_opts)   -> string
  # -->
  # Returns a copy of `self` transcoded as determined by `dst_encoding`. By
  # default, raises an exception if `self` contains an invalid byte or a character
  # not defined in `dst_encoding`; that behavior may be modified by encoding
  # options; see below.
  #
  # With no arguments:
  #
  # *   Uses the same encoding if `Encoding.default_internal` is `nil` (the
  #     default):
  #
  #         Encoding.default_internal # => nil
  #         s = "Ruby\x99".force_encoding('Windows-1252')
  #         s.encoding                # => #<Encoding:Windows-1252>
  #         s.bytes                   # => [82, 117, 98, 121, 153]
  #         t = s.encode              # => "Ruby\x99"
  #         t.encoding                # => #<Encoding:Windows-1252>
  #         t.bytes                   # => [82, 117, 98, 121, 226, 132, 162]
  #
  # *   Otherwise, uses the encoding `Encoding.default_internal`:
  #
  #         Encoding.default_internal = 'UTF-8'
  #         t = s.encode              # => "Ruby"
  #         t.encoding                # => #<Encoding:UTF-8>
  #
  # With only argument `dst_encoding` given, uses that encoding:
  #
  #     s = "Ruby\x99".force_encoding('Windows-1252')
  #     s.encoding            # => #<Encoding:Windows-1252>
  #     t = s.encode('UTF-8') # => "Ruby"
  #     t.encoding            # => #<Encoding:UTF-8>
  #
  # With arguments `dst_encoding` and `src_encoding` given, interprets `self`
  # using `src_encoding`, encodes the new string using `dst_encoding`:
  #
  #     s = "Ruby\x99"
  #     t = s.encode('UTF-8', 'Windows-1252') # => "Ruby"
  #     t.encoding                            # => #<Encoding:UTF-8>
  #
  # Optional keyword arguments `enc_opts` specify encoding options; see [Encoding
  # Options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  # Please note that, unless `invalid: :replace` option is given, conversion from
  # an encoding `enc` to the same encoding `enc` (independent of whether `enc` is
  # given explicitly or implicitly) is a no-op, i.e. the string is simply copied
  # without any changes, and no exceptions are raised, even if there are invalid
  # bytes.
  #
  def encode: (
    ?encoding source_encoding,
    ?encoding? from_encoding,
    ?invalid: :replace ?,
    ?undef: :replace ?,
    ?replace: string?,
    ?xml: (:text | :attr)?,
    ?newline: (:universal | :crlf | :cr | :lf)?,
    ?universal_newline: boolish,
    ?cr_newline: boolish,
    ?crlf_newline: boolish,
    ?lf_newline: boolish,
    ?fallback: ^(String) -> string? | Method | _EncodeFallbackAref
  ) -> instance

  interface _EncodeFallbackAref
    def []: (String) -> string?
  end

  # <!--
  #   rdoc-file=transcode.c
  #   - encode!(dst_encoding = Encoding.default_internal, **enc_opts) -> self
  #   - encode!(dst_encoding, src_encoding, **enc_opts)   -> self
  # -->
  # Like #encode, but applies encoding changes to `self`; returns `self`.
  #
  def encode!: (
    ?encoding source_encoding,
    ?encoding? from_encoding,
    ?invalid: :replace ?,
    ?undef: :replace ?,
    ?replace: string?,
    ?xml: (:text | :attr)?,
    ?newline: (:universal | :crlf | :cr | :lf)?,
    ?universal_newline: boolish,
    ?cr_newline: boolish,
    ?crlf_newline: boolish,
    ?lf_newline: boolish,
    ?fallback: ^(String) -> string? | Method | _EncodeFallbackAref
  ) -> self

  # <!--
  #   rdoc-file=string.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - end_with?(*strings) -> true or false
  # -->
  # Returns whether `self` ends with any of the given `strings`.
  #
  # Returns `true` if any given string matches the end, `false` otherwise:
  #
  #     'hello'.end_with?('ello')               #=> true
  #     'hello'.end_with?('heaven', 'ello')     #=> true
  #     'hello'.end_with?('heaven', 'paradise') #=> false
  #     ''.end_with?('')                   # => true
  #     ''.end_with?('')              # => true
  #
  # Related: String#start_with?.
  #
  def end_with?: (*string suffixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - eql?(object) -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s.eql?('foo') # => true
  #     s.eql?('food') # => false
  #     s.eql?('FOO') # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #
  #     "\u{e4 f6 fc}".encode("ISO-8859-1").eql?("\u{c4 d6 dc}") # => false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - force_encoding(encoding) -> self
  # -->
  # Changes the encoding of `self` to `encoding`, which may be a string encoding
  # name or an Encoding object; returns self:
  #
  #     s = 'a'
  #     s.bytes                   # => [197, 130, 97, 197, 130]
  #     s.encoding                # => #<Encoding:UTF-8>
  #     s.force_encoding('ascii') # => "\xC5\x82a\xC5\x82"
  #     s.encoding                # => #<Encoding:US-ASCII>
  #
  # Does not change the underlying bytes:
  #
  #     s.bytes                   # => [197, 130, 97, 197, 130]
  #
  # Makes the change even if the given `encoding` is invalid for `self` (as is the
  # change above):
  #
  #     s.valid_encoding?                 # => false
  #     s.force_encoding(Encoding::UTF_8) # => "a"
  #     s.valid_encoding?                 # => true
  #
  def force_encoding: (encoding enc) -> self

  # <!--
  #   rdoc-file=string.c
  #   - freeze()
  # -->
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - getbyte(index) -> integer or nil
  # -->
  # Returns the byte at zero-based `index` as an integer, or `nil` if `index` is
  # out of range:
  #
  #     s = 'abcde'   # => "abcde"
  #     s.getbyte(0)  # => 97
  #     s.getbyte(-1) # => 101
  #     s.getbyte(5)  # => nil
  #
  # Related: String#setbyte.
  #
  def getbyte: (int index) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - grapheme_clusters -> array_of_grapheme_clusters
  # -->
  # Returns an array of the grapheme clusters in `self` (see [Unicode Grapheme
  # Cluster
  # Boundaries](https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)
  # ):
  #
  #     s = "\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308" # => "a-pqr-b-xyz-c"
  #     s.grapheme_clusters
  #     # => ["a", "-", "p", "q", "r", "-", "b", "-", "x", "y", "z", "-", "c"]
  #
  def grapheme_clusters: () -> Array[String]
                       | () { (String grapheme_cluter) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - gsub(pattern, replacement)   -> new_string
  #   - gsub(pattern) {|match| ... } -> new_string
  #   - gsub(pattern)                -> enumerator
  # -->
  # Returns a copy of `self` with all occurrences of the given `pattern` replaced.
  #
  # See [Substitution Methods](rdoc-ref:String@Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#sub!, String#gsub!.
  #
  def gsub: (Regexp | string pattern, string | hash[String, _ToS] replacement) -> String
          | (Regexp | string pattern) -> Enumerator[String, String]
          | (Regexp | string pattern) { (String match) -> _ToS } -> String

  # <!--
  #   rdoc-file=string.c
  #   - gsub!(pattern, replacement)   -> self or nil
  #   - gsub!(pattern) {|match| ... } -> self or nil
  #   - gsub!(pattern)                -> an_enumerator
  # -->
  # Performs the specified substring replacement(s) on `self`; returns `self` if
  # any replacement occurred, `nil` otherwise.
  #
  # See [Substitution Methods](rdoc-ref:String@Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#gsub, String#sub!.
  #
  def gsub!: (Regexp | string pattern, string | hash[String, _ToS] replacement) -> self?
           | (Regexp | string pattern) -> Enumerator[String, self?]
           | (Regexp | string pattern) { (String match) -> _ToS } -> self?

  # <!--
  #   rdoc-file=string.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. The value is based on the length,
  # content and encoding of `self`.
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - hex -> integer
  # -->
  # Interprets the leading substring of `self` as a string of hexadecimal digits
  # (with an optional sign and an optional `0x`) and returns the corresponding
  # number; returns zero if there is no such leading substring:
  #
  #     '0x0a'.hex        # => 10
  #     '-1234'.hex       # => -4660
  #     '0'.hex           # => 0
  #     'non-numeric'.hex # => 0
  #
  # Related: String#oct.
  #
  def hex: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - include?(other_string) -> true or false
  # -->
  # Returns `true` if `self` contains `other_string`, `false` otherwise:
  #
  #     s = 'foo'
  #     s.include?('f')    # => true
  #     s.include?('fo')   # => true
  #     s.include?('food') # => false
  #
  def include?: (string other_string) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - index(substring, offset = 0) -> integer or nil
  #   - index(regexp, offset = 0) -> integer or nil
  # -->
  # Returns the integer index of the first match for the given argument, or `nil`
  # if none found; the search of `self` is forward, and begins at position
  # `offset` (in characters).
  #
  # With string argument `substring`, returns the index of the first matching
  # substring in `self`:
  #
  #     'foo'.index('f')         # => 0
  #     'foo'.index('o')         # => 1
  #     'foo'.index('oo')        # => 1
  #     'foo'.index('ooo')       # => nil
  #     ''.index('')        # => 2
  #     ''.index('')   # => 3
  #
  # With Regexp argument `regexp`, returns the index of the first match in `self`:
  #
  #     'foo'.index(/o./) # => 1
  #     'foo'.index(/.o/) # => 0
  #
  # With positive integer `offset`, begins the search at position `offset`:
  #
  #     'foo'.index('o', 1)        # => 1
  #     'foo'.index('o', 2)        # => 2
  #     'foo'.index('o', 3)        # => nil
  #     ''.index('', 1)       # => 2
  #     ''.index('', 2)  # => 3
  #
  # With negative integer `offset`, selects the search position by counting
  # backward from the end of `self`:
  #
  #     'foo'.index('o', -1)  # => 2
  #     'foo'.index('o', -2)  # => 1
  #     'foo'.index('o', -3)  # => 1
  #     'foo'.index('o', -4)  # => nil
  #     'foo'.index(/o./, -2) # => 1
  #     'foo'.index(/.o/, -2) # => 1
  #
  # Related: String#rindex.
  #
  def index: (Regexp | string pattern, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - insert(index, other_string) -> self
  # -->
  # Inserts the given `other_string` into `self`; returns `self`.
  #
  # If the Integer `index` is positive, inserts `other_string` at offset `index`:
  #
  #     'foo'.insert(1, 'bar') # => "fbaroo"
  #
  # If the Integer `index` is negative, counts backward from the end of `self` and
  # inserts `other_string` at offset `index+1` (that is, *after* `self[index]`):
  #
  #     'foo'.insert(-2, 'bar') # => "fobaro"
  #
  def insert: (int index, string other_str) -> self

  # <!--
  #   rdoc-file=string.c
  #   - inspect -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, and with
  # special characters escaped:
  #
  #     s = "foo\tbar\tbaz\n"
  #     s.inspect
  #     # => "\"foo\\tbar\\tbaz\\n\""
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.intern   -> symbol
  #   - str.to_sym   -> symbol
  # -->
  # Returns the `Symbol` corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  def intern: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - length -> integer
  # -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     'foo'.length        # => 3
  #     ''.length       # => 4
  #     ''.length   # => 5
  #
  # Contrast with String#bytesize:
  #
  #     'foo'.bytesize        # => 3
  #     ''.bytesize       # => 8
  #     ''.bytesize   # => 15
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - lines(Line_sep = $/, chomp: false) -> array_of_strings
  # -->
  # Forms substrings ("lines") of `self` according to the given arguments (see
  # String#each_line for details); returns the lines in an array.
  #
  def lines: (?string? separator, ?chomp: boolish) -> Array[String]
           | (?string? separator, ?chomp: boolish) { (String line) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - ljust(size, pad_string = ' ') -> new_string
  # -->
  # Returns a left-justified copy of `self`.
  #
  # If integer argument `size` is greater than the size (in characters) of `self`,
  # returns a new string of length `size` that is a copy of `self`, left justified
  # and padded on the right with `pad_string`:
  #
  #     'hello'.ljust(10)       # => "hello     "
  #     '  hello'.ljust(10)     # => "  hello   "
  #     'hello'.ljust(10, 'ab') # => "helloababa"
  #     ''.ljust(10)        # => "      "
  #     ''.ljust(10)    # => "     "
  #
  # If `size` is not greater than the size of `self`, returns a copy of `self`:
  #
  #     'hello'.ljust(5)  # => "hello"
  #     'hello'.ljust(1)  # => "hello"
  #
  # Related: String#rjust, String#center.
  #
  def ljust: (int size, ?string pad_string) -> String

  # <!--
  #   rdoc-file=string.c
  #   - lstrip -> new_string
  # -->
  # Returns a copy of `self` with leading whitespace removed; see [Whitespace in
  # Strings](rdoc-ref:String@Whitespace+in+Strings):
  #
  #     whitespace = "\x00\t\n\v\f\r "
  #     s = whitespace + 'abc' + whitespace
  #     s        # => "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
  #     s.lstrip # => "abc\u0000\t\n\v\f\r "
  #
  # Related: String#rstrip, String#strip.
  #
  def lstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - lstrip! -> self or nil
  # -->
  # Like String#lstrip, except that any modifications are made in `self`; returns
  # `self` if any modification are made, `nil` otherwise.
  #
  # Related: String#rstrip!, String#strip!.
  #
  def lstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - match(pattern, offset = 0) -> matchdata or nil
  #   - match(pattern, offset = 0) {|matchdata| ... } -> object
  # -->
  # Returns a MatchData object (or `nil`) based on `self` and the given `pattern`.
  #
  # Note: also updates Regexp@Global+Variables.
  #
  # *   Computes `regexp` by converting `pattern` (if not already a Regexp).
  #         regexp = Regexp.new(pattern)
  #
  # *   Computes `matchdata`, which will be either a MatchData object or `nil`
  #     (see Regexp#match):
  #         matchdata = <tt>regexp.match(self)
  #
  # With no block given, returns the computed `matchdata`:
  #
  #     'foo'.match('f') # => #<MatchData "f">
  #     'foo'.match('o') # => #<MatchData "o">
  #     'foo'.match('x') # => nil
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #
  #     'foo'.match('f', 1) # => nil
  #     'foo'.match('o', 1) # => #<MatchData "o">
  #
  # With a block given, calls the block with the computed `matchdata` and returns
  # the block's return value:
  #
  #     'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
  #     'foo'.match(/x/) {|matchdata| matchdata } # => nil
  #     'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil
  #
  def match: (Regexp | string pattern, ?int offset) -> MatchData?
           | [T] (Regexp | string pattern, ?int offset) { (MatchData matchdata) -> T } -> T?

  # <!--
  #   rdoc-file=string.c
  #   - match?(pattern, offset = 0) -> true or false
  # -->
  # Returns `true` or `false` based on whether a match is found for `self` and
  # `pattern`.
  #
  # Note: does not update Regexp@Global+Variables.
  #
  # Computes `regexp` by converting `pattern` (if not already a Regexp).
  #     regexp = Regexp.new(pattern)
  #
  # Returns `true` if `self+.match(regexp)` returns a MatchData object, `false`
  # otherwise:
  #
  #     'foo'.match?(/o/) # => true
  #     'foo'.match?('o') # => true
  #     'foo'.match?(/x/) # => false
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #     'foo'.match?('f', 1) # => false
  #     'foo'.match?('o', 1) # => true
  #
  def match?: (Regexp | string pattern, ?int offset) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty `String` is a new empty `String`:
  #
  #     ''.succ # => ""
  #
  alias next succ

  # <!-- rdoc-file=string.c -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  alias next! succ!

  # <!--
  #   rdoc-file=string.c
  #   - oct -> integer
  # -->
  # Interprets the leading substring of `self` as a string of octal digits (with
  # an optional sign) and returns the corresponding number; returns zero if there
  # is no such leading substring:
  #
  #     '123'.oct             # => 83
  #     '-377'.oct            # => -255
  #     '0377non-numeric'.oct # => 255
  #     'non-numeric'.oct     # => 0
  #
  # If `self` starts with `0`, radix indicators are honored; see Kernel#Integer.
  #
  # Related: String#hex.
  #
  def oct: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - ord -> integer
  # -->
  # Returns the integer ordinal of the first character of `self`:
  #
  #     'h'.ord         # => 104
  #     'hello'.ord     # => 104
  #     ''.ord      # => 1090
  #     ''.ord  # => 12371
  #
  def ord: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - partition(string_or_regexp) -> [head, match, tail]
  # -->
  # Returns a 3-element array of substrings of `self`.
  #
  # Matches a pattern against `self`, scanning from the beginning. The pattern is:
  #
  # *   `string_or_regexp` itself, if it is a Regexp.
  # *   `Regexp.quote(string_or_regexp)`, if `string_or_regexp` is a string.
  #
  # If the pattern is matched, returns pre-match, first-match, post-match:
  #
  #     'hello'.partition('l')      # => ["he", "l", "lo"]
  #     'hello'.partition('ll')     # => ["he", "ll", "o"]
  #     'hello'.partition('h')      # => ["", "h", "ello"]
  #     'hello'.partition('o')      # => ["hell", "o", ""]
  #     'hello'.partition(/l+/)     #=> ["he", "ll", "o"]
  #     'hello'.partition('')       # => ["", "", "hello"]
  #     ''.partition('')       # => ["", "", ""]
  #     ''.partition('')  # => ["", "", ""]
  #
  # If the pattern is not matched, returns a copy of `self` and two empty strings:
  #
  #     'hello'.partition('x') # => ["hello", "", ""]
  #
  # Related: String#rpartition, String#split.
  #
  def partition: (Regexp | string pattern) -> [String, String, String]

  # <!--
  #   rdoc-file=string.c
  #   - prepend(*other_strings)  -> string
  # -->
  # Prepends each string in `other_strings` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.prepend('bar', 'baz') # => "barbazfoo"
  #     s                       # => "barbazfoo"
  #
  # Related: String#concat.
  #
  def prepend: (*string other_strings) -> self

  # <!-- rdoc-file=string.c -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  def replace: (string other_string) -> self

  # <!--
  #   rdoc-file=string.c
  #   - reverse -> string
  # -->
  # Returns a new string with the characters from `self` in reverse order.
  #
  #     'stressed'.reverse # => "desserts"
  #
  def reverse: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - reverse! -> self
  # -->
  # Returns `self` with its characters reversed:
  #
  #     s = 'stressed'
  #     s.reverse! # => "desserts"
  #     s          # => "desserts"
  #
  def reverse!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - rindex(substring, offset = self.length) -> integer or nil
  #   - rindex(regexp, offset = self.length) -> integer or nil
  # -->
  # Returns the Integer index of the *last* occurrence of the given `substring`,
  # or `nil` if none found:
  #
  #     'foo'.rindex('f') # => 0
  #     'foo'.rindex('o') # => 2
  #     'foo'.rindex('oo') # => 1
  #     'foo'.rindex('ooo') # => nil
  #
  # Returns the Integer index of the *last* match for the given Regexp `regexp`,
  # or `nil` if none found:
  #
  #     'foo'.rindex(/f/) # => 0
  #     'foo'.rindex(/o/) # => 2
  #     'foo'.rindex(/oo/) # => 1
  #     'foo'.rindex(/ooo/) # => nil
  #
  # The *last* match means starting at the possible last position, not the last of
  # longest matches.
  #
  #     'foo'.rindex(/o+/) # => 2
  #     $~ #=> #<MatchData "o">
  #
  # To get the last longest match, needs to combine with negative lookbehind.
  #
  #     'foo'.rindex(/(?<!o)o+/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Or String#index with negative lookforward.
  #
  #     'foo'.index(/o+(?!.*o)/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Integer argument `offset`, if given and non-negative, specifies the maximum
  # starting position in the string to *end* the search:
  #
  #     'foo'.rindex('o', 0) # => nil
  #     'foo'.rindex('o', 1) # => 1
  #     'foo'.rindex('o', 2) # => 2
  #     'foo'.rindex('o', 3) # => 2
  #
  # If `offset` is a negative Integer, the maximum starting position in the string
  # to *end* the search is the sum of the string's length and `offset`:
  #
  #     'foo'.rindex('o', -1) # => 2
  #     'foo'.rindex('o', -2) # => 1
  #     'foo'.rindex('o', -3) # => nil
  #     'foo'.rindex('o', -4) # => nil
  #
  # Related: String#index.
  #
  def rindex: (Regexp | string pattern, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - rjust(size, pad_string = ' ') -> new_string
  # -->
  # Returns a right-justified copy of `self`.
  #
  # If integer argument `size` is greater than the size (in characters) of `self`,
  # returns a new string of length `size` that is a copy of `self`, right
  # justified and padded on the left with `pad_string`:
  #
  #     'hello'.rjust(10)       # => "     hello"
  #     'hello  '.rjust(10)     # => "   hello  "
  #     'hello'.rjust(10, 'ab') # => "ababahello"
  #     ''.rjust(10)        # => "      "
  #     ''.rjust(10)    # => "     "
  #
  # If `size` is not greater than the size of `self`, returns a copy of `self`:
  #
  #     'hello'.rjust(5, 'ab')  # => "hello"
  #     'hello'.rjust(1, 'ab')  # => "hello"
  #
  # Related: String#ljust, String#center.
  #
  def rjust: (int size, ?string pad_string) -> String

  # <!--
  #   rdoc-file=string.c
  #   - rpartition(sep) -> [head, match, tail]
  # -->
  # Returns a 3-element array of substrings of `self`.
  #
  # Matches a pattern against `self`, scanning backwards from the end. The pattern
  # is:
  #
  # *   `string_or_regexp` itself, if it is a Regexp.
  # *   `Regexp.quote(string_or_regexp)`, if `string_or_regexp` is a string.
  #
  # If the pattern is matched, returns pre-match, last-match, post-match:
  #
  #     'hello'.rpartition('l')      # => ["hel", "l", "o"]
  #     'hello'.rpartition('ll')     # => ["he", "ll", "o"]
  #     'hello'.rpartition('h')      # => ["", "h", "ello"]
  #     'hello'.rpartition('o')      # => ["hell", "o", ""]
  #     'hello'.rpartition(/l+/)     # => ["hel", "l", "o"]
  #     'hello'.rpartition('')       # => ["hello", "", ""]
  #     ''.rpartition('')       # => ["", "", ""]
  #     ''.rpartition('')  # => ["", "", ""]
  #
  # If the pattern is not matched, returns two empty strings and a copy of `self`:
  #
  #     'hello'.rpartition('x') # => ["", "", "hello"]
  #
  # Related: String#partition, String#split.
  #
  def rpartition: (Regexp | string pattern) -> [String, String, String]

  # <!--
  #   rdoc-file=string.c
  #   - rstrip -> new_string
  # -->
  # Returns a copy of the receiver with trailing whitespace removed; see
  # [Whitespace in Strings](rdoc-ref:String@Whitespace+in+Strings):
  #
  #     whitespace = "\x00\t\n\v\f\r "
  #     s = whitespace + 'abc' + whitespace
  #     s        # => "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
  #     s.rstrip # => "\u0000\t\n\v\f\r abc"
  #
  # Related: String#lstrip, String#strip.
  #
  def rstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - rstrip! -> self or nil
  # -->
  # Like String#rstrip, except that any modifications are made in `self`; returns
  # `self` if any modification are made, `nil` otherwise.
  #
  # Related: String#lstrip!, String#strip!.
  #
  def rstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - scan(string_or_regexp) -> array
  #   - scan(string_or_regexp) {|matches| ... } -> self
  # -->
  # Matches a pattern against `self`; the pattern is:
  #
  # *   `string_or_regexp` itself, if it is a Regexp.
  # *   `Regexp.quote(string_or_regexp)`, if `string_or_regexp` is a string.
  #
  # Iterates through `self`, generating a collection of matching results:
  #
  # *   If the pattern contains no groups, each result is the matched string,
  #     `$&`.
  # *   If the pattern contains groups, each result is an array containing one
  #     entry per group.
  #
  # With no block given, returns an array of the results:
  #
  #     s = 'cruel world'
  #     s.scan(/\w+/)      # => ["cruel", "world"]
  #     s.scan(/.../)      # => ["cru", "el ", "wor"]
  #     s.scan(/(...)/)    # => [["cru"], ["el "], ["wor"]]
  #     s.scan(/(..)(..)/) # => [["cr", "ue"], ["l ", "wo"]]
  #
  # With a block given, calls the block with each result; returns `self`:
  #
  #     s.scan(/\w+/) {|w| print "<<#{w}>> " }
  #     print "\n"
  #     s.scan(/(.)(.)/) {|x,y| print y, x }
  #     print "\n"
  #
  # Output:
  #
  #     <<cruel>> <<world>>
  #     rceu lowlr
  #
  def scan: (Regexp pattern) -> Array[String | Array[String?]]
          | (Regexp pattern) { (String | Array[String?] matches) -> void } -> self
          | (string pattern) -> Array[String]
          | (string pattern) { (String match) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - scrub(replacement_string = default_replacement) -> new_string
  #   - scrub{|bytes| ... } -> new_string
  # -->
  # Returns a copy of `self` with each invalid byte sequence replaced by the given
  # `replacement_string`.
  #
  # With no block given and no argument, replaces each invalid sequence with the
  # default replacement string (`""` for a Unicode encoding, `'?'` otherwise):
  #
  #     s = "foo\x81\x81bar"
  #     s.scrub # => "foobar"
  #
  # With no block given and argument `replacement_string` given, replaces each
  # invalid sequence with that string:
  #
  #     "foo\x81\x81bar".scrub('xyzzy') # => "fooxyzzyxyzzybar"
  #
  # With a block given, replaces each invalid sequence with the value of the
  # block:
  #
  #     "foo\x81\x81bar".scrub {|bytes| p bytes; 'XYZZY' }
  #     # => "fooXYZZYXYZZYbar"
  #
  # Output:
  #
  #     "\x81"
  #     "\x81"
  #
  def scrub: (?string? replacement) -> String
           | (?nil) { (String bytes) -> string } -> String

  # <!--
  #   rdoc-file=string.c
  #   - scrub! -> self
  #   - scrub!(replacement_string = default_replacement) -> self
  #   - scrub!{|bytes| ... } -> self
  # -->
  # Like String#scrub, except that any replacements are made in `self`.
  #
  def scrub!: (?string? replacement) -> self
            | (?nil) { (String bytes) -> string } -> self

  # <!--
  #   rdoc-file=string.c
  #   - setbyte(index, integer) -> integer
  # -->
  # Sets the byte at zero-based `index` to `integer`; returns `integer`:
  #
  #     s = 'abcde'      # => "abcde"
  #     s.setbyte(0, 98) # => 98
  #     s                # => "bbcde"
  #
  # Related: String#getbyte.
  #
  def setbyte: [T < _ToInt] (int index, T byte) -> T

  # <!-- rdoc-file=string.c -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     'foo'.length        # => 3
  #     ''.length       # => 4
  #     ''.length   # => 5
  #
  # Contrast with String#bytesize:
  #
  #     'foo'.bytesize        # => 3
  #     ''.bytesize       # => 8
  #     ''.bytesize   # => 15
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Returns the substring of `self` specified by the arguments. See examples at
  # [String Slices](rdoc-ref:String@String+Slices).
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - slice!(index)               -> new_string or nil
  #   - slice!(start, length)       -> new_string or nil
  #   - slice!(range)               -> new_string or nil
  #   - slice!(regexp, capture = 0) -> new_string or nil
  #   - slice!(substring)           -> new_string or nil
  # -->
  # Removes and returns the substring of `self` specified by the arguments. See
  # [String Slices](rdoc-ref:String@String+Slices).
  #
  # A few examples:
  #
  #     string = "This is a string"
  #     string.slice!(2)        #=> "i"
  #     string.slice!(3..6)     #=> " is "
  #     string.slice!(/s.*t/)   #=> "sa st"
  #     string.slice!("r")      #=> "r"
  #     string                  #=> "Thing"
  #
  def slice!: (int index, ?int length) -> String?
            | (range[int?] range) -> String?
            | (String substring) -> String?
            | (Regexp regexp, ?MatchData::capture backref) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - split(field_sep = $;, limit = 0) -> array
  #   - split(field_sep = $;, limit = 0) {|substring| ... } -> self
  # -->
  # Returns an array of substrings of `self` that are the result of splitting
  # `self` at each occurrence of the given field separator `field_sep`.
  #
  # When `field_sep` is `$;`:
  #
  # *   If `$;` is `nil` (its default value), the split occurs just as if
  #     `field_sep` were given as a space character (see below).
  #
  # *   If `$;` is a string, the split occurs just as if `field_sep` were given as
  #     that string (see below).
  #
  # When `field_sep` is `' '` and `limit` is `0` (its default value), the split
  # occurs at each sequence of whitespace:
  #
  #     'abc def ghi'.split(' ')         => ["abc", "def", "ghi"]
  #     "abc \n\tdef\t\n  ghi".split(' ') # => ["abc", "def", "ghi"]
  #     'abc  def   ghi'.split(' ')      => ["abc", "def", "ghi"]
  #     ''.split(' ')                    => []
  #
  # When `field_sep` is a string different from `' '` and `limit` is `0`, the
  # split occurs at each occurrence of `field_sep`; trailing empty substrings are
  # not returned:
  #
  #     'abracadabra'.split('ab')  => ["", "racad", "ra"]
  #     'aaabcdaaa'.split('a')     => ["", "", "", "bcd"]
  #     ''.split('a')              => []
  #     '3.14159'.split('1')       => ["3.", "4", "59"]
  #     '!@#$%^$&*($)_+'.split('$') # => ["!@#", "%^", "&*(", ")_+"]
  #     ''.split('')          => ["", ""]
  #     ''.split('')     => ["", ""]
  #
  # When `field_sep` is a Regexp and `limit` is `0`, the split occurs at each
  # occurrence of a match; trailing empty substrings are not returned:
  #
  #     'abracadabra'.split(/ab/) # => ["", "racad", "ra"]
  #     'aaabcdaaa'.split(/a/)   => ["", "", "", "bcd"]
  #     'aaabcdaaa'.split(//)    => ["a", "a", "a", "b", "c", "d", "a", "a", "a"]
  #     '1 + 1 == 2'.split(/\W+/) # => ["1", "1", "2"]
  #
  # If the Regexp contains groups, their matches are also included in the returned
  # array:
  #
  #     '1:2:3'.split(/(:)()()/, 2) # => ["1", ":", "", "", "2:3"]
  #
  # As seen above, if `limit` is `0`, trailing empty substrings are not returned:
  #
  #     'aaabcdaaa'.split('a')   => ["", "", "", "bcd"]
  #
  # If `limit` is positive integer `n`, no more than `n - 1-` splits occur, so
  # that at most `n` substrings are returned, and trailing empty substrings are
  # included:
  #
  #     'aaabcdaaa'.split('a', 1) # => ["aaabcdaaa"]
  #     'aaabcdaaa'.split('a', 2) # => ["", "aabcdaaa"]
  #     'aaabcdaaa'.split('a', 5) # => ["", "", "", "bcd", "aa"]
  #     'aaabcdaaa'.split('a', 7) # => ["", "", "", "bcd", "", "", ""]
  #     'aaabcdaaa'.split('a', 8) # => ["", "", "", "bcd", "", "", ""]
  #
  # Note that if `field_sep` is a Regexp containing groups, their matches are in
  # the returned array, but do not count toward the limit.
  #
  # If `limit` is negative, it behaves the same as if `limit` was zero, meaning
  # that there is no limit, and trailing empty substrings are included:
  #
  #     'aaabcdaaa'.split('a', -1) # => ["", "", "", "bcd", "", "", ""]
  #
  # If a block is given, it is called with each substring:
  #
  #     'abc def ghi'.split(' ') {|substring| p substring }
  #
  # Output:
  #
  #     "abc"
  #     "def"
  #     "ghi"
  #
  # Related: String#partition, String#rpartition.
  #
  def split: (?Regexp | string | nil pattern, ?int limit) -> Array[String]
           | (?Regexp | string | nil pattern, ?int limit) { (String substring) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - squeeze(*selectors) -> new_string
  # -->
  # Returns a copy of `self` with characters specified by `selectors` "squeezed"
  # (see [Multiple Character
  # Selectors](rdoc-ref:character_selectors.rdoc@Multiple+Character+Selectors)):
  #
  # "Squeezed" means that each multiple-character run of a selected character is
  # squeezed down to a single character; with no arguments given, squeezes all
  # characters:
  #
  #     "yellow moon".squeeze                  #=> "yelow mon"
  #     "  now   is  the".squeeze(" ")         #=> " now is the"
  #     "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
  #
  def squeeze: (*selector selectors) -> String

  # <!--
  #   rdoc-file=string.c
  #   - squeeze!(*selectors) -> self or nil
  # -->
  # Like String#squeeze, but modifies `self` in place. Returns `self` if any
  # changes were made, `nil` otherwise.
  #
  def squeeze!: (*selector selectors) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - start_with?(*string_or_regexp) -> true or false
  # -->
  # Returns whether `self` starts with any of the given `string_or_regexp`.
  #
  # Matches patterns against the beginning of `self`. For each given
  # `string_or_regexp`, the pattern is:
  #
  # *   `string_or_regexp` itself, if it is a Regexp.
  # *   `Regexp.quote(string_or_regexp)`, if `string_or_regexp` is a string.
  #
  # Returns `true` if any pattern matches the beginning, `false` otherwise:
  #
  #     'hello'.start_with?('hell')               # => true
  #     'hello'.start_with?(/H/i)                 # => true
  #     'hello'.start_with?('heaven', 'hell')     # => true
  #     'hello'.start_with?('heaven', 'paradise') # => false
  #     ''.start_with?('')                   # => true
  #     ''.start_with?('')              # => true
  #
  # Related: String#end_with?.
  #
  def start_with?: (*Regexp | string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - strip -> new_string
  # -->
  # Returns a copy of the receiver with leading and trailing whitespace removed;
  # see [Whitespace in Strings](rdoc-ref:String@Whitespace+in+Strings):
  #
  #     whitespace = "\x00\t\n\v\f\r "
  #     s = whitespace + 'abc' + whitespace
  #     s       # => "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
  #     s.strip # => "abc"
  #
  # Related: String#lstrip, String#rstrip.
  #
  def strip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - strip! -> self or nil
  # -->
  # Like String#strip, except that any modifications are made in `self`; returns
  # `self` if any modification are made, `nil` otherwise.
  #
  # Related: String#lstrip!, String#strip!.
  #
  def strip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - sub(pattern, replacement)   -> new_string
  #   - sub(pattern) {|match| ... } -> new_string
  # -->
  # Returns a copy of `self` with only the first occurrence (not all occurrences)
  # of the given `pattern` replaced.
  #
  # See [Substitution Methods](rdoc-ref:String@Substitution+Methods).
  #
  # Related: String#sub!, String#gsub, String#gsub!.
  #
  def sub: (Regexp | string pattern, string | hash[String, _ToS] replacement) -> String
         | (Regexp | string pattern) { (String match) -> _ToS } -> String

  # <!--
  #   rdoc-file=string.c
  #   - sub!(pattern, replacement)   -> self or nil
  #   - sub!(pattern) {|match| ... } -> self or nil
  # -->
  # Replaces the first occurrence (not all occurrences) of the given `pattern` on
  # `self`; returns `self` if a replacement occurred, `nil` otherwise.
  #
  # See [Substitution Methods](rdoc-ref:String@Substitution+Methods).
  #
  # Related: String#sub, String#gsub, String#gsub!.
  #
  def sub!: (Regexp | string pattern, string | hash[String, _ToS] replacement) -> self?
          | (Regexp | string pattern) { (String match) -> _ToS } -> self?

  # <!--
  #   rdoc-file=string.c
  #   - succ -> new_str
  # -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty `String` is a new empty `String`:
  #
  #     ''.succ # => ""
  #
  def succ: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - succ! -> self
  # -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  def succ!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - sum(n = 16) -> integer
  # -->
  # Returns a basic `n`-bit checksum of the characters in `self`; the checksum is
  # the sum of the binary value of each byte in `self`, modulo `2**n - 1`:
  #
  #     'hello'.sum     # => 532
  #     'hello'.sum(4)  # => 4
  #     'hello'.sum(64) # => 532
  #     ''.sum      # => 1405
  #     ''.sum  # => 2582
  #
  # This is not a particularly strong checksum.
  #
  def sum: (?int bits) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> string
  # -->
  # Returns a string containing the characters in `self`, with cases reversed;
  # each uppercase character is downcased; each lowercase character is upcased:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase         # => "hELLO wORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#swapcase!.
  #
  def swapcase: () -> String
              | (:ascii | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - swapcase!(*options) -> self or nil
  # -->
  # Upcases each lowercase character in `self`; downcases uppercase character;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase!        # => "hELLO wORLD!"
  #     s                  # => "hELLO wORLD!"
  #     ''.swapcase!       # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#swapcase.
  #
  def swapcase!: () -> self?
               | (:ascii | :lithuanian | :turkic) -> self?
               | (:lithuanian, :turkic) -> self?
               | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - to_c -> complex
  # -->
  # Returns `self` interpreted as a Complex object; leading whitespace and
  # trailing garbage are ignored:
  #
  #     '9'.to_c                 # => (9+0i)
  #     '2.5'.to_c               # => (2.5+0i)
  #     '2.5/1'.to_c             # => ((5/2)+0i)
  #     '-3/2'.to_c              # => ((-3/2)+0i)
  #     '-i'.to_c                # => (0-1i)
  #     '45i'.to_c               # => (0+45i)
  #     '3-4i'.to_c              # => (3-4i)
  #     '-4e2-4e-2i'.to_c        # => (-400.0-0.04i)
  #     '-0.0-0.0i'.to_c         # => (-0.0-0.0i)
  #     '1/2+3/4i'.to_c          # => ((1/2)+(3/4)*i)
  #     '1.0@0'.to_c             # => (1+0.0i)
  #     "1.0@#{Math::PI/2}".to_c # => (0.0+1i)
  #     "1.0@#{Math::PI}".to_c   # => (-1+0.0i)
  #
  # Returns Complex zero if the string cannot be converted:
  #
  #     'ruby'.to_c        # => (0+0i)
  #
  # See Kernel#Complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=string.c
  #   - to_f -> float
  # -->
  # Returns the result of interpreting leading characters in `self` as a Float:
  #
  #     '3.14159'.to_f  # => 3.14159
  #     '1.234e-2'.to_f # => 0.01234
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '3.14 (pi to two places)'.to_f # => 3.14
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_f # => 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=string.c
  #   - to_i(base = 10) -> integer
  # -->
  # Returns the result of interpreting leading characters in `self` as an integer
  # in the given `base` (which must be in (0, 2..36)):
  #
  #     '123456'.to_i     # => 123456
  #     '123def'.to_i(16) # => 1195503
  #
  # With `base` zero, string `object` may contain leading characters to specify
  # the actual base:
  #
  #     '123def'.to_i(0)   # => 123
  #     '0123def'.to_i(0)  # => 83
  #     '0b123def'.to_i(0) # => 1
  #     '0o123def'.to_i(0) # => 83
  #     '0d123def'.to_i(0) # => 123
  #     '0x123def'.to_i(0) # => 1195503
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '12.345'.to_i   # => 12
  #     '12345'.to_i(2) # => 1
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_i # => 0
  #     '2'.to_i(2)   # => 0
  #
  def to_i: (?int radix) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - str.to_r  ->  rational
  # -->
  # Returns the result of interpreting leading characters in `str` as a rational.
  # Leading whitespace and extraneous characters past the end of a valid number
  # are ignored. Digit sequences can be separated by an underscore. If there is
  # not a valid number at the start of `str`, zero is returned.  This method never
  # raises an exception.
  #
  #     '  2  '.to_r       #=> (2/1)
  #     '300/2'.to_r       #=> (150/1)
  #     '-9.2'.to_r        #=> (-46/5)
  #     '-9.2e2'.to_r      #=> (-920/1)
  #     '1_234_567'.to_r   #=> (1234567/1)
  #     '21 June 09'.to_r  #=> (21/1)
  #     '21/06/09'.to_r    #=> (7/2)
  #     'BWV 1079'.to_r    #=> (0/1)
  #
  # NOTE: "0.3".to_r isn't the same as 0.3.to_r.  The former is equivalent to
  # "3/10".to_r, but the latter isn't so.
  #
  #     "0.3".to_r == 3/10r  #=> true
  #     0.3.to_r   == 3/10r  #=> false
  #
  # See also Kernel#Rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=string.c
  #   - to_s -> self or string
  # -->
  # Returns `self` if `self` is a `String`, or `self` converted to a `String` if
  # `self` is a subclass of `String`.
  #
  def to_s: () -> String

  # <!-- rdoc-file=string.c -->
  # Returns `self` if `self` is a `String`, or `self` converted to a `String` if
  # `self` is a subclass of `String`.
  #
  alias to_str to_s

  # <!-- rdoc-file=string.c -->
  # Returns the `Symbol` corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  alias to_sym intern

  # <!--
  #   rdoc-file=string.c
  #   - tr(selector, replacements) -> new_string
  # -->
  # Returns a copy of `self` with each character specified by string `selector`
  # translated to the corresponding character in string `replacements`. The
  # correspondence is *positional*:
  #
  # *   Each occurrence of the first character specified by `selector` is
  #     translated to the first character in `replacements`.
  # *   Each occurrence of the second character specified by `selector` is
  #     translated to the second character in `replacements`.
  # *   And so on.
  #
  # Example:
  #
  #     'hello'.tr('el', 'ip') #=> "hippo"
  #
  # If `replacements` is shorter than `selector`, it is implicitly padded with its
  # own last character:
  #
  #     'hello'.tr('aeiou', '-')   # => "h-ll-"
  #     'hello'.tr('aeiou', 'AA-') # => "hAll-"
  #
  # Arguments `selector` and `replacements` must be valid character selectors (see
  # [Character Selectors](rdoc-ref:character_selectors.rdoc)), and may use any of
  # its valid forms, including negation, ranges, and escaping:
  #
  #     # Negation.
  #     'hello'.tr('^aeiou', '-') # => "-e--o"
  #     # Ranges.
  #     'ibm'.tr('b-z', 'a-z') # => "hal"
  #     # Escapes.
  #     'hel^lo'.tr('\^aeiou', '-')     # => "h-l-l-"    # Escaped leading caret.
  #     'i-b-m'.tr('b\-z', 'a-z')       # => "ibabm"     # Escaped embedded hyphen.
  #     'foo\\bar'.tr('ab\\', 'XYZ')    # => "fooZYXr"   # Escaped backslash.
  #
  def tr: (selector source, string relpacement) -> String

  # <!--
  #   rdoc-file=string.c
  #   - tr!(selector, replacements) -> self or nil
  # -->
  # Like String#tr, but modifies `self` in place. Returns `self` if any changes
  # were made, `nil` otherwise.
  #
  def tr!: (selector source, string relpacement) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - tr_s(selector, replacements) -> string
  # -->
  # Like String#tr, but also squeezes the modified portions of the translated
  # string; returns a new string (translated and squeezed).
  #
  #     'hello'.tr_s('l', 'r')   #=> "hero"
  #     'hello'.tr_s('el', '-')  #=> "h-o"
  #     'hello'.tr_s('el', 'hx') #=> "hhxo"
  #
  # Related: String#squeeze.
  #
  def tr_s: (selector source, string replacement) -> String

  # <!--
  #   rdoc-file=string.c
  #   - tr_s!(selector, replacements) -> self or nil
  # -->
  # Like String#tr_s, but modifies `self` in place. Returns `self` if any changes
  # were made, `nil` otherwise.
  #
  # Related: String#squeeze!.
  #
  def tr_s!: (selector source, string replacement) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - undump -> string
  # -->
  # Returns an unescaped version of `self`:
  #
  #     s_orig = "\f\x00\xff\\\""    # => "\f\u0000\xFF\\\""
  #     s_dumped = s_orig.dump       # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #     s_undumped = s_dumped.undump # => "\f\u0000\xFF\\\""
  #     s_undumped == s_orig         # => true
  #
  # Related: String#dump (inverse of String#undump).
  #
  def undump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - unicode_normalize(form = :nfc) -> string
  # -->
  # Returns a copy of `self` with [Unicode
  # normalization](https://unicode.org/reports/tr15) applied.
  #
  # Argument `form` must be one of the following symbols (see [Unicode
  # normalization forms](https://unicode.org/reports/tr15/#Norm_Forms)):
  #
  # *   `:nfc`: Canonical decomposition, followed by canonical composition.
  # *   `:nfd`: Canonical decomposition.
  # *   `:nfkc`: Compatibility decomposition, followed by canonical composition.
  # *   `:nfkd`: Compatibility decomposition.
  #
  # The encoding of `self` must be one of:
  #
  # *   Encoding::UTF_8
  # *   Encoding::UTF_16BE
  # *   Encoding::UTF_16LE
  # *   Encoding::UTF_32BE
  # *   Encoding::UTF_32LE
  # *   Encoding::GB18030
  # *   Encoding::UCS_2BE
  # *   Encoding::UCS_4BE
  #
  # Examples:
  #
  #     "a\u0300".unicode_normalize      # => "a"
  #     "\u00E0".unicode_normalize(:nfd) # => "a "
  #
  # Related: String#unicode_normalize!, String#unicode_normalized?.
  #
  def unicode_normalize: (?:nfc | :nfd | :nfkc | :nfkd form) -> self

  # <!--
  #   rdoc-file=string.c
  #   - unicode_normalize!(form = :nfc) -> self
  # -->
  # Like String#unicode_normalize, except that the normalization is performed on
  # `self`.
  #
  # Related String#unicode_normalized?.
  #
  def unicode_normalize!: (?:nfc | :nfd | :nfkc | :nfkd form) -> self

  # <!--
  #   rdoc-file=string.c
  #   - unicode_normalized?(form = :nfc) -> true or false
  # -->
  # Returns `true` if `self` is in the given `form` of Unicode normalization,
  # `false` otherwise. The `form` must be one of `:nfc`, `:nfd`, `:nfkc`, or
  # `:nfkd`.
  #
  # Examples:
  #
  #     "a\u0300".unicode_normalized?       # => false
  #     "a\u0300".unicode_normalized?(:nfd) # => true
  #     "\u00E0".unicode_normalized?        # => true
  #     "\u00E0".unicode_normalized?(:nfd)  # => false
  #
  # Raises an exception if `self` is not in a Unicode encoding:
  #
  #     s = "\xE0".force_encoding('ISO-8859-1')
  #     s.unicode_normalized? # Raises Encoding::CompatibilityError.
  #
  # Related: String#unicode_normalize, String#unicode_normalize!.
  #
  def unicode_normalized?: (?:nfc | :nfd | :nfkc | :nfkd) -> bool

  # <!--
  #   rdoc-file=pack.rb
  #   - unpack(template, offset: 0, &block) -> array
  # -->
  # Extracts data from `self`.
  #
  # If `block` is not given, forming objects that become the elements of a new
  # array, and returns that array.  Otherwise, yields each object.
  #
  # See [Packed Data](rdoc-ref:packed_data.rdoc).
  #
  def unpack: (string template, ?offset: int) -> Array[Integer | Float | String | nil]
            | (string template, ?offset: int) { (Integer | Float | String | nil value) -> void } -> nil

  # <!--
  #   rdoc-file=pack.rb
  #   - unpack1(template, offset: 0) -> object
  # -->
  # Like String#unpack, but unpacks and returns only the first extracted object.
  # See [Packed Data](rdoc-ref:packed_data.rdoc).
  #
  def unpack1: (string template, ?offset: int) -> (Integer | Float | String)?

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> string
  # -->
  # Returns a string containing the upcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase           # => "HELLO WORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#upcase!, String#downcase, String#downcase!.
  #
  def upcase: () -> String
            | (:ascii | :lithuanian | :turkic) -> String
            | (:lithuanian, :turkic) -> String
            | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - upcase!(*options) -> self or nil
  # -->
  # Upcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase!          # => "HELLO WORLD!"
  #     s                  # => "HELLO WORLD!"
  #     s.upcase!          # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](rdoc-ref:case_mapping.rdoc).
  #
  # Related: String#upcase, String#downcase, String#downcase!.
  #
  def upcase!: () -> self?
             | (:ascii | :lithuanian | :turkic) -> self?
             | (:lithuanian, :turkic) -> self?
             | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - upto(other_string, exclusive = false) {|string| ... } -> self
  #   - upto(other_string, exclusive = false) -> new_enumerator
  # -->
  # With a block given, calls the block with each `String` value returned by
  # successive calls to String#succ; the first value is `self`, the next is
  # `self.succ`, and so on; the sequence terminates when value `other_string` is
  # reached; returns `self`:
  #
  #     'a8'.upto('b6') {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5 b6
  #
  # If argument `exclusive` is given as a truthy object, the last value is
  # omitted:
  #
  #     'a8'.upto('b6', true) {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5
  #
  # If `other_string` would not be reached, does not call the block:
  #
  #     '25'.upto('5') {|s| fail s }
  #     'aa'.upto('a') {|s| fail s }
  #
  # With no block given, returns a new Enumerator:
  #
  #     'a8'.upto('b6') # => #<Enumerator: "a8":upto("b6")>
  #
  def upto: (string other_string, ?boolish exclusive) -> Enumerator[String, self]
          | (string other_string, ?boolish exclusive) { (String s) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - valid_encoding? -> true or false
  # -->
  # Returns `true` if `self` is encoded correctly, `false` otherwise:
  #
  #     "\xc2\xa1".force_encoding("UTF-8").valid_encoding? # => true
  #     "\xc2".force_encoding("UTF-8").valid_encoding?     # => false
  #     "\x80".force_encoding("UTF-8").valid_encoding?     # => false
  #
  def valid_encoding?: () -> bool
end

%a{steep:deprecated}
interface _ArefFromStringToString
  def []: (String) -> String
end

%a{steep:deprecated}
type String::encode_fallback = Hash[String, String] | Proc | Method | _ArefFromStringToString
# <!-- rdoc-file=proc.c -->
# A `Proc` object is an encapsulation of a block of code, which can be stored in
# a local variable, passed to a method or another Proc, and can be called. Proc
# is an essential concept in Ruby and a core of its functional programming
# features.
#
#     square = Proc.new {|x| x**2 }
#
#     square.call(3)  #=> 9
#     # shorthands:
#     square.(3)      #=> 9
#     square[3]       #=> 9
#
# Proc objects are *closures*, meaning they remember and can use the entire
# context in which they were created.
#
#     def gen_times(factor)
#       Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
#     end
#
#     times3 = gen_times(3)
#     times5 = gen_times(5)
#
#     times3.call(12)               #=> 36
#     times5.call(5)                #=> 25
#     times3.call(times5.call(4))   #=> 60
#
# ## Creation
#
# There are several methods to create a Proc
#
# *   Use the Proc class constructor:
#
#         proc1 = Proc.new {|x| x**2 }
#
# *   Use the Kernel#proc method as a shorthand of Proc.new:
#
#         proc2 = proc {|x| x**2 }
#
# *   Receiving a block of code into proc argument (note the `&`):
#
#         def make_proc(&block)
#           block
#         end
#
#         proc3 = make_proc {|x| x**2 }
#
# *   Construct a proc with lambda semantics using the Kernel#lambda method (see
#     below for explanations about lambdas):
#
#         lambda1 = lambda {|x| x**2 }
#
# *   Use the [Lambda proc
#     literal](rdoc-ref:syntax/literals.rdoc@Lambda+Proc+Literals) syntax (also
#     constructs a proc with lambda semantics):
#
#         lambda2 = ->(x) { x**2 }
#
# ## Lambda and non-lambda semantics
#
# Procs are coming in two flavors: lambda and non-lambda (regular procs).
# Differences are:
#
# *   In lambdas, `return` and `break` means exit from this lambda;
# *   In non-lambda procs, `return` means exit from embracing method (and will
#     throw `LocalJumpError` if invoked outside the method);
# *   In non-lambda procs, `break` means exit from the method which the block
#     given for. (and will throw `LocalJumpError` if invoked after the method
#     returns);
# *   In lambdas, arguments are treated in the same way as in methods: strict,
#     with `ArgumentError` for mismatching argument number, and no additional
#     argument processing;
# *   Regular procs accept arguments more generously: missing arguments are
#     filled with `nil`, single Array arguments are deconstructed if the proc
#     has multiple arguments, and there is no error raised on extra arguments.
#
# Examples:
#
#     # +return+ in non-lambda proc, +b+, exits +m2+.
#     # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
#     #=> []
#
#     # +break+ in non-lambda proc, +b+, exits +m1+.
#     # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
#     #=> [:m2]
#
#     # +next+ in non-lambda proc, +b+, exits the block.
#     # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # Using +proc+ method changes the behavior as follows because
#     # The block is given for +proc+ method and embraced by +m2+.
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
#     #=> []
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
#     # break from proc-closure (LocalJumpError)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # +return+, +break+ and +next+ in the stubby lambda exits the block.
#     # (+lambda+ method behaves same.)
#     # (The block is given for stubby lambda syntax and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     p = proc {|x, y| "x=#{x}, y=#{y}" }
#     p.call(1, 2)      #=> "x=1, y=2"
#     p.call([1, 2])    #=> "x=1, y=2", array deconstructed
#     p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
#     p.call(1)         #=> "x=1, y=", nil substituted instead of error
#
#     l = lambda {|x, y| "x=#{x}, y=#{y}" }
#     l.call(1, 2)      #=> "x=1, y=2"
#     l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
#     l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
#     l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)
#
#     def test_return
#       -> { return 3 }.call      # just returns from lambda into method body
#       proc { return 4 }.call    # returns from method
#       return 5
#     end
#
#     test_return # => 4, return from proc
#
# Lambdas are useful as self-sufficient functions, in particular useful as
# arguments to higher-order functions, behaving exactly like Ruby methods.
#
# Procs are useful for implementing iterators:
#
#     def test
#       [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
#                                 #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# Inside `map`, the block of code is treated as a regular (non-lambda) proc,
# which means that the internal arrays will be deconstructed to pairs of
# arguments, and `return` will exit from the method `test`. That would not be
# possible with a stricter lambda.
#
# You can tell a lambda from a regular proc by using the #lambda? instance
# method.
#
# Lambda semantics is typically preserved during the proc lifetime, including
# `&`-deconstruction to a block of code:
#
#     p = proc {|x, y| x }
#     l = lambda {|x, y| x }
#     [[1, 2], [3, 4]].map(&p) #=> [1, 3]
#     [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)
#
# The only exception is dynamic method definition: even if defined by passing a
# non-lambda proc, methods still have normal semantics of argument checking.
#
#     class C
#       define_method(:e, &proc {})
#     end
#     C.new.e(1,2)       #=> ArgumentError
#     C.new.method(:e).to_proc.lambda?   #=> true
#
# This exception ensures that methods never have unusual argument passing
# conventions, and makes it easy to have wrappers defining methods that behave
# as usual.
#
#     class C
#       def self.def2(name, &body)
#         define_method(name, &body)
#       end
#
#       def2(:f) {}
#     end
#     C.new.f(1,2)       #=> ArgumentError
#
# The wrapper `def2` receives *body* as a non-lambda proc, yet defines a method
# which has normal semantics.
#
# ## Conversion of other objects to procs
#
# Any object that implements the `to_proc` method can be converted into a proc
# by the `&` operator, and therefore can be consumed by iterators.
#
#     class Greeter
#       def initialize(greeting)
#         @greeting = greeting
#       end
#
#       def to_proc
#         proc {|name| "#{@greeting}, #{name}!" }
#       end
#     end
#
#     hi = Greeter.new("Hi")
#     hey = Greeter.new("Hey")
#     ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
#     ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]
#
# Of the Ruby core classes, this method is implemented by Symbol, Method, and
# Hash.
#
#     :to_s.to_proc.call(1)           #=> "1"
#     [1, 2].map(&:to_s)              #=> ["1", "2"]
#
#     method(:puts).to_proc.call(1)   # prints 1
#     [1, 2].each(&method(:puts))     # prints 1, 2
#
#     {test: 1}.to_proc.call(:test)       #=> 1
#     %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]
#
# ## Orphaned Proc
#
# `return` and `break` in a block exit a method. If a Proc object is generated
# from the block and the Proc object survives until the method is returned,
# `return` and `break` cannot work. In such case, `return` and `break` raises
# LocalJumpError. A Proc object in such situation is called as orphaned Proc
# object.
#
# Note that the method to exit is different for `return` and `break`. There is a
# situation that orphaned for `break` but not orphaned for `return`.
#
#     def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
#     def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok
#
#     def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
#     def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError
#
#     def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
#     def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError
#
# Since `return` and `break` exits the block itself in lambdas, lambdas cannot
# be orphaned.
#
# ## Anonymous block parameters
#
# To simplify writing short blocks, Ruby provides two different types of
# anonymous parameters: `it` (single parameter) and numbered ones: `_1`, `_2`
# and so on.
#
#     # Explicit parameter:
#     %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]
#
#     # it:
#     %w[test me please].each { puts it.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { it**2 } # => [1, 4, 9, 16, 25]
#
#     # Numbered parameter:
#     %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]
#
# ### `it`
#
# `it` is a name that is available inside a block when no explicit parameters
# defined, as shown above.
#
#     %w[test me please].each { puts it.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { it**2 } # => [1, 4, 9, 16, 25]
#
# `it` is a "soft keyword": it is not a reserved name, and can be used as a name
# for methods and local variables:
#
#     it = 5 # no warnings
#     def it(&block) # RSpec-like API, no warnings
#        # ...
#     end
#
# `it` can be used as a local variable even in blocks that use it as an implicit
# parameter (though this style is obviously confusing):
#
#     [1, 2, 3].each {
#       # takes a value of implicit parameter "it" and uses it to
#       # define a local variable with the same name
#       it = it**2
#       p it
#     }
#
# In a block with explicit parameters defined `it` usage raises an exception:
#
#     [1, 2, 3].each { |x| p it }
#     # syntax error found (SyntaxError)
#     # [1, 2, 3].each { |x| p it }
#     #                        ^~ `it` is not allowed when an ordinary parameter is defined
#
# But if a local name (variable or method) is available, it would be used:
#
#     it = 5
#     [1, 2, 3].each { |x| p it }
#     # Prints 5, 5, 5
#
# Blocks using `it` can be nested:
#
#     %w[test me].each { it.each_char { p it } }
#     # Prints "t", "e", "s", "t", "m", "e"
#
# Blocks using `it` are considered to have one parameter:
#
#     p = proc { it**2 }
#     l = lambda { it**2 }
#     p.parameters     # => [[:opt, nil]]
#     p.arity          # => 1
#     l.parameters     # => [[:req]]
#     l.arity          # => 1
#
# ### Numbered parameters
#
# Numbered parameters are another way to name block parameters implicitly.
# Unlike `it`, numbered parameters allow to refer to several parameters in one
# block.
#
#     %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
#     {a: 100, b: 200}.map { "#{_1} = #{_2}" } # => "a = 100", "b = 200"
#
# Parameter names from `_1` to `_9` are supported:
#
#     [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
#     # => [120, 150, 180]
#
# Though, it is advised to resort to them wisely, probably limiting yourself to
# `_1` and `_2`, and to one-line blocks.
#
# Numbered parameters can't be used together with explicitly named ones:
#
#     [10, 20, 30].map { |x| _1**2 }
#     # SyntaxError (ordinary parameter is defined)
#
# Numbered parameters can't be mixed with `it` either:
#
#     [10, 20, 30].map { _1 + it }
#     # SyntaxError: `it` is not allowed when a numbered parameter is already used
#
# To avoid conflicts, naming local variables or method arguments `_1`, `_2` and
# so on, causes an error.
#
#       _1 = 'test'
#     # ^~ _1 is reserved for numbered parameters (SyntaxError)
#
# Using implicit numbered parameters affects block's arity:
#
#     p = proc { _1 + _2 }
#     l = lambda { _1 + _2 }
#     p.parameters     # => [[:opt, :_1], [:opt, :_2]]
#     p.arity          # => 2
#     l.parameters     # => [[:req, :_1], [:req, :_2]]
#     l.arity          # => 2
#
# Blocks with numbered parameters can't be nested:
#
#     %w[test me].each { _1.each_char { p _1 } }
#     # numbered parameter is already used in outer block (SyntaxError)
#     # %w[test me].each { _1.each_char { p _1 } }
#     #                    ^~
#
class Proc
  interface _Callable
    def call: (?) -> untyped
  end

  # <!--
  #   rdoc-file=proc.c
  #   - Proc.new {|...| block } -> a_proc
  # -->
  # Creates a new Proc object, bound to the current context.
  #
  #     proc = Proc.new { "hello" }
  #     proc.call   #=> "hello"
  #
  # Raises ArgumentError if called without a block.
  #
  #     Proc.new    #=> ArgumentError
  #
  def self.new: () { (?) -> untyped } -> instance

  def clone: () -> instance
  def dup: () -> instance

  # <!-- rdoc-file=proc.c -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  alias === call

  # <!-- rdoc-file=proc.c -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  alias yield call

  # <!--
  #   rdoc-file=proc.c
  #   - prc << g -> a_proc
  # -->
  # Returns a proc that is the composition of this proc and the given *g*. The
  # returned proc takes a variable number of arguments, calls *g* with them then
  # calls this proc with the result.
  #
  #     f = proc {|x| x * x }
  #     g = proc {|x| x + x }
  #     p (f << g).call(2) #=> 16
  #
  # See Proc#>> for detailed explanations.
  #
  def <<: (_Callable callable) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - prc >> g -> a_proc
  # -->
  # Returns a proc that is the composition of this proc and the given *g*. The
  # returned proc takes a variable number of arguments, calls this proc with them
  # then calls *g* with the result.
  #
  #     f = proc {|x| x * x }
  #     g = proc {|x| x + x }
  #     p (f >> g).call(2) #=> 8
  #
  # *g* could be other Proc, or Method, or any other object responding to `call`
  # method:
  #
  #     class Parser
  #       def self.call(text)
  #          # ...some complicated parsing logic...
  #       end
  #     end
  #
  #     pipeline = File.method(:read) >> Parser >> proc { |data| puts "data size: #{data.count}" }
  #     pipeline.call('data.json')
  #
  # See also Method#>> and Method#<<.
  #
  def >>: (_Callable callable) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - prc == other -> true or false
  #   - prc.eql?(other) -> true or false
  # -->
  # Two procs are the same if, and only if, they were created from the same code
  # block.
  #
  #     def return_block(&block)
  #       block
  #     end
  #
  #     def pass_block_twice(&block)
  #       [return_block(&block), return_block(&block)]
  #     end
  #
  #     block1, block2 = pass_block_twice { puts 'test' }
  #     # Blocks might be instantiated into Proc's lazily, so they may, or may not,
  #     # be the same object.
  #     # But they are produced from the same code block, so they are equal
  #     block1 == block2
  #     #=> true
  #
  #     # Another Proc will never be equal, even if the code is the "same"
  #     block1 == proc { puts 'test' }
  #     #=> false
  #
  def ==: (untyped other) -> bool

  # <!-- rdoc-file=proc.c -->
  # Two procs are the same if, and only if, they were created from the same code
  # block.
  #
  #     def return_block(&block)
  #       block
  #     end
  #
  #     def pass_block_twice(&block)
  #       [return_block(&block), return_block(&block)]
  #     end
  #
  #     block1, block2 = pass_block_twice { puts 'test' }
  #     # Blocks might be instantiated into Proc's lazily, so they may, or may not,
  #     # be the same object.
  #     # But they are produced from the same code block, so they are equal
  #     block1 == block2
  #     #=> true
  #
  #     # Another Proc will never be equal, even if the code is the "same"
  #     block1 == proc { puts 'test' }
  #     #=> false
  #
  alias eql? ==

  # <!--
  #   rdoc-file=proc.c
  #   - prc.arity -> integer
  # -->
  # Returns the number of mandatory arguments. If the block is declared to take no
  # arguments, returns 0. If the block is known to take exactly n arguments,
  # returns n. If the block has optional arguments, returns -n-1, where n is the
  # number of mandatory arguments, with the exception for blocks that are not
  # lambdas and have only a finite number of optional arguments; in this latter
  # case, returns n. Keyword arguments will be considered as a single additional
  # argument, that argument being mandatory if any keyword argument is mandatory.
  # A #proc with no argument declarations is the same as a block declaring `||` as
  # its arguments.
  #
  #     proc {}.arity                  #=>  0
  #     proc { || }.arity              #=>  0
  #     proc { |a| }.arity             #=>  1
  #     proc { |a, b| }.arity          #=>  2
  #     proc { |a, b, c| }.arity       #=>  3
  #     proc { |*a| }.arity            #=> -1
  #     proc { |a, *b| }.arity         #=> -2
  #     proc { |a, *b, c| }.arity      #=> -3
  #     proc { |x:, y:, z:0| }.arity   #=>  1
  #     proc { |*a, x:, y:0| }.arity   #=> -2
  #
  #     proc   { |a=0| }.arity         #=>  0
  #     lambda { |a=0| }.arity         #=> -1
  #     proc   { |a=0, b| }.arity      #=>  1
  #     lambda { |a=0, b| }.arity      #=> -2
  #     proc   { |a=0, b=0| }.arity    #=>  0
  #     lambda { |a=0, b=0| }.arity    #=> -1
  #     proc   { |a, b=0| }.arity      #=>  1
  #     lambda { |a, b=0| }.arity      #=> -2
  #     proc   { |(a, b), c=0| }.arity #=>  1
  #     lambda { |(a, b), c=0| }.arity #=> -2
  #     proc   { |a, x:0, y:0| }.arity #=>  1
  #     lambda { |a, x:0, y:0| }.arity #=> -2
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - prc.binding    -> binding
  # -->
  # Returns the binding associated with *prc*.
  #
  #     def fred(param)
  #       proc {}
  #     end
  #
  #     b = fred(99)
  #     eval("param", b.binding)   #=> 99
  #
  def binding: () -> Binding

  # <!--
  #   rdoc-file=proc.c
  #   - prc.call(params,...)   -> obj
  #   - prc[params,...]        -> obj
  #   - prc.(params,...)       -> obj
  #   - prc.yield(params,...)  -> obj
  # -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  def call: (?) -> untyped

  # <!-- rdoc-file=proc.c -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  alias [] call

  # <!--
  #   rdoc-file=proc.c
  #   - prc.curry         -> a_proc
  #   - prc.curry(arity)  -> a_proc
  # -->
  # Returns a curried proc. If the optional *arity* argument is given, it
  # determines the number of arguments. A curried proc receives some arguments. If
  # a sufficient number of arguments are supplied, it passes the supplied
  # arguments to the original proc and returns the result. Otherwise, returns
  # another curried proc that takes the rest of arguments.
  #
  # The optional *arity* argument should be supplied when currying procs with
  # variable arguments to determine how many arguments are needed before the proc
  # is called.
  #
  #     b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 6
  #     p b.curry(5)[1][2][3][4][5]  #=> 6
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 6
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> wrong number of arguments (given 4, expected 3)
  #     p b.curry(5)                 #=> wrong number of arguments (given 5, expected 3)
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = proc { :foo }
  #     p b.curry[]                  #=> :foo
  #
  def curry: (?int? arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - prc.hash   ->  integer
  # -->
  # Returns a hash value corresponding to proc body.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - prc.lambda? -> true or false
  # -->
  # Returns `true` if a Proc object is lambda. `false` if non-lambda.
  #
  # The lambda-ness affects argument handling and the behavior of `return` and
  # `break`.
  #
  # A Proc object generated by `proc` ignores extra arguments.
  #
  #     proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]
  #
  # It provides `nil` for missing arguments.
  #
  #     proc {|a,b| [a,b] }.call(1)        #=> [1,nil]
  #
  # It expands a single array argument.
  #
  #     proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]
  #
  # A Proc object generated by `lambda` doesn't have such tricks.
  #
  #     lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError
  #
  # Proc#lambda? is a predicate for the tricks. It returns `true` if no tricks
  # apply.
  #
  #     lambda {}.lambda?            #=> true
  #     proc {}.lambda?              #=> false
  #
  # Proc.new is the same as `proc`.
  #
  #     Proc.new {}.lambda?          #=> false
  #
  # `lambda`, `proc` and Proc.new preserve the tricks of a Proc object given by
  # `&` argument.
  #
  #     lambda(&lambda {}).lambda?   #=> true
  #     proc(&lambda {}).lambda?     #=> true
  #     Proc.new(&lambda {}).lambda? #=> true
  #
  #     lambda(&proc {}).lambda?     #=> false
  #     proc(&proc {}).lambda?       #=> false
  #     Proc.new(&proc {}).lambda?   #=> false
  #
  # A Proc object generated by `&` argument has the tricks
  #
  #     def n(&b) b.lambda? end
  #     n {}                         #=> false
  #
  # The `&` argument preserves the tricks if a Proc object is given by `&`
  # argument.
  #
  #     n(&lambda {})                #=> true
  #     n(&proc {})                  #=> false
  #     n(&Proc.new {})              #=> false
  #
  # A Proc object converted from a method has no tricks.
  #
  #     def m() end
  #     method(:m).to_proc.lambda?   #=> true
  #
  #     n(&method(:m))               #=> true
  #     n(&method(:m).to_proc)       #=> true
  #
  # `define_method` is treated the same as method definition. The defined method
  # has no tricks.
  #
  #     class C
  #       define_method(:d) {}
  #     end
  #     C.new.d(1,2)       #=> ArgumentError
  #     C.new.method(:d).to_proc.lambda?   #=> true
  #
  # `define_method` always defines a method without the tricks, even if a
  # non-lambda Proc object is given. This is the only exception for which the
  # tricks are not preserved.
  #
  #     class C
  #       define_method(:e, &proc {})
  #     end
  #     C.new.e(1,2)       #=> ArgumentError
  #     C.new.method(:e).to_proc.lambda?   #=> true
  #
  # This exception ensures that methods never have tricks and makes it easy to
  # have wrappers to define methods that behave as usual.
  #
  #     class C
  #       def self.def2(name, &body)
  #         define_method(name, &body)
  #       end
  #
  #       def2(:f) {}
  #     end
  #     C.new.f(1,2)       #=> ArgumentError
  #
  # The wrapper *def2* defines a method which has no tricks.
  #
  def lambda?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - prc.parameters(lambda: nil)  -> array
  # -->
  # Returns the parameter information of this proc.  If the lambda keyword is
  # provided and not nil, treats the proc as a lambda if true and as a non-lambda
  # if false.
  #
  #     prc = proc{|x, y=42, *other|}
  #     prc.parameters  #=> [[:opt, :x], [:opt, :y], [:rest, :other]]
  #     prc = lambda{|x, y=42, *other|}
  #     prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]
  #     prc = proc{|x, y=42, *other|}
  #     prc.parameters(lambda: true)  #=> [[:req, :x], [:opt, :y], [:rest, :other]]
  #     prc = lambda{|x, y=42, *other|}
  #     prc.parameters(lambda: false) #=> [[:opt, :x], [:opt, :y], [:rest, :other]]
  #
  def parameters: (?lambda: boolish) -> Method::param_types

  # <!--
  #   rdoc-file=proc.c
  #   - prc.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this proc or `nil`
  # if this proc was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [String, Integer]?

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_proc -> proc
  # -->
  # Part of the protocol for converting objects to Proc objects. Instances of
  # class Proc simply return themselves.
  #
  def to_proc: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_s   -> string
  # -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  def to_s: () -> String

  # <!-- rdoc-file=proc.c -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  alias inspect to_s
end
# <!-- rdoc-file=object.c -->
# The Kernel module is included by class Object, so its methods are available in
# every Ruby object.
#
# The Kernel instance methods are documented in class Object while the module
# methods are documented here.  These methods are called without a receiver and
# thus can be called in functional form:
#
#     sprintf "%.1f", 1.234 #=> "1.2"
#
# ## What's Here
#
# Module Kernel provides methods that are useful for:
#
# *   [Converting](rdoc-ref:Kernel@Converting)
# *   [Querying](rdoc-ref:Kernel@Querying)
# *   [Exiting](rdoc-ref:Kernel@Exiting)
# *   [Exceptions](rdoc-ref:Kernel@Exceptions)
# *   [IO](rdoc-ref:Kernel@IO)
# *   [Procs](rdoc-ref:Kernel@Procs)
# *   [Tracing](rdoc-ref:Kernel@Tracing)
# *   [Subprocesses](rdoc-ref:Kernel@Subprocesses)
# *   [Loading](rdoc-ref:Kernel@Loading)
# *   [Yielding](rdoc-ref:Kernel@Yielding)
# *   [Random Values](rdoc-ref:Kernel@Random+Values)
# *   [Other](rdoc-ref:Kernel@Other)
#
# ### Converting
#
# *   #Array: Returns an Array based on the given argument.
# *   #Complex: Returns a Complex based on the given arguments.
# *   #Float: Returns a Float based on the given arguments.
# *   #Hash: Returns a Hash based on the given argument.
# *   #Integer: Returns an Integer based on the given arguments.
# *   #Rational: Returns a Rational based on the given arguments.
# *   #String: Returns a String based on the given argument.
#
# ### Querying
#
# *   #__callee__: Returns the called name of the current method as a symbol.
# *   #__dir__: Returns the path to the directory from which the current method
#     is called.
# *   #__method__: Returns the name of the current method as a symbol.
# *   #autoload?: Returns the file to be loaded when the given module is
#     referenced.
# *   #binding: Returns a Binding for the context at the point of call.
# *   #block_given?: Returns `true` if a block was passed to the calling method.
# *   #caller: Returns the current execution stack as an array of strings.
# *   #caller_locations: Returns the current execution stack as an array of
#     Thread::Backtrace::Location objects.
# *   #class: Returns the class of `self`.
# *   #frozen?: Returns whether `self` is frozen.
# *   #global_variables: Returns an array of global variables as symbols.
# *   #local_variables: Returns an array of local variables as symbols.
# *   #test: Performs specified tests on the given single file or pair of files.
#
# ### Exiting
#
# *   #abort: Exits the current process after printing the given arguments.
# *   #at_exit: Executes the given block when the process exits.
# *   #exit: Exits the current process after calling any registered `at_exit`
#     handlers.
# *   #exit!: Exits the current process without calling any registered `at_exit`
#     handlers.
#
# ### Exceptions
#
# *   #catch: Executes the given block, possibly catching a thrown object.
# *   #raise (aliased as #fail): Raises an exception based on the given
#     arguments.
# *   #throw: Returns from the active catch block waiting for the given tag.
#
# ### IO
#
# *   ::pp: Prints the given objects in pretty form.
# *   #gets: Returns and assigns to `$_` the next line from the current input.
# *   #open: Creates an IO object connected to the given stream, file, or
#     subprocess.
# *   #p:  Prints the given objects' inspect output to the standard output.
# *   #print: Prints the given objects to standard output without a newline.
# *   #printf: Prints the string resulting from applying the given format string
#     to any additional arguments.
# *   #putc: Equivalent to <tt.$stdout.putc(object)</tt> for the given object.
# *   #puts: Equivalent to `$stdout.puts(*objects)` for the given objects.
# *   #readline: Similar to #gets, but raises an exception at the end of file.
# *   #readlines: Returns an array of the remaining lines from the current
#     input.
# *   #select: Same as IO.select.
#
# ### Procs
#
# *   #lambda: Returns a lambda proc for the given block.
# *   #proc: Returns a new Proc; equivalent to Proc.new.
#
# ### Tracing
#
# *   #set_trace_func: Sets the given proc as the handler for tracing, or
#     disables tracing if given `nil`.
# *   #trace_var: Starts tracing assignments to the given global variable.
# *   #untrace_var: Disables tracing of assignments to the given global
#     variable.
#
# ### Subprocesses
#
# *   [\`command`](rdoc-ref:Kernel#`): Returns the standard output of running
#     `command` in a subshell.
# *   #exec: Replaces current process with a new process.
# *   #fork: Forks the current process into two processes.
# *   #spawn: Executes the given command and returns its pid without waiting for
#     completion.
# *   #system: Executes the given command in a subshell.
#
# ### Loading
#
# *   #autoload: Registers the given file to be loaded when the given constant
#     is first referenced.
# *   #load: Loads the given Ruby file.
# *   #require: Loads the given Ruby file unless it has already been loaded.
# *   #require_relative: Loads the Ruby file path relative to the calling file,
#     unless it has already been loaded.
#
# ### Yielding
#
# *   #tap: Yields `self` to the given block; returns `self`.
# *   #then (aliased as #yield_self): Yields `self` to the block and returns the
#     result of the block.
#
# ### Random Values
#
# *   #rand: Returns a pseudo-random floating point number strictly between 0.0
#     and 1.0.
# *   #srand: Seeds the pseudo-random number generator with the given number.
#
# ### Other
#
# *   #eval: Evaluates the given string as Ruby code.
# *   #loop: Repeatedly executes the given block.
# *   #sleep: Suspends the current thread for the given number of seconds.
# *   #sprintf (aliased as #format): Returns the string resulting from applying
#     the given format string to any additional arguments.
# *   #syscall: Runs an operating system call.
# *   #trap: Specifies the handling of system signals.
# *   #warn: Issue a warning based on the given messages and options.
#
%a{annotate:rdoc:source:from=object.c}
module Kernel : BasicObject
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller(start=1, length=nil)  -> array or nil
  #   - caller(range)                -> array or nil
  # -->
  # Returns the current execution stack---an array containing strings in the form
  # `file:line` or `file:line: in `method'`.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  #     def a(skip)
  #       caller(skip)
  #     end
  #     def b(skip)
  #       a(skip)
  #     end
  #     def c(skip)
  #       b(skip)
  #     end
  #     c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
  #     c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
  #     c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
  #     c(3)   #=> ["prog:13:in `<main>'"]
  #     c(4)   #=> []
  #     c(5)   #=> nil
  #
  def self?.caller: (Integer start_or_range, ?Integer length) -> ::Array[String]?
                  | (::Range[Integer] start_or_range) -> ::Array[String]?
                  | () -> ::Array[String]

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller_locations(start=1, length=nil)    -> array or nil
  #   - caller_locations(range)                  -> array or nil
  # -->
  # Returns the current execution stack---an array containing backtrace location
  # objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  def self?.caller_locations: (?Integer start_or_range, ?Integer length) -> ::Array[Thread::Backtrace::Location]?
                            | (?::Range[Integer] start_or_range) -> ::Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=vm_eval.c
  #   - catch([tag]) {|tag| block }  -> obj
  # -->
  # `catch` executes its block. If `throw` is not called, the block executes
  # normally, and `catch` returns the value of the last expression evaluated.
  #
  #     catch(1) { 123 }            # => 123
  #
  # If `throw(tag2, val)` is called, Ruby searches up its stack for a `catch`
  # block whose `tag` has the same `object_id` as *tag2*. When found, the block
  # stops executing and returns *val* (or `nil` if no second argument was given to
  # `throw`).
  #
  #     catch(1) { throw(1, 456) }  # => 456
  #     catch(1) { throw(1) }       # => nil
  #
  # When `tag` is passed as the first argument, `catch` yields it as the parameter
  # of the block.
  #
  #     catch(1) {|x| x + 2 }       # => 3
  #
  # When no `tag` is given, `catch` yields a new unique object (as from
  # `Object.new`) as the block parameter. This object can then be used as the
  # argument to `throw`, and will match the correct `catch` block.
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_B, 123)
  #         puts "This puts is not reached"
  #       end
  #
  #       puts "This puts is displayed"
  #       456
  #     end
  #
  #     # => 456
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_A, 123)
  #         puts "This puts is still not reached"
  #       end
  #
  #       puts "Now this puts is also not reached"
  #       456
  #     end
  #
  #     # => 123
  #
  def self?.catch: [T] (T tag) { (T tag) -> untyped } -> untyped
                 | () { (Object tag) -> untyped } -> untyped

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.class    -> class
  # -->
  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as #class is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> Class

  # <!--
  #   rdoc-file=vm_eval.c
  #   - eval(string [, binding [, filename [,lineno]]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*. If *binding* is given, which
  # must be a Binding object, the evaluation is performed in its context. If the
  # optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(str)
  #       return binding
  #     end
  #     str = "hello"
  #     eval "str + ' Fred'"                      #=> "hello Fred"
  #     eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
  #
  def self?.eval: (string src, ?Binding? scope, ?string filename, ?int lineno) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - block_given?   -> true or false
  # -->
  # Returns `true` if `yield` would execute a block in the current context. The
  # `iterator?` form is mildly deprecated.
  #
  #     def try
  #       if block_given?
  #         yield
  #       else
  #         "no block"
  #       end
  #     end
  #     try                  #=> "no block"
  #     try { "hello" }      #=> "hello"
  #     try do "hello" end   #=> "hello"
  #
  def self?.block_given?: () -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - local_variables    -> array
  # -->
  # Returns the names of the current local variables.
  #
  #     fred = 1
  #     for i in 1..10
  #        # ...
  #     end
  #     local_variables   #=> [:fred, :i]
  #
  def self?.local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self?.srand: (?int number) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.fork { ... } -> integer or nil
  #   - Process.fork -> integer or nil
  # -->
  # Creates a child process.
  #
  # With a block given, runs the block in the child process; on block exit, the
  # child terminates with a status of zero:
  #
  #     puts "Before the fork: #{Process.pid}"
  #     fork do
  #       puts "In the child process: #{Process.pid}"
  #     end                   # => 382141
  #     puts "After the fork: #{Process.pid}"
  #
  # Output:
  #
  #     Before the fork: 420496
  #     After the fork: 420496
  #     In the child process: 420520
  #
  # With no block given, the `fork` call returns twice:
  #
  # *   Once in the parent process, returning the pid of the child process.
  # *   Once in the child process, returning `nil`.
  #
  # Example:
  #
  #     puts "This is the first line before the fork (pid #{Process.pid})"
  #     puts fork
  #     puts "This is the second line after the fork (pid #{Process.pid})"
  #
  # Output:
  #
  #     This is the first line before the fork (pid 420199)
  #     420223
  #     This is the second line after the fork (pid 420199)
  #
  #     This is the second line after the fork (pid 420223)
  #
  # In either case, the child process may exit using Kernel.exit! to avoid the
  # call to Kernel#at_exit.
  #
  # To avoid zombie processes, the parent process should call either:
  #
  # *   Process.wait, to collect the termination statuses of its children.
  # *   Process.detach, to register disinterest in their status.
  #
  # The thread calling `fork` is the only thread in the created child process;
  # `fork` doesn't copy other threads.
  #
  # Note that method `fork` is available on some platforms, but not on others:
  #
  #     Process.respond_to?(:fork) # => true # Would be false on some.
  #
  # If not, you may use ::spawn instead of `fork`.
  #
  def self?.fork: () -> Integer?
                | () { () -> void } -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - Array(object) -> object or new_array
  # -->
  # Returns an array converted from `object`.
  #
  # Tries to convert `object` to an array using `to_ary` first and `to_a` second:
  #
  #     Array([0, 1, 2])        # => [0, 1, 2]
  #     Array({foo: 0, bar: 1}) # => [[:foo, 0], [:bar, 1]]
  #     Array(0..4)             # => [0, 1, 2, 3, 4]
  #
  # Returns `object` in an array, `[object]`, if `object` cannot be converted:
  #
  #     Array(:foo)             # => [:foo]
  #
  def self?.Array: (nil) -> []
                 | [T] (array[T] | _ToA[T] array_like) -> Array[T]
                 | [T] (T ele) -> [T]

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(real, imag = 0, exception: true) -> complex or nil
  #   - Complex(s, exception: true) -> complex or nil
  # -->
  # Returns a new Complex object if the arguments are valid; otherwise raises an
  # exception if `exception` is `true`; otherwise returns `nil`.
  #
  # With Numeric arguments `real` and `imag`, returns `Complex.rect(real, imag)`
  # if the arguments are valid.
  #
  # With string argument `s`, returns a new Complex object if the argument is
  # valid; the string may have:
  #
  # *   One or two numeric substrings, each of which specifies a Complex, Float,
  #     Integer, Numeric, or Rational value, specifying [rectangular
  #     coordinates](rdoc-ref:Complex@Rectangular+Coordinates):
  #
  #     *   Sign-separated real and imaginary numeric substrings (with trailing
  #         character `'i'`):
  #
  #             Complex('1+2i')  # => (1+2i)
  #             Complex('+1+2i') # => (1+2i)
  #             Complex('+1-2i') # => (1-2i)
  #             Complex('-1+2i') # => (-1+2i)
  #             Complex('-1-2i') # => (-1-2i)
  #
  #     *   Real-only numeric string (without trailing character `'i'`):
  #
  #             Complex('1')  # => (1+0i)
  #             Complex('+1') # => (1+0i)
  #             Complex('-1') # => (-1+0i)
  #
  #     *   Imaginary-only numeric string (with trailing character `'i'`):
  #
  #             Complex('1i')  # => (0+1i)
  #             Complex('+1i') # => (0+1i)
  #             Complex('-1i') # => (0-1i)
  #
  # *   At-sign separated real and imaginary rational substrings, each of which
  #     specifies a Rational value, specifying [polar
  #     coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #         Complex('1/2@3/4')   # => (0.36584443443691045+0.34081938001166706i)
  #         Complex('+1/2@+3/4') # => (0.36584443443691045+0.34081938001166706i)
  #         Complex('+1/2@-3/4') # => (0.36584443443691045-0.34081938001166706i)
  #         Complex('-1/2@+3/4') # => (-0.36584443443691045-0.34081938001166706i)
  #         Complex('-1/2@-3/4') # => (-0.36584443443691045+0.34081938001166706i)
  #
  def self?.Complex: (_ToC complex_like, ?exception: true) -> Complex
                   | (_ToC complex_like, exception: bool) -> Complex?
                   | (Numeric | String real, ?Numeric | String imag, ?exception: true) -> Complex
                   | (Numeric | String real, ?Numeric | String imag, exception: bool) -> Complex?
                   | (untyped, ?untyped, ?exception: bool) -> Complex?

  # <!--
  #   rdoc-file=kernel.rb
  #   - Float(arg, exception: true)    -> float or nil
  # -->
  # Returns *arg* converted to a float. Numeric types are converted directly, and
  # with exception to String and `nil`, the rest are converted using *arg*`.to_f`.
  # Converting a String with invalid characters will result in an ArgumentError.
  # Converting `nil` generates a TypeError. Exceptions can be suppressed by
  # passing `exception: false`.
  #
  #     Float(1)                 #=> 1.0
  #     Float("123.456")         #=> 123.456
  #     Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
  #     Float(nil)               #=> TypeError: can't convert nil into Float
  #     Float("123.0_badstring", exception: false)  #=> nil
  #
  def self?.Float: (_ToF float_like, ?exception: true) -> Float
                 | (_ToF float_like, exception: bool) -> Float?
                 | (untyped, ?exception: bool) -> Float?

  # <!--
  #   rdoc-file=object.c
  #   - Hash(object) -> object or new_hash
  # -->
  # Returns a hash converted from `object`.
  #
  # *   If `object` is:
  #
  #     *   A hash, returns `object`.
  #     *   An empty array or `nil`, returns an empty hash.
  #
  # *   Otherwise, if `object.to_hash` returns a hash, returns that hash.
  # *   Otherwise, returns TypeError.
  #
  # Examples:
  #
  #     Hash({foo: 0, bar: 1}) # => {:foo=>0, :bar=>1}
  #     Hash(nil)              # => {}
  #     Hash([])               # => {}
  #
  def self?.Hash: [K, V] (nil | [] _empty) -> Hash[K, V]
                | [K, V] (hash[K, V] hash_like) -> Hash[K, V]

  # <!--
  #   rdoc-file=kernel.rb
  #   - Integer(object, base = 0, exception: true) -> integer or nil
  # -->
  # Returns an integer converted from `object`.
  #
  # Tries to convert `object` to an integer using `to_int` first and `to_i`
  # second; see below for exceptions.
  #
  # With a non-zero `base`, `object` must be a string or convertible to a string.
  #
  # #### Numeric objects
  #
  # With an integer argument `object` given, returns `object`:
  #
  #     Integer(1)                # => 1
  #     Integer(-1)               # => -1
  #
  # With a floating-point argument `object` given, returns `object` truncated to
  # an integer:
  #
  #     Integer(1.9)              # => 1  # Rounds toward zero.
  #     Integer(-1.9)             # => -1 # Rounds toward zero.
  #
  # #### String objects
  #
  # With a string argument `object` and zero `base` given, returns `object`
  # converted to an integer in base 10:
  #
  #     Integer('100')    # => 100
  #     Integer('-100')   # => -100
  #
  # With `base` zero, string `object` may contain leading characters to specify
  # the actual base (radix indicator):
  #
  #     Integer('0100')  # => 64  # Leading '0' specifies base 8.
  #     Integer('0b100') # => 4   # Leading '0b' specifies base 2.
  #     Integer('0x100') # => 256 # Leading '0x' specifies base 16.
  #
  # With a positive `base` (in range 2..36) given, returns `object` converted to
  # an integer in the given base:
  #
  #     Integer('100', 2)   # => 4
  #     Integer('100', 8)   # => 64
  #     Integer('-100', 16) # => -256
  #
  # With a negative `base` (in range -36..-2) given, returns `object` converted to
  # the radix indicator if it exists or `base`:
  #
  #     Integer('0x100', -2)   # => 256
  #     Integer('100', -2)     # => 4
  #     Integer('0b100', -8)   # => 4
  #     Integer('100', -8)     # => 64
  #     Integer('0o100', -10)  # => 64
  #     Integer('100', -10)    # => 100
  #
  # `base` -1 is equivalent to the -10 case.
  #
  # When converting strings, surrounding whitespace and embedded underscores are
  # allowed and ignored:
  #
  #     Integer(' 100 ')      # => 100
  #     Integer('-1_0_0', 16) # => -256
  #
  # #### Other classes
  #
  # Examples with `object` of various other classes:
  #
  #     Integer(Rational(9, 10)) # => 0  # Rounds toward zero.
  #     Integer(Complex(2, 0))   # => 2  # Imaginary part must be zero.
  #     Integer(Time.now)        # => 1650974042
  #
  # #### Keywords
  #
  # With the optional keyword argument `exception` given as `true` (the default):
  #
  # *   Raises TypeError if `object` does not respond to `to_int` or `to_i`.
  # *   Raises TypeError if `object` is `nil`.
  # *   Raises ArgumentError if `object` is an invalid string.
  #
  # With `exception` given as `false`, an exception of any kind is suppressed and
  # `nil` is returned.
  #
  def self?.Integer: (int | _ToI int_like, ?exception: true) -> Integer
                   | (int | _ToI int_like, exception: bool) -> Integer?
                   | (string str, int base, ?exception: true) -> Integer
                   | (string str, int base, exception: bool) -> Integer?
                   | (untyped, ?untyped, ?exception: bool) -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - Rational(x, y, exception: true)  ->  rational or nil
  #   - Rational(arg, exception: true)   ->  rational or nil
  # -->
  # Returns `x/y` or `arg` as a Rational.
  #
  #     Rational(2, 3)   #=> (2/3)
  #     Rational(5)      #=> (5/1)
  #     Rational(0.5)    #=> (1/2)
  #     Rational(0.3)    #=> (5404319552844595/18014398509481984)
  #
  #     Rational("2/3")  #=> (2/3)
  #     Rational("0.3")  #=> (3/10)
  #
  #     Rational("10 cents")  #=> ArgumentError
  #     Rational(nil)         #=> TypeError
  #     Rational(1, nil)      #=> TypeError
  #
  #     Rational("10 cents", exception: false)  #=> nil
  #
  # Syntax of the string form:
  #
  #     string form = extra spaces , rational , extra spaces ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit } ;
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See also String#to_r.
  #
  def self?.Rational: (int | _ToR rational_like, ?exception: true) -> Rational
                    | (int | _ToR rational_like, exception: bool) -> Rational?
                    | (int | _ToR numer, ?int | _ToR denom, ?exception: true) -> Rational
                    | (int | _ToR numer, ?int | _ToR denom, exception: bool) -> Rational?
                    | [T] (Numeric & _RationalDiv[T] numer, Numeric denom, ?exception: bool) -> T
                    | [T < Numeric] (T value, 1, ?exception: bool) -> T
                    | (untyped, ?untyped, ?exception: bool) -> Rational?

  interface _RationalDiv[T]
    def /: (Numeric) -> T
  end

  # <!--
  #   rdoc-file=object.c
  #   - String(object) -> object or new_string
  # -->
  # Returns a string converted from `object`.
  #
  # Tries to convert `object` to a string using `to_str` first and `to_s` second:
  #
  #     String([0, 1, 2])        # => "[0, 1, 2]"
  #     String(0..5)             # => "0..5"
  #     String({foo: 0, bar: 1}) # => "{foo: 0, bar: 1}"
  #
  # Raises `TypeError` if `object` cannot be converted to a string.
  #
  def self?.String: (string | _ToS string_like) -> String

  # <!--
  #   rdoc-file=eval.c
  #   - __callee__         -> symbol
  # -->
  # Returns the called name of the current method as a Symbol. If called outside
  # of a method, it returns `nil`.
  #
  def self?.__callee__: () -> Symbol?

  # <!--
  #   rdoc-file=eval.c
  #   - __dir__         -> string
  # -->
  # Returns the canonicalized absolute path of the directory of the file from
  # which this method is called. It means symlinks in the path is resolved. If
  # `__FILE__` is `nil`, it returns `nil`. The return value equals to
  # `File.dirname(File.realpath(__FILE__))`.
  #
  def self?.__dir__: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - __method__         -> symbol
  # -->
  # Returns the name at the definition of the current method as a Symbol. If
  # called outside of a method, it returns `nil`.
  #
  def self?.__method__: () -> Symbol?

  # <!--
  #   rdoc-file=io.c
  #   - `command` -> string
  # -->
  # Returns the `$stdout` output from running `command` in a subshell; sets global
  # variable `$?` to the process status.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # Examples:
  #
  #     $ `date`                 # => "Wed Apr  9 08:56:30 CDT 2003\n"
  #     $ `echo oops && exit 99` # => "oops\n"
  #     $ $?                     # => #<Process::Status: pid 17088 exit 99>
  #     $ $?.status              # => 99>
  #
  # The built-in syntax `%x{...}` uses this method.
  #
  def self?.`: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - abort
  #   - Process.abort(msg = nil)
  # -->
  # Terminates execution immediately, effectively by calling `Kernel.exit(false)`.
  #
  # If string argument `msg` is given, it is written to STDERR prior to
  # termination; otherwise, if an exception was raised, prints its message and
  # backtrace.
  #
  def self?.abort: (?string msg) -> bot

  # <!--
  #   rdoc-file=eval_jump.c
  #   - at_exit { block } -> proc
  # -->
  # Converts *block* to a `Proc` object (and therefore binds it at the point of
  # call) and registers it for execution when the program exits. If multiple
  # handlers are registered, they are executed in reverse order of registration.
  #
  #     def do_at_exit(str1)
  #       at_exit { print str1 }
  #     end
  #     at_exit { puts "cruel world" }
  #     do_at_exit("goodbye ")
  #     exit
  #
  # *produces:*
  #
  #     goodbye cruel world
  #
  def self?.at_exit: () { () -> void } -> Proc

  # <!--
  #   rdoc-file=load.c
  #   - autoload(const, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *const* (which may be a String or a symbol) is accessed.
  #
  #     autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")
  #
  # If *const* is defined as autoload, the file name to be loaded is replaced with
  # *filename*.  If *const* is defined but not as autoload, does nothing.
  #
  def self?.autoload: (interned _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload` in the
  # current namespace or one of its ancestors.
  #
  #     autoload(:B, "b")
  #     autoload?(:B)            #=> "b"
  #
  #     module C
  #       autoload(:D, "d")
  #       autoload?(:D)          #=> "d"
  #       autoload?(:B)          #=> nil
  #     end
  #
  #     class E
  #       autoload(:F, "f")
  #       autoload?(:F)          #=> "f"
  #       autoload?(:B)          #=> "b"
  #     end
  #
  def self?.autoload?: (interned name) -> String?

  # <!--
  #   rdoc-file=proc.c
  #   - binding -> a_binding
  # -->
  # Returns a Binding object, describing the variable and method bindings at the
  # point of call. This object can be used when calling Binding#eval to execute
  # the evaluated command in this environment, or extracting its local variables.
  #
  #     class User
  #       def initialize(name, position)
  #         @name = name
  #         @position = position
  #       end
  #
  #       def get_binding
  #         binding
  #       end
  #     end
  #
  #     user = User.new('Joan', 'manager')
  #     template = '{name: @name, position: @position}'
  #
  #     # evaluate template in context of the object
  #     eval(template, user.get_binding)
  #     #=> {:name=>"Joan", :position=>"manager"}
  #
  # Binding#local_variable_get can be used to access the variables whose names are
  # reserved Ruby keywords:
  #
  #     # This is valid parameter declaration, but `if` parameter can't
  #     # be accessed by name, because it is a reserved word.
  #     def validate(field, validation, if: nil)
  #       condition = binding.local_variable_get('if')
  #       return unless condition
  #
  #       # ...Some implementation ...
  #     end
  #
  #     validate(:name, :empty?, if: false) # skips validation
  #     validate(:name, :empty?, if: true) # performs validation
  #
  def self?.binding: () -> Binding

  # <!--
  #   rdoc-file=process.c
  #   - exit(status = true)
  #   - Process.exit(status = true)
  # -->
  # Initiates termination of the Ruby script by raising SystemExit; the exception
  # may be caught. Returns exit status `status` to the underlying operating
  # system.
  #
  # Values `true` and `false` for argument `status` indicate, respectively,
  # success and failure; The meanings of integer values are system-dependent.
  #
  # Example:
  #
  #     begin
  #       exit
  #       puts 'Never get here.'
  #     rescue SystemExit
  #       puts 'Rescued a SystemExit exception.'
  #     end
  #     puts 'After begin block.'
  #
  # Output:
  #
  #     Rescued a SystemExit exception.
  #     After begin block.
  #
  # Just prior to final termination, Ruby executes any at-exit procedures (see
  # Kernel::at_exit) and any object finalizers (see
  # ObjectSpace::define_finalizer).
  #
  # Example:
  #
  #     at_exit { puts 'In at_exit function.' }
  #     ObjectSpace.define_finalizer('string', proc { puts 'In finalizer.' })
  #     exit
  #
  # Output:
  #
  #     In at_exit function.
  #     In finalizer.
  #
  def self?.exit: (?int | bool status) -> bot

  # <!--
  #   rdoc-file=process.c
  #   - exit!(status = false)
  #   - Process.exit!(status = false)
  # -->
  # Exits the process immediately; no exit handlers are called. Returns exit
  # status `status` to the underlying operating system.
  #
  #     Process.exit!(true)
  #
  # Values `true` and `false` for argument `status` indicate, respectively,
  # success and failure; The meanings of integer values are system-dependent.
  #
  def self?.exit!: (?int | bool status) -> bot

  # <!-- rdoc-file=eval.c -->
  # Raises an exception; see [Exceptions](rdoc-ref:exceptions.md).
  #
  # Argument `exception` sets the class of the new exception; it should be class
  # Exception or one of its subclasses (most commonly, RuntimeError or
  # StandardError), or an instance of one of those classes:
  #
  #     begin
  #       raise(StandardError)
  #     rescue => x
  #       p x.class
  #     end
  #     # => StandardError
  #
  # Argument `message` sets the stored message in the new exception, which may be
  # retrieved by method Exception#message; the message must be a
  # [string-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@String-Convertible+Objects) or
  # `nil`:
  #
  #     begin
  #       raise(StandardError, 'Boom')
  #     rescue => x
  #       p x.message
  #     end
  #     # => "Boom"
  #
  # If argument `message` is not given, the message is the exception class name.
  #
  # See [Messages](rdoc-ref:exceptions.md@Messages).
  #
  # Argument `backtrace` sets the stored backtrace in the new exception, which may
  # be retrieved by method Exception#backtrace; the backtrace must be an array of
  # strings or `nil`:
  #
  #     begin
  #       raise(StandardError, 'Boom', %w[foo bar baz])
  #     rescue => x
  #       p x.backtrace
  #     end
  #     # => ["foo", "bar", "baz"]
  #
  # If argument `backtrace` is not given, the backtrace is set according to an
  # array of Thread::Backtrace::Location objects, as derived from the call stack.
  #
  # See [Backtraces](rdoc-ref:exceptions.md@Backtraces).
  #
  # Keyword argument `cause` sets the stored cause in the new exception, which may
  # be retrieved by method Exception#cause; the cause must be an exception object
  # (Exception or one of its subclasses), or `nil`:
  #
  #     begin
  #       raise(StandardError, cause: RuntimeError.new)
  #     rescue => x
  #       p x.cause
  #     end
  #     # => #<RuntimeError: RuntimeError>
  #
  # If keyword argument `cause` is not given, the cause is the value of `$!`.
  #
  # See [Cause](rdoc-ref:exceptions.md@Cause).
  #
  # In the alternate calling sequence, where argument `exception` *not* given,
  # raises a new exception of the class given by `$!`, or of class RuntimeError if
  # `$!` is `nil`:
  #
  #     begin
  #       raise
  #     rescue => x
  #       p x
  #     end
  #     # => RuntimeError
  #
  # With argument `exception` not given, argument `message` and keyword argument
  # `cause` may be given, but argument `backtrace` may not be given.
  #
  def self?.fail: () -> bot
                | (string message, ?cause: Exception?) -> bot
                | (_Exception exception, ?_ToS? message, ?String | Array[String] | Array[Thread::Backtrace::Location] | nil backtrace, ?cause: Exception?) -> bot
                | (_Exception exception, ?cause: Exception?, **untyped) -> bot

  # <!--
  #   rdoc-file=eval.c
  #   - raise(exception, message = exception.to_s, backtrace = nil, cause: $!)
  #   - raise(message = nil, cause: $!)
  # -->
  # Raises an exception; see [Exceptions](rdoc-ref:exceptions.md).
  #
  # Argument `exception` sets the class of the new exception; it should be class
  # Exception or one of its subclasses (most commonly, RuntimeError or
  # StandardError), or an instance of one of those classes:
  #
  #     begin
  #       raise(StandardError)
  #     rescue => x
  #       p x.class
  #     end
  #     # => StandardError
  #
  # Argument `message` sets the stored message in the new exception, which may be
  # retrieved by method Exception#message; the message must be a
  # [string-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@String-Convertible+Objects) or
  # `nil`:
  #
  #     begin
  #       raise(StandardError, 'Boom')
  #     rescue => x
  #       p x.message
  #     end
  #     # => "Boom"
  #
  # If argument `message` is not given, the message is the exception class name.
  #
  # See [Messages](rdoc-ref:exceptions.md@Messages).
  #
  # Argument `backtrace` sets the stored backtrace in the new exception, which may
  # be retrieved by method Exception#backtrace; the backtrace must be an array of
  # strings or `nil`:
  #
  #     begin
  #       raise(StandardError, 'Boom', %w[foo bar baz])
  #     rescue => x
  #       p x.backtrace
  #     end
  #     # => ["foo", "bar", "baz"]
  #
  # If argument `backtrace` is not given, the backtrace is set according to an
  # array of Thread::Backtrace::Location objects, as derived from the call stack.
  #
  # See [Backtraces](rdoc-ref:exceptions.md@Backtraces).
  #
  # Keyword argument `cause` sets the stored cause in the new exception, which may
  # be retrieved by method Exception#cause; the cause must be an exception object
  # (Exception or one of its subclasses), or `nil`:
  #
  #     begin
  #       raise(StandardError, cause: RuntimeError.new)
  #     rescue => x
  #       p x.cause
  #     end
  #     # => #<RuntimeError: RuntimeError>
  #
  # If keyword argument `cause` is not given, the cause is the value of `$!`.
  #
  # See [Cause](rdoc-ref:exceptions.md@Cause).
  #
  # In the alternate calling sequence, where argument `exception` *not* given,
  # raises a new exception of the class given by `$!`, or of class RuntimeError if
  # `$!` is `nil`:
  #
  #     begin
  #       raise
  #     rescue => x
  #       p x
  #     end
  #     # => RuntimeError
  #
  # With argument `exception` not given, argument `message` and keyword argument
  # `cause` may be given, but argument `backtrace` may not be given.
  #
  alias raise fail

  alias self.raise self.fail

  # <!-- rdoc-file=object.c -->
  # Returns the string resulting from formatting `objects` into `format_string`.
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  def self?.format: (String format, *untyped args) -> String

  # <!--
  #   rdoc-file=object.c
  #   - sprintf(format_string *objects)  -> string
  # -->
  # Returns the string resulting from formatting `objects` into `format_string`.
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  alias sprintf format

  alias self.sprintf self.format

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep=$/ [, getline_args])     -> string or nil
  #   - gets(limit [, getline_args])      -> string or nil
  #   - gets(sep, limit [, getline_args]) -> string or nil
  # -->
  # Returns (and assigns to `$_`) the next line from the list of files in `ARGV`
  # (or `$*`), or from standard input if no files are present on the command line.
  # Returns `nil` at end of file. The optional argument specifies the record
  # separator. The separator is included with the contents of each record. A
  # separator of `nil` reads the entire contents, and a zero-length separator
  # reads the input one paragraph at a time, where paragraphs are divided by two
  # consecutive newlines.  If the first argument is an integer, or optional second
  # argument is given, the returning string would not be longer than the given
  # value in bytes.  If multiple filenames are present in `ARGV`, `gets(nil)` will
  # read the contents one file at a time.
  #
  #     ARGV << "testfile"
  #     print while gets
  #
  # *produces:*
  #
  #     This is line one
  #     This is line two
  #     This is line three
  #     And so on...
  #
  # The style of programming using `$_` as an implicit parameter is gradually
  # losing favor in the Ruby community.
  #
  def self?.gets: (?String arg0, ?Integer arg1) -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - global_variables    -> array
  # -->
  # Returns an array of the names of global variables. This includes special
  # regexp global variables such as `$~` and `$+`, but does not include the
  # numbered regexp global variables (`$1`, `$2`, etc.).
  #
  #     global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]
  #
  def self?.global_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=load.c
  #   - load(filename, wrap=false)   -> true
  # -->
  # Loads and executes the Ruby program in the file *filename*.
  #
  # If the filename is an absolute path (e.g. starts with '/'), the file will be
  # loaded directly using the absolute path.
  #
  # If the filename is an explicit relative path (e.g. starts with './' or '../'),
  # the file will be loaded using the relative path from the current directory.
  #
  # Otherwise, the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the file is found in a directory, it will attempt to
  # load the file relative to that directory.  If the file is not found in any of
  # the directories in `$LOAD_PATH`, the file will be loaded using the relative
  # path from the current directory.
  #
  # If the file doesn't exist when there is an attempt to load it, a LoadError
  # will be raised.
  #
  # If the optional *wrap* parameter is `true`, the loaded script will be executed
  # under an anonymous module. If the optional *wrap* parameter is a module, the
  # loaded script will be executed under the given module. In no circumstance will
  # any local variables in the loaded file be propagated to the loading
  # environment.
  #
  def self?.load: (String filename, ?Module | bool) -> bool

  # <!--
  #   rdoc-file=kernel.rb
  #   - loop { block }
  #   - loop            -> an_enumerator
  # -->
  # Repeatedly executes the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     loop do
  #       print "Input: "
  #       line = gets
  #       break if !line or line =~ /^q/i
  #       # ...
  #     end
  #
  # A StopIteration raised in the block breaks the loop. In this case, loop
  # returns the "result" value stored in the exception.
  #
  #     enum = Enumerator.new { |y|
  #       y << "one"
  #       y << "two"
  #       :ok
  #     }
  #
  #     result = loop {
  #       puts enum.next
  #     } #=> :ok
  #
  def self?.loop: () { () -> void } -> bot
                | () -> ::Enumerator[nil, bot]

  # <!--
  #   rdoc-file=io.c
  #   - open(path, mode = 'r', perm = 0666, **opts)             -> io or nil
  #   - open(path, mode = 'r', perm = 0666, **opts) {|io| ... } -> obj
  # -->
  # Creates an IO object connected to the given file.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # With no block given, file stream is returned:
  #
  #     open('t.txt') # => #<File:t.txt>
  #
  # With a block given, calls the block with the open file stream, then closes the
  # stream:
  #
  #     open('t.txt') {|f| p f } # => #<File:t.txt (closed)>
  #
  # Output:
  #
  #     #<File:t.txt>
  #
  # See File.open for details.
  #
  def self?.open: (String name, ?String mode, ?Integer perm) -> IO?
                | [T] (String name, ?String mode, ?Integer perm) { (IO) -> T } -> T

  # <!--
  #   rdoc-file=io.c
  #   - print(*objects) -> nil
  # -->
  # Equivalent to `$stdout.print(*objects)`, this method is the straightforward
  # way to write to `$stdout`.
  #
  # Writes the given objects to `$stdout`; returns `nil`. Appends the output
  # record separator `$OUTPUT_RECORD_SEPARATOR` `$\`), if it is not `nil`.
  #
  # With argument `objects` given, for each object:
  #
  # *   Converts via its method `to_s` if not a string.
  # *   Writes to `stdout`.
  # *   If not the last object, writes the output field separator
  #     `$OUTPUT_FIELD_SEPARATOR` (`$,` if it is not `nil`.
  #
  # With default separators:
  #
  #     objects = [0, 0.0, Rational(0, 1), Complex(0, 0), :zero, 'zero']
  #     $OUTPUT_RECORD_SEPARATOR
  #     $OUTPUT_FIELD_SEPARATOR
  #     print(*objects)
  #
  # Output:
  #
  #     nil
  #     nil
  #     00.00/10+0izerozero
  #
  # With specified separators:
  #
  #     $OUTPUT_RECORD_SEPARATOR = "\n"
  #     $OUTPUT_FIELD_SEPARATOR = ','
  #     print(*objects)
  #
  # Output:
  #
  #     0,0.0,0/1,0+0i,zero,zero
  #
  # With no argument given, writes the content of `$_` (which is usually the most
  # recent user input):
  #
  #     gets  # Sets $_ to the most recent user input.
  #     print # Prints $_.
  #
  def self?.print: (*_ToS args) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - printf(format_string, *objects)               -> nil
  #   - printf(io, format_string, *objects) -> nil
  # -->
  # Equivalent to:
  #
  #     io.write(sprintf(format_string, *objects))
  #
  # For details on `format_string`, see [Format
  # Specifications](rdoc-ref:format_specifications.rdoc).
  #
  # With the single argument `format_string`, formats `objects` into the string,
  # then writes the formatted string to $stdout:
  #
  #     printf('%4.4d %10s %2.2f', 24, 24, 24.0)
  #
  # Output (on $stdout):
  #
  #     0024         24 24.00#
  #
  # With arguments `io` and `format_string`, formats `objects` into the string,
  # then writes the formatted string to `io`:
  #
  #     printf($stderr, '%4.4d %10s %2.2f', 24, 24, 24.0)
  #
  # Output (on $stderr):
  #
  #     0024         24 24.00# => nil
  #
  # With no arguments, does nothing.
  #
  def self?.printf: () -> nil
                  | (String fmt, *untyped args) -> nil
                  | (_Writer io, string fmt, *untyped args) -> nil

  # <!--
  #   rdoc-file=proc.c
  #   - proc   { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new.
  #
  def self?.proc: () { (?) -> untyped } -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - lambda { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new, except the resulting Proc objects check the number of
  # parameters passed when called.
  #
  def self?.lambda: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=io.c
  #   - putc(int) -> int
  # -->
  # Equivalent to:
  #
  #     $stdout.putc(int)
  #
  # See IO#putc for important information regarding multi-byte characters.
  #
  def self?.putc: [T < _ToInt] (T chr) -> T
                | (String chr) -> String

  # <!--
  #   rdoc-file=io.c
  #   - puts(*objects)    -> nil
  # -->
  # Equivalent to
  #
  #     $stdout.puts(objects)
  #
  def self?.puts: (*_ToS objects) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - p(object)   -> obj
  #   - p(*objects) -> array of objects
  #   - p           -> nil
  # -->
  # For each object `obj`, executes:
  #
  #     $stdout.write(obj.inspect, "\n")
  #
  # With one object given, returns the object; with multiple objects given,
  # returns an array containing the objects; with no object given, returns `nil`.
  #
  # Examples:
  #
  #     r = Range.new(0, 4)
  #     p r                 # => 0..4
  #     p [r, r, r]         # => [0..4, 0..4, 0..4]
  #     p                   # => nil
  #
  # Output:
  #
  #     0..4
  #     [0..4, 0..4, 0..4]
  #
  # Kernel#p is designed for debugging purposes. Ruby implementations may define
  # Kernel#p to be uninterruptible in whole or in part. On CRuby, Kernel#p's
  # writing of data is uninterruptible.
  #
  def self?.p: [T < _Inspect] (T arg0) -> T
             | (_Inspect arg0, _Inspect arg1, *_Inspect rest) -> Array[_Inspect]
             | () -> nil

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pp(*objs)
  # -->
  # prints arguments in pretty form.
  #
  # `#pp` returns argument(s).
  #
  def self?.pp: [T] (T arg0) -> T
              | (untyped, untyped, *untyped) -> Array[untyped]
              | () -> nil

  # <!--
  #   rdoc-file=random.c
  #   - rand(max=0)    -> number
  # -->
  # If called without an argument, or if `max.to_i.abs == 0`, rand returns a
  # pseudo-random floating point number between 0.0 and 1.0, including 0.0 and
  # excluding 1.0.
  #
  #     rand        #=> 0.2725926052826416
  #
  # When `max.abs` is greater than or equal to 1, `rand` returns a pseudo-random
  # integer greater than or equal to 0 and less than `max.to_i.abs`.
  #
  #     rand(100)   #=> 12
  #
  # When `max` is a Range, `rand` returns a random number where
  # `range.member?(number) == true`.
  #
  # Negative or floating point values for `max` are allowed, but may give
  # surprising results.
  #
  #     rand(-100) # => 87
  #     rand(-0.5) # => 0.8130921818028143
  #     rand(1.9)  # equivalent to rand(1), which is always 0
  #
  # Kernel.srand may be used to ensure that sequences of random numbers are
  # reproducible between different runs of a program.
  #
  # See also Random.rand.
  #
  def self?.rand: (?0) -> Float
                | (int arg0) -> Integer
                | (::Range[Integer] arg0) -> Integer?
                | (::Range[Float] arg0) -> Float?

  # <!--
  #   rdoc-file=io.c
  #   - readline(sep = $/, chomp: false)   -> string
  #   - readline(limit, chomp: false)      -> string
  #   - readline(sep, limit, chomp: false) -> string
  # -->
  # Equivalent to method Kernel#gets, except that it raises an exception if called
  # at end-of-stream:
  #
  #     $ cat t.txt | ruby -e "p readlines; readline"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #     in `readline': end of file reached (EOFError)
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted.
  #
  def self?.readline: (?String arg0, ?Integer arg1) -> String

  # <!--
  #   rdoc-file=io.c
  #   - readlines(sep = $/, chomp: false, **enc_opts)   -> array
  #   - readlines(limit, chomp: false, **enc_opts)       -> array
  #   - readlines(sep, limit, chomp: false, **enc_opts) -> array
  # -->
  # Returns an array containing the lines returned by calling Kernel#gets until
  # the end-of-stream is reached; (see [Line IO](rdoc-ref:IO@Line+IO)).
  #
  # With only string argument `sep` given, returns the remaining lines as
  # determined by line separator `sep`, or `nil` if none; see [Line
  # Separator](rdoc-ref:IO@Line+Separator):
  #
  #     # Default separator.
  #     $ cat t.txt | ruby -e "p readlines"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #
  #     # Specified separator.
  #     $ cat t.txt | ruby -e "p readlines 'li'"
  #     ["First li", "ne\nSecond li", "ne\n\nFourth li", "ne\nFifth li", "ne\n"]
  #
  #     # Get-all separator.
  #     $ cat t.txt | ruby -e "p readlines nil"
  #     ["First line\nSecond line\n\nFourth line\nFifth line\n"]
  #
  #     # Get-paragraph separator.
  #     $ cat t.txt | ruby -e "p readlines ''"
  #     ["First line\nSecond line\n\n", "Fourth line\nFifth line\n"]
  #
  # With only integer argument `limit` given, limits the number of bytes in the
  # line; see [Line Limit](rdoc-ref:IO@Line+Limit):
  #
  #     $cat t.txt | ruby -e "p readlines 10"
  #     ["First line", "\n", "Second lin", "e\n", "\n", "Fourth lin", "e\n", "Fifth line", "\n"]
  #
  #     $cat t.txt | ruby -e "p readlines 11"
  #     ["First line\n", "Second line", "\n", "\n", "Fourth line", "\n", "Fifth line\n"]
  #
  #     $cat t.txt | ruby -e "p readlines 12"
  #     ["First line\n", "Second line\n", "\n", "Fourth line\n", "Fifth line\n"]
  #
  # With arguments `sep` and `limit` given, combines the two behaviors (see [Line
  # Separator and Line Limit](rdoc-ref:IO@Line+Separator+and+Line+Limit)).
  #
  # Optional keyword argument `chomp` specifies whether line separators are to be
  # omitted:
  #
  #     $ cat t.txt | ruby -e "p readlines(chomp: true)"
  #     ["First line", "Second line", "", "Fourth line", "Fifth line"]
  #
  # Optional keyword arguments `enc_opts` specify encoding options; see [Encoding
  # options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def self?.readlines: (?string sep, ?int limit, ?chomp: boolish) -> ::Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/core_ext/kernel_require.rb
  #   - require(path)
  # -->
  # When RubyGems is required, Kernel#require is replaced with our own which is
  # capable of loading gems on demand.
  #
  # When you call `require 'x'`, this is what happens:
  # *   If the file can be loaded from the existing Ruby loadpath, it is.
  # *   Otherwise, installed gems are searched for a file that matches. If it's
  #     found in gem 'y', that gem is activated (added to the loadpath).
  #
  # The normal `require` functionality of returning false if that file has already
  # been loaded is preserved.
  #
  def self?.require: (String path) -> bool

  # <!--
  #   rdoc-file=load.c
  #   - require_relative(string) -> true or false
  # -->
  # Ruby tries to load the library named *string* relative to the directory
  # containing the requiring file.  If the file does not exist a LoadError is
  # raised. Returns `true` if the file was loaded and `false` if the file was
  # already loaded before.
  #
  def self?.require_relative: (String feature) -> bool

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_ios, write_ios = [], error_ios = [], timeout = nil) -> array or nil
  # -->
  # Invokes system call [select(2)](https://linux.die.net/man/2/select), which
  # monitors multiple file descriptors, waiting until one or more of the file
  # descriptors becomes ready for some class of I/O operation.
  #
  # Not implemented on all platforms.
  #
  # Each of the arguments `read_ios`, `write_ios`, and `error_ios` is an array of
  # IO objects.
  #
  # Argument `timeout` is a numeric value (such as integer or float) timeout
  # interval in seconds.
  #
  # The method monitors the IO objects given in all three arrays, waiting for some
  # to be ready; returns a 3-element array whose elements are:
  #
  # *   An array of the objects in `read_ios` that are ready for reading.
  # *   An array of the objects in `write_ios` that are ready for writing.
  # *   An array of the objects in `error_ios` have pending exceptions.
  #
  # If no object becomes ready within the given `timeout`, `nil` is returned.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after non-blocking methods such
  # as #read_nonblock, #write_nonblock, etc.  The methods raise an exception which
  # is extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how
  # the caller should wait with IO.select.  If IO::WaitReadable is raised, the
  # caller should wait for reading.  If IO::WaitWritable is raised, the caller
  # should wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of non-blocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of non-blocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process; see
  # [select(2)](https://linux.die.net/man/2/select)
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # Example:
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # Output:
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self?.select: (::Array[IO] read, ?::Array[IO] write, ?::Array[IO] error, ?Time::_Timeout timeout) -> ::Array[String]

  # <!--
  #   rdoc-file=process.c
  #   - sleep(secs = nil) -> slept_secs
  # -->
  # Suspends execution of the current thread for the number of seconds specified
  # by numeric argument `secs`, or forever if `secs` is `nil`; returns the integer
  # number of seconds suspended (rounded).
  #
  #     Time.new  # => 2008-03-08 19:56:19 +0900
  #     sleep 1.2 # => 1
  #     Time.new  # => 2008-03-08 19:56:20 +0900
  #     sleep 1.9 # => 2
  #     Time.new  # => 2008-03-08 19:56:22 +0900
  #
  def self?.sleep: (?nil) -> bot
                 | (Time::_Timeout duration) -> Integer

  %a{steep:deprecated}
  interface _Divmod
    def divmod: (Numeric) -> [ Numeric, Numeric ]
  end

  # <!--
  #   rdoc-file=io.c
  #   - syscall(integer_callno, *arguments)   -> integer
  # -->
  # Invokes Posix system call [syscall(2)](https://linux.die.net/man/2/syscall),
  # which calls a specified function.
  #
  # Calls the operating system function identified by `integer_callno`; returns
  # the result of the function or raises SystemCallError if it failed. The effect
  # of the call is platform-dependent. The arguments and returned value are
  # platform-dependent.
  #
  # For each of `arguments`: if it is an integer, it is passed directly; if it is
  # a string, it is interpreted as a binary sequence of bytes. There may be as
  # many as nine such arguments.
  #
  # Arguments `integer_callno` and `argument`, as well as the returned value, are
  # platform-dependent.
  #
  # Note: Method `syscall` is essentially unsafe and unportable. The DL (Fiddle)
  # library is preferred for safer and a bit more portable programming.
  #
  # Not implemented on all platforms.
  #
  def self?.syscall: (Integer num, *untyped args) -> untyped

  # <!--
  #   rdoc-file=file.c
  #   - test(char, path0, path1 = nil) -> object
  # -->
  # Performs a test on one or both of the *filesystem entities* at the given paths
  # `path0` and `path1`:
  # *   Each path `path0` or `path1` points to a file, directory, device, pipe,
  #     etc.
  # *   Character `char` selects a specific test.
  # The tests:
  # *   Each of these tests operates only on the entity at `path0`,
  #      and returns `true` or `false`;
  #      for a non-existent entity, returns `false` (does not raise exception):
  #  Character  |Test
  # ------------|-------------------------------------------------------------------------
  # <tt>'b'</tt>|Whether the entity is a block device.
  # <tt>'c'</tt>|Whether the entity is a character device.
  # <tt>'d'</tt>|Whether the entity is a directory.
  # <tt>'e'</tt>|Whether the entity is an existing entity.
  # <tt>'f'</tt>|Whether the entity is an existing regular file.
  # <tt>'g'</tt>|Whether the entity's setgid bit is set.
  # <tt>'G'</tt>|Whether the entity's group ownership is equal to the caller's.
  # <tt>'k'</tt>|Whether the entity's sticky bit is set.
  # <tt>'l'</tt>|Whether the entity is a symbolic link.
  # <tt>'o'</tt>|Whether the entity is owned by the caller's effective uid.
  # <tt>'O'</tt>|Like <tt>'o'</tt>, but uses the real uid (not the effective uid).
  # <tt>'p'</tt>|Whether the entity is a FIFO device (named pipe).
  # <tt>'r'</tt>|Whether the entity is readable by the caller's effective uid/gid.
  # <tt>'R'</tt>|Like <tt>'r'</tt>, but uses the real uid/gid (not the effective uid/gid).
  # <tt>'S'</tt>|Whether the entity is a socket.
  # <tt>'u'</tt>|Whether the entity's setuid bit is set.
  # <tt>'w'</tt>|Whether the entity is writable by the caller's effective uid/gid.
  # <tt>'W'</tt>|Like <tt>'w'</tt>, but uses the real uid/gid (not the effective uid/gid).
  # <tt>'x'</tt>|Whether the entity is executable by the caller's effective uid/gid.
  # <tt>'X'</tt>|Like <tt>'x'</tt>, but uses the real uid/gid (not the effective uid/git).
  # <tt>'z'</tt>|Whether the entity exists and is of length zero.
  # *   This test operates only on the entity at `path0`,
  #      and returns an integer size or `nil`:
  #  Character  |Test
  # ------------|--------------------------------------------------------------------------------------------
  # <tt>'s'</tt>|Returns positive integer size if the entity exists and has non-zero length, +nil+ otherwise.
  # *   Each of these tests operates only on the entity at `path0`,
  #      and returns a Time object;
  #      raises an exception if the entity does not exist:
  #  Character  |Test
  # ------------|--------------------------------------
  # <tt>'A'</tt>|Last access time for the entity.
  # <tt>'C'</tt>|Last change time for the entity.
  # <tt>'M'</tt>|Last modification time for the entity.
  # *   Each of these tests operates on the modification time (`mtime`)
  #      of each of the entities at `path0` and `path1`,
  #      and returns a `true` or `false`;
  #      returns `false` if either entity does not exist:
  #  Character  |Test
  # ------------|---------------------------------------------------------------
  # <tt>'<'</tt>|Whether the `mtime` at `path0` is less than that at `path1`.
  # <tt>'='</tt>|Whether the `mtime` at `path0` is equal to that at `path1`.
  # <tt>'>'</tt>|Whether the `mtime` at `path0` is greater than that at `path1`.
  # *   This test operates on the content of each of the entities at `path0` and
  #     `path1`,
  #      and returns a `true` or `false`;
  #      returns `false` if either entity does not exist:
  #  Character  |Test
  # ------------|---------------------------------------------
  # <tt>'-'</tt>|Whether the entities exist and are identical.
  #
  def self?.test: (String | Integer cmd, String | IO file1, ?String | IO file2) -> (TrueClass | FalseClass | Time | nil | Integer)

  # <!--
  #   rdoc-file=vm_eval.c
  #   - throw(tag [, obj])
  # -->
  # Transfers control to the end of the active `catch` block waiting for *tag*.
  # Raises `UncaughtThrowError` if there is no `catch` block for the *tag*. The
  # optional second parameter supplies a return value for the `catch` block, which
  # otherwise defaults to `nil`. For examples, see Kernel::catch.
  #
  def self?.throw: (untyped tag, ?untyped obj) -> bot

  # <!--
  #   rdoc-file=warning.rb
  #   - warn(*msgs, uplevel: nil, category: nil)   -> nil
  # -->
  # If warnings have been disabled (for example with the `-W0` flag), does
  # nothing.  Otherwise, converts each of the messages to strings, appends a
  # newline character to the string if the string does not end in a newline, and
  # calls Warning.warn with the string.
  #
  #     warn("warning 1", "warning 2")
  #
  # *produces:*
  #
  #     warning 1
  #     warning 2
  #
  # If the `uplevel` keyword argument is given, the string will be prepended with
  # information for the given caller frame in the same format used by the
  # `rb_warn` C function.
  #
  #     # In baz.rb
  #     def foo
  #       warn("invalid call to foo", uplevel: 1)
  #     end
  #
  #     def bar
  #       foo
  #     end
  #
  #     bar
  #
  # *produces:*
  #
  #     baz.rb:6: warning: invalid call to foo
  #
  # If `category` keyword argument is given, passes the category to
  # `Warning.warn`.  The category given must be one of the following categories:
  #
  # :deprecated
  # :   Used for warning for deprecated functionality that may be removed in the
  #     future.
  #
  # :experimental
  # :   Used for experimental features that may change in future releases.
  #
  # :performance
  # :   Used for warning about APIs or pattern that have negative performance
  #     impact
  #
  def self?.warn: (*_ToS msg, ?uplevel: int?, ?category: Warning::category?) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - exec([env, ] command_line, options = {})
  #   - exec([env, ] exe_path, *args, options  = {})
  # -->
  # Replaces the current process by doing one of the following:
  #
  # *   Passing string `command_line` to the shell.
  # *   Invoking the executable at `exe_path`.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # The new process is created using the [exec system
  # call](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/functions/e
  # xecve.html); it may inherit some of its environment from the calling program
  # (possibly including open file descriptors).
  #
  # Argument `env`, if given, is a hash that affects `ENV` for the new process;
  # see [Execution Environment](rdoc-ref:Process@Execution+Environment).
  #
  # Argument `options` is a hash of options for the new process; see [Execution
  # Options](rdoc-ref:Process@Execution+Options).
  #
  # The first required argument is one of the following:
  #
  # *   `command_line` if it is a string, and if it begins with a shell reserved
  #     word or special built-in, or if it contains one or more meta characters.
  # *   `exe_path` otherwise.
  #
  # **Argument `command_line`**
  #
  # String argument `command_line` is a command line to be passed to a shell; it
  # must begin with a shell reserved word, begin with a special built-in, or
  # contain meta characters:
  #
  #     exec('if true; then echo "Foo"; fi') # Shell reserved word.
  #     exec('exit')                         # Built-in.
  #     exec('date > date.tmp')              # Contains meta character.
  #
  # The command line may also contain arguments and options for the command:
  #
  #     exec('echo "Foo"')
  #
  # Output:
  #
  #     Foo
  #
  # See [Execution Shell](rdoc-ref:Process@Execution+Shell) for details about the
  # shell.
  #
  # Raises an exception if the new process could not execute.
  #
  # **Argument `exe_path`**
  #
  # Argument `exe_path` is one of the following:
  #
  # *   The string path to an executable to be called.
  # *   A 2-element array containing the path to an executable and the string to
  #     be used as the name of the executing process.
  #
  # Example:
  #
  #     exec('/usr/bin/date')
  #
  # Output:
  #
  #     Sat Aug 26 09:38:00 AM CDT 2023
  #
  # Ruby invokes the executable directly. This form does not use the shell; see
  # [Arguments args](rdoc-ref:Process@Arguments+args) for caveats.
  #
  #     exec('doesnt_exist') # Raises Errno::ENOENT
  #
  # If one or more `args` is given, each is an argument or option to be passed to
  # the executable:
  #
  #     exec('echo', 'C*')
  #     exec('echo', 'hello', 'world')
  #
  # Output:
  #
  #     C*
  #     hello world
  #
  # Raises an exception if the new process could not execute.
  #
  def self?.exec: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> bot
                | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> bot

  type redirect_fd = Integer | :in | :out | :err | IO | String | [ String ] | [ String, string | int ] | [ String, string | int, int ] | [ :child, int ] | :close

  # <!--
  #   rdoc-file=process.c
  #   - spawn([env, ] command_line, options = {}) -> pid
  #   - spawn([env, ] exe_path, *args, options  = {}) -> pid
  # -->
  # Creates a new child process by doing one of the following in that process:
  #
  # *   Passing string `command_line` to the shell.
  # *   Invoking the executable at `exe_path`.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # Returns the process ID (pid) of the new process, without waiting for it to
  # complete.
  #
  # To avoid zombie processes, the parent process should call either:
  #
  # *   Process.wait, to collect the termination statuses of its children.
  # *   Process.detach, to register disinterest in their status.
  #
  # The new process is created using the [exec system
  # call](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/functions/e
  # xecve.html); it may inherit some of its environment from the calling program
  # (possibly including open file descriptors).
  #
  # Argument `env`, if given, is a hash that affects `ENV` for the new process;
  # see [Execution Environment](rdoc-ref:Process@Execution+Environment).
  #
  # Argument `options` is a hash of options for the new process; see [Execution
  # Options](rdoc-ref:Process@Execution+Options).
  #
  # The first required argument is one of the following:
  #
  # *   `command_line` if it is a string, and if it begins with a shell reserved
  #     word or special built-in, or if it contains one or more meta characters.
  # *   `exe_path` otherwise.
  #
  # **Argument `command_line`**
  #
  # String argument `command_line` is a command line to be passed to a shell; it
  # must begin with a shell reserved word, begin with a special built-in, or
  # contain meta characters:
  #
  #     spawn('if true; then echo "Foo"; fi') # => 798847 # Shell reserved word.
  #     Process.wait                          # => 798847
  #     spawn('exit')                         # => 798848 # Built-in.
  #     Process.wait                          # => 798848
  #     spawn('date > /tmp/date.tmp')         # => 798879 # Contains meta character.
  #     Process.wait                          # => 798849
  #     spawn('date > /nop/date.tmp')         # => 798882 # Issues error message.
  #     Process.wait                          # => 798882
  #
  # The command line may also contain arguments and options for the command:
  #
  #     spawn('echo "Foo"') # => 799031
  #     Process.wait        # => 799031
  #
  # Output:
  #
  #     Foo
  #
  # See [Execution Shell](rdoc-ref:Process@Execution+Shell) for details about the
  # shell.
  #
  # Raises an exception if the new process could not execute.
  #
  # **Argument `exe_path`**
  #
  # Argument `exe_path` is one of the following:
  #
  # *   The string path to an executable to be called.
  # *   A 2-element array containing the path to an executable to be called, and
  #     the string to be used as the name of the executing process.
  #
  #         spawn('/usr/bin/date') # Path to date on Unix-style system.
  #         Process.wait
  #
  #     Output:
  #
  #         Mon Aug 28 11:43:10 AM CDT 2023
  #
  # Ruby invokes the executable directly. This form does not use the shell; see
  # [Arguments args](rdoc-ref:Process@Arguments+args) for caveats.
  #
  # If one or more `args` is given, each is an argument or option to be passed to
  # the executable:
  #
  #     spawn('echo', 'C*')             # => 799392
  #     Process.wait                    # => 799392
  #     spawn('echo', 'hello', 'world') # => 799393
  #     Process.wait                    # => 799393
  #
  # Output:
  #
  #     C*
  #     hello world
  #
  # Raises an exception if the new process could not execute.
  #
  def self?.spawn: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer
                 | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - system([env, ] command_line, options = {}, exception: false) -> true, false, or nil
  #   - system([env, ] exe_path, *args, options  = {}, exception: false) -> true, false, or nil
  # -->
  # Creates a new child process by doing one of the following in that process:
  #
  # *   Passing string `command_line` to the shell.
  # *   Invoking the executable at `exe_path`.
  #
  # This method has potential security vulnerabilities if called with untrusted
  # input; see [Command Injection](rdoc-ref:command_injection.rdoc).
  #
  # Returns:
  #
  # *   `true` if the command exits with status zero.
  # *   `false` if the exit status is a non-zero integer.
  # *   `nil` if the command could not execute.
  #
  # Raises an exception (instead of returning `false` or `nil`) if keyword
  # argument `exception` is set to `true`.
  #
  # Assigns the command's error status to `$?`.
  #
  # The new process is created using the [system system
  # call](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/functions/s
  # ystem.html); it may inherit some of its environment from the calling program
  # (possibly including open file descriptors).
  #
  # Argument `env`, if given, is a hash that affects `ENV` for the new process;
  # see [Execution Environment](rdoc-ref:Process@Execution+Environment).
  #
  # Argument `options` is a hash of options for the new process; see [Execution
  # Options](rdoc-ref:Process@Execution+Options).
  #
  # The first required argument is one of the following:
  #
  # *   `command_line` if it is a string, and if it begins with a shell reserved
  #     word or special built-in, or if it contains one or more meta characters.
  # *   `exe_path` otherwise.
  #
  # **Argument `command_line`**
  #
  # String argument `command_line` is a command line to be passed to a shell; it
  # must begin with a shell reserved word, begin with a special built-in, or
  # contain meta characters:
  #
  #     system('if true; then echo "Foo"; fi')          # => true  # Shell reserved word.
  #     system('exit')                                  # => true  # Built-in.
  #     system('date > /tmp/date.tmp')                  # => true  # Contains meta character.
  #     system('date > /nop/date.tmp')                  # => false
  #     system('date > /nop/date.tmp', exception: true) # Raises RuntimeError.
  #
  # Assigns the command's error status to `$?`:
  #
  #     system('exit')                             # => true  # Built-in.
  #     $?                                         # => #<Process::Status: pid 640610 exit 0>
  #     system('date > /nop/date.tmp')             # => false
  #     $?                                         # => #<Process::Status: pid 640742 exit 2>
  #
  # The command line may also contain arguments and options for the command:
  #
  #     system('echo "Foo"') # => true
  #
  # Output:
  #
  #     Foo
  #
  # See [Execution Shell](rdoc-ref:Process@Execution+Shell) for details about the
  # shell.
  #
  # Raises an exception if the new process could not execute.
  #
  # **Argument `exe_path`**
  #
  # Argument `exe_path` is one of the following:
  #
  # *   The string path to an executable to be called.
  # *   A 2-element array containing the path to an executable and the string to
  #     be used as the name of the executing process.
  #
  # Example:
  #
  #     system('/usr/bin/date') # => true # Path to date on Unix-style system.
  #     system('foo')           # => nil  # Command failed.
  #
  # Output:
  #
  #     Mon Aug 28 11:43:10 AM CDT 2023
  #
  # Assigns the command's error status to `$?`:
  #
  #     system('/usr/bin/date') # => true
  #     $?                      # => #<Process::Status: pid 645605 exit 0>
  #     system('foo')           # => nil
  #     $?                      # => #<Process::Status: pid 645608 exit 127>
  #
  # Ruby invokes the executable directly. This form does not use the shell; see
  # [Arguments args](rdoc-ref:Process@Arguments+args) for caveats.
  #
  #     system('doesnt_exist') # => nil
  #
  # If one or more `args` is given, each is an argument or option to be passed to
  # the executable:
  #
  #     system('echo', 'C*')             # => true
  #     system('echo', 'hello', 'world') # => true
  #
  # Output:
  #
  #     C*
  #     hello world
  #
  # Raises an exception if the new process could not execute.
  #
  def self?.system: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String, ?exception: bool) -> (NilClass | FalseClass | TrueClass)
                  | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String, ?exception: bool) -> (NilClass | FalseClass | TrueClass)

  # <!--
  #   rdoc-file=object.c
  #   - obj !~ other  -> true or false
  # -->
  # Returns true if two objects do not match (using the *=~* method), otherwise
  # false.
  #
  def !~: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj <=> other -> 0 or nil
  # -->
  # Returns 0 if `obj` and `other` are the same object or `obj == other`,
  # otherwise nil.
  #
  # The #<=> is used by various methods to compare objects, for example
  # Enumerable#sort, Enumerable#max etc.
  #
  # Your implementation of #<=> should return one of the following values: -1, 0,
  # 1 or nil. -1 means self is smaller than other. 0 means self is equal to other.
  # 1 means self is bigger than other. Nil means the two values could not be
  # compared.
  #
  # When you define #<=>, you can include Comparable to gain the methods #<=, #<,
  # #==, #>=, #> and #between?.
  #
  def <=>: (untyped other) -> 0?

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  alias === ==

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.clone(freeze: nil) -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. #clone copies the frozen value state of
  # *obj*, unless the `:freeze` keyword argument is given with a false or true
  # value. See also the discussion under Object#dup.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior. If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool?) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - define_singleton_method(symbol, method) -> symbol
  #   - define_singleton_method(symbol) { block } -> symbol
  # -->
  # Defines a public singleton method in the receiver. The *method* parameter can
  # be a `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified,
  # it is used as the method body. If a block or a method has parameters, they're
  # used as method parameters.
  #
  #     class A
  #       class << self
  #         def class_name
  #           to_s
  #         end
  #       end
  #     end
  #     A.define_singleton_method(:who_am_i) do
  #       "I am: #{class_name}"
  #     end
  #     A.who_am_i   # ==> "I am: A"
  #
  #     guy = "Bob"
  #     guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
  #     guy.hello    #=>  "Bob: Hello there!"
  #
  #     chris = "Chris"
  #     chris.define_singleton_method(:greet) {|greeting| "#{greeting}, I'm Chris!" }
  #     chris.greet("Hi") #=> "Hi, I'm Chris!"
  #
  def define_singleton_method: (interned name, Method | UnboundMethod | Proc method) -> Symbol
                             | (interned name) { (?) -> untyped } -> Symbol

  # <!--
  #   rdoc-file=io.c
  #   - display(port = $>) -> nil
  # -->
  # Writes `self` on the given port:
  #
  #     1.display
  #     "cat".display
  #     [ 4, 5, 6 ].display
  #     puts
  #
  # Output:
  #
  #     1cat[4, 5, 6]
  #
  def display: (?_Writer port) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - obj.dup -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, #clone and #dup may have different semantics in descendant
  # classes. While #clone is used to duplicate an object, including its internal
  # state, #dup typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401be280>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401c1084>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401c1084>
  #
  def dup: () -> self

  # <!-- rdoc-file=enumerator.c -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  def enum_for: (?interned method, *untyped, **untyped) ?{ (*untyped, **untyped) -> Integer } -> Enumerator[untyped, untyped]

  alias to_enum enum_for

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - obj.extend(module, ...)    -> obj
  # -->
  # Adds to *obj* the instance methods from each module given as a parameter.
  #
  #     module Mod
  #       def hello
  #         "Hello from Mod.\n"
  #       end
  #     end
  #
  #     class Klass
  #       def hello
  #         "Hello from Klass.\n"
  #       end
  #     end
  #
  #     k = Klass.new
  #     k.hello         #=> "Hello from Klass.\n"
  #     k.extend(Mod)   #=> #<Klass:0x401b3bc8>
  #     k.hello         #=> "Hello from Mod.\n"
  #
  def extend: (Module module, *Module other_modules) -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.freeze    -> obj
  # -->
  # Prevents further modifications to *obj*. A FrozenError will be raised if
  # modification is attempted. There is no way to unfreeze a frozen object. See
  # also Object#frozen?.
  #
  # This method returns self.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze
  #     a << "z"
  #
  # *produces:*
  #
  #     prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
  #      from prog.rb:3
  #
  # Objects of the following classes are always frozen: Integer, Float, Symbol.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.frozen?    -> true or false
  # -->
  # Returns the freeze status of *obj*.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze    #=> ["a", "b", "c"]
  #     a.frozen?   #=> true
  #
  def frozen?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.hash    -> integer
  # -->
  # Generates an Integer hash value for this object.  This function must have the
  # property that `a.eql?(b)` implies `a.hash == b.hash`.
  #
  # The hash value is used along with #eql? by the Hash class to determine if two
  # objects reference the same hash key.  Any hash value that exceeds the capacity
  # of an Integer will be truncated before being used.
  #
  # The hash value for an object may not be identical across invocations or
  # implementations of Ruby.  If you need a stable identifier across Ruby
  # invocations and implementations you will need to generate one with a custom
  # method.
  #
  # Certain core classes such as Integer use built-in hash calculations and do not
  # call the #hash method when used as a hash key.
  #
  # When implementing your own #hash based on multiple values, the best practice
  # is to combine the class and any values using the hash code of an array:
  #
  # For example:
  #
  #     def hash
  #       [self.class, a, b, c].hash
  #     end
  #
  # The reason for this is that the Array#hash method already has logic for safely
  # and efficiently combining multiple hash values.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.inspect   -> string
  # -->
  # Returns a string containing a human-readable representation of *obj*. The
  # default #inspect shows the object's class name, an encoding of its memory
  # address, and a list of the instance variables and their values (by calling
  # #inspect on each of them).  User defined classes should override this method
  # to provide a better representation of *obj*.  When overriding this method, it
  # should return a string whose encoding is compatible with the default external
  # encoding.
  #
  #     [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
  #     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
  #
  #     class Foo
  #     end
  #     Foo.new.inspect                  #=> "#<Foo:0x0300c868>"
  #
  #     class Bar
  #       def initialize
  #         @bar = 1
  #       end
  #     end
  #     Bar.new.inspect                  #=> "#<Bar:0x0300c868 @bar=1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_of?(class)    -> true or false
  # -->
  # Returns `true` if *obj* is an instance of the given class. See also
  # Object#kind_of?.
  #
  #     class A;     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.instance_of? A   #=> false
  #     b.instance_of? B   #=> true
  #     b.instance_of? C   #=> false
  #
  def instance_of?: (Module | Class module_or_class) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_defined?(symbol)    -> true or false
  #   - obj.instance_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given instance variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_defined?(:@a)    #=> true
  #     fred.instance_variable_defined?("@b")   #=> true
  #     fred.instance_variable_defined?("@c")   #=> false
  #
  def instance_variable_defined?: (interned variable) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_get(symbol)    -> obj
  #   - obj.instance_variable_get(string)    -> obj
  # -->
  # Returns the value of the given instance variable, or nil if the instance
  # variable is not set. The `@` part of the variable name should be included for
  # regular instance variables. Throws a NameError exception if the supplied
  # symbol is not valid as an instance variable name. String arguments are
  # converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_get(:@a)    #=> "cat"
  #     fred.instance_variable_get("@b")   #=> 99
  #
  def instance_variable_get: (interned variable) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_set(symbol, obj)    -> obj
  #   - obj.instance_variable_set(string, obj)    -> obj
  # -->
  # Sets the instance variable named by *symbol* to the given object. This may
  # circumvent the encapsulation intended by the author of the class, so it should
  # be used with care. The variable does not have to exist prior to this call. If
  # the instance variable name is passed as a string, that string is converted to
  # a symbol.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_set(:@a, 'dog')   #=> "dog"
  #     fred.instance_variable_set(:@c, 'cat')   #=> "cat"
  #     fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"
  #
  def instance_variable_set: [T] (interned variable, T value) -> T

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variables    -> array
  # -->
  # Returns an array of instance variable names for the receiver. Note that simply
  # defining an accessor does not create the corresponding instance variable.
  #
  #     class Fred
  #       attr_accessor :a1
  #       def initialize
  #         @iv = 3
  #       end
  #     end
  #     Fred.new.instance_variables   #=> [:@iv]
  #
  def instance_variables: () -> Array[Symbol]

  # <!-- rdoc-file=object.c -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  def is_a?: (Module | Class module_or_class) -> bool

  alias kind_of? is_a?

  # <!--
  #   rdoc-file=object.c
  #   - obj.itself    -> obj
  # -->
  # Returns the receiver.
  #
  #     string = "my string"
  #     string.itself.object_id == string.object_id   #=> true
  #
  def itself: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - obj.method(sym)    -> method
  # -->
  # Looks up the named method as a receiver in *obj*, returning a Method object
  # (or raising NameError). The Method object acts as a closure in *obj*'s object
  # instance, so instance variables and the value of `self` remain available.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     m = k.method(:hello)
  #     m.call   #=> "Hello, @iv = 99"
  #
  #     l = Demo.new('Fred')
  #     m = l.method("hello")
  #     m.call   #=> "Hello, @iv = Fred"
  #
  # Note that Method implements `to_proc` method, which means it can be used with
  # iterators.
  #
  #     [ 1, 2, 3 ].each(&method(:puts)) # => prints 3 lines to stdout
  #
  #     out = File.open('test.txt', 'w')
  #     [ 1, 2, 3 ].each(&out.method(:puts)) # => prints 3 lines to file
  #
  #     require 'date'
  #     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
  #     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
  #
  def method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.methods(regular=true)    -> array
  # -->
  # Returns a list of the names of public and protected methods of *obj*. This
  # will include all the methods accessible in *obj*'s ancestors. If the optional
  # parameter is `false`, it returns an array of *obj*'s public and protected
  # singleton methods, the array will not include methods in modules included in
  # *obj*.
  #
  #     class Klass
  #       def klass_method()
  #       end
  #     end
  #     k = Klass.new
  #     k.methods[0..9]    #=> [:klass_method, :nil?, :===,
  #                        #    :==~, :!, :eql?
  #                        #    :hash, :<=>, :class, :singleton_class]
  #     k.methods.length   #=> 56
  #
  #     k.methods(false)   #=> []
  #     def k.singleton_method; end
  #     k.methods(false)   #=> [:singleton_method]
  #
  #     module M123; def m123; end end
  #     k.extend M123
  #     k.methods(false)   #=> [:singleton_method]
  #
  def methods: (?boolish regular) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.nil?               -> true or false
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  #     Object.new.nil?   #=> false
  #     nil.nil?          #=> true
  #
  def nil?: () -> false

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  alias object_id __id__

  # <!--
  #   rdoc-file=object.c
  #   - obj.private_methods(all=true)   -> array
  # -->
  # Returns the list of private methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def private_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.protected_methods(all=true)   -> array
  # -->
  # Returns the list of protected methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def protected_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - obj.public_method(sym)    -> method
  # -->
  # Similar to *method*, searches public method only.
  #
  def public_method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.public_methods(all=true)   -> array
  # -->
  # Returns the list of public methods accessible to *obj*. If the *all* parameter
  # is set to `false`, only those methods in the receiver will be listed.
  #
  def public_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.public_send(symbol [, args...])  -> obj
  #   - obj.public_send(string [, args...])  -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # Unlike send, public_send calls public methods only. When the method is
  # identified by a string, the string is converted to a symbol.
  #
  #     1.public_send(:puts, "hello")  # causes NoMethodError
  #
  def public_send: (interned name, *untyped, **untyped) ?{ (?) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.remove_instance_variable(symbol)    -> obj
  #   - obj.remove_instance_variable(string)    -> obj
  # -->
  # Removes the named instance variable from *obj*, returning that variable's
  # value. String arguments are converted to symbols.
  #
  #     class Dummy
  #       attr_reader :var
  #       def initialize
  #         @var = 99
  #       end
  #       def remove
  #         remove_instance_variable(:@var)
  #       end
  #     end
  #     d = Dummy.new
  #     d.var      #=> 99
  #     d.remove   #=> 99
  #     d.var      #=> nil
  #
  def remove_instance_variable: (interned variable) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to?(symbol, include_all=false) -> true or false
  #   - obj.respond_to?(string, include_all=false) -> true or false
  # -->
  # Returns `true` if *obj* responds to the given method.  Private and protected
  # methods are included in the search only if the optional second parameter
  # evaluates to `true`.
  #
  # If the method is not implemented, as Process.fork on Windows, File.lchmod on
  # GNU/Linux, etc., false is returned.
  #
  # If the method is not defined, `respond_to_missing?` method is called and the
  # result is returned.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  def respond_to?: (interned name, ?boolish include_all) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to_missing?(symbol, include_all) -> true or false
  #   - obj.respond_to_missing?(string, include_all) -> true or false
  # -->
  # DO NOT USE THIS DIRECTLY.
  #
  # Hook method to return whether the *obj* can respond to *id* method or not.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  # See #respond_to?, and the example of BasicObject.
  #
  private def respond_to_missing?: (Symbol | String name, bool include_all) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  alias send __send__

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_class    -> class
  # -->
  # Returns the singleton class of *obj*.  This method creates a new singleton
  # class if *obj* does not have one.
  #
  # If *obj* is `nil`, `true`, or `false`, it returns NilClass, TrueClass, or
  # FalseClass, respectively. If *obj* is an Integer, a Float or a Symbol, it
  # raises a TypeError.
  #
  #     Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
  #     String.singleton_class      #=> #<Class:String>
  #     nil.singleton_class         #=> NilClass
  #
  def singleton_class: () -> Class

  # <!--
  #   rdoc-file=proc.c
  #   - obj.singleton_method(sym)    -> method
  # -->
  # Similar to *method*, searches singleton method only.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     def k.hi
  #       "Hi, @iv = #{@iv}"
  #     end
  #     m = k.singleton_method(:hi)
  #     m.call   #=> "Hi, @iv = 99"
  #     m = k.singleton_method(:hello) #=> NameError
  #
  def singleton_method: (interned name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_methods(all=true)    -> array
  # -->
  # Returns an array of the names of singleton methods for *obj*. If the optional
  # *all* parameter is true, the list will include methods in modules included in
  # *obj*. Only public and protected singleton methods are returned.
  #
  #     module Other
  #       def three() end
  #     end
  #
  #     class Single
  #       def Single.four() end
  #     end
  #
  #     a = Single.new
  #
  #     def a.one()
  #     end
  #
  #     class << a
  #       include Other
  #       def two()
  #       end
  #     end
  #
  #     Single.singleton_methods    #=> [:four]
  #     a.singleton_methods(false)  #=> [:two, :one]
  #     a.singleton_methods         #=> [:two, :one, :three]
  #
  def singleton_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.tap {|x| block }    -> obj
  # -->
  # Yields self to the block and then returns self. The primary purpose of this
  # method is to "tap into" a method chain, in order to perform operations on
  # intermediate results within the chain.
  #
  #     (1..10)                  .tap {|x| puts "original: #{x}" }
  #       .to_a                  .tap {|x| puts "array:    #{x}" }
  #       .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
  #       .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }
  #
  def tap: () { (self) -> void } -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.to_s    -> string
  # -->
  # Returns a string representing *obj*. The default #to_s prints the object's
  # class and an encoding of the object id. As a special case, the top-level
  # object that is the initial execution context of Ruby programs returns
  # ``main''.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=kernel.rb
  #   - yield_self()
  # -->
  #
  def yield_self: () -> Enumerator[self, untyped]
                | [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.then {|x| block }          -> an_object
  # -->
  # Yields self to the block and returns the result of the block.
  #
  #     3.next.then {|x| x**x }.to_s             #=> "256"
  #
  # A good use of `then` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments)
  #       .then {|url| URI(url).read }
  #       .then {|response| JSON.parse(response) }
  #
  # When called without a block, the method returns an `Enumerator`, which can be
  # used, for example, for conditional circuit-breaking:
  #
  #     # Meets condition, no-op
  #     1.then.detect(&:odd?)            # => 1
  #     # Does not meet condition, drop value
  #     2.then.detect(&:odd?)            # => nil
  #
  alias then yield_self

  private

  def initialize_copy: (self object) -> self

  def initialize_clone: (self object, ?freeze: bool?) -> self

  def initialize_dup: (self object) -> self
end
# <!-- rdoc-file=file.c -->
# A File object is a representation of a file in the underlying platform.
#
# Class File extends module FileTest, supporting such singleton methods as
# `File.exist?`.
#
# ## About the Examples
#
# Many examples here use these variables:
#
#     # English text with newlines.
#     text = <<~EOT
#       First line
#       Second line
#
#       Fourth line
#       Fifth line
#     EOT
#
#     # Russian text.
#     russian = "\u{442 435 441 442}" # => ""
#
#     # Binary data.
#     data = "\u9990\u9991\u9992\u9993\u9994"
#
#     # Text file.
#     File.write('t.txt', text)
#
#     # File with Russian text.
#     File.write('t.rus', russian)
#
#     # File with binary data.
#     f = File.new('t.dat', 'wb:UTF-16')
#     f.write(data)
#     f.close
#
# ## Access Modes
#
# Methods File.new and File.open each create a File object for a given file
# path.
#
# ### String Access Modes
#
# Methods File.new and File.open each may take string argument `mode`, which:
#
# *   Begins with a 1- or 2-character [read/write
#     mode](rdoc-ref:File@Read-2FWrite+Mode).
# *   May also contain a 1-character [data mode](rdoc-ref:File@Data+Mode).
# *   May also contain a 1-character [file-create
#     mode](rdoc-ref:File@File-Create+Mode).
#
# #### Read/Write Mode
#
# The read/write `mode` determines:
#
# *   Whether the file is to be initially truncated.
#
# *   Whether reading is allowed, and if so:
#
#     *   The initial read position in the file.
#     *   Where in the file reading can occur.
#
# *   Whether writing is allowed, and if so:
#
#     *   The initial write position in the file.
#     *   Where in the file writing can occur.
#
# These tables summarize:
#
#     Read/Write Modes for Existing File
#
#     |------|-----------|----------|----------|----------|-----------|
#     | R/W  | Initial   |          | Initial  |          | Initial   |
#     | Mode | Truncate? |  Read    | Read Pos |  Write   | Write Pos |
#     |------|-----------|----------|----------|----------|-----------|
#     | 'r'  |    No     | Anywhere |    0     |   Error  |     -     |
#     | 'w'  |    Yes    |   Error  |    -     | Anywhere |     0     |
#     | 'a'  |    No     |   Error  |    -     | End only |    End    |
#     | 'r+' |    No     | Anywhere |    0     | Anywhere |     0     |
#     | 'w+' |    Yes    | Anywhere |    0     | Anywhere |     0     |
#     | 'a+' |    No     | Anywhere |   End    | End only |    End    |
#     |------|-----------|----------|----------|----------|-----------|
#
#     Read/Write Modes for \File To Be Created
#
#     |------|----------|----------|----------|-----------|
#     | R/W  |          | Initial  |          | Initial   |
#     | Mode |  Read    | Read Pos |  Write   | Write Pos |
#     |------|----------|----------|----------|-----------|
#     | 'w'  |   Error  |    -     | Anywhere |     0     |
#     | 'a'  |   Error  |    -     | End only |     0     |
#     | 'w+' | Anywhere |    0     | Anywhere |     0     |
#     | 'a+' | Anywhere |    0     | End only |    End    |
#     |------|----------|----------|----------|-----------|
#
# Note that modes `'r'` and `'r+'` are not allowed for a non-existent file
# (exception raised).
#
# In the tables:
#
# *   `Anywhere` means that methods IO#rewind, IO#pos=, and IO#seek may be used
#     to change the file's position, so that allowed reading or writing may
#     occur anywhere in the file.
# *   `End only` means that writing can occur only at end-of-file, and that
#     methods IO#rewind, IO#pos=, and IO#seek do not affect writing.
# *   `Error` means that an exception is raised if disallowed reading or writing
#     is attempted.
#
# ##### Read/Write Modes for Existing File
#
# *   `'r'`:
#
#     *   File is not initially truncated:
#
#             f = File.new('t.txt') # => #<File:t.txt>
#             f.size == 0           # => false
#
#     *   File's initial read position is 0:
#
#             f.pos # => 0
#
#     *   File may be read anywhere; see IO#rewind, IO#pos=, IO#seek:
#
#             f.readline # => "First line\n"
#             f.readline # => "Second line\n"
#
#             f.rewind
#             f.readline # => "First line\n"
#
#             f.pos = 1
#             f.readline # => "irst line\n"
#
#             f.seek(1, :CUR)
#             f.readline # => "econd line\n"
#
#     *   Writing is not allowed:
#
#             f.write('foo') # Raises IOError.
#
# *   `'w'`:
#
#     *   File is initially truncated:
#
#             path = 't.tmp'
#             File.write(path, text)
#             f = File.new(path, 'w')
#             f.size == 0 # => true
#
#     *   File's initial write position is 0:
#
#             f.pos # => 0
#
#     *   File may be written anywhere (even past end-of-file); see IO#rewind,
#         IO#pos=, IO#seek:
#
#             f.write('foo')
#             f.flush
#             File.read(path) # => "foo"
#             f.pos # => 3
#
#             f.write('bar')
#             f.flush
#             File.read(path) # => "foobar"
#             f.pos # => 6
#
#             f.rewind
#             f.write('baz')
#             f.flush
#             File.read(path) # => "bazbar"
#             f.pos # => 3
#
#             f.pos = 3
#             f.write('foo')
#             f.flush
#             File.read(path) # => "bazfoo"
#             f.pos # => 6
#
#             f.seek(-3, :END)
#             f.write('bam')
#             f.flush
#             File.read(path) # => "bazbam"
#             f.pos # => 6
#
#             f.pos = 8
#             f.write('bah')  # Zero padding as needed.
#             f.flush
#             File.read(path) # => "bazbam\u0000\u0000bah"
#             f.pos # => 11
#
#     *   Reading is not allowed:
#
#             f.read # Raises IOError.
#
# *   `'a'`:
#
#     *   File is not initially truncated:
#
#             path = 't.tmp'
#             File.write(path, 'foo')
#             f = File.new(path, 'a')
#             f.size == 0 # => false
#
#     *   File's initial position is 0 (but is ignored):
#
#             f.pos # => 0
#
#     *   File may be written only at end-of-file; IO#rewind, IO#pos=, IO#seek
#         do not affect writing:
#
#             f.write('bar')
#             f.flush
#             File.read(path) # => "foobar"
#             f.write('baz')
#             f.flush
#             File.read(path) # => "foobarbaz"
#
#             f.rewind
#             f.write('bat')
#             f.flush
#             File.read(path) # => "foobarbazbat"
#
#     *   Reading is not allowed:
#
#             f.read # Raises IOError.
#
# *   `'r+'`:
#
#     *   File is not initially truncated:
#
#             path = 't.tmp'
#             File.write(path, text)
#             f = File.new(path, 'r+')
#             f.size == 0 # => false
#
#     *   File's initial read position is 0:
#
#             f.pos # => 0
#
#     *   File may be read or written anywhere (even past end-of-file); see
#         IO#rewind, IO#pos=, IO#seek:
#
#             f.readline # => "First line\n"
#             f.readline # => "Second line\n"
#
#             f.rewind
#             f.readline # => "First line\n"
#
#             f.pos = 1
#             f.readline # => "irst line\n"
#
#             f.seek(1, :CUR)
#             f.readline # => "econd line\n"
#
#             f.rewind
#             f.write('WWW')
#             f.flush
#             File.read(path)
#             # => "WWWst line\nSecond line\nFourth line\nFifth line\n"
#
#             f.pos = 10
#             f.write('XXX')
#             f.flush
#             File.read(path)
#             # => "WWWst lineXXXecond line\nFourth line\nFifth line\n"
#
#             f.seek(-6, :END)
#             # => 0
#             f.write('YYY')
#             # => 3
#             f.flush
#             # => #<File:t.tmp>
#             File.read(path)
#             # => "WWWst lineXXXecond line\nFourth line\nFifth YYYe\n"
#
#             f.seek(2, :END)
#             f.write('ZZZ') # Zero padding as needed.
#             f.flush
#             File.read(path)
#             # => "WWWst lineXXXecond line\nFourth line\nFifth YYYe\n\u0000\u0000ZZZ"
#
# *   `'a+'`:
#
#     *   File is not initially truncated:
#
#             path = 't.tmp'
#             File.write(path, 'foo')
#             f = File.new(path, 'a+')
#             f.size == 0 # => false
#
#     *   File's initial read position is 0:
#
#             f.pos # => 0
#
#     *   File may be written only at end-of-file; IO#rewind, IO#pos=, IO#seek
#         do not affect writing:
#
#             f.write('bar')
#             f.flush
#             File.read(path)      # => "foobar"
#             f.write('baz')
#             f.flush
#             File.read(path)      # => "foobarbaz"
#
#             f.rewind
#             f.write('bat')
#             f.flush
#             File.read(path) # => "foobarbazbat"
#
#     *   File may be read anywhere; see IO#rewind, IO#pos=, IO#seek:
#
#             f.rewind
#             f.read # => "foobarbazbat"
#
#             f.pos = 3
#             f.read # => "barbazbat"
#
#             f.seek(-3, :END)
#             f.read # => "bat"
#
# ##### Read/Write Modes for File To Be Created
#
# Note that modes `'r'` and `'r+'` are not allowed for a non-existent file
# (exception raised).
#
# *   `'w'`:
#
#     *   File's initial write position is 0:
#
#             path = 't.tmp'
#             FileUtils.rm_f(path)
#             f = File.new(path, 'w')
#             f.pos # => 0
#
#     *   File may be written anywhere (even past end-of-file); see IO#rewind,
#         IO#pos=, IO#seek:
#
#             f.write('foo')
#             f.flush
#             File.read(path) # => "foo"
#             f.pos # => 3
#
#             f.write('bar')
#             f.flush
#             File.read(path) # => "foobar"
#             f.pos # => 6
#
#             f.rewind
#             f.write('baz')
#             f.flush
#             File.read(path) # => "bazbar"
#             f.pos # => 3
#
#             f.pos = 3
#             f.write('foo')
#             f.flush
#             File.read(path) # => "bazfoo"
#             f.pos # => 6
#
#             f.seek(-3, :END)
#             f.write('bam')
#             f.flush
#             File.read(path) # => "bazbam"
#             f.pos # => 6
#
#             f.pos = 8
#             f.write('bah')  # Zero padding as needed.
#             f.flush
#             File.read(path) # => "bazbam\u0000\u0000bah"
#             f.pos # => 11
#
#     *   Reading is not allowed:
#
#             f.read # Raises IOError.
#
# *   `'a'`:
#
#     *   File's initial write position is 0:
#
#             path = 't.tmp'
#             FileUtils.rm_f(path)
#             f = File.new(path, 'a')
#             f.pos # => 0
#
#     *   Writing occurs only at end-of-file:
#
#             f.write('foo')
#             f.pos # => 3
#             f.write('bar')
#             f.pos # => 6
#             f.flush
#             File.read(path) # => "foobar"
#
#             f.rewind
#             f.write('baz')
#             f.flush
#             File.read(path) # => "foobarbaz"
#
#     *   Reading is not allowed:
#
#             f.read # Raises IOError.
#
# *   `'w+'`:
#
#     *   File's initial position is 0:
#
#             path = 't.tmp'
#             FileUtils.rm_f(path)
#             f = File.new(path, 'w+')
#             f.pos # => 0
#
#     *   File may be written anywhere (even past end-of-file); see IO#rewind,
#         IO#pos=, IO#seek:
#
#             f.write('foo')
#             f.flush
#             File.read(path) # => "foo"
#             f.pos # => 3
#
#             f.write('bar')
#             f.flush
#             File.read(path) # => "foobar"
#             f.pos # => 6
#
#             f.rewind
#             f.write('baz')
#             f.flush
#             File.read(path) # => "bazbar"
#             f.pos # => 3
#
#             f.pos = 3
#             f.write('foo')
#             f.flush
#             File.read(path) # => "bazfoo"
#             f.pos # => 6
#
#             f.seek(-3, :END)
#             f.write('bam')
#             f.flush
#             File.read(path) # => "bazbam"
#             f.pos # => 6
#
#             f.pos = 8
#             f.write('bah')  # Zero padding as needed.
#             f.flush
#             File.read(path) # => "bazbam\u0000\u0000bah"
#             f.pos # => 11
#
#     *   File may be read anywhere (even past end-of-file); see IO#rewind,
#         IO#pos=, IO#seek:
#
#             f.rewind
#             # => 0
#             f.read
#             # => "bazbam\u0000\u0000bah"
#
#             f.pos = 3
#             # => 3
#             f.read
#             # => "bam\u0000\u0000bah"
#
#             f.seek(-3, :END)
#             # => 0
#             f.read
#             # => "bah"
#
# *   `'a+'`:
#
#     *   File's initial write position is 0:
#
#             path = 't.tmp'
#             FileUtils.rm_f(path)
#             f = File.new(path, 'a+')
#             f.pos # => 0
#
#     *   Writing occurs only at end-of-file:
#
#             f.write('foo')
#             f.pos # => 3
#             f.write('bar')
#             f.pos # => 6
#             f.flush
#             File.read(path) # => "foobar"
#
#             f.rewind
#             f.write('baz')
#             f.flush
#             File.read(path) # => "foobarbaz"
#
#     *   File may be read anywhere (even past end-of-file); see IO#rewind,
#         IO#pos=, IO#seek:
#
#             f.rewind
#             f.read # => "foobarbaz"
#
#             f.pos = 3
#             f.read # => "barbaz"
#
#             f.seek(-3, :END)
#             f.read # => "baz"
#
#             f.pos = 800
#             f.read # => ""
#
# #### Data Mode
#
# To specify whether data is to be treated as text or as binary data, either of
# the following may be suffixed to any of the string read/write modes above:
#
# *   `'t'`: Text data; sets the default external encoding to `Encoding::UTF_8`;
#     on Windows, enables conversion between EOL and CRLF and enables
#     interpreting `0x1A` as an end-of-file marker.
# *   `'b'`: Binary data; sets the default external encoding to
#     `Encoding::ASCII_8BIT`; on Windows, suppresses conversion between EOL and
#     CRLF and disables interpreting `0x1A` as an end-of-file marker.
#
# If neither is given, the stream defaults to text data.
#
# Examples:
#
#     File.new('t.txt', 'rt')
#     File.new('t.dat', 'rb')
#
# When the data mode is specified, the read/write mode may not be omitted, and
# the data mode must precede the file-create mode, if given:
#
#     File.new('t.dat', 'b')   # Raises an exception.
#     File.new('t.dat', 'rxb') # Raises an exception.
#
# #### File-Create Mode
#
# The following may be suffixed to any writable string mode above:
#
# *   `'x'`: Creates the file if it does not exist; raises an exception if the
#     file exists.
#
# Example:
#
#     File.new('t.tmp', 'wx')
#
# When the file-create mode is specified, the read/write mode may not be
# omitted, and the file-create mode must follow the data mode:
#
#     File.new('t.dat', 'x')   # Raises an exception.
#     File.new('t.dat', 'rxb') # Raises an exception.
#
# ### Integer Access Modes
#
# When mode is an integer it must be one or more of the following constants,
# which may be combined by the bitwise OR operator `|`:
#
# *   `File::RDONLY`: Open for reading only.
# *   `File::WRONLY`: Open for writing only.
# *   `File::RDWR`: Open for reading and writing.
# *   `File::APPEND`: Open for appending only.
#
# Examples:
#
#     File.new('t.txt', File::RDONLY)
#     File.new('t.tmp', File::RDWR | File::CREAT | File::EXCL)
#
# Note: Method IO#set_encoding does not allow the mode to be specified as an
# integer.
#
# ### File-Create Mode Specified as an Integer
#
# These constants may also be ORed into the integer mode:
#
# *   `File::CREAT`: Create file if it does not exist.
# *   `File::EXCL`: Raise an exception if `File::CREAT` is given and the file
#     exists.
#
# ### Data Mode Specified as an Integer
#
# Data mode cannot be specified as an integer. When the stream access mode is
# given as an integer, the data mode is always text, never binary.
#
# Note that although there is a constant `File::BINARY`, setting its value in an
# integer stream mode has no effect; this is because, as documented in
# File::Constants, the `File::BINARY` value disables line code conversion, but
# does not change the external encoding.
#
# ### Encodings
#
# Any of the string modes above may specify encodings - either external encoding
# only or both external and internal encodings - by appending one or both
# encoding names, separated by colons:
#
#     f = File.new('t.dat', 'rb')
#     f.external_encoding # => #<Encoding:ASCII-8BIT>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => #<Encoding:UTF-16>
#     f.close
#
# The numerous encoding names are available in array Encoding.name_list:
#
#     Encoding.name_list.take(3) # => ["ASCII-8BIT", "UTF-8", "US-ASCII"]
#
# When the external encoding is set, strings read are tagged by that encoding
# when reading, and strings written are converted to that encoding when writing.
#
# When both external and internal encodings are set, strings read are converted
# from external to internal encoding, and strings written are converted from
# internal to external encoding. For further details about transcoding input and
# output, see [Encodings](rdoc-ref:encodings.rdoc@Encodings).
#
# If the external encoding is `'BOM|UTF-8'`, `'BOM|UTF-16LE'` or
# `'BOM|UTF16-BE'`, Ruby checks for a Unicode BOM in the input document to help
# determine the encoding. For UTF-16 encodings the file open mode must be
# binary. If the BOM is found, it is stripped and the external encoding from the
# BOM is used.
#
# Note that the BOM-style encoding option is case insensitive, so `'bom|utf-8'`
# is also valid.
#
# ## File Permissions
#
# A File object has *permissions*, an octal integer representing the permissions
# of an actual file in the underlying platform.
#
# Note that file permissions are quite different from the *mode* of a file
# stream (File object).
#
# In a File object, the permissions are available thus, where method `mode`,
# despite its name, returns permissions:
#
#     f = File.new('t.txt')
#     f.lstat.mode.to_s(8) # => "100644"
#
# On a Unix-based operating system, the three low-order octal digits represent
# the permissions for owner (6), group (4), and world (4). The triplet of bits
# in each octal digit represent, respectively, read, write, and execute
# permissions.
#
# Permissions `0644` thus represent read-write access for owner and read-only
# access for group and world. See man pages
# [open(2)](https://www.unix.com/man-page/bsd/2/open) and
# [chmod(2)](https://www.unix.com/man-page/bsd/2/chmod).
#
# For a directory, the meaning of the execute bit changes: when set, the
# directory can be searched.
#
# Higher-order bits in permissions may indicate the type of file (plain,
# directory, pipe, socket, etc.) and various other special features.
#
# On non-Posix operating systems, permissions may include only read-only or
# read-write, in which case, the remaining permission will resemble typical
# values. On Windows, for instance, the default permissions are `0644`; The only
# change that can be made is to make the file read-only, which is reported as
# `0444`.
#
# For a method that actually creates a file in the underlying platform (as
# opposed to merely creating a File object), permissions may be specified:
#
#     File.new('t.tmp', File::CREAT, 0644)
#     File.new('t.tmp', File::CREAT, 0444)
#
# Permissions may also be changed:
#
#     f = File.new('t.tmp', File::CREAT, 0444)
#     f.chmod(0644)
#     f.chmod(0444)
#
# ## File Constants
#
# Various constants for use in File and IO methods may be found in module
# File::Constants; an array of their names is returned by
# `File::Constants.constants`.
#
# ## What's Here
#
# First, what's elsewhere. Class File:
#
# *   Inherits from [class IO](rdoc-ref:IO@What-27s+Here), in particular,
#     methods for creating, reading, and writing files
# *   Includes module FileTest, which provides dozens of additional methods.
#
# Here, class File provides methods that are useful for:
#
# *   [Creating](rdoc-ref:File@Creating)
# *   [Querying](rdoc-ref:File@Querying)
# *   [Settings](rdoc-ref:File@Settings)
# *   [Other](rdoc-ref:File@Other)
#
# ### Creating
#
# *   ::new: Opens the file at the given path; returns the file.
# *   ::open: Same as ::new, but when given a block will yield the file to the
#     block, and close the file upon exiting the block.
# *   ::link: Creates a new name for an existing file using a hard link.
# *   ::mkfifo: Returns the FIFO file created at the given path.
# *   ::symlink: Creates a symbolic link for the given file path.
#
# ### Querying
#
# *Paths*
#
# *   ::absolute_path: Returns the absolute file path for the given path.
# *   ::absolute_path?: Returns whether the given path is the absolute file
#     path.
# *   ::basename: Returns the last component of the given file path.
# *   ::dirname: Returns all but the last component of the given file path.
# *   ::expand_path: Returns the absolute file path for the given path,
#     expanding `~` for a home directory.
# *   ::extname: Returns the file extension for the given file path.
# *   ::fnmatch? (aliased as ::fnmatch): Returns whether the given file path
#     matches the given pattern.
# *   ::join: Joins path components into a single path string.
# *   ::path: Returns the string representation of the given path.
# *   ::readlink: Returns the path to the file at the given symbolic link.
# *   ::realdirpath: Returns the real path for the given file path, where the
#     last component need not exist.
# *   ::realpath: Returns the real path for the given file path, where all
#     components must exist.
# *   ::split: Returns an array of two strings: the directory name and basename
#     of the file at the given path.
# *   #path (aliased as #to_path):  Returns the string representation of the
#     given path.
#
# *Times*
#
# *   ::atime: Returns a Time for the most recent access to the given file.
# *   ::birthtime: Returns a Time  for the creation of the given file.
# *   ::ctime: Returns a Time  for the metadata change of the given file.
# *   ::mtime: Returns a Time for the most recent data modification to the
#     content of the given file.
# *   #atime: Returns a Time for the most recent access to `self`.
# *   #birthtime: Returns a Time  the creation for `self`.
# *   #ctime: Returns a Time for the metadata change of `self`.
# *   #mtime: Returns a Time for the most recent data modification to the
#     content of `self`.
#
# *Types*
#
# *   ::blockdev?: Returns whether the file at the given path is a block device.
# *   ::chardev?: Returns whether the file at the given path is a character
#     device.
# *   ::directory?: Returns whether the file at the given path is a directory.
# *   ::executable?: Returns whether the file at the given path is executable by
#     the effective user and group of the current process.
# *   ::executable_real?: Returns whether the file at the given path is
#     executable by the real user and group of the current process.
# *   ::exist?: Returns whether the file at the given path exists.
# *   ::file?: Returns whether the file at the given path is a regular file.
# *   ::ftype: Returns a string giving the type of the file at the given path.
# *   ::grpowned?: Returns whether the effective group of the current process
#     owns the file at the given path.
# *   ::identical?: Returns whether the files at two given paths are identical.
# *   ::lstat: Returns the File::Stat object for the last symbolic link in the
#     given path.
# *   ::owned?: Returns whether the effective user of the current process owns
#     the file at the given path.
# *   ::pipe?: Returns whether the file at the given path is a pipe.
# *   ::readable?: Returns whether the file at the given path is readable by the
#     effective user and group of the current process.
# *   ::readable_real?: Returns whether the file at the given path is readable
#     by the real user and group of the current process.
# *   ::setgid?: Returns whether the setgid bit is set for the file at the given
#     path.
# *   ::setuid?: Returns whether the setuid bit is set for the file at the given
#     path.
# *   ::socket?: Returns whether the file at the given path is a socket.
# *   ::stat: Returns the File::Stat object for the file at the given path.
# *   ::sticky?: Returns whether the file at the given path has its sticky bit
#     set.
# *   ::symlink?: Returns whether the file at the given path is a symbolic link.
# *   ::umask: Returns the umask value for the current process.
# *   ::world_readable?: Returns whether the file at the given path is readable
#     by others.
# *   ::world_writable?: Returns whether the file at the given path is writable
#     by others.
# *   ::writable?: Returns whether the file at the given path is writable by the
#     effective user and group of the current process.
# *   ::writable_real?: Returns whether the file at the given path is writable
#     by the real user and group of the current process.
# *   #lstat: Returns the File::Stat object for the last symbolic link in the
#     path for `self`.
#
# *Contents*
#
# *   ::empty? (aliased as ::zero?): Returns whether the file at the given path
#     exists and is empty.
# *   ::size: Returns the size (bytes) of the file at the given path.
# *   ::size?: Returns `nil` if there is no file at the given path, or if that
#     file is empty; otherwise returns the file size (bytes).
# *   #size: Returns the size (bytes) of `self`.
#
# ### Settings
#
# *   ::chmod: Changes permissions of the file at the given path.
# *   ::chown: Change ownership of the file at the given path.
# *   ::lchmod: Changes permissions of the last symbolic link in the given path.
# *   ::lchown: Change ownership of the last symbolic in the given path.
# *   ::lutime: For each given file path, sets the access time and modification
#     time of the last symbolic link in the path.
# *   ::rename: Moves the file at one given path to another given path.
# *   ::utime: Sets the access time and modification time of each file at the
#     given paths.
# *   #flock: Locks or unlocks `self`.
#
# ### Other
#
# *   ::truncate: Truncates the file at the given file path to the given size.
# *   ::unlink (aliased as ::delete): Deletes the file for each given file path.
# *   #truncate: Truncates `self` to the given size.
#
class File < IO
  # <!--
  #   rdoc-file=io.c
  #   - File.new(path, mode = 'r', perm = 0666, **opts) -> file
  # -->
  # Opens the file at the given `path` according to the given `mode`; creates and
  # returns a new File object for that file.
  #
  # The new File object is buffered mode (or non-sync mode), unless `filename` is
  # a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync=.
  #
  # Argument `path` must be a valid file path:
  #
  #     f = File.new('/etc/fstab')
  #     f.close
  #     f = File.new('t.txt')
  #     f.close
  #
  # Optional argument `mode` (defaults to 'r') must specify a valid mode; see
  # [Access Modes](rdoc-ref:File@Access+Modes):
  #
  #     f = File.new('t.tmp', 'w')
  #     f.close
  #     f = File.new('t.tmp', File::RDONLY)
  #     f.close
  #
  # Optional argument `perm` (defaults to 0666) must specify valid permissions see
  # [File Permissions](rdoc-ref:File@File+Permissions):
  #
  #     f = File.new('t.tmp', File::CREAT, 0644)
  #     f.close
  #     f = File.new('t.tmp', File::CREAT, 0444)
  #     f.close
  #
  # Optional keyword arguments `opts` specify:
  #
  # *   [Open Options](rdoc-ref:IO@Open+Options).
  # *   [Encoding options](rdoc-ref:encodings.rdoc@Encoding+Options).
  #
  def initialize: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> void

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless *dir_string* is
  # given, in which case it will be used as the starting point. If the given
  # pathname starts with a ```~`'' it is NOT expanded, it is treated as a normal
  # directory name.
  #
  #     File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
  #
  def self.absolute_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path?(file_name)  ->  true or false
  # -->
  # Returns `true` if `file_name` is an absolute path, and `false` otherwise.
  #
  #     File.absolute_path?("c:/foo")     #=> false (on Linux), true (on Windows)
  #
  def self.absolute_path?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.atime(file_name)  ->  time
  # -->
  # Returns the last access time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003
  #
  def self.atime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.basename(file_name [, suffix] )  ->  base_name
  # -->
  # Returns the last component of the filename given in *file_name* (after first
  # stripping trailing separators), which can be formed using both File::SEPARATOR
  # and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not
  # `nil`. If *suffix* is given and present at the end of *file_name*, it is
  # removed. If *suffix* is ".*", any extension will be removed.
  #
  #     File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
  #     File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
  #     File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"
  #
  def self.basename: (string | _ToPath file_name, ?string suffix) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.birthtime(file_name)  -> time
  # -->
  # Returns the birth time for the named file.
  #
  # *file_name* can be an IO object.
  #
  #     File.birthtime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  def self.birthtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a block device, `false` otherwise:
  #
  #     File.blockdev?('/dev/sda1')       # => true
  #     File.blockdev?(File.new('t.tmp')) # => false
  #
  def self.blockdev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a character device, `false` otherwise.
  #
  #     File.chardev?($stdin)     # => true
  #     File.chardev?('t.txt')     # => false
  #
  def self.chardev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chmod(mode_int, file_name, ... )  ->  integer
  # -->
  # Changes permission bits on the named file(s) to the bit pattern represented by
  # *mode_int*. Actual effects are operating system dependent (see the beginning
  # of this section). On Unix systems, see `chmod(2)` for details. Returns the
  # number of files processed.
  #
  #     File.chmod(0644, "testfile", "out")   #=> 2
  #
  def self.chmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.chown(owner_int, group_int, file_name, ...)  ->  integer
  # -->
  # Changes the owner and group of the named file(s) to the given numeric owner
  # and group id's. Only a process with superuser privileges may change the owner
  # of a file. The current owner of a file may change the file's group to any
  # group to which the owner belongs. A `nil` or -1 owner or group id is ignored.
  # Returns the number of files processed.
  #
  #     File.chown(nil, 100, "testfile")
  #
  def self.chown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.ctime(file_name)  -> time
  # -->
  # Returns the change time for the named file (the time at which directory
  # information about the file was changed, not the file itself).
  #
  # *file_name* can be an IO object.
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
  #
  def self.ctime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  alias self.delete self.unlink

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(path) -> true or false
  # -->
  # With string `object` given, returns `true` if `path` is a string path leading
  # to a directory, or to a symbolic link to a directory; `false` otherwise:
  #
  #     File.directory?('.')              # => true
  #     File.directory?('foo')            # => false
  #     File.symlink('.', 'dirlink')      # => 0
  #     File.directory?('dirlink')        # => true
  #     File.symlink('t,txt', 'filelink') # => 0
  #     File.directory?('filelink')       # => false
  #
  # Argument `path` can be an IO object.
  #
  def self.directory?: (string | _ToPath | IO path) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.dirname(file_name, level = 1)  ->  dir_name
  # -->
  # Returns all components of the filename given in *file_name* except the last
  # one (after first stripping trailing separators). The filename can be formed
  # using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when
  # File::ALT_SEPARATOR is not `nil`.
  #
  #     File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"
  #
  # If `level` is given, removes the last `level` components, not only one.
  #
  #     File.dirname("/home/gumby/work/ruby.rb", 2) #=> "/home/gumby"
  #     File.dirname("/home/gumby/work/ruby.rb", 4) #=> "/"
  #
  def self.dirname: (string | _ToPath file_name, ?Integer level) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  alias self.empty? self.zero?

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self.executable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self.executable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self.exist?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.expand_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless `dir_string` is
  # given, in which case it will be used as the starting point. The given pathname
  # may start with a ```~`'', which expands to the process owner's home directory
  # (the environment variable `HOME` must be set correctly). ```~`*user*'' expands
  # to the named user's home directory.
  #
  #     File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"
  #
  # A simple example of using `dir_string` is as follows.
  #     File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"
  #
  # A more complex example which also resolves parent directory is as follows.
  # Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.
  #
  #     File.expand_path("../../lib/mygem.rb", __FILE__)
  #     #=> ".../path/to/project/lib/mygem.rb"
  #
  # So first it resolves the parent of __FILE__, that is bin/, then go to the
  # parent, the root of the project and appends `lib/mygem.rb`.
  #
  def self.expand_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.extname(path)  ->  string
  # -->
  # Returns the extension (the portion of file name in `path` starting from the
  # last period).
  #
  # If `path` is a dotfile, or starts with a period, then the starting dot is not
  # dealt with the start of the extension.
  #
  # An empty string will also be returned when the period is the last character in
  # `path`.
  #
  # On Windows, trailing dots are truncated.
  #
  #     File.extname("test.rb")         #=> ".rb"
  #     File.extname("a/b/d/test.rb")   #=> ".rb"
  #     File.extname(".a/b/d/test.rb")  #=> ".rb"
  #     File.extname("foo.")            #=> "" on Windows
  #     File.extname("foo.")            #=> "." on non-Windows
  #     File.extname("test")            #=> ""
  #     File.extname(".profile")        #=> ""
  #     File.extname(".profile.sh")     #=> ".sh"
  #
  def self.extname: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self.file?: (string | _ToPath | IO file) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - File.fnmatch( pattern, path, [flags] ) -> (true or false)
  #   - File.fnmatch?( pattern, path, [flags] ) -> (true or false)
  # -->
  # Returns true if `path` matches against `pattern`.  The pattern is not a
  # regular expression; instead it follows rules similar to shell filename
  # globbing.  It may contain the following metacharacters:
  #
  # `*`
  # :   Matches any file. Can be restricted by other values in the glob.
  #     Equivalent to `/.*/x` in regexp.
  #
  #     `*`
  # :       Matches all regular files
  #
  #     `c*`
  # :       Matches all files beginning with `c`
  #
  #     `*c`
  # :       Matches all files ending with `c`
  #
  #     `*c*`
  # :       Matches all files that have `c` in them (including at the beginning or
  #         end).
  #
  #
  #     To match hidden files (that start with a `.`) set the File::FNM_DOTMATCH
  #     flag.
  #
  #
  # `**`
  # :   Matches directories recursively or files expansively.
  #
  #
  # `?`
  # :   Matches any one character. Equivalent to `/.{1}/` in regexp.
  #
  #
  # `[set]`
  # :   Matches any one character in `set`.  Behaves exactly like character sets
  #     in Regexp, including set negation (`[^a-z]`).
  #
  #
  # `\`
  # :   Escapes the next metacharacter.
  #
  #
  # `{a,b}`
  # :   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.
  #     Behaves like a Regexp union (`(?:a|b)`).
  #
  #
  # `flags` is a bitwise OR of the `FNM_XXX` constants. The same glob pattern and
  # flags are used by Dir::glob.
  #
  # Examples:
  #
  #     File.fnmatch('cat',       'cat')        #=> true  # match entire string
  #     File.fnmatch('cat',       'category')   #=> false # only match partial string
  #
  #     File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
  #     File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB
  #
  #     File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
  #     File.fnmatch('c??t',    'cat')          #=> false # ditto
  #     File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
  #     File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
  #     File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
  #     File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')
  #
  #     File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default
  #
  #     File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
  #     File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
  #     File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto
  #
  #     File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
  #     File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
  #     File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
  #     File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression
  #
  #     File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
  #     File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
  #     File.fnmatch('.*',  '.profile')                      #=> true
  #
  #     File.fnmatch('**/*.rb', 'main.rb')                  #=> false
  #     File.fnmatch('**/*.rb', './main.rb')                #=> false
  #     File.fnmatch('**/*.rb', 'lib/song.rb')              #=> true
  #     File.fnmatch('**.rb', 'main.rb')                    #=> true
  #     File.fnmatch('**.rb', './main.rb')                  #=> false
  #     File.fnmatch('**.rb', 'lib/song.rb')                #=> true
  #     File.fnmatch('*',     'dave/.profile')              #=> true
  #
  #     File.fnmatch('**/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
  #     File.fnmatch('**/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
  #     File.fnmatch('**/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
  #
  def self.fnmatch: (string pattern, string | _ToPath path, ?int flags) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - fnmatch?(pattern, path, flags = 0)
  # -->
  #
  alias self.fnmatch? self.fnmatch

  # <!--
  #   rdoc-file=file.c
  #   - File.ftype(file_name)   -> string
  # -->
  # Identifies the type of the named file; the return string is one of ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.ftype("testfile")            #=> "file"
  #     File.ftype("/dev/tty")            #=> "characterSpecial"
  #     File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
  #
  def self.ftype: (string | _ToPath file_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self.grpowned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self.identical?: (string | _ToPath | IO file_1, string | _ToPath | IO file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.join(string, ...)  ->  string
  # -->
  # Returns a new string formed by joining the strings using `"/"`.
  #
  #     File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"
  #
  def self.join: (*path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.lchmod(mode_int, file_name, ...)  -> integer
  # -->
  # Equivalent to File::chmod, but does not follow symbolic links (so it will
  # change the permissions associated with the link, not the file referenced by
  # the link). Often not available.
  #
  def self.lchmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.lchown(owner_int, group_int, file_name,..) -> integer
  # -->
  # Equivalent to File::chown, but does not follow symbolic links (so it will
  # change the owner associated with the link, not the file referenced by the
  # link). Often not available. Returns number of files in the argument list.
  #
  def self.lchown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.link(old_name, new_name)    -> 0
  # -->
  # Creates a new name for an existing file using a hard link. Will not overwrite
  # *new_name* if it already exists (raising a subclass of SystemCallError). Not
  # available on all platforms.
  #
  #     File.link("testfile", ".testfile")   #=> 0
  #     IO.readlines(".testfile")[0]         #=> "This is line one\n"
  #
  def self.link: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.lstat(filepath) -> stat
  # -->
  # Like File::stat, but does not follow the last symbolic link; instead, returns
  # a File::Stat object for the link itself.
  #
  #     File.symlink('t.txt', 'symlink')
  #     File.stat('symlink').size  # => 47
  #     File.lstat('symlink').size # => 5
  #
  def self.lstat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.lutime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon the link itself as
  # opposed to its referent; for the inverse behavior, see File.utime. Returns the
  # number of file names in the argument list.
  #
  def self.lutime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.mkfifo(file_name, mode=0666)  => 0
  # -->
  # Creates a FIFO special file with name *file_name*.  *mode* specifies the
  # FIFO's permissions. It is modified by the process's umask in the usual way:
  # the permissions of the created file are (mode & ~umask).
  #
  def self.mkfifo: (string | _ToPath file_name, ?int mode) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.mtime(file_name)  ->  time
  # -->
  # Returns the modification time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003
  #
  def self.mtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=io.c
  #   - File.open(path, mode = 'r', perm = 0666, **opts) -> file
  #   - File.open(path, mode = 'r', perm = 0666, **opts) {|f| ... } -> object
  # -->
  # Creates a new File object, via File.new with the given arguments.
  #
  # With no block given, returns the File object.
  #
  # With a block given, calls the block with the File object and returns the
  # block's value.
  #
  def self.open: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> instance
               | [T] (string | _ToPath | int file_name, ?string | int mode, ?int perm) { (File) -> T } -> T

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self.owned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.path(path)  ->  string
  # -->
  # Returns the string representation of the path
  #
  #     File.path(File::NULL)           #=> "/dev/null"
  #     File.path(Pathname.new("/tmp")) #=> "/tmp"
  #
  def self.path: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a pipe, `false` otherwise:
  #
  #     File.mkfifo('tmp/fifo')
  #     File.pipe?('tmp/fifo') # => true
  #     File.pipe?('t.txt')    # => false
  #
  def self.pipe?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self.readable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self.readable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readlink(link_name)  ->  file_name
  # -->
  # Returns the name of the file referenced by the given link. Not available on
  # all platforms.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.readlink("link2test")              #=> "testfile"
  #
  def self.readlink: (string | _ToPath link_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realdirpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem.
  # The real pathname doesn't contain symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # The last component of the real pathname can be nonexistent.
  #
  def self.realdirpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem
  # not containing symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # All components of the pathname must exist when this method is called.
  #
  def self.realpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.rename(old_name, new_name)   -> 0
  # -->
  # Renames the given file to the new name. Raises a SystemCallError if the file
  # cannot be renamed.
  #
  #     File.rename("afile", "afile.bak")   #=> 0
  #
  def self.rename: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setgid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setuid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self.size: (string | _ToPath | IO file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self.size?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(filepath)   ->  true or false
  # -->
  # Returns `true` if `filepath` points to a socket, `false` otherwise:
  #
  #     require 'socket'
  #     File.socket?(Socket.new(:INET, :STREAM)) # => true
  #     File.socket?(File.new('t.txt'))          # => false
  #
  def self.socket?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.split(file_name)   -> array
  # -->
  # Splits the given string into a directory and a file component and returns them
  # in a two-element array. See also File::dirname and File::basename.
  #
  #     File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]
  #
  def self.split: (string | _ToPath file_name) -> [ String, String ]

  # <!--
  #   rdoc-file=file.c
  #   - File.stat(filepath) ->  stat
  # -->
  # Returns a File::Stat object for the file at `filepath` (see File::Stat):
  #
  #     File.stat('t.txt').class # => File::Stat
  #
  def self.stat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.sticky?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink(old_name, new_name)   -> 0
  # -->
  # Creates a symbolic link called *new_name* for the existing file *old_name*.
  # Raises a NotImplemented exception on platforms that do not support symbolic
  # links.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #
  def self.symlink: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(filepath) -> true or false
  # -->
  # Returns `true` if `filepath` points to a symbolic link, `false` otherwise:
  #
  #     symlink = File.symlink('t.txt', 'symlink')
  #     File.symlink?('symlink') # => true
  #     File.symlink?('t.txt')   # => false
  #
  def self.symlink?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.truncate(file_name, integer)  -> 0
  # -->
  # Truncates the file *file_name* to be at most *integer* bytes long. Not
  # available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.write("1234567890")     #=> 10
  #     f.close                   #=> nil
  #     File.truncate("out", 5)   #=> 0
  #     File.size("out")          #=> 5
  #
  def self.truncate: (string | _ToPath file_name, int length) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.umask()          -> integer
  #   - File.umask(integer)   -> integer
  # -->
  # Returns the current umask value for this process. If the optional argument is
  # given, set the umask to that value and return the previous value. Umask values
  # are *subtracted* from the default permissions, so a umask of `0222` would make
  # a file read-only for everyone.
  #
  #     File.umask(0006)   #=> 18
  #     File.umask         #=> 6
  #
  def self.umask: (?int umask) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  def self.unlink: (*string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.utime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon its referent rather
  # than the link itself; for the inverse behavior see File.lutime. Returns the
  # number of file names in the argument list.
  #
  def self.utime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self.world_readable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self.world_writable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self.writable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self.writable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self.zero?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - file.atime    -> time
  # -->
  # Returns the last access time (a Time object) for *file*, or epoch if *file*
  # has not been accessed.
  #
  #     File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.birthtime  ->  time
  # -->
  # Returns the birth time for *file*.
  #
  #     File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.chmod(mode_int)   -> 0
  # -->
  # Changes permission bits on *file* to the bit pattern represented by
  # *mode_int*. Actual effects are platform dependent; on Unix systems, see
  # `chmod(2)` for details. Follows symbolic links. Also see File#lchmod.
  #
  #     f = File.new("out", "w");
  #     f.chmod(0644)   #=> 0
  #
  def chmod: (int mode) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.chown(owner_int, group_int )   -> 0
  # -->
  # Changes the owner and group of *file* to the given numeric owner and group
  # id's. Only a process with superuser privileges may change the owner of a file.
  # The current owner of a file may change the file's group to any group to which
  # the owner belongs. A `nil` or -1 owner or group id is ignored. Follows
  # symbolic links. See also File#lchown.
  #
  #     File.new("testfile").chown(502, 1000)
  #
  def chown: (int? owner, int? group) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.ctime  ->  time
  # -->
  # Returns the change time for *file* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - flock(locking_constant) -> 0 or false
  # -->
  # Locks or unlocks file `self` according to the given `locking_constant`,
  # a bitwise OR of the values in the table below.
  # Not available on all platforms.
  # Returns `false` if `File::LOCK_NB` is specified and the operation would have
  # blocked;
  # otherwise returns `0`.
  #    Constant    |    Lock    |                                                    Effect
  # ---------------|------------|--------------------------------------------------------------------------------------------------------------
  # +File::LOCK_EX+| Exclusive  |                      Only one process may hold an exclusive lock for +self+ at a time.
  # +File::LOCK_NB+|Non-blocking|No blocking; may be combined with +File::LOCK_SH+ or +File::LOCK_EX+ using the bitwise OR operator <tt>|</tt>.
  # +File::LOCK_SH+|   Shared   |                 Multiple processes may each hold a shared lock for +self+ at the same time.
  # +File::LOCK_UN+|   Unlock   |                                Remove an existing lock held by this process.
  # Example:
  #     # Update a counter using an exclusive lock.
  # # Don't use File::WRONLY because it truncates the file.
  # File.open('counter', File::RDWR | File::CREAT, 0644) do |f|
  #   f.flock(File::LOCK_EX)
  #   value = f.read.to_i + 1
  #   f.rewind
  #   f.write("#{value}\n")
  #   f.flush
  #   f.truncate(f.pos)
  # end
  #
  # # Read the counter using a shared lock.
  # File.open('counter', 'r') do |f|
  #   f.flock(File::LOCK_SH)
  #   f.read
  # end
  #
  def flock: (int locking_constant) -> (0 | false)

  # <!--
  #   rdoc-file=file.c
  #   - lstat -> stat
  # -->
  # Like File#stat, but does not follow the last symbolic link; instead, returns a
  # File::Stat object for the link itself:
  #
  #     File.symlink('t.txt', 'symlink')
  #     f = File.new('symlink')
  #     f.stat.size  # => 47
  #     f.lstat.size # => 11
  #
  def lstat: () -> (File::Stat | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.mtime  ->  time
  # -->
  # Returns the modification time for *file*.
  #
  #     File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.path  ->  filename
  #   - file.to_path  ->  filename
  # -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  def path: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - file.size    -> integer
  # -->
  # Returns the size of *file* in bytes.
  #
  #     File.new("testfile").size   #=> 66
  #
  def size: () -> Integer

  # <!-- rdoc-file=file.c -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  alias to_path path

  # <!--
  #   rdoc-file=file.c
  #   - file.truncate(integer)    -> 0
  # -->
  # Truncates *file* to at most *integer* bytes. The file must be opened for
  # writing. Not available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.syswrite("1234567890")   #=> 10
  #     f.truncate(5)              #=> 0
  #     f.close()                  #=> nil
  #     File.size("out")           #=> 5
  #
  def truncate: (int length) -> 0
end

# <!-- rdoc-file=file.c -->
# platform specific alternative separator
#
File::ALT_SEPARATOR: String?

# <!-- rdoc-file=file.c -->
# path list separator
#
File::PATH_SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::Separator: String

# <!-- rdoc-file=file.c -->
# Module `File::Constants` defines file-related constants.
#
# There are two families of constants here:
#
# *   Those having to do with [file
#     access](rdoc-ref:File::Constants@File+Access).
# *   Those having to do with [filename
#     globbing](rdoc-ref:File::Constants@Filename+Globbing+Constants+-28File-3A-
#     3AFNM_-2A-29).
#
# File constants defined for the local process may be retrieved with method
# File::Constants.constants:
#
#     File::Constants.constants.take(5)
#     # => [:RDONLY, :WRONLY, :RDWR, :APPEND, :CREAT]
#
# ## File Access
#
# File-access constants may be used with optional argument `mode` in calls to
# the following methods:
#
# *   File.new.
# *   File.open.
# *   IO.for_fd.
# *   IO.new.
# *   IO.open.
# *   IO.popen.
# *   IO.reopen.
# *   IO.sysopen.
# *   StringIO.new.
# *   StringIO.open.
# *   StringIO#reopen.
#
# ### Read/Write Access
#
# Read-write access for a stream may be specified by a file-access constant.
#
# The constant may be specified as part of a bitwise OR of other such constants.
#
# Any combination of the constants in this section may be specified.
#
# #### File::RDONLY
#
# Flag File::RDONLY specifies the stream should be opened for reading only:
#
#     filepath = '/tmp/t.tmp'
#     f = File.new(filepath, File::RDONLY)
#     f.write('Foo') # Raises IOError (not opened for writing).
#
# #### File::WRONLY
#
# Flag File::WRONLY specifies that the stream should be opened for writing only:
#
#     f = File.new(filepath, File::WRONLY)
#     f.read # Raises IOError (not opened for reading).
#
# #### File::RDWR
#
# Flag File::RDWR specifies that the stream should be opened for both reading
# and writing:
#
#     f = File.new(filepath, File::RDWR)
#     f.write('Foo') # => 3
#     f.rewind       # => 0
#     f.read         # => "Foo"
#
# ### File Positioning
#
# #### File::APPEND
#
# Flag File::APPEND specifies that the stream should be opened in append mode.
#
# Before each write operation, the position is set to end-of-stream. The
# modification of the position and the following write operation are performed
# as a single atomic step.
#
# #### File::TRUNC
#
# Flag File::TRUNC specifies that the stream should be truncated at its
# beginning. If the file exists and is successfully opened for writing, it is to
# be truncated to position zero; its ctime and mtime are updated.
#
# There is no effect on a FIFO special file or a terminal device. The effect on
# other file types is implementation-defined. The result of using File::TRUNC
# with File::RDONLY is undefined.
#
# ### Creating and Preserving
#
# #### File::CREAT
#
# Flag File::CREAT specifies that the stream should be created if it does not
# already exist.
#
# If the file exists:
#
#     - Raise an exception if File::EXCL is also specified.
#     - Otherwise, do nothing.
#
# If the file does not exist, then it is created. Upon successful completion,
# the atime, ctime, and mtime of the file are updated, and the ctime and mtime
# of the parent directory are updated.
#
# #### File::EXCL
#
# Flag File::EXCL specifies that the stream should not already exist; If flags
# File::CREAT and File::EXCL are both specified and the stream already exists,
# an exception is raised.
#
# The check for the existence and creation of the file is performed as an atomic
# operation.
#
# If both File::EXCL and File::CREAT are specified and the path names a symbolic
# link, an exception is raised regardless of the contents of the symbolic link.
#
# If File::EXCL is specified and File::CREAT is not specified, the result is
# undefined.
#
# ### POSIX File Constants
#
# Some file-access constants are defined only on POSIX-compliant systems; those
# are:
#
# *   File::SYNC.
# *   File::DSYNC.
# *   File::RSYNC.
# *   File::DIRECT.
# *   File::NOATIME.
# *   File::NOCTTY.
# *   File::NOFOLLOW.
# *   File::TMPFILE.
#
# #### File::SYNC, File::RSYNC, and File::DSYNC
#
# Flag File::SYNC, File::RSYNC, or File::DSYNC specifies synchronization of I/O
# operations with the underlying file system.
#
# These flags are valid only for POSIX-compliant systems.
#
# *   File::SYNC specifies that all write operations (both data and metadata)
#     are immediately to be flushed to the underlying storage device. This means
#     that the data is written to the storage device, and the file's metadata
#     (e.g., file size, timestamps, permissions) are also synchronized. This
#     guarantees that data is safely stored on the storage medium before
#     returning control to the calling program. This flag can have a significant
#     impact on performance since it requires synchronous writes, which can be
#     slower compared to asynchronous writes.
#
# *   File::RSYNC specifies that any read operations on the file will not return
#     until all outstanding write operations (those that have been issued but
#     not completed) are also synchronized. This is useful when you want to read
#     the most up-to-date data, which may still be in the process of being
#     written.
#
# *   File::DSYNC specifies that all *data* write operations are immediately to
#     be flushed to the underlying storage device; this differs from File::SYNC,
#     which requires that *metadata* also be synchronized.
#
# Note that the behavior of these flags may vary slightly depending on the
# operating system and filesystem being used. Additionally, using these flags
# can have an impact on performance due to the synchronous nature of the I/O
# operations, so they should be used judiciously, especially in
# performance-critical applications.
#
# #### File::NOCTTY
#
# Flag File::NOCTTY specifies that if the stream is a terminal device, that
# device does not become the controlling terminal for the process.
#
# Defined only for POSIX-compliant systems.
#
# #### File::DIRECT
#
# Flag File::DIRECT requests that cache effects of the I/O to and from the
# stream be minimized.
#
# Defined only for POSIX-compliant systems.
#
# #### File::NOATIME
#
# Flag File::NOATIME specifies that act of opening the stream should not modify
# its access time (atime).
#
# Defined only for POSIX-compliant systems.
#
# #### File::NOFOLLOW
#
# Flag File::NOFOLLOW specifies that if path is a symbolic link, it should not
# be followed.
#
# Defined only for POSIX-compliant systems.
#
# #### File::TMPFILE
#
# Flag File::TMPFILE specifies that the opened stream should be a new temporary
# file.
#
# Defined only for POSIX-compliant systems.
#
# ### Other File-Access Constants
#
# #### File::NONBLOCK
#
# When possible, the file is opened in nonblocking mode. Neither the open
# operation nor any subsequent I/O operations on the file will cause the calling
# process to wait.
#
# #### File::BINARY
#
# Flag File::BINARY specifies that the stream is to be accessed in binary mode.
#
# #### File::SHARE_DELETE
#
# Flag File::SHARE_DELETE enables other processes to open the stream with delete
# access.
#
# Windows only.
#
# If the stream is opened for (local) delete access without File::SHARE_DELETE,
# and another process attempts to open it with delete access, the attempt fails
# and the stream is not opened for that process.
#
# ## Locking
#
# Four file constants relate to stream locking; see File#flock:
#
# #### File::LOCK_EX
#
# Flag File::LOCK_EX specifies an exclusive lock; only one process a a time may
# lock the stream.
#
# #### File::LOCK_NB
#
# Flag File::LOCK_NB specifies non-blocking locking for the stream; may be
# combined with File::LOCK_EX or File::LOCK_SH.
#
# #### File::LOCK_SH
#
# Flag File::LOCK_SH specifies that multiple processes may lock the stream at
# the same time.
#
# #### File::LOCK_UN
#
# Flag File::LOCK_UN specifies that the stream is not to be locked.
#
# ## Filename Globbing Constants (File::FNM_*)
#
# Filename-globbing constants may be used with optional argument `flags` in
# calls to the following methods:
#
# *   Dir.glob.
# *   File.fnmatch.
# *   Pathname#fnmatch.
# *   Pathname.glob.
# *   Pathname#glob.
#
# The constants are:
#
# #### File::FNM_CASEFOLD
#
# Flag File::FNM_CASEFOLD makes patterns case insensitive for File.fnmatch (but
# not Dir.glob).
#
# #### File::FNM_DOTMATCH
#
# Flag File::FNM_DOTMATCH makes the `'*'` pattern match a filename starting with
# `'.'`.
#
# #### File::FNM_EXTGLOB
#
# Flag File::FNM_EXTGLOB enables pattern `'{*a*,*b*}'`, which matches pattern
# '*a*' and pattern '*b*'; behaves like a [regexp union](rdoc-ref:Regexp.union)
# (e.g., `'(?:*a*|*b*)'`):
#
#     pattern = '{LEGAL,BSDL}'
#     Dir.glob(pattern)      # => ["LEGAL", "BSDL"]
#     Pathname.glob(pattern) # => [#<Pathname:LEGAL>, #<Pathname:BSDL>]
#     pathname.glob(pattern) # => [#<Pathname:LEGAL>, #<Pathname:BSDL>]
#
# #### File::FNM_NOESCAPE
#
# Flag File::FNM_NOESCAPE disables `'\'` escaping.
#
# #### File::FNM_PATHNAME
#
# Flag File::FNM_PATHNAME specifies that patterns `'*'` and `'?'` do not match
# the directory separator (the value of constant File::SEPARATOR).
#
# #### File::FNM_SHORTNAME
#
# Flag File::FNM_SHORTNAME allows patterns to match short names if they exist.
#
# Windows only.
#
# #### File::FNM_SYSCASE
#
# Flag File::FNM_SYSCASE specifies that case sensitivity is the same as in the
# underlying operating system; effective for File.fnmatch, but not Dir.glob.
#
# ## Other Constants
#
# #### File::NULL
#
# Flag File::NULL contains the string value of the null device:
#
# *   On a Unix-like OS, `'/dev/null'`.
# *   On Windows, `'NUL'`.
#
module File::Constants
end

# <!-- rdoc-file=file.c -->
# [File::APPEND](rdoc-ref:File::Constants@File-3A-3AAPPEND)
#
File::Constants::APPEND: Integer

# <!-- rdoc-file=file.c -->
# [File::BINARY](rdoc-ref:File::Constants@File-3A-3ABINARY)
#
File::Constants::BINARY: Integer

# <!-- rdoc-file=file.c -->
# [File::CREAT](rdoc-ref:File::Constants@File-3A-3ACREAT)
#
File::Constants::CREAT: Integer

# <!-- rdoc-file=file.c -->
# [File::DIRECT](rdoc-ref:File::Constants@File-3A-3ADIRECT)
#
File::Constants::DIRECT: Integer

# <!-- rdoc-file=file.c -->
# [File::DSYNC](rdoc-ref:File::Constants@File-3A-3ASYNC-2C+File-3A-3ARSYNC-2C+an
# d+File-3A-3ADSYNC)
#
File::Constants::DSYNC: Integer

# <!-- rdoc-file=file.c -->
# [File::EXCL](rdoc-ref:File::Constants@File-3A-3AEXCL)
#
File::Constants::EXCL: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_CASEFOLD](rdoc-ref:File::Constants@File-3A-3AFNM_CASEFOLD)
#
File::Constants::FNM_CASEFOLD: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_DOTMATCH](rdoc-ref:File::Constants@File-3A-3AFNM_DOTMATCH)
#
File::Constants::FNM_DOTMATCH: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_EXTGLOB](rdoc-ref:File::Constants@File-3A-3AFNM_EXTGLOB)
#
File::Constants::FNM_EXTGLOB: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_NOESCAPE](rdoc-ref:File::Constants@File-3A-3AFNM_NOESCAPE)
#
File::Constants::FNM_NOESCAPE: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_PATHNAME](rdoc-ref:File::Constants@File-3A-3AFNM_PATHNAME)
#
File::Constants::FNM_PATHNAME: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_SHORTNAME](rdoc-ref:File::Constants@File-3A-3AFNM_SHORTNAME)
#
File::Constants::FNM_SHORTNAME: Integer

# <!-- rdoc-file=dir.c -->
# [File::FNM_SYSCASE](rdoc-ref:File::Constants@File-3A-3AFNM_SYSCASE)
#
File::Constants::FNM_SYSCASE: Integer

# <!-- rdoc-file=file.c -->
# [File::LOCK_EX](rdoc-ref:File::Constants@File-3A-3ALOCK_EX)
#
File::Constants::LOCK_EX: Integer

# <!-- rdoc-file=file.c -->
# [File::LOCK_NB](rdoc-ref:File::Constants@File-3A-3ALOCK_NB)
#
File::Constants::LOCK_NB: Integer

# <!-- rdoc-file=file.c -->
# [File::LOCK_SH](rdoc-ref:File::Constants@File-3A-3ALOCK_SH)
#
File::Constants::LOCK_SH: Integer

# <!-- rdoc-file=file.c -->
# [File::LOCK_UN](rdoc-ref:File::Constants@File-3A-3ALOCK_UN)
#
File::Constants::LOCK_UN: Integer

# <!-- rdoc-file=file.c -->
# [File::NOATIME](rdoc-ref:File::Constants@File-3A-3ANOATIME)
#
File::Constants::NOATIME: Integer

# <!-- rdoc-file=file.c -->
# [File::NOCTTY](rdoc-ref:File::Constants@File-3A-3ANOCTTY)
#
File::Constants::NOCTTY: Integer

# <!-- rdoc-file=file.c -->
# [File::NOFOLLOW](rdoc-ref:File::Constants@File-3A-3ANOFOLLOW)
#
File::Constants::NOFOLLOW: Integer

# <!-- rdoc-file=file.c -->
# [File::NONBLOCK](rdoc-ref:File::Constants@File-3A-3ANONBLOCK)
#
File::Constants::NONBLOCK: Integer

# <!-- rdoc-file=file.c -->
# [File::NULL](rdoc-ref:File::Constants@File-3A-3ANULL)
#
File::Constants::NULL: String

# <!-- rdoc-file=file.c -->
# [File::RDONLY](rdoc-ref:File::Constants@File-3A-3ARDONLY)
#
File::Constants::RDONLY: Integer

# <!-- rdoc-file=file.c -->
# [File::RDWR](rdoc-ref:File::Constants@File-3A-3ARDWR)
#
File::Constants::RDWR: Integer

# <!-- rdoc-file=file.c -->
# [File::RSYNC](rdoc-ref:File::Constants@File-3A-3ASYNC-2C+File-3A-3ARSYNC-2C+an
# d+File-3A-3ADSYNC)
#
File::Constants::RSYNC: Integer

# <!-- rdoc-file=file.c -->
# [File::SHARE_DELETE](rdoc-ref:File::Constants@File-3A-3ASHARE_DELETE)
#
File::Constants::SHARE_DELETE: Integer

# <!-- rdoc-file=file.c -->
# [File::SYNC](rdoc-ref:File::Constants@File-3A-3ASYNC-2C+File-3A-3ARSYNC-2C+and
# +File-3A-3ADSYNC)
#
File::Constants::SYNC: Integer

# <!-- rdoc-file=file.c -->
# [File::TMPFILE](rdoc-ref:File::Constants@File-3A-3ATMPFILE)
#
File::Constants::TMPFILE: Integer

# <!-- rdoc-file=file.c -->
# [File::TRUNC](rdoc-ref:File::Constants@File-3A-3ATRUNC)
#
File::Constants::TRUNC: Integer

# <!-- rdoc-file=file.c -->
# [File::WRONLY](rdoc-ref:File::Constants@File-3A-3AWRONLY)
#
File::Constants::WRONLY: Integer

# <!-- rdoc-file=file.c -->
# Objects of class File::Stat encapsulate common status information for File
# objects. The information is recorded at the moment the File::Stat object is
# created; changes made to the file after that point will not be reflected.
# File::Stat objects are returned by IO#stat, File::stat, File#lstat, and
# File::lstat. Many of these methods return platform-specific values, and not
# all values are meaningful on all systems. See also Kernel#test.
#
class File::Stat < Object
  include Comparable

  # <!--
  #   rdoc-file=file.c
  #   - new(p1)
  # -->
  # File::Stat.new(file_name)  -> stat
  #
  # Create a File::Stat object for the given file name (raising an exception if
  # the file doesn't exist).
  #
  def initialize: (String file) -> void

  # <!--
  #   rdoc-file=file.c
  #   - stat <=> other_stat    -> -1, 0, 1, nil
  # -->
  # Compares File::Stat objects by comparing their respective modification times.
  #
  # `nil` is returned if `other_stat` is not a File::Stat object
  #
  #     f1 = File.new("f1", "w")
  #     sleep 1
  #     f2 = File.new("f2", "w")
  #     f1.stat <=> f2.stat   #=> -1
  #
  def <=>: (File::Stat other) -> Integer
         | (untyped) -> nil

  # <!--
  #   rdoc-file=file.c
  #   - stat.atime   -> time
  # -->
  # Returns the last access time for this file as an object of class Time.
  #
  #     File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.birthtime  ->  time
  # -->
  # Returns the birth time for *stat*.
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  #     File.write("testfile", "foo")
  #     sleep 10
  #     File.write("testfile", "bar")
  #     sleep 10
  #     File.chmod(0644, "testfile")
  #     sleep 10
  #     File.read("testfile")
  #     File.stat("testfile").birthtime   #=> 2014-02-24 11:19:17 +0900
  #     File.stat("testfile").mtime       #=> 2014-02-24 11:19:27 +0900
  #     File.stat("testfile").ctime       #=> 2014-02-24 11:19:37 +0900
  #     File.stat("testfile").atime       #=> 2014-02-24 11:19:47 +0900
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.blksize   -> integer or nil
  # -->
  # Returns the native file system's block size. Will return `nil` on platforms
  # that don't support this information.
  #
  #     File.stat("testfile").blksize   #=> 4096
  #
  def blksize: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.blockdev?   -> true or false
  # -->
  # Returns `true` if the file is a block device, `false` if it isn't or if the
  # operating system doesn't support this feature.
  #
  #     File.stat("testfile").blockdev?    #=> false
  #     File.stat("/dev/hda1").blockdev?   #=> true
  #
  def blockdev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.blocks    -> integer or nil
  # -->
  # Returns the number of native file system blocks allocated for this file, or
  # `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("testfile").blocks   #=> 2
  #
  def blocks: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.chardev?    -> true or false
  # -->
  # Returns `true` if the file is a character device, `false` if it isn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("/dev/tty").chardev?   #=> true
  #
  def chardev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ctime  ->  time
  # -->
  # Returns the change time for *stat* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev    -> integer
  # -->
  # Returns an integer representing the device on which *stat* resides.
  #
  #     File.stat("testfile").dev   #=> 774
  #
  def dev: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_major   #=> 2
  #     File.stat("/dev/tty").dev_major   #=> 5
  #
  def dev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_minor   #=> 1
  #     File.stat("/dev/tty").dev_minor   #=> 0
  #
  def dev_minor: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.directory?   -> true or false
  # -->
  # Returns `true` if *stat* is a directory, `false` otherwise.
  #
  #     File.stat("testfile").directory?   #=> false
  #     File.stat(".").directory?          #=> true
  #
  def directory?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable?    -> true or false
  # -->
  # Returns `true` if *stat* is executable or if the operating system doesn't
  # distinguish executable files from nonexecutable files. The tests are made
  # using the effective owner of the process.
  #
  #     File.stat("testfile").executable?   #=> false
  #
  def executable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable_real?    -> true or false
  # -->
  # Same as `executable?`, but tests using the real owner of the process.
  #
  def executable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.file?    -> true or false
  # -->
  # Returns `true` if *stat* is a regular file (not a device file, pipe, socket,
  # etc.).
  #
  #     File.stat("testfile").file?   #=> true
  #
  def file?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ftype   -> string
  # -->
  # Identifies the type of *stat*. The return string is one of: ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.stat("/dev/tty").ftype   #=> "characterSpecial"
  #
  def ftype: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.gid   -> integer
  # -->
  # Returns the numeric group id of the owner of *stat*.
  #
  #     File.stat("testfile").gid   #=> 500
  #
  def gid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.grpowned?   -> true or false
  # -->
  # Returns true if the effective group id of the process is the same as the group
  # id of *stat*. On Windows, returns `false`.
  #
  #     File.stat("testfile").grpowned?      #=> true
  #     File.stat("/etc/passwd").grpowned?   #=> false
  #
  def grpowned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ino   -> integer
  # -->
  # Returns the inode number for *stat*.
  #
  #     File.stat("testfile").ino   #=> 1083669
  #
  def ino: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.inspect  ->  string
  # -->
  # Produce a nicely formatted description of *stat*.
  #
  #     File.stat("/etc/passwd").inspect
  #        #=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,
  #        #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,
  #        #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,
  #        #    mtime=Fri Sep 12 15:41:41 CDT 2003,
  #        #    ctime=Mon Oct 27 11:20:27 CST 2003,
  #        #    birthtime=Mon Aug 04 08:13:49 CDT 2003>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.mode   -> integer
  # -->
  # Returns an integer representing the permission bits of *stat*. The meaning of
  # the bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  #     File.chmod(0644, "testfile")   #=> 1
  #     s = File.stat("testfile")
  #     sprintf("%o", s.mode)          #=> "100644"
  #
  def mode: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.mtime  ->  time
  # -->
  # Returns the modification time of *stat*.
  #
  #     File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.nlink   -> integer
  # -->
  # Returns the number of hard links to *stat*.
  #
  #     File.stat("testfile").nlink             #=> 1
  #     File.link("testfile", "testfile.bak")   #=> 0
  #     File.stat("testfile").nlink             #=> 2
  #
  def nlink: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.owned?    -> true or false
  # -->
  # Returns `true` if the effective user id of the process is the same as the
  # owner of *stat*.
  #
  #     File.stat("testfile").owned?      #=> true
  #     File.stat("/etc/passwd").owned?   #=> false
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.pipe?    -> true or false
  # -->
  # Returns `true` if the operating system supports pipes and *stat* is a pipe;
  # `false` otherwise.
  #
  def pipe?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev   ->  integer or nil
  # -->
  # Returns an integer representing the device type on which *stat* resides.
  # Returns `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("/dev/fd1").rdev   #=> 513
  #     File.stat("/dev/tty").rdev   #=> 1280
  #
  def rdev: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_major   #=> 2
  #     File.stat("/dev/tty").rdev_major   #=> 5
  #
  def rdev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_minor   #=> 1
  #     File.stat("/dev/tty").rdev_minor   #=> 0
  #
  def rdev_minor: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable?    -> true or false
  # -->
  # Returns `true` if *stat* is readable by the effective user id of this process.
  #
  #     File.stat("testfile").readable?   #=> true
  #
  def readable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is readable by the real user id of this process.
  #
  #     File.stat("testfile").readable_real?   #=> true
  #
  def readable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setgid?   -> true or false
  # -->
  # Returns `true` if *stat* has the set-group-id permission bit set, `false` if
  # it doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/usr/sbin/lpc").setgid?   #=> true
  #
  def setgid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setuid?    -> true or false
  # -->
  # Returns `true` if *stat* has the set-user-id permission bit set, `false` if it
  # doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/bin/su").setuid?   #=> true
  #
  def setuid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.size    -> integer
  # -->
  # Returns the size of *stat* in bytes.
  #
  #     File.stat("testfile").size   #=> 66
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.size?    -> Integer or nil
  # -->
  # Returns `nil` if *stat* is a zero-length file, the size of the file otherwise.
  #
  #     File.stat("testfile").size?   #=> 66
  #     File.stat(File::NULL).size?   #=> nil
  #
  def size?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.socket?    -> true or false
  # -->
  # Returns `true` if *stat* is a socket, `false` if it isn't or if the operating
  # system doesn't support this feature.
  #
  #     File.stat("testfile").socket?   #=> false
  #
  def socket?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.sticky?    -> true or false
  # -->
  # Returns `true` if *stat* has its sticky bit set, `false` if it doesn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("testfile").sticky?   #=> false
  #
  def sticky?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.symlink?    -> true or false
  # -->
  # Returns `true` if *stat* is a symbolic link, `false` if it isn't or if the
  # operating system doesn't support this feature. As File::stat automatically
  # follows symbolic links, #symlink? will always be `false` for an object
  # returned by File::stat.
  #
  #     File.symlink("testfile", "alink")   #=> 0
  #     File.stat("alink").symlink?         #=> false
  #     File.lstat("alink").symlink?        #=> true
  #
  def symlink?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.uid    -> integer
  # -->
  # Returns the numeric user id of the owner of *stat*.
  #
  #     File.stat("testfile").uid   #=> 501
  #
  def uid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_readable? -> integer or nil
  # -->
  # If *stat* is readable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/etc/passwd").world_readable?  #=> 420
  #     sprintf("%o", m)                              #=> "644"
  #
  def world_readable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_writable?  ->  integer or nil
  # -->
  # If *stat* is writable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/tmp").world_writable?         #=> 511
  #     sprintf("%o", m)                              #=> "777"
  #
  def world_writable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the effective user id of this process.
  #
  #     File.stat("testfile").writable?   #=> true
  #
  def writable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the real user id of this process.
  #
  #     File.stat("testfile").writable_real?   #=> true
  #
  def writable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.zero?    -> true or false
  # -->
  # Returns `true` if *stat* is a zero-length file; `false` otherwise.
  #
  #     File.stat("testfile").zero?   #=> false
  #
  def zero?: () -> bool
end
# <!-- rdoc-file=error.c -->
# Class `Exception` and its subclasses are used to indicate that an error or
# other problem has occurred, and may need to be handled. See
# [Exceptions](rdoc-ref:exceptions.md).
#
# An `Exception` object carries certain information:
#
# *   The type (the exception's class), commonly StandardError, RuntimeError, or
#     a subclass of one or the other; see [Built-In Exception Class
#     Hierarchy](rdoc-ref:Exception@Built-In+Exception+Class+Hierarchy).
# *   An optional descriptive message; see methods ::new, #message.
# *   Optional backtrace information; see methods #backtrace,
#     #backtrace_locations, #set_backtrace.
# *   An optional cause; see method #cause.
#
# ## Built-In Exception Class Hierarchy
#
# The hierarchy of built-in subclasses of class `Exception`:
#
# *   NoMemoryError
# *   ScriptError
#     *   LoadError
#     *   NotImplementedError
#     *   SyntaxError
# *   SecurityError
# *   SignalException
#     *   Interrupt
# *   StandardError
#     *   ArgumentError
#         *   UncaughtThrowError
#     *   EncodingError
#     *   FiberError
#     *   IOError
#         *   EOFError
#     *   IndexError
#         *   KeyError
#         *   StopIteration
#             *   ClosedQueueError
#     *   LocalJumpError
#     *   NameError
#         *   NoMethodError
#     *   RangeError
#         *   FloatDomainError
#     *   RegexpError
#     *   RuntimeError
#         *   FrozenError
#     *   SystemCallError
#         *   Errno (and its subclasses, representing system errors)
#     *   ThreadError
#     *   TypeError
#     *   ZeroDivisionError
# *   SystemExit
# *   SystemStackError
# *   [fatal](rdoc-ref:fatal)
#
class Exception
  # <!--
  #   rdoc-file=error.c
  #   - Exception.to_tty? -> true or false
  # -->
  # Returns `true` if exception messages will be sent to a terminal device.
  #
  def self.to_tty?: () -> bool

  # <!--
  #   rdoc-file=error.c
  #   - exception(message = nil) -> self or new_exception
  # -->
  # Returns an exception object of the same class as `self`; useful for creating a
  # similar exception, but with a different message.
  #
  # With `message` `nil`, returns `self`:
  #
  #     x0 = StandardError.new('Boom') # => #<StandardError: Boom>
  #     x1 = x0.exception              # => #<StandardError: Boom>
  #     x0.__id__ == x1.__id__         # => true
  #
  # With [string-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@String-Convertible+Objects)
  # `message` (even the same as the original message), returns a new exception
  # object whose class is the same as `self`, and whose message is the given
  # `message`:
  #
  #     x1 = x0.exception('Boom') # => #<StandardError: Boom>
  #     x0..equal?(x1)            # => false
  #
  def self.exception: (?string | _ToS msg) -> instance

  # <!--
  #   rdoc-file=error.c
  #   - self == object -> true or false
  # -->
  # Returns whether `object` is the same class as `self` and its #message and
  # #backtrace are equal to those of `self`.
  #
  def ==: (untyped obj) -> bool

  # <!--
  #   rdoc-file=error.c
  #   - backtrace -> array or nil
  # -->
  # Returns a backtrace value for `self`; the returned value depends on the form
  # of the stored backtrace value:
  #
  # *   Array of Thread::Backtrace::Location objects: returns the array of strings
  #     given by `Exception#backtrace_locations.map {|loc| loc.to_s }`. This is
  #     the normal case, where the backtrace value was stored by Kernel#raise.
  # *   Array of strings: returns that array. This is the unusual case, where the
  #     backtrace value was explicitly stored as an array of strings.
  # *   `nil`: returns `nil`.
  #
  # Example:
  #
  #     begin
  #       1 / 0
  #     rescue => x
  #       x.backtrace.take(2)
  #     end
  #     # => ["(irb):132:in `/'", "(irb):132:in `<top (required)>'"]
  #
  # see [Backtraces](rdoc-ref:exceptions.md@Backtraces).
  #
  def backtrace: () -> Array[String]?

  # <!--
  #   rdoc-file=error.c
  #   - backtrace_locations -> array or nil
  # -->
  # Returns a backtrace value for `self`; the returned value depends on the form
  # of the stored backtrace value:
  #
  # *   Array of Thread::Backtrace::Location objects: returns that array.
  # *   Array of strings or `nil`: returns `nil`.
  #
  # Example:
  #
  #     begin
  #       1 / 0
  #     rescue => x
  #       x.backtrace_locations.take(2)
  #     end
  #     # => ["(irb):150:in `/'", "(irb):150:in `<top (required)>'"]
  #
  # See [Backtraces](rdoc-ref:exceptions.md@Backtraces).
  #
  def backtrace_locations: () -> Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=error.c
  #   - cause -> exception or nil
  # -->
  # Returns the previous value of global variable `$!`, which may be `nil` (see
  # [Global Variables](rdoc-ref:exceptions.md@Global+Variables)):
  #
  #     begin
  #       raise('Boom 0')
  #     rescue => x0
  #       puts "Exception: #{x0};  $!: #{$!};  cause: #{x0.cause.inspect}."
  #       begin
  #         raise('Boom 1')
  #       rescue => x1
  #         puts "Exception: #{x1};  $!: #{$!};  cause: #{x1.cause}."
  #         begin
  #           raise('Boom 2')
  #         rescue => x2
  #           puts "Exception: #{x2};  $!: #{$!};  cause: #{x2.cause}."
  #         end
  #       end
  #     end
  #
  # Output:
  #
  #     Exception: Boom 0;  $!: Boom 0;  cause: nil.
  #     Exception: Boom 1;  $!: Boom 1;  cause: Boom 0.
  #     Exception: Boom 2;  $!: Boom 2;  cause: Boom 1.
  #
  def cause: () -> Exception?

  # <!--
  #   rdoc-file=error.c
  #   - detailed_message(highlight: false, **kwargs) -> string
  # -->
  # Returns the message string with enhancements:
  #
  # *   Includes the exception class name in the first line.
  # *   If the value of keyword `highlight` is `true`, includes bolding and
  #     underlining ANSI codes (see below) to enhance the appearance of the
  #     message.
  #
  # Examples:
  #
  #     begin
  #       1 / 0
  #     rescue => x
  #       p x.message
  #       p x.detailed_message                  # Class name added.
  #       p x.detailed_message(highlight: true) # Class name, bolding, and underlining added.
  #     end
  #
  # Output:
  #
  #     "divided by 0"
  #     "divided by 0 (ZeroDivisionError)"
  #     "\e[1mdivided by 0 (\e[1;4mZeroDivisionError\e[m\e[1m)\e[m"
  #
  # This method is overridden by some gems in the Ruby standard library to add
  # information:
  #
  # *   DidYouMean::Correctable#detailed_message.
  # *   ErrorHighlight::CoreExt#detailed_message.
  # *   SyntaxSuggest#detailed_message.
  #
  # An overriding method must be tolerant of passed keyword arguments, which may
  # include (but may not be limited to):
  #
  # *   `:highlight`.
  # *   `:did_you_mean`.
  # *   `:error_highlight`.
  # *   `:syntax_suggest`.
  #
  # An overriding method should also be careful with ANSI code enhancements; see
  # [Messages](rdoc-ref:exceptions.md@Messages).
  #
  def detailed_message: (?highlight: bool?, **untyped ignored) -> String

  # <!--
  #   rdoc-file=error.c
  #   - exception(message = nil) -> self or new_exception
  # -->
  # Returns an exception object of the same class as `self`; useful for creating a
  # similar exception, but with a different message.
  #
  # With `message` `nil`, returns `self`:
  #
  #     x0 = StandardError.new('Boom') # => #<StandardError: Boom>
  #     x1 = x0.exception              # => #<StandardError: Boom>
  #     x0.__id__ == x1.__id__         # => true
  #
  # With [string-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@String-Convertible+Objects)
  # `message` (even the same as the original message), returns a new exception
  # object whose class is the same as `self`, and whose message is the given
  # `message`:
  #
  #     x1 = x0.exception('Boom') # => #<StandardError: Boom>
  #     x0..equal?(x1)            # => false
  #
  def exception: (?self) -> self
               | (string | _ToS message) -> instance

  # <!--
  #   rdoc-file=error.c
  #   - Exception.new(message = nil) -> exception
  # -->
  # Returns a new exception object.
  #
  # The given `message` should be a [string-convertible
  # object](rdoc-ref:implicit_conversion.rdoc@String-Convertible+Objects); see
  # method #message; if not given, the message is the class name of the new
  # instance (which may be the name of a subclass):
  #
  # Examples:
  #
  #     Exception.new         # => #<Exception: Exception>
  #     LoadError.new         # => #<LoadError: LoadError> # Subclass of Exception.
  #     Exception.new('Boom') # => #<Exception: Boom>
  #
  def initialize: (?string | _ToS message) -> void

  # <!--
  #   rdoc-file=error.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     x = RuntimeError.new('Boom')
  #     x.inspect # => "#<RuntimeError: Boom>"
  #     x = RuntimeError.new
  #     x.inspect # => "#<RuntimeError: RuntimeError>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - message -> string
  # -->
  # Returns #to_s.
  #
  # See [Messages](rdoc-ref:exceptions.md@Messages).
  #
  def message: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - set_backtrace(value) -> value
  # -->
  # Sets the backtrace value for `self`; returns the given +value:
  #
  #     x = RuntimeError.new('Boom')
  #     x.set_backtrace(%w[foo bar baz]) # => ["foo", "bar", "baz"]
  #     x.backtrace                      # => ["foo", "bar", "baz"]
  #
  # The given `value` must be an array of strings, a single string, or `nil`.
  #
  # Does not affect the value returned by #backtrace_locations.
  #
  # See [Backtraces](rdoc-ref:exceptions.md@Backtraces).
  #
  def set_backtrace: (String | Array[String]) -> Array[String]
                   | (Array[Thread::Backtrace::Location]) -> Array[Thread::Backtrace::Location]
                   | (nil) -> nil

  # <!--
  #   rdoc-file=error.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     x = RuntimeError.new('Boom')
  #     x.to_s # => "Boom"
  #     x = RuntimeError.new
  #     x.to_s # => "RuntimeError"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - full_message(highlight: true, order: :top) -> string
  # -->
  # Returns an enhanced message string:
  #
  # *   Includes the exception class name.
  # *   If the value of keyword `highlight` is true (not `nil` or `false`),
  #     includes bolding ANSI codes (see below) to enhance the appearance of the
  #     message.
  # *   Includes the [backtrace](rdoc-ref:exceptions.md@Backtraces):
  #
  #     *   If the value of keyword `order` is `:top` (the default), lists the
  #         error message and the innermost backtrace entry first.
  #     *   If the value of keyword `order` is `:bottom`, lists the error message
  #         the the innermost entry last.
  #
  # Example:
  #
  #     def baz
  #       begin
  #         1 / 0
  #       rescue => x
  #         pp x.message
  #         pp x.full_message(highlight: false).split("\n")
  #         pp x.full_message.split("\n")
  #       end
  #     end
  #     def bar; baz; end
  #     def foo; bar; end
  #     foo
  #
  # Output:
  #
  #     "divided by 0"
  #     ["t.rb:3:in `/': divided by 0 (ZeroDivisionError)",
  #      "\tfrom t.rb:3:in `baz'",
  #      "\tfrom t.rb:10:in `bar'",
  #      "\tfrom t.rb:11:in `foo'",
  #      "\tfrom t.rb:12:in `<main>'"]
  #     ["t.rb:3:in `/': \e[1mdivided by 0 (\e[1;4mZeroDivisionError\e[m\e[1m)\e[m",
  #      "\tfrom t.rb:3:in `baz'",
  #      "\tfrom t.rb:10:in `bar'",
  #      "\tfrom t.rb:11:in `foo'",
  #      "\tfrom t.rb:12:in `<main>'"]
  #
  # An overriding method should be careful with ANSI code enhancements; see
  # [Messages](rdoc-ref:exceptions.md@Messages).
  #
  def full_message: (?highlight: bool?, ?order: (:top | :bottom | string)?) -> String
end
# <!-- rdoc-file=complex.c -->
# A Complex object houses a pair of values, given when the object is created as
# either *rectangular coordinates* or *polar coordinates*.
#
# ## Rectangular Coordinates
#
# The rectangular coordinates of a complex number are called the *real* and
# *imaginary* parts; see [Complex number
# definition](https://en.wikipedia.org/wiki/Complex_number#Definition_and_basic_
# operations).
#
# You can create a Complex object from rectangular coordinates with:
#
# *   A [complex literal](rdoc-ref:syntax/literals.rdoc@Complex+Literals).
# *   Method Complex.rect.
# *   Method Kernel#Complex, either with numeric arguments or with certain
#     string arguments.
# *   Method String#to_c, for certain strings.
#
# Note that each of the stored parts may be a an instance one of the classes
# Complex, Float, Integer, or Rational; they may be retrieved:
#
# *   Separately, with methods Complex#real and Complex#imaginary.
# *   Together, with method Complex#rect.
#
# The corresponding (computed) polar values may be retrieved:
#
# *   Separately, with methods Complex#abs and Complex#arg.
# *   Together, with method Complex#polar.
#
# ## Polar Coordinates
#
# The polar coordinates of a complex number are called the *absolute* and
# *argument* parts; see [Complex polar
# plane](https://en.wikipedia.org/wiki/Complex_number#Polar_form).
#
# In this class, the argument part in expressed
# [radians](https://en.wikipedia.org/wiki/Radian) (not
# [degrees](https://en.wikipedia.org/wiki/Degree_(angle))).
#
# You can create a Complex object from polar coordinates with:
#
# *   Method Complex.polar.
# *   Method Kernel#Complex, with certain string arguments.
# *   Method String#to_c, for certain strings.
#
# Note that each of the stored parts may be a an instance one of the classes
# Complex, Float, Integer, or Rational; they may be retrieved:
#
# *   Separately, with methods Complex#abs and Complex#arg.
# *   Together, with method Complex#polar.
#
# The corresponding (computed) rectangular values may be retrieved:
#
# *   Separately, with methods Complex#real and Complex#imag.
# *   Together, with method Complex#rect.
#
# ## What's Here
#
# First, what's elsewhere:
#
# *   Class Complex inherits (directly or indirectly) from classes
#     [Numeric](rdoc-ref:Numeric@What-27s+Here) and
#     [Object](rdoc-ref:Object@What-27s+Here).
# *   Includes (indirectly) module
#     [Comparable](rdoc-ref:Comparable@What-27s+Here).
#
# Here, class Complex has methods for:
#
# ### Creating Complex Objects
#
# *   ::polar: Returns a new Complex object based on given polar coordinates.
# *   ::rect (and its alias ::rectangular): Returns a new Complex object based
#     on given rectangular coordinates.
#
# ### Querying
#
# *   #abs (and its alias #magnitude): Returns the absolute value for `self`.
# *   #arg (and its aliases #angle and #phase): Returns the argument (angle) for
#     `self` in radians.
# *   #denominator: Returns the denominator of `self`.
# *   #finite?: Returns whether both `self.real` and `self.image` are finite.
# *   #hash: Returns the integer hash value for `self`.
# *   #imag (and its alias #imaginary): Returns the imaginary value for `self`.
# *   #infinite?: Returns whether `self.real` or `self.image` is infinite.
# *   #numerator: Returns the numerator of `self`.
# *   #polar: Returns the array `[self.abs, self.arg]`.
# *   #inspect: Returns a string representation of `self`.
# *   #real: Returns the real value for `self`.
# *   #real?: Returns `false`; for compatibility with Numeric#real?.
# *   #rect (and its alias #rectangular): Returns the array `[self.real,
#     self.imag]`.
#
# ### Comparing
#
# *   #<=>: Returns whether `self` is less than, equal to, or greater than the
#     given argument.
# *   #==: Returns whether `self` is equal to the given argument.
#
# ### Converting
#
# *   #rationalize: Returns a Rational object whose value is exactly or
#     approximately equivalent to that of `self.real`.
# *   #to_c: Returns `self`.
# *   #to_d: Returns the value as a BigDecimal object.
# *   #to_f: Returns the value of `self.real` as a Float, if possible.
# *   #to_i: Returns the value of `self.real` as an Integer, if possible.
# *   #to_r: Returns the value of `self.real` as a Rational, if possible.
# *   #to_s: Returns a string representation of `self`.
#
# ### Performing Complex Arithmetic
#
# *   #*: Returns the product of `self` and the given numeric.
# *   #**: Returns `self` raised to power of the given numeric.
# *   #+: Returns the sum of `self` and the given numeric.
# *   #-: Returns the difference of `self` and the given numeric.
# *   #-@: Returns the negation of `self`.
# *   #/: Returns the quotient of `self` and the given numeric.
# *   #abs2: Returns square of the absolute value (magnitude) for `self`.
# *   #conj (and its alias #conjugate): Returns the conjugate of `self`.
# *   #fdiv: Returns `Complex.rect(self.real/numeric, self.imag/numeric)`.
#
# ### Working with JSON
#
# *   ::json_create: Returns a new Complex object, deserialized from the given
#     serialized hash.
# *   #as_json: Returns a serialized hash constructed from `self`.
# *   #to_json: Returns a JSON string representing `self`.
#
# These methods are provided by the [JSON gem](https://github.com/ruby/json). To
# make these methods available:
#
#     require 'json/add/complex'
#
class Complex < Numeric
  # <!--
  #   rdoc-file=complex.c
  #   - Complex.polar(abs, arg = 0) -> complex
  # -->
  # Returns a new Complex object formed from the arguments, each of which must be
  # an instance of Numeric, or an instance of one of its subclasses: Complex,
  # Float, Integer, Rational. Argument `arg` is given in radians; see [Polar
  # Coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(3)        # => (3+0i)
  #     Complex.polar(3, 2.0)   # => (-1.2484405096414273+2.727892280477045i)
  #     Complex.polar(-3, -2.0) # => (1.2484405096414273+2.727892280477045i)
  #
  def self.polar: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real, imag = 0) -> complex
  # -->
  # Returns a new Complex object formed from the arguments, each of which must be
  # an instance of Numeric, or an instance of one of its subclasses: Complex,
  # Float, Integer, Rational; see [Rectangular
  # Coordinates](rdoc-ref:Complex@Rectangular+Coordinates):
  #
  #     Complex.rect(3)             # => (3+0i)
  #     Complex.rect(3, Math::PI)   # => (3+3.141592653589793i)
  #     Complex.rect(-3, -Math::PI) # => (-3-3.141592653589793i)
  #
  # Complex.rectangular is an alias for Complex.rect.
  #
  def self.rect: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real, imag = 0) -> complex
  # -->
  # Returns a new Complex object formed from the arguments, each of which must be
  # an instance of Numeric, or an instance of one of its subclasses: Complex,
  # Float, Integer, Rational; see [Rectangular
  # Coordinates](rdoc-ref:Complex@Rectangular+Coordinates):
  #
  #     Complex.rect(3)             # => (3+0i)
  #     Complex.rect(3, Math::PI)   # => (3+3.141592653589793i)
  #     Complex.rect(-3, -Math::PI) # => (-3-3.141592653589793i)
  #
  # Complex.rectangular is an alias for Complex.rect.
  #
  alias self.rectangular self.rect

  # <!--
  #   rdoc-file=complex.c
  #   - complex * numeric -> new_complex
  # -->
  # Returns the product of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  * Complex.rect(2, 3)  # => (-5+12i)
  #     Complex.rect(900)   * Complex.rect(1)     # => (900+0i)
  #     Complex.rect(-2, 9) * Complex.rect(-9, 2) # => (0-85i)
  #     Complex.rect(9, 8)  * 4                   # => (36+32i)
  #     Complex.rect(20, 9) * 9.8                 # => (196.0+88.2i)
  #
  def *: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - complex ** numeric -> new_complex
  # -->
  # Returns `self` raised to power `numeric`:
  #
  #     Complex.rect(0, 1) ** 2            # => (-1+0i)
  #     Complex.rect(-8) ** Rational(1, 3) # => (1.0000000000000002+1.7320508075688772i)
  #
  def **: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - complex + numeric -> new_complex
  # -->
  # Returns the sum of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  + Complex.rect(2, 3)  # => (4+6i)
  #     Complex.rect(900)   + Complex.rect(1)     # => (901+0i)
  #     Complex.rect(-2, 9) + Complex.rect(-9, 2) # => (-11+11i)
  #     Complex.rect(9, 8)  + 4                   # => (13+8i)
  #     Complex.rect(20, 9) + 9.8                 # => (29.8+9i)
  #
  def +: (Numeric) -> Complex

  def +@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - complex - numeric -> new_complex
  # -->
  # Returns the difference of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  - Complex.rect(2, 3)  # => (0+0i)
  #     Complex.rect(900)   - Complex.rect(1)     # => (899+0i)
  #     Complex.rect(-2, 9) - Complex.rect(-9, 2) # => (7+7i)
  #     Complex.rect(9, 8)  - 4                   # => (5+8i)
  #     Complex.rect(20, 9) - 9.8                 # => (10.2+9i)
  #
  def -: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - -complex -> new_complex
  # -->
  # Returns the negation of `self`, which is the negation of each of its parts:
  #
  #     -Complex.rect(1, 2)   # => (-1-2i)
  #     -Complex.rect(-1, -2) # => (1+2i)
  #
  def -@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - complex / numeric -> new_complex
  # -->
  # Returns the quotient of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  / Complex.rect(2, 3)  # => (1+0i)
  #     Complex.rect(900)   / Complex.rect(1)     # => (900+0i)
  #     Complex.rect(-2, 9) / Complex.rect(-9, 2) # => ((36/85)-(77/85)*i)
  #     Complex.rect(9, 8)  / 4                   # => ((9/4)+2i)
  #     Complex.rect(20, 9) / 9.8                 # => (2.0408163265306123+0.9183673469387754i)
  #
  def /: (Numeric) -> Complex

  def <: (Numeric) -> bot

  def <=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - complex <=> object -> -1, 0, 1, or nil
  # -->
  # Returns:
  #
  # *   `self.real <=> object.real` if both of the following are true:
  #
  #     *   `self.imag == 0`.
  #     *   `object.imag == 0`. # Always true if object is numeric but not
  #         complex.
  #
  # *   `nil` otherwise.
  #
  # Examples:
  #
  #     Complex.rect(2) <=> 3                  # => -1
  #     Complex.rect(2) <=> 2                  # => 0
  #     Complex.rect(2) <=> 1                  # => 1
  #     Complex.rect(2, 1) <=> 1               # => nil # self.imag not zero.
  #     Complex.rect(1) <=> Complex.rect(1, 1) # => nil # object.imag not zero.
  #     Complex.rect(1) <=> 'Foo'              # => nil # object.imag not defined.
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - complex == object -> true or false
  # -->
  # Returns `true` if `self.real == object.real` and `self.imag == object.imag`:
  #
  #     Complex.rect(2, 3)  == Complex.rect(2.0, 3.0) # => true
  #
  def ==: (untyped) -> bool

  def >: (Numeric) -> bot

  def >=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - abs -> float
  # -->
  # Returns the absolute value (magnitude) for `self`; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(-1, 0).abs # => 1.0
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.rectangular(1, 1).abs # => 1.4142135623730951 # The square root of 2.
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - abs2 -> float
  # -->
  # Returns square of the absolute value (magnitude) for `self`; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(2, 2).abs2 # => 4.0
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.rectangular(1.0/3, 1.0/3).abs2 # => 0.2222222222222222
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns the argument (angle) for `self` in radians; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(3, Math::PI/2).arg  # => 1.57079632679489660
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, 1.0/3).arg # => 0.33333333333333326
  #
  def angle: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - arg -> float
  # -->
  # Returns the argument (angle) for `self` in radians; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(3, Math::PI/2).arg  # => 1.57079632679489660
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, 1.0/3).arg # => 0.33333333333333326
  #
  alias arg angle

  def ceil: (*untyped) -> bot

  def coerce: (Numeric) -> [ Complex, Complex ]

  # <!-- rdoc-file=complex.c -->
  # Returns the conjugate of `self`, `Complex.rect(self.imag, self.real)`:
  #
  #     Complex.rect(1, 2).conj # => (1-2i)
  #
  def conj: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - conj -> complex
  # -->
  # Returns the conjugate of `self`, `Complex.rect(self.imag, self.real)`:
  #
  #     Complex.rect(1, 2).conj # => (1-2i)
  #
  def conjugate: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - denominator -> integer
  # -->
  # Returns the denominator of `self`, which is the [least common
  # multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of
  # `self.real.denominator` and `self.imag.denominator`:
  #
  #     Complex.rect(Rational(1, 2), Rational(2, 3)).denominator # => 6
  #
  # Note that `n.denominator` of a non-rational numeric is `1`.
  #
  # Related: Complex#numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> bot

  def divmod: (Numeric) -> bot

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=complex.c
  #   - fdiv(numeric) -> new_complex
  # -->
  # Returns `Complex.rect(self.real/numeric, self.imag/numeric)`:
  #
  #     Complex.rect(11, 22).fdiv(3) # => (3.6666666666666665+7.333333333333333i)
  #
  def fdiv: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - finite? -> true or false
  # -->
  # Returns `true` if both `self.real.finite?` and `self.imag.finite?` are true,
  # `false` otherwise:
  #
  #     Complex.rect(1, 1).finite?               # => true
  #     Complex.rect(Float::INFINITY, 0).finite? # => false
  #
  # Related: Numeric#finite?, Float#finite?.
  #
  def finite?: () -> bool

  def floor: (?Integer) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two Complex objects created from the same values will have the same hash value
  # (and will compare using #eql?):
  #
  #     Complex.rect(1, 2).hash == Complex.rect(1, 2).hash # => true
  #
  def hash: () -> Integer

  def i: () -> bot

  # <!-- rdoc-file=complex.c -->
  # Returns the imaginary value for `self`:
  #
  #     Complex.rect(7).imag     # => 0
  #     Complex.rect(9, -4).imag # => -4
  #
  # If `self` was created with [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, Math::PI/4).imag # => 0.7071067811865476 # Square root of 2.
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - imag -> numeric
  # -->
  # Returns the imaginary value for `self`:
  #
  #     Complex.rect(7).imag     # => 0
  #     Complex.rect(9, -4).imag # => -4
  #
  # If `self` was created with [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, Math::PI/4).imag # => 0.7071067811865476 # Square root of 2.
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - infinite? -> 1 or nil
  # -->
  # Returns `1` if either `self.real.infinite?` or `self.imag.infinite?` is true,
  # `nil` otherwise:
  #
  #     Complex.rect(Float::INFINITY, 0).infinite? # => 1
  #     Complex.rect(1, 1).infinite?               # => nil
  #
  # Related: Numeric#infinite?, Float#infinite?.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     Complex.rect(2).inspect                      # => "(2+0i)"
  #     Complex.rect(-8, 6).inspect                  # => "(-8+6i)"
  #     Complex.rect(0, Rational(1, 2)).inspect      # => "(0+(1/2)*i)"
  #     Complex.rect(0, Float::INFINITY).inspect     # => "(0+Infinity*i)"
  #     Complex.rect(Float::NAN, Float::NAN).inspect # => "(NaN+NaN*i)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns the absolute value (magnitude) for `self`; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(-1, 0).abs # => 1.0
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.rectangular(1, 1).abs # => 1.4142135623730951 # The square root of 2.
  #
  alias magnitude abs

  def modulo: (Numeric) -> bot

  def negative?: () -> bot

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - numerator -> new_complex
  # -->
  # Returns the Complex object created from the numerators of the real and
  # imaginary parts of `self`, after converting each part to the [lowest common
  # denominator](https://en.wikipedia.org/wiki/Lowest_common_denominator) of the
  # two:
  #
  #     c = Complex.rect(Rational(2, 3), Rational(3, 4)) # => ((2/3)+(3/4)*i)
  #     c.numerator                                      # => (8+9i)
  #
  # In this example, the lowest common denominator of the two parts is 12; the two
  # converted parts may be thought of as Rational(8, 12) and Rational(9, 12),
  # whose numerators, respectively, are 8 and 9; so the returned value of
  # `c.numerator` is `Complex.rect(8, 9)`.
  #
  # Related: Complex#denominator.
  #
  def numerator: () -> Complex

  # <!-- rdoc-file=complex.c -->
  # Returns the argument (angle) for `self` in radians; see [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates):
  #
  #     Complex.polar(3, Math::PI/2).arg  # => 1.57079632679489660
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, 1.0/3).arg # => 0.33333333333333326
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - polar -> array
  # -->
  # Returns the array `[self.abs, self.arg]`:
  #
  #     Complex.polar(1, 2).polar # => [1.0, 2.0]
  #
  # See [Polar Coordinates](rdoc-ref:Complex@Polar+Coordinates).
  #
  # If `self` was created with [rectangular
  # coordinates](rdoc-ref:Complex@Rectangular+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.rect(1, 1).polar # => [1.4142135623730951, 0.7853981633974483]
  #
  def polar: () -> [ Numeric, Float ]

  def positive?: () -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - complex / numeric -> new_complex
  # -->
  # Returns the quotient of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  / Complex.rect(2, 3)  # => (1+0i)
  #     Complex.rect(900)   / Complex.rect(1)     # => (900+0i)
  #     Complex.rect(-2, 9) / Complex.rect(-9, 2) # => ((36/85)-(77/85)*i)
  #     Complex.rect(9, 8)  / 4                   # => ((9/4)+2i)
  #     Complex.rect(20, 9) / 9.8                 # => (2.0408163265306123+0.9183673469387754i)
  #
  def quo: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - rationalize(epsilon = nil) -> rational
  # -->
  # Returns a Rational object whose value is exactly or approximately equivalent
  # to that of `self.real`.
  #
  # With no argument `epsilon` given, returns a Rational object whose value is
  # exactly equal to that of `self.real.rationalize`:
  #
  #     Complex.rect(1, 0).rationalize              # => (1/1)
  #     Complex.rect(1, Rational(0, 1)).rationalize # => (1/1)
  #     Complex.rect(3.14159, 0).rationalize        # => (314159/100000)
  #
  # With argument `epsilon` given, returns a Rational object whose value is
  # exactly or approximately equal to that of `self.real` to the given precision:
  #
  #     Complex.rect(3.14159, 0).rationalize(0.1)          # => (16/5)
  #     Complex.rect(3.14159, 0).rationalize(0.01)         # => (22/7)
  #     Complex.rect(3.14159, 0).rationalize(0.001)        # => (201/64)
  #     Complex.rect(3.14159, 0).rationalize(0.0001)       # => (333/106)
  #     Complex.rect(3.14159, 0).rationalize(0.00001)      # => (355/113)
  #     Complex.rect(3.14159, 0).rationalize(0.000001)     # => (7433/2366)
  #     Complex.rect(3.14159, 0).rationalize(0.0000001)    # => (9208/2931)
  #     Complex.rect(3.14159, 0).rationalize(0.00000001)   # => (47460/15107)
  #     Complex.rect(3.14159, 0).rationalize(0.000000001)  # => (76149/24239)
  #     Complex.rect(3.14159, 0).rationalize(0.0000000001) # => (314159/100000)
  #     Complex.rect(3.14159, 0).rationalize(0.0)          # => (3537115888337719/1125899906842624)
  #
  # Related: Complex#to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - real -> numeric
  # -->
  # Returns the real value for `self`:
  #
  #     Complex.rect(7).real     # => 7
  #     Complex.rect(9, -4).real # => 9
  #
  # If `self` was created with [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1, Math::PI/4).real # => 0.7071067811865476 # Square root of 2.
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - real? -> false
  # -->
  # Returns `false`; for compatibility with Numeric#real?.
  #
  def real?: () -> false

  # <!-- rdoc-file=complex.c -->
  # Returns a new Complex object formed from the arguments, each of which must be
  # an instance of Numeric, or an instance of one of its subclasses: Complex,
  # Float, Integer, Rational; see [Rectangular
  # Coordinates](rdoc-ref:Complex@Rectangular+Coordinates):
  #
  #     Complex.rect(3)             # => (3+0i)
  #     Complex.rect(3, Math::PI)   # => (3+3.141592653589793i)
  #     Complex.rect(-3, -Math::PI) # => (-3-3.141592653589793i)
  #
  # Complex.rectangular is an alias for Complex.rect.
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - rect -> array
  # -->
  # Returns the array `[self.real, self.imag]`:
  #
  #     Complex.rect(1, 2).rect # => [1, 2]
  #
  # See [Rectangular Coordinates](rdoc-ref:Complex@Rectangular+Coordinates).
  #
  # If `self` was created with [polar
  # coordinates](rdoc-ref:Complex@Polar+Coordinates), the returned value is
  # computed, and may be inexact:
  #
  #     Complex.polar(1.0, 1.0).rect # => [0.5403023058681398, 0.8414709848078965]
  #
  # Complex#rectangular is an alias for Complex#rect.
  #
  alias rectangular rect

  def reminder: (Numeric) -> bot

  def round: (*untyped) -> bot

  def step: (*untyped) ?{ (*untyped) -> untyped } -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - to_c -> self
  # -->
  # Returns `self`.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - to_f -> float
  # -->
  # Returns the value of `self.real` as a Float, if possible:
  #
  #     Complex.rect(1, 0).to_f              # => 1.0
  #     Complex.rect(1, Rational(0, 1)).to_f # => 1.0
  #
  # Raises RangeError if `self.imag` is not exactly zero (either `Integer(0)` or
  # `Rational(0, *n*)`).
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - to_i -> integer
  # -->
  # Returns the value of `self.real` as an Integer, if possible:
  #
  #     Complex.rect(1, 0).to_i              # => 1
  #     Complex.rect(1, Rational(0, 1)).to_i # => 1
  #
  # Raises RangeError if `self.imag` is not exactly zero (either `Integer(0)` or
  # `Rational(0, *n*)`).
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=complex.c
  #   - to_r -> rational
  # -->
  # Returns the value of `self.real` as a Rational, if possible:
  #
  #     Complex.rect(1, 0).to_r              # => (1/1)
  #     Complex.rect(1, Rational(0, 1)).to_r # => (1/1)
  #     Complex.rect(1, 0.0).to_r            # => (1/1)
  #
  # Raises RangeError if `self.imag` is not exactly zero (either `Integer(0)` or
  # `Rational(0, *n*)`) and `self.imag.to_r` is not exactly zero.
  #
  # Related: Complex#rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     Complex.rect(2).to_s                      # => "2+0i"
  #     Complex.rect(-8, 6).to_s                  # => "-8+6i"
  #     Complex.rect(0, Rational(1, 2)).to_s      # => "0+1/2i"
  #     Complex.rect(0, Float::INFINITY).to_s     # => "0+Infinity*i"
  #     Complex.rect(Float::NAN, Float::NAN).to_s # => "NaN+NaN*i"
  #
  def to_s: () -> String

  def truncate: (?Integer) -> bot

  def zero?: () -> bool
end

# <!-- rdoc-file=complex.c -->
# Equivalent to `Complex.rect(0, 1)`:
#
#     Complex::I # => (0+1i)
#
Complex::I: Complex
%a{annotate:rdoc:skip}
class IO
  # <!-- rdoc-file=io_buffer.c -->
  # IO::Buffer is a efficient zero-copy buffer for input/output. There are typical
  # use cases:
  #
  # *   Create an empty buffer with ::new, fill it with buffer using #copy or
  #     #set_value, #set_string, get buffer with #get_string or write it directly
  #     to some file with #write.
  # *   Create a buffer mapped to some string with ::for, then it could be used
  #     both for reading with #get_string or #get_value, and writing (writing will
  #     change the source string, too).
  # *   Create a buffer mapped to some file with ::map, then it could be used for
  #     reading and writing the underlying file.
  # *   Create a string of a fixed size with ::string, then #read into it, or
  #     modify it using #set_value.
  #
  # Interaction with string and file memory is performed by efficient low-level C
  # mechanisms like `memcpy`.
  #
  # The class is meant to be an utility for implementing more high-level
  # mechanisms like Fiber::Scheduler#io_read and Fiber::Scheduler#io_write and
  # parsing binary protocols.
  #
  # ## Examples of Usage
  #
  # Empty buffer:
  #
  #     buffer = IO::Buffer.new(8)  # create empty 8-byte buffer
  #     # =>
  #     # #<IO::Buffer 0x0000555f5d1a5c50+8 INTERNAL>
  #     # ...
  #     buffer
  #     # =>
  #     # <IO::Buffer 0x0000555f5d156ab0+8 INTERNAL>
  #     # 0x00000000  00 00 00 00 00 00 00 00
  #     buffer.set_string('test', 2) # put there bytes of the "test" string, starting from offset 2
  #     # => 4
  #     buffer.get_string  # get the result
  #     # => "\x00\x00test\x00\x00"
  #
  # Buffer from string:
  #
  #     string = 'data'
  #     IO::Buffer.for(string) do |buffer|
  #       buffer
  #       # =>
  #       # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #       # 0x00000000  64 61 74 61                                     data
  #
  #       buffer.get_string(2)  # read content starting from offset 2
  #       # => "ta"
  #       buffer.set_string('---', 1) # write content, starting from offset 1
  #       # => 3
  #       buffer
  #       # =>
  #       # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #       # 0x00000000  64 2d 2d 2d                                     d---
  #       string  # original string changed, too
  #       # => "d---"
  #     end
  #
  # Buffer from file:
  #
  #     File.write('test.txt', 'test data')
  #     # => 9
  #     buffer = IO::Buffer.map(File.open('test.txt'))
  #     # =>
  #     # #<IO::Buffer 0x00007f3f0768c000+9 MAPPED IMMUTABLE>
  #     # ...
  #     buffer.get_string(5, 2) # read 2 bytes, starting from offset 5
  #     # => "da"
  #     buffer.set_string('---', 1) # attempt to write
  #     # in `set_string': Buffer is not writable! (IO::Buffer::AccessError)
  #
  #     # To create writable file-mapped buffer
  #     # Open file for read-write, pass size, offset, and flags=0
  #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 9, 0, 0)
  #     buffer.set_string('---', 1)
  #     # => 3 -- bytes written
  #     File.read('test.txt')
  #     # => "t--- data"
  #
  # **The class is experimental and the interface is subject to change, this is
  # especially true of file mappings which may be removed entirely in the
  # future.**
  #
  class Buffer
    include Comparable

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.for(string) -> readonly io_buffer
    #   - IO::Buffer.for(string) {|io_buffer| ... read/write io_buffer ...}
    # -->
    # Creates a zero-copy IO::Buffer from the given string's memory. Without a block
    # a frozen internal copy of the string is created efficiently and used as the
    # buffer source. When a block is provided, the buffer is associated directly
    # with the string's internal buffer and updating the buffer will update the
    # string.
    #
    # Until #free is invoked on the buffer, either explicitly or via the garbage
    # collector, the source string will be locked and cannot be modified.
    #
    # If the string is frozen, it will create a read-only buffer which cannot be
    # modified. If the string is shared, it may trigger a copy-on-write when using
    # the block form.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(string)
    #     buffer.external? #=> true
    #
    #     buffer.get_string(0, 1)
    #     # => "t"
    #     string
    #     # => "best"
    #
    #     buffer.resize(100)
    #     # in `resize': Cannot resize external buffer! (IO::Buffer::AccessError)
    #
    #     IO::Buffer.for(string) do |buffer|
    #       buffer.set_string("T")
    #       string
    #       # => "Test"
    #     end
    #
    def self.for: (String) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.map(file, [size, [offset, [flags]]]) -> io_buffer
    # -->
    # Create an IO::Buffer for reading from `file` by memory-mapping the file.
    # `file_io` should be a `File` instance, opened for reading.
    #
    # Optional `size` and `offset` of mapping can be specified.
    #
    # By default, the buffer would be immutable (read only); to create a writable
    # mapping, you need to open a file in read-write mode, and explicitly pass
    # `flags` argument without IO::Buffer::IMMUTABLE.
    #
    #     File.write('test.txt', 'test')
    #
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     # => #<IO::Buffer 0x00000001014a0000+4 MAPPED READONLY>
    #
    #     buffer.readonly?   # => true
    #
    #     buffer.get_string
    #     # => "test"
    #
    #     buffer.set_string('b', 0)
    #     # `set_string': Buffer is not writable! (IO::Buffer::AccessError)
    #
    #     # create read/write mapping: length 4 bytes, offset 0, flags 0
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 4, 0)
    #     buffer.set_string('b', 0)
    #     # => 1
    #
    #     # Check it
    #     File.read('test.txt')
    #     # => "best"
    #
    # Note that some operating systems may not have cache coherency between mapped
    # buffers and file reads.
    #
    def self.map: (File file, ?Integer? size, ?Integer offset, ?Integer flags) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.string(length) {|io_buffer| ... read/write io_buffer ...} -> string
    # -->
    # Creates a new string of the given length and yields a zero-copy IO::Buffer
    # instance to the block which uses the string as a source. The block is expected
    # to write to the buffer and the string will be returned.
    #
    #     IO::Buffer.string(4) do |buffer|
    #       buffer.set_string("Ruby")
    #     end
    #     # => "Ruby"
    #
    def self.string: (int) { (Buffer) -> void } -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - <=>(other) -> true or false
    # -->
    # Buffers are compared by size and exact contents of the memory they are
    # referencing using `memcmp`.
    #
    def <=>: (Buffer) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - clear(value = 0, [offset, [length]]) -> self
    # -->
    # Fill buffer with `value`, starting with `offset` and going for `length` bytes.
    #
    #     buffer = IO::Buffer.for('test').dup
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 INTERNAL>
    #     #   0x00000000  74 65 73 74         test
    #
    #     buffer.clear
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 INTERNAL>
    #     #   0x00000000  00 00 00 00         ....
    #
    #     buf.clear(1) # fill with 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 INTERNAL>
    #     #   0x00000000  01 01 01 01         ....
    #
    #     buffer.clear(2, 1, 2) # fill with 2, starting from offset 1, for 2 bytes
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 INTERNAL>
    #     #   0x00000000  01 02 02 01         ....
    #
    #     buffer.clear(2, 1) # fill with 2, starting from offset 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 INTERNAL>
    #     #   0x00000000  01 02 02 02         ....
    #
    def clear: (?Integer value, ?Integer offset, ?Integer length) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - copy(source, [offset, [length, [source_offset]]]) -> size
    # -->
    # Efficiently copy from a source IO::Buffer into the buffer, at `offset` using
    # `memmove`. For copying String instances, see #set_string.
    #
    #     buffer = IO::Buffer.new(32)
    #     # =>
    #     # #<IO::Buffer 0x0000555f5ca22520+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................  *
    #
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # => 4 -- size of buffer copied
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x0000555f5cf8fe40+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 74 65 73 74 00 00 00 00 ........test....
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ *
    #
    # #copy can be used to put buffer into strings associated with buffer:
    #
    #     string = "data:    "
    #     # => "data:    "
    #     buffer = IO::Buffer.for(string) do |buffer|
    #       buffer.copy(IO::Buffer.for("test"), 5)
    #     end
    #     # => 4
    #     string
    #     # => "data:test"
    #
    # Attempt to copy into a read-only buffer will fail:
    #
    #     File.write('test.txt', 'test')
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # in `copy': Buffer is not writable! (IO::Buffer::AccessError)
    #
    # See ::map for details of creation of mutable file mappings, this will work:
    #
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'))
    #     buffer.copy(IO::Buffer.for("boom"), 0)
    #     # => 4
    #     File.read('test.txt')
    #     # => "boom"
    #
    # Attempt to copy the buffer which will need place outside of buffer's bounds
    # will fail:
    #
    #     buffer = IO::Buffer.new(2)
    #     buffer.copy(IO::Buffer.for('test'), 0)
    #     # in `copy': Specified offset+length is bigger than the buffer size! (ArgumentError)
    #
    # It is safe to copy between memory regions that overlaps each other. In such
    # case, the data is copied as if the data was first copied from the source
    # buffer to a temporary buffer, and then copied from the temporary buffer to the
    # destination buffer.
    #
    #     buffer = IO::Buffer.new(10)
    #     buffer.set_string("0123456789")
    #     buffer.copy(buffer, 3, 7)
    #     # => 7
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x000056494f8ce440+10 INTERNAL>
    #     # 0x00000000  30 31 32 30 31 32 33 34 35 36                   0120123456
    #
    def copy: (Buffer source, ?Integer offset, ?Integer length, ?Integer source_offset) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - empty? -> true or false
    # -->
    # If the buffer has 0 size: it is created by ::new with size 0, or with ::for
    # from an empty string. (Note that empty files can't be mapped, so the buffer
    # created with ::map will never be empty.)
    #
    def empty?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - external? -> true or false
    # -->
    # The buffer is *external* if it references the memory which is not allocated or
    # mapped by the buffer itself.
    #
    # A buffer created using ::for has an external reference to the string's memory.
    #
    # External buffer can't be resized.
    #
    def external?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - free -> self
    # -->
    # If the buffer references memory, release it back to the operating system.
    # *   for a *mapped* buffer (e.g. from file): unmap.
    # *   for a buffer created from scratch: free memory.
    # *   for a buffer created from string: undo the association.
    #
    # After the buffer is freed, no further operations can't be performed on it.
    #
    # You can resize a freed buffer to re-allocate it.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.free
    #     # => #<IO::Buffer 0x0000000000000000+0 NULL>
    #
    #     buffer.get_value(:U8, 0)
    #     # in `get_value': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.get_string
    #     # in `get_string': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.null?
    #     # => true
    #
    def free: () -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_string([offset, [length, [encoding]]]) -> string
    # -->
    # Read a chunk or all of the buffer into a string, in the specified `encoding`.
    # If no encoding is provided `Encoding::BINARY` is used.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.get_string
    #     # => "test"
    #     buffer.get_string(2)
    #     # => "st"
    #     buffer.get_string(2, 1)
    #     # => "s"
    #
    def get_string: (?Integer offset, ?Integer length, ?Encoding encoding) -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_value(buffer_type, offset) -> numeric
    # -->
    # Read from buffer a value of `type` at `offset`. `buffer_type` should be one of
    # symbols:
    #
    # *   `:U8`: unsigned integer, 1 byte
    # *   `:S8`: signed integer, 1 byte
    # *   `:u16`: unsigned integer, 2 bytes, little-endian
    # *   `:U16`: unsigned integer, 2 bytes, big-endian
    # *   `:s16`: signed integer, 2 bytes, little-endian
    # *   `:S16`: signed integer, 2 bytes, big-endian
    # *   `:u32`: unsigned integer, 4 bytes, little-endian
    # *   `:U32`: unsigned integer, 4 bytes, big-endian
    # *   `:s32`: signed integer, 4 bytes, little-endian
    # *   `:S32`: signed integer, 4 bytes, big-endian
    # *   `:u64`: unsigned integer, 8 bytes, little-endian
    # *   `:U64`: unsigned integer, 8 bytes, big-endian
    # *   `:s64`: signed integer, 8 bytes, little-endian
    # *   `:S64`: signed integer, 8 bytes, big-endian
    # *   `:f32`: float, 4 bytes, little-endian
    # *   `:F32`: float, 4 bytes, big-endian
    # *   `:f64`: double, 8 bytes, little-endian
    # *   `:F64`: double, 8 bytes, big-endian
    #
    # A buffer type refers specifically to the type of binary buffer that is stored
    # in the buffer. For example, a `:u32` buffer type is a 32-bit unsigned integer
    # in little-endian format.
    #
    #     string = [1.5].pack('f')
    #     # => "\x00\x00\xC0?"
    #     IO::Buffer.for(string).get_value(:f32, 0)
    #     # => 1.5
    #
    def get_value: (int_get_type, Integer offset) -> Integer
                 | (float_get_type, Integer offset) -> Float

    type int_get_type = :U8 | :S8
                      | :u16 | :U16 | :s16 | :S16
                      | :u32 | :U32 | :s32 | :S32
                      | :u64 | :U64 | :s64 | :S64

    type float_get_type = :f32 | :F32 | :f64 | :F64

    # <!--
    #   rdoc-file=io_buffer.c
    #   - hexdump([offset, [length, [width]]]) -> string
    # -->
    # Returns a human-readable string representation of the buffer. The exact format
    # is subject to change.
    #
    #     buffer = IO::Buffer.for("Hello World")
    #     puts buffer.hexdump
    #     # 0x00000000  48 65 6c 6c 6f 20 57 6f 72 6c 64                Hello World
    #
    # As buffers are usually fairly big, you may want to limit the output by
    # specifying the offset and length:
    #
    #     puts buffer.hexdump(6, 5)
    #     # 0x00000006  57 6f 72 6c 64                                  World
    #
    def hexdump: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - inspect -> string
    # -->
    # Inspect the buffer and report useful information about it's internal state.
    # Only a limited portion of the buffer will be displayed in a hexdump style
    # format.
    #
    #     buffer = IO::Buffer.for("Hello World")
    #     puts buffer.inspect
    #     # #<IO::Buffer 0x000000010198ccd8+11 EXTERNAL READONLY SLICE>
    #     # 0x00000000  48 65 6c 6c 6f 20 57 6f 72 6c 64                Hello World
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - internal? -> true or false
    # -->
    # If the buffer is *internal*, meaning it references memory allocated by the
    # buffer itself.
    #
    # An internal buffer is not associated with any external memory (e.g. string) or
    # file mapping.
    #
    # Internal buffers are created using ::new and is the default when the requested
    # size is less than the IO::Buffer::PAGE_SIZE and it was not requested to be
    # mapped on creation.
    #
    # Internal buffers can be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def internal?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked { ... }
    # -->
    # Allows to process a buffer in exclusive way, for concurrency-safety. While the
    # block is performed, the buffer is considered locked, and no other code can
    # enter the lock. Also, locked buffer can't be changed with #resize or #free.
    #
    # The following operations acquire a lock: #resize, #free.
    #
    # Locking is not thread safe. It is designed as a safety net around non-blocking
    # system calls. You can only share a buffer between threads with appropriate
    # synchronisation techniques.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.locked? #=> false
    #
    #     Fiber.schedule do
    #       buffer.locked do
    #         buffer.write(io) # theoretical system call interface
    #       end
    #     end
    #
    #     Fiber.schedule do
    #       # in `locked': Buffer already locked! (IO::Buffer::LockedError)
    #       buffer.locked do
    #         buffer.set_string("test", 0)
    #       end
    #     end
    #
    def locked: [A] () { (IO::Buffer) -> A } -> A

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked? -> true or false
    # -->
    # If the buffer is *locked*, meaning it is inside #locked block execution.
    # Locked buffer can't be resized or freed, and another lock can't be acquired on
    # it.
    #
    # Locking is not thread safe, but is a semantic used to ensure buffers don't
    # move while being used by a system call.
    #
    #     buffer.locked do
    #       buffer.write(io) # theoretical system call interface
    #     end
    #
    def locked?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - mapped? -> true or false
    # -->
    # If the buffer is *mapped*, meaning it references memory mapped by the buffer.
    #
    # Mapped buffers are either anonymous, if created by ::new with the
    # IO::Buffer::MAPPED flag or if the size was at least IO::Buffer::PAGE_SIZE, or
    # backed by a file if created with ::map.
    #
    # Mapped buffers can usually be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def mapped?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - null? -> true or false
    # -->
    # If the buffer was freed with #free, transferred with #transfer, or was never
    # allocated in the first place.
    #
    #     buffer = IO::Buffer.new(0)
    #     buffer.null? #=> true
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.null? #=> false
    #     buffer.free
    #     buffer.null? #=> true
    #
    def null?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pread(io, from, [length, [offset]]) -> read length or -errno
    # -->
    # Read at least `length` bytes from the `io` starting at the specified `from`
    # position, into the buffer starting at `offset`. If an error occurs, return
    # `-errno`.
    #
    # If `length` is not given or `nil`, it defaults to the size of the buffer minus
    # the offset, i.e. the entire buffer.
    #
    # If `length` is zero, exactly one `pread` operation will occur.
    #
    # If `offset` is not given, it defaults to zero, i.e. the beginning of the
    # buffer.
    #
    #     IO::Buffer.for('test') do |buffer|
    #       p buffer
    #       # =>
    #       # <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #       # 0x00000000  74 65 73 74         test
    #
    #       # take 2 bytes from the beginning of urandom,
    #       # put them in buffer starting from position 2
    #       buffer.pread(File.open('/dev/urandom', 'rb'), 0, 2, 2)
    #       p buffer
    #       # =>
    #       # <IO::Buffer 0x00007f3bc65f2a58+4 EXTERNAL SLICE>
    #       # 0x00000000  05 35 73 74         te.5
    #     end
    #
    def pread: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pwrite(io, from, [length, [offset]]) -> written length or -errno
    # -->
    # Write at least `length` bytes from the buffer starting at `offset`, into the
    # `io` starting at the specified `from` position. If an error occurs, return
    # `-errno`.
    #
    # If `length` is not given or `nil`, it defaults to the size of the buffer minus
    # the offset, i.e. the entire buffer.
    #
    # If `length` is zero, exactly one `pwrite` operation will occur.
    #
    # If `offset` is not given, it defaults to zero, i.e. the beginning of the
    # buffer.
    #
    # If the `from` position is beyond the end of the file, the gap will be filled
    # with null (0 value) bytes.
    #
    #     out = File.open('output.txt', File::RDWR) # open for read/write, no truncation
    #     IO::Buffer.for('1234567').pwrite(out, 2, 3, 1)
    #
    # This leads to `234` (3 bytes, starting from position 1) being written into
    # `output.txt`, starting from file position 2.
    #
    def pwrite: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - read(io, [length, [offset]]) -> read length or -errno
    # -->
    # Read at least `length` bytes from the `io`, into the buffer starting at
    # `offset`. If an error occurs, return `-errno`.
    #
    # If `length` is not given or `nil`, it defaults to the size of the buffer minus
    # the offset, i.e. the entire buffer.
    #
    # If `length` is zero, exactly one `read` operation will occur.
    #
    # If `offset` is not given, it defaults to zero, i.e. the beginning of the
    # buffer.
    #
    #     IO::Buffer.for('test') do |buffer|
    #       p buffer
    #       # =>
    #       # <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #       # 0x00000000  74 65 73 74         test
    #       buffer.read(File.open('/dev/urandom', 'rb'), 2)
    #       p buffer
    #       # =>
    #       # <IO::Buffer 0x00007f3bc65f2a58+4 EXTERNAL SLICE>
    #       # 0x00000000  05 35 73 74         .5st
    #     end
    #
    def read: (untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - readonly? -> true or false
    # -->
    # If the buffer is *read only*, meaning the buffer cannot be modified using
    # #set_value, #set_string or #copy and similar.
    #
    # Frozen strings and read-only files create read-only buffers.
    #
    def readonly?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - resize(new_size) -> self
    # -->
    # Resizes a buffer to a `new_size` bytes, preserving its content. Depending on
    # the old and new size, the memory area associated with the buffer might be
    # either extended, or rellocated at different address with content being copied.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.set_string("test", 0)
    #     buffer.resize(8) # resize to 8 bytes
    #     # =>
    #     # #<IO::Buffer 0x0000555f5d1a1630+8 INTERNAL>
    #     # 0x00000000  74 65 73 74 00 00 00 00                         test....
    #
    # External buffer (created with ::for), and locked buffer can not be resized.
    #
    def resize: (Integer) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_string(string, [offset, [length, [source_offset]]]) -> size
    # -->
    # Efficiently copy from a source String into the buffer, at `offset` using
    # `memmove`.
    #
    #     buf = IO::Buffer.new(8)
    #     # =>
    #     # #<IO::Buffer 0x0000557412714a20+8 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00                         ........
    #
    #     # set buffer starting from offset 1, take 2 bytes starting from string's
    #     # second
    #     buf.set_string('test', 1, 2, 1)
    #     # => 2
    #     buf
    #     # =>
    #     # #<IO::Buffer 0x0000557412714a20+8 INTERNAL>
    #     # 0x00000000  00 65 73 00 00 00 00 00                         .es.....
    #
    # See also #copy for examples of how buffer writing might be used for changing
    # associated strings and files.
    #
    def set_string: (*untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_value(type, offset, value) -> offset
    # -->
    # Write to a buffer a `value` of `type` at `offset`. `type` should be one of
    # symbols described in #get_value.
    #
    #     buffer = IO::Buffer.new(8)
    #     # =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00
    #
    #     buffer.set_value(:U8, 1, 111)
    #     # => 1
    #
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 6f 00 00 00 00 00 00                         .o......
    #
    # Note that if the `type` is integer and `value` is Float, the implicit
    # truncation is performed:
    #
    #     buffer = IO::Buffer.new(8)
    #     buffer.set_value(:U32, 0, 2.5)
    #
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 00 00 02 00 00 00 00
    #     #                      ^^ the same as if we'd pass just integer 2
    #
    def set_value: (int_get_type | float_get_type, Integer offset, Float | Integer value) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - size -> integer
    # -->
    # Returns the size of the buffer that was explicitly set (on creation with ::new
    # or on #resize), or deduced on buffer's creation from string or file.
    #
    def size: () -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - slice([offset, [length]]) -> io_buffer
    # -->
    # Produce another IO::Buffer which is a slice (or view into) the current one
    # starting at `offset` bytes and going for `length` bytes.
    #
    # The slicing happens without copying of memory, and the slice keeps being
    # associated with the original buffer's source (string, or file), if any.
    #
    # If the offset is not given, it will be zero. If the offset is negative, it
    # will raise an ArgumentError.
    #
    # If the length is not given, the slice will be as long as the original buffer
    # minus the specified offset. If the length is negative, it will raise an
    # ArgumentError.
    #
    # Raises RuntimeError if the `offset+length` is out of the current buffer's
    # bounds.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(string).dup
    #
    #     slice = buffer.slice
    #     # =>
    #     # #<IO::Buffer 0x0000000108338e68+4 SLICE>
    #     # 0x00000000  74 65 73 74                                     test
    #
    #     buffer.slice(2)
    #     # =>
    #     # #<IO::Buffer 0x0000000108338e6a+2 SLICE>
    #     # 0x00000000  73 74                                           st
    #
    #     slice = buffer.slice(1, 2)
    #     # =>
    #     # #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     # 0x00000000  65 73                                           es
    #
    #     # Put "o" into 0s position of the slice
    #     slice.set_string('o', 0)
    #     slice
    #     # =>
    #     # #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     # 0x00000000  6f 73                                           os
    #
    #     # it is also visible at position 1 of the original buffer
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x00007fc3d31e2d80+4 INTERNAL>
    #     # 0x00000000  74 6f 73 74                                     tost
    #
    def slice: (Integer offset, Integer length) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - to_s -> string
    # -->
    # Short representation of the buffer. It includes the address, size and symbolic
    # flags. This format is subject to change.
    #
    #     puts IO::Buffer.new(4) # uses to_s internally
    #     # #<IO::Buffer 0x000055769f41b1a0+4 INTERNAL>
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - transfer -> new_io_buffer
    # -->
    # Transfers ownership of the underlying memory to a new buffer, causing the
    # current buffer to become uninitialized.
    #
    #     buffer = IO::Buffer.new('test')
    #     other = buffer.transfer
    #     other
    #     # =>
    #     # #<IO::Buffer 0x00007f136a15f7b0+4 SLICE>
    #     # 0x00000000  74 65 73 74                                     test
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x0000000000000000+0 NULL>
    #     buffer.null?
    #     # => true
    #
    def transfer: () -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - valid? -> true or false
    # -->
    # Returns whether the buffer buffer is accessible.
    #
    # A buffer becomes invalid if it is a slice of another buffer (or string) which
    # has been freed or re-allocated at a different address.
    #
    def valid?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - write(io, [length, [offset]]) -> written length or -errno
    # -->
    # Write at least `length` bytes from the buffer starting at `offset`, into the
    # `io`. If an error occurs, return `-errno`.
    #
    # If `length` is not given or `nil`, it defaults to the size of the buffer minus
    # the offset, i.e. the entire buffer.
    #
    # If `length` is zero, exactly one `write` operation will occur.
    #
    # If `offset` is not given, it defaults to zero, i.e. the beginning of the
    # buffer.
    #
    #     out = File.open('output.txt', 'wb')
    #     IO::Buffer.for('1234567').write(out, 3)
    #
    # This leads to `123` being written into `output.txt`
    #
    def write: (untyped, untyped) -> untyped

    private

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.new([size = DEFAULT_SIZE, [flags = 0]]) -> io_buffer
    # -->
    # Create a new zero-filled IO::Buffer of `size` bytes. By default, the buffer
    # will be *internal*: directly allocated chunk of the memory. But if the
    # requested `size` is more than OS-specific IO::Buffer::PAGE_SIZE, the buffer
    # would be allocated using the virtual memory mechanism (anonymous `mmap` on
    # Unix, `VirtualAlloc` on Windows). The behavior can be forced by passing
    # IO::Buffer::MAPPED as a second parameter.
    #
    #     buffer = IO::Buffer.new(4)
    #     # =>
    #     # #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     # 0x00000000  00 00 00 00                                     ....
    #
    #     buffer.get_string(0, 1) # => "\x00"
    #
    #     buffer.set_string("test")
    #     buffer
    #     # =>
    #     # #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     # 0x00000000  74 65 73 74                                     test
    #
    def initialize: (?Integer size, ?Integer flags) -> void

    # <!-- rdoc-file=io_buffer.c -->
    # Refers to big endian byte order, where the most significant byte is stored
    # first. See #get_value for more details.
    #
    BIG_ENDIAN: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # The default buffer size, typically a (small) multiple of the PAGE_SIZE. Can be
    # explicitly specified by setting the RUBY_IO_BUFFER_DEFAULT_SIZE environment
    # variable.
    #
    DEFAULT_SIZE: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is owned by someone else. See
    # #external? for more details.
    #
    EXTERNAL: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Refers to the byte order of the host machine. See #get_value for more details.
    #
    HOST_ENDIAN: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is owned by the buffer. See #internal?
    # for more details.
    #
    INTERNAL: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Refers to little endian byte order, where the least significant byte is stored
    # first. See #get_value for more details.
    #
    LITTLE_ENDIAN: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is locked and cannot be resized or
    # freed. See #locked? and #locked for more details.
    #
    LOCKED: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is mapped by the operating system. See
    # #mapped? for more details.
    #
    MAPPED: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Refers to network byte order, which is the same as big endian. See #get_value
    # for more details.
    #
    NETWORK_ENDIAN: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # The operating system page size. Used for efficient page-aligned memory
    # allocations.
    #
    PAGE_SIZE: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is mapped privately and changes won't
    # be replicated to the underlying file. See #private? for more details.
    #
    PRIVATE: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Indicates that the memory in the buffer is read only, and attempts to modify
    # it will fail. See #readonly? for more details.
    #
    READONLY: Integer

    # <!-- rdoc-file=io_buffer.c -->
    # Raised when an operation would resize or re-allocate a locked buffer.
    #
    class LockedError < RuntimeError
    end

    # <!-- rdoc-file=io_buffer.c -->
    # Raised when the buffer cannot be allocated for some reason, or you try to use
    # a buffer that's not allocated.
    #
    class AllocationError < RuntimeError
    end

    # <!-- rdoc-file=io_buffer.c -->
    # Raised when you try to write to a read-only buffer, or resize an external
    # buffer.
    #
    class AccessError < RuntimeError
    end

    # <!-- rdoc-file=io_buffer.c -->
    # Raised if you try to access a buffer slice which no longer references a valid
    # memory range of the underlying source.
    #
    class InvalidatedError < RuntimeError
    end

    # <!-- rdoc-file=io_buffer.c -->
    # Raised if the mask given to a binary operation is invalid, e.g. zero length or
    # overlaps the target buffer.
    #
    class MaskError < ArgumentError
    end
  end
end
%a{annotate:rdoc:skip}
class IO
  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.nread -> int
  # -->
  # Returns number of bytes that can be read without blocking. Returns zero if no
  # information available.
  #
  # You must require 'io/wait' to use this method.
  #
  def nread: () -> Integer

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.ready? -> truthy or falsy
  # -->
  # Returns a truthy value if input available without blocking, or a falsy value.
  #
  # You must require 'io/wait' to use this method.
  #
  def ready?: () -> boolish

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait(events, timeout) -> event mask, false or nil
  #   - io.wait(timeout = nil, mode = :read) -> self, true, or false
  # -->
  # Waits until the IO becomes ready for the specified events and returns the
  # subset of events that become ready, or a falsy value when times out.
  #
  # The events can be a bit mask of `IO::READABLE`, `IO::WRITABLE` or
  # `IO::PRIORITY`.
  #
  # Returns a truthy value immediately when buffered data is available.
  #
  # Optional parameter `mode` is one of `:read`, `:write`, or `:read_write`.
  #
  # You must require 'io/wait' to use this method.
  #
  def wait: (Integer events, ?Time::_Timeout timeout) -> (Integer | false | nil)
          | (?Time::_Timeout? timeout, *wait_mode mode) -> (self | true | false)

  type wait_mode = :read | :r | :readable | :write | :w | :writable | :read_write | :rw | :readable_writable

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_readable          -> truthy or falsy
  #   - io.wait_readable(timeout) -> truthy or falsy
  # -->
  # Waits until IO is readable and returns a truthy value, or a falsy value when
  # times out.  Returns a truthy value immediately when buffered data is
  # available.
  #
  # You must require 'io/wait' to use this method.
  #
  def wait_readable: (?Time::_Timeout? timeout) -> boolish

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_writable          -> truthy or falsy
  #   - io.wait_writable(timeout) -> truthy or falsy
  # -->
  # Waits until IO is writable and returns a truthy value or a falsy value when
  # times out.
  #
  # You must require 'io/wait' to use this method.
  #
  def wait_writable: (?Time::_Timeout? timeout) -> boolish
end
# <!-- rdoc-file=enumerator.c -->
# A class which allows both internal and external iteration.
#
# An Enumerator can be created by the following methods.
# *   Object#to_enum
# *   Object#enum_for
# *   Enumerator.new
#
# Most methods have two forms: a block form where the contents are evaluated for
# each item in the enumeration, and a non-block form which returns a new
# Enumerator wrapping the iteration.
#
#     enumerator = %w(one two three).each
#     puts enumerator.class # => Enumerator
#
#     enumerator.each_with_object("foo") do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
#     enum_with_obj = enumerator.each_with_object("foo")
#     puts enum_with_obj.class # => Enumerator
#
#     enum_with_obj.each do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
# This allows you to chain Enumerators together.  For example, you can map a
# list's elements to strings containing the index and the element as a string
# via:
#
#     puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
#     # => ["0:foo", "1:bar", "2:baz"]
#
# ## External Iteration
#
# An Enumerator can also be used as an external iterator. For example,
# Enumerator#next returns the next value of the iterator or raises StopIteration
# if the Enumerator is at the end.
#
#     e = [1,2,3].each   # returns an enumerator object.
#     puts e.next   # => 1
#     puts e.next   # => 2
#     puts e.next   # => 3
#     puts e.next   # raises StopIteration
#
# `next`, `next_values`, `peek`, and `peek_values` are the only methods which
# use external iteration (and Array#zip(Enumerable-not-Array) which uses `next`
# internally).
#
# These methods do not affect other internal enumeration methods, unless the
# underlying iteration method itself has side-effect, e.g. IO#each_line.
#
# FrozenError will be raised if these methods are called against a frozen
# enumerator. Since `rewind` and `feed` also change state for external
# iteration, these methods may raise FrozenError too.
#
# External iteration differs **significantly** from internal iteration due to
# using a Fiber:
# *   The Fiber adds some overhead compared to internal enumeration.
# *   The stacktrace will only include the stack from the Enumerator, not above.
# *   Fiber-local variables are **not** inherited inside the Enumerator Fiber,
#     which instead starts with no Fiber-local variables.
# *   Fiber storage variables **are** inherited and are designed to handle
#     Enumerator Fibers. Assigning to a Fiber storage variable only affects the
#     current Fiber, so if you want to change state in the caller Fiber of the
#     Enumerator Fiber, you need to use an extra indirection (e.g., use some
#     object in the Fiber storage variable and mutate some ivar of it).
#
# Concretely:
#
#     Thread.current[:fiber_local] = 1
#     Fiber[:storage_var] = 1
#     e = Enumerator.new do |y|
#       p Thread.current[:fiber_local] # for external iteration: nil, for internal iteration: 1
#       p Fiber[:storage_var] # => 1, inherited
#       Fiber[:storage_var] += 1
#       y << 42
#     end
#
#     p e.next # => 42
#     p Fiber[:storage_var] # => 1 (it ran in a different Fiber)
#
#     e.each { p _1 }
#     p Fiber[:storage_var] # => 2 (it ran in the same Fiber/"stack" as the current Fiber)
#
# ## Convert External Iteration to Internal Iteration
#
# You can use an external iterator to implement an internal iterator as follows:
#
#     def ext_each(e)
#       while true
#         begin
#           vs = e.next_values
#         rescue StopIteration
#           return $!.result
#         end
#         y = yield(*vs)
#         e.feed y
#       end
#     end
#
#     o = Object.new
#
#     def o.each
#       puts yield
#       puts yield(1)
#       puts yield(1, 2)
#       3
#     end
#
#     # use o.each as an internal iterator directly.
#     puts o.each {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
#     # convert o.each to an external iterator for
#     # implementing an internal iterator.
#     puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
class Enumerator[unchecked out Elem, out Return = void] < Object
  include Enumerable[Elem]

  # A convenience interface for `each` with optional block
  #
  interface _Each[out E, out R]
    def each: () { (E) -> void } -> R
            | () -> Enumerator[E, R]
  end

  # <!--
  #   rdoc-file=enumerator.c
  #   - Enumerator.produce(initial = nil) { |prev| block } -> enumerator
  # -->
  # Creates an infinite enumerator from any block, just called over and over.  The
  # result of the previous iteration is passed to the next one. If `initial` is
  # provided, it is passed to the first iteration, and becomes the first element
  # of the enumerator; if it is not provided, the first iteration receives `nil`,
  # and its result becomes the first element of the iterator.
  #
  # Raising StopIteration from the block stops an iteration.
  #
  #     Enumerator.produce(1, &:succ)   # => enumerator of 1, 2, 3, 4, ....
  #
  #     Enumerator.produce { rand(10) } # => infinite random number sequence
  #
  #     ancestors = Enumerator.produce(node) { |prev| node = prev.parent or raise StopIteration }
  #     enclosing_section = ancestors.find { |n| n.type == :section }
  #
  # Using ::produce together with Enumerable methods like Enumerable#detect,
  # Enumerable#slice_after, Enumerable#take_while can provide Enumerator-based
  # alternatives for `while` and `until` cycles:
  #
  #     # Find next Tuesday
  #     require "date"
  #     Enumerator.produce(Date.today, &:succ).detect(&:tuesday?)
  #
  #     # Simple lexer:
  #     require "strscan"
  #     scanner = StringScanner.new("7+38/6")
  #     PATTERN = %r{\d+|[-/+*]}
  #     Enumerator.produce { scanner.scan(PATTERN) }.slice_after { scanner.eos? }.first
  #     # => ["7", "+", "38", "/", "6"]
  #
  def self.produce: [T] () { (T? prev) -> T } -> Enumerator[T, bot]
                  | [T] (T initial) { (T prev) -> T } -> Enumerator[T, bot]

  # <!--
  #   rdoc-file=enumerator.c
  #   - Enumerator.product(*enums) -> enumerator
  #   - Enumerator.product(*enums) { |elts| ... } -> enumerator
  # -->
  # Generates a new enumerator object that generates a Cartesian product of given
  # enumerable objects.  This is equivalent to Enumerator::Product.new.
  #
  #     e = Enumerator.product(1..3, [4, 5])
  #     e.to_a #=> [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
  #     e.size #=> 6
  #
  # When a block is given, calls the block with each N-element array generated and
  # returns `nil`.
  #
  def self.product: [Elem] (*_EachEntry[Elem]) -> Product[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - enum.each { |elm| block }                    -> obj
  #   - enum.each                                    -> enum
  #   - enum.each(*appending_args) { |elm| block }   -> obj
  #   - enum.each(*appending_args)                   -> an_enumerator
  # -->
  # Iterates over the block according to how this Enumerator was constructed. If
  # no block and no arguments are given, returns self.
  #
  # ### Examples
  #
  #     "Hello, world!".scan(/\w+/)                     #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan, /\w+/).to_a      #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan).each(/\w+/).to_a #=> ["Hello", "world"]
  #
  #     obj = Object.new
  #
  #     def obj.each_arg(a, b=:b, *rest)
  #       yield a
  #       yield b
  #       yield rest
  #       :method_returned
  #     end
  #
  #     enum = obj.to_enum :each_arg, :a, :x
  #
  #     enum.each.to_a                  #=> [:a, :x, []]
  #     enum.each.equal?(enum)          #=> true
  #     enum.each { |elm| elm }         #=> :method_returned
  #
  #     enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]
  #     enum.each(:y, :z).equal?(enum)  #=> false
  #     enum.each(:y, :z) { |elm| elm } #=> :method_returned
  #
  def each: () { (Elem arg0) -> untyped } -> Return
          | () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.feed obj   -> nil
  # -->
  # Sets the value to be returned by the next yield inside `e`.
  #
  # If the value is not set, the yield returns nil.
  #
  # This value is cleared after being yielded.
  #
  #     # Array#map passes the array's elements to "yield" and collects the
  #     # results of "yield" as an array.
  #     # Following example shows that "next" returns the passed elements and
  #     # values passed to "feed" are collected as an array which can be
  #     # obtained by StopIteration#result.
  #     e = [1,2,3].map
  #     p e.next           #=> 1
  #     e.feed "a"
  #     p e.next           #=> 2
  #     e.feed "b"
  #     p e.next           #=> 3
  #     e.feed "c"
  #     begin
  #       e.next
  #     rescue StopIteration
  #       p $!.result      #=> ["a", "b", "c"]
  #     end
  #
  #     o = Object.new
  #     def o.each
  #       x = yield         # (2) blocks
  #       p x               # (5) => "foo"
  #       x = yield         # (6) blocks
  #       p x               # (8) => nil
  #       x = yield         # (9) blocks
  #       p x               # not reached w/o another e.next
  #     end
  #
  #     e = o.to_enum
  #     e.next              # (1)
  #     e.feed "foo"        # (3)
  #     e.next              # (4)
  #     e.next              # (7)
  #                         # (10)
  #
  def feed: (Elem arg0) -> NilClass

  # <!--
  #   rdoc-file=enumerator.c
  #   - Enumerator.new(size = nil) { |yielder| ... }
  # -->
  # Creates a new Enumerator object, which can be used as an Enumerable.
  #
  # Iteration is defined by the given block, in which a "yielder" object, given as
  # block parameter, can be used to yield a value by calling the `yield` method
  # (aliased as `<<`):
  #
  #     fib = Enumerator.new do |y|
  #       a = b = 1
  #       loop do
  #         y << a
  #         a, b = b, a + b
  #       end
  #     end
  #
  #     fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
  #
  # The optional parameter can be used to specify how to calculate the size in a
  # lazy fashion (see Enumerator#size). It can either be a value or a callable
  # object.
  #
  def initialize: (?Integer arg0) { (Enumerator::Yielder arg0) -> Return } -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.inspect  -> string
  # -->
  # Creates a printable version of *e*.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next   -> object
  # -->
  # Returns the next object in the enumerator, and move the internal position
  # forward.  When the position reached at the end, StopIteration is raised.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.next   #raises StopIteration
  #
  # See class-level notes about external iterators.
  #
  def next: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next_values   -> array
  # -->
  # Returns the next object as an array in the enumerator, and move the internal
  # position forward.  When the position reached at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # This method can be used to distinguish `yield` and `yield nil`.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #       yield nil
  #       yield [1, 2]
  #     end
  #     e = o.to_enum
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     e = o.to_enum
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #
  #     ## yield args       next_values      next
  #     #  yield            []               nil
  #     #  yield 1          [1]              1
  #     #  yield 1, 2       [1, 2]           [1, 2]
  #     #  yield nil        [nil]            nil
  #     #  yield [1, 2]     [[1, 2]]         [1, 2]
  #
  def next_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek   -> object
  # -->
  # Returns the next object in the enumerator, but doesn't move the internal
  # position forward.  If the position is already at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.peek   #raises StopIteration
  #
  def peek: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek_values   -> array
  # -->
  # Returns the next object as an array, similar to Enumerator#next_values, but
  # doesn't move the internal position forward.  If the position is already at the
  # end, StopIteration is raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #     end
  #     e = o.to_enum
  #     p e.peek_values    #=> []
  #     e.next
  #     p e.peek_values    #=> [1]
  #     p e.peek_values    #=> [1]
  #     e.next
  #     p e.peek_values    #=> [1, 2]
  #     e.next
  #     p e.peek_values    # raises StopIteration
  #
  def peek_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.rewind   -> e
  # -->
  # Rewinds the enumeration sequence to the beginning.
  #
  # If the enclosed object responds to a "rewind" method, it is called.
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.size          -> int, Float::INFINITY or nil
  # -->
  # Returns the size of the enumerator, or `nil` if it can't be calculated lazily.
  #
  #     (1..100).to_a.permutation(4).size # => 94109400
  #     loop.size # => Float::INFINITY
  #     (1..100).drop_while.size # => nil
  #
  def size: () -> (Integer | Float)?

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.with_index(offset = 0) {|(*args), idx| ... }
  #   - e.with_index(offset = 0)
  # -->
  # Iterates the given block for each element with an index, which starts from
  # `offset`.  If no block is given, returns a new Enumerator that includes the
  # index, starting from `offset`
  #
  # `offset`
  # :   the starting index to use
  #
  def with_index: (?Integer offset) { (Elem arg0, Integer arg1) -> untyped } -> Return
                | (?Integer offset) -> ::Enumerator[[ Elem, Integer ], Return]

  # <!-- rdoc-file=enumerator.c -->
  # Iterates the given block for each element with an arbitrary object, `obj`, and
  # returns `obj`
  #
  # If no block is given, returns a new Enumerator.
  #
  # ### Example
  #
  #     to_three = Enumerator.new do |y|
  #       3.times do |x|
  #         y << x
  #       end
  #     end
  #
  #     to_three_with_string = to_three.with_object("foo")
  #     to_three_with_string.each do |x,string|
  #       puts "#{string}: #{x}"
  #     end
  #
  #     # => foo: 0
  #     # => foo: 1
  #     # => foo: 2
  #
  def with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                 | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]
end

# <!-- rdoc-file=enumerator.c -->
# Generator
#
class Enumerator::Generator[out Elem] < Object
  include Enumerable[Elem]

  def each: () { (Elem) -> void } -> void
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Lazy is a special type of Enumerator, that allows constructing
# chains of operations without evaluating them immediately, and evaluating
# values on as-needed basis. In order to do so it redefines most of Enumerable
# methods so that they just construct another lazy enumerator.
#
# Enumerator::Lazy can be constructed from any Enumerable with the
# Enumerable#lazy method.
#
#     lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
#     # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>
#
# The real enumeration is performed when any non-redefined Enumerable method is
# called, like Enumerable#first or Enumerable#to_a (the latter is aliased as
# #force for more semantic code):
#
#     lazy.first(2)
#     #=> [21, 23]
#
#     lazy.force
#     #=> [21, 23, 25, 27, 29]
#
# Note that most Enumerable methods that could be called with or without a
# block, on Enumerator::Lazy will always require a block:
#
#     [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
#     [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block
#
# This class allows idiomatic calculations on long or infinite sequences, as
# well as chaining of calculations without constructing intermediate arrays.
#
# Example for working with a slowly calculated sequence:
#
#     require 'open-uri'
#
#     # This will fetch all URLs before selecting
#     # necessary data
#     URLS.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
#     # This will fetch URLs one-by-one, only till
#     # there is enough data to satisfy the condition
#     URLS.lazy.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
# Ending a chain with ".eager" generates a non-lazy enumerator, which is
# suitable for returning or passing to another method that expects a normal
# enumerator.
#
#     def active_items
#       groups
#         .lazy
#         .flat_map(&:items)
#         .reject(&:disabled)
#         .eager
#     end
#
#     # This works lazily; if a checked item is found, it stops
#     # iteration and does not look into remaining groups.
#     first_checked = active_items.find(&:checked)
#
#     # This returns an array of items like a normal enumerator does.
#     all_checked = active_items.select(&:checked)
#
class Enumerator::Lazy[out Elem, out Return = void] < Enumerator[Elem, Return]
  # <!-- rdoc-file=enumerator.c -->
  # Expands `lazy` enumerator to an array. See Enumerable#to_a.
  #
  alias force to_a

  # <!--
  #   rdoc-file=enumerator.c
  #   - lazy.compact                  -> lazy_enumerator
  # -->
  # Like Enumerable#compact, but chains operation to be lazy-evaluated.
  #
  def compact: () -> Enumerator::Lazy[Elem, Return]
end

# <!-- rdoc-file=enumerator.c -->
# Yielder
#
class Enumerator::Yielder < Object
  def <<: (untyped arg0) -> void

  def yield: (*untyped arg0) -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - to_proc()
  # -->
  # Returns a Proc object that takes arguments and yields them.
  #
  # This method is implemented so that a Yielder object can be directly passed to
  # another method as a block argument.
  #
  #     enum = Enumerator.new { |y|
  #       Dir.glob("*.rb") { |file|
  #         File.open(file) { |f| f.each_line(&y) }
  #       }
  #     }
  #
  def to_proc: () -> Proc
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Chain is a subclass of Enumerator, which represents a chain of
# enumerables that works as a single enumerator.
#
# This type of objects can be created by Enumerable#chain and Enumerator#+.
#
class Enumerator::Chain[out Elem] < Enumerator[Elem, void]
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - obj.each(*args) { |...| ... } -> obj
  #   - obj.each(*args) -> enumerator
  # -->
  # Iterates over the elements of the first enumerable by calling the "each"
  # method on it with the given arguments, then proceeds to the following
  # enumerables in sequence until all of the enumerables are exhausted.
  #
  # If no block is given, returns an enumerator.
  #
  def each: () { (Elem) -> void } -> void
end
# <!-- rdoc-file=vm.c -->
# The RubyVM module only exists on MRI. `RubyVM` is not defined in other Ruby
# implementations such as JRuby and TruffleRuby.
#
# The RubyVM module provides some access to MRI internals. This module is for
# very limited purposes, such as debugging, prototyping, and research.  Normal
# users must not use it. This module is not portable between Ruby
# implementations.
#
class RubyVM < Object
end

# <!-- rdoc-file=vm.c -->
# ::RubyVM::DEFAULT_PARAMS This constant exposes the VM's default parameters.
# Note that changing these values does not affect VM execution. Specification is
# not stable and you should not depend on this value. Of course, this constant
# is MRI specific.
#
RubyVM::DEFAULT_PARAMS: Hash[Symbol, Integer]

# <!-- rdoc-file=vm.c -->
# ::RubyVM::INSTRUCTION_NAMES A list of bytecode instruction names in MRI. This
# constant is MRI specific.
#
RubyVM::INSTRUCTION_NAMES: Array[String]

# <!-- rdoc-file=vm.c -->
# ::RubyVM::OPTS An Array of VM build options. This constant is MRI specific.
#
RubyVM::OPTS: Array[String]

# <!-- rdoc-file=iseq.c -->
# The InstructionSequence class represents a compiled sequence of instructions
# for the Virtual Machine used in MRI. Not all implementations of Ruby may
# implement this class, and for the implementations that implement it, the
# methods defined and behavior of the methods can change in any version.
#
# With it, you can get a handle to the instructions that make up a method or a
# proc, compile strings of Ruby code down to VM instructions, and disassemble
# instruction sequences to strings for easy inspection. It is mostly useful if
# you want to learn how YARV works, but it also lets you control various
# settings for the Ruby iseq compiler.
#
# You can find the source for the VM instructions in `insns.def` in the Ruby
# source.
#
# The instruction sequence results will almost certainly change as Ruby changes,
# so example output in this documentation may be different from what you see.
#
# Of course, this class is MRI specific.
#
class RubyVM::InstructionSequence < Object
  # <!--
  #   rdoc-file=iseq.c
  #   - absolute_path()
  # -->
  # Returns the absolute path of this instruction sequence.
  #
  # `nil` if the iseq was evaluated from a string.
  #
  # For example, using ::compile_file:
  #
  #     # /tmp/method.rb
  #     def hello
  #       puts "hello, world"
  #     end
  #
  #     # in irb
  #     > iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
  #     > iseq.absolute_path #=> /tmp/method.rb
  #
  def absolute_path: () -> String?

  # <!--
  #   rdoc-file=iseq.c
  #   - base_label()
  # -->
  # Returns the base label of this instruction sequence.
  #
  # For example, using irb:
  #
  #     iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
  #     #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>
  #     iseq.base_label
  #     #=> "<compiled>"
  #
  # Using ::compile_file:
  #
  #     # /tmp/method.rb
  #     def hello
  #       puts "hello, world"
  #     end
  #
  #     # in irb
  #     > iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
  #     > iseq.base_label #=> <main>
  #
  def base_label: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.disasm -> str
  #   - iseq.disassemble -> str
  # -->
  # Returns the instruction sequence as a `String` in human readable form.
  #
  #     puts RubyVM::InstructionSequence.compile('1 + 2').disasm
  #
  # Produces:
  #
  #     == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========
  #     0000 trace            1                                               (   1)
  #     0002 putobject        1
  #     0004 putobject        2
  #     0006 opt_plus         <ic:1>
  #     0008 leave
  #
  def disasm: () -> String

  # <!-- rdoc-file=iseq.c -->
  # Returns the instruction sequence as a `String` in human readable form.
  #
  #     puts RubyVM::InstructionSequence.compile('1 + 2').disasm
  #
  # Produces:
  #
  #     == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========
  #     0000 trace            1                                               (   1)
  #     0002 putobject        1
  #     0004 putobject        2
  #     0006 opt_plus         <ic:1>
  #     0008 leave
  #
  def disassemble: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.each_child{|child_iseq| ...} -> iseq
  # -->
  # Iterate all direct child instruction sequences. Iteration order is
  # implementation/version defined so that people should not rely on the order.
  #
  def each_child: () -> RubyVM::InstructionSequence

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.eval -> obj
  # -->
  # Evaluates the instruction sequence and returns the result.
  #
  #     RubyVM::InstructionSequence.compile("1 + 2").eval #=> 3
  #
  def eval: () -> untyped

  # <!--
  #   rdoc-file=iseq.c
  #   - first_lineno()
  # -->
  # Returns the number of the first source line where the instruction sequence was
  # loaded from.
  #
  # For example, using irb:
  #
  #     iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
  #     #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>
  #     iseq.first_lineno
  #     #=> 1
  #
  def first_lineno: () -> Integer

  # <!--
  #   rdoc-file=iseq.c
  #   - inspect()
  # -->
  # Returns a human-readable string representation of this instruction sequence,
  # including the #label and #path.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - label()
  # -->
  # Returns the label of this instruction sequence.
  #
  # `<main>` if it's at the top level, `<compiled>` if it was evaluated from a
  # string.
  #
  # For example, using irb:
  #
  #     iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
  #     #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>
  #     iseq.label
  #     #=> "<compiled>"
  #
  # Using ::compile_file:
  #
  #     # /tmp/method.rb
  #     def hello
  #       puts "hello, world"
  #     end
  #
  #     # in irb
  #     > iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
  #     > iseq.label #=> <main>
  #
  def label: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - path()
  # -->
  # Returns the path of this instruction sequence.
  #
  # `<compiled>` if the iseq was evaluated from a string.
  #
  # For example, using irb:
  #
  #     iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
  #     #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>
  #     iseq.path
  #     #=> "<compiled>"
  #
  # Using ::compile_file:
  #
  #     # /tmp/method.rb
  #     def hello
  #       puts "hello, world"
  #     end
  #
  #     # in irb
  #     > iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
  #     > iseq.path #=> /tmp/method.rb
  #
  def path: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.script_lines -> array or nil
  # -->
  # It returns recorded script lines if it is available. The script lines are not
  # limited to the iseq range, but are entire lines of the source file.
  #
  # Note that this is an API for ruby internal use, debugging, and research. Do
  # not use this for any other purpose. The compatibility is not guaranteed.
  #
  def script_lines: () -> Array[String]?

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.to_a -> ary
  # -->
  # Returns an Array with 14 elements representing the instruction sequence with
  # the following data:
  #
  # magic
  # :   A string identifying the data format. **Always
  #     `YARVInstructionSequence/SimpleDataFormat`.**
  #
  #
  # major_version
  # :   The major version of the instruction sequence.
  #
  #
  # minor_version
  # :   The minor version of the instruction sequence.
  #
  #
  # format_type
  # :   A number identifying the data format. **Always 1**.
  #
  #
  # misc
  # :   A hash containing:
  #
  #     `:arg_size`
  # :       the total number of arguments taken by the method or the block (0 if
  #         *iseq* doesn't represent a method or block)
  #
  #     `:local_size`
  # :       the number of local variables + 1
  #
  #     `:stack_max`
  # :       used in calculating the stack depth at which a SystemStackError is
  #         thrown.
  #
  #
  #
  # #label
  # :   The name of the context (block, method, class, module, etc.) that this
  #     instruction sequence belongs to.
  #
  #     `<main>` if it's at the top level, `<compiled>` if it was evaluated from a
  #     string.
  #
  #
  # #path
  # :   The relative path to the Ruby file where the instruction sequence was
  #     loaded from.
  #
  #     `<compiled>` if the iseq was evaluated from a string.
  #
  #
  # #absolute_path
  # :   The absolute path to the Ruby file where the instruction sequence was
  #     loaded from.
  #
  #     `nil` if the iseq was evaluated from a string.
  #
  #
  # #first_lineno
  # :   The number of the first source line where the instruction sequence was
  #     loaded from.
  #
  #
  # type
  # :   The type of the instruction sequence.
  #
  #     Valid values are `:top`, `:method`, `:block`, `:class`, `:rescue`,
  #     `:ensure`, `:eval`, `:main`, and `plain`.
  #
  #
  # locals
  # :   An array containing the names of all arguments and local variables as
  #     symbols.
  #
  #
  # params
  # :   An Hash object containing parameter information.
  #
  #     More info about these values can be found in `vm_core.h`.
  #
  #
  # catch_table
  # :   A list of exceptions and control flow operators (rescue, next, redo,
  #     break, etc.).
  #
  #
  # bytecode
  # :   An array of arrays containing the instruction names and operands that make
  #     up the body of the instruction sequence.
  #
  #
  # Note that this format is MRI specific and version dependent.
  #
  def to_a: () -> Array[untyped]

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.to_binary(extra_data = nil) -> binary str
  # -->
  # Returns serialized iseq binary format data as a String object. A corresponding
  # iseq object is created by RubyVM::InstructionSequence.load_from_binary()
  # method.
  #
  # String extra_data will be saved with binary data. You can access this data
  # with RubyVM::InstructionSequence.load_from_binary_extra_data(binary).
  #
  # Note that the translated binary data is not portable. You can not move this
  # binary data to another machine. You can not use the binary data which is
  # created by another version/another architecture of Ruby.
  #
  def to_binary: () -> String

  # <!--
  #   rdoc-file=iseq.c
  #   - iseq.trace_points -> ary
  # -->
  # Return trace points in the instruction sequence. Return an array of [line,
  # event_symbol] pair.
  #
  def trace_points: () -> Array[untyped]
end

# <!-- rdoc-file=ast.rb -->
# AbstractSyntaxTree provides methods to parse Ruby code into abstract syntax
# trees. The nodes in the tree are instances of
# RubyVM::AbstractSyntaxTree::Node.
#
# This module is MRI specific as it exposes implementation details of the MRI
# abstract syntax tree.
#
# This module is experimental and its API is not stable, therefore it might
# change without notice. As examples, the order of children nodes is not
# guaranteed, the number of children nodes might change, there is no way to
# access children nodes by name, etc.
#
# If you are looking for a stable API or an API working under multiple Ruby
# implementations, consider using the *prism* gem, which is the official Ruby
# API to parse Ruby code.
#
module RubyVM::AbstractSyntaxTree
  # <!--
  #   rdoc-file=ast.rb
  #   - RubyVM::AbstractSyntaxTree.parse(string, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node
  # -->
  # Parses the given *string* into an abstract syntax tree, returning the root
  # node of that tree.
  #
  #     RubyVM::AbstractSyntaxTree.parse("x = 1 + 2")
  #     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-1:9>
  #
  # If `keep_script_lines: true` option is provided, the text of the parsed source
  # is associated with nodes and is available via Node#script_lines.
  #
  # If `keep_tokens: true` option is provided, Node#tokens are populated.
  #
  # SyntaxError is raised if the given *string* is invalid syntax. To overwrite
  # this behavior, `error_tolerant: true` can be provided. In this case, the
  # parser will produce a tree where expressions with syntax errors would be
  # represented by Node with `type=:ERROR`.
  #
  #     root = RubyVM::AbstractSyntaxTree.parse("x = 1; p(x; y=2")
  #     # <internal:ast>:33:in `parse': syntax error, unexpected ';', expecting ')' (SyntaxError)
  #     # x = 1; p(x; y=2
  #     #           ^
  #
  #     root = RubyVM::AbstractSyntaxTree.parse("x = 1; p(x; y=2", error_tolerant: true)
  #     # (SCOPE@1:0-1:15
  #     #  tbl: [:x, :y]
  #     #  args: nil
  #     #  body: (BLOCK@1:0-1:15 (LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)) (ERROR@1:7-1:11) (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2))))
  #     root.children.last.children
  #     # [(LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)),
  #     #  (ERROR@1:7-1:11),
  #     #  (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2))]
  #
  # Note that parsing continues even after the errored expression.
  #
  def self.parse: (String string, ?keep_script_lines: bool, ?error_tolerant: bool, ?keep_tokens: bool) -> Node

  # <!--
  #   rdoc-file=ast.rb
  #   - RubyVM::AbstractSyntaxTree.parse_file(pathname, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node
  # -->
  # Reads the file from *pathname*, then parses it like ::parse, returning the
  # root node of the abstract syntax tree.
  #
  # SyntaxError is raised if *pathname*'s contents are not valid Ruby syntax.
  #
  #     RubyVM::AbstractSyntaxTree.parse_file("my-app/app.rb")
  #     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-31:3>
  #
  # See ::parse for explanation of keyword argument meaning and usage.
  #
  def self.parse_file: (String | ::_ToPath string, ?keep_script_lines: bool, ?error_tolerant: bool, ?keep_tokens: bool) -> Node

  # <!--
  #   rdoc-file=ast.rb
  #   - RubyVM::AbstractSyntaxTree.of(proc, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false)   -> RubyVM::AbstractSyntaxTree::Node
  #   - RubyVM::AbstractSyntaxTree.of(method, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node
  # -->
  # Returns AST nodes of the given *proc* or *method*.
  #
  #     RubyVM::AbstractSyntaxTree.of(proc {1 + 2})
  #     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:35-1:42>
  #
  #     def hello
  #       puts "hello, world"
  #     end
  #
  #     RubyVM::AbstractSyntaxTree.of(method(:hello))
  #     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-3:3>
  #
  # See ::parse for explanation of keyword argument meaning and usage.
  #
  def self.of: (Proc | Method | UnboundMethod body, ?keep_script_lines: bool, ?error_tolerant: bool, ?keep_tokens: bool) -> Node?

  # <!--
  #   rdoc-file=ast.rb
  #   - RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(backtrace_location)   -> integer
  # -->
  # Returns the node id for the given backtrace location.
  #
  #     begin
  #       raise
  #     rescue =>  e
  #       loc = e.backtrace_locations.first
  #       RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(loc)
  #     end # => 0
  #
  def self.node_id_for_backtrace_location: (Thread::Backtrace::Location backtrace_location) -> Integer

  # <!-- rdoc-file=ast.rb -->
  # RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in
  # RubyVM::AbstractSyntaxTree.
  #
  # This class is MRI specific.
  #
  class Node
    # <!--
    #   rdoc-file=ast.rb
    #   - node.type -> symbol
    # -->
    # Returns the type of this node as a symbol.
    #
    #     root = RubyVM::AbstractSyntaxTree.parse("x = 1 + 2")
    #     root.type # => :SCOPE
    #     lasgn = root.children[2]
    #     lasgn.type # => :LASGN
    #     call = lasgn.children[1]
    #     call.type # => :OPCALL
    #
    def type: () -> Symbol

    # <!--
    #   rdoc-file=ast.rb
    #   - node.first_lineno -> integer
    # -->
    # The line number in the source code where this AST's text began.
    #
    def first_lineno: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - node.first_column -> integer
    # -->
    # The column number in the source code where this AST's text began.
    #
    def first_column: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - node.last_lineno -> integer
    # -->
    # The line number in the source code where this AST's text ended.
    #
    def last_lineno: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - node.last_column -> integer
    # -->
    # The column number in the source code where this AST's text ended.
    #
    def last_column: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - node.locations -> array
    # -->
    # Returns location objects associated with the AST node. The returned array
    # contains RubyVM::AbstractSyntaxTree::Location.
    #
    def locations: () -> Array[Location]

    # <!--
    #   rdoc-file=ast.rb
    #   - node.tokens -> array
    # -->
    # Returns tokens corresponding to the location of the node. Returns `nil` if
    # `keep_tokens` is not enabled when #parse method is called.
    #
    #     root = RubyVM::AbstractSyntaxTree.parse("x = 1 + 2", keep_tokens: true)
    #     root.tokens # => [[0, :tIDENTIFIER, "x", [1, 0, 1, 1]], [1, :tSP, " ", [1, 1, 1, 2]], ...]
    #     root.tokens.map{_1[2]}.join # => "x = 1 + 2"
    #
    # Token is an array of:
    #
    # *   id
    # *   token type
    # *   source code text
    # *   location [ first_lineno, first_column, last_lineno, last_column ]
    #
    def tokens: () -> Array[[Integer, Symbol, String, [Integer, Integer, Integer, Integer]]]?

    # <!--
    #   rdoc-file=ast.rb
    #   - node.all_tokens -> array
    # -->
    # Returns all tokens for the input script regardless the receiver node. Returns
    # `nil` if `keep_tokens` is not enabled when #parse method is called.
    #
    #     root = RubyVM::AbstractSyntaxTree.parse("x = 1 + 2", keep_tokens: true)
    #     root.all_tokens # => [[0, :tIDENTIFIER, "x", [1, 0, 1, 1]], [1, :tSP, " ", [1, 1, 1, 2]], ...]
    #     root.children[-1].all_tokens # => [[0, :tIDENTIFIER, "x", [1, 0, 1, 1]], [1, :tSP, " ", [1, 1, 1, 2]], ...]
    #
    def all_tokens: () -> Array[[Integer, Symbol, String, [Integer, Integer, Integer, Integer]]]?

    # <!--
    #   rdoc-file=ast.rb
    #   - node.children -> array
    # -->
    # Returns AST nodes under this one.  Each kind of node has different children,
    # depending on what kind of node it is.
    #
    # The returned array may contain other nodes or `nil`.
    #
    def children: () -> Array[untyped]
  end

  # <!-- rdoc-file=ast.rb -->
  # RubyVM::AbstractSyntaxTree::Location instances are created by
  # RubyVM::AbstractSyntaxTree::Node#locations.
  #
  # This class is MRI specific.
  #
  class Location
    # <!--
    #   rdoc-file=ast.rb
    #   - location.first_column -> integer
    # -->
    # The column number in the source code where this AST's text began.
    #
    def first_column: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - location.first_lineno -> integer
    # -->
    # The line number in the source code where this AST's text began.
    #
    def first_lineno: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - location.inspect -> string
    # -->
    # Returns debugging information about this location as a string.
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=ast.rb
    #   - location.last_lineno -> integer
    # -->
    # The line number in the source code where this AST's text ended.
    #
    def last_lineno: () -> Integer

    # <!--
    #   rdoc-file=ast.rb
    #   - location.last_column -> integer
    # -->
    # The column number in the source code where this AST's text ended.
    #
    def last_column: () -> Integer
  end
end

# <!-- rdoc-file=yjit.rb -->
# This module allows for introspection of YJIT, CRuby's just-in-time compiler.
# Everything in the module is highly implementation specific and the API might
# be less stable compared to the standard library.
# This module may not exist if YJIT does not support the particular platform
# for which CRuby is built.
#
module RubyVM::YJIT
  # <!--
  #   rdoc-file=yjit.rb
  #   - code_gc()
  # -->
  # Discard existing compiled code to reclaim memory
  # and allow for recompilations in the future.
  #
  def self.code_gc: () -> void

  # <!--
  #   rdoc-file=yjit.rb
  #   - dump_exit_locations(filename)
  # -->
  # Marshal dumps exit locations to the given filename.
  # Usage:
  # If `--yjit-exit-locations` is passed, a file named
  # "yjit_exit_locations.dump" will automatically be generated.
  # If you want to collect traces manually, call `dump_exit_locations`
  # directly.
  # Note that calling this in a script will generate stats after the
  # dump is created, so the stats data may include exits from the
  # dump itself.
  # In a script call:
  #     at_exit do
  #       RubyVM::YJIT.dump_exit_locations("my_file.dump")
  #     end
  #
  # Then run the file with the following options:
  #     ruby --yjit --yjit-trace-exits test.rb
  #
  # Once the code is done running, use Stackprof to read the dump file.
  # See Stackprof documentation for options.
  #
  def self.dump_exit_locations: (untyped filename) -> void

  # <!--
  #   rdoc-file=yjit.rb
  #   - enable(stats: false, log: false)
  # -->
  # Enable YJIT compilation. `stats` option decides whether to enable YJIT stats
  # or not. `compilation_log` decides
  # whether to enable YJIT compilation logging or not.
  # `stats`:
  # * `false`: Don't enable stats.
  # * `true`: Enable stats. Print stats at exit.
  # * `:quiet`: Enable stats. Do not print stats at exit.
  # `log`:
  # * `false`: Don't enable the log.
  # * `true`: Enable the log. Print log at exit.
  # * `:quiet`: Enable the log. Do not print log at exit.
  #
  def self.enable: (?stats: false | true | :quiet) -> void

  # <!--
  #   rdoc-file=yjit.rb
  #   - enabled?()
  # -->
  # Check if YJIT is enabled.
  #
  def self.enabled?: () -> bool

  # <!--
  #   rdoc-file=yjit.rb
  #   - format_number(pad, number)
  # -->
  # Format large numbers with comma separators for readability
  #
  def self.format_number: (untyped pad, untyped number) -> untyped

  # <!--
  #   rdoc-file=yjit.rb
  #   - format_number_pct(pad, number, total)
  # -->
  # Format a number along with a percentage over a total value
  #
  def self.format_number_pct: (untyped pad, untyped number, untyped total) -> untyped

  # <!--
  #   rdoc-file=yjit.rb
  #   - reset_stats!()
  # -->
  # Discard statistics collected for `--yjit-stats`.
  #
  def self.reset_stats!: () -> void

  # <!--
  #   rdoc-file=yjit.rb
  #   - runtime_stats(key = nil)
  # -->
  # Return a hash for statistics generated for the `--yjit-stats` command line
  # option.
  # Return `nil` when option is not passed or unavailable.
  # If a symbol argument is provided, return only the value for the named stat.
  # If any other type is provided, raises TypeError.
  #
  def self.runtime_stats: (?context: bool) -> Hash[untyped, untyped]?

  # <!--
  #   rdoc-file=yjit.rb
  #   - stats_enabled?()
  # -->
  # Check if `--yjit-stats` is used.
  #
  def self.stats_enabled?: () -> bool

  # <!--
  #   rdoc-file=yjit.rb
  #   - stats_string()
  # -->
  # Format and print out counters as a String. This returns a non-empty
  # content only when `--yjit-stats` is enabled.
  #
  def self.stats_string: () -> String
end

module RubyVM::RJIT
end
# <!-- rdoc-file=object.c -->
# `BasicObject` is the parent class of all classes in Ruby. In particular,
# `BasicObject` is the parent class of class Object, which is itself the default
# parent class of every Ruby class:
#
#     class Foo; end
#     Foo.superclass    # => Object
#     Object.superclass # => BasicObject
#
# `BasicObject` is the only class that has no parent:
#
#     BasicObject.superclass # => nil
#
# Class `BasicObject` can be used to create an object hierarchy (e.g., class
# Delegator) that is independent of Ruby's object hierarchy. Such objects:
#
# *   Do not have namespace "pollution" from the many methods provided in class
#     Object and its included module Kernel.
# *   Do not have definitions of common classes, and so references to such
#     common classes must be fully qualified (`::String`, not `String`).
#
# A variety of strategies can be used to provide useful portions of the Standard
# Library in subclasses of `BasicObject`:
#
# *   The immediate subclass could `include Kernel`, which would define methods
#     such as `puts`, `exit`, etc.
# *   A custom Kernel-like module could be created and included.
# *   Delegation can be used via #method_missing:
#
#         class MyObjectSystem < BasicObject
#           DELEGATE = [:puts, :p]
#
#           def method_missing(name, *args, &block)
#             return super unless DELEGATE.include? name
#             ::Kernel.send(name, *args, &block)
#           end
#
#           def respond_to_missing?(name, include_private = false)
#             DELEGATE.include?(name)
#           end
#         end
#
# ### What's Here
#
# These are the methods defined for BasicObject:
#
# *   ::new: Returns a new BasicObject instance.
# *   #!: Returns the boolean negation of `self`: `true` or `false`.
# *   #!=: Returns whether `self` and the given object are *not* equal.
# *   #==: Returns whether `self` and the given object are equivalent.
# *   #__id__: Returns the integer object identifier for `self`.
# *   #__send__: Calls the method identified by the given symbol.
# *   #equal?: Returns whether `self` and the given object are the same object.
# *   #instance_eval: Evaluates the given string or block in the context of
#     `self`.
# *   #instance_exec: Executes the given block in the context of `self`, passing
#     the given arguments.
# *   #method_missing: Called when `self` is called with a method it does not
#     define.
# *   #singleton_method_added: Called when a singleton method is added to
#     `self`.
# *   #singleton_method_removed: Called when a singleton method is removed from
#     `self`.
# *   #singleton_method_undefined: Called when a singleton method is undefined
#     in `self`.
#
class BasicObject
  # <!--
  #   rdoc-file=object.c
  #   - !obj    -> true or false
  # -->
  # Boolean negate.
  #
  def !: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj != other        -> true or false
  # -->
  # Returns true if two objects are not-equal, otherwise false.
  #
  def !=: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements `__id__`, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  def __id__: () -> Integer

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements `__send__`, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  def __send__: (interned name, *untyped, **untyped) ?{ (?) -> untyped } -> untyped

  # <!-- rdoc-file=object.c -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  alias equal? ==

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_eval(string [, filename [, lineno]] )   -> obj
  #   - obj.instance_eval {|obj| block }                     -> obj
  # -->
  # Evaluates a string containing Ruby source code, or the given block, within the
  # context of the receiver (*obj*). In order to set the context, the variable
  # `self` is set to *obj* while the code is executing, giving the code access to
  # *obj*'s instance variables and private methods.
  #
  # When `instance_eval` is given a block, *obj* is also passed in as the block's
  # only argument.
  #
  # When `instance_eval` is given a `String`, the optional second and third
  # parameters supply a filename and starting line number that are used when
  # reporting compilation errors.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #       private
  #       def the_secret
  #         "Ssssh! The secret is #{@secret}."
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_eval { @secret }          #=> 99
  #     k.instance_eval { the_secret }       #=> "Ssssh! The secret is 99."
  #     k.instance_eval {|obj| obj == self } #=> true
  #
  def instance_eval: (string code, ?string filename, ?int lineno) -> untyped
                   | [U] () { (self) [self: self] -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_exec(arg...) {|var...| block }                       -> obj
  # -->
  # Executes the given block within the context of the receiver (*obj*). In order
  # to set the context, the variable `self` is set to *obj* while the code is
  # executing, giving the code access to *obj*'s instance variables.  Arguments
  # are passed as block parameters.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_exec(5) {|x| @secret+x }   #=> 104
  #
  def instance_exec: [U] (*untyped, **untyped) { (?) [self: self] -> U } -> U

  # <!--
  #   rdoc-file=object.c
  #   - BasicObject.new
  # -->
  # Returns a new BasicObject.
  #
  def initialize: () -> void

  private

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.method_missing(symbol [, *args] )   -> result
  # -->
  # Invoked by Ruby when *obj* is sent a message it cannot handle. *symbol* is the
  # symbol for the method called, and *args* are any arguments that were passed to
  # it. By default, the interpreter raises an error when this method is called.
  # However, it is possible to override the method to provide more dynamic
  # behavior. If it is decided that a particular method should not be handled,
  # then *super* should be called, so that ancestors can pick up the missing
  # method. The example below creates a class `Roman`, which responds to methods
  # with names consisting of roman numerals, returning the corresponding integer
  # values.
  #
  #     class Roman
  #       def roman_to_int(str)
  #         # ...
  #       end
  #
  #       def method_missing(symbol, *args)
  #         str = symbol.id2name
  #         begin
  #           roman_to_int(str)
  #         rescue
  #           super(symbol, *args)
  #         end
  #       end
  #     end
  #
  #     r = Roman.new
  #     r.iv      #=> 4
  #     r.xxiii   #=> 23
  #     r.mm      #=> 2000
  #     r.foo     #=> NoMethodError
  #
  def method_missing: (Symbol, *untyped, **untyped) ?{ (?) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_added(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is added to the receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_added(id)
  #         puts "Adding #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #     end
  #
  # *produces:*
  #
  #     Adding singleton_method_added
  #     Adding one
  #     Adding three
  #
  def singleton_method_added: (Symbol name) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_removed(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_removed(id)
  #         puts "Removing #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #       class << self
  #         remove_method :three
  #         remove_method :one
  #       end
  #     end
  #
  # *produces:*
  #
  #     Removing three
  #     Removing one
  #
  def singleton_method_removed: (Symbol name) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_undefined(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is undefined in the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_undefined(id)
  #         puts "Undefining #{id.id2name}"
  #       end
  #       def Chatty.one()   end
  #       class << self
  #          undef_method(:one)
  #       end
  #     end
  #
  # *produces:*
  #
  #     Undefining one
  #
  def singleton_method_undefined: (Symbol name) -> nil
end
# <!-- rdoc-file=marshal.c -->
# The marshaling library converts collections of Ruby objects into a byte
# stream, allowing them to be stored outside the currently active script. This
# data may subsequently be read and the original objects reconstituted.
#
# Marshaled data has major and minor version numbers stored along with the
# object information. In normal use, marshaling can only load data written with
# the same major version number and an equal or lower minor version number. If
# Ruby's ``verbose'' flag is set (normally using -d, -v, -w, or --verbose) the
# major and minor numbers must match exactly. Marshal versioning is independent
# of Ruby's version numbers. You can extract the version by reading the first
# two bytes of marshaled data.
#
#     str = Marshal.dump("thing")
#     RUBY_VERSION   #=> "1.9.0"
#     str[0].ord     #=> 4
#     str[1].ord     #=> 8
#
# Some objects cannot be dumped: if the objects to be dumped include bindings,
# procedure or method objects, instances of class IO, or singleton objects, a
# TypeError will be raised.
#
# If your class has special serialization needs (for example, if you want to
# serialize in some specific format), or if it contains objects that would
# otherwise not be serializable, you can implement your own serialization
# strategy.
#
# There are two methods of doing this, your object can define either
# marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
# precedence over _dump if both are defined.  marshal_dump may result in smaller
# Marshal strings.
#
# ## Security considerations
#
# By design, Marshal.load can deserialize almost any class loaded into the Ruby
# process. In many cases this can lead to remote code execution if the Marshal
# data is loaded from an untrusted source.
#
# As a result, Marshal.load is not suitable as a general purpose serialization
# format and you should never unmarshal user supplied input or other untrusted
# data.
#
# If you need to deserialize untrusted data, use JSON or another serialization
# format that is only able to load simple, 'primitive' types such as String,
# Array, Hash, etc. Never allow user input to specify arbitrary types to
# deserialize into.
#
# ## marshal_dump and marshal_load
#
# When dumping an object the method marshal_dump will be called. marshal_dump
# must return a result containing the information necessary for marshal_load to
# reconstitute the object.  The result can be any object.
#
# When loading an object dumped using marshal_dump the object is first allocated
# then marshal_load is called with the result from marshal_dump. marshal_load
# must recreate the object from the information in the result.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def marshal_dump
#         [@name, @version]
#       end
#
#       def marshal_load array
#         @name, @version = array
#       end
#     end
#
# ## _dump and _load
#
# Use _dump and _load when you need to allocate the object you're restoring
# yourself.
#
# When dumping an object the instance method _dump is called with an Integer
# which indicates the maximum depth of objects to dump (a value of -1 implies
# that you should disable depth checking).  _dump must return a String
# containing the information necessary to reconstitute the object.
#
# The class method _load should take a String and use it to return an object of
# the same class.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def _dump level
#         [@name, @version].join ':'
#       end
#
#       def self._load args
#         new(*args.split(':'))
#       end
#     end
#
# Since Marshal.dump outputs a string you can have _dump return a Marshal string
# which is Marshal.loaded in _load for complex objects.
#
module Marshal
  # <!-- rdoc-file=marshal.c -->
  # major version
  #
  MAJOR_VERSION: Integer

  # <!-- rdoc-file=marshal.c -->
  # minor version
  #
  MINOR_VERSION: Integer

  # <!--
  #   rdoc-file=marshal.c
  #   - dump( obj [, anIO] , limit=-1 ) -> anIO
  # -->
  # Serializes obj and all descendant objects. If anIO is specified, the
  # serialized data will be written to it, otherwise the data will be returned as
  # a String. If limit is specified, the traversal of subobjects will be limited
  # to that depth. If limit is negative, no checking of depth will be performed.
  #
  #     class Klass
  #       def initialize(str)
  #         @str = str
  #       end
  #       def say_hello
  #         @str
  #       end
  #     end
  #
  # (produces no output)
  #
  #     o = Klass.new("hello\n")
  #     data = Marshal.dump(o)
  #     obj = Marshal.load(data)
  #     obj.say_hello  #=> "hello\n"
  #
  # Marshal can't dump following objects:
  # *   anonymous Class/Module.
  # *   objects which are related to system (ex: Dir, File::Stat, IO, File, Socket
  #     and so on)
  # *   an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,
  #     ThreadGroup, Continuation
  # *   objects which define singleton methods
  #
  def self?.dump: [W < _Writer] (untyped obj, W port, ?int? limit) -> W
                | (untyped obj, ?Integer limit) -> String

  # <!--
  #   rdoc-file=marshal.rb
  #   - load(source, proc = nil, freeze: false) -> obj
  #   - restore(source, proc = nil, freeze: false) -> obj
  # -->
  # Returns the result of converting the serialized data in source into a Ruby
  # object (possibly with associated subordinate objects). source may be either an
  # instance of IO or an object that responds to to_str. If proc is specified,
  # each object will be passed to the proc, as the object is being deserialized.
  #
  # Never pass untrusted data (including user supplied input) to this method.
  # Please see the overview for further details.
  #
  # If the `freeze: true` argument is passed, deserialized object would be deeply
  # frozen. Note that it may lead to more efficient memory usage due to frozen
  # strings deduplication:
  #
  #     serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])
  #
  #     deserialized = Marshal.load(serialized)
  #     deserialized.map(&:frozen?)
  #     # => [false, false, false, false]
  #     deserialized.map(&:object_id)
  #     # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects
  #
  #     deserialized = Marshal.load(serialized, freeze: true)
  #     deserialized.map(&:frozen?)
  #     # => [true, true, true, true]
  #     deserialized.map(&:object_id)
  #     # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating
  #
  def self.load: (string | _Source source, ?freeze: boolish) -> untyped
               | [A] (string | _Source source, _Proc[A] proc, ?freeze: boolish) -> A

  interface _Proc[T]
    def call: (untyped loaded) -> T
  end

  interface _Source
    def getbyte: () -> (String | int)

    def read: (Integer) -> string
  end

  # <!--
  #   rdoc-file=marshal.rb
  #   - restore(source, proc = nil, freeze: false)
  # -->
  #
  alias self.restore self.load
end
# <!-- rdoc-file=error.c -->
# The Warning module contains a single method named #warn, and the module
# extends itself, making Warning.warn available. Warning.warn is called for all
# warnings issued by Ruby. By default, warnings are printed to $stderr.
#
# Changing the behavior of Warning.warn is useful to customize how warnings are
# handled by Ruby, for instance by filtering some warnings, and/or outputting
# warnings somewhere other than `$stderr`.
#
# If you want to change the behavior of Warning.warn you should use
# `Warning.extend(MyNewModuleWithWarnMethod)` and you can use `super` to get the
# default behavior of printing the warning to `$stderr`.
#
# Example:
#     module MyWarningFilter
#       def warn(message, category: nil, **kwargs)
#         if /some warning I want to ignore/.match?(message)
#           # ignore
#         else
#           super
#         end
#       end
#     end
#     Warning.extend MyWarningFilter
#
# You should never redefine Warning#warn (the instance method), as that will
# then no longer provide a way to use the default behavior.
#
# The [warning](https://rubygems.org/gems/warning) gem provides convenient ways
# to customize Warning.warn.
#
module Warning
  # The types of categories the `Warning` module understands.
  #
  type category = :deprecated | :experimental | :performance

  # <!--
  #   rdoc-file=error.c
  #   - Warning[category]  -> true or false
  # -->
  # Returns the flag to show the warning messages for `category`. Supported
  # categories are:
  #
  # `:deprecated`
  # :   deprecation warnings
  #     *   assignment of non-nil value to `$,` and `$;`
  #     *   keyword arguments
  #     etc.
  #
  #
  # `:experimental`
  # :   experimental features
  #
  #
  # `:performance`
  # :   performance hints
  #     *   Shape variation limit
  #
  def self.[]: (category) -> bool

  # <!--
  #   rdoc-file=error.c
  #   - Warning[category] = flag -> flag
  # -->
  # Sets the warning flags for `category`. See Warning.[] for the categories.
  #
  def self.[]=: [T] (category, T flag) -> T

  # <!--
  #   rdoc-file=error.c
  #   - categories  -> array
  # -->
  # Returns a list of the supported category symbols.
  #
  def self.categories: () -> Array[Symbol]

  # <!--
  #   rdoc-file=error.c
  #   - warn(msg, category: nil)  -> nil
  # -->
  # Writes warning message `msg` to $stderr. This method is called by Ruby for all
  # emitted warnings. A `category` may be included with the warning.
  #
  # See the documentation of the Warning module for how to customize this.
  #
  def self?.warn: (String message, ?category: category?) -> nil
end
# <!-- rdoc-file=struct.c -->
# Class Data provides a convenient way to define simple classes for value-alike
# objects.
#
# The simplest example of usage:
#
#     Measure = Data.define(:amount, :unit)
#
#     # Positional arguments constructor is provided
#     distance = Measure.new(100, 'km')
#     #=> #<data Measure amount=100, unit="km">
#
#     # Keyword arguments constructor is provided
#     weight = Measure.new(amount: 50, unit: 'kg')
#     #=> #<data Measure amount=50, unit="kg">
#
#     # Alternative form to construct an object:
#     speed = Measure[10, 'mPh']
#     #=> #<data Measure amount=10, unit="mPh">
#
#     # Works with keyword arguments, too:
#     area = Measure[amount: 1.5, unit: 'm^2']
#     #=> #<data Measure amount=1.5, unit="m^2">
#
#     # Argument accessors are provided:
#     distance.amount #=> 100
#     distance.unit #=> "km"
#
# Constructed object also has a reasonable definitions of #== operator, #to_h
# hash conversion, and #deconstruct / #deconstruct_keys to be used in pattern
# matching.
#
# ::define method accepts an optional block and evaluates it in the context of
# the newly defined class. That allows to define additional methods:
#
#     Measure = Data.define(:amount, :unit) do
#       def <=>(other)
#         return unless other.is_a?(self.class) && other.unit == unit
#         amount <=> other.amount
#       end
#
#       include Comparable
#     end
#
#     Measure[3, 'm'] < Measure[5, 'm'] #=> true
#     Measure[3, 'm'] < Measure[5, 'kg']
#     # comparison of Measure with Measure failed (ArgumentError)
#
# Data provides no member writers, or enumerators: it is meant to be a storage
# for immutable atomic values. But note that if some of data members is of a
# mutable class, Data does no additional immutability enforcement:
#
#     Event = Data.define(:time, :weekdays)
#     event = Event.new('18:00', %w[Tue Wed Fri])
#     #=> #<data Event time="18:00", weekdays=["Tue", "Wed", "Fri"]>
#
#     # There is no #time= or #weekdays= accessors, but changes are
#     # still possible:
#     event.weekdays << 'Sat'
#     event
#     #=> #<data Event time="18:00", weekdays=["Tue", "Wed", "Fri", "Sat"]>
#
# See also Struct, which is a similar concept, but has more container-alike API,
# allowing to change contents of the object and enumerate it.
#
class Data
  # <!--
  #   rdoc-file=struct.c
  #   - define(*symbols) -> class
  # -->
  # Defines a new Data class.
  #
  #     measure = Data.define(:amount, :unit)
  #     #=> #<Class:0x00007f70c6868498>
  #     measure.new(1, 'km')
  #     #=> #<data amount=1, unit="km">
  #
  #     # It you store the new class in the constant, it will
  #     # affect #inspect and will be more natural to use:
  #     Measure = Data.define(:amount, :unit)
  #     #=> Measure
  #     Measure.new(1, 'km')
  #     #=> #<data Measure amount=1, unit="km">
  #
  # Note that member-less Data is acceptable and might be a useful technique for
  # defining several homogeneous data classes, like
  #
  #     class HTTPFetcher
  #       Response = Data.define(:body)
  #       NotFound = Data.define
  #       # ... implementation
  #     end
  #
  # Now, different kinds of responses from `HTTPFetcher` would have consistent
  # representation:
  #
  #     #<data HTTPFetcher::Response body="<html...">
  #     #<data HTTPFetcher::NotFound>
  #
  # And are convenient to use in pattern matching:
  #
  #     case fetcher.get(url)
  #     in HTTPFetcher::Response(body)
  #       # process body variable
  #     in HTTPFetcher::NotFound
  #       # handle not found case
  #     end
  #
  def self.define: [KLASS < _DataClass] (*Symbol) ?{ (KLASS) [self: KLASS] -> void } -> KLASS

  interface _DataClass
    # <!--
    #   rdoc-file=struct.c
    #   - new(*args) -> instance
    #   - new(**kwargs) -> instance
    #   - ::[](*args) -> instance
    #   - ::[](**kwargs) -> instance
    # -->
    # Constructors for classes defined with ::define accept both positional and
    # keyword arguments.
    #
    #     Measure = Data.define(:amount, :unit)
    #
    #     Measure.new(1, 'km')
    #     #=> #<data Measure amount=1, unit="km">
    #     Measure.new(amount: 1, unit: 'km')
    #     #=> #<data Measure amount=1, unit="km">
    #
    #     # Alternative shorter intialization with []
    #     Measure[1, 'km']
    #     #=> #<data Measure amount=1, unit="km">
    #     Measure[amount: 1, unit: 'km']
    #     #=> #<data Measure amount=1, unit="km">
    #
    # All arguments are mandatory (unlike Struct), and converted to keyword
    # arguments:
    #
    #     Measure.new(amount: 1)
    #     # in `initialize': missing keyword: :unit (ArgumentError)
    #
    #     Measure.new(1)
    #     # in `initialize': missing keyword: :unit (ArgumentError)
    #
    # Note that `Measure#initialize` always receives keyword arguments, and that
    # mandatory arguments are checked in `initialize`, not in `new`. This can be
    # important for redefining initialize in order to convert arguments or provide
    # defaults:
    #
    #     Measure = Data.define(:amount, :unit) do
    #       NONE = Data.define
    #
    #       def initialize(amount:, unit: NONE.new)
    #         super(amount: Float(amount), unit:)
    #       end
    #     end
    #
    #     Measure.new('10', 'km') # => #<data Measure amount=10.0, unit="km">
    #     Measure.new(10_000)     # => #<data Measure amount=10000.0, unit=#<data NONE>>
    #
    %a{annotate:rdoc:copy:Data.new}
    def new: (*untyped) -> Data
           | (**untyped) -> Data

    %a{annotate:rdoc:copy:Data.[]}
    def []: (*untyped) -> Data
          | (**untyped) -> Data

    # <!--
    #   rdoc-file=struct.c
    #   - DataClass::members -> array_of_symbols
    # -->
    # Returns an array of member names of the data class:
    #
    #     Measure = Data.define(:amount, :unit)
    #     Measure.members # => [:amount, :unit]
    #
    %a{annotate:rdoc:copy:Data.members}
    def members: () -> Array[Symbol]
  end

  %a{annotate:rdoc:skip}
  def self.new: () -> bot

  def self.allocate: () -> bot

  # <!--
  #   rdoc-file=struct.c
  #   - self == other -> true or false
  # -->
  # Returns  `true` if `other` is the same class as `self`, and all members are
  # equal.
  #
  # Examples:
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     Measure[1, 'km'] == Measure[1, 'km'] #=> true
  #     Measure[1, 'km'] == Measure[2, 'km'] #=> false
  #     Measure[1, 'km'] == Measure[1, 'm']  #=> false
  #
  #     Measurement = Data.define(:amount, :unit)
  #     # Even though Measurement and Measure have the same "shape"
  #     # their instances are never equal
  #     Measure[1, 'km'] == Measurement[1, 'km'] #=> false
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=struct.c
  #   - deconstruct     -> array
  # -->
  # Returns the values in `self` as an array, to use in pattern matching:
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     distance = Measure[10, 'km']
  #     distance.deconstruct #=> [10, "km"]
  #
  #     # usage
  #     case distance
  #     in n, 'km' # calls #deconstruct underneath
  #       puts "It is #{n} kilometers away"
  #     else
  #       puts "Don't know how to handle it"
  #     end
  #     # prints "It is 10 kilometers away"
  #
  # Or, with checking the class, too:
  #
  #     case distance
  #     in Measure(n, 'km')
  #       puts "It is #{n} kilometers away"
  #     # ...
  #     end
  #
  def deconstruct: () -> Array[untyped]

  # <!--
  #   rdoc-file=struct.c
  #   - deconstruct_keys(array_of_names_or_nil) -> hash
  # -->
  # Returns a hash of the name/value pairs, to use in pattern matching.
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     distance = Measure[10, 'km']
  #     distance.deconstruct_keys(nil) #=> {:amount=>10, :unit=>"km"}
  #     distance.deconstruct_keys([:amount]) #=> {:amount=>10}
  #
  #     # usage
  #     case distance
  #     in amount:, unit: 'km' # calls #deconstruct_keys underneath
  #       puts "It is #{amount} kilometers away"
  #     else
  #       puts "Don't know how to handle it"
  #     end
  #     # prints "It is 10 kilometers away"
  #
  # Or, with checking the class, too:
  #
  #     case distance
  #     in Measure(amount:, unit: 'km')
  #       puts "It is #{amount} kilometers away"
  #     # ...
  #     end
  #
  def deconstruct_keys: (?Array[Symbol]?) -> Hash[Symbol, untyped]

  # <!--
  #   rdoc-file=struct.c
  #   - self.eql?(other) -> true or false
  # -->
  # Equality check that is used when two items of data are keys of a Hash.
  #
  # The subtle difference with #== is that members are also compared with their
  # #eql? method, which might be important in some cases:
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     Measure[1, 'km'] == Measure[1.0, 'km'] #=> true, they are equal as values
  #     # ...but...
  #     Measure[1, 'km'].eql? Measure[1.0, 'km'] #=> false, they represent different hash keys
  #
  # See also Object#eql? for further explanations of the method usage.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=struct.c
  #   - hash -> integer
  # -->
  # Redefines Object#hash (used to distinguish objects as Hash keys) so that data
  # objects of the same class with same content would have the same `hash` value,
  # and represented the same Hash key.
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     Measure[1, 'km'].hash == Measure[1, 'km'].hash #=> true
  #     Measure[1, 'km'].hash == Measure[10, 'km'].hash #=> false
  #     Measure[1, 'km'].hash == Measure[1, 'm'].hash #=> false
  #     Measure[1, 'km'].hash == Measure[1.0, 'km'].hash #=> false
  #
  #     # Structurally similar data class, but shouldn't be considered
  #     # the same hash key
  #     Measurement = Data.define(:amount, :unit)
  #
  #     Measure[1, 'km'].hash == Measurement[1, 'km'].hash #=> false
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=struct.c
  #   - inspect -> string
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     distance = Measure[10, 'km']
  #
  #     p distance  # uses #inspect underneath
  #     #<data Measure amount=10, unit="km">
  #
  #     puts distance  # uses #to_s underneath, same representation
  #     #<data Measure amount=10, unit="km">
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=struct.c
  #   - members -> array_of_symbols
  # -->
  # Returns the member names from `self` as an array:
  #
  #     Measure = Data.define(:amount, :unit)
  #     distance = Measure[10, 'km']
  #
  #     distance.members #=> [:amount, :unit]
  #
  def members: () -> Array[Symbol]

  # <!--
  #   rdoc-file=struct.c
  #   - to_h -> hash
  #   - to_h {|name, value| ... } -> hash
  # -->
  # Returns Hash representation of the data object.
  #
  #     Measure = Data.define(:amount, :unit)
  #     distance = Measure[10, 'km']
  #
  #     distance.to_h
  #     #=> {:amount=>10, :unit=>"km"}
  #
  # Like Enumerable#to_h, if the block is provided, it is expected to produce
  # key-value pairs to construct a hash:
  #
  #     distance.to_h { |name, val| [name.to_s, val.to_s] }
  #     #=> {"amount"=>"10", "unit"=>"km"}
  #
  # Note that there is a useful symmetry between #to_h and #initialize:
  #
  #     distance2 = Measure.new(**distance.to_h)
  #     #=> #<data Measure amount=10, unit="km">
  #     distance2 == distance
  #     #=> true
  #
  def to_h: () -> Hash[Symbol, untyped]

  # <!-- rdoc-file=struct.c -->
  # Returns a string representation of `self`:
  #
  #     Measure = Data.define(:amount, :unit)
  #
  #     distance = Measure[10, 'km']
  #
  #     p distance  # uses #inspect underneath
  #     #<data Measure amount=10, unit="km">
  #
  #     puts distance  # uses #to_s underneath, same representation
  #     #<data Measure amount=10, unit="km">
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=struct.c
  #   - with(**kwargs) -> instance
  # -->
  # Returns a shallow copy of `self` --- the instance variables of `self` are
  # copied, but not the objects they reference.
  #
  # If the method is supplied any keyword arguments, the copy will be created with
  # the respective field values updated to use the supplied keyword argument
  # values. Note that it is an error to supply a keyword that the Data class does
  # not have as a member.
  #
  #     Point = Data.define(:x, :y)
  #
  #     origin = Point.new(x: 0, y: 0)
  #
  #     up = origin.with(x: 1)
  #     right = origin.with(y: 1)
  #     up_and_right = up.with(y: 1)
  #
  #     p origin       # #<data Point x=0, y=0>
  #     p up           # #<data Point x=1, y=0>
  #     p right        # #<data Point x=0, y=1>
  #     p up_and_right # #<data Point x=1, y=1>
  #
  #     out = origin.with(z: 1) # ArgumentError: unknown keyword: :z
  #     some_point = origin.with(1, 2) # ArgumentError: expected keyword arguments, got positional arguments
  #
  def with: (**untyped) -> instance
end
# <!-- rdoc-file=gc.rb -->
# The GC module provides an interface to Ruby's mark-and-sweep garbage
# collection mechanism.
#
# Some of the underlying methods are also available via the ObjectSpace module.
#
# You may obtain information about the operation of the GC through GC::Profiler.
#
module GC
  # <!-- rdoc-file=gc.c -->
  # The GC profiler provides access to information on GC runs including time,
  # length and object space size.
  #
  # Example:
  #
  #     GC::Profiler.enable
  #
  #     require 'rdoc/rdoc'
  #
  #     GC::Profiler.report
  #
  #     GC::Profiler.disable
  #
  # See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations
  #
  module Profiler
    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.clear          -> nil
    # -->
    # Clears the GC profiler data.
    #
    def self.clear: () -> nil

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.disable      -> nil
    # -->
    # Stops the GC profiler.
    #
    def self.disable: () -> nil

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.enable       -> nil
    # -->
    # Starts the GC profiler.
    #
    def self.enable: () -> nil

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.enabled?     -> true or false
    # -->
    # The current status of GC profile mode.
    #
    def self.enabled?: () -> bool

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.raw_data    -> [Hash, ...]
    # -->
    # Returns an Array of individual raw profile data Hashes ordered from earliest
    # to latest by `:GC_INVOKE_TIME`.
    #
    # For example:
    #
    #     [
    #       {
    #          :GC_TIME=>1.3000000000000858e-05,
    #          :GC_INVOKE_TIME=>0.010634999999999999,
    #          :HEAP_USE_SIZE=>289640,
    #          :HEAP_TOTAL_SIZE=>588960,
    #          :HEAP_TOTAL_OBJECTS=>14724,
    #          :GC_IS_MARKED=>false
    #       },
    #       # ...
    #     ]
    #
    # The keys mean:
    #
    # `:GC_TIME`
    # :   Time elapsed in seconds for this GC run
    #
    # `:GC_INVOKE_TIME`
    # :   Time elapsed in seconds from startup to when the GC was invoked
    #
    # `:HEAP_USE_SIZE`
    # :   Total bytes of heap used
    #
    # `:HEAP_TOTAL_SIZE`
    # :   Total size of heap in bytes
    #
    # `:HEAP_TOTAL_OBJECTS`
    # :   Total number of objects
    #
    # `:GC_IS_MARKED`
    # :   Returns `true` if the GC is in mark phase
    #
    #
    # If ruby was built with `GC_PROFILE_MORE_DETAIL`, you will also have access to
    # the following hash keys:
    #
    # `:GC_MARK_TIME`
    # `:GC_SWEEP_TIME`
    # `:ALLOCATE_INCREASE`
    # `:ALLOCATE_LIMIT`
    # `:HEAP_USE_PAGES`
    # `:HEAP_LIVE_OBJECTS`
    # `:HEAP_FREE_OBJECTS`
    # `:HAVE_FINALIZE`
    # :
    #
    def self.raw_data: () -> Array[Hash[Symbol, untyped]]

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.report
    #   - GC::Profiler.report(io)
    # -->
    # Writes the GC::Profiler.result to `$stdout` or the given IO object.
    #
    def self.report: (?_Reporter io) -> nil

    interface _Reporter
      def write: (String msg) -> void
    end

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.result  -> String
    # -->
    # Returns a profile data report such as:
    #
    #     GC 1 invokes.
    #     Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object                    GC time(ms)
    #         1               0.012               159240               212940                10647         0.00000000000001530000
    #
    def self.result: () -> String

    # <!--
    #   rdoc-file=gc.c
    #   - GC::Profiler.total_time  -> float
    # -->
    # The total time used for garbage collection in seconds
    #
    def self.total_time: () -> Float
  end

  # <!-- rdoc-file=gc.c -->
  # Internal constants in the garbage collector.
  #
  INTERNAL_CONSTANTS: Hash[Symbol, untyped]

  # <!-- rdoc-file=gc.c -->
  # GC build options
  #
  OPTS: Array[String]

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.config -> hash
  #   - GC.config(hash) -> hash
  # -->
  # Sets or gets information about the current GC config.
  #
  # Configuration parameters are GC implementation-specific and may change without
  # notice.
  #
  # This method can be called without parameters to retrieve the current config as
  # a `Hash` with `Symbol` keys.
  #
  # This method can also be called with a `Hash` argument to assign values to
  # valid config keys. Config keys missing from the passed `Hash` will be left
  # unmodified.
  #
  # If a key/value pair is passed to this function that does not correspond to a
  # valid config key for the GC implementation being used, no config will be
  # updated, the key will be present in the returned Hash, and its value will be
  # `nil`. This is to facilitate easy migration between GC implementations.
  #
  # In both call-seqs, the return value of `GC.config` will be a `Hash` containing
  # the most recent full configuration, i.e., all keys and values defined by the
  # specific GC implementation being used. In the case of a config update, the
  # return value will include the new values being updated.
  #
  # This method is only expected to work on CRuby.
  #
  # ### GC Implementation independent values
  #
  # The `GC.config` hash can also contain keys that are global and read-only.
  # These keys are not specific to any one GC library implementation and
  # attempting to write to them will raise `ArgumentError`.
  #
  # There is currently only one global, read-only key:
  #
  # implementation
  # :   Returns a `String` containing the name of the currently loaded GC library,
  #     if one has been loaded using `RUBY_GC_LIBRARY`, and "default" in all other
  #     cases
  #
  #
  # ### GC Implementation specific values
  #
  # GC libraries are expected to document their own configuration. Valid keys for
  # Ruby's default GC implementation are:
  #
  # rgengc_allow_full_mark
  # :   Controls whether the GC is allowed to run a full mark (young & old
  #     objects).
  #
  #     When `true`, GC interleaves major and minor collections. This is the
  #     default. GC will function as intended.
  #
  #     When `false`, the GC will never trigger a full marking cycle unless
  #     explicitly requested by user code. Instead, only a minor mark will
  #     runonly young objects will be marked. When the heap space is exhausted,
  #     new pages will be allocated immediately instead of running a full mark.
  #
  #     A flag will be set to notify that a full mark has been requested. This
  #     flag is accessible using `GC.latest_gc_info(:needs_major_by)`
  #
  #     The user can trigger a major collection at any time using
  #     `GC.start(full_mark: true)`
  #
  #     When `false`, Young to Old object promotion is disabled. For performance
  #     reasons, it is recommended to warm up an application using
  #     `Process.warmup` before setting this parameter to `false`.
  #
  def self.config: () -> Hash[Symbol, untyped]
                 | (Hash[Symbol, untyped]) -> Hash[Symbol, untyped]

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.count -> Integer
  # -->
  # Returns the number of times GC has occurred since the process started.
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.disable -> true or false
  # -->
  # Disables garbage collection, returning `true` if garbage collection was
  # already disabled.
  #
  #     GC.disable   #=> false
  #     GC.disable   #=> true
  #
  def self.disable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.enable -> true or false
  # -->
  # Enables garbage collection, returning `true` if garbage collection was
  # previously disabled.
  #
  #     GC.disable   #=> false
  #     GC.enable    #=> true
  #     GC.enable    #=> false
  #
  def self.enable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - start(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  # Initiates garbage collection, even if manually disabled.
  #
  # The `full_mark` keyword argument determines whether or not to perform a major
  # garbage collection cycle. When set to `true`, a major garbage collection cycle
  # is run, meaning all objects are marked. When set to `false`, a minor garbage
  # collection cycle is run, meaning only young objects are marked.
  #
  # The `immediate_mark` keyword argument determines whether or not to perform
  # incremental marking. When set to `true`, marking is completed during the call
  # to this method. When set to `false`, marking is performed in steps that are
  # interleaved with future Ruby code execution, so marking might not be completed
  # during this method call. Note that if `full_mark` is `false`, then marking
  # will always be immediate, regardless of the value of `immediate_mark`.
  #
  # The `immediate_sweep` keyword argument determines whether or not to defer
  # sweeping (using lazy sweep). When set to `false`, sweeping is performed in
  # steps that are interleaved with future Ruby code execution, so sweeping might
  # not be completed during this method call. When set to `true`, sweeping is
  # completed during the call to this method.
  #
  # Note: These keyword arguments are implementation and version-dependent. They
  # are not guaranteed to be future-compatible and may be ignored if the
  # underlying implementation does not support them.
  #
  def self.start: (?immediate_sweep: boolish, ?immediate_mark: boolish, ?full_mark: boolish) -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stat -> Hash
  #   - GC.stat(hash) -> Hash
  #   - GC.stat(:key) -> Numeric
  # -->
  # Returns a Hash containing information about the GC.
  #
  # The contents of the hash are implementation-specific and may change in the
  # future without notice.
  #
  # The hash includes internal statistics about GC such as:
  #
  # count
  # :   The total number of garbage collections run since application start (count
  #     includes both minor and major garbage collections)
  #
  # time
  # :   The total time spent in garbage collections (in milliseconds)
  #
  # heap_allocated_pages
  # :   The total number of `:heap_eden_pages` + `:heap_tomb_pages`
  #
  # heap_sorted_length
  # :   The number of pages that can fit into the buffer that holds references to
  #     all pages
  #
  # heap_allocatable_pages
  # :   The total number of pages the application could allocate without
  #     additional GC
  #
  # heap_available_slots
  # :   The total number of slots in all `:heap_allocated_pages`
  #
  # heap_live_slots
  # :   The total number of slots which contain live objects
  #
  # heap_free_slots
  # :   The total number of slots which do not contain live objects
  #
  # heap_final_slots
  # :   The total number of slots with pending finalizers to be run
  #
  # heap_marked_slots
  # :   The total number of objects marked in the last GC
  #
  # heap_eden_pages
  # :   The total number of pages which contain at least one live slot
  #
  # heap_tomb_pages
  # :   The total number of pages which do not contain any live slots
  #
  # total_allocated_pages
  # :   The cumulative number of pages allocated since application start
  #
  # total_freed_pages
  # :   The cumulative number of pages freed since application start
  #
  # total_allocated_objects
  # :   The cumulative number of objects allocated since application start
  #
  # total_freed_objects
  # :   The cumulative number of objects freed since application start
  #
  # malloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by any GC
  #
  # malloc_increase_bytes_limit
  # :   When `:malloc_increase_bytes` crosses this limit, GC is triggered
  #
  # minor_gc_count
  # :   The total number of minor garbage collections run since process start
  #
  # major_gc_count
  # :   The total number of major garbage collections run since process start
  #
  # compact_count
  # :   The total number of compactions run since process start
  #
  # read_barrier_faults
  # :   The total number of times the read barrier was triggered during compaction
  #
  # total_moved_objects
  # :   The total number of objects compaction has moved
  #
  # remembered_wb_unprotected_objects
  # :   The total number of objects without write barriers
  #
  # remembered_wb_unprotected_objects_limit
  # :   When `:remembered_wb_unprotected_objects` crosses this limit, major GC is
  #     triggered
  #
  # old_objects
  # :   Number of live, old objects which have survived at least 3 garbage
  #     collections
  #
  # old_objects_limit
  # :   When `:old_objects` crosses this limit, major GC is triggered
  #
  # oldmalloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by major GC
  #
  # oldmalloc_increase_bytes_limit
  # :   When `:oldmalloc_increase_bytes` crosses this limit, major GC is triggered
  #
  #
  # If the optional argument, hash, is given, it is overwritten and returned. This
  # is intended to avoid the probe effect.
  #
  # This method is only expected to work on CRuby.
  #
  def self.stat: (?Hash[Symbol, untyped]? hash) -> Hash[Symbol, untyped]
               | (Symbol key) -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.measure_total_time = true/false
  # -->
  # Enables measuring GC time. You can get the result with `GC.stat(:time)`. Note
  # that GC time measurement can cause some performance overhead.
  #
  def self.measure_total_time=: [T] (T enable) -> T

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.measure_total_time -> true/false
  # -->
  # Returns the measure_total_time flag (default: `true`). Note that measurement
  # can affect the application's performance.
  #
  def self.measure_total_time: () -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - GC.auto_compact = flag
  # -->
  # Updates automatic compaction mode.
  #
  # When enabled, the compactor will execute on every major collection.
  #
  # Enabling compaction will degrade performance on major collections.
  #
  def self.auto_compact=: [T] (T enable) -> T

  # <!--
  #   rdoc-file=gc.c
  #   - GC.auto_compact    -> true or false
  # -->
  # Returns whether or not automatic compaction has been enabled.
  #
  def self.auto_compact: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stat_heap -> Hash
  #   - GC.stat_heap(nil, hash) -> Hash
  #   - GC.stat_heap(heap_name) -> Hash
  #   - GC.stat_heap(heap_name, hash) -> Hash
  #   - GC.stat_heap(heap_name, :key) -> Numeric
  # -->
  # Returns information for heaps in the GC.
  #
  # If the first optional argument, `heap_name`, is passed in and not `nil`, it
  # returns a `Hash` containing information about the particular heap. Otherwise,
  # it will return a `Hash` with heap names as keys and a `Hash` containing
  # information about the heap as values.
  #
  # If the second optional argument, `hash_or_key`, is given as a `Hash`, it will
  # be overwritten and returned. This is intended to avoid the probe effect.
  #
  # If both optional arguments are passed in and the second optional argument is a
  # symbol, it will return a `Numeric` value for the particular heap.
  #
  # On CRuby, `heap_name` is of the type `Integer` but may be of type `String` on
  # other implementations.
  #
  # The contents of the hash are implementation-specific and may change in the
  # future without notice.
  #
  # If the optional argument, hash, is given, it is overwritten and returned.
  #
  # This method is only expected to work on CRuby.
  #
  # The hash includes the following keys about the internal information in the GC:
  #
  # slot_size
  # :   The slot size of the heap in bytes.
  #
  # heap_allocatable_pages
  # :   The number of pages that can be allocated without triggering a new garbage
  #     collection cycle.
  #
  # heap_eden_pages
  # :   The number of pages in the eden heap.
  #
  # heap_eden_slots
  # :   The total number of slots in all of the pages in the eden heap.
  #
  # heap_tomb_pages
  # :   The number of pages in the tomb heap. The tomb heap only contains pages
  #     that do not have any live objects.
  #
  # heap_tomb_slots
  # :   The total number of slots in all of the pages in the tomb heap.
  #
  # total_allocated_pages
  # :   The total number of pages that have been allocated in the heap.
  #
  # total_freed_pages
  # :   The total number of pages that have been freed and released back to the
  #     system in the heap.
  #
  # force_major_gc_count
  # :   The number of times this heap has forced major garbage collection cycles
  #     to start due to running out of free slots.
  #
  # force_incremental_marking_finish_count
  # :   The number of times this heap has forced incremental marking to complete
  #     due to running out of pooled slots.
  #
  def self.stat_heap: (?Integer? heap_name, ?Hash[Symbol, untyped]? hash) -> Hash[Symbol, untyped]
                    | (Integer heap_name, Symbol key) -> Integer

  # <!--
  #   rdoc-file=gc.c
  #   - GC.latest_compact_info -> hash
  # -->
  # Returns information about object moved in the most recent GC compaction.
  #
  # The returned hash has two keys :considered and :moved.  The hash for
  # :considered lists the number of objects that were considered for movement by
  # the compactor, and the :moved hash lists the number of objects that were
  # actually moved.  Some objects can't be moved (maybe they were pinned) so these
  # numbers can be used to calculate compaction efficiency.
  #
  def self.latest_compact_info: () -> compact_info

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress -> integer, true, or false
  # -->
  # Returns the current status of GC stress mode.
  #
  def self.stress: () -> (Integer | bool)

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress = flag -> flag
  # -->
  # Updates the GC stress mode.
  #
  # When stress mode is enabled, the GC is invoked at every GC opportunity: all
  # memory and object allocations.
  #
  # Enabling stress mode will degrade performance; it is only for debugging.
  #
  # The flag can be true, false, or an integer bitwise-ORed with the following
  # flags:
  #     0x01:: no major GC
  #     0x02:: no immediate sweep
  #     0x04:: full mark after malloc/calloc/realloc
  #
  def self.stress=: (Integer flag) -> Integer
                  | (bool flag) -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.total_time -> int
  # -->
  # Returns the measured GC total time in nanoseconds.
  #
  def self.total_time: () -> Integer

  # <!--
  #   rdoc-file=gc.c
  #   - GC.compact
  # -->
  # This function compacts objects together in Ruby's heap.  It eliminates unused
  # space (or fragmentation) in the heap by moving objects in to that unused
  # space.  This function returns a hash which contains statistics about which
  # objects were moved.  See `GC.latest_gc_info` for details about compaction
  # statistics.
  #
  # This method is implementation specific and not expected to be implemented in
  # any implementation besides MRI.
  #
  # To test whether GC compaction is supported, use the idiom:
  #
  #     GC.respond_to?(:compact)
  #
  def self.compact: () -> compact_info

  # The type that `GC.compact` and related functions can return.
  #
  type compact_info = Hash[:considered | :moved |:moved_up | :moved_down, Hash[Symbol, Integer]]

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.verify_compaction_references(toward: nil, double_heap: false) -> hash
  # -->
  # Verify compaction reference consistency.
  #
  # This method is implementation specific.  During compaction, objects that were
  # moved are replaced with T_MOVED objects.  No object should have a reference to
  # a T_MOVED object after compaction.
  #
  # This function expands the heap to ensure room to move all objects, compacts
  # the heap to make sure everything moves, updates all references, then performs
  # a full GC.  If any object contains a reference to a T_MOVED object, that
  # object should be pushed on the mark stack, and will make a SEGV.
  #
  def self.verify_compaction_references: (?toward: :empty | untyped, ?double_heap: boolish, ?expand_heap: boolish) -> compact_info

  # <!--
  #   rdoc-file=gc.c
  #   - GC.verify_internal_consistency                  -> nil
  # -->
  # Verify internal consistency.
  #
  # This method is implementation specific. Now this method checks generational
  # consistency if RGenGC is supported.
  #
  def self.verify_internal_consistency: () -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.latest_gc_info -> hash
  #   - GC.latest_gc_info(hash) -> hash
  #   - GC.latest_gc_info(key) -> value
  # -->
  # Returns information about the most recent garbage collection.
  #
  # If the argument `hash` is given and is a Hash object, it is overwritten and
  # returned. This is intended to avoid the probe effect.
  #
  # If the argument `key` is given and is a Symbol object, it returns the value
  # associated with the key. This is equivalent to `GC.latest_gc_info[key]`.
  #
  def self.latest_gc_info: (?Hash[Symbol, untyped]? hash) -> Hash[Symbol, untyped]
                         | (Symbol key) -> untyped

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  # Alias of GC.start
  #
  def garbage_collect: (?immediate_sweep: boolish immediate_sweep, ?immediate_mark: boolish immediate_mark, ?full_mark: boolish full_mark) -> nil
end
# <!-- rdoc-file=lib/base64.rb -->
# Module Base64 provides methods for:
#
# *   Encoding a binary string (containing non-ASCII characters) as a string of
#     printable ASCII characters.
# *   Decoding such an encoded string.
#
# Base64 is commonly used in contexts where binary data is not allowed or
# supported:
#
# *   Images in HTML or CSS files, or in URLs.
# *   Email attachments.
#
# A Base64-encoded string is about one-third larger that its source. See the
# [Wikipedia article](https://en.wikipedia.org/wiki/Base64) for more
# information.
#
# This module provides three pairs of encode/decode methods. Your choices among
# these methods should depend on:
#
# *   Which character set is to be used for encoding and decoding.
# *   Whether "padding" is to be used.
# *   Whether encoded strings are to contain newlines.
#
# Note: Examples on this page assume that the including program has executed:
#
#     require 'base64'
#
# ## Encoding Character Sets
#
# A Base64-encoded string consists only of characters from a 64-character set:
#
# *   `('A'..'Z')`.
# *   `('a'..'z')`.
# *   `('0'..'9')`.
# *   `=`, the 'padding' character.
# *   Either:
#     *   `%w[+ /]`:
#         [RFC-2045-compliant](https://datatracker.ietf.org/doc/html/rfc2045);
#         *not* safe for URLs.
#     *   `%w[- _]`:
#         [RFC-4648-compliant](https://datatracker.ietf.org/doc/html/rfc4648);
#         safe for URLs.
#
# If you are working with Base64-encoded strings that will come from or be put
# into URLs, you should choose this encoder-decoder pair of RFC-4648-compliant
# methods:
#
# *   Base64.urlsafe_encode64 and Base64.urlsafe_decode64.
#
# Otherwise, you may choose any of the pairs in this module, including the pair
# above, or the RFC-2045-compliant pairs:
#
# *   Base64.encode64 and Base64.decode64.
# *   Base64.strict_encode64 and Base64.strict_decode64.
#
# ## Padding
#
# Base64-encoding changes a triplet of input bytes into a quartet of output
# characters.
#
# **Padding in Encode Methods**
#
# Padding -- extending an encoded string with zero, one, or two trailing `=`
# characters -- is performed by methods Base64.encode64, Base64.strict_encode64,
# and, by default, Base64.urlsafe_encode64:
#
#     Base64.encode64('s')                         # => "cw==\n"
#     Base64.strict_encode64('s')                  # => "cw=="
#     Base64.urlsafe_encode64('s')                 # => "cw=="
#     Base64.urlsafe_encode64('s', padding: false) # => "cw"
#
# When padding is performed, the encoded string is always of length *4n*, where
# `n` is a non-negative integer:
#
# *   Input bytes of length *3n* generate unpadded output characters of length
#     *4n*:
#
#         # n = 1:  3 bytes => 4 characters.
#         Base64.strict_encode64('123')      # => "MDEy"
#         # n = 2:  6 bytes => 8 characters.
#         Base64.strict_encode64('123456')   # => "MDEyMzQ1"
#
# *   Input bytes of length *3n+1* generate padded output characters of length
#     *4(n+1)*, with two padding characters at the end:
#
#         # n = 1:  4 bytes => 8 characters.
#         Base64.strict_encode64('1234')     # => "MDEyMw=="
#         # n = 2:  7 bytes => 12 characters.
#         Base64.strict_encode64('1234567')  # => "MDEyMzQ1Ng=="
#
# *   Input bytes of length *3n+2* generate padded output characters of length
#     *4(n+1)*, with one padding character at the end:
#
#         # n = 1:  5 bytes => 8 characters.
#         Base64.strict_encode64('12345')    # => "MDEyMzQ="
#         # n = 2:  8 bytes => 12 characters.
#         Base64.strict_encode64('12345678') # => "MDEyMzQ1Njc="
#
# When padding is suppressed, for a positive integer *n*:
#
# *   Input bytes of length *3n* generate unpadded output characters of length
#     *4n*:
#
#         # n = 1:  3 bytes => 4 characters.
#         Base64.urlsafe_encode64('123', padding: false)      # => "MDEy"
#         # n = 2:  6 bytes => 8 characters.
#         Base64.urlsafe_encode64('123456', padding: false)   # => "MDEyMzQ1"
#
# *   Input bytes of length *3n+1* generate unpadded output characters of length
#     *4n+2*, with two padding characters at the end:
#
#         # n = 1:  4 bytes => 6 characters.
#         Base64.urlsafe_encode64('1234', padding: false)     # => "MDEyMw"
#         # n = 2:  7 bytes => 10 characters.
#         Base64.urlsafe_encode64('1234567', padding: false)  # => "MDEyMzQ1Ng"
#
# *   Input bytes of length *3n+2* generate unpadded output characters of length
#     *4n+3*, with one padding character at the end:
#
#         # n = 1:  5 bytes => 7 characters.
#         Base64.urlsafe_encode64('12345', padding: false)    # => "MDEyMzQ"
#         # m = 2:  8 bytes => 11 characters.
#         Base64.urlsafe_encode64('12345678', padding: false) # => "MDEyMzQ1Njc"
#
# **Padding in Decode Methods**
#
# All of the Base64 decode methods support (but do not require) padding.
#
# Method Base64.decode64 does not check the size of the padding:
#
#     Base64.decode64("MDEyMzQ1Njc") # => "01234567"
#     Base64.decode64("MDEyMzQ1Njc=") # => "01234567"
#     Base64.decode64("MDEyMzQ1Njc==") # => "01234567"
#
# Method Base64.strict_decode64 strictly enforces padding size:
#
#     Base64.strict_decode64("MDEyMzQ1Njc")   # Raises ArgumentError
#     Base64.strict_decode64("MDEyMzQ1Njc=")  # => "01234567"
#     Base64.strict_decode64("MDEyMzQ1Njc==") # Raises ArgumentError
#
# Method Base64.urlsafe_decode64 allows padding in `str`, which if present, must
# be correct: see [Padding](Base64.html#module-Base64-label-Padding), above:
#
#     Base64.urlsafe_decode64("MDEyMzQ1Njc") # => "01234567"
#     Base64.urlsafe_decode64("MDEyMzQ1Njc=") # => "01234567"
#     Base64.urlsafe_decode64("MDEyMzQ1Njc==") # Raises ArgumentError.
#
# ## Newlines
#
# An encoded string returned by Base64.encode64 or Base64.urlsafe_encode64 has
# an embedded newline character after each 60-character sequence, and, if
# non-empty, at the end:
#
#     # No newline if empty.
#     encoded = Base64.encode64("\x00" *  0)
#     encoded.index("\n") # => nil
#
#     # Newline at end of short output.
#     encoded = Base64.encode64("\x00" *  1)
#     encoded.size        # => 4
#     encoded.index("\n") # => 4
#
#     # Newline at end of longer output.
#     encoded = Base64.encode64("\x00" * 45)
#     encoded.size        # => 60
#     encoded.index("\n") # => 60
#
#     # Newlines embedded and at end of still longer output.
#     encoded = Base64.encode64("\x00" * 46)
#     encoded.size                          # => 65
#     encoded.rindex("\n")                  # => 65
#     encoded.split("\n").map {|s| s.size } # => [60, 4]
#
# The string to be encoded may itself contain newlines, which are encoded as
# Base64:
#
#       #   Base64.encode64("\n\n\n") # => "CgoK\n"
#     s = "This is line 1\nThis is line 2\n"
#     Base64.encode64(s) # => "VGhpcyBpcyBsaW5lIDEKVGhpcyBpcyBsaW5lIDIK\n"
#
module Base64
  # <!--
  #   rdoc-file=lib/base64.rb
  #   - decode64(str)
  # -->
  # Returns a string containing the decoding of an RFC-2045-compliant
  # Base64-encoded string `str`:
  #
  #     s = "VGhpcyBpcyBsaW5lIDEKVGhpcyBpcyBsaW5lIDIK\n"
  #     Base64.decode64(s) # => "This is line 1\nThis is line 2\n"
  #
  # Non-Base64 characters in `str` are ignored; see [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above: these
  # include newline characters and characters `-` and `/`:
  #
  #     Base64.decode64("\x00\n-_") # => ""
  #
  # Padding in `str` (even if incorrect) is ignored:
  #
  #     Base64.decode64("MDEyMzQ1Njc")   # => "01234567"
  #     Base64.decode64("MDEyMzQ1Njc=")  # => "01234567"
  #     Base64.decode64("MDEyMzQ1Njc==") # => "01234567"
  #
  def self?.decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - encode64(bin)
  # -->
  # Returns a string containing the RFC-2045-compliant Base64-encoding of `bin`.
  #
  # Per RFC 2045, the returned string may contain the URL-unsafe characters `+` or
  # `/`; see [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above:
  #
  #     Base64.encode64("\xFB\xEF\xBE") # => "++++\n"
  #     Base64.encode64("\xFF\xFF\xFF") # => "////\n"
  #
  # The returned string may include padding; see
  # [Padding](Base64.html#module-Base64-label-Padding) above.
  #
  #     Base64.encode64('*') # => "Kg==\n"
  #
  # The returned string ends with a newline character, and if sufficiently long
  # will have one or more embedded newline characters; see
  # [Newlines](Base64.html#module-Base64-label-Newlines) above:
  #
  #     Base64.encode64('*') # => "Kg==\n"
  #     Base64.encode64('*' * 46)
  #     # => "KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq\nKg==\n"
  #
  # The string to be encoded may itself contain newlines, which will be encoded as
  # ordinary Base64:
  #
  #     Base64.encode64("\n\n\n") # => "CgoK\n"
  #     s = "This is line 1\nThis is line 2\n"
  #     Base64.encode64(s) # => "VGhpcyBpcyBsaW5lIDEKVGhpcyBpcyBsaW5lIDIK\n"
  #
  def self?.encode64: (String bin) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - strict_decode64(str)
  # -->
  # Returns a string containing the decoding of an RFC-2045-compliant
  # Base64-encoded string `str`:
  #
  #     s = "VGhpcyBpcyBsaW5lIDEKVGhpcyBpcyBsaW5lIDIK"
  #     Base64.strict_decode64(s) # => "This is line 1\nThis is line 2\n"
  #
  # Non-Base64 characters in `str` not allowed; see [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above: these
  # include newline characters and characters `-` and `/`:
  #
  #     Base64.strict_decode64("\n") # Raises ArgumentError
  #     Base64.strict_decode64('-')  # Raises ArgumentError
  #     Base64.strict_decode64('_')  # Raises ArgumentError
  #
  # Padding in `str`, if present, must be correct:
  #
  #     Base64.strict_decode64("MDEyMzQ1Njc")   # Raises ArgumentError
  #     Base64.strict_decode64("MDEyMzQ1Njc=")  # => "01234567"
  #     Base64.strict_decode64("MDEyMzQ1Njc==") # Raises ArgumentError
  #
  def self?.strict_decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - strict_encode64(bin)
  # -->
  # Returns a string containing the RFC-2045-compliant Base64-encoding of `bin`.
  #
  # Per RFC 2045, the returned string may contain the URL-unsafe characters `+` or
  # `/`; see [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above:
  #
  #     Base64.strict_encode64("\xFB\xEF\xBE") # => "++++\n"
  #     Base64.strict_encode64("\xFF\xFF\xFF") # => "////\n"
  #
  # The returned string may include padding; see
  # [Padding](Base64.html#module-Base64-label-Padding) above.
  #
  #     Base64.strict_encode64('*') # => "Kg==\n"
  #
  # The returned string will have no newline characters, regardless of its length;
  # see [Newlines](Base64.html#module-Base64-label-Newlines) above:
  #
  #     Base64.strict_encode64('*') # => "Kg=="
  #     Base64.strict_encode64('*' * 46)
  #     # => "KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg=="
  #
  # The string to be encoded may itself contain newlines, which will be encoded as
  # ordinary Base64:
  #
  #     Base64.strict_encode64("\n\n\n") # => "CgoK"
  #     s = "This is line 1\nThis is line 2\n"
  #     Base64.strict_encode64(s) # => "VGhpcyBpcyBsaW5lIDEKVGhpcyBpcyBsaW5lIDIK"
  #
  def self?.strict_encode64: (String bin) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - urlsafe_decode64(str)
  # -->
  # Returns the decoding of an RFC-4648-compliant Base64-encoded string `str`:
  #
  # `str` may not contain non-Base64 characters; see [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above:
  #
  #     Base64.urlsafe_decode64('+')  # Raises ArgumentError.
  #     Base64.urlsafe_decode64('/')  # Raises ArgumentError.
  #     Base64.urlsafe_decode64("\n") # Raises ArgumentError.
  #
  # Padding in `str`, if present, must be correct: see
  # [Padding](Base64.html#module-Base64-label-Padding), above:
  #
  #     Base64.urlsafe_decode64("MDEyMzQ1Njc") # => "01234567"
  #     Base64.urlsafe_decode64("MDEyMzQ1Njc=") # => "01234567"
  #     Base64.urlsafe_decode64("MDEyMzQ1Njc==") # Raises ArgumentError.
  #
  def self?.urlsafe_decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - urlsafe_encode64(bin, padding: true)
  # -->
  # Returns the RFC-4648-compliant Base64-encoding of `bin`.
  #
  # Per RFC 4648, the returned string will not contain the URL-unsafe characters
  # `+` or `/`, but instead may contain the URL-safe characters `-` and `_`; see
  # [Encoding Character
  # Set](Base64.html#module-Base64-label-Encoding+Character+Sets) above:
  #
  #     Base64.urlsafe_encode64("\xFB\xEF\xBE") # => "----"
  #     Base64.urlsafe_encode64("\xFF\xFF\xFF") # => "____"
  #
  # By default, the returned string may have padding; see
  # [Padding](Base64.html#module-Base64-label-Padding), above:
  #
  #     Base64.urlsafe_encode64('*') # => "Kg=="
  #
  # Optionally, you can suppress padding:
  #
  #     Base64.urlsafe_encode64('*', padding: false) # => "Kg"
  #
  # The returned string will have no newline characters, regardless of its length;
  # see [Newlines](Base64.html#module-Base64-label-Newlines) above:
  #
  #     Base64.urlsafe_encode64('*') # => "Kg=="
  #     Base64.urlsafe_encode64('*' * 46)
  #     # => "KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg=="
  #
  def self?.urlsafe_encode64: (String bin, ?padding: boolish) -> String
end
# <!-- rdoc-file=lib/benchmark.rb -->
# The Benchmark module provides methods to measure and report the time used to
# execute Ruby code.
#
# *   Measure the time to construct the string given by the expression
#     `"a"*1_000_000_000`:
#
#         require 'benchmark'
#
#         puts Benchmark.measure { "a"*1_000_000_000 }
#
#     On my machine (OSX 10.8.3 on i5 1.7 GHz) this generates:
#
#         0.350000   0.400000   0.750000 (  0.835234)
#
#     This report shows the user CPU time, system CPU time, the sum of the user
#     and system CPU times, and the elapsed real time. The unit of time is
#     seconds.
#
# *   Do some experiments sequentially using the #bm method:
#
#         require 'benchmark'
#
#         n = 5000000
#         Benchmark.bm do |x|
#           x.report { for i in 1..n; a = "1"; end }
#           x.report { n.times do   ; a = "1"; end }
#           x.report { 1.upto(n) do ; a = "1"; end }
#         end
#
#     The result:
#
#             user     system      total        real
#         1.010000   0.000000   1.010000 (  1.014479)
#         1.000000   0.000000   1.000000 (  0.998261)
#         0.980000   0.000000   0.980000 (  0.981335)
#
# *   Continuing the previous example, put a label in each report:
#
#         require 'benchmark'
#
#         n = 5000000
#         Benchmark.bm(7) do |x|
#           x.report("for:")   { for i in 1..n; a = "1"; end }
#           x.report("times:") { n.times do   ; a = "1"; end }
#           x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
#         end
#
# The result:
#
#                   user     system      total        real
#     for:      1.010000   0.000000   1.010000 (  1.015688)
#     times:    1.000000   0.000000   1.000000 (  1.003611)
#     upto:     1.030000   0.000000   1.030000 (  1.028098)
#
# *   The times for some benchmarks depend on the order in which items are run.
#     These differences are due to the cost of memory allocation and garbage
#     collection. To avoid these discrepancies, the #bmbm method is provided.
#     For example, to compare ways to sort an array of floats:
#
#         require 'benchmark'
#
#         array = (1..1000000).map { rand }
#
#         Benchmark.bmbm do |x|
#           x.report("sort!") { array.dup.sort! }
#           x.report("sort")  { array.dup.sort  }
#         end
#
#     The result:
#
#         Rehearsal -----------------------------------------
#         sort!   1.490000   0.010000   1.500000 (  1.490520)
#         sort    1.460000   0.000000   1.460000 (  1.463025)
#         -------------------------------- total: 2.960000sec
#
#                     user     system      total        real
#         sort!   1.460000   0.000000   1.460000 (  1.460465)
#         sort    1.450000   0.010000   1.460000 (  1.448327)
#
# *   Report statistics of sequential experiments with unique labels, using the
#     #benchmark method:
#
#         require 'benchmark'
#         include Benchmark         # we need the CAPTION and FORMAT constants
#
#         n = 5000000
#         Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
#           tf = x.report("for:")   { for i in 1..n; a = "1"; end }
#           tt = x.report("times:") { n.times do   ; a = "1"; end }
#           tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
#           [tf+tt+tu, (tf+tt+tu)/3]
#         end
#
#     The result:
#
#                      user     system      total        real
#         for:      0.950000   0.000000   0.950000 (  0.952039)
#         times:    0.980000   0.000000   0.980000 (  0.984938)
#         upto:     0.950000   0.000000   0.950000 (  0.946787)
#         >total:   2.880000   0.000000   2.880000 (  2.883764)
#         >avg:     0.960000   0.000000   0.960000 (  0.961255)
#
module Benchmark
  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - benchmark(caption = "", label_width = nil, format = nil, *labels) { |report| ... }
  # -->
  # Invokes the block with a Benchmark::Report object, which may be used to
  # collect and report on the results of individual benchmark tests. Reserves
  # `label_width` leading spaces for labels on each line. Prints `caption` at the
  # top of the report, and uses `format` to format each line. (Note: `caption`
  # must contain a terminating newline character, see the default
  # Benchmark::Tms::CAPTION for an example.)
  #
  # Returns an array of Benchmark::Tms objects.
  #
  # If the block returns an array of Benchmark::Tms objects, these will be used to
  # format additional lines of output. If `labels` parameter are given, these are
  # used to label these extra lines.
  #
  # *Note*: Other methods provide a simpler interface to this one, and are
  # suitable for nearly all benchmarking requirements.  See the examples in
  # Benchmark, and the #bm and #bmbm methods.
  #
  # Example:
  #
  #     require 'benchmark'
  #     include Benchmark          # we need the CAPTION and FORMAT constants
  #
  #     n = 5000000
  #     Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
  #       tf = x.report("for:")   { for i in 1..n; a = "1"; end }
  #       tt = x.report("times:") { n.times do   ; a = "1"; end }
  #       tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
  #       [tf+tt+tu, (tf+tt+tu)/3]
  #     end
  #
  # Generates:
  #
  #                   user     system      total        real
  #     for:      0.970000   0.000000   0.970000 (  0.970493)
  #     times:    0.990000   0.000000   0.990000 (  0.989542)
  #     upto:     0.970000   0.000000   0.970000 (  0.972854)
  #     >total:   2.930000   0.000000   2.930000 (  2.932889)
  #     >avg:     0.976667   0.000000   0.976667 (  0.977630)
  #
  def self?.benchmark: (String caption, ?Integer? label_width, ?String? format, *String labels) { (Report report) -> (Array[Tms] | untyped) } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - bm(label_width = 0, *labels) { |report| ... }
  # -->
  # A simple interface to the #benchmark method, #bm generates sequential reports
  # with labels. `label_width` and `labels` parameters have the same meaning as
  # for #benchmark.
  #
  #     require 'benchmark'
  #
  #     n = 5000000
  #     Benchmark.bm(7) do |x|
  #       x.report("for:")   { for i in 1..n; a = "1"; end }
  #       x.report("times:") { n.times do   ; a = "1"; end }
  #       x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
  #     end
  #
  # Generates:
  #
  #                   user     system      total        real
  #     for:      0.960000   0.000000   0.960000 (  0.957966)
  #     times:    0.960000   0.000000   0.960000 (  0.960423)
  #     upto:     0.950000   0.000000   0.950000 (  0.954864)
  #
  def self?.bm: (?Integer label_width, *String labels) { (Report report) -> void } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - bmbm(width = 0) { |job| ... }
  # -->
  # Sometimes benchmark results are skewed because code executed earlier
  # encounters different garbage collection overheads than that run later. #bmbm
  # attempts to minimize this effect by running the tests twice, the first time as
  # a rehearsal in order to get the runtime environment stable, the second time
  # for real. GC.start is executed before the start of each of the real timings;
  # the cost of this is not included in the timings. In reality, though, there's
  # only so much that #bmbm can do, and the results are not guaranteed to be
  # isolated from garbage collection and other effects.
  #
  # Because #bmbm takes two passes through the tests, it can calculate the
  # required label width.
  #
  #     require 'benchmark'
  #
  #     array = (1..1000000).map { rand }
  #
  #     Benchmark.bmbm do |x|
  #       x.report("sort!") { array.dup.sort! }
  #       x.report("sort")  { array.dup.sort  }
  #     end
  #
  # Generates:
  #
  #     Rehearsal -----------------------------------------
  #     sort!   1.440000   0.010000   1.450000 (  1.446833)
  #     sort    1.440000   0.000000   1.440000 (  1.448257)
  #     -------------------------------- total: 2.890000sec
  #
  #                 user     system      total        real
  #     sort!   1.460000   0.000000   1.460000 (  1.458065)
  #     sort    1.450000   0.000000   1.450000 (  1.455963)
  #
  # #bmbm yields a Benchmark::Job object and returns an array of Benchmark::Tms
  # objects.
  #
  def self?.bmbm: (?Integer width) { (Job job) -> void } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - measure(label = "") { || ... }
  # -->
  # Returns the time used to execute the given block as a Benchmark::Tms object.
  # Takes `label` option.
  #
  #     require 'benchmark'
  #
  #     n = 1000000
  #
  #     time = Benchmark.measure do
  #       n.times { a = "1" }
  #     end
  #     puts time
  #
  # Generates:
  #
  #     0.220000   0.000000   0.220000 (  0.227313)
  #
  def self?.measure: (?String label) { () -> void } -> Tms

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - realtime() { || ... }
  # -->
  # Returns the elapsed real time used to execute the given block. The unit of
  # time is seconds.
  #
  #     Benchmark.realtime { "a" * 1_000_000_000 }
  #     #=> 0.5098029999935534
  #
  def self?.realtime: () { () -> void } -> Float

  BENCHMARK_VERSION: String

  # <!-- rdoc-file=lib/benchmark.rb -->
  # The default caption string (heading above the output times).
  #
  CAPTION: String

  # <!-- rdoc-file=lib/benchmark.rb -->
  # The default format string used to display times.  See also
  # Benchmark::Tms#format.
  #
  FORMAT: String

  class Job
    # Prints the `label` and measured time for the block,
    # formatted by `format`. See Tms#format for the
    # formatting rules.
    def item: (?String label) { () -> void } -> self

    # An array of 2-element arrays, consisting of label and block pairs.
    def list: () -> Array[untyped]

    alias report item

    # Length of the widest label in the #list.
    def width: () -> Integer
  end

  class Report
    # Prints the `label` and measured time for the block,
    # formatted by `format`. See Tms#format for the
    # formatting rules.
    def item: (?String label, *untyped format) { () -> void } -> Tms

    # An array of Benchmark::Tms objects representing each item.
    def list: () -> Array[Tms]

    alias report item
  end

  # <!-- rdoc-file=lib/benchmark.rb -->
  # A data object, representing the times associated with a benchmark measurement.
  #
  class Tms
    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - *(x)
    # -->
    # Returns a new Tms object obtained by memberwise multiplication of the
    # individual times for this Tms object by `x`.
    #
    def *: (untyped x) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - +(other)
    # -->
    # Returns a new Tms object obtained by memberwise summation of the individual
    # times for this Tms object with those of the `other` Tms object. This method
    # and #/() are useful for taking statistics.
    #
    def +: (untyped other) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - -(other)
    # -->
    # Returns a new Tms object obtained by memberwise subtraction of the individual
    # times for the `other` Tms object from those of this Tms object.
    #
    def -: (untyped other) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - /(x)
    # -->
    # Returns a new Tms object obtained by memberwise division of the individual
    # times for this Tms object by `x`. This method and #+() are useful for taking
    # statistics.
    #
    def /: (untyped x) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - add() { || ... }
    # -->
    # Returns a new Tms object whose times are the sum of the times for this Tms
    # object, plus the time required to execute the code block (`blk`).
    #
    def add: () { (*untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - add!(&blk)
    # -->
    # An in-place version of #add. Changes the times of this Tms object by making it
    # the sum of the times for this Tms object, plus the time required to execute
    # the code block (`blk`).
    #
    def add!: () { (*untyped) -> untyped } -> untyped

    # <!-- rdoc-file=lib/benchmark.rb -->
    # System CPU time of children
    #
    def cstime: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # User CPU time of children
    #
    def cutime: () -> Float

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - format(format = nil, *args)
    # -->
    # Returns the contents of this Tms object as a formatted string, according to a
    # `format` string like that passed to Kernel.format. In addition, #format
    # accepts the following extensions:
    #
    # `%u`
    # :   Replaced by the user CPU time, as reported by Tms#utime.
    #
    # `%y`
    # :   Replaced by the system CPU time, as reported by #stime (Mnemonic: y of
    #     "s*y*stem")
    #
    # `%U`
    # :   Replaced by the children's user CPU time, as reported by Tms#cutime
    #
    # `%Y`
    # :   Replaced by the children's system CPU time, as reported by Tms#cstime
    #
    # `%t`
    # :   Replaced by the total CPU time, as reported by Tms#total
    #
    # `%r`
    # :   Replaced by the elapsed real time, as reported by Tms#real
    #
    # `%n`
    # :   Replaced by the label string, as reported by Tms#label (Mnemonic: n of
    #     "*n*ame")
    #
    #
    # If `format` is not given, FORMAT is used as default value, detailing the user,
    # system and real elapsed time.
    #
    def format: (?String format, *untyped args) -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Label
    #
    def label: () -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Elapsed real time
    #
    def real: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # System CPU time
    #
    def stime: () -> Float

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - to_a()
    # -->
    # Returns a new 6-element array, consisting of the label, user CPU time, system
    # CPU time, children's user CPU time, children's system CPU time and elapsed
    # real time.
    #
    def to_a: () -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - to_s()
    # -->
    # Same as #format.
    #
    def to_s: () -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Total time, that is `utime` + `stime` + `cutime` + `cstime`
    #
    def total: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # User CPU time
    #
    def utime: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Default caption, see also Benchmark::CAPTION
    #
    CAPTION: String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Default format string, see also Benchmark::FORMAT
    #
    FORMAT: String
  end
end
class BigDecimal < Numeric
  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - _load(p1)
  # -->
  # Internal method used to provide marshalling support. See the Marshal module.
  #
  def self._load: (String) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.double_fig -> integer
  # -->
  # Returns the number of digits a Float object is allowed to have; the result is
  # system-dependent:
  #
  #     BigDecimal.double_fig # => 16
  #
  def self.double_fig: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - interpret_loosely(p1)
  # -->
  #
  def self.interpret_loosely: (string) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.limit(digits)
  # -->
  # Limit the number of significant digits in newly created BigDecimal numbers to
  # the specified value. Rounding is performed as necessary, as specified by
  # BigDecimal.mode.
  #
  # A limit of 0, the default, means no upper limit.
  #
  # The limit specified by this method takes less priority over any limit
  # specified to instance methods such as ceil, floor, truncate, or round.
  #
  def self.limit: (?Integer? digits) -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.mode(mode, setting = nil) -> integer
  # -->
  # Returns an integer representing the mode settings for exception handling and
  # rounding.
  #
  # These modes control exception handling:
  #
  # *   BigDecimal::EXCEPTION_NaN.
  # *   BigDecimal::EXCEPTION_INFINITY.
  # *   BigDecimal::EXCEPTION_UNDERFLOW.
  # *   BigDecimal::EXCEPTION_OVERFLOW.
  # *   BigDecimal::EXCEPTION_ZERODIVIDE.
  # *   BigDecimal::EXCEPTION_ALL.
  #
  # Values for `setting` for exception handling:
  #
  # *   `true`: sets the given `mode` to `true`.
  # *   `false`: sets the given `mode` to `false`.
  # *   `nil`: does not modify the mode settings.
  #
  # You can use method BigDecimal.save_exception_mode to temporarily change, and
  # then automatically restore, exception modes.
  #
  # For clarity, some examples below begin by setting all exception modes to
  # `false`.
  #
  # This mode controls the way rounding is to be performed:
  #
  # *   BigDecimal::ROUND_MODE
  #
  # You can use method BigDecimal.save_rounding_mode to temporarily change, and
  # then automatically restore, the rounding mode.
  #
  # **NaNs**
  #
  # Mode BigDecimal::EXCEPTION_NaN controls behavior when a BigDecimal NaN is
  # created.
  #
  # Settings:
  #
  # *   `false` (default): Returns `BigDecimal('NaN')`.
  # *   `true`: Raises FloatDomainError.
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
  #     BigDecimal('NaN')                                 # => NaN
  #     BigDecimal.mode(BigDecimal::EXCEPTION_NaN, true)  # => 2
  #     BigDecimal('NaN') # Raises FloatDomainError
  #
  # **Infinities**
  #
  # Mode BigDecimal::EXCEPTION_INFINITY controls behavior when a BigDecimal
  # Infinity or -Infinity is created. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
  #     BigDecimal('Infinity')                                # => Infinity
  #     BigDecimal('-Infinity')                               # => -Infinity
  #     BigDecimal.mode(BigDecimal::EXCEPTION_INFINITY, true) # => 1
  #     BigDecimal('Infinity')  # Raises FloatDomainError
  #     BigDecimal('-Infinity') # Raises FloatDomainError
  #
  # **Underflow**
  #
  # Mode BigDecimal::EXCEPTION_UNDERFLOW controls behavior when a BigDecimal
  # underflow occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('0')` or `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)      # => 0
  #     def flow_under
  #       x = BigDecimal('0.1')
  #       100.times { x *= x }
  #     end
  #     flow_under                                             # => 100
  #     BigDecimal.mode(BigDecimal::EXCEPTION_UNDERFLOW, true) # => 4
  #     flow_under # Raises FloatDomainError
  #
  # **Overflow**
  #
  # Mode BigDecimal::EXCEPTION_OVERFLOW controls behavior when a BigDecimal
  # overflow occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
  #     def flow_over
  #       x = BigDecimal('10')
  #       100.times { x *= x }
  #     end
  #     flow_over                                             # => 100
  #     BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, true) # => 1
  #     flow_over # Raises FloatDomainError
  #
  # **Zero Division**
  #
  # Mode BigDecimal::EXCEPTION_ZERODIVIDE controls behavior when a zero-division
  # occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)       # => 0
  #     one = BigDecimal('1')
  #     zero = BigDecimal('0')
  #     one / zero                                              # => Infinity
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ZERODIVIDE, true) # => 16
  #     one / zero # Raises FloatDomainError
  #
  # **All Exceptions**
  #
  # Mode BigDecimal::EXCEPTION_ALL controls all of the above:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, true)  # => 23
  #
  # **Rounding**
  #
  # Mode BigDecimal::ROUND_MODE controls the way rounding is to be performed; its
  # `setting` values are:
  #
  # *   `ROUND_UP`: Round away from zero. Aliased as `:up`.
  # *   `ROUND_DOWN`: Round toward zero. Aliased as `:down` and `:truncate`.
  # *   `ROUND_HALF_UP`: Round toward the nearest neighbor; if the neighbors are
  #     equidistant, round away from zero. Aliased as `:half_up` and `:default`.
  # *   `ROUND_HALF_DOWN`: Round toward the nearest neighbor; if the neighbors are
  #     equidistant, round toward zero. Aliased as `:half_down`.
  # *   `ROUND_HALF_EVEN` (Banker's rounding): Round toward the nearest neighbor;
  #     if the neighbors are equidistant, round toward the even neighbor. Aliased
  #     as `:half_even` and `:banker`.
  # *   `ROUND_CEILING`: Round toward positive infinity. Aliased as `:ceiling` and
  #     `:ceil`.
  # *   `ROUND_FLOOR`: Round toward negative infinity. Aliased as `:floor:`.
  #
  def self.mode: (Integer mode, ?Integer? value) -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_exception_mode { ... }
  # -->
  # Execute the provided block, but preserve the exception mode
  #
  #     BigDecimal.save_exception_mode do
  #       BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, false)
  #       BigDecimal.mode(BigDecimal::EXCEPTION_NaN, false)
  #
  #       BigDecimal(BigDecimal('Infinity'))
  #       BigDecimal(BigDecimal('-Infinity'))
  #       BigDecimal(BigDecimal('NaN'))
  #     end
  #
  # For use with the BigDecimal::EXCEPTION_*
  #
  # See BigDecimal.mode
  #
  def self.save_exception_mode: () { (?nil) -> void } -> void

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_limit { ... }
  # -->
  # Execute the provided block, but preserve the precision limit
  #
  #     BigDecimal.limit(100)
  #     puts BigDecimal.limit
  #     BigDecimal.save_limit do
  #         BigDecimal.limit(200)
  #         puts BigDecimal.limit
  #     end
  #     puts BigDecimal.limit
  #
  def self.save_limit: () { (?nil) -> void } -> void

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_rounding_mode { ... }
  # -->
  # Execute the provided block, but preserve the rounding mode
  #
  #     BigDecimal.save_rounding_mode do
  #       BigDecimal.mode(BigDecimal::ROUND_MODE, :up)
  #       puts BigDecimal.mode(BigDecimal::ROUND_MODE)
  #     end
  #
  # For use with the BigDecimal::ROUND_*
  #
  # See BigDecimal.mode
  #
  def self.save_rounding_mode: () { (?nil) -> void } -> void

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - a % b
  #   - a.modulo(b)
  # -->
  # Returns the modulus from dividing by b.
  #
  # See BigDecimal#divmod.
  #
  def %: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - *(p1)
  # -->
  #
  def *: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self ** other -> bigdecimal
  # -->
  # Returns the BigDecimal value of `self` raised to power `other`:
  #
  #     b = BigDecimal('3.14')
  #     b ** 2              # => 0.98596e1
  #     b ** 2.0            # => 0.98596e1
  #     b ** Rational(2, 1) # => 0.98596e1
  #
  # Related: BigDecimal#power.
  #
  def **: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self + value -> bigdecimal
  # -->
  # Returns the BigDecimal sum of `self` and `value`:
  #
  #     b = BigDecimal('111111.111') # => 0.111111111e6
  #     b + 2                        # => 0.111113111e6
  #     b + 2.0                      # => 0.111113111e6
  #     b + Rational(2, 1)           # => 0.111113111e6
  #     b + Complex(2, 0)            # => (0.111113111e6+0i)
  #
  # See the [Note About
  # Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).
  #
  def +: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - +big_decimal -> self
  # -->
  # Returns `self`:
  #
  #     +BigDecimal(5)  # => 0.5e1
  #     +BigDecimal(-5) # => -0.5e1
  #
  def +@: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self - value -> bigdecimal
  # -->
  # Returns the BigDecimal difference of `self` and `value`:
  #
  #     b = BigDecimal('333333.333') # => 0.333333333e6
  #     b - 2                        # => 0.333331333e6
  #     b - 2.0                      # => 0.333331333e6
  #     b - Rational(2, 1)           # => 0.333331333e6
  #     b - Complex(2, 0)            # => (0.333331333e6+0i)
  #
  # See the [Note About
  # Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).
  #
  def -: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - -self -> bigdecimal
  # -->
  # Returns the BigDecimal negation of self:
  #
  #     b0 = BigDecimal('1.5')
  #     b1 = -b0 # => -0.15e1
  #     b2 = -b1 # => 0.15e1
  #
  def -@: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - a / b   -> bigdecimal
  # -->
  # Divide by the specified value.
  #
  # The result precision will be the precision of the larger operand, but its
  # minimum is 2*Float::DIG.
  #
  # See BigDecimal#div. See BigDecimal#quo.
  #
  def /: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if `self` is less than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5') # => 0.15e1
  #     b < 2                 # => true
  #     b < 2.0               # => true
  #     b < Rational(2, 1)    # => true
  #     b < 1.5               # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self <= other -> true or false
  # -->
  # Returns `true` if `self` is less or equal to than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5') # => 0.15e1
  #     b <= 2                # => true
  #     b <= 2.0              # => true
  #     b <= Rational(2, 1)   # => true
  #     b <= 1.5              # => true
  #     b < 1                 # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - <=>(p1)
  # -->
  # The comparison operator. a <=> b is 0 if a == b, 1 if a > b, -1 if a < b.
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - ==(p1)
  # -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if `self` is greater than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5')
  #     b > 1              # => true
  #     b > 1.0            # => true
  #     b > Rational(1, 1) # => true
  #     b > 2              # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self >= other -> true or false
  # -->
  # Returns `true` if `self` is greater than or equal to `other`, `false`
  # otherwise:
  #
  #     b = BigDecimal('1.5')
  #     b >= 1              # => true
  #     b >= 1.0            # => true
  #     b >= Rational(1, 1) # => true
  #     b >= 1.5            # => true
  #     b > 2               # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - _dump -> string
  # -->
  # Returns a string representing the marshalling of `self`. See module Marshal.
  #
  #     inf = BigDecimal('Infinity') # => Infinity
  #     dumped = inf._dump           # => "9:Infinity"
  #     BigDecimal._load(dumped)     # => Infinity
  #
  def _dump: (?untyped) -> String

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - abs -> bigdecimal
  # -->
  # Returns the BigDecimal absolute value of `self`:
  #
  #     BigDecimal('5').abs  # => 0.5e1
  #     BigDecimal('-3').abs # => 0.3e1
  #
  def abs: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - add(value, ndigits) -> new_bigdecimal
  # -->
  # Returns the BigDecimal sum of `self` and `value` with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is less than the number of significant digits in the sum, the
  # sum is rounded to that number of digits, according to the current rounding
  # mode; see BigDecimal.mode.
  #
  # Examples:
  #
  #     # Set the rounding mode.
  #     BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
  #     b = BigDecimal('111111.111')
  #     b.add(1, 0)               # => 0.111112111e6
  #     b.add(1, 3)               # => 0.111e6
  #     b.add(1, 6)               # => 0.111112e6
  #     b.add(1, 15)              # => 0.111112111e6
  #     b.add(1.0, 15)            # => 0.111112111e6
  #     b.add(Rational(1, 1), 15) # => 0.111112111e6
  #
  def add: (Numeric value, Integer digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - ceil(n)
  # -->
  # Return the smallest integer greater than or equal to the value, as a
  # BigDecimal.
  #
  #     BigDecimal('3.14159').ceil #=> 4
  #     BigDecimal('-9.1').ceil #=> -9
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').ceil(3) #=> 3.142
  #     BigDecimal('13345.234').ceil(-2) #=> 13400.0
  #
  def ceil: () -> Integer
          | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - clone()
  # -->
  #
  def clone: () -> self

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - coerce(p1)
  # -->
  # The coerce method provides support for Ruby type coercion. It is not enabled
  # by default.
  #
  # This means that binary operations like + * / or - can often be performed on a
  # BigDecimal and an object of another type, if the other object can be coerced
  # into a BigDecimal value.
  #
  # e.g.
  #     a = BigDecimal("1.0")
  #     b = a / 2.0 #=> 0.5
  #
  # Note that coercing a String to a BigDecimal is not supported by default; it
  # requires a special compile-time option when building Ruby.
  #
  def coerce: (Numeric) -> [ BigDecimal, BigDecimal ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - div(value)  -> integer
  #   - div(value, digits)  -> bigdecimal or integer
  # -->
  # Divide by the specified value.
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to that number of digits, according to
  #     BigDecimal.mode.
  #
  #     If digits is 0, the result is the same as for the / operator or #quo.
  #
  #     If digits is not specified, the result is an integer, by analogy with
  #     Float#div; see also BigDecimal#divmod.
  #
  #
  # See BigDecimal#/. See BigDecimal#quo.
  #
  # Examples:
  #
  #     a = BigDecimal("4")
  #     b = BigDecimal("3")
  #
  #     a.div(b, 3)  # => 0.133e1
  #
  #     a.div(b, 0)  # => 0.1333333333333333333e1
  #     a / b        # => 0.1333333333333333333e1
  #     a.quo(b)     # => 0.1333333333333333333e1
  #
  #     a.div(b)     # => 1
  #
  def div: (Numeric value) -> Integer
         | (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - divmod(value)
  # -->
  # Divides by the specified value, and returns the quotient and modulus as
  # BigDecimal numbers. The quotient is rounded towards negative infinity.
  #
  # For example:
  #
  #     require 'bigdecimal'
  #
  #     a = BigDecimal("42")
  #     b = BigDecimal("9")
  #
  #     q, m = a.divmod(b)
  #
  #     c = q * b + m
  #
  #     a == c  #=> true
  #
  # The quotient q is (a/b).floor, and the modulus is the amount that must be
  # added to q * b to get a.
  #
  def divmod: (Numeric) -> [ BigDecimal, BigDecimal ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - dup()
  # -->
  #
  def dup: () -> self

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - exponent()
  # -->
  # Returns the exponent of the BigDecimal number, as an Integer.
  #
  # If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of
  # digits with no leading zeros, then n is the exponent.
  #
  def exponent: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - finite?()
  # -->
  # Returns True if the value is finite (not NaN or infinite).
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - fix()
  # -->
  # Return the integer part of the number, as a BigDecimal.
  #
  def fix: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - floor(n)
  # -->
  # Return the largest integer less than or equal to the value, as a BigDecimal.
  #
  #     BigDecimal('3.14159').floor #=> 3
  #     BigDecimal('-9.1').floor #=> -10
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').floor(3) #=> 3.141
  #     BigDecimal('13345.234').floor(-2) #=> 13300.0
  #
  def floor: () -> Integer
           | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - frac()
  # -->
  # Return the fractional part of the number, as a BigDecimal.
  #
  def frac: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two instances of BigDecimal have the same hash value if and only if they have
  # equal:
  #
  # *   Sign.
  # *   Fractional part.
  # *   Exponent.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - infinite?()
  # -->
  # Returns nil, -1, or +1 depending on whether the value is finite, -Infinity, or
  # +Infinity.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - inspect()
  # -->
  # Returns a string representation of self.
  #
  #     BigDecimal("1234.5678").inspect
  #       #=> "0.12345678e4"
  #
  def inspect: () -> String

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Returns the modulus from dividing by b.
  #
  # See BigDecimal#divmod.
  #
  def modulo: (Numeric b) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - mult(other, ndigits) -> bigdecimal
  # -->
  # Returns the BigDecimal product of `self` and `value` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is less than the number of significant digits in the sum, the
  # sum is rounded to that number of digits, according to the current rounding
  # mode; see BigDecimal.mode.
  #
  # Examples:
  #
  #     # Set the rounding mode.
  #     BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
  #     b = BigDecimal('555555.555')
  #     b.mult(3, 0)              # => 0.1666666665e7
  #     b.mult(3, 3)              # => 0.167e7
  #     b.mult(3, 6)              # => 0.166667e7
  #     b.mult(3, 15)             # => 0.1666666665e7
  #     b.mult(3.0, 0)            # => 0.1666666665e7
  #     b.mult(Rational(3, 1), 0) # => 0.1666666665e7
  #     b.mult(Complex(3, 0), 0)  # => (0.1666666665e7+0.0i)
  #
  def mult: (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - nan?()
  # -->
  # Returns True if the value is Not a Number.
  #
  def nan?: () -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - nonzero?()
  # -->
  # Returns self if the value is non-zero, nil otherwise.
  #
  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - power(n)
  #   - power(n, prec)
  # -->
  # Returns the value raised to the power of n.
  #
  # Note that n must be an Integer.
  #
  # Also available as the operator **.
  #
  def power: (Numeric n, int prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - precs -> array
  # -->
  # Returns an Array of two Integer values that represent platform-dependent
  # internal storage properties.
  #
  # This method is deprecated and will be removed in the future. Instead, use
  # BigDecimal#n_significant_digits for obtaining the number of significant digits
  # in scientific notation, and BigDecimal#precision for obtaining the number of
  # digits in decimal notation.
  #
  def precs: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - quo(value)  -> bigdecimal
  #   - quo(value, digits)  -> bigdecimal
  # -->
  # Divide by the specified value.
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to the given number of digits, according to the
  #     rounding mode indicated by BigDecimal.mode.
  #
  #     If digits is 0 or omitted, the result is the same as for the / operator.
  #
  #
  # See BigDecimal#/. See BigDecimal#div.
  #
  def quo: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - remainder(value)
  # -->
  # Returns the remainder from dividing by the value.
  #
  # x.remainder(y) means x-y*(x/y).truncate
  #
  def remainder: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - round(n, mode)
  # -->
  # Round to the nearest integer (by default), returning the result as a
  # BigDecimal if n is specified, or as an Integer if it isn't.
  #
  #     BigDecimal('3.14159').round #=> 3
  #     BigDecimal('8.7').round #=> 9
  #     BigDecimal('-9.9').round #=> -10
  #
  #     BigDecimal('3.14159').round(2).class.name #=> "BigDecimal"
  #     BigDecimal('3.14159').round.class.name #=> "Integer"
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result, and return value will be an Integer.
  #
  #     BigDecimal('3.14159').round(3) #=> 3.142
  #     BigDecimal('13345.234').round(-2) #=> 13300
  #
  # The value of the optional mode argument can be used to determine how rounding
  # is performed; see BigDecimal.mode.
  #
  def round: () -> Integer
           | (Numeric n, ?Integer mode) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sign()
  # -->
  # Returns the sign of the value.
  #
  # Returns a positive value if > 0, a negative value if < 0. It behaves the same
  # with zeros - it returns a positive value for a positive zero (BigDecimal('0'))
  # and a negative value for a negative zero (BigDecimal('-0')).
  #
  # The specific value returned indicates the type and sign of the BigDecimal, as
  # follows:
  #
  # BigDecimal::SIGN_NaN
  # :   value is Not a Number
  #
  # BigDecimal::SIGN_POSITIVE_ZERO
  # :   value is +0
  #
  # BigDecimal::SIGN_NEGATIVE_ZERO
  # :   value is -0
  #
  # BigDecimal::SIGN_POSITIVE_INFINITE
  # :   value is +Infinity
  #
  # BigDecimal::SIGN_NEGATIVE_INFINITE
  # :   value is -Infinity
  #
  # BigDecimal::SIGN_POSITIVE_FINITE
  # :   value is positive
  #
  # BigDecimal::SIGN_NEGATIVE_FINITE
  # :   value is negative
  #
  def sign: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - split()
  # -->
  # Splits a BigDecimal number into four parts, returned as an array of values.
  #
  # The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if
  # the BigDecimal is Not a Number.
  #
  # The second value is a string representing the significant digits of the
  # BigDecimal, with no leading zeros.
  #
  # The third value is the base used for arithmetic (currently always 10) as an
  # Integer.
  #
  # The fourth value is an Integer exponent.
  #
  # If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the
  # string of significant digits with no leading zeros, and n is the exponent.
  #
  # From these values, you can translate a BigDecimal to a float as follows:
  #
  #     sign, significant_digits, base, exponent = a.split
  #     f = sign * "0.#{significant_digits}".to_f * (base ** exponent)
  #
  # (Note that the to_f method is provided as a more convenient way to translate a
  # BigDecimal to a Float.)
  #
  def split: () -> [ Integer, String, Integer, Integer ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sqrt(n)
  # -->
  # Returns the square root of the value.
  #
  # Result has at least n significant digits.
  #
  def sqrt: (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sub(value, digits)  -> bigdecimal
  # -->
  # Subtract the specified value.
  #
  # e.g.
  #     c = a.sub(b,n)
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to that number of digits, according to
  #     BigDecimal.mode.
  #
  def sub: (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_f()
  # -->
  # Returns a new Float object having approximately the same value as the
  # BigDecimal number. Normal accuracy limits and built-in errors of binary Float
  # arithmetic apply.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_i()
  # -->
  # Returns the value as an Integer.
  #
  # If the BigDecimal is infinity or NaN, raises FloatDomainError.
  #
  def to_i: () -> Integer

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Returns the value as an Integer.
  #
  # If the BigDecimal is infinity or NaN, raises FloatDomainError.
  #
  def to_int: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_r()
  # -->
  # Converts a BigDecimal to a Rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_s(s)
  # -->
  # Converts the value to a string.
  #
  # The default format looks like  0.xxxxEnn.
  #
  # The optional parameter s consists of either an integer; or an optional '+' or
  # ' ', followed by an optional number, followed by an optional 'E' or 'F'.
  #
  # If there is a '+' at the start of s, positive values are returned with a
  # leading '+'.
  #
  # A space at the start of s returns positive values with a leading space.
  #
  # If s contains a number, a space is inserted after each group of that many
  # digits, starting from '.' and counting outwards.
  #
  # If s ends with an 'E', engineering notation (0.xxxxEnn) is used.
  #
  # If s ends with an 'F', conventional floating point notation is used.
  #
  # Examples:
  #
  #     BigDecimal('-1234567890123.45678901234567890').to_s('5F')
  #       #=> '-123 45678 90123.45678 90123 45678 9'
  #
  #     BigDecimal('1234567890123.45678901234567890').to_s('+8F')
  #       #=> '+12345 67890123.45678901 23456789'
  #
  #     BigDecimal('1234567890123.45678901234567890').to_s(' F')
  #       #=> ' 1234567890123.4567890123456789'
  #
  def to_s: (?String | int s) -> String

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - truncate(n)
  # -->
  # Truncate to the nearest integer (by default), returning the result as a
  # BigDecimal.
  #
  #     BigDecimal('3.14159').truncate #=> 3
  #     BigDecimal('8.7').truncate #=> 8
  #     BigDecimal('-9.9').truncate #=> -9
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').truncate(3) #=> 3.141
  #     BigDecimal('13345.234').truncate(-2) #=> 13300.0
  #
  def truncate: () -> Integer
              | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - zero?()
  # -->
  # Returns True if the value is zero.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - a.to_d -> bigdecimal
  # -->
  # Returns self.
  #
  #     require 'bigdecimal/util'
  #
  #     d = BigDecimal("3.14")
  #     d.to_d                       # => 0.314e1
  #
  def to_d: () -> BigDecimal

  private

  def initialize_copy: (self) -> self
end

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Base value used in internal calculations.  On a 32 bit system, BASE is 10000,
# indicating that calculation is done in groups of 4 digits. (If it were larger,
# BASE**2 wouldn't fit in 32 bits, so you couldn't guarantee that two groups
# could always be multiplied together without overflow.)
#
BigDecimal::BASE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines whether overflow, underflow or zero divide result in an exception
# being thrown. See BigDecimal.mode.
#
BigDecimal::EXCEPTION_ALL: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is infinity.  See
# BigDecimal.mode.
#
BigDecimal::EXCEPTION_INFINITY: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is not a number
# (NaN). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_NaN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is an overflow (a
# result too large to be represented). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_OVERFLOW: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is an underflow (a
# result too small to be represented). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_UNDERFLOW: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when a division by zero is performed. See
# BigDecimal.mode.
#
BigDecimal::EXCEPTION_ZERODIVIDE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Special value constants
#
BigDecimal::INFINITY: BigDecimal

BigDecimal::NAN: BigDecimal

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards +Infinity. See BigDecimal.mode.
#
BigDecimal::ROUND_CEILING: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that values should be rounded towards zero. See BigDecimal.mode.
#
BigDecimal::ROUND_DOWN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards -Infinity. See BigDecimal.mode.
#
BigDecimal::ROUND_FLOOR: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that digits >= 6 should be rounded up, others rounded down. See
# BigDecimal.mode.
#
BigDecimal::ROUND_HALF_DOWN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards the even neighbor. See BigDecimal.mode.
#
BigDecimal::ROUND_HALF_EVEN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that digits >= 5 should be rounded up, others rounded down. See
# BigDecimal.mode.
#
BigDecimal::ROUND_HALF_UP: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when a result must be rounded in order to fit in the
# appropriate number of significant digits. See BigDecimal.mode.
#
BigDecimal::ROUND_MODE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that values should be rounded away from zero. See BigDecimal.mode.
#
BigDecimal::ROUND_UP: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is negative and finite. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_FINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is negative and infinite. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_INFINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is -0. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_ZERO: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is not a number. See BigDecimal.sign.
#
BigDecimal::SIGN_NaN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is positive and finite. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_FINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is positive and infinite. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_INFINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is +0. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_ZERO: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# The version of bigdecimal library
#
BigDecimal::VERSION: String

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal(value, exception: true) -> bigdecimal
  #   - BigDecimal(value, ndigits, exception: true) -> bigdecimal
  # -->
  # Returns the BigDecimal converted from `value` with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is less than the number of significant digits in the value, the
  # result is rounded to that number of digits, according to the current rounding
  # mode; see BigDecimal.mode.
  #
  # When `ndigits` is 0, the number of digits to correctly represent a float
  # number is determined automatically.
  #
  # Returns `value` converted to a BigDecimal, depending on the type of `value`:
  #
  # *   Integer, Float, Rational, Complex, or BigDecimal: converted directly:
  #
  #         # Integer, Complex, or BigDecimal value does not require ndigits; ignored if given.
  #         BigDecimal(2)                     # => 0.2e1
  #         BigDecimal(Complex(2, 0))         # => 0.2e1
  #         BigDecimal(BigDecimal(2))         # => 0.2e1
  #         # Float or Rational value requires ndigits.
  #         BigDecimal(2.0, 0)                # => 0.2e1
  #         BigDecimal(Rational(2, 1), 0)     # => 0.2e1
  #
  # *   String: converted by parsing if it contains an integer or floating-point
  #     literal; leading and trailing whitespace is ignored:
  #
  #         # String does not require ndigits; ignored if given.
  #         BigDecimal('2')     # => 0.2e1
  #         BigDecimal('2.0')   # => 0.2e1
  #         BigDecimal('0.2e1') # => 0.2e1
  #         BigDecimal(' 2.0 ') # => 0.2e1
  #
  # *   Other type that responds to method `:to_str`: first converted to a string,
  #     then converted to a BigDecimal, as above.
  #
  # *   Other type:
  #
  #     *   Raises an exception if keyword argument `exception` is `true`.
  #     *   Returns `nil` if keyword argument `exception` is `false`.
  #
  # Raises an exception if `value` evaluates to a Float and `digits` is larger
  # than Float::DIG + 1.
  #
  def self?.BigDecimal: (real | string | BigDecimal initial, ?int digits, ?exception: bool) -> BigDecimal
end

%a{annotate:rdoc:skip}
class Integer
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - int.to_d  -> bigdecimal
  # -->
  # Returns the value of `int` as a BigDecimal.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     42.to_d   # => 0.42e2
  #
  # See also Kernel.BigDecimal.
  #
  def to_d: () -> BigDecimal

  # <!--
  #   rdoc-file=numeric.c
  #   - self / numeric -> numeric_result
  # -->
  # Performs division; for integer `numeric`, truncates the result to an integer:
  #
  #      4 / 3              # => 1
  #      4 / -3             # => -2
  #      -4 / 3             # => -2
  #      -4 / -3            # => 1
  #
  #     For other +numeric+, returns non-integer result:
  #
  #      4 / 3.0            # => 1.3333333333333333
  #      4 / Rational(3, 1) # => (4/3)
  #      4 / Complex(3, 0)  # => ((4/3)+0i)
  #
  def /: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self * numeric -> numeric_result
  # -->
  # Performs multiplication:
  #
  #     4 * 2              # => 8
  #     4 * -2             # => -8
  #     -4 * 2             # => -8
  #     4 * 2.0            # => 8.0
  #     4 * Rational(1, 3) # => (4/3)
  #     4 * Complex(2, 0)  # => (8+0i)
  #
  def *: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self + numeric -> numeric_result
  # -->
  # Performs addition:
  #
  #     2 + 2              # => 4
  #     -2 + 2             # => 0
  #     -2 + -2            # => -4
  #     2 + 2.0            # => 4.0
  #     2 + Rational(2, 1) # => (4/1)
  #     2 + Complex(2, 0)  # => (4+0i)
  #
  def +: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self - numeric -> numeric_result
  # -->
  # Performs subtraction:
  #
  #     4 - 2              # => 2
  #     -4 - 2             # => -6
  #     -4 - -2            # => -2
  #     4 - 2.0            # => 2.0
  #     4 - Rational(2, 1) # => (2/1)
  #     4 - Complex(2, 0)  # => (2+0i)
  #
  def -: (BigDecimal) -> BigDecimal
    | ...
end

%a{annotate:rdoc:skip}
class Float
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - float.to_d             -> bigdecimal
  #   - float.to_d(precision)  -> bigdecimal
  # -->
  # Returns the value of `float` as a BigDecimal. The `precision` parameter is
  # used to determine the number of significant digits for the result. When
  # `precision` is set to `0`, the number of digits to represent the float being
  # converted is determined automatically. The default `precision` is `0`.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     0.5.to_d         # => 0.5e0
  #     1.234.to_d       # => 0.1234e1
  #     1.234.to_d(2)    # => 0.12e1
  #
  # See also Kernel.BigDecimal.
  #
  def to_d: (?Integer precision) -> BigDecimal

  # <!--
  #   rdoc-file=numeric.c
  #   - self / other -> numeric
  # -->
  # Returns a new Float which is the result of dividing `self` by `other`:
  #
  #     f = 3.14
  #     f / 2              # => 1.57
  #     f / 2.0            # => 1.57
  #     f / Rational(2, 1) # => 1.57
  #     f / Complex(2, 0)  # => (1.57+0.0i)
  #
  def /: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self * other -> numeric
  # -->
  # Returns a new Float which is the product of `self` and `other`:
  #
  #     f = 3.14
  #     f * 2              # => 6.28
  #     f * 2.0            # => 6.28
  #     f * Rational(1, 2) # => 1.57
  #     f * Complex(2, 0)  # => (6.28+0.0i)
  #
  def *: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self + other -> numeric
  # -->
  # Returns a new Float which is the sum of `self` and `other`:
  #
  #     f = 3.14
  #     f + 1                 # => 4.140000000000001
  #     f + 1.0               # => 4.140000000000001
  #     f + Rational(1, 1)    # => 4.140000000000001
  #     f + Complex(1, 0)     # => (4.140000000000001+0i)
  #
  def +: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=numeric.c
  #   - self - other -> numeric
  # -->
  # Returns a new Float which is the difference of `self` and `other`:
  #
  #     f = 3.14
  #     f - 1                 # => 2.14
  #     f - 1.0               # => 2.14
  #     f - Rational(1, 1)    # => 2.14
  #     f - Complex(1, 0)     # => (2.14+0i)
  #
  def -: (BigDecimal) -> BigDecimal
    | ...
end

%a{annotate:rdoc:skip}
class String
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - str.to_d  -> bigdecimal
  # -->
  # Returns the result of interpreting leading characters in `str` as a
  # BigDecimal.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     "0.5".to_d             # => 0.5e0
  #     "123.45e1".to_d        # => 0.12345e4
  #     "45.67 degrees".to_d   # => 0.4567e2
  #
  # See also Kernel.BigDecimal.
  #
  def to_d: () -> BigDecimal
end

%a{annotate:rdoc:skip}
class Rational
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - rat.to_d(precision)  -> bigdecimal
  # -->
  # Returns the value as a BigDecimal.
  #
  # The required `precision` parameter is used to determine the number of
  # significant digits for the result.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     Rational(22, 7).to_d(3)   # => 0.314e1
  #
  # See also Kernel.BigDecimal.
  #
  def to_d: (Integer precision) -> BigDecimal

  # <!--
  #   rdoc-file=rational.c
  #   - rat / numeric     ->  numeric
  #   - rat.quo(numeric)  ->  numeric
  # -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def /: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=rational.c
  #   - rat * numeric  ->  numeric
  # -->
  # Performs multiplication.
  #
  #     Rational(2, 3)  * Rational(2, 3)   #=> (4/9)
  #     Rational(900)   * Rational(1)      #=> (900/1)
  #     Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)
  #     Rational(9, 8)  * 4                #=> (9/2)
  #     Rational(20, 9) * 9.8              #=> 21.77777777777778
  #
  def *: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=rational.c
  #   - rat + numeric  ->  numeric
  # -->
  # Performs addition.
  #
  #     Rational(2, 3)  + Rational(2, 3)   #=> (4/3)
  #     Rational(900)   + Rational(1)      #=> (901/1)
  #     Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)
  #     Rational(9, 8)  + 4                #=> (41/8)
  #     Rational(20, 9) + 9.8              #=> 12.022222222222222
  #
  def +: (BigDecimal) -> BigDecimal
    | ...

  # <!--
  #   rdoc-file=rational.c
  #   - rat - numeric  ->  numeric
  # -->
  # Performs subtraction.
  #
  #     Rational(2, 3)  - Rational(2, 3)   #=> (0/1)
  #     Rational(900)   - Rational(1)      #=> (899/1)
  #     Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)
  #     Rational(9, 8)  - 4                #=> (-23/8)
  #     Rational(20, 9) - 9.8              #=> -7.577777777777778
  #
  def -: (BigDecimal) -> BigDecimal
    | ...
end

%a{annotate:rdoc:skip}
class Complex
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - cmp.to_d             -> bigdecimal
  #   - cmp.to_d(precision)  -> bigdecimal
  # -->
  # Returns the value as a BigDecimal.
  #
  # The `precision` parameter is required for a rational complex number. This
  # parameter is used to determine the number of significant digits for the
  # result.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     Complex(0.1234567, 0).to_d(4)   # => 0.1235e0
  #     Complex(Rational(22, 7), 0).to_d(3)   # => 0.314e1
  #
  # See also Kernel.BigDecimal.
  #
  def to_d: (*untyped args) -> BigDecimal

  # <!--
  #   rdoc-file=complex.c
  #   - complex / numeric -> new_complex
  # -->
  # Returns the quotient of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  / Complex.rect(2, 3)  # => (1+0i)
  #     Complex.rect(900)   / Complex.rect(1)     # => (900+0i)
  #     Complex.rect(-2, 9) / Complex.rect(-9, 2) # => ((36/85)-(77/85)*i)
  #     Complex.rect(9, 8)  / 4                   # => ((9/4)+2i)
  #     Complex.rect(20, 9) / 9.8                 # => (2.0408163265306123+0.9183673469387754i)
  #
  def /: (BigDecimal) -> Complex
    | ...

  # <!--
  #   rdoc-file=complex.c
  #   - complex * numeric -> new_complex
  # -->
  # Returns the product of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  * Complex.rect(2, 3)  # => (-5+12i)
  #     Complex.rect(900)   * Complex.rect(1)     # => (900+0i)
  #     Complex.rect(-2, 9) * Complex.rect(-9, 2) # => (0-85i)
  #     Complex.rect(9, 8)  * 4                   # => (36+32i)
  #     Complex.rect(20, 9) * 9.8                 # => (196.0+88.2i)
  #
  def *: (BigDecimal) -> Complex
    | ...

  # <!--
  #   rdoc-file=complex.c
  #   - complex + numeric -> new_complex
  # -->
  # Returns the sum of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  + Complex.rect(2, 3)  # => (4+6i)
  #     Complex.rect(900)   + Complex.rect(1)     # => (901+0i)
  #     Complex.rect(-2, 9) + Complex.rect(-9, 2) # => (-11+11i)
  #     Complex.rect(9, 8)  + 4                   # => (13+8i)
  #     Complex.rect(20, 9) + 9.8                 # => (29.8+9i)
  #
  def +: (BigDecimal) -> Complex
    | ...

  # <!--
  #   rdoc-file=complex.c
  #   - complex - numeric -> new_complex
  # -->
  # Returns the difference of `self` and `numeric`:
  #
  #     Complex.rect(2, 3)  - Complex.rect(2, 3)  # => (0+0i)
  #     Complex.rect(900)   - Complex.rect(1)     # => (899+0i)
  #     Complex.rect(-2, 9) - Complex.rect(-9, 2) # => (7+7i)
  #     Complex.rect(9, 8)  - 4                   # => (5+8i)
  #     Complex.rect(20, 9) - 9.8                 # => (10.2+9i)
  #
  def -: (BigDecimal) -> Complex
    | ...
end

%a{annotate:rdoc:skip}
class NilClass
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/util.rb
  #   - nil.to_d -> bigdecimal
  # -->
  # Returns nil represented as a BigDecimal.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     nil.to_d   # => 0.0
  #
  def to_d: () -> BigDecimal
end
# <!-- rdoc-file=lib/cgi.rb -->
# ## Overview
#
# The Common Gateway Interface (CGI) is a simple protocol for passing an HTTP
# request from a web server to a standalone program, and returning the output to
# the web browser.  Basically, a CGI program is called with the parameters of
# the request passed in either in the environment (GET) or via $stdin (POST),
# and everything it prints to $stdout is returned to the client.
#
# This file holds the CGI class.  This class provides functionality for
# retrieving HTTP request parameters, managing cookies, and generating HTML
# output.
#
# The file CGI::Session provides session management functionality; see that
# class for more details.
#
# See http://www.w3.org/CGI/ for more information on the CGI protocol.
#
# ## Introduction
#
# CGI is a large class, providing several categories of methods, many of which
# are mixed in from other modules.  Some of the documentation is in this class,
# some in the modules CGI::QueryExtension and CGI::HtmlExtension.  See
# CGI::Cookie for specific information on handling cookies, and cgi/session.rb
# (CGI::Session) for information on sessions.
#
# For queries, CGI provides methods to get at environmental variables,
# parameters, cookies, and multipart request data.  For responses, CGI provides
# methods for writing output and generating HTML.
#
# Read on for more details.  Examples are provided at the bottom.
#
# ## Queries
#
# The CGI class dynamically mixes in parameter and cookie-parsing functionality,
#  environmental variable access, and support for parsing multipart requests
# (including uploaded files) from the CGI::QueryExtension module.
#
# ### Environmental Variables
#
# The standard CGI environmental variables are available as read-only attributes
# of a CGI object.  The following is a list of these variables:
#
#     AUTH_TYPE               HTTP_HOST          REMOTE_IDENT
#     CONTENT_LENGTH          HTTP_NEGOTIATE     REMOTE_USER
#     CONTENT_TYPE            HTTP_PRAGMA        REQUEST_METHOD
#     GATEWAY_INTERFACE       HTTP_REFERER       SCRIPT_NAME
#     HTTP_ACCEPT             HTTP_USER_AGENT    SERVER_NAME
#     HTTP_ACCEPT_CHARSET     PATH_INFO          SERVER_PORT
#     HTTP_ACCEPT_ENCODING    PATH_TRANSLATED    SERVER_PROTOCOL
#     HTTP_ACCEPT_LANGUAGE    QUERY_STRING       SERVER_SOFTWARE
#     HTTP_CACHE_CONTROL      REMOTE_ADDR
#     HTTP_FROM               REMOTE_HOST
#
# For each of these variables, there is a corresponding attribute with the same
# name, except all lower case and without a preceding HTTP_. `content_length`
# and `server_port` are integers; the rest are strings.
#
# ### Parameters
#
# The method #params() returns a hash of all parameters in the request as
# name/value-list pairs, where the value-list is an Array of one or more values.
#  The CGI object itself also behaves as a hash of parameter names to values,
# but only returns a single value (as a String) for each parameter name.
#
# For instance, suppose the request contains the parameter "favourite_colours"
# with the multiple values "blue" and "green".  The following behavior would
# occur:
#
#     cgi.params["favourite_colours"]  # => ["blue", "green"]
#     cgi["favourite_colours"]         # => "blue"
#
# If a parameter does not exist, the former method will return an empty array,
# the latter an empty string.  The simplest way to test for existence of a
# parameter is by the #has_key? method.
#
# ### Cookies
#
# HTTP Cookies are automatically parsed from the request.  They are available
# from the #cookies() accessor, which returns a hash from cookie name to
# CGI::Cookie object.
#
# ### Multipart requests
#
# If a request's method is POST and its content type is multipart/form-data,
# then it may contain uploaded files.  These are stored by the QueryExtension
# module in the parameters of the request.  The parameter name is the name
# attribute of the file input field, as usual.  However, the value is not a
# string, but an IO object, either an IOString for small files, or a Tempfile
# for larger ones.  This object also has the additional singleton methods:
#
# #local_path()
# :   the path of the uploaded file on the local filesystem
#
# #original_filename()
# :   the name of the file on the client computer
#
# #content_type()
# :   the content type of the file
#
#
# ## Responses
#
# The CGI class provides methods for sending header and content output to the
# HTTP client, and mixes in methods for programmatic HTML generation from
# CGI::HtmlExtension and CGI::TagMaker modules.  The precise version of HTML to
# use for HTML generation is specified at object creation time.
#
# ### Writing output
#
# The simplest way to send output to the HTTP client is using the #out() method.
# This takes the HTTP headers as a hash parameter, and the body content via a
# block.  The headers can be generated as a string using the #http_header()
# method.  The output stream can be written directly to using the #print()
# method.
#
# ### Generating HTML
#
# Each HTML element has a corresponding method for generating that element as a
# String.  The name of this method is the same as that of the element, all
# lowercase.  The attributes of the element are passed in as a hash, and the
# body as a no-argument block that evaluates to a String.  The HTML generation
# module knows which elements are always empty, and silently drops any passed-in
# body.  It also knows which elements require matching closing tags and which
# don't.  However, it does not know what attributes are legal for which
# elements.
#
# There are also some additional HTML generation methods mixed in from the
# CGI::HtmlExtension module.  These include individual methods for the different
# types of form inputs, and methods for elements that commonly take particular
# attributes where the attributes can be directly specified as arguments, rather
# than via a hash.
#
# ### Utility HTML escape and other methods like a function.
#
# There are some utility tool defined in cgi/util.rb . And when include, you can
# use utility methods like a function.
#
# ## Examples of use
#
# ### Get form values
#
#     require "cgi"
#     cgi = CGI.new
#     value = cgi['field_name']   # <== value string for 'field_name'
#       # if not 'field_name' included, then return "".
#     fields = cgi.keys            # <== array of field names
#
#     # returns true if form has 'field_name'
#     cgi.has_key?('field_name')
#     cgi.has_key?('field_name')
#     cgi.include?('field_name')
#
# CAUTION! `cgi['field_name']` returned an Array with the old cgi.rb(included in
# Ruby 1.6)
#
# ### Get form values as hash
#
#     require "cgi"
#     cgi = CGI.new
#     params = cgi.params
#
# cgi.params is a hash.
#
#     cgi.params['new_field_name'] = ["value"]  # add new param
#     cgi.params['field_name'] = ["new_value"]  # change value
#     cgi.params.delete('field_name')           # delete param
#     cgi.params.clear                          # delete all params
#
# ### Save form values to file
#
#     require "pstore"
#     db = PStore.new("query.db")
#     db.transaction do
#       db["params"] = cgi.params
#     end
#
# ### Restore form values from file
#
#     require "pstore"
#     db = PStore.new("query.db")
#     db.transaction do
#       cgi.params = db["params"]
#     end
#
# ### Get multipart form values
#
#     require "cgi"
#     cgi = CGI.new
#     value = cgi['field_name']   # <== value string for 'field_name'
#     value.read                  # <== body of value
#     value.local_path            # <== path to local file of value
#     value.original_filename     # <== original filename of value
#     value.content_type          # <== content_type of value
#
# and value has StringIO or Tempfile class methods.
#
# ### Get cookie values
#
#     require "cgi"
#     cgi = CGI.new
#     values = cgi.cookies['name']  # <== array of 'name'
#       # if not 'name' included, then return [].
#     names = cgi.cookies.keys      # <== array of cookie names
#
# and cgi.cookies is a hash.
#
# ### Get cookie objects
#
#     require "cgi"
#     cgi = CGI.new
#     for name, cookie in cgi.cookies
#       cookie.expires = Time.now + 30
#     end
#     cgi.out("cookie" => cgi.cookies) {"string"}
#
#     cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }
#
#     require "cgi"
#     cgi = CGI.new
#     cgi.cookies['name'].expires = Time.now + 30
#     cgi.out("cookie" => cgi.cookies['name']) {"string"}
#
# ### Print http header and html string to $DEFAULT_OUTPUT ($>)
#
#     require "cgi"
#     cgi = CGI.new("html4")  # add HTML generation methods
#     cgi.out do
#       cgi.html do
#         cgi.head do
#           cgi.title { "TITLE" }
#         end +
#         cgi.body do
#           cgi.form("ACTION" => "uri") do
#             cgi.p do
#               cgi.textarea("get_text") +
#               cgi.br +
#               cgi.submit
#             end
#           end +
#           cgi.pre do
#             CGI.escapeHTML(
#               "params: #{cgi.params.inspect}\n" +
#               "cookies: #{cgi.cookies.inspect}\n" +
#               ENV.collect do |key, value|
#                 "#{key} --> #{value}\n"
#               end.join("")
#             )
#           end
#         end
#       end
#     end
#
#     # add HTML generation methods
#     CGI.new("html3")    # html3.2
#     CGI.new("html4")    # html4.01 (Strict)
#     CGI.new("html4Tr")  # html4.01 Transitional
#     CGI.new("html4Fr")  # html4.01 Frameset
#     CGI.new("html5")    # html5
#
# ### Some utility methods
#
#     require 'cgi/util'
#     CGI.escapeHTML('Usage: foo "bar" <baz>')
#
# ### Some utility methods like a function
#
#     require 'cgi/util'
#     include CGI::Util
#     escapeHTML('Usage: foo "bar" <baz>')
#     h('Usage: foo "bar" <baz>') # alias
#
class CGI
  include CGI::Util

  extend CGI::Util

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - CGI.new(tag_maker) { block }
  #   - CGI.new(options_hash = {}) { block }
  # -->
  # Create a new CGI instance.
  #
  # `tag_maker`
  # :   This is the same as using the `options_hash` form with the value `{
  #     :tag_maker => tag_maker }` Note that it is recommended to use the
  #     `options_hash` form, since it also allows you specify the charset you will
  #     accept.
  #
  # `options_hash`
  # :   A Hash that recognizes three options:
  #
  #     `:accept_charset`
  # :       specifies encoding of received query string.  If omitted,
  #         `@@accept_charset` is used.  If the encoding is not valid, a
  #         CGI::InvalidEncoding will be raised.
  #
  #         Example. Suppose `@@accept_charset` is "UTF-8"
  #
  #         when not specified:
  #
  #             cgi=CGI.new      # @accept_charset # => "UTF-8"
  #
  #         when specified as "EUC-JP":
  #
  #             cgi=CGI.new(:accept_charset => "EUC-JP") # => "EUC-JP"
  #
  #
  #     `:tag_maker`
  # :       String that specifies which version of the HTML generation methods to
  #         use.  If not specified, no HTML generation methods will be loaded.
  #
  #         The following values are supported:
  #
  #         "html3"
  # :           HTML 3.x
  #
  #         "html4"
  # :           HTML 4.0
  #
  #         "html4Tr"
  # :           HTML 4.0 Transitional
  #
  #         "html4Fr"
  # :           HTML 4.0 with Framesets
  #
  #         "html5"
  # :           HTML 5
  #
  #
  #
  #     `:max_multipart_length`
  # :       Specifies maximum length of multipart data. Can be an Integer scalar
  #         or a lambda, that will be evaluated when the request is parsed. This
  #         allows more complex logic to be set when determining whether to accept
  #         multipart data (e.g. consult a registered users upload allowance)
  #
  #         Default is 128 * 1024 * 1024 bytes
  #
  #             cgi=CGI.new(:max_multipart_length => 268435456) # simple scalar
  #
  #             cgi=CGI.new(:max_multipart_length => -> {check_filesystem}) # lambda
  #
  #
  #
  # `block`
  # :   If provided, the block is called when an invalid encoding is encountered.
  #     For example:
  #
  #         encoding_errors={}
  #         cgi=CGI.new(:accept_charset=>"EUC-JP") do |name,value|
  #           encoding_errors[name] = value
  #         end
  #
  #
  # Finally, if the CGI object is not created in a standard CGI call environment
  # (that is, it can't locate REQUEST_METHOD in its environment), then it will run
  # in "offline" mode.  In this mode, it reads its parameters from the command
  # line or (failing that) from standard input.  Otherwise, cookies and other
  # parameters are parsed automatically from the standard CGI locations, which
  # varies according to the REQUEST_METHOD.
  #
  def initialize: (?String tag_maker) ?{ (String name, String value) -> void } -> void
                | (Hash[Symbol, untyped] options_hash) ?{ (String name, String value) -> void } -> void

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - accept_charset()
  # -->
  # Return the accept character set for all new CGI instances.
  #
  def self.accept_charset: () -> encoding

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - accept_charset=(accept_charset)
  # -->
  # Set the accept character set for all new CGI instances.
  #
  def self.accept_charset=: (encoding accept_charset) -> encoding

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - parse(query)
  # -->
  # Parse an HTTP query string into a hash of key=>value pairs.
  #
  #     params = CGI.parse("query_string")
  #       # {"name1" => ["value1", "value2", ...],
  #       #  "name2" => ["value1", "value2", ...], ... }
  #
  def self.parse: (String query) -> Hash[String, Array[String]]

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Return the accept character set for this CGI instance.
  #
  attr_reader accept_charset: encoding

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # This method is an alias for #http_header, when HTML5 tag maker is inactive.
  #
  # NOTE: use #http_header to create HTTP header blocks, this alias is only
  # provided for backwards compatibility.
  #
  # Using #header with the HTML5 tag maker will create a <header> element.
  #
  alias header http_header

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - http_header(content_type_string="text/html")
  #   - http_header(headers_hash)
  # -->
  # Create an HTTP header block as a string.
  #
  # Includes the empty line that ends the header block.
  #
  # `content_type_string`
  # :   If this form is used, this string is the `Content-Type`
  #
  # `headers_hash`
  # :   A Hash of header values. The following header keys are recognized:
  #
  #     type
  # :       The Content-Type header.  Defaults to "text/html"
  #
  #     charset
  # :       The charset of the body, appended to the Content-Type header.
  #
  #     nph
  # :       A boolean value.  If true, prepend protocol string and status code,
  #         and date; and sets default values for "server" and "connection" if not
  #         explicitly set.
  #
  #     status
  # :       The HTTP status code as a String, returned as the Status header.  The
  #         values are:
  #
  #         OK
  # :           200 OK
  #
  #         PARTIAL_CONTENT
  # :           206 Partial Content
  #
  #         MULTIPLE_CHOICES
  # :           300 Multiple Choices
  #
  #         MOVED
  # :           301 Moved Permanently
  #
  #         REDIRECT
  # :           302 Found
  #
  #         NOT_MODIFIED
  # :           304 Not Modified
  #
  #         BAD_REQUEST
  # :           400 Bad Request
  #
  #         AUTH_REQUIRED
  # :           401 Authorization Required
  #
  #         FORBIDDEN
  # :           403 Forbidden
  #
  #         NOT_FOUND
  # :           404 Not Found
  #
  #         METHOD_NOT_ALLOWED
  # :           405 Method Not Allowed
  #
  #         NOT_ACCEPTABLE
  # :           406 Not Acceptable
  #
  #         LENGTH_REQUIRED
  # :           411 Length Required
  #
  #         PRECONDITION_FAILED
  # :           412 Precondition Failed
  #
  #         SERVER_ERROR
  # :           500 Internal Server Error
  #
  #         NOT_IMPLEMENTED
  # :           501 Method Not Implemented
  #
  #         BAD_GATEWAY
  # :           502 Bad Gateway
  #
  #         VARIANT_ALSO_VARIES
  # :           506 Variant Also Negotiates
  #
  #
  #
  #     server
  # :       The server software, returned as the Server header.
  #
  #     connection
  # :       The connection type, returned as the Connection header (for instance,
  #         "close".
  #
  #     length
  # :       The length of the content that will be sent, returned as the
  #         Content-Length header.
  #
  #     language
  # :       The language of the content, returned as the Content-Language header.
  #
  #     expires
  # :       The time on which the current content expires, as a `Time` object,
  #         returned as the Expires header.
  #
  #     cookie
  # :       A cookie or cookies, returned as one or more Set-Cookie headers.  The
  #         value can be the literal string of the cookie; a CGI::Cookie object;
  #         an Array of literal cookie strings or Cookie objects; or a hash all of
  #         whose values are literal cookie strings or Cookie objects.
  #
  #         These cookies are in addition to the cookies held in the
  #         @output_cookies field.
  #
  #
  #     Other headers can also be set; they are appended as key: value.
  #
  #
  # Examples:
  #
  #     http_header
  #       # Content-Type: text/html
  #
  #     http_header("text/plain")
  #       # Content-Type: text/plain
  #
  #     http_header("nph"        => true,
  #                 "status"     => "OK",  # == "200 OK"
  #                   # "status"     => "200 GOOD",
  #                 "server"     => ENV['SERVER_SOFTWARE'],
  #                 "connection" => "close",
  #                 "type"       => "text/html",
  #                 "charset"    => "iso-2022-jp",
  #                   # Content-Type: text/html; charset=iso-2022-jp
  #                 "length"     => 103,
  #                 "language"   => "ja",
  #                 "expires"    => Time.now + 30,
  #                 "cookie"     => [cookie1, cookie2],
  #                 "my_header1" => "my_value",
  #                 "my_header2" => "my_value")
  #
  # This method does not perform charset conversion.
  #
  def http_header: (?String options) -> String
                 | (?Hash[interned, untyped] header_hash) -> String

  def nph?: () -> untyped

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - cgi.out(content_type_string='text/html')
  #   - cgi.out(headers_hash)
  # -->
  # Print an HTTP header and body to $DEFAULT_OUTPUT ($>)
  #
  # `content_type_string`
  # :   If a string is passed, it is assumed to be the content type.
  #
  # `headers_hash`
  # :   This is a Hash of headers, similar to that used by #http_header.
  #
  # `block`
  # :   A block is required and should evaluate to the body of the response.
  #
  #
  # `Content-Length` is automatically calculated from the size of the String
  # returned by the content block.
  #
  # If `ENV['REQUEST_METHOD'] == "HEAD"`, then only the header is output (the
  # content block is still required, but it is ignored).
  #
  # If the charset is "iso-2022-jp" or "euc-jp" or "shift_jis" then the content is
  # converted to this charset, and the language is set to "ja".
  #
  # Example:
  #
  #     cgi = CGI.new
  #     cgi.out{ "string" }
  #       # Content-Type: text/html
  #       # Content-Length: 6
  #       #
  #       # string
  #
  #     cgi.out("text/plain") { "string" }
  #       # Content-Type: text/plain
  #       # Content-Length: 6
  #       #
  #       # string
  #
  #     cgi.out("nph"        => true,
  #             "status"     => "OK",  # == "200 OK"
  #             "server"     => ENV['SERVER_SOFTWARE'],
  #             "connection" => "close",
  #             "type"       => "text/html",
  #             "charset"    => "iso-2022-jp",
  #               # Content-Type: text/html; charset=iso-2022-jp
  #             "language"   => "ja",
  #             "expires"    => Time.now + (3600 * 24 * 30),
  #             "cookie"     => [cookie1, cookie2],
  #             "my_header1" => "my_value",
  #             "my_header2" => "my_value") { "string" }
  #        # HTTP/1.1 200 OK
  #        # Date: Sun, 15 May 2011 17:35:54 GMT
  #        # Server: Apache 2.2.0
  #        # Connection: close
  #        # Content-Type: text/html; charset=iso-2022-jp
  #        # Content-Length: 6
  #        # Content-Language: ja
  #        # Expires: Tue, 14 Jun 2011 17:35:54 GMT
  #        # Set-Cookie: foo
  #        # Set-Cookie: bar
  #        # my_header1: my_value
  #        # my_header2: my_value
  #        #
  #        # string
  #
  def out: (?String content_type_string) { () -> String } -> void
         | (Hash[interned, untyped] headers_hash) { () -> String } -> void

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - print(*options)
  # -->
  # Print an argument or list of arguments to the default output stream
  #
  #     cgi = CGI.new
  #     cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
  #
  def print: (*String options) -> void

  private

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - stdinput()
  # -->
  # Synonym for $stdin.
  #
  def stdinput: () -> ::IO

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - stdoutput()
  # -->
  # Synonym for $stdout.
  #
  def stdoutput: () -> ::IO

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # String for carriage return
  #
  CR: String

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Standard internet newline sequence
  #
  EOL: String

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # HTTP status codes.
  #
  HTTP_STATUS: Hash[String, String]

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # String for linefeed
  #
  LF: String

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Maximum number of request parameters when multipart
  #
  MAX_MULTIPART_COUNT: Integer

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Whether processing will be required in binary vs text
  #
  NEEDS_BINMODE: bool

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Path separators in different environments.
  #
  PATH_SEPARATOR: Hash[String, String]

  REVISION: String

  VERSION: String

  # <!-- rdoc-file=lib/cgi/cookie.rb -->
  # Class representing an HTTP cookie.
  #
  # In addition to its specific fields and methods, a Cookie instance is a
  # delegator to the array of its values.
  #
  # See RFC 2965.
  #
  # ## Examples of use
  #     cookie1 = CGI::Cookie.new("name", "value1", "value2", ...)
  #     cookie1 = CGI::Cookie.new("name" => "name", "value" => "value")
  #     cookie1 = CGI::Cookie.new('name'     => 'name',
  #                               'value'    => ['value1', 'value2', ...],
  #                               'path'     => 'path',   # optional
  #                               'domain'   => 'domain', # optional
  #                               'expires'  => Time.now, # optional
  #                               'secure'   => true,     # optional
  #                               'httponly' => true      # optional
  #                               )
  #
  #     cgi.out("cookie" => [cookie1, cookie2]) { "string" }
  #
  #     name     = cookie1.name
  #     values   = cookie1.value
  #     path     = cookie1.path
  #     domain   = cookie1.domain
  #     expires  = cookie1.expires
  #     secure   = cookie1.secure
  #     httponly = cookie1.httponly
  #
  #     cookie1.name     = 'name'
  #     cookie1.value    = ['value1', 'value2', ...]
  #     cookie1.path     = 'path'
  #     cookie1.domain   = 'domain'
  #     cookie1.expires  = Time.now + 30
  #     cookie1.secure   = true
  #     cookie1.httponly = true
  #
  class Cookie < Array[String]
    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - parse(raw_cookie)
    # -->
    # Parse a raw cookie string into a hash of cookie-name=>Cookie pairs.
    #
    #     cookies = CGI::Cookie.parse("raw_cookie_string")
    #       # { "name1" => cookie1, "name2" => cookie2, ... }
    #
    def self.parse: (String raw_cookie) -> Hash[String, instance]

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # Domain for which this cookie applies, as a `String`
    #
    def domain: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - domain=(str)
    # -->
    # Set domain for which this cookie applies
    #
    def domain=: (String domain) -> String

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # Time at which this cookie expires, as a `Time`
    #
    def expires: () -> Time?

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # Time at which this cookie expires, as a `Time`
    #
    def expires=: (Time time) -> Time

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # True if this cookie is httponly; false otherwise
    #
    def httponly: () -> bool

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - httponly=(val)
    # -->
    # Set whether the Cookie is a httponly cookie or not.
    #
    # `val` must be a boolean.
    #
    def httponly=: (boolish val) -> bool

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - inspect()
    # -->
    # A summary of cookie string.
    #
    def inspect: () -> String

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # Name of this cookie, as a `String`
    #
    def name: () -> String

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - name=(str)
    # -->
    # Set name of this cookie
    #
    def name=: (String name) -> String

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # Path for which this cookie applies, as a `String`
    #
    def path: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - path=(str)
    # -->
    # Set path for which this cookie applies
    #
    def path=: (String path) -> String

    # <!-- rdoc-file=lib/cgi/cookie.rb -->
    # True if this cookie is secure; false otherwise
    #
    def secure: () -> bool

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - secure=(val)
    # -->
    # Set whether the Cookie is a secure cookie or not.
    #
    # `val` must be a boolean.
    #
    def secure=: [A] (boolish val) -> A

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - to_s()
    # -->
    # Convert the Cookie to its string representation.
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - value()
    # -->
    # Returns the value or list of values for this cookie.
    #
    def value: () -> Array[String]

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - value=(val)
    # -->
    # Replaces the value of this cookie with a new value or list of values.
    #
    def value=: (String val) -> String
              | (Array[String] val) -> Array[String]

    private

    # <!--
    #   rdoc-file=lib/cgi/cookie.rb
    #   - Cookie.new(name_string,*value)
    #   - Cookie.new(options_hash)
    # -->
    # Create a new CGI::Cookie object.
    #
    # `name_string`
    # :   The name of the cookie; in this form, there is no #domain or #expiration.
    #     The #path is gleaned from the `SCRIPT_NAME` environment variable, and
    #     #secure is false.
    #
    # `*value`
    # :   value or list of values of the cookie
    #
    # `options_hash`
    # :   A Hash of options to initialize this Cookie.  Possible options are:
    #
    #     name
    # :       the name of the cookie.  Required.
    #
    #     value
    # :       the cookie's value or list of values.
    #
    #     path
    # :       the path for which this cookie applies.  Defaults to the value of the
    #         `SCRIPT_NAME` environment variable.
    #
    #     domain
    # :       the domain for which this cookie applies.
    #
    #     expires
    # :       the time at which this cookie expires, as a `Time` object.
    #
    #     secure
    # :       whether this cookie is a secure cookie or not (default to false).
    #         Secure cookies are only transmitted to HTTPS servers.
    #
    #     httponly
    # :       whether this cookie is a HttpOnly cookie or not (default to
    #
    #         false).  HttpOnly cookies are not available to javascript.
    #
    #     These keywords correspond to attributes of the cookie object.
    #
    def initialize: (String name_string, *String value) -> void
                  | (Hash[String, untyped] options_hash) -> void
  end

  module Escape
    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.escape(string) -> string
    # -->
    # Returns URL-escaped string (`application/x-www-form-urlencoded`).
    #
    def escape: (string str) -> String

    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.escapeHTML(string) -> string
    # -->
    # Returns HTML-escaped string.
    #
    def escapeHTML: (string str) -> String

    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.escapeURIComponent(string) -> string
    # -->
    # Returns URL-escaped string following RFC 3986.
    #
    def escapeURIComponent: (string) -> String

    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.unescape(string, encoding=@@accept_charset) -> string
    # -->
    # Returns URL-unescaped string (`application/x-www-form-urlencoded`).
    #
    def unescape: (string str, ?encoding encoding) -> String

    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.unescapeHTML(string) -> string
    # -->
    # Returns HTML-unescaped string.
    #
    def unescapeHTML: (string str) -> String

    # <!--
    #   rdoc-file=ext/cgi/escape/escape.c
    #   - CGI.unescapeURIComponent(string, encoding=@@accept_charset) -> string
    # -->
    # Returns URL-unescaped string following RFC 3986.
    #
    def unescapeURIComponent: (string) -> String
  end

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Exception raised when there is an invalid encoding detected
  #
  class InvalidEncoding < Exception
  end

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Mixin module that provides the following:
  #
  # 1.  Access to the CGI environment variables as methods.  See documentation to
  #     the CGI class for a list of these variables.  The methods are exposed by
  #     removing the leading `HTTP_` (if it exists) and downcasing the name.  For
  #     example, `auth_type` will return the environment variable `AUTH_TYPE`, and
  #     `accept` will return the value for `HTTP_ACCEPT`.
  #
  # 2.  Access to cookies, including the cookies attribute.
  #
  # 3.  Access to parameters, including the params attribute, and overloading #[]
  #     to perform parameter value lookup by key.
  #
  # 4.  The initialize_query method, for initializing the above mechanisms,
  #     handling multipart forms, and allowing the class to be used in "offline"
  #     mode.
  #
  module QueryExtension
    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - [](key)
    # -->
    # Get the value for the parameter with a given key.
    #
    # If the parameter has multiple values, only the first will be retrieved; use
    # #params to get the array of values.
    #
    def []: (String key) -> String?

    def accept: () -> String?

    def accept_charset: () -> String?

    def accept_encoding: () -> String?

    def accept_language: () -> String?

    def auth_type: () -> String?

    def cache_control: () -> String?

    def content_length: () -> String?

    def content_type: () -> String?

    # <!-- rdoc-file=lib/cgi/core.rb -->
    # Get the cookies as a hash of cookie-name=>Cookie pairs.
    #
    def cookies: () -> Hash[String, Cookie]

    # <!-- rdoc-file=lib/cgi/core.rb -->
    # Get the cookies as a hash of cookie-name=>Cookie pairs.
    #
    def cookies=: (Hash[String, Cookie] cookies) -> Hash[String, Cookie]

    def create_body: (boolish is_large) -> (Tempfile | StringIO)

    # <!-- rdoc-file=lib/cgi/core.rb -->
    # Get the uploaded files as a hash of name=>values pairs
    #
    def files: () -> Hash[String, Tempfile | StringIO]

    def from: () -> String?

    def gateway_interface: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - has_key?(*args)
    # -->
    # Returns true if a given query string parameter exists.
    #
    def has_key?: (String key) -> bool

    def host: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - include?(*args)
    # -->
    #
    alias include? has_key?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - key?(*args)
    # -->
    #
    alias key? has_key?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - keys(*args)
    # -->
    # Return all query parameter names as an array of String.
    #
    def keys: () -> Array[String]

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - multipart?()
    # -->
    # Returns whether the form contained multipart/form-data
    #
    def multipart?: () -> bool

    def negotiate: () -> String?

    # <!-- rdoc-file=lib/cgi/core.rb -->
    # Get the parameters as a hash of name=>values pairs, where values is an Array.
    #
    def params: () -> Hash[String, Array[String] | Tempfile | StringIO]

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - params=(hash)
    # -->
    # Set all the parameters.
    #
    def params=: (Hash[String, Array[String] | Tempfile | StringIO] hash) -> Hash[String, Array[String] | Tempfile | StringIO]

    def path_info: () -> String?

    def path_translated: () -> String?

    def pragma: () -> String?

    def query_string: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - raw_cookie()
    # -->
    # Get the raw cookies as a string.
    #
    def raw_cookie: () -> String?

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - raw_cookie2()
    # -->
    # Get the raw RFC2965 cookies as a string.
    #
    def raw_cookie2: () -> String?

    def referer: () -> String?

    def remote_addr: () -> String?

    def remote_host: () -> String?

    def remote_ident: () -> String?

    def remote_user: () -> String?

    def request_method: () -> String?

    def script_name: () -> String?

    def server_name: () -> String?

    def server_port: () -> String?

    def server_protocol: () -> String?

    def server_software: () -> String?

    def unescape_filename?: () -> bool

    def user_agent: () -> String?

    private

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - initialize_query()
    # -->
    # A wrapper class to use a StringIO object as the body and switch to a TempFile
    # when the passed threshold is passed. Initialize the data from the query.
    #
    # Handles multipart forms (in particular, forms that involve file uploads).
    # Reads query parameters in the @params field, and cookies into @cookies.
    #
    def initialize_query: () -> void

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - read_from_cmdline()
    # -->
    # offline mode. read name=value pairs on standard input.
    #
    def read_from_cmdline: () -> String

    # <!--
    #   rdoc-file=lib/cgi/core.rb
    #   - read_multipart(boundary, content_length)
    # -->
    # Parses multipart form elements according to
    #     http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2
    #
    # Returns a hash of multipart form parameters with bodies of type StringIO or
    # Tempfile depending on whether the multipart form element exceeds 10 KB
    #
    #     params[name => body]
    #
    def read_multipart: (String boundary, Integer content_length) -> (Tempfile | StringIO)
  end

  module Util
    include CGI::Escape

    # <!--
    #   rdoc-file=lib/cgi/util.rb
    #   - escapeElement(string, *elements)
    # -->
    # Escape only the tags of certain HTML elements in `string`.
    #
    # Takes an element or elements or array of elements.  Each element is specified
    # by the name of the element, without angle brackets. This matches both the
    # start and the end tag of that element. The attribute list of the open tag will
    # also be escaped (for instance, the double-quotes surrounding attribute
    # values).
    #
    #     print CGI.escapeElement('<BR><A HREF="url"></A>', "A", "IMG")
    #       # "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"
    #
    #     print CGI.escapeElement('<BR><A HREF="url"></A>', ["A", "IMG"])
    #       # "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"
    #
    def escapeElement: (string string, *String | Array[String] elements) -> String

    # <!-- rdoc-file=lib/cgi/util.rb -->
    # Synonym for CGI.escapeElement(str)
    #
    alias escape_element escapeElement

    # <!-- rdoc-file=lib/cgi/util.rb -->
    # Synonym for CGI.escapeHTML(str)
    #
    alias escape_html escapeHTML

    # <!--
    #   rdoc-file=lib/cgi/util.rb
    #   - h(string)
    # -->
    #
    alias h escapeHTML

    # <!--
    #   rdoc-file=lib/cgi/util.rb
    #   - pretty(string, shift = " ")
    # -->
    # Prettify (indent) an HTML string.
    #
    # `string` is the HTML string to indent.  `shift` is the indentation unit to
    # use; it defaults to two spaces.
    #
    #     print CGI.pretty("<HTML><BODY></BODY></HTML>")
    #       # <HTML>
    #       #   <BODY>
    #       #   </BODY>
    #       # </HTML>
    #
    #     print CGI.pretty("<HTML><BODY></BODY></HTML>", "\t")
    #       # <HTML>
    #       #         <BODY>
    #       #         </BODY>
    #       # </HTML>
    #
    def pretty: (string string, ?String shift) -> String

    # <!--
    #   rdoc-file=lib/cgi/util.rb
    #   - rfc1123_date(time)
    # -->
    # Format a `Time` object as a String using the format specified by RFC 1123.
    #
    #     CGI.rfc1123_date(Time.now)
    #       # Sat, 01 Jan 2000 00:00:00 GMT
    #
    def rfc1123_date: (Time time) -> String

    # <!--
    #   rdoc-file=lib/cgi/util.rb
    #   - unescapeElement(string, *elements)
    # -->
    # Undo escaping such as that done by CGI.escapeElement()
    #
    #     print CGI.unescapeElement(
    #             CGI.escapeHTML('<BR><A HREF="url"></A>'), "A", "IMG")
    #       # "&lt;BR&gt;<A HREF="url"></A>"
    #
    #     print CGI.unescapeElement(
    #             CGI.escapeHTML('<BR><A HREF="url"></A>'), ["A", "IMG"])
    #       # "&lt;BR&gt;<A HREF="url"></A>"
    #
    def unescapeElement: (string string, *String | Array[String] elements) -> String

    # <!-- rdoc-file=lib/cgi/util.rb -->
    # Synonym for CGI.unescapeElement(str)
    #
    alias unescape_element unescapeElement

    # <!-- rdoc-file=lib/cgi/util.rb -->
    # Synonym for CGI.unescapeHTML(str)
    #
    alias unescape_html unescapeHTML

    # Abbreviated day-of-week names specified by RFC 822
    RFC822_DAYS: Array[String]

    # Abbreviated month names specified by RFC 822
    RFC822_MONTHS: Array[String]

    # <!-- rdoc-file=lib/cgi/util.rb -->
    # The set of special characters and their escaped values
    #
    TABLE_FOR_ESCAPE_HTML__: Hash[String, String]
  end
end
# <!-- rdoc-file=ext/coverage/coverage.c -->
# Coverage provides coverage measurement feature for Ruby. This feature is
# experimental, so these APIs may be changed in future.
#
# Caveat: Currently, only process-global coverage measurement is supported. You
# cannot measure per-thread coverage.
#
# # Usage
#
# 1.  require "coverage"
# 2.  do Coverage.start
# 3.  require or load Ruby source file
# 4.  Coverage.result will return a hash that contains filename as key and
#     coverage array as value. A coverage array gives, for each line, the number
#     of line execution by the interpreter. A `nil` value means coverage is
#     disabled for this line (lines like `else` and `end`).
#
# # Examples
#
#     [foo.rb]
#     s = 0
#     10.times do |x|
#       s += x
#     end
#
#     if s == 45
#       p :ok
#     else
#       p :ng
#     end
#     [EOF]
#
#     require "coverage"
#     Coverage.start
#     require "foo.rb"
#     p Coverage.result  #=> {"foo.rb"=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}
#
# ## Lines Coverage
#
# If a coverage mode is not explicitly specified when starting coverage, lines
# coverage is what will run. It reports the number of line executions for each
# line.
#
#     require "coverage"
#     Coverage.start(lines: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}}
#
# The value of the lines coverage result is an array containing how many times
# each line was executed. Order in this array is important. For example, the
# first item in this array, at index 0, reports how many times line 1 of this
# file was executed while coverage was run (which, in this example, is one
# time).
#
# A `nil` value means coverage is disabled for this line (lines like `else` and
# `end`).
#
# ## Oneshot Lines Coverage
#
# Oneshot lines coverage tracks and reports on the executed lines while coverage
# is running. It will not report how many times a line was executed, only that
# it was executed.
#
#     require "coverage"
#     Coverage.start(oneshot_lines: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:oneshot_lines=>[1, 2, 3, 6, 7]}}
#
# The value of the oneshot lines coverage result is an array containing the line
# numbers that were executed.
#
# ## Branches Coverage
#
# Branches coverage reports how many times each branch within each conditional
# was executed.
#
#     require "coverage"
#     Coverage.start(branches: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}}}
#
# Each entry within the branches hash is a conditional, the value of which is
# another hash where each entry is a branch in that conditional. The values are
# the number of times the method was executed, and the keys are identifying
# information about the branch.
#
# The information that makes up each key identifying branches or conditionals is
# the following, from left to right:
#
# 1.  A label for the type of branch or conditional.
# 2.  A unique identifier.
# 3.  The starting line number it appears on in the file.
# 4.  The starting column number it appears on in the file.
# 5.  The ending line number it appears on in the file.
# 6.  The ending column number it appears on in the file.
#
# ## Methods Coverage
#
# Methods coverage reports how many times each method was executed.
#
#     [foo_method.rb]
#     class Greeter
#       def greet
#         "welcome!"
#       end
#     end
#
#     def hello
#       "Hi"
#     end
#
#     hello()
#     Greeter.new.greet()
#     [EOF]
#
#     require "coverage"
#     Coverage.start(methods: true)
#     require "foo_method.rb"
#     p Coverage.result #=> {"foo_method.rb"=>{:methods=>{[Object, :hello, 7, 0, 9, 3]=>1, [Greeter, :greet, 2, 2, 4, 5]=>1}}}
#
# Each entry within the methods hash represents a method. The values in this
# hash are the number of times the method was executed, and the keys are
# identifying information about the method.
#
# The information that makes up each key identifying a method is the following,
# from left to right:
#
# 1.  The class.
# 2.  The method name.
# 3.  The starting line number the method appears on in the file.
# 4.  The starting column number the method appears on in the file.
# 5.  The ending line number the method appears on in the file.
# 6.  The ending column number the method appears on in the file.
#
# ## All Coverage Modes
#
# You can also run all modes of coverage simultaneously with this shortcut. Note
# that running all coverage modes does not run both lines and oneshot lines.
# Those modes cannot be run simultaneously. Lines coverage is run in this case,
# because you can still use it to determine whether or not a line was executed.
#
#     require "coverage"
#     Coverage.start(:all)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil], :branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}, :methods=>{}}}
#
module Coverage
  # <!--
  #   rdoc-file=ext/coverage/lib/coverage.rb
  #   - line_stub(file)
  # -->
  #
  def self.line_stub: (String) -> Array[Integer?]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.peek_result  => hash
  # -->
  # Returns a hash that contains filename as key and coverage array as value. This
  # is the same as `Coverage.result(stop: false, clear: false)`.
  #
  #     {
  #       "file.rb" => [1, 2, nil],
  #       ...
  #     }
  #
  def self.peek_result: () -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.result(stop: true, clear: true)  => hash
  # -->
  # Returns a hash that contains filename as key and coverage array as value. If
  # `clear` is true, it clears the counters to zero. If `stop` is true, it
  # disables coverage measurement.
  #
  def self.result: (?stop: boolish, ?clear: boolish) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.running?  => bool
  # -->
  # Returns true if coverage stats are currently being collected (after
  # Coverage.start call, but before Coverage.result call)
  #
  def self.running?: () -> bool

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.setup                                                          => nil
  #   - Coverage.setup(:all)                                                    => nil
  #   - Coverage.setup(lines: bool, branches: bool, methods: bool, eval: bool)  => nil
  #   - Coverage.setup(oneshot_lines: true)                                     => nil
  # -->
  # Set up the coverage measurement.
  #
  # Note that this method does not start the measurement itself. Use
  # Coverage.resume to start the measurement.
  #
  # You may want to use Coverage.start to setup and then start the measurement.
  #
  def self.setup: (?lines: bool, ?branches: bool, ?methods: bool, ?eval: bool) -> nil
                | (oneshot_lines: bool, ?branches: bool, ?methods: bool, ?eval: bool) -> nil
                | (:all) -> nil

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.start                                                          => nil
  #   - Coverage.start(:all)                                                    => nil
  #   - Coverage.start(lines: bool, branches: bool, methods: bool, eval: bool)  => nil
  #   - Coverage.start(oneshot_lines: true)                                     => nil
  # -->
  # Enables the coverage measurement. See the documentation of Coverage class in
  # detail. This is equivalent to Coverage.setup and Coverage.resume.
  #
  alias self.start self.setup

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.state  => :idle, :suspended, :running
  # -->
  # Returns the state of the coverage measurement.
  #
  def self.state: () -> (:idle | :suspended | :running)

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.resume  => nil
  # -->
  # Start/resume the coverage measurement.
  #
  # Caveat: Currently, only process-global coverage measurement is supported. You
  # cannot measure per-thread coverage. If your process has multiple thread, using
  # Coverage.resume/suspend to capture code coverage executed from only a limited
  # code block, may yield misleading results.
  #
  def self.resume: () -> nil

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.supported?(mode) -> true or false
  # -->
  # Returns true if coverage measurement is supported for the given mode.
  #
  # The mode should be one of the following symbols: `:lines`, `:oneshot_lines`,
  # `:branches`, `:methods`, `:eval`.
  #
  # Example:
  #
  #     Coverage.supported?(:lines)  #=> true
  #     Coverage.supported?(:all)    #=> false
  #
  def self.supported?: (Symbol) -> bool

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.suspend  => nil
  # -->
  # Suspend the coverage measurement. You can use Coverage.resume to restart the
  # measurement.
  #
  def self.suspend: () -> nil
end
# <!-- rdoc-file=lib/csv.rb -->
# ## CSV
#
# ### CSV Data
#
# CSV (comma-separated values) data is a text representation of a table:
# *   A *row* *separator* delimits table rows. A common row separator is the
#     newline character `"\n"`.
# *   A *column* *separator* delimits fields in a row. A common column separator
#     is the comma character `","`.
#
# This CSV String, with row separator `"\n"` and column separator `","`, has
# three rows and two columns:
#     "foo,0\nbar,1\nbaz,2\n"
#
# Despite the name CSV, a CSV representation can use different separators.
#
# For more about tables, see the Wikipedia article "[Table
# (information)](https://en.wikipedia.org/wiki/Table_(information))", especially
# its section "[Simple
# table](https://en.wikipedia.org/wiki/Table_(information)#Simple_table)"
#
# ## Class CSV
#
# Class CSV provides methods for:
# *   Parsing CSV data from a String object, a File (via its file path), or an
#     IO object.
# *   Generating CSV data to a String object.
#
# To make CSV available:
#     require 'csv'
#
# All examples here assume that this has been done.
#
# ## Keeping It Simple
#
# A CSV object has dozens of instance methods that offer fine-grained control of
# parsing and generating CSV data. For many needs, though, simpler approaches
# will do.
#
# This section summarizes the singleton methods in CSV that allow you to parse
# and generate without explicitly creating CSV objects. For details, follow the
# links.
#
# ### Simple Parsing
#
# Parsing methods commonly return either of:
# *   An Array of Arrays of Strings:
#     *   The outer Array is the entire "table".
#     *   Each inner Array is a row.
#     *   Each String is a field.
# *   A CSV::Table object.  For details, see [\CSV with
#     Headers](#class-CSV-label-CSV+with+Headers).
#
# #### Parsing a String
#
# The input to be parsed can be a string:
#     string = "foo,0\nbar,1\nbaz,2\n"
#
# Method CSV.parse returns the entire CSV data:
#     CSV.parse(string) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.parse_line returns only the first row:
#     CSV.parse_line(string) # => ["foo", "0"]
#
# CSV extends class String with instance method String#parse_csv, which also
# returns only the first row:
#     string.parse_csv # => ["foo", "0"]
#
# #### Parsing Via a File Path
#
# The input to be parsed can be in a file:
#     string = "foo,0\nbar,1\nbaz,2\n"
#     path = 't.csv'
#     File.write(path, string)
#
# Method CSV.read returns the entire CSV data:
#     CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.foreach iterates, passing each row to the given block:
#     CSV.foreach(path) do |row|
#       p row
#     end
#
# Output:
#     ["foo", "0"]
#     ["bar", "1"]
#     ["baz", "2"]
#
# Method CSV.table returns the entire CSV data as a CSV::Table object:
#     CSV.table(path) # => #<CSV::Table mode:col_or_row row_count:3>
#
# #### Parsing from an Open IO Stream
#
# The input to be parsed can be in an open IO stream:
#
# Method CSV.read returns the entire CSV data:
#     File.open(path) do |file|
#       CSV.read(file)
#     end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# As does method CSV.parse:
#     File.open(path) do |file|
#       CSV.parse(file)
#     end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.parse_line returns only the first row:
#     File.open(path) do |file|
#      CSV.parse_line(file)
#     end # => ["foo", "0"]
#
# Method CSV.foreach iterates, passing each row to the given block:
#     File.open(path) do |file|
#       CSV.foreach(file) do |row|
#         p row
#       end
#     end
#
# Output:
#     ["foo", "0"]
#     ["bar", "1"]
#     ["baz", "2"]
#
# Method CSV.table returns the entire CSV data as a CSV::Table object:
#     File.open(path) do |file|
#       CSV.table(file)
#     end # => #<CSV::Table mode:col_or_row row_count:3>
#
# ### Simple Generating
#
# Method CSV.generate returns a String; this example uses method CSV#<< to
# append the rows that are to be generated:
#     output_string = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ['bar', 1]
#       csv << ['baz', 2]
#     end
#     output_string # => "foo,0\nbar,1\nbaz,2\n"
#
# Method CSV.generate_line returns a String containing the single row
# constructed from an Array:
#     CSV.generate_line(['foo', '0']) # => "foo,0\n"
#
# CSV extends class Array with instance method `Array#to_csv`, which forms an
# Array into a String:
#     ['foo', '0'].to_csv # => "foo,0\n"
#
# ### "Filtering" CSV
#
# Method CSV.filter provides a Unix-style filter for CSV data. The input data is
# processed to form the output data:
#     in_string = "foo,0\nbar,1\nbaz,2\n"
#     out_string = ''
#     CSV.filter(in_string, out_string) do |row|
#       row[0] = row[0].upcase
#       row[1] *= 4
#     end
#     out_string # => "FOO,0000\nBAR,1111\nBAZ,2222\n"
#
# ## CSV Objects
#
# There are three ways to create a CSV object:
# *   Method CSV.new returns a new CSV object.
# *   Method CSV.instance returns a new or cached CSV object.
# *   Method CSV() also returns a new or cached CSV object.
#
# ### Instance Methods
#
# CSV has three groups of instance methods:
# *   Its own internally defined instance methods.
# *   Methods included by module Enumerable.
# *   Methods delegated to class IO. See below.
#
# #### Delegated Methods
#
# For convenience, a CSV object will delegate to many methods in class IO. (A
# few have wrapper "guard code" in CSV.) You may call:
# *   IO#binmode
# *   #binmode?
# *   IO#close
# *   IO#close_read
# *   IO#close_write
# *   IO#closed?
# *   #eof
# *   #eof?
# *   IO#external_encoding
# *   IO#fcntl
# *   IO#fileno
# *   #flock
# *   IO#flush
# *   IO#fsync
# *   IO#internal_encoding
# *   #ioctl
# *   IO#isatty
# *   #path
# *   IO#pid
# *   IO#pos
# *   IO#pos=
# *   IO#reopen
# *   #rewind
# *   IO#seek
# *   #stat
# *   IO#string
# *   IO#sync
# *   IO#sync=
# *   IO#tell
# *   #to_i
# *   #to_io
# *   IO#truncate
# *   IO#tty?
#
# ### Options
#
# The default values for options are:
#     DEFAULT_OPTIONS = {
#       # For both parsing and generating.
#       col_sep:            ",",
#       row_sep:            :auto,
#       quote_char:         '"',
#       # For parsing.
#       field_size_limit:   nil,
#       converters:         nil,
#       unconverted_fields: nil,
#       headers:            false,
#       return_headers:     false,
#       header_converters:  nil,
#       skip_blanks:        false,
#       skip_lines:         nil,
#       liberal_parsing:    false,
#       nil_value:          nil,
#       empty_value:        "",
#       strip:              false,
#       # For generating.
#       write_headers:      nil,
#       quote_empty:        true,
#       force_quotes:       false,
#       write_converters:   nil,
#       write_nil_value:    nil,
#       write_empty_value:  "",
#     }
#
# #### Options for Parsing
#
# Options for parsing, described in detail below, include:
# *   `row_sep`: Specifies the row separator; used to delimit rows.
# *   `col_sep`: Specifies the column separator; used to delimit fields.
# *   `quote_char`: Specifies the quote character; used to quote fields.
# *   `field_size_limit`: Specifies the maximum field size + 1 allowed.
#     Deprecated since 3.2.3. Use `max_field_size` instead.
# *   `max_field_size`: Specifies the maximum field size allowed.
# *   `converters`: Specifies the field converters to be used.
# *   `unconverted_fields`: Specifies whether unconverted fields are to be
#     available.
# *   `headers`: Specifies whether data contains headers, or specifies the
#     headers themselves.
# *   `return_headers`: Specifies whether headers are to be returned.
# *   `header_converters`: Specifies the header converters to be used.
# *   `skip_blanks`: Specifies whether blanks lines are to be ignored.
# *   `skip_lines`: Specifies how comments lines are to be recognized.
# *   `strip`: Specifies whether leading and trailing whitespace are to be
#     stripped from fields. This must be compatible with `col_sep`; if it is
#     not, then an `ArgumentError` exception will be raised.
# *   `liberal_parsing`: Specifies whether CSV should attempt to parse
#     non-compliant data.
# *   `nil_value`: Specifies the object that is to be substituted for each null
#     (no-text) field.
# *   `empty_value`: Specifies the object that is to be substituted for each
#     empty field.
#
# ###### Option `row_sep`
#
# Specifies the row separator, a String or the Symbol `:auto` (see below), to be
# used for both parsing and generating.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto
#
# ---
#
# When `row_sep` is a String, that String becomes the row separator. The String
# will be transcoded into the data's Encoding before use.
#
# Using `"\n"`:
#     row_sep = "\n"
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `|` (pipe):
#     row_sep = '|'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0|bar,1|baz,2|"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `--` (two hyphens):
#     row_sep = '--'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0--bar,1--baz,2--"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     row_sep = ''
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0bar,1baz,2"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0bar", "1baz", "2"]]
#
# ---
#
# When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
# the row separator:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#
# Parsing, on the other hand, invokes auto-discovery of the row separator.
#
# Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
# `\r` sequence. The sequence will be selected even if it occurs in a quoted
# field, assuming that you would have the same line endings there.
#
# Example:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
# is true:
# *   None of those sequences is found.
# *   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
# *   The stream is only available for output.
#
# Obviously, discovery takes a little time. Set manually if speed is important.
# Also note that IO objects should be opened in binary mode on Windows if this
# feature will be used as the line-ending translation can cause problems with
# resetting the document position to where it was before the read ahead.
#
# ###### Option `col_sep`
#
# Specifies the String field separator to be used for both parsing and
# generating. The String will be transcoded into the data's Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)
#
# Using the default (comma):
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `:` (colon):
#     col_sep = ':'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo:0\nbar:1\nbaz:2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `::` (two colons):
#     col_sep = '::'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo::0\nbar::1\nbaz::2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     col_sep = ''
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo0\nbar1\nbaz2\n"
#
# ---
#
# Raises an exception if parsing with the empty String:
#     col_sep = ''
#     # Raises ArgumentError (:col_sep must be 1 or more characters: "")
#     CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
#
# ###### Option `quote_char`
#
# Specifies the character (String of length 1) used used to quote fields in both
# parsing and generating. This String will be transcoded into the data's
# Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)
#
# This is useful for an application that incorrectly uses `'` (single-quote) to
# quote fields, instead of the correct `"` (double-quote).
#
# Using the default (double quote):
#     str = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# Using `'` (single-quote):
#     quote_char = "'"
#     str = CSV.generate(quote_char: quote_char) do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
#     ary = CSV.parse(str, quote_char: quote_char)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# ---
#
# Raises an exception if the String length is greater than 1:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: 'xx')
#
# Raises an exception if the value is not a String:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: :foo)
#
# ###### Option `field_size_limit`
#
# Specifies the Integer field size limit.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:field_size_limit) # => nil
#
# This is a maximum size CSV will read ahead looking for the closing quote for a
# field. (In truth, it reads to the first line ending beyond this size.) If a
# quote cannot be found within the limit CSV will raise a MalformedCSVError,
# assuming the data is faulty. You can use this limit to prevent what are
# effectively DoS attacks on the parser. However, this limit can cause a
# legitimate parse to fail; therefore the default value is `nil` (no limit).
#
# For the examples in this section:
#     str = <<~EOT
#       "a","b"
#       "
#       2345
#       ",""
#     EOT
#     str # => "\"a\",\"b\"\n\"\n2345\n\",\"\"\n"
#
# Using the default `nil`:
#     ary = CSV.parse(str)
#     ary # => [["a", "b"], ["\n2345\n", ""]]
#
# Using `50`:
#     field_size_limit = 50
#     ary = CSV.parse(str, field_size_limit: field_size_limit)
#     ary # => [["a", "b"], ["\n2345\n", ""]]
#
# ---
#
# Raises an exception if a field is too long:
#     big_str = "123456789\n" * 1024
#     # Raises CSV::MalformedCSVError (Field size exceeded in line 1.)
#     CSV.parse('valid,fields,"' + big_str + '"', field_size_limit: 2048)
#
# ###### Option `converters`
#
# Specifies converters to be used in parsing fields. See [Field
# Converters](#class-CSV-label-Field+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:converters) # => nil
#
# The value may be a field converter name (see [Stored
# Converters](#class-CSV-label-Stored+Converters)):
#     str = '1,2,3'
#     # Without a converter
#     array = CSV.parse_line(str)
#     array # => ["1", "2", "3"]
#     # With built-in converter :integer
#     array = CSV.parse_line(str, converters: :integer)
#     array # => [1, 2, 3]
#
# The value may be a converter list (see [Converter
# Lists](#class-CSV-label-Converter+Lists)):
#     str = '1,3.14159'
#     # Without converters
#     array = CSV.parse_line(str)
#     array # => ["1", "3.14159"]
#     # With built-in converters
#     array = CSV.parse_line(str, converters: [:integer, :float])
#     array # => [1, 3.14159]
#
# The value may be a Proc custom converter: (see [Custom Field
# Converters](#class-CSV-label-Custom+Field+Converters)):
#     str = ' foo  ,  bar  ,  baz  '
#     # Without a converter
#     array = CSV.parse_line(str)
#     array # => [" foo  ", "  bar  ", "  baz  "]
#     # With a custom converter
#     array = CSV.parse_line(str, converters: proc {|field| field.strip })
#     array # => ["foo", "bar", "baz"]
#
# See also [Custom Field Converters](#class-CSV-label-Custom+Field+Converters)
#
# ---
#
# Raises an exception if the converter is not a converter name or a Proc:
#     str = 'foo,0'
#     # Raises NoMethodError (undefined method `arity' for nil:NilClass)
#     CSV.parse(str, converters: :foo)
#
# ###### Option `unconverted_fields`
#
# Specifies the boolean that determines whether unconverted field values are to
# be available.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:unconverted_fields) # => nil
#
# The unconverted field values are those found in the source data, prior to any
# conversions performed via option `converters`.
#
# When option `unconverted_fields` is `true`, each returned row (Array or
# CSV::Row) has an added method, `unconverted_fields`, that returns the
# unconverted field values:
#     str = <<-EOT
#     foo,0
#     bar,1
#     baz,2
#     EOT
#     # Without unconverted_fields
#     csv = CSV.parse(str, converters: :integer)
#     csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
#     csv.first.respond_to?(:unconverted_fields) # => false
#     # With unconverted_fields
#     csv = CSV.parse(str, converters: :integer, unconverted_fields: true)
#     csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
#     csv.first.respond_to?(:unconverted_fields) # => true
#     csv.first.unconverted_fields # => ["foo", "0"]
#
# ###### Option `headers`
#
# Specifies a boolean, Symbol, Array, or String to be used to define column
# headers.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:headers) # => false
#
# ---
#
# Without `headers`:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str)
#     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
#     csv.headers # => nil
#     csv.shift # => ["Name", "Count"]
#
# ---
#
# If set to `true` or the Symbol `:first_row`, the first row of the data is
# treated as a row of headers:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: true)
#     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:2 col_sep:"," row_sep:"\n" quote_char:"\"" headers:["Name", "Count"]>
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ---
#
# If set to an Array, the Array elements are treated as headers:
#     str = <<-EOT
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: ['Name', 'Count'])
#     csv
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ---
#
# If set to a String `str`, method `CSV::parse_line(str, options)` is called
# with the current `options`, and the returned Array is treated as headers:
#     str = <<-EOT
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: 'Name,Count')
#     csv
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ###### Option `return_headers`
#
# Specifies the boolean that determines whether method #shift returns or ignores
# the header row.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:return_headers) # => false
#
# Examples:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     # Without return_headers first row is str.
#     csv = CSV.new(str, headers: true)
#     csv.shift # => #<CSV::Row "Name":"foo" "Count":"0">
#     # With return_headers first row is headers.
#     csv = CSV.new(str, headers: true, return_headers: true)
#     csv.shift # => #<CSV::Row "Name":"Name" "Count":"Count">
#
# ###### Option `header_converters`
#
# Specifies converters to be used in parsing headers. See [Header
# Converters](#class-CSV-label-Header+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:header_converters) # => nil
#
# Identical in functionality to option
# [converters](#class-CSV-label-Option+converters) except that:
# *   The converters apply only to the header row.
# *   The built-in header converters are `:downcase` and `:symbol`.
#
# This section assumes prior execution of:
#     str = <<-EOT
#     Name,Value
#     foo,0
#     bar,1
#     baz,2
#     EOT
#     # With no header converter
#     table = CSV.parse(str, headers: true)
#     table.headers # => ["Name", "Value"]
#
# The value may be a header converter name (see [Stored
# Converters](#class-CSV-label-Stored+Converters)):
#     table = CSV.parse(str, headers: true, header_converters: :downcase)
#     table.headers # => ["name", "value"]
#
# The value may be a converter list (see [Converter
# Lists](#class-CSV-label-Converter+Lists)):
#     header_converters = [:downcase, :symbol]
#     table = CSV.parse(str, headers: true, header_converters: header_converters)
#     table.headers # => [:name, :value]
#
# The value may be a Proc custom converter (see [Custom Header
# Converters](#class-CSV-label-Custom+Header+Converters)):
#     upcase_converter = proc {|field| field.upcase }
#     table = CSV.parse(str, headers: true, header_converters: upcase_converter)
#     table.headers # => ["NAME", "VALUE"]
#
# See also [Custom Header Converters](#class-CSV-label-Custom+Header+Converters)
#
# ###### Option `skip_blanks`
#
# Specifies a boolean that determines whether blank lines in the input will be
# ignored; a line that contains a column separator is not considered to be
# blank.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:skip_blanks) # => false
#
# See also option [skiplines](#class-CSV-label-Option+skip_lines).
#
# For examples in this section:
#     str = <<-EOT
#     foo,0
#
#     bar,1
#     baz,2
#
#     ,
#     EOT
#
# Using the default, `false`:
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], [], ["bar", "1"], ["baz", "2"], [], [nil, nil]]
#
# Using `true`:
#     ary = CSV.parse(str, skip_blanks: true)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
#
# Using a truthy value:
#     ary = CSV.parse(str, skip_blanks: :foo)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
#
# ###### Option `skip_lines`
#
# Specifies an object to use in identifying comment lines in the input that are
# to be ignored:
# *   If a Regexp, ignores lines that match it.
# *   If a String, converts it to a Regexp, ignores lines that match it.
# *   If `nil`, no lines are considered to be comments.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:skip_lines) # => nil
#
# For examples in this section:
#     str = <<-EOT
#     # Comment
#     foo,0
#     bar,1
#     baz,2
#     # Another comment
#     EOT
#     str # => "# Comment\nfoo,0\nbar,1\nbaz,2\n# Another comment\n"
#
# Using the default, `nil`:
#     ary = CSV.parse(str)
#     ary # => [["# Comment"], ["foo", "0"], ["bar", "1"], ["baz", "2"], ["# Another comment"]]
#
# Using a Regexp:
#     ary = CSV.parse(str, skip_lines: /^#/)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using a String:
#     ary = CSV.parse(str, skip_lines: '#')
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# ---
#
# Raises an exception if given an object that is not a Regexp, a String, or
# `nil`:
#     # Raises ArgumentError (:skip_lines has to respond to #match: 0)
#     CSV.parse(str, skip_lines: 0)
#
# ###### Option `strip`
#
# Specifies the boolean value that determines whether whitespace is stripped
# from each input field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:strip) # => false
#
# With default value `false`:
#     ary = CSV.parse_line(' a , b ')
#     ary # => [" a ", " b "]
#
# With value `true`:
#     ary = CSV.parse_line(' a , b ', strip: true)
#     ary # => ["a", "b"]
#
# ###### Option `liberal_parsing`
#
# Specifies the boolean or hash value that determines whether CSV will attempt
# to parse input not conformant with RFC 4180, such as double quotes in unquoted
# fields.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:liberal_parsing) # => false
#
# For the next two examples:
#     str = 'is,this "three, or four",fields'
#
# Without `liberal_parsing`:
#     # Raises CSV::MalformedCSVError (Illegal quoting in str 1.)
#     CSV.parse_line(str)
#
# With `liberal_parsing`:
#     ary = CSV.parse_line(str, liberal_parsing: true)
#     ary # => ["is", "this \"three", " or four\"", "fields"]
#
# Use the `backslash_quote` sub-option to parse values that use a backslash to
# escape a double-quote character.  This causes the parser to treat `\"` as if
# it were `""`.
#
# For the next two examples:
#     str = 'Show,"Harry \"Handcuff\" Houdini, the one and only","Tampa Theater"'
#
# With `liberal_parsing`, but without the `backslash_quote` sub-option:
#     # Incorrect interpretation of backslash; incorrectly interprets the quoted comma as a field separator.
#     ary = CSV.parse_line(str, liberal_parsing: true)
#     ary # => ["Show", "\"Harry \\\"Handcuff\\\" Houdini", " the one and only\"", "Tampa Theater"]
#     puts ary[1] # => "Harry \"Handcuff\" Houdini
#
# With `liberal_parsing` and its `backslash_quote` sub-option:
#     ary = CSV.parse_line(str, liberal_parsing: { backslash_quote: true })
#     ary # => ["Show", "Harry \"Handcuff\" Houdini, the one and only", "Tampa Theater"]
#     puts ary[1] # => Harry "Handcuff" Houdini, the one and only
#
# ###### Option `nil_value`
#
# Specifies the object that is to be substituted for each null (no-text) field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:nil_value) # => nil
#
# With the default, `nil`:
#     CSV.parse_line('a,,b,,c') # => ["a", nil, "b", nil, "c"]
#
# With a different object:
#     CSV.parse_line('a,,b,,c', nil_value: 0) # => ["a", 0, "b", 0, "c"]
#
# ###### Option `empty_value`
#
# Specifies the object that is to be substituted for each field that has an
# empty String.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:empty_value) # => "" (empty string)
#
# With the default, `""`:
#     CSV.parse_line('a,"",b,"",c') # => ["a", "", "b", "", "c"]
#
# With a different object:
#     CSV.parse_line('a,"",b,"",c', empty_value: 'x') # => ["a", "x", "b", "x", "c"]
#
# #### Options for Generating
#
# Options for generating, described in detail below, include:
# *   `row_sep`: Specifies the row separator; used to delimit rows.
# *   `col_sep`: Specifies the column separator; used to delimit fields.
# *   `quote_char`: Specifies the quote character; used to quote fields.
# *   `write_headers`: Specifies whether headers are to be written.
# *   `force_quotes`: Specifies whether each output field is to be quoted.
# *   `quote_empty`: Specifies whether each empty output field is to be quoted.
# *   `write_converters`: Specifies the field converters to be used in writing.
# *   `write_nil_value`: Specifies the object that is to be substituted for each
#     `nil`-valued field.
# *   `write_empty_value`: Specifies the object that is to be substituted for
#     each empty field.
#
# ###### Option `row_sep`
#
# Specifies the row separator, a String or the Symbol `:auto` (see below), to be
# used for both parsing and generating.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto
#
# ---
#
# When `row_sep` is a String, that String becomes the row separator. The String
# will be transcoded into the data's Encoding before use.
#
# Using `"\n"`:
#     row_sep = "\n"
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `|` (pipe):
#     row_sep = '|'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0|bar,1|baz,2|"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `--` (two hyphens):
#     row_sep = '--'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0--bar,1--baz,2--"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     row_sep = ''
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0bar,1baz,2"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0bar", "1baz", "2"]]
#
# ---
#
# When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
# the row separator:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#
# Parsing, on the other hand, invokes auto-discovery of the row separator.
#
# Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
# `\r` sequence. The sequence will be selected even if it occurs in a quoted
# field, assuming that you would have the same line endings there.
#
# Example:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
# is true:
# *   None of those sequences is found.
# *   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
# *   The stream is only available for output.
#
# Obviously, discovery takes a little time. Set manually if speed is important.
# Also note that IO objects should be opened in binary mode on Windows if this
# feature will be used as the line-ending translation can cause problems with
# resetting the document position to where it was before the read ahead.
#
# ###### Option `col_sep`
#
# Specifies the String field separator to be used for both parsing and
# generating. The String will be transcoded into the data's Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)
#
# Using the default (comma):
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `:` (colon):
#     col_sep = ':'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo:0\nbar:1\nbaz:2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `::` (two colons):
#     col_sep = '::'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo::0\nbar::1\nbaz::2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     col_sep = ''
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo0\nbar1\nbaz2\n"
#
# ---
#
# Raises an exception if parsing with the empty String:
#     col_sep = ''
#     # Raises ArgumentError (:col_sep must be 1 or more characters: "")
#     CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
#
# ###### Option `quote_char`
#
# Specifies the character (String of length 1) used used to quote fields in both
# parsing and generating. This String will be transcoded into the data's
# Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)
#
# This is useful for an application that incorrectly uses `'` (single-quote) to
# quote fields, instead of the correct `"` (double-quote).
#
# Using the default (double quote):
#     str = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# Using `'` (single-quote):
#     quote_char = "'"
#     str = CSV.generate(quote_char: quote_char) do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
#     ary = CSV.parse(str, quote_char: quote_char)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# ---
#
# Raises an exception if the String length is greater than 1:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: 'xx')
#
# Raises an exception if the value is not a String:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: :foo)
#
# ###### Option `write_headers`
#
# Specifies the boolean that determines whether a header row is included in the
# output; ignored if there are no headers.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_headers) # => nil
#
# Without `write_headers`:
#     file_path = 't.csv'
#     CSV.open(file_path,'w',
#         :headers => ['Name','Value']
#       ) do |csv|
#         csv << ['foo', '0']
#     end
#     CSV.open(file_path) do |csv|
#       csv.shift
#     end # => ["foo", "0"]
#
# With `write_headers`":
#     CSV.open(file_path,'w',
#         :write_headers => true,
#         :headers => ['Name','Value']
#       ) do |csv|
#         csv << ['foo', '0']
#     end
#     CSV.open(file_path) do |csv|
#       csv.shift
#     end # => ["Name", "Value"]
#
# ###### Option `force_quotes`
#
# Specifies the boolean that determines whether each output field is to be
# double-quoted.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:force_quotes) # => false
#
# For examples in this section:
#     ary = ['foo', 0, nil]
#
# Using the default, `false`:
#     str = CSV.generate_line(ary)
#     str # => "foo,0,\n"
#
# Using `true`:
#     str = CSV.generate_line(ary, force_quotes: true)
#     str # => "\"foo\",\"0\",\"\"\n"
#
# ###### Option `quote_empty`
#
# Specifies the boolean that determines whether an empty value is to be
# double-quoted.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_empty) # => true
#
# With the default `true`:
#     CSV.generate_line(['"', ""]) # => "\"\"\"\",\"\"\n"
#
# With `false`:
#     CSV.generate_line(['"', ""], quote_empty: false) # => "\"\"\"\",\n"
#
# ###### Option `write_converters`
#
# Specifies converters to be used in generating fields. See [Write
# Converters](#class-CSV-label-Write+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_converters) # => nil
#
# With no write converter:
#     str = CSV.generate_line(["\na\n", "\tb\t", " c "])
#     str # => "\"\na\n\",\tb\t, c \n"
#
# With a write converter:
#     strip_converter = proc {|field| field.strip }
#     str = CSV.generate_line(["\na\n", "\tb\t", " c "], write_converters: strip_converter)
#     str # => "a,b,c\n"
#
# With two write converters (called in order):
#     upcase_converter = proc {|field| field.upcase }
#     downcase_converter = proc {|field| field.downcase }
#     write_converters = [upcase_converter, downcase_converter]
#     str = CSV.generate_line(['a', 'b', 'c'], write_converters: write_converters)
#     str # => "a,b,c\n"
#
# See also [Write Converters](#class-CSV-label-Write+Converters)
#
# ###### Option `write_nil_value`
#
# Specifies the object that is to be substituted for each `nil`-valued field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_nil_value) # => nil
#
# Without the option:
#     str = CSV.generate_line(['a', nil, 'c', nil])
#     str # => "a,,c,\n"
#
# With the option:
#     str = CSV.generate_line(['a', nil, 'c', nil], write_nil_value: "x")
#     str # => "a,x,c,x\n"
#
# ###### Option `write_empty_value`
#
# Specifies the object that is to be substituted for each field that has an
# empty String.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_empty_value) # => ""
#
# Without the option:
#     str = CSV.generate_line(['a', '', 'c', ''])
#     str # => "a,\"\",c,\"\"\n"
#
# With the option:
#     str = CSV.generate_line(['a', '', 'c', ''], write_empty_value: "x")
#     str # => "a,x,c,x\n"
#
# ### CSV with Headers
#
# CSV allows to specify column names of CSV file, whether they are in data, or
# provided separately. If headers are specified, reading methods return an
# instance of CSV::Table, consisting of CSV::Row.
#
#     # Headers are part of data
#     data = CSV.parse(<<~ROWS, headers: true)
#       Name,Department,Salary
#       Bob,Engineering,1000
#       Jane,Sales,2000
#       John,Management,5000
#     ROWS
#
#     data.class      #=> CSV::Table
#     data.first      #=> #<CSV::Row "Name":"Bob" "Department":"Engineering" "Salary":"1000">
#     data.first.to_h #=> {"Name"=>"Bob", "Department"=>"Engineering", "Salary"=>"1000"}
#
#     # Headers provided by developer
#     data = CSV.parse('Bob,Engineering,1000', headers: %i[name department salary])
#     data.first      #=> #<CSV::Row name:"Bob" department:"Engineering" salary:"1000">
#
# ### Converters
#
# By default, each value (field or header) parsed by CSV is formed into a
# String. You can use a *field* *converter* or  *header* *converter* to
# intercept and modify the parsed values:
# *   See [Field Converters](#class-CSV-label-Field+Converters).
# *   See [Header Converters](#class-CSV-label-Header+Converters).
#
# Also by default, each value to be written during generation is written
# 'as-is'. You can use a *write* *converter* to modify values before writing.
# *   See [Write Converters](#class-CSV-label-Write+Converters).
#
# #### Specifying Converters
#
# You can specify converters for parsing or generating in the `options` argument
# to various CSV methods:
# *   Option `converters` for converting parsed field values.
# *   Option `header_converters` for converting parsed header values.
# *   Option `write_converters` for converting values to be written (generated).
#
# There are three forms for specifying converters:
# *   A converter proc: executable code to be used for conversion.
# *   A converter name: the name of a stored converter.
# *   A converter list: an array of converter procs, converter names, and
#     converter lists.
#
# ##### Converter Procs
#
# This converter proc, `strip_converter`, accepts a value `field` and returns
# `field.strip`:
#     strip_converter = proc {|field| field.strip }
#
# In this call to `CSV.parse`, the keyword argument `converters:
# string_converter` specifies that:
# *   Proc `string_converter` is to be called for each parsed field.
# *   The converter's return value is to replace the `field` value.
# Example:
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# A converter proc can receive a second argument, `field_info`, that contains
# details about the field. This modified `strip_converter` displays its
# arguments:
#     strip_converter = proc do |field, field_info|
#       p [field, field_info]
#       field.strip
#     end
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Output:
#     [" foo ", #<struct CSV::FieldInfo index=0, line=1, header=nil>]
#     [" 0 ", #<struct CSV::FieldInfo index=1, line=1, header=nil>]
#     [" bar ", #<struct CSV::FieldInfo index=0, line=2, header=nil>]
#     [" 1 ", #<struct CSV::FieldInfo index=1, line=2, header=nil>]
#     [" baz ", #<struct CSV::FieldInfo index=0, line=3, header=nil>]
#     [" 2 ", #<struct CSV::FieldInfo index=1, line=3, header=nil>]
#
# Each CSV::FieldInfo object shows:
# *   The 0-based field index.
# *   The 1-based line index.
# *   The field header, if any.
#
# ##### Stored Converters
#
# A converter may be given a name and stored in a structure where the parsing
# methods can find it by name.
#
# The storage structure for field converters is the Hash CSV::Converters. It has
# several built-in converter procs:
# *   `:integer`: converts each String-embedded integer into a true Integer.
# *   `:float`: converts each String-embedded float into a true Float.
# *   `:date`: converts each String-embedded date into a true Date.
# *   `:date_time`: converts each String-embedded date-time into a true DateTime
# . This example creates a converter proc, then stores it:
#     strip_converter = proc {|field| field.strip }
#     CSV::Converters[:strip] = strip_converter
#
# Then the parsing method call can refer to the converter by its name, `:strip`:
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: :strip)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The storage structure for header converters is the Hash CSV::HeaderConverters,
# which works in the same way. It also has built-in converter procs:
# *   `:downcase`: Downcases each header.
# *   `:symbol`: Converts each header to a Symbol.
#
# There is no such storage structure for write headers.
#
# In order for the parsing methods to access stored converters in
# non-main-Ractors, the storage structure must be made shareable first.
# Therefore, `Ractor.make_shareable(CSV::Converters)` and
# `Ractor.make_shareable(CSV::HeaderConverters)` must be called before the
# creation of Ractors that use the converters stored in these structures. (Since
# making the storage structures shareable involves freezing them, any custom
# converters that are to be used must be added first.)
#
# ##### Converter Lists
#
# A *converter* *list* is an Array that may include any assortment of:
# *   Converter procs.
# *   Names of stored converters.
# *   Nested converter lists.
#
# Examples:
#     numeric_converters = [:integer, :float]
#     date_converters = [:date, :date_time]
#     [numeric_converters, strip_converter]
#     [strip_converter, date_converters, :float]
#
# Like a converter proc, a converter list may be named and stored in either
# CSV::Converters or CSV::HeaderConverters:
#     CSV::Converters[:custom] = [strip_converter, date_converters, :float]
#     CSV::HeaderConverters[:custom] = [:downcase, :symbol]
#
# There are two built-in converter lists:
#     CSV::Converters[:numeric] # => [:integer, :float]
#     CSV::Converters[:all] # => [:date_time, :numeric]
#
# #### Field Converters
#
# With no conversion, all parsed fields in all rows become Strings:
#     string = "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(string)
#     ary # => # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# When you specify a field converter, each parsed field is passed to the
# converter; its return value becomes the stored value for the field. A
# converter might, for example, convert an integer embedded in a String into a
# true Integer. (In fact, that's what built-in field converter `:integer` does.)
#
# There are three ways to use field converters.
#
# *   Using option [converters](#class-CSV-label-Option+converters) with a
#     parsing method:
#         ary = CSV.parse(string, converters: :integer)
#         ary # => [0, 1, 2] # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
# *   Using option [converters](#class-CSV-label-Option+converters) with a new
#     CSV instance:
#         csv = CSV.new(string, converters: :integer)
#         # Field converters in effect:
#         csv.converters # => [:integer]
#         csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
# *   Using method #convert to add a field converter to a CSV instance:
#         csv = CSV.new(string)
#         # Add a converter.
#         csv.convert(:integer)
#         csv.converters # => [:integer]
#         csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
# Installing a field converter does not affect already-read rows:
#     csv = CSV.new(string)
#     csv.shift # => ["foo", "0"]
#     # Add a converter.
#     csv.convert(:integer)
#     csv.converters # => [:integer]
#     csv.read # => [["bar", 1], ["baz", 2]]
#
# There are additional built-in converters, and custom converters are also
# supported.
#
# ##### Built-In Field Converters
#
# The built-in field converters are in Hash CSV::Converters:
# *   Each key is a field converter name.
# *   Each value is one of:
#     *   A Proc field converter.
#     *   An Array of field converter names.
#
# Display:
#     CSV::Converters.each_pair do |name, value|
#       if value.kind_of?(Proc)
#         p [name, value.class]
#       else
#         p [name, value]
#       end
#     end
#
# Output:
#     [:integer, Proc]
#     [:float, Proc]
#     [:numeric, [:integer, :float]]
#     [:date, Proc]
#     [:date_time, Proc]
#     [:all, [:date_time, :numeric]]
#
# Each of these converters transcodes values to UTF-8 before attempting
# conversion. If a value cannot be transcoded to UTF-8 the conversion will fail
# and the value will remain unconverted.
#
# Converter `:integer` converts each field that Integer() accepts:
#     data = '0,1,2,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["0", "1", "2", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :integer)
#     csv # => [0, 1, 2, "x"]
#
# Converter `:float` converts each field that Float() accepts:
#     data = '1.0,3.14159,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["1.0", "3.14159", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :float)
#     csv # => [1.0, 3.14159, "x"]
#
# Converter `:numeric` converts with both `:integer` and `:float`..
#
# Converter `:date` converts each field that Date::parse accepts:
#     data = '2001-02-03,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["2001-02-03", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :date)
#     csv # => [#<Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)>, "x"]
#
# Converter `:date_time` converts each field that DateTime::parse accepts:
#     data = '2020-05-07T14:59:00-05:00,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["2020-05-07T14:59:00-05:00", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :date_time)
#     csv # => [#<DateTime: 2020-05-07T14:59:00-05:00 ((2458977j,71940s,0n),-18000s,2299161j)>, "x"]
#
# Converter `:numeric` converts with both `:date_time` and `:numeric`..
#
# As seen above, method #convert adds converters to a CSV instance, and method
# #converters returns an Array of the converters in effect:
#     csv = CSV.new('0,1,2')
#     csv.converters # => []
#     csv.convert(:integer)
#     csv.converters # => [:integer]
#     csv.convert(:date)
#     csv.converters # => [:integer, :date]
#
# ##### Custom Field Converters
#
# You can define a custom field converter:
#     strip_converter = proc {|field| field.strip }
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# You can register the converter in Converters Hash, which allows you to refer
# to it by name:
#     CSV::Converters[:strip] = strip_converter
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: :strip)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# #### Header Converters
#
# Header converters operate only on headers (and not on other rows).
#
# There are three ways to use header converters; these examples use built-in
# header converter `:downcase`, which downcases each parsed header.
#
# *   Option `header_converters` with a singleton parsing method:
#         string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#         tbl = CSV.parse(string, headers: true, header_converters: :downcase)
#         tbl.class # => CSV::Table
#         tbl.headers # => ["name", "count"]
#
# *   Option `header_converters` with a new CSV instance:
#         csv = CSV.new(string, header_converters: :downcase)
#         # Header converters in effect:
#         csv.header_converters # => [:downcase]
#         tbl = CSV.parse(string, headers: true)
#         tbl.headers # => ["Name", "Count"]
#
# *   Method #header_convert adds a header converter to a CSV instance:
#         csv = CSV.new(string)
#         # Add a header converter.
#         csv.header_convert(:downcase)
#         csv.header_converters # => [:downcase]
#         tbl = CSV.parse(string, headers: true)
#         tbl.headers # => ["Name", "Count"]
#
# ##### Built-In Header Converters
#
# The built-in header converters are in Hash CSV::HeaderConverters. The keys
# there are the names of the converters:
#     CSV::HeaderConverters.keys # => [:downcase, :symbol]
#
# Converter `:downcase` converts each header by downcasing it:
#     string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#     tbl = CSV.parse(string, headers: true, header_converters: :downcase)
#     tbl.class # => CSV::Table
#     tbl.headers # => ["name", "count"]
#
# Converter `:symbol` converts each header by making it into a Symbol:
#     string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#     tbl = CSV.parse(string, headers: true, header_converters: :symbol)
#     tbl.headers # => [:name, :count]
#
# Details:
# *   Strips leading and trailing whitespace.
# *   Downcases the header.
# *   Replaces embedded spaces with underscores.
# *   Removes non-word characters.
# *   Makes the string into a Symbol.
#
# ##### Custom Header Converters
#
# You can define a custom header converter:
#     upcase_converter = proc {|header| header.upcase }
#     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(string, headers: true, header_converters: upcase_converter)
#     table # => #<CSV::Table mode:col_or_row row_count:4>
#     table.headers # => ["NAME", "VALUE"]
#
# You can register the converter in HeaderConverters Hash, which allows you to
# refer to it by name:
#     CSV::HeaderConverters[:upcase] = upcase_converter
#     table = CSV.parse(string, headers: true, header_converters: :upcase)
#     table # => #<CSV::Table mode:col_or_row row_count:4>
#     table.headers # => ["NAME", "VALUE"]
#
# ##### Write Converters
#
# When you specify a write converter for generating CSV, each field to be
# written is passed to the converter; its return value becomes the new value for
# the field. A converter might, for example, strip whitespace from a field.
#
# Using no write converter (all fields unmodified):
#     output_string = CSV.generate do |csv|
#       csv << [' foo ', 0]
#       csv << [' bar ', 1]
#       csv << [' baz ', 2]
#     end
#     output_string # => " foo ,0\n bar ,1\n baz ,2\n"
#
# Using option `write_converters` with two custom write converters:
#     strip_converter = proc {|field| field.respond_to?(:strip) ? field.strip : field }
#     upcase_converter = proc {|field| field.respond_to?(:upcase) ? field.upcase : field }
#     write_converters = [strip_converter, upcase_converter]
#     output_string = CSV.generate(write_converters: write_converters) do |csv|
#       csv << [' foo ', 0]
#       csv << [' bar ', 1]
#       csv << [' baz ', 2]
#     end
#     output_string # => "FOO,0\nBAR,1\nBAZ,2\n"
#
# ### Character Encodings (M17n or Multilingualization)
#
# This new CSV parser is m17n savvy.  The parser works in the Encoding of the IO
# or String object being read from or written to. Your data is never transcoded
# (unless you ask Ruby to transcode it for you) and will literally be parsed in
# the Encoding it is in. Thus CSV will return Arrays or Rows of Strings in the
# Encoding of your data. This is accomplished by transcoding the parser itself
# into your Encoding.
#
# Some transcoding must take place, of course, to accomplish this multiencoding
# support. For example, `:col_sep`, `:row_sep`, and `:quote_char` must be
# transcoded to match your data.  Hopefully this makes the entire process feel
# transparent, since CSV's defaults should just magically work for your data.
# However, you can set these values manually in the target Encoding to avoid the
# translation.
#
# It's also important to note that while all of CSV's core parser is now
# Encoding agnostic, some features are not. For example, the built-in converters
# will try to transcode data to UTF-8 before making conversions. Again, you can
# provide custom converters that are aware of your Encodings to avoid this
# translation. It's just too hard for me to support native conversions in all of
# Ruby's Encodings.
#
# Anyway, the practical side of this is simple: make sure IO and String objects
# passed into CSV have the proper Encoding set and everything should just work.
# CSV methods that allow you to open IO objects (CSV::foreach(), CSV::open(),
# CSV::read(), and CSV::readlines()) do allow you to specify the Encoding.
#
# One minor exception comes when generating CSV into a String with an Encoding
# that is not ASCII compatible. There's no existing data for CSV to use to
# prepare itself and thus you will probably need to manually specify the desired
# Encoding for most of those cases. It will try to guess using the fields in a
# row of output though, when using CSV::generate_line() or Array#to_csv().
#
# I try to point out any other Encoding issues in the documentation of methods
# as they come up.
#
# This has been tested to the best of my ability with all non-"dummy" Encodings
# Ruby ships with. However, it is brave new code and may have some bugs. Please
# feel free to [report](mailto:james@grayproductions.net) any issues you find
# with it.
#
class CSV < Object
  include Enumerable[untyped]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - foreach(path_or_io, mode='r', **options) {|row| ... )
  #   - foreach(path_or_io, mode='r', **options) -> new_enumerator
  # -->
  # Calls the block with each row read from source `path_or_io`.
  #
  # Path input without headers:
  #
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     in_path = 't.csv'
  #     File.write(in_path, string)
  #     CSV.foreach(in_path) {|row| p row }
  #
  # Output:
  #
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # Path input with headers:
  #
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     in_path = 't.csv'
  #     File.write(in_path, string)
  #     CSV.foreach(in_path, headers: true) {|row| p row }
  #
  # Output:
  #
  #     <CSV::Row "Name":"foo" "Value":"0">
  #     <CSV::Row "Name":"bar" "Value":"1">
  #     <CSV::Row "Name":"baz" "Value":"2">
  #
  # IO stream input without headers:
  #
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     File.open('t.csv') do |in_io|
  #       CSV.foreach(in_io) {|row| p row }
  #     end
  #
  # Output:
  #
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # IO stream input with headers:
  #
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     File.open('t.csv') do |in_io|
  #       CSV.foreach(in_io, headers: true) {|row| p row }
  #     end
  #
  # Output:
  #
  #     <CSV::Row "Name":"foo" "Value":"0">
  #     <CSV::Row "Name":"bar" "Value":"1">
  #     <CSV::Row "Name":"baz" "Value":"2">
  #
  # With no block given, returns an Enumerator:
  #
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     CSV.foreach(path) # => #<Enumerator: CSV:foreach("t.csv", "r")>
  #
  # Arguments:
  # *   Argument `path_or_io` must be a file path or an IO stream.
  # *   Argument `mode`, if given, must be a File mode. See [Access
  #     Modes](rdoc-ref:File@Access+Modes).
  # *   Arguments `**options` must be keyword options. See [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing).
  # *   This method optionally accepts an additional `:encoding` option that you
  #     can use to specify the Encoding of the data read from `path` or `io`. You
  #     must provide this unless your data is in the encoding given by
  #     `Encoding::default_external`. Parsing will use this to determine how to
  #     parse the data. You may provide a second Encoding to have the data
  #     transcoded as it is read. For example,
  #         encoding: 'UTF-32BE:UTF-8'
  #
  #     would read `UTF-32BE` data from the file but transcode it to `UTF-8`
  #     before parsing.
  #
  def self.foreach: (String | IO path, ?String mode, headers: true | :first_row | Array[untyped] | String, **untyped options) { (::CSV::Row arg0) -> void } -> void
                  | (String | IO path, ?String mode, headers: true | :first_row | Array[untyped] | String, **untyped options) -> Enumerator[::CSV::Row, void]
                  | (String | IO path, ?String mode, **untyped options) { (::Array[String?] arg0) -> void } -> void
                  | (String | IO path, ?String mode, **untyped options) -> Enumerator[::Array[String?], void]

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - CSV.new(string)
  #   - CSV.new(io)
  #   - CSV.new(string, **options)
  #   - CSV.new(io, **options)
  # -->
  # Returns the new CSV object created using `string` or `io` and the specified
  # `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  # *   Argument `options`: See:
  #     *   [Options for Parsing](#class-CSV-label-Options+for+Parsing)
  #     *   [Options for Generating](#class-CSV-label-Options+for+Generating)
  #     For performance reasons, the options cannot be overridden in a CSV object,
  #     so those specified here will endure.
  #
  # In addition to the CSV instance methods, several IO methods are delegated. See
  # [Delegated Methods](#class-CSV-label-Delegated+Methods).
  #
  # ---
  #
  # Create a CSV object from a String object:
  #     csv = CSV.new('foo,0')
  #     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
  #
  # Create a CSV object from a File object:
  #     File.write('t.csv', 'foo,0')
  #     csv = CSV.new(File.open('t.csv'))
  #     csv # => #<CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
  #
  # ---
  #
  # Raises an exception if the argument is `nil`:
  #     # Raises ArgumentError (Cannot parse nil as CSV):
  #     CSV.new(nil)
  #
  def initialize: (?String | IO | StringIO io, ?::Hash[Symbol, untyped] options) -> void

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - parse(string) -> array_of_arrays
  #   - parse(io) -> array_of_arrays
  #   - parse(string, headers: ..., **options) -> csv_table
  #   - parse(io, headers: ..., **options) -> csv_table
  #   - parse(string, **options) {|row| ... }
  #   - parse(io, **options) {|row| ... }
  # -->
  # Parses `string` or `io` using the specified `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  # *   Argument `options`: see [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing)
  #
  # ###### Without Option `headers`
  #
  # Without {option `headers`[}](#class-CSV-label-Option+headers) case.
  #
  # These examples assume prior execution of:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # ---
  #
  # With no block given, returns an Array of Arrays formed from the source.
  #
  # Parse a String:
  #     a_of_a = CSV.parse(string)
  #     a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # Parse an open File:
  #     a_of_a = File.open(path) do |file|
  #       CSV.parse(file)
  #     end
  #     a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # ---
  #
  # With a block given, calls the block with each parsed row:
  #
  # Parse a String:
  #     CSV.parse(string) {|row| p row }
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # Parse an open File:
  #     File.open(path) do |file|
  #       CSV.parse(file) {|row| p row }
  #     end
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # ###### With Option `headers`
  #
  # With {option `headers`[}](#class-CSV-label-Option+headers) case.
  #
  # These examples assume prior execution of:
  #     string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # ---
  #
  # With no block given, returns a CSV::Table object formed from the source.
  #
  # Parse a String:
  #     csv_table = CSV.parse(string, headers: ['Name', 'Count'])
  #     csv_table # => #<CSV::Table mode:col_or_row row_count:5>
  #
  # Parse an open File:
  #     csv_table = File.open(path) do |file|
  #       CSV.parse(file, headers: ['Name', 'Count'])
  #     end
  #     csv_table # => #<CSV::Table mode:col_or_row row_count:4>
  #
  # ---
  #
  # With a block given, calls the block with each parsed row, which has been
  # formed into a CSV::Row object:
  #
  # Parse a String:
  #     CSV.parse(string, headers: ['Name', 'Count']) {|row| p row }
  #
  # Output:
  #     # <CSV::Row "Name":"foo" "Count":"0">
  #     # <CSV::Row "Name":"bar" "Count":"1">
  #     # <CSV::Row "Name":"baz" "Count":"2">
  #
  # Parse an open File:
  #     File.open(path) do |file|
  #       CSV.parse(file, headers: ['Name', 'Count']) {|row| p row }
  #     end
  #
  # Output:
  #     # <CSV::Row "Name":"foo" "Count":"0">
  #     # <CSV::Row "Name":"bar" "Count":"1">
  #     # <CSV::Row "Name":"baz" "Count":"2">
  #
  # ---
  #
  # Raises an exception if the argument is not a String object or IO object:
  #     # Raises NoMethodError (undefined method `close' for :foo:Symbol)
  #     CSV.parse(:foo)
  #
  def self.parse: (String str, ?::Hash[Symbol, untyped] options) ?{ (::Array[String?] arg0) -> void } -> ::Array[::Array[String?]]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - CSV.parse_line(string) -> new_array or nil
  #   - CSV.parse_line(io) -> new_array or nil
  #   - CSV.parse_line(string, **options) -> new_array or nil
  #   - CSV.parse_line(io, **options) -> new_array or nil
  #   - CSV.parse_line(string, headers: true, **options) -> csv_row or nil
  #   - CSV.parse_line(io, headers: true, **options) -> csv_row or nil
  # -->
  # Returns the data created by parsing the first line of `string` or `io` using
  # the specified `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  # *   Argument `options`: see [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing)
  #
  # ###### Without Option `headers`
  #
  # Without option `headers`, returns the first row as a new Array.
  #
  # These examples assume prior execution of:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Parse the first line from a String object:
  #     CSV.parse_line(string) # => ["foo", "0"]
  #
  # Parse the first line from a File object:
  #     File.open(path) do |file|
  #       CSV.parse_line(file) # => ["foo", "0"]
  #     end # => ["foo", "0"]
  #
  # Returns `nil` if the argument is an empty String:
  #     CSV.parse_line('') # => nil
  #
  # ###### With Option `headers`
  #
  # With {option `headers`[}](#class-CSV-label-Option+headers), returns the first
  # row as a CSV::Row object.
  #
  # These examples assume prior execution of:
  #     string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Parse the first line from a String object:
  #     CSV.parse_line(string, headers: true) # => #<CSV::Row "Name":"foo" "Count":"0">
  #
  # Parse the first line from a File object:
  #     File.open(path) do |file|
  #       CSV.parse_line(file, headers: true)
  #     end # => #<CSV::Row "Name":"foo" "Count":"0">
  #
  # ---
  #
  # Raises an exception if the argument is `nil`:
  #     # Raises ArgumentError (Cannot parse nil as CSV):
  #     CSV.parse_line(nil)
  #
  def self.parse_line: (String str, ?::Hash[Symbol, untyped] options) -> ::Array[String?]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv.read -> array or csv_table
  # -->
  # Forms the remaining rows from `self` into:
  # *   A CSV::Table object, if headers are in use.
  # *   An Array of Arrays, otherwise.
  #
  # The data source must be opened for reading.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     csv = CSV.open(path)
  #     csv.read # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     csv = CSV.open(path, headers: true)
  #     csv.read # => #<CSV::Table mode:col_or_row row_count:4>
  #
  # ---
  #
  # Raises an exception if the source is not opened for reading:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.close
  #     # Raises IOError (not opened for reading)
  #     csv.read
  #
  def read: () -> ::Array[::Array[String?]]

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - readline()
  # -->
  #
  def readline: () -> ::Array[String?]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - read(source, **options) -> array_of_arrays
  #   - read(source, headers: true, **options) -> csv_table
  # -->
  # Opens the given `source` with the given `options` (see CSV.open), reads the
  # source (see CSV#read), and returns the result, which will be either an Array
  # of Arrays or a CSV::Table.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     CSV.read(path, headers: true) # => #<CSV::Table mode:col_or_row row_count:4>
  #
  def self.read: (String | IO path, headers: true | :first_row | Array[untyped] | String, **untyped options) -> ::CSV::Table[CSV::Row]
               | (String | IO path, ?::Hash[Symbol, untyped] options) -> ::Array[::Array[String?]]

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv << row -> self
  # -->
  # Appends a row to `self`.
  #
  # *   Argument `row` must be an Array object or a CSV::Row object.
  # *   The output stream must be open for writing.
  #
  # ---
  #
  # Append Arrays:
  #     CSV.generate do |csv|
  #       csv << ['foo', 0]
  #       csv << ['bar', 1]
  #       csv << ['baz', 2]
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # Append CSV::Rows:
  #     headers = []
  #     CSV.generate do |csv|
  #       csv << CSV::Row.new(headers, ['foo', 0])
  #       csv << CSV::Row.new(headers, ['bar', 1])
  #       csv << CSV::Row.new(headers, ['baz', 2])
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # Headers in CSV::Row objects are not appended:
  #     headers = ['Name', 'Count']
  #     CSV.generate do |csv|
  #       csv << CSV::Row.new(headers, ['foo', 0])
  #       csv << CSV::Row.new(headers, ['bar', 1])
  #       csv << CSV::Row.new(headers, ['baz', 2])
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # ---
  #
  # Raises an exception if `row` is not an Array or CSV::Row:
  #     CSV.generate do |csv|
  #       # Raises NoMethodError (undefined method `collect' for :foo:Symbol)
  #       csv << :foo
  #     end
  #
  # Raises an exception if the output stream is not opened for writing:
  #     path = 't.csv'
  #     File.write(path, '')
  #     File.open(path) do |file|
  #       CSV.open(file) do |csv|
  #         # Raises IOError (not opened for writing)
  #         csv << ['foo', 0]
  #       end
  #     end
  #
  def <<: (::Array[untyped] | CSV::Row row) -> void

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - generate(csv_string, **options) {|csv| ... }
  #   - generate(**options) {|csv| ... }
  # -->
  # *   Argument `csv_string`, if given, must be a String object; defaults to a
  #     new empty String.
  # *   Arguments `options`, if given, should be generating options. See [Options
  #     for Generating](#class-CSV-label-Options+for+Generating).
  #
  # ---
  #
  # Creates a new CSV object via `CSV.new(csv_string, **options)`; calls the block
  # with the CSV object, which the block may modify; returns the String generated
  # from the CSV object.
  #
  # Note that a passed String **is** modified by this method. Pass
  # `csv_string`.dup if the String must be preserved.
  #
  # This method has one additional option: `:encoding`, which sets the base
  # Encoding for the output if no no `str` is specified. CSV needs this hint if
  # you plan to output non-ASCII compatible data.
  #
  # ---
  #
  # Add lines:
  #     input_string = "foo,0\nbar,1\nbaz,2\n"
  #     output_string = CSV.generate(input_string) do |csv|
  #       csv << ['bat', 3]
  #       csv << ['bam', 4]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     input_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     output_string.equal?(input_string) # => true # Same string, modified
  #
  # Add lines into new string, preserving old string:
  #     input_string = "foo,0\nbar,1\nbaz,2\n"
  #     output_string = CSV.generate(input_string.dup) do |csv|
  #       csv << ['bat', 3]
  #       csv << ['bam', 4]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     input_string # => "foo,0\nbar,1\nbaz,2\n"
  #     output_string.equal?(input_string) # => false # Different strings
  #
  # Create lines from nothing:
  #     output_string = CSV.generate do |csv|
  #       csv << ['foo', 0]
  #       csv << ['bar', 1]
  #       csv << ['baz', 2]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\n"
  #
  # ---
  #
  # Raises an exception if `csv_string` is not a String object:
  #     # Raises TypeError (no implicit conversion of Integer into String)
  #     CSV.generate(0)
  #
  def self.generate: (?String str, **untyped options) { (CSV csv) -> void } -> String

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv.each -> enumerator
  #   - csv.each {|row| ...}
  # -->
  # Calls the block with each successive row. The data source must be opened for
  # reading.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.each do |row|
  #       p row
  #     end
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string, headers: true)
  #     csv.each do |row|
  #       p row
  #     end
  #
  # Output:
  #     <CSV::Row "Name":"foo" "Value":"0">
  #     <CSV::Row "Name":"bar" "Value":"1">
  #     <CSV::Row "Name":"baz" "Value":"2">
  #
  # ---
  #
  # Raises an exception if the source is not opened for reading:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.close
  #     # Raises IOError (not opened for reading)
  #     csv.each do |row|
  #       p row
  #     end
  #
  def each: () -> Enumerator[untyped, Integer]
          | () { (untyped) -> void } -> Integer

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv.headers -> object
  # -->
  # Returns the value that determines whether headers are used; used for parsing;
  # see {Option `headers`[}](#class-CSV-label-Option+headers):
  #     CSV.new('').headers # => nil
  #
  def headers: () -> (Array[String] | true | nil)
end

# <!-- rdoc-file=lib/csv.rb -->
# Default values for method options.
#
CSV::DEFAULT_OPTIONS: ::Hash[untyped, untyped]

# <!-- rdoc-file=lib/csv/version.rb -->
# The version of the installed library.
#
CSV::VERSION: String

# <!-- rdoc-file=lib/csv/row.rb -->
# # CSV::Row
# A CSV::Row instance represents a CSV table row. (see [class
# CSV](../CSV.html)).
#
# The instance may have:
# *   Fields: each is an object, not necessarily a String.
# *   Headers: each serves a key, and also need not be a String.
#
# ### Instance Methods
#
# CSV::Row has three groups of instance methods:
# *   Its own internally defined instance methods.
# *   Methods included by module Enumerable.
# *   Methods delegated to class Array.:
#     *   Array#empty?
#     *   Array#length
#     *   Array#size
#
# ## Creating a CSV::Row Instance
#
# Commonly, a new CSV::Row instance is created by parsing CSV source that has
# headers:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.each {|row| p row }
#
# Output:
#     #<CSV::Row "Name":"foo" "Value":"0">
#     #<CSV::Row "Name":"bar" "Value":"1">
#     #<CSV::Row "Name":"baz" "Value":"2">
#
# You can also create a row directly. See ::new.
#
# ## Headers
#
# Like a CSV::Table, a CSV::Row has headers.
#
# A CSV::Row that was created by parsing CSV source inherits its headers from
# the table:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     row = table.first
#     row.headers # => ["Name", "Value"]
#
# You can also create a new row with headers; like the keys in a Hash, the
# headers need not be Strings:
#     row = CSV::Row.new([:name, :value], ['foo', 0])
#     row.headers # => [:name, :value]
#
# The new row retains its headers even if added to a table that has headers:
#     table << row # => #<CSV::Table mode:col_or_row row_count:5>
#     row.headers # => [:name, :value]
#     row[:name] # => "foo"
#     row['Name'] # => nil
#
# ## Accessing Fields
#
# You may access a field in a CSV::Row with either its Integer index
# (Array-style) or its header (Hash-style).
#
# Fetch a field using method #[]:
#     row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
#     row[1] # => 0
#     row['Value'] # => 0
#
# Set a field using method #[]=:
#     row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
#     row # => #<CSV::Row "Name":"foo" "Value":0>
#     row[0] = 'bar'
#     row['Value'] = 1
#     row # => #<CSV::Row "Name":"bar" "Value":1>
#
class CSV::Row < Object
  include Enumerable[Array[String]]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - CSV::Row.new(headers, fields, header_row = false) -> csv_row
  # -->
  # Returns the new CSV::Row instance constructed from arguments `headers` and
  # `fields`; both should be Arrays; note that the fields need not be Strings:
  #     row = CSV::Row.new(['Name', 'Value'], ['foo', 0])
  #     row # => #<CSV::Row "Name":"foo" "Value":0>
  #
  # If the Array lengths are different, the shorter is `nil`-filled:
  #     row = CSV::Row.new(['Name', 'Value', 'Date', 'Size'], ['foo', 0])
  #     row # => #<CSV::Row "Name":"foo" "Value":0 "Date":nil "Size":nil>
  #
  # Each CSV::Row object is either a *field row* or a *header row*; by default, a
  # new row is a field row;  for the row created above:
  #     row.field_row? # => true
  #     row.header_row? # => false
  #
  # If the optional argument `header_row` is given as `true`, the created row is a
  # header row:
  #     row = CSV::Row.new(['Name', 'Value'], ['foo', 0], header_row = true)
  #     row # => #<CSV::Row "Name":"foo" "Value":0>
  #     row.field_row? # => false
  #     row.header_row? # => true
  #
  def initialize: (Array[untyped] headers, Array[untyped] fields, ?header_row: bool) -> void

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row << [header, value] -> self
  #   - row << hash -> self
  #   - row << value -> self
  # -->
  # Adds a field to `self`; returns `self`:
  #
  # If the argument is a 2-element Array `[header, value]`, a field is added with
  # the given `header` and `value`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << ['NAME', 'Bat']
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" "NAME":"Bat">
  #
  # If the argument is a Hash, each `key-value` pair is added as a field with
  # header `key` and value `value`.
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << {NAME: 'Bat', name: 'Bam'}
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" NAME:"Bat" name:"Bam">
  #
  # Otherwise, the given `value` is added as a field with no header.
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << 'Bag'
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bag">
  #
  def <<: (untyped arg) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row == other -> true or false
  # -->
  # Returns `true` if `other` is a /CSV::Row that has the same fields (headers and
  # values) in the same order as `self`; otherwise returns `false`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     other_row = table[0]
  #     row == other_row # => true
  #     other_row = table[1]
  #     row == other_row # => false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - [](header_or_index, minimum_index = 0)
  # -->
  #
  alias [] field

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row[index] = value -> value
  #   - row[header, offset] = value -> value
  #   - row[header] = value -> value
  # -->
  # Assigns the field value for the given `index` or `header`; returns `value`.
  #
  # ---
  #
  # Assign field value by Integer index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row[0] = 'Bat'
  #     row[1] = 3
  #     row # => #<CSV::Row "Name":"Bat" "Value":3>
  #
  # Counts backward from the last column if `index` is negative:
  #     row[-1] = 4
  #     row[-2] = 'Bam'
  #     row # => #<CSV::Row "Name":"Bam" "Value":4>
  #
  # Extends the row with `nil:nil` if positive `index` is not in the row:
  #     row[4] = 5
  #     row # => #<CSV::Row "Name":"bad" "Value":4 nil:nil nil:nil nil:5>
  #
  # Raises IndexError if negative `index` is too small (too far from zero).
  #
  # ---
  #
  # Assign field value by header (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['Name'] = 'Bat'
  #     row # => #<CSV::Row "Name":"Bat" "Name":"Bar" "Name":"Baz">
  #
  # Assign field value by header, ignoring `offset` leading fields:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['Name', 2] = 4
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":4>
  #
  # Append new field by (new) header:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['New'] = 6
  #     row# => #<CSV::Row "Name":"foo" "Value":"0" "New":6>
  #
  def []=: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - delete(index) -> [header, value] or nil
  #   - delete(header) -> [header, value] or empty_array
  #   - delete(header, offset) -> [header, value] or empty_array
  # -->
  # Removes a specified field from `self`; returns the 2-element Array `[header,
  # value]` if the field exists.
  #
  # If an Integer argument `index` is given, removes and returns the field at
  # offset `index`, or returns `nil` if the field does not exist:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete(1) # => ["Name", "Bar"]
  #     row.delete(50) # => nil
  #
  # Otherwise, if the single argument `header` is given, removes and returns the
  # first-found field with the given header, of returns a new empty Array if the
  # field does not exist:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete('Name') # => ["Name", "Foo"]
  #     row.delete('NAME') # => []
  #
  # If argument `header` and Integer argument `offset` are given, removes and
  # returns the first-found field with the given header whose `index` is at least
  # as large as `offset`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete('Name', 1) # => ["Name", "Bar"]
  #     row.delete('NAME', 1) # => []
  #
  def delete: (untyped header_or_index, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.delete_if {|header, value| ... } -> self
  # -->
  # Removes fields from `self` as selected by the block; returns `self`.
  #
  # Removes each field for which the block returns a truthy value:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete_if {|header, value| value.start_with?('B') } # => true
  #     row # => #<CSV::Row "Name":"Foo">
  #     row.delete_if {|header, value| header.start_with?('B') } # => false
  #
  # If no block is given, returns a new Enumerator:
  #     row.delete_if # => #<Enumerator: #<CSV::Row "Name":"Foo">:delete_if>
  #
  def delete_if: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.dig(index_or_header, *identifiers) -> object
  # -->
  # Finds and returns the object in nested object that is specified by
  # `index_or_header` and `specifiers`.
  #
  # The nested objects may be instances of various classes. See [Dig
  # Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Examples:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.dig(1) # => "0"
  #     row.dig('Value') # => "0"
  #     row.dig(5) # => nil
  #
  def dig: (untyped index_or_header, *untyped indexes) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.each {|header, value| ... } -> self
  # -->
  # Calls the block with each header-value pair; returns `self`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.each {|header, value| p [header, value] }
  #
  # Output:
  #     ["Name", "Foo"]
  #     ["Name", "Bar"]
  #     ["Name", "Baz"]
  #
  # If no block is given, returns a new Enumerator:
  #     row.each # => #<Enumerator: #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz">:each>
  #
  def each: () -> Enumerator[Array[String], self]
          | () { (Array[String]) -> void } -> self

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - each_pair(&block)
  # -->
  #
  alias each_pair each

  def empty?: (*untyped args) { (*untyped) -> untyped } -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - fetch(header) -> value
  #   - fetch(header, default) -> value
  #   - fetch(header) {|row| ... } -> value
  # -->
  # Returns the field value as specified by `header`.
  #
  # ---
  #
  # With the single argument `header`, returns the field value for that header
  # (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name') # => "Foo"
  #
  # Raises exception `KeyError` if the header does not exist.
  #
  # ---
  #
  # With arguments `header` and `default` given, returns the field value for the
  # header (first found) if the header exists, otherwise returns `default`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name', '') # => "Foo"
  #     row.fetch(:nosuch, '') # => ""
  #
  # ---
  #
  # With argument `header` and a block given, returns the field value for the
  # header (first found) if the header exists; otherwise calls the block and
  # returns its return value:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name') {|header| fail 'Cannot happen' } # => "Foo"
  #     row.fetch(:nosuch) {|header| "Header '#{header} not found'" } # => "Header 'nosuch not found'"
  #
  def fetch: (untyped header, *untyped varargs) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - field(index) -> value
  #   - field(header) -> value
  #   - field(header, offset) -> value
  # -->
  # Returns the field value for the given `index` or `header`.
  #
  # ---
  #
  # Fetch field value by Integer index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field(0) # => "foo"
  #     row.field(1) # => "bar"
  #
  # Counts backward from the last column if `index` is negative:
  #     row.field(-1) # => "0"
  #     row.field(-2) # => "foo"
  #
  # Returns `nil` if `index` is out of range:
  #     row.field(2) # => nil
  #     row.field(-3) # => nil
  #
  # ---
  #
  # Fetch field value by header (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field('Name') # => "Foo"
  #
  # Fetch field value by header, ignoring `offset` leading fields:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field('Name', 2) # => "Baz"
  #
  # Returns `nil` if the header does not exist.
  #
  def field: (untyped header_or_index, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.field?(value) -> true or false
  # -->
  # Returns `true` if `value` is a field in this row, `false` otherwise:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field?('Bar') # => true
  #     row.field?('BAR') # => false
  #
  def field?: (untyped data) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.field_row? -> true or false
  # -->
  # Returns `true` if this is a field row, `false` otherwise.
  #
  def field_row?: () -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - self.fields(*specifiers) -> array_of_fields
  # -->
  # Returns field values per the given `specifiers`, which may be any mixture of:
  # *   Integer index.
  # *   Range of Integer indexes.
  # *   2-element Array containing a header and offset.
  # *   Header.
  # *   Range of headers.
  #
  # For `specifier` in one of the first four cases above, returns the result of
  # `self.field(specifier)`;  see #field.
  #
  # Although there may be any number of `specifiers`, the examples here will
  # illustrate one at a time.
  #
  # When the specifier is an Integer `index`, returns `self.field(index)`L
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fields(1) # => ["Bar"]
  #
  # When the specifier is a Range of Integers `range`, returns
  # `self.field(range)`:
  #     row.fields(1..2) # => ["Bar", "Baz"]
  #
  # When the specifier is a 2-element Array `array`, returns `self.field(array)`L
  #     row.fields('Name', 1) # => ["Foo", "Bar"]
  #
  # When the specifier is a header `header`, returns `self.field(header)`L
  #     row.fields('Name') # => ["Foo"]
  #
  # When the specifier is a Range of headers `range`, forms a new Range
  # `new_range` from the indexes of `range.start` and `range.end`, and returns
  # `self.field(new_range)`:
  #     source = "Name,NAME,name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fields('Name'..'NAME') # => ["Foo", "Bar"]
  #
  # Returns all fields if no argument given:
  #     row.fields # => ["Foo", "Bar", "Baz"]
  #
  def fields: (*untyped headers_and_or_indices) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.has_key?(header) -> true or false
  # -->
  # Returns `true` if there is a field with the given `header`, `false` otherwise.
  #
  def has_key?: (untyped header) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - header?(header)
  # -->
  #
  alias header? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.header_row? -> true or false
  # -->
  # Returns `true` if this is a header row, `false` otherwise.
  #
  def header_row?: () -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.headers -> array_of_headers
  # -->
  # Returns the headers for this row:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table.first
  #     row.headers # => ["Name", "Value"]
  #
  def headers: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - include?(header)
  # -->
  #
  alias include? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - index(header) -> index
  #   - index(header, offset) -> index
  # -->
  # Returns the index for the given header, if it exists; otherwise returns `nil`.
  #
  # With the single argument `header`, returns the index of the first-found field
  # with the given `header`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.index('Name') # => 0
  #     row.index('NAME') # => nil
  #
  # With arguments `header` and `offset`, returns the index of the first-found
  # field with given `header`, but ignoring the first `offset` fields:
  #     row.index('Name', 1) # => 1
  #     row.index('Name', 3) # => nil
  #
  def index: (untyped header, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.inspect -> string
  # -->
  # Returns an ASCII-compatible String showing:
  # *   Class CSV::Row.
  # *   Header-value pairs.
  # Example:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.inspect # => "#<CSV::Row \"Name\":\"foo\" \"Value\":\"0\">"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - key?(header)
  # -->
  #
  alias key? has_key?

  def length: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - member?(header)
  # -->
  #
  alias member? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.push(*values) -> self
  # -->
  # Appends each of the given `values` to `self` as a field; returns `self`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.push('Bat', 'Bam')
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bat" nil:"Bam">
  #
  def push: (*untyped args) -> untyped

  def size: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.to_csv -> csv_string
  # -->
  # Returns the row as a CSV String. Headers are not included:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_csv # => "foo,0\n"
  #
  def to_csv: (**untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.to_h -> hash
  # -->
  # Returns the new Hash formed by adding each header-value pair in `self` as a
  # key-value pair in the Hash.
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_h # => {"Name"=>"foo", "Value"=>"0"}
  #
  # Header order is preserved, but repeated headers are ignored:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_h # => {"Name"=>"Foo"}
  #
  def to_h: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - to_hash()
  # -->
  #
  alias to_hash to_h

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - to_s(**options)
  # -->
  #
  alias to_s to_csv

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - values_at(*headers_and_or_indices)
  # -->
  #
  alias values_at fields
end

class CSV::FieldInfo < Struct[untyped]
end

# <!-- rdoc-file=lib/csv.rb -->
# The error thrown when the parser encounters illegal CSV formatting.
#
class CSV::MalformedCSVError < RuntimeError
end

# <!-- rdoc-file=lib/csv/table.rb -->
# # CSV::Table
# A CSV::Table instance represents CSV data. (see [class CSV](../CSV.html)).
#
# The instance may have:
# *   Rows: each is a Table::Row object.
# *   Headers: names for the columns.
#
# ### Instance Methods
#
# CSV::Table has three groups of instance methods:
# *   Its own internally defined instance methods.
# *   Methods included by module Enumerable.
# *   Methods delegated to class Array.:
#     *   Array#empty?
#     *   Array#length
#     *   Array#size
#
# ## Creating a CSV::Table Instance
#
# Commonly, a new CSV::Table instance is created by parsing CSV source using
# headers:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.class # => CSV::Table
#
# You can also create an instance directly. See ::new.
#
# ## Headers
#
# If a table has headers, the headers serve as labels for the columns of data.
# Each header serves as the label for its column.
#
# The headers for a CSV::Table object are stored as an Array of Strings.
#
# Commonly, headers are defined in the first row of CSV source:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.headers # => ["Name", "Value"]
#
# If no headers are defined, the Array is empty:
#     table = CSV::Table.new([])
#     table.headers # => []
#
# ## Access Modes
#
# CSV::Table provides three modes for accessing table data:
# *   Row mode.
# *   Column mode.
# *   Mixed mode (the default for a new table).
#
# The access mode for aCSV::Table instance affects the behavior of some of its
# instance methods:
# *   #[]
# *   #[]=
# *   #delete
# *   #delete_if
# *   #each
# *   #values_at
#
# ### Row Mode
#
# Set a table to row mode with method #by_row!:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.by_row! # => #<CSV::Table mode:row row_count:4>
#
# Specify a single row by an Integer index:
#     # Get a row.
#     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
#     # Set a row, then get it.
#     table[1] = CSV::Row.new(['Name', 'Value'], ['bam', 3])
#     table[1] # => #<CSV::Row "Name":"bam" "Value":3>
#
# Specify a sequence of rows by a Range:
#     # Get rows.
#     table[1..2] # => [#<CSV::Row "Name":"bam" "Value":3>, #<CSV::Row "Name":"baz" "Value":"2">]
#     # Set rows, then get them.
#     table[1..2] = [
#       CSV::Row.new(['Name', 'Value'], ['bat', 4]),
#       CSV::Row.new(['Name', 'Value'], ['bad', 5]),
#     ]
#     table[1..2] # => [["Name", #<CSV::Row "Name":"bat" "Value":4>], ["Value", #<CSV::Row "Name":"bad" "Value":5>]]
#
# ### Column Mode
#
# Set a table to column mode with method #by_col!:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.by_col! # => #<CSV::Table mode:col row_count:4>
#
# Specify a column by an Integer index:
#     # Get a column.
#     table[0]
#     # Set a column, then get it.
#     table[0] = ['FOO', 'BAR', 'BAZ']
#     table[0] # => ["FOO", "BAR", "BAZ"]
#
# Specify a column by its String header:
#     # Get a column.
#     table['Name'] # => ["FOO", "BAR", "BAZ"]
#     # Set a column, then get it.
#     table['Name'] = ['Foo', 'Bar', 'Baz']
#     table['Name'] # => ["Foo", "Bar", "Baz"]
#
# ### Mixed Mode
#
# In mixed mode, you can refer to either rows or columns:
# *   An Integer index refers to a row.
# *   A Range index refers to multiple rows.
# *   A String index refers to a column.
#
# Set a table to mixed mode with method #by_col_or_row!:
#     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(source, headers: true)
#     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
#
# Specify a single row by an Integer index:
#     # Get a row.
#     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
#     # Set a row, then get it.
#     table[1] = CSV::Row.new(['Name', 'Value'], ['bam', 3])
#     table[1] # => #<CSV::Row "Name":"bam" "Value":3>
#
# Specify a sequence of rows by a Range:
#     # Get rows.
#     table[1..2] # => [#<CSV::Row "Name":"bam" "Value":3>, #<CSV::Row "Name":"baz" "Value":"2">]
#     # Set rows, then get them.
#     table[1] = CSV::Row.new(['Name', 'Value'], ['bat', 4])
#     table[2] = CSV::Row.new(['Name', 'Value'], ['bad', 5])
#     table[1..2] # => [["Name", #<CSV::Row "Name":"bat" "Value":4>], ["Value", #<CSV::Row "Name":"bad" "Value":5>]]
#
# Specify a column by its String header:
#     # Get a column.
#     table['Name'] # => ["foo", "bat", "bad"]
#     # Set a column, then get it.
#     table['Name'] = ['Foo', 'Bar', 'Baz']
#     table['Name'] # => ["Foo", "Bar", "Baz"]
#
class CSV::Table[out Elem] < Object
  include Enumerable[Elem]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - CSV::Table.new(array_of_rows, headers = nil) -> csv_table
  # -->
  # Returns a new CSV::Table object.
  #
  # *   Argument `array_of_rows` must be an Array of CSV::Row objects.
  # *   Argument `headers`, if given, may be an Array of Strings.
  #
  # ---
  #
  # Create an empty CSV::Table object:
  #     table = CSV::Table.new([])
  #     table # => #<CSV::Table mode:col_or_row row_count:1>
  #
  # Create a non-empty CSV::Table object:
  #     rows = [
  #       CSV::Row.new([], []),
  #       CSV::Row.new([], []),
  #       CSV::Row.new([], []),
  #     ]
  #     table  = CSV::Table.new(rows)
  #     table # => #<CSV::Table mode:col_or_row row_count:4>
  #
  # ---
  #
  # If argument `headers` is an Array of Strings, those Strings become the table's
  # headers:
  #     table = CSV::Table.new([], headers: ['Name', 'Age'])
  #     table.headers # => ["Name", "Age"]
  #
  # If argument `headers` is not given and the table has rows, the headers are
  # taken from the first row:
  #     rows = [
  #       CSV::Row.new(['Foo', 'Bar'], []),
  #       CSV::Row.new(['foo', 'bar'], []),
  #       CSV::Row.new(['FOO', 'BAR'], []),
  #     ]
  #     table  = CSV::Table.new(rows)
  #     table.headers # => ["Foo", "Bar"]
  #
  # If argument `headers` is not given and the table is empty (has no rows), the
  # headers are also empty:
  #     table  = CSV::Table.new([])
  #     table.headers # => []
  #
  # ---
  #
  # Raises an exception if argument `array_of_rows` is not an Array object:
  #     # Raises NoMethodError (undefined method `first' for :foo:Symbol):
  #     CSV::Table.new(:foo)
  #
  # Raises an exception if an element of `array_of_rows` is not a CSV::Table
  # object:
  #     # Raises NoMethodError (undefined method `headers' for :foo:Symbol):
  #     CSV::Table.new([:foo])
  #
  def initialize: (untyped array_of_rows, ?headers: untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table << row_or_array -> self
  # -->
  # If `row_or_array` is a CSV::Row object, it is appended to the table:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table << CSV::Row.new(table.headers, ['bat', 3])
  #     table[3] # => #<CSV::Row "Name":"bat" "Value":3>
  #
  # If `row_or_array` is an Array, it is used to create a new CSV::Row object
  # which is then appended to the table:
  #     table << ['bam', 4]
  #     table[4] # => #<CSV::Row "Name":"bam" "Value":4>
  #
  def <<: (untyped row_or_array) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table == other_table -> true or false
  # -->
  # Returns `true` if all each row of `self` `==` the corresponding row of
  # `other_table`, otherwise, `false`.
  #
  # The access mode does no affect the result.
  #
  # Equal tables:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     other_table = CSV.parse(source, headers: true)
  #     table == other_table # => true
  #
  # Different row count:
  #     other_table.delete(2)
  #     table == other_table # => false
  #
  # Different last row:
  #     other_table << ['bat', 3]
  #     table == other_table # => false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table[n] -> row or column_data
  #   - table[range] -> array_of_rows or array_of_column_data
  #   - table[header] -> array_of_column_data
  # -->
  # Returns data from the table;  does not modify the table.
  #
  # ---
  #
  #
  # Fetch a Row by Its Integer Index
  # :
  # *   Form: `table[n]`, `n` an integer.
  # *   Access mode: `:row` or `:col_or_row`.
  # *   Return value: *nth* row of the table, if that row exists; otherwise `nil`.
  #
  # Returns the *nth* row of the table if that row exists:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
  #
  # Counts backward from the last row if `n` is negative:
  #     table[-1] # => #<CSV::Row "Name":"baz" "Value":"2">
  #
  # Returns `nil` if `n` is too large or too small:
  #     table[4] # => nil
  #     table[-4] # => nil
  #
  # Raises an exception if the access mode is `:row` and `n` is not an Integer:
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     # Raises TypeError (no implicit conversion of String into Integer):
  #     table['Name']
  #
  # ---
  #
  #
  # Fetch a Column by Its Integer Index
  # :
  # *   Form: `table[n]`, `n` an Integer.
  # *   Access mode: `:col`.
  # *   Return value: *nth* column of the table, if that column exists; otherwise
  #     an Array of `nil` fields of length `self.size`.
  #
  # Returns the *nth* column of the table if that column exists:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table[1] # => ["0", "1", "2"]
  #
  # Counts backward from the last column if `n` is negative:
  #     table[-2] # => ["foo", "bar", "baz"]
  #
  # Returns an Array of `nil` fields if `n` is too large or too small:
  #     table[4] # => [nil, nil, nil]
  #     table[-4] # => [nil, nil, nil]
  #
  # ---
  #
  #
  # Fetch Rows by Range
  # :
  # *   Form: `table[range]`, `range` a Range object.
  # *   Access mode: `:row` or `:col_or_row`.
  # *   Return value: rows from the table, beginning at row `range.start`, if
  #     those rows exists.
  #
  # Returns rows from the table, beginning at row `range.first`, if those rows
  # exist:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If there are too few rows, returns all from `range.start` to the end:
  #     rows = table[1..50] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # Special case: if `range.start == table.size`, returns an empty Array:
  #     table[table.size..50] # => []
  #
  # If `range.end` is negative, calculates the ending index from the end:
  #     rows = table[0..-1]
  #     rows # => [#<CSV::Row "Name":"foo" "Value":"0">, #<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If `range.start` is negative, calculates the starting index from the end:
  #     rows = table[-1..2]
  #     rows # => [#<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If `range.start` is larger than `table.size`, returns `nil`:
  #     table[4..4] # => nil
  #
  # ---
  #
  #
  # Fetch Columns by Range
  # :
  # *   Form: `table[range]`, `range` a Range object.
  # *   Access mode: `:col`.
  # *   Return value: column data from the table, beginning at column
  #     `range.start`, if those columns exist.
  #
  # Returns column values from the table, if the column exists; the values are
  # arranged by row:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col!
  #     table[0..1] # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # Special case: if `range.start == headers.size`, returns an Array (size:
  # `table.size`) of empty Arrays:
  #     table[table.headers.size..50] # => [[], [], []]
  #
  # If `range.end` is negative, calculates the ending index from the end:
  #     table[0..-1] # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # If `range.start` is negative, calculates the starting index from the end:
  #     table[-2..2] # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # If `range.start` is larger than `table.size`, returns an Array of `nil`
  # values:
  #     table[4..4] # => [nil, nil, nil]
  #
  # ---
  #
  #
  # Fetch a Column by Its String Header
  # :
  # *   Form: `table[header]`, `header` a String header.
  # *   Access mode: `:col` or `:col_or_row`
  # *   Return value: column data from the table, if that `header` exists.
  #
  # Returns column values from the table, if the column exists:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table['Name'] # => ["foo", "bar", "baz"]
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     col = table['Name']
  #     col # => ["foo", "bar", "baz"]
  #
  # Modifying the returned column values does not modify the table:
  #     col[0] = 'bat'
  #     col # => ["bat", "bar", "baz"]
  #     table['Name'] # => ["foo", "bar", "baz"]
  #
  # Returns an Array of `nil` values if there is no such column:
  #     table['Nosuch'] # => [nil, nil, nil]
  #
  def []: (untyped index_or_header) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table[n] = row -> row
  #   - table[n] = field_or_array_of_fields -> field_or_array_of_fields
  #   - table[header] = field_or_array_of_fields -> field_or_array_of_fields
  # -->
  # Puts data onto the table.
  #
  # ---
  #
  #
  # Set a Row by Its Integer Index
  # :
  # *   Form: `table[n] = row`, `n` an Integer, `row` a CSV::Row instance or an
  #     Array of fields.
  # *   Access mode: `:row` or `:col_or_row`.
  # *   Return value: `row`.
  #
  # If the row exists, it is replaced:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     new_row = CSV::Row.new(['Name', 'Value'], ['bat', 3])
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     return_value = table[0] = new_row
  #     return_value.equal?(new_row) # => true # Returned the row
  #     table[0].to_h # => {"Name"=>"bat", "Value"=>3}
  #
  # With access mode `:col_or_row`:
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     table[0] = CSV::Row.new(['Name', 'Value'], ['bam', 4])
  #     table[0].to_h # => {"Name"=>"bam", "Value"=>4}
  #
  # With an Array instead of a CSV::Row, inherits headers from the table:
  #     array = ['bad', 5]
  #     return_value = table[0] = array
  #     return_value.equal?(array) # => true # Returned the array
  #     table[0].to_h # => {"Name"=>"bad", "Value"=>5}
  #
  # If the row does not exist, extends the table by adding rows: assigns rows with
  # `nil` as needed:
  #     table.size # => 3
  #     table[5] = ['bag', 6]
  #     table.size # => 6
  #     table[3] # => nil
  #     table[4]# => nil
  #     table[5].to_h # => {"Name"=>"bag", "Value"=>6}
  #
  # Note that the `nil` rows are actually `nil`, not a row of `nil` fields.
  #
  # ---
  #
  #
  # Set a Column by Its Integer Index
  # :
  # *   Form: `table[n] = array_of_fields`, `n` an Integer, `array_of_fields` an
  #     Array of String fields.
  # *   Access mode: `:col`.
  # *   Return value: `array_of_fields`.
  #
  # If the column exists, it is replaced:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     new_col = [3, 4, 5]
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     return_value = table[1] = new_col
  #     return_value.equal?(new_col) # => true # Returned the column
  #     table[1] # => [3, 4, 5]
  #     # The rows, as revised:
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table[0].to_h # => {"Name"=>"foo", "Value"=>3}
  #     table[1].to_h # => {"Name"=>"bar", "Value"=>4}
  #     table[2].to_h # => {"Name"=>"baz", "Value"=>5}
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #
  # If there are too few values, fills with `nil` values:
  #     table[1] = [0]
  #     table[1] # => [0, nil, nil]
  #
  # If there are too many values, ignores the extra values:
  #     table[1] = [0, 1, 2, 3, 4]
  #     table[1] # => [0, 1, 2]
  #
  # If a single value is given, replaces all fields in the column with that value:
  #     table[1] = 'bat'
  #     table[1] # => ["bat", "bat", "bat"]
  #
  # ---
  #
  #
  # Set a Column by Its String Header
  # :
  # *   Form: `table[header] = field_or_array_of_fields`, `header` a String
  #     header, `field_or_array_of_fields` a field value or an Array of String
  #     fields.
  # *   Access mode: `:col` or `:col_or_row`.
  # *   Return value: `field_or_array_of_fields`.
  #
  # If the column exists, it is replaced:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     new_col = [3, 4, 5]
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     return_value = table['Value'] = new_col
  #     return_value.equal?(new_col) # => true # Returned the column
  #     table['Value'] # => [3, 4, 5]
  #     # The rows, as revised:
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table[0].to_h # => {"Name"=>"foo", "Value"=>3}
  #     table[1].to_h # => {"Name"=>"bar", "Value"=>4}
  #     table[2].to_h # => {"Name"=>"baz", "Value"=>5}
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #
  # If there are too few values, fills with `nil` values:
  #     table['Value'] = [0]
  #     table['Value'] # => [0, nil, nil]
  #
  # If there are too many values, ignores the extra values:
  #     table['Value'] = [0, 1, 2, 3, 4]
  #     table['Value'] # => [0, 1, 2]
  #
  # If the column does not exist, extends the table by adding columns:
  #     table['Note'] = ['x', 'y', 'z']
  #     table['Note'] # => ["x", "y", "z"]
  #     # The rows, as revised:
  #     table.by_row!
  #     table[0].to_h # => {"Name"=>"foo", "Value"=>0, "Note"=>"x"}
  #     table[1].to_h # => {"Name"=>"bar", "Value"=>1, "Note"=>"y"}
  #     table[2].to_h # => {"Name"=>"baz", "Value"=>2, "Note"=>"z"}
  #     table.by_col!
  #
  # If a single value is given, replaces all fields in the column with that value:
  #     table['Value'] = 'bat'
  #     table['Value'] # => ["bat", "bat", "bat"]
  #
  def []=: (untyped index_or_header, untyped value) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_col -> table_dup
  # -->
  # Returns a duplicate of `self`, in column mode (see [Column
  # Mode](#class-CSV::Table-label-Column+Mode)):
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.mode # => :col_or_row
  #     dup_table = table.by_col
  #     dup_table.mode # => :col
  #     dup_table.equal?(table) # => false # It's a dup
  #
  # This may be used to chain method calls without changing the mode (but also
  # will affect performance and memory usage):
  #     dup_table.by_col['Name']
  #
  # Also note that changes to the duplicate table will not affect the original.
  #
  def by_col: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_col! -> self
  # -->
  # Sets the mode for `self` to column mode (see [Column
  # Mode](#class-CSV::Table-label-Column+Mode)); returns `self`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.mode # => :col_or_row
  #     table1 = table.by_col!
  #     table.mode # => :col
  #     table1.equal?(table) # => true # Returned self
  #
  def by_col!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_col_or_row -> table_dup
  # -->
  # Returns a duplicate of `self`, in mixed mode (see [Mixed
  # Mode](#class-CSV::Table-label-Mixed+Mode)):
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true).by_col!
  #     table.mode # => :col
  #     dup_table = table.by_col_or_row
  #     dup_table.mode # => :col_or_row
  #     dup_table.equal?(table) # => false # It's a dup
  #
  # This may be used to chain method calls without changing the mode (but also
  # will affect performance and memory usage):
  #     dup_table.by_col_or_row['Name']
  #
  # Also note that changes to the duplicate table will not affect the original.
  #
  def by_col_or_row: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_col_or_row! -> self
  # -->
  # Sets the mode for `self` to mixed mode (see [Mixed
  # Mode](#class-CSV::Table-label-Mixed+Mode)); returns `self`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true).by_col!
  #     table.mode # => :col
  #     table1 = table.by_col_or_row!
  #     table.mode # => :col_or_row
  #     table1.equal?(table) # => true # Returned self
  #
  def by_col_or_row!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_row -> table_dup
  # -->
  # Returns a duplicate of `self`, in row mode (see [Row
  # Mode](#class-CSV::Table-label-Row+Mode)):
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.mode # => :col_or_row
  #     dup_table = table.by_row
  #     dup_table.mode # => :row
  #     dup_table.equal?(table) # => false # It's a dup
  #
  # This may be used to chain method calls without changing the mode (but also
  # will affect performance and memory usage):
  #     dup_table.by_row[1]
  #
  # Also note that changes to the duplicate table will not affect the original.
  #
  def by_row: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.by_row! -> self
  # -->
  # Sets the mode for `self` to row mode (see [Row
  # Mode](#class-CSV::Table-label-Row+Mode)); returns `self`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.mode # => :col_or_row
  #     table1 = table.by_row!
  #     table.mode # => :row
  #     table1.equal?(table) # => true # Returned self
  #
  def by_row!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.delete(*indexes) -> deleted_values
  #   - table.delete(*headers) -> deleted_values
  # -->
  # If the access mode is `:row` or `:col_or_row`, and each argument is either an
  # Integer or a Range, returns deleted rows. Otherwise, returns deleted columns
  # data.
  #
  # In either case, the returned values are in the order specified by the
  # arguments.  Arguments may be repeated.
  #
  # ---
  #
  # Returns rows as an Array of CSV::Row objects.
  #
  # One index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete(0)
  #     deleted_values # => [#<CSV::Row "Name":"foo" "Value":"0">]
  #
  # Two indexes:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete(2, 0)
  #     deleted_values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]
  #
  # ---
  #
  # Returns columns data as column Arrays.
  #
  # One header:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete('Name')
  #     deleted_values # => ["foo", "bar", "baz"]
  #
  # Two headers:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete('Value', 'Name')
  #     deleted_values # => [["0", "1", "2"], ["foo", "bar", "baz"]]
  #
  def delete: (*untyped indexes_or_headers) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.delete_if {|row_or_column| ... } -> self
  # -->
  # Removes rows or columns for which the block returns a truthy value; returns
  # `self`.
  #
  # Removes rows when the access mode is `:row` or `:col_or_row`; calls the block
  # with each CSV::Row object:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table.size # => 3
  #     table.delete_if {|row| row['Name'].start_with?('b') }
  #     table.size # => 1
  #
  # Removes columns when the access mode is `:col`; calls the block with each
  # column as a 2-element array containing the header and an Array of column
  # fields:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table.headers.size # => 2
  #     table.delete_if {|column_data| column_data[1].include?('2') }
  #     table.headers.size # => 1
  #
  # Returns a new Enumerator if no block is given:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.delete_if # => #<Enumerator: #<CSV::Table mode:col_or_row row_count:4>:delete_if>
  #
  def delete_if: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - dig(index_or_header, *index_or_headers)
  # -->
  # Extracts the nested value specified by the sequence of `index` or `header`
  # objects by calling dig at each step, returning nil if any intermediate step is
  # nil.
  #
  def dig: (untyped index_or_header, *untyped index_or_headers) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.each {|row_or_column| ... ) -> self
  # -->
  # Calls the block with each row or column; returns `self`.
  #
  # When the access mode is `:row` or `:col_or_row`, calls the block with each
  # CSV::Row object:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table.each {|row| p row }
  #
  # Output:
  #     #<CSV::Row "Name":"foo" "Value":"0">
  #     #<CSV::Row "Name":"bar" "Value":"1">
  #     #<CSV::Row "Name":"baz" "Value":"2">
  #
  # When the access mode is `:col`, calls the block with each column as a
  # 2-element array containing the header and an Array of column fields:
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table.each {|column_data| p column_data }
  #
  # Output:
  #     ["Name", ["foo", "bar", "baz"]]
  #     ["Value", ["0", "1", "2"]]
  #
  # Returns a new Enumerator if no block is given:
  #     table.each # => #<Enumerator: #<CSV::Table mode:col row_count:4>:each>
  #
  def each: () -> Enumerator[Elem, self]
          | () { (Elem) -> void } -> self
          | () { (*untyped) -> void } -> self

  def empty?: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.headers -> array_of_headers
  # -->
  # Returns a new Array containing the String headers for the table.
  #
  # If the table is not empty, returns the headers from the first row:
  #     rows = [
  #       CSV::Row.new(['Foo', 'Bar'], []),
  #       CSV::Row.new(['FOO', 'BAR'], []),
  #       CSV::Row.new(['foo', 'bar'], []),
  #     ]
  #     table  = CSV::Table.new(rows)
  #     table.headers # => ["Foo", "Bar"]
  #     table.delete(0)
  #     table.headers # => ["FOO", "BAR"]
  #     table.delete(0)
  #     table.headers # => ["foo", "bar"]
  #
  # If the table is empty, returns a copy of the headers in the table itself:
  #     table.delete(0)
  #     table.headers # => ["Foo", "Bar"]
  #
  def headers: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.inspect => string
  # -->
  # Returns a `US-ASCII`-encoded String showing table:
  # *   Class: `CSV::Table`.
  # *   Access mode: `:row`, `:col`, or `:col_or_row`.
  # *   Size:  Row count, including the header row.
  #
  # Example:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.inspect # => "#<CSV::Table mode:col_or_row row_count:4>\nName,Value\nfoo,0\nbar,1\nbaz,2\n"
  #
  def inspect: () -> String

  def length: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!-- rdoc-file=lib/csv/table.rb -->
  # The current access mode for indexing and iteration.
  #
  def mode: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.push(*rows_or_arrays) -> self
  # -->
  # A shortcut for appending multiple rows. Equivalent to:
  #     rows.each {|row| self << row }
  #
  # Each argument may be either a CSV::Row object or an Array:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     rows = [
  #       CSV::Row.new(table.headers, ['bat', 3]),
  #       ['bam', 4]
  #     ]
  #     table.push(*rows)
  #     table[3..4] # => [#<CSV::Row "Name":"bat" "Value":3>, #<CSV::Row "Name":"bam" "Value":4>]
  #
  def push: (*untyped rows) -> untyped

  def size: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.to_a -> array_of_arrays
  # -->
  # Returns the table as an Array of Arrays; the headers are in the first row:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.to_a # => [["Name", "Value"], ["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  def to_a: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.to_csv(**options) -> csv_string
  # -->
  # Returns the table as CSV string. See [Options for
  # Generating](../CSV.html#class-CSV-label-Options+for+Generating).
  #
  # Defaults option `write_headers` to `true`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.to_csv # => "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #
  # Omits the headers if option `write_headers` is given as `false` (see {Option
  # `write_headers`[}](../CSV.html#class-CSV-label-Option+write_headers)):
  #     table.to_csv(write_headers: false) # => "foo,0\nbar,1\nbaz,2\n"
  #
  # Limit rows if option `limit` is given like `2`:
  #     table.to_csv(limit: 2) # => "Name,Value\nfoo,0\nbar,1\n"
  #
  def to_csv: (?write_headers: boolish, **untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - to_s(write_headers: true, limit: nil, **options)
  # -->
  #
  alias to_s to_csv

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.values_at(*indexes) -> array_of_rows
  #   - table.values_at(*headers) -> array_of_columns_data
  # -->
  # If the access mode is `:row` or `:col_or_row`, and each argument is either an
  # Integer or a Range, returns rows. Otherwise, returns columns data.
  #
  # In either case, the returned values are in the order specified by the
  # arguments.  Arguments may be repeated.
  #
  # ---
  #
  # Returns rows as an Array of CSV::Row objects.
  #
  # No argument:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.values_at # => []
  #
  # One index:
  #     values = table.values_at(0)
  #     values # => [#<CSV::Row "Name":"foo" "Value":"0">]
  #
  # Two indexes:
  #     values = table.values_at(2, 0)
  #     values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]
  #
  # One Range:
  #     values = table.values_at(1..2)
  #     values # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # Ranges and indexes:
  #     values = table.values_at(0..1, 1..2, 0, 2)
  #     pp values
  #
  # Output:
  #     [#<CSV::Row "Name":"foo" "Value":"0">,
  #      #<CSV::Row "Name":"bar" "Value":"1">,
  #      #<CSV::Row "Name":"bar" "Value":"1">,
  #      #<CSV::Row "Name":"baz" "Value":"2">,
  #      #<CSV::Row "Name":"foo" "Value":"0">,
  #      #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # ---
  #
  # Returns columns data as row Arrays, each consisting of the specified columns
  # data for that row:
  #     values = table.values_at('Name')
  #     values # => [["foo"], ["bar"], ["baz"]]
  #     values = table.values_at('Value', 'Name')
  #     values # => [["0", "foo"], ["1", "bar"], ["2", "baz"]]
  #
  def values_at: (*untyped indices_or_headers) -> untyped
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem] < Object
  # Equivalent to CSV::generate_line(self, options)
  #
  #   ["CSV", "data"].to_csv
  #     #=> "CSV,data\n"
  def to_csv: (**untyped options) -> String
end

%a{annotate:rdoc:skip}
class String
  # Equivalent to CSV::parse_line(self, options)
  #
  #   "CSV,data".parse_csv
  #     #=> ["CSV", "data"]
  def parse_csv: (**untyped options) -> ::Array[String?]?
end
# <!-- rdoc-file=ext/date/date_core.c -->
# Class Date provides methods for storing and manipulating calendar dates.
#
# Consider using [class Time](rdoc-ref:Time) instead of class Date if:
#
# *   You need both dates and times; Date handles only dates.
# *   You need only Gregorian dates (and not Julian dates); see [Julian and
#     Gregorian Calendars](rdoc-ref:date/calendars.rdoc).
#
# A Date object, once created, is immutable, and cannot be modified.
#
# ## Creating a Date
#
# You can create a date for the current date, using Date.today:
#
#     Date.today # => #<Date: 1999-12-31>
#
# You can create a specific date from various combinations of arguments:
#
# *   Date.new takes integer year, month, and day-of-month:
#
#         Date.new(1999, 12, 31) # => #<Date: 1999-12-31>
#
# *   Date.ordinal takes integer year and day-of-year:
#
#         Date.ordinal(1999, 365) # => #<Date: 1999-12-31>
#
# *   Date.jd takes integer Julian day:
#
#         Date.jd(2451544) # => #<Date: 1999-12-31>
#
# *   Date.commercial takes integer commercial data (year, week, day-of-week):
#
#         Date.commercial(1999, 52, 5) # => #<Date: 1999-12-31>
#
# *   Date.parse takes a string, which it parses heuristically:
#
#         Date.parse('1999-12-31')    # => #<Date: 1999-12-31>
#         Date.parse('31-12-1999')    # => #<Date: 1999-12-31>
#         Date.parse('1999-365')      # => #<Date: 1999-12-31>
#         Date.parse('1999-W52-5')    # => #<Date: 1999-12-31>
#
# *   Date.strptime takes a date string and a format string, then parses the
#     date string according to the format string:
#
#         Date.strptime('1999-12-31', '%Y-%m-%d')  # => #<Date: 1999-12-31>
#         Date.strptime('31-12-1999', '%d-%m-%Y')  # => #<Date: 1999-12-31>
#         Date.strptime('1999-365', '%Y-%j')       # => #<Date: 1999-12-31>
#         Date.strptime('1999-W52-5', '%G-W%V-%u') # => #<Date: 1999-12-31>
#         Date.strptime('1999 52 5', '%Y %U %w')   # => #<Date: 1999-12-31>
#         Date.strptime('1999 52 5', '%Y %W %u')   # => #<Date: 1999-12-31>
#         Date.strptime('fri31dec99', '%a%d%b%y')  # => #<Date: 1999-12-31>
#
# See also the specialized methods in ["Specialized Format Strings" in Formats
# for Dates and
# Times](rdoc-ref:strftime_formatting.rdoc@Specialized+Format+Strings)
#
# ## Argument `limit`
#
# Certain singleton methods in Date that parse string arguments also take
# optional keyword argument `limit`, which can limit the length of the string
# argument.
#
# When `limit` is:
#
# *   Non-negative: raises ArgumentError if the string length is greater than
#     *limit*.
# *   Other numeric or `nil`: ignores `limit`.
# *   Other non-numeric: raises TypeError.
#
class Date
  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.new(year = -4712, month = 1, mday = 1, start = Date::ITALY) -> date
  # -->
  # Returns a new Date object constructed from the given arguments:
  #
  #     Date.new(2022).to_s        # => "2022-01-01"
  #     Date.new(2022, 2).to_s     # => "2022-02-01"
  #     Date.new(2022, 2, 4).to_s  # => "2022-02-04"
  #
  # Argument `month` should be in range (1..12) or range (-12..-1); when the
  # argument is negative, counts backward from the end of the year:
  #
  #     Date.new(2022, -11, 4).to_s # => "2022-02-04"
  #
  # Argument `mday` should be in range (1..n) or range (-n..-1) where `n` is the
  # number of days in the month; when the argument is negative, counts backward
  # from the end of the month.
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd.
  #
  def initialize: (?Integer year, ?Integer month, ?Integer mday, ?Integer start) -> void

  include Comparable

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._httpdate(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid [HTTP
  # date format](rdoc-ref:strftime_formatting.rdoc@HTTP+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.httpdate # => "Sat, 03 Feb 2001 00:00:00 GMT"
  #     Date._httpdate(s)
  #     # => {:wday=>6, :mday=>3, :mon=>2, :year=>2001, :hour=>0, :min=>0, :sec=>0, :zone=>"GMT", :offset=>0}
  #
  # Related: Date.httpdate (returns a Date object).
  #
  def self._httpdate: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._iso8601(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should contain an [ISO
  # 8601 formatted
  # date](rdoc-ref:strftime_formatting.rdoc@ISO+8601+Format+Specifications):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.iso8601    # => "2001-02-03"
  #     Date._iso8601(s) # => {:mday=>3, :year=>2001, :mon=>2}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.iso8601 (returns a Date object).
  #
  def self._iso8601: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._jisx0301(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid [JIS X
  # 0301 date format](rdoc-ref:strftime_formatting.rdoc@JIS+X+0301+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.jisx0301    # => "H13.02.03"
  #     Date._jisx0301(s) # => {:year=>2001, :mon=>2, :mday=>3}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.jisx0301 (returns a Date object).
  #
  def self._jisx0301: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._parse(string, comp = true, limit: 128) -> hash
  # -->
  # **Note**: This method recognizes many forms in `string`, but it is not a
  # validator. For formats, see ["Specialized Format Strings" in Formats for Dates
  # and Times](rdoc-ref:strftime_formatting.rdoc@Specialized+Format+Strings)
  #
  # If `string` does not specify a valid date, the result is unpredictable;
  # consider using Date._strptime instead.
  #
  # Returns a hash of values parsed from `string`:
  #
  #     Date._parse('2001-02-03') # => {:year=>2001, :mon=>2, :mday=>3}
  #
  # If `comp` is `true` and the given year is in the range `(0..99)`, the current
  # century is supplied; otherwise, the year is taken as given:
  #
  #     Date._parse('01-02-03', true)  # => {:year=>2001, :mon=>2, :mday=>3}
  #     Date._parse('01-02-03', false) # => {:year=>1, :mon=>2, :mday=>3}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.parse(returns a Date object).
  #
  def self._parse: (String str, ?boolish complete) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc2822(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid [RFC
  # 2822 date format](rdoc-ref:strftime_formatting.rdoc@RFC+2822+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc2822 # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #     Date._rfc2822(s)
  #     # => {:wday=>6, :mday=>3, :mon=>2, :year=>2001, :hour=>0, :min=>0, :sec=>0, :zone=>"+0000", :offset=>0}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.rfc2822 (returns a Date object).
  #
  def self._rfc2822: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc3339(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid [RFC
  # 3339 format](rdoc-ref:strftime_formatting.rdoc@RFC+3339+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc3339     # => "2001-02-03T00:00:00+00:00"
  #     Date._rfc3339(s)
  #     # => {:year=>2001, :mon=>2, :mday=>3, :hour=>0, :min=>0, :sec=>0, :zone=>"+00:00", :offset=>0}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.rfc3339 (returns a Date object).
  #
  def self._rfc3339: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc2822(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid [RFC
  # 2822 date format](rdoc-ref:strftime_formatting.rdoc@RFC+2822+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc2822 # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #     Date._rfc2822(s)
  #     # => {:wday=>6, :mday=>3, :mon=>2, :year=>2001, :hour=>0, :min=>0, :sec=>0, :zone=>"+0000", :offset=>0}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.rfc2822 (returns a Date object).
  #
  def self._rfc822: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._strptime(string, format = '%F') -> hash
  # -->
  # Returns a hash of values parsed from `string` according to the given `format`:
  #
  #     Date._strptime('2001-02-03', '%Y-%m-%d') # => {:year=>2001, :mon=>2, :mday=>3}
  #
  # For other formats, see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc). (Unlike Date.strftime, does not
  # support flags and width.)
  #
  # See also [strptime(3)](https://man7.org/linux/man-pages/man3/strptime.3.html).
  #
  # Related: Date.strptime (returns a Date object).
  #
  def self._strptime: (String str, ?String format) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._xmlschema(string, limit: 128) -> hash
  # -->
  # Returns a hash of values parsed from `string`, which should be a valid XML
  # date format:
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.xmlschema    # => "2001-02-03"
  #     Date._xmlschema(s) # => {:year=>2001, :mon=>2, :mday=>3}
  #
  # See argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date.xmlschema (returns a Date object).
  #
  def self._xmlschema: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - civil(*args)
  # -->
  # Same as Date.new.
  #
  def self.civil: (?Integer year, ?Integer month, ?Integer mday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.commercial(cwyear = -4712, cweek = 1, cwday = 1, start = Date::ITALY) -> date
  # -->
  # Returns a new Date object constructed from the arguments.
  #
  # Argument `cwyear` gives the year, and should be an integer.
  #
  # Argument `cweek` gives the index of the week within the year, and should be in
  # range (1..53) or (-53..-1); in some years, 53 or -53 will be out-of-range; if
  # negative, counts backward from the end of the year:
  #
  #     Date.commercial(2022, 1, 1).to_s  # => "2022-01-03"
  #     Date.commercial(2022, 52, 1).to_s # => "2022-12-26"
  #
  # Argument `cwday` gives the indes of the weekday within the week, and should be
  # in range (1..7) or (-7..-1); 1 or -7 is Monday; if negative, counts backward
  # from the end of the week:
  #
  #     Date.commercial(2022, 1, 1).to_s  # => "2022-01-03"
  #     Date.commercial(2022, 1, -7).to_s # => "2022-01-03"
  #
  # When `cweek` is 1:
  #
  # *   If January 1 is a Friday, Saturday, or Sunday, the first week begins in
  #     the week after:
  #
  #         Date::ABBR_DAYNAMES[Date.new(2023, 1, 1).wday] # => "Sun"
  #         Date.commercial(2023, 1, 1).to_s # => "2023-01-02"
  #         Date.commercial(2023, 1, 7).to_s # => "2023-01-08"
  #
  # *   Otherwise, the first week is the week of January 1, which may mean some of
  #     the days fall on the year before:
  #
  #         Date::ABBR_DAYNAMES[Date.new(2020, 1, 1).wday] # => "Wed"
  #         Date.commercial(2020, 1, 1).to_s # => "2019-12-30"
  #         Date.commercial(2020, 1, 7).to_s # => "2020-01-05"
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.new, Date.ordinal.
  #
  def self.commercial: (?Integer cwyear, ?Integer cweek, ?Integer cwday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.gregorian_leap?(year) -> true or false
  # -->
  # Returns `true` if the given year is a leap year in the [proleptic Gregorian
  # calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar), `false`
  # otherwise:
  #
  #     Date.gregorian_leap?(2000) # => true
  #     Date.gregorian_leap?(2001) # => false
  #
  # Related: Date.julian_leap?.
  #
  def self.gregorian_leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.httpdate(string = 'Mon, 01 Jan -4712 00:00:00 GMT', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [HTTP date format](rdoc-ref:strftime_formatting.rdoc@HTTP+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.httpdate   # => "Sat, 03 Feb 2001 00:00:00 GMT"
  #     Date.httpdate(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._httpdate (returns a hash).
  #
  def self.httpdate: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.iso8601(string = '-4712-01-01', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should
  # contain an [ISO 8601 formatted
  # date](rdoc-ref:strftime_formatting.rdoc@ISO+8601+Format+Specifications):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.iso8601   # => "2001-02-03"
  #     Date.iso8601(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._iso8601 (returns a hash).
  #
  def self.iso8601: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.jd(jd = 0, start = Date::ITALY) -> date
  # -->
  # Returns a new Date object formed from the arguments:
  #
  #     Date.jd(2451944).to_s # => "2001-02-03"
  #     Date.jd(2451945).to_s # => "2001-02-04"
  #     Date.jd(0).to_s       # => "-4712-01-01"
  #
  # The returned date is:
  #
  # *   Gregorian, if the argument is greater than or equal to `start`:
  #
  #         Date::ITALY                         # => 2299161
  #         Date.jd(Date::ITALY).gregorian?     # => true
  #         Date.jd(Date::ITALY + 1).gregorian? # => true
  #
  # *   Julian, otherwise
  #
  #         Date.jd(Date::ITALY - 1).julian?    # => true
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.new.
  #
  def self.jd: (Integer jd, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.jisx0301(string = '-4712-01-01', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [JIS X 0301
  # format](rdoc-ref:strftime_formatting.rdoc@JIS+X+0301+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.jisx0301   # => "H13.02.03"
  #     Date.jisx0301(s) # => #<Date: 2001-02-03>
  #
  # For no-era year, legacy format, Heisei is assumed.
  #
  #     Date.jisx0301('13.02.03') # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._jisx0301 (returns a hash).
  #
  def self.jisx0301: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.julian_leap?(year) -> true or false
  # -->
  # Returns `true` if the given year is a leap year in the [proleptic Julian
  # calendar](https://en.wikipedia.org/wiki/Proleptic_Julian_calendar), `false`
  # otherwise:
  #
  #     Date.julian_leap?(1900) # => true
  #     Date.julian_leap?(1901) # => false
  #
  # Related: Date.gregorian_leap?.
  #
  def self.julian_leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.gregorian_leap?(year) -> true or false
  # -->
  # Returns `true` if the given year is a leap year in the [proleptic Gregorian
  # calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar), `false`
  # otherwise:
  #
  #     Date.gregorian_leap?(2000) # => true
  #     Date.gregorian_leap?(2001) # => false
  #
  # Related: Date.julian_leap?.
  #
  def self.leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.ordinal(year = -4712, yday = 1, start = Date::ITALY) -> date
  # -->
  # Returns a new Date object formed fom the arguments.
  #
  # With no arguments, returns the date for January 1, -4712:
  #
  #     Date.ordinal.to_s # => "-4712-01-01"
  #
  # With argument `year`, returns the date for January 1 of that year:
  #
  #     Date.ordinal(2001).to_s  # => "2001-01-01"
  #     Date.ordinal(-2001).to_s # => "-2001-01-01"
  #
  # With positive argument `yday` == `n`, returns the date for the `nth` day of
  # the given year:
  #
  #     Date.ordinal(2001, 14).to_s # => "2001-01-14"
  #
  # With negative argument `yday`, counts backward from the end of the year:
  #
  #     Date.ordinal(2001, -14).to_s # => "2001-12-18"
  #
  # Raises an exception if `yday` is zero or out of range.
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.new.
  #
  def self.ordinal: (?Integer year, ?Integer yday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.parse(string = '-4712-01-01', comp = true, start = Date::ITALY, limit: 128) -> date
  # -->
  # **Note**: This method recognizes many forms in `string`, but it is not a
  # validator. For formats, see ["Specialized Format Strings" in Formats for Dates
  # and Times](rdoc-ref:strftime_formatting.rdoc@Specialized+Format+Strings) If
  # `string` does not specify a valid date, the result is unpredictable; consider
  # using Date._strptime instead.
  #
  # Returns a new Date object with values parsed from `string`:
  #
  #     Date.parse('2001-02-03')   # => #<Date: 2001-02-03>
  #     Date.parse('20010203')     # => #<Date: 2001-02-03>
  #     Date.parse('3rd Feb 2001') # => #<Date: 2001-02-03>
  #
  # If `comp` is `true` and the given year is in the range `(0..99)`, the current
  # century is supplied; otherwise, the year is taken as given:
  #
  #     Date.parse('01-02-03', true)  # => #<Date: 2001-02-03>
  #     Date.parse('01-02-03', false) # => #<Date: 0001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._parse (returns a hash).
  #
  def self.parse: (?String str, ?boolish complete, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc2822(string = 'Mon, 1 Jan -4712 00:00:00 +0000', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [RFC 2822 date
  # format](rdoc-ref:strftime_formatting.rdoc@RFC+2822+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc2822   # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #     Date.rfc2822(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._rfc2822 (returns a hash).
  #
  def self.rfc2822: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc3339(string = '-4712-01-01T00:00:00+00:00', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [RFC 3339 format](rdoc-ref:strftime_formatting.rdoc@RFC+3339+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc3339   # => "2001-02-03T00:00:00+00:00"
  #     Date.rfc3339(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._rfc3339 (returns a hash).
  #
  def self.rfc3339: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc2822(string = 'Mon, 1 Jan -4712 00:00:00 +0000', start = Date::ITALY, limit: 128) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [RFC 2822 date
  # format](rdoc-ref:strftime_formatting.rdoc@RFC+2822+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc2822   # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #     Date.rfc2822(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._rfc2822 (returns a hash).
  #
  def self.rfc822: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.strptime(string = '-4712-01-01', format = '%F', start = Date::ITALY) -> date
  # -->
  # Returns a new Date object with values parsed from `string`, according to the
  # given `format`:
  #
  #     Date.strptime('2001-02-03', '%Y-%m-%d')  # => #<Date: 2001-02-03>
  #     Date.strptime('03-02-2001', '%d-%m-%Y')  # => #<Date: 2001-02-03>
  #     Date.strptime('2001-034', '%Y-%j')       # => #<Date: 2001-02-03>
  #     Date.strptime('2001-W05-6', '%G-W%V-%u') # => #<Date: 2001-02-03>
  #     Date.strptime('2001 04 6', '%Y %U %w')   # => #<Date: 2001-02-03>
  #     Date.strptime('2001 05 6', '%Y %W %u')   # => #<Date: 2001-02-03>
  #     Date.strptime('sat3feb01', '%a%d%b%y')   # => #<Date: 2001-02-03>
  #
  # For other formats, see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc). (Unlike Date.strftime, does not
  # support flags and width.)
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # See also [strptime(3)](https://man7.org/linux/man-pages/man3/strptime.3.html).
  #
  # Related: Date._strptime (returns a hash).
  #
  def self.strptime: (String str, ?String format, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.today(start = Date::ITALY) -> date
  # -->
  # Returns a new Date object constructed from the present date:
  #
  #     Date.today.to_s # => "2022-07-06"
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  def self.today: (?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_civil?(year, month, mday, start = Date::ITALY) -> true or false
  # -->
  # Returns `true` if the arguments define a valid ordinal date, `false`
  # otherwise:
  #
  #     Date.valid_date?(2001, 2, 3)  # => true
  #     Date.valid_date?(2001, 2, 29) # => false
  #     Date.valid_date?(2001, 2, -1) # => true
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.new.
  #
  def self.valid_civil?: (Integer year, Integer month, Integer mday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_commercial?(cwyear, cweek, cwday, start = Date::ITALY) -> true or false
  # -->
  # Returns `true` if the arguments define a valid commercial date, `false`
  # otherwise:
  #
  #     Date.valid_commercial?(2001, 5, 6) # => true
  #     Date.valid_commercial?(2001, 5, 8) # => false
  #
  # See Date.commercial.
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.commercial.
  #
  def self.valid_commercial?: (Integer cwyear, Integer cweek, Integer cwday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_civil?(year, month, mday, start = Date::ITALY) -> true or false
  # -->
  # Returns `true` if the arguments define a valid ordinal date, `false`
  # otherwise:
  #
  #     Date.valid_date?(2001, 2, 3)  # => true
  #     Date.valid_date?(2001, 2, 29) # => false
  #     Date.valid_date?(2001, 2, -1) # => true
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.new.
  #
  def self.valid_date?: (Integer year, Integer month, Integer mday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_jd?(jd, start = Date::ITALY) -> true
  # -->
  # Implemented for compatibility; returns `true` unless `jd` is invalid (i.e.,
  # not a Numeric).
  #
  #     Date.valid_jd?(2451944) # => true
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd.
  #
  def self.valid_jd?: (Integer jd, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_ordinal?(year, yday, start = Date::ITALY) -> true or false
  # -->
  # Returns `true` if the arguments define a valid ordinal date, `false`
  # otherwise:
  #
  #     Date.valid_ordinal?(2001, 34)  # => true
  #     Date.valid_ordinal?(2001, 366) # => false
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  # Related: Date.jd, Date.ordinal.
  #
  def self.valid_ordinal?: (Integer year, Integer yday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.xmlschema(string = '-4712-01-01', start = Date::ITALY, limit: 128)  ->  date
  # -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid XML date format:
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.xmlschema   # => "2001-02-03"
  #     Date.xmlschema(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._xmlschema (returns a hash).
  #
  def self.xmlschema: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d + other  ->  date
  # -->
  # Returns a date object pointing `other` days after self.  The other should be a
  # numeric value.  If the other is a fractional number, assumes its precision is
  # at most nanosecond.
  #
  #     Date.new(2001,2,3) + 1    #=> #<Date: 2001-02-04 ...>
  #     DateTime.new(2001,2,3) + Rational(1,2)
  #                               #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>
  #     DateTime.new(2001,2,3) + Rational(-1,2)
  #                               #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
  #     DateTime.jd(0,12) + DateTime.new(2001,2,3).ajd
  #                               #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #
  def +: (Numeric & _ToR other) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d - other  ->  date or rational
  # -->
  # If the other is a date object, returns a Rational whose value is the
  # difference between the two dates in days. If the other is a numeric value,
  # returns a date object pointing `other` days before self. If the other is a
  # fractional number, assumes its precision is at most nanosecond.
  #
  #     Date.new(2001,2,3) - 1   #=> #<Date: 2001-02-02 ...>
  #     DateTime.new(2001,2,3) - Rational(1,2)
  #                              #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
  #     Date.new(2001,2,3) - Date.new(2001)
  #                              #=> (33/1)
  #     DateTime.new(2001,2,3) - DateTime.new(2001,2,2,12)
  #                              #=> (1/2)
  #
  def -: (Numeric & _ToR other) -> Date
       | (Date other) -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d << n  ->  date
  # -->
  # Returns a new Date object representing the date `n` months earlier; `n` should
  # be a numeric:
  #
  #     (Date.new(2001, 2, 3) << 1).to_s  # => "2001-01-03"
  #     (Date.new(2001, 2, 3) << -2).to_s # => "2001-04-03"
  #
  # When the same day does not exist for the new month, the last day of that month
  # is used instead:
  #
  #     (Date.new(2001, 3, 31) << 1).to_s  # => "2001-02-28"
  #     (Date.new(2001, 3, 31) << -6).to_s # => "2001-09-30"
  #
  # This results in the following, possibly unexpected, behaviors:
  #
  #     d0 = Date.new(2001, 3, 31)
  #     d0 << 2      # => #<Date: 2001-01-31>
  #     d0 << 1 << 1 # => #<Date: 2001-01-28>
  #
  #     d0 = Date.new(2001, 3, 31)
  #     d1 = d0 << 1  # => #<Date: 2001-02-28>
  #     d2 = d1 << -1 # => #<Date: 2001-03-28>
  #
  def <<: (Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - self <=> other  -> -1, 0, 1 or nil
  # -->
  # Compares `self` and `other`, returning:
  #
  # *   `-1` if `other` is larger.
  # *   `0` if the two are equal.
  # *   `1` if `other` is smaller.
  # *   `nil` if the two are incomparable.
  #
  # Argument `other` may be:
  #
  # *   Another Date object:
  #
  #         d = Date.new(2022, 7, 27) # => #<Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)>
  #         prev_date = d.prev_day    # => #<Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)>
  #         next_date = d.next_day    # => #<Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)>
  #         d <=> next_date           # => -1
  #         d <=> d                   # => 0
  #         d <=> prev_date           # => 1
  #
  # *   A DateTime object:
  #
  #         d <=> DateTime.new(2022, 7, 26) # => 1
  #         d <=> DateTime.new(2022, 7, 27) # => 0
  #         d <=> DateTime.new(2022, 7, 28) # => -1
  #
  # *   A numeric (compares `self.ajd` to `other`):
  #
  #         d <=> 2459788 # => -1
  #         d <=> 2459787 # => 1
  #         d <=> 2459786 # => 1
  #         d <=> d.ajd   # => 0
  #
  # *   Any other object:
  #
  #         d <=> Object.new # => nil
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - self === other -> true, false, or nil.
  # -->
  # Returns `true` if `self` and `other` represent the same date, `false` if not,
  # `nil` if the two are not comparable.
  #
  # Argument `other` may be:
  #
  # *   Another Date object:
  #
  #         d = Date.new(2022, 7, 27) # => #<Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)>
  #         prev_date = d.prev_day    # => #<Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)>
  #         next_date = d.next_day    # => #<Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)>
  #         d === prev_date           # => false
  #         d === d                   # => true
  #         d === next_date           # => false
  #
  # *   A DateTime object:
  #
  #         d === DateTime.new(2022, 7, 26) # => false
  #         d === DateTime.new(2022, 7, 27) # => true
  #         d === DateTime.new(2022, 7, 28) # => false
  #
  # *   A numeric (compares `self.jd` to `other`):
  #
  #         d === 2459788 # => true
  #         d === 2459787 # => false
  #         d === 2459786 # => false
  #         d === d.jd    # => true
  #
  # *   An object not comparable:
  #
  #         d === Object.new # => nil
  #
  def ===: (Date other) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d >> n -> new_date
  # -->
  # Returns a new Date object representing the date `n` months later; `n` should
  # be a numeric:
  #
  #     (Date.new(2001, 2, 3) >> 1).to_s  # => "2001-03-03"
  #     (Date.new(2001, 2, 3) >> -2).to_s # => "2000-12-03"
  #
  # When the same day does not exist for the new month, the last day of that month
  # is used instead:
  #
  #     (Date.new(2001, 1, 31) >> 1).to_s  # => "2001-02-28"
  #     (Date.new(2001, 1, 31) >> -4).to_s # => "2000-09-30"
  #
  # This results in the following, possibly unexpected, behaviors:
  #
  #     d0 = Date.new(2001, 1, 31)
  #     d1 = d0 >> 1 # => #<Date: 2001-02-28>
  #     d2 = d1 >> 1 # => #<Date: 2001-03-28>
  #
  #     d0 = Date.new(2001, 1, 31)
  #     d1 = d0 >> 1  # => #<Date: 2001-02-28>
  #     d2 = d1 >> -1 # => #<Date: 2001-01-28>
  #
  def >>: (Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.ajd  ->  rational
  # -->
  # Returns the astronomical Julian day number.  This is a fractional number,
  # which is not adjusted by the offset.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').ajd     #=> (11769328217/4800)
  #     DateTime.new(2001,2,2,14,5,6,'-7').ajd    #=> (11769328217/4800)
  #
  def ajd: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.amjd  ->  rational
  # -->
  # Returns the astronomical modified Julian day number.  This is a fractional
  # number, which is not adjusted by the offset.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').amjd    #=> (249325817/4800)
  #     DateTime.new(2001,2,2,14,5,6,'-7').amjd   #=> (249325817/4800)
  #
  def amjd: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - asctime -> string
  # -->
  # Equivalent to #strftime with argument `'%a %b %e %T %Y'` (or its [shorthand
  # form](rdoc-ref:strftime_formatting.rdoc@Shorthand+Conversion+Specifiers)
  # `'%c'`):
  #
  #     Date.new(2001, 2, 3).asctime # => "Sat Feb  3 00:00:00 2001"
  #
  # See [asctime](https://linux.die.net/man/3/asctime).
  #
  def asctime: () -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Equivalent to #strftime with argument `'%a %b %e %T %Y'` (or its [shorthand
  # form](rdoc-ref:strftime_formatting.rdoc@Shorthand+Conversion+Specifiers)
  # `'%c'`):
  #
  #     Date.new(2001, 2, 3).asctime # => "Sat Feb  3 00:00:00 2001"
  #
  # See [asctime](https://linux.die.net/man/3/asctime).
  #
  def ctime: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - cwday -> integer
  # -->
  # Returns the commercial-date weekday index for `self` (see Date.commercial); 1
  # is Monday:
  #
  #     Date.new(2001, 2, 3).cwday # => 6
  #
  def cwday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - cweek -> integer
  # -->
  # Returns commercial-date week index for `self` (see Date.commercial):
  #
  #     Date.new(2001, 2, 3).cweek # => 5
  #
  def cweek: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - cwyear -> integer
  # -->
  # Returns commercial-date year for `self` (see Date.commercial):
  #
  #     Date.new(2001, 2, 3).cwyear # => 2001
  #     Date.new(2000, 1, 1).cwyear # => 1999
  #
  def cwyear: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the day of the month in range (1..31):
  #
  #     Date.new(2001, 2, 3).mday # => 3
  #
  def day: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - deconstruct_keys(array_of_names_or_nil) -> hash
  # -->
  # Returns a hash of the name/value pairs, to use in pattern matching. Possible
  # keys are: `:year`, `:month`, `:day`, `:wday`, `:yday`.
  #
  # Possible usages:
  #
  #     d = Date.new(2022, 10, 5)
  #
  #     if d in wday: 3, day: ..7  # uses deconstruct_keys underneath
  #       puts "first Wednesday of the month"
  #     end
  #     #=> prints "first Wednesday of the month"
  #
  #     case d
  #     in year: ...2022
  #       puts "too old"
  #     in month: ..9
  #       puts "quarter 1-3"
  #     in wday: 1..5, month:
  #       puts "working day in month #{month}"
  #     end
  #     #=> prints "working day in month 10"
  #
  # Note that deconstruction by pattern can also be combined with class check:
  #
  #     if d in Date(wday: 3, day: ..7)
  #       puts "first Wednesday of the month"
  #     end
  #
  def deconstruct_keys: (Array[Symbol]?) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - downto(min){|date| ... } -> self
  # -->
  # Equivalent to #step with arguments `min` and `-1`.
  #
  def downto: (Date min) { (Date) -> untyped } -> Date
            | (Date min) -> Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - england -> new_date
  # -->
  # Equivalent to Date#new_start with argument Date::ENGLAND.
  #
  def england: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - friday? -> true or false
  # -->
  # Returns `true` if `self` is a Friday, `false` otherwise.
  #
  def friday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - gregorian -> new_date
  # -->
  # Equivalent to Date#new_start with argument Date::GREGORIAN.
  #
  def gregorian: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - gregorian? -> true or false
  # -->
  # Returns `true` if the date is on or after the date of calendar reform, `false`
  # otherwise:
  #
  #     Date.new(1582, 10, 15).gregorian?       # => true
  #     (Date.new(1582, 10, 15) - 1).gregorian? # => false
  #
  def gregorian?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - httpdate -> string
  # -->
  # Equivalent to #strftime with argument `'%a, %d %b %Y %T GMT'`; see [Formats
  # for Dates and Times](rdoc-ref:strftime_formatting.rdoc):
  #
  #     Date.new(2001, 2, 3).httpdate # => "Sat, 03 Feb 2001 00:00:00 GMT"
  #
  def httpdate: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     Date.new(2001, 2, 3).inspect
  #     # => "#<Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - iso8601    ->  string
  # -->
  # Equivalent to #strftime with argument `'%Y-%m-%d'` (or its [shorthand
  # form](rdoc-ref:strftime_formatting.rdoc@Shorthand+Conversion+Specifiers)
  # `'%F'`);
  #
  #     Date.new(2001, 2, 3).iso8601 # => "2001-02-03"
  #
  def iso8601: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - italy -> new_date
  # -->
  # Equivalent to Date#new_start with argument Date::ITALY.
  #
  def italy: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.jd  ->  integer
  # -->
  # Returns the Julian day number.  This is a whole number, which is adjusted by
  # the offset as the local time.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').jd      #=> 2451944
  #     DateTime.new(2001,2,3,4,5,6,'-7').jd      #=> 2451944
  #
  def jd: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - jisx0301 -> string
  # -->
  # Returns a string representation of the date in `self` in JIS X 0301 format.
  #
  #     Date.new(2001, 2, 3).jisx0301 # => "H13.02.03"
  #
  def jisx0301: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - julian -> new_date
  # -->
  # Equivalent to Date#new_start with argument Date::JULIAN.
  #
  def julian: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.julian? -> true or false
  # -->
  # Returns `true` if the date is before the date of calendar reform, `false`
  # otherwise:
  #
  #     (Date.new(1582, 10, 15) - 1).julian? # => true
  #     Date.new(1582, 10, 15).julian?       # => false
  #
  def julian?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - ld -> integer
  # -->
  # Returns the [Lilian day number](https://en.wikipedia.org/wiki/Lilian_date),
  # which is the number of days since the beginning of the Gregorian calendar,
  # October 15, 1582.
  #
  #     Date.new(2001, 2, 3).ld # => 152784
  #
  def ld: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - leap? -> true or false
  # -->
  # Returns `true` if the year is a leap year, `false` otherwise:
  #
  #     Date.new(2000).leap? # => true
  #     Date.new(2001).leap? # => false
  #
  def leap?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - mday -> integer
  # -->
  # Returns the day of the month in range (1..31):
  #
  #     Date.new(2001, 2, 3).mday # => 3
  #
  def mday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.mjd  ->  integer
  # -->
  # Returns the modified Julian day number.  This is a whole number, which is
  # adjusted by the offset as the local time.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').mjd     #=> 51943
  #     DateTime.new(2001,2,3,4,5,6,'-7').mjd     #=> 51943
  #
  def mjd: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - mon -> integer
  # -->
  # Returns the month in range (1..12):
  #
  #     Date.new(2001, 2, 3).mon # => 2
  #
  def mon: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - monday? -> true or false
  # -->
  # Returns `true` if `self` is a Monday, `false` otherwise.
  #
  def monday?: () -> bool

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the month in range (1..12):
  #
  #     Date.new(2001, 2, 3).mon # => 2
  #
  def month: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - new_start(start = Date::ITALY]) -> new_date
  # -->
  # Returns a copy of `self` with the given `start` value:
  #
  #     d0 = Date.new(2000, 2, 3)
  #     d0.julian? # => false
  #     d1 = d0.new_start(Date::JULIAN)
  #     d1.julian? # => true
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  def new_start: (?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.next -> new_date
  # -->
  # Returns a new Date object representing the following day:
  #
  #     d = Date.new(2001, 2, 3)
  #     d.to_s      # => "2001-02-03"
  #     d.next.to_s # => "2001-02-04"
  #
  def next: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - next_day(n = 1) -> new_date
  # -->
  # Equivalent to Date#+ with argument `n`.
  #
  def next_day: (?Integer day) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - next_month(n = 1) -> new_date
  # -->
  # Equivalent to #>> with argument `n`.
  #
  def next_month: (?Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - next_year(n = 1) -> new_date
  # -->
  # Equivalent to #>> with argument `n * 12`.
  #
  def next_year: (?Integer year) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - prev_day(n = 1) -> new_date
  # -->
  # Equivalent to Date#- with argument `n`.
  #
  def prev_day: (?Integer day) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - prev_month(n = 1) -> new_date
  # -->
  # Equivalent to #<< with argument `n`.
  #
  def prev_month: (?Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - prev_year(n = 1) -> new_date
  # -->
  # Equivalent to #<< with argument `n * 12`.
  #
  def prev_year: (?Integer year) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - rfc2822 -> string
  # -->
  # Equivalent to #strftime with argument `'%a, %-d %b %Y %T %z'`; see [Formats
  # for Dates and Times](rdoc-ref:strftime_formatting.rdoc):
  #
  #     Date.new(2001, 2, 3).rfc2822 # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #
  def rfc2822: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - rfc3339 -> string
  # -->
  # Equivalent to #strftime with argument `'%FT%T%:z'`; see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc):
  #
  #     Date.new(2001, 2, 3).rfc3339 # => "2001-02-03T00:00:00+00:00"
  #
  def rfc3339: () -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns a new Date object with values parsed from `string`, which should be a
  # valid [RFC 2822 date
  # format](rdoc-ref:strftime_formatting.rdoc@RFC+2822+Format):
  #
  #     d = Date.new(2001, 2, 3)
  #     s = d.rfc2822   # => "Sat, 3 Feb 2001 00:00:00 +0000"
  #     Date.rfc2822(s) # => #<Date: 2001-02-03>
  #
  # See:
  #
  # *   Argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  # *   Argument [limit](rdoc-ref:Date@Argument+limit).
  #
  # Related: Date._rfc2822 (returns a hash).
  #
  def rfc822: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - saturday? -> true or false
  # -->
  # Returns `true` if `self` is a Saturday, `false` otherwise.
  #
  def saturday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - start -> float
  # -->
  # Returns the Julian start date for calendar reform; if not an infinity, the
  # returned value is suitable for passing to Date#jd:
  #
  #     d = Date.new(2001, 2, 3, Date::ITALY)
  #     s = d.start     # => 2299161.0
  #     Date.jd(s).to_s # => "1582-10-15"
  #
  #     d = Date.new(2001, 2, 3, Date::ENGLAND)
  #     s = d.start     # => 2361222.0
  #     Date.jd(s).to_s # => "1752-09-14"
  #
  #     Date.new(2001, 2, 3, Date::GREGORIAN).start # => -Infinity
  #     Date.new(2001, 2, 3, Date::JULIAN).start    # => Infinity
  #
  # See argument [start](rdoc-ref:date/calendars.rdoc@Argument+start).
  #
  def start: () -> Float

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - step(limit, step = 1){|date| ... } -> self
  # -->
  # Calls the block with specified dates; returns `self`.
  #
  # *   The first `date` is `self`.
  # *   Each successive `date` is `date + step`, where `step` is the numeric step
  #     size in days.
  # *   The last date is the last one that is before or equal to `limit`, which
  #     should be a Date object.
  #
  # Example:
  #
  #     limit = Date.new(2001, 12, 31)
  #     Date.new(2001).step(limit){|date| p date.to_s if date.mday == 31 }
  #
  # Output:
  #
  #     "2001-01-31"
  #     "2001-03-31"
  #     "2001-05-31"
  #     "2001-07-31"
  #     "2001-08-31"
  #     "2001-10-31"
  #     "2001-12-31"
  #
  # Returns an Enumerator if no block is given.
  #
  def step: (Date limit, ?Integer step) { (Date) -> untyped } -> Date
          | (Date limit, ?Integer step) -> ::Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - strftime(format = '%F') -> string
  # -->
  # Returns a string representation of the date in `self`, formatted according the
  # given `format`:
  #
  #     Date.new(2001, 2, 3).strftime # => "2001-02-03"
  #
  # For other formats, see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc).
  #
  def strftime: (?String format) -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns a new Date object representing the following day:
  #
  #     d = Date.new(2001, 2, 3)
  #     d.to_s      # => "2001-02-03"
  #     d.next.to_s # => "2001-02-04"
  #
  def succ: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - sunday? -> true or false
  # -->
  # Returns `true` if `self` is a Sunday, `false` otherwise.
  #
  def sunday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - thursday? -> true or false
  # -->
  # Returns `true` if `self` is a Thursday, `false` otherwise.
  #
  def thursday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - to_date -> self
  # -->
  # Returns `self`.
  #
  def to_date: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.to_datetime  -> datetime
  # -->
  # Returns a DateTime whose value is the same as `self`:
  #
  #     Date.new(2001, 2, 3).to_datetime # => #<DateTime: 2001-02-03T00:00:00+00:00>
  #
  def to_datetime: () -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - to_s -> string
  # -->
  # Returns a string representation of the date in `self` in [ISO 8601 extended
  # date format](rdoc-ref:strftime_formatting.rdoc@ISO+8601+Format+Specifications)
  # (`'%Y-%m-%d'`):
  #
  #     Date.new(2001, 2, 3).to_s # => "2001-02-03"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - to_time -> time
  # -->
  # Returns a new Time object with the same value as `self`; if `self` is a Julian
  # date, derives its Gregorian date for conversion to the Time object:
  #
  #     Date.new(2001, 2, 3).to_time               # => 2001-02-03 00:00:00 -0600
  #     Date.new(2001, 2, 3, Date::JULIAN).to_time # => 2001-02-16 00:00:00 -0600
  #
  def to_time: () -> Time

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - tuesday? -> true or false
  # -->
  # Returns `true` if `self` is a Tuesday, `false` otherwise.
  #
  def tuesday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - upto(max){|date| ... } -> self
  # -->
  # Equivalent to #step with arguments `max` and `1`.
  #
  def upto: (Date max) { (Date) -> untyped } -> Date
          | (Date max) -> ::Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - wday -> integer
  # -->
  # Returns the day of week in range (0..6); Sunday is 0:
  #
  #     Date.new(2001, 2, 3).wday # => 6
  #
  def wday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - wednesday? -> true or false
  # -->
  # Returns `true` if `self` is a Wednesday, `false` otherwise.
  #
  def wednesday?: () -> bool

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Equivalent to #strftime with argument `'%Y-%m-%d'` (or its [shorthand
  # form](rdoc-ref:strftime_formatting.rdoc@Shorthand+Conversion+Specifiers)
  # `'%F'`);
  #
  #     Date.new(2001, 2, 3).iso8601 # => "2001-02-03"
  #
  def xmlschema: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - yday -> integer
  # -->
  # Returns the day of the year, in range (1..366):
  #
  #     Date.new(2001, 2, 3).yday # => 34
  #
  def yday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - year -> integer
  # -->
  # Returns the year:
  #
  #     Date.new(2001, 2, 3).year    # => 2001
  #     (Date.new(1, 1, 1) - 1).year # => 0
  #
  def year: () -> Integer
end

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of abbreviated day names in English.  The first is "Sun".
#
Date::ABBR_DAYNAMES: Array[String]

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of abbreviated month names in English.  The first element
# is nil.
#
Date::ABBR_MONTHNAMES: Array[String?]

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of the full names of days of the week in English. The
# first is "Sunday".
#
Date::DAYNAMES: Array[String]

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for England and her
# colonies.
#
Date::ENGLAND: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for the proleptic
# Gregorian calendar.
#
Date::GREGORIAN: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for Italy and some
# catholic countries.
#
Date::ITALY: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for the proleptic Julian
# calendar.
#
Date::JULIAN: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of full month names in English.  The first element is nil.
#
Date::MONTHNAMES: Array[String?]
%a{annotate:rdoc:skip}
class Time
  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - t.to_time  ->  time
  # -->
  # Returns self.
  #
  def to_time: () -> Time

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - t.to_date  ->  date
  # -->
  # Returns a Date object which denotes self.
  #
  def to_date: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - t.to_datetime  ->  datetime
  # -->
  # Returns a DateTime object which denotes self.
  #
  def to_datetime: () -> DateTime
end
# <!-- rdoc-file=ext/date/date_core.c -->
# ## DateTime
#
# A subclass of Date that easily handles date, hour, minute, second, and offset.
#
# DateTime class is considered deprecated. Use Time class.
#
# DateTime does not consider any leap seconds, does not track any summer time
# rules.
#
# A DateTime object is created with DateTime::new, DateTime::jd,
# DateTime::ordinal, DateTime::commercial, DateTime::parse, DateTime::strptime,
# DateTime::now, Time#to_datetime, etc.
#
#     require 'date'
#
#     DateTime.new(2001,2,3,4,5,6)
#                         #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>
#
# The last element of day, hour, minute, or second can be a fractional number.
# The fractional number's precision is assumed at most nanosecond.
#
#     DateTime.new(2001,2,3.5)
#                         #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>
#
# An optional argument, the offset, indicates the difference between the local
# time and UTC. For example, `Rational(3,24)` represents ahead of 3 hours of
# UTC, `Rational(-5,24)` represents behind of 5 hours of UTC. The offset should
# be -1 to +1, and its precision is assumed at most second. The default value is
# zero (equals to UTC).
#
#     DateTime.new(2001,2,3,4,5,6,Rational(3,24))
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>
#
# The offset also accepts string form:
#
#     DateTime.new(2001,2,3,4,5,6,'+03:00')
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>
#
# An optional argument, the day of calendar reform (`start`), denotes a Julian
# day number, which should be 2298874 to 2426355 or negative/positive infinity.
# The default value is `Date::ITALY` (2299161=1582-10-15).
#
# A DateTime object has various methods. See each reference.
#
#     d = DateTime.parse('3rd Feb 2001 04:05:06+03:30')
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:30 ...>
#     d.hour              #=> 4
#     d.min               #=> 5
#     d.sec               #=> 6
#     d.offset            #=> (7/48)
#     d.zone              #=> "+03:30"
#     d += Rational('1.5')
#                         #=> #<DateTime: 2001-02-04%16:05:06+03:30 ...>
#     d = d.new_offset('+09:00')
#                         #=> #<DateTime: 2001-02-04%21:35:06+09:00 ...>
#     d.strftime('%I:%M:%S %p')
#                         #=> "09:35:06 PM"
#     d > DateTime.new(1999)
#                         #=> true
#
# ### When should you use DateTime and when should you use Time?
#
# It's a common misconception that [William
# Shakespeare](https://en.wikipedia.org/wiki/William_Shakespeare) and [Miguel de
# Cervantes](https://en.wikipedia.org/wiki/Miguel_de_Cervantes) died on the same
# day in history - so much so that UNESCO named April 23 as [World Book Day
# because of this fact](https://en.wikipedia.org/wiki/World_Book_Day). However,
# because England hadn't yet adopted the [Gregorian Calendar
# Reform](https://en.wikipedia.org/wiki/Gregorian_calendar#Gregorian_reform)
# (and wouldn't until
# [1752](https://en.wikipedia.org/wiki/Calendar_(New_Style)_Act_1750)) their
# deaths are actually 10 days apart. Since Ruby's Time class implements a
# [proleptic Gregorian
# calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar) and has
# no concept of calendar reform there's no way to express this with Time
# objects. This is where DateTime steps in:
#
#     shakespeare = DateTime.iso8601('1616-04-23', Date::ENGLAND)
#      #=> Tue, 23 Apr 1616 00:00:00 +0000
#     cervantes = DateTime.iso8601('1616-04-23', Date::ITALY)
#      #=> Sat, 23 Apr 1616 00:00:00 +0000
#
# Already you can see something is weird - the days of the week are different.
# Taking this further:
#
#     cervantes == shakespeare
#      #=> false
#     (shakespeare - cervantes).to_i
#      #=> 10
#
# This shows that in fact they died 10 days apart (in reality 11 days since
# Cervantes died a day earlier but was buried on the 23rd). We can see the
# actual date of Shakespeare's death by using the #gregorian method to convert
# it:
#
#     shakespeare.gregorian
#      #=> Tue, 03 May 1616 00:00:00 +0000
#
# So there's an argument that all the celebrations that take place on the 23rd
# April in Stratford-upon-Avon are actually the wrong date since England is now
# using the Gregorian calendar. You can see why when we transition across the
# reform date boundary:
#
#     # start off with the anniversary of Shakespeare's birth in 1751
#     shakespeare = DateTime.iso8601('1751-04-23', Date::ENGLAND)
#      #=> Tue, 23 Apr 1751 00:00:00 +0000
#
#     # add 366 days since 1752 is a leap year and April 23 is after February 29
#     shakespeare + 366
#      #=> Thu, 23 Apr 1752 00:00:00 +0000
#
#     # add another 365 days to take us to the anniversary in 1753
#     shakespeare + 366 + 365
#      #=> Fri, 04 May 1753 00:00:00 +0000
#
# As you can see, if we're accurately tracking the number of [solar
# years](https://en.wikipedia.org/wiki/Tropical_year) since Shakespeare's
# birthday then the correct anniversary date would be the 4th May and not the
# 23rd April.
#
# So when should you use DateTime in Ruby and when should you use Time? Almost
# certainly you'll want to use Time since your app is probably dealing with
# current dates and times. However, if you need to deal with dates and times in
# a historical context you'll want to use DateTime to avoid making the same
# mistakes as UNESCO. If you also have to deal with timezones then best of luck
# - just bear in mind that you'll probably be dealing with [local solar
# times](https://en.wikipedia.org/wiki/Solar_time), since it wasn't until the
# 19th century that the introduction of the railways necessitated the need for
# [Standard Time](https://en.wikipedia.org/wiki/Standard_time#Great_Britain) and
# eventually timezones.
#
class DateTime < Date
  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - new(*args)
  # -->
  # Same as DateTime.new.
  #
  def initialize: (?Integer year, ?Integer month, ?Integer mday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> void

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime._strptime(string[, format='%FT%T%z'])  ->  hash
  # -->
  # Parses the given representation of date and time with the given template, and
  # returns a hash of parsed elements.  _strptime does not support specification
  # of flags and width unlike strftime.
  #
  # See also strptime(3) and #strftime.
  #
  def self._strptime: (String str, ?String format) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - civil(*args)
  # -->
  # Same as DateTime.new.
  #
  def self.civil: (?Integer year, ?Integer month, ?Integer mday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.commercial([cwyear=-4712[, cweek=1[, cwday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given week date.
  #
  #     DateTime.commercial(2001) #=> #<DateTime: 2001-01-01T00:00:00+00:00 ...>
  #     DateTime.commercial(2002) #=> #<DateTime: 2001-12-31T00:00:00+00:00 ...>
  #     DateTime.commercial(2001,5,6,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def self.commercial: (?Integer cwyear, ?Integer cweek, ?Integer cwday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.httpdate(string='Mon, 01 Jan -4712 00:00:00 GMT'[, start=Date::ITALY])  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some RFC
  # 2616 format.
  #
  #     DateTime.httpdate('Sat, 03 Feb 2001 04:05:06 GMT')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.httpdate: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.iso8601(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical ISO 8601 formats.
  #
  #     DateTime.iso8601('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.iso8601('20010203T040506+0700')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.iso8601('2001-W05-6T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.iso8601: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.jd([jd=0[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given chronological Julian day number.
  #
  #     DateTime.jd(2451944)      #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.jd(2451945)      #=> #<DateTime: 2001-02-04T00:00:00+00:00 ...>
  #     DateTime.jd(Rational('0.5'))
  #                               #=> #<DateTime: -4712-01-01T12:00:00+00:00 ...>
  #
  def self.jd: (?Integer jd, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.jisx0301(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical JIS X 0301 formats.
  #
  #     DateTime.jisx0301('H13.02.03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # For no-era year, legacy format, Heisei is assumed.
  #
  #     DateTime.jisx0301('13.02.03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.jisx0301: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.now([start=Date::ITALY])  ->  datetime
  # -->
  # Creates a DateTime object denoting the present time.
  #
  #     DateTime.now              #=> #<DateTime: 2011-06-11T21:20:44+09:00 ...>
  #
  def self.now: (?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.ordinal([year=-4712[, yday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given ordinal date.
  #
  #     DateTime.ordinal(2001,34) #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.ordinal(2001,34,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.ordinal(2001,-332,-20,-55,-54,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def self.ordinal: (?Integer year, ?Integer yday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.parse(string='-4712-01-01T00:00:00+00:00'[, comp=true[, start=Date::ITALY]], limit: 128)  ->  datetime
  # -->
  # Parses the given representation of date and time, and creates a DateTime
  # object.
  #
  # This method **does** **not** function as a validator.  If the input string
  # does not match valid formats strictly, you may get a cryptic result.  Should
  # consider to use DateTime.strptime instead of this method as possible.
  #
  # If the optional second argument is true and the detected year is in the range
  # "00" to "99", makes it full.
  #
  #     DateTime.parse('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.parse('20010203T040506+0700')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.parse('3rd Feb 2001 04:05:06 PM')
  #                               #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.parse: (String str, ?boolish complete, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  datetime
  #   - DateTime.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 2822 formats.
  #
  #     DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
  #                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc2822: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc3339(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 3339 formats.
  #
  #     DateTime.rfc3339('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc3339: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  datetime
  #   - DateTime.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 2822 formats.
  #
  #     DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
  #                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc822: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.strptime([string='-4712-01-01T00:00:00+00:00'[, format='%FT%T%z'[ ,start=Date::ITALY]]])  ->  datetime
  # -->
  # Parses the given representation of date and time with the given template, and
  # creates a DateTime object.  strptime does not support specification of flags
  # and width unlike strftime.
  #
  #     DateTime.strptime('2001-02-03T04:05:06+07:00', '%Y-%m-%dT%H:%M:%S%z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('03-02-2001 04:05:06 PM', '%d-%m-%Y %I:%M:%S %p')
  #                               #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>
  #     DateTime.strptime('2001-W05-6T04:05:06+07:00', '%G-W%V-%uT%H:%M:%S%z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('2001 04 6 04 05 06 +7', '%Y %U %w %H %M %S %z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('2001 05 6 04 05 06 +7', '%Y %W %u %H %M %S %z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('-1', '%s')
  #                               #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
  #     DateTime.strptime('-1000', '%Q')
  #                               #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
  #     DateTime.strptime('sat3feb014pm+7', '%a%d%b%y%H%p%z')
  #                               #=> #<DateTime: 2001-02-03T16:00:00+07:00 ...>
  #
  # See also strptime(3) and #strftime.
  #
  def self.strptime: (String str, ?String format, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.xmlschema(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical XML Schema formats.
  #
  #     DateTime.xmlschema('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.xmlschema: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - deconstruct_keys(array_of_names_or_nil) -> hash
  # -->
  # Returns a hash of the name/value pairs, to use in pattern matching. Possible
  # keys are: `:year`, `:month`, `:day`, `:wday`, `:yday`, `:hour`, `:min`,
  # `:sec`, `:sec_fraction`, `:zone`.
  #
  # Possible usages:
  #
  #     dt = DateTime.new(2022, 10, 5, 13, 30)
  #
  #     if d in wday: 1..5, hour: 10..18  # uses deconstruct_keys underneath
  #       puts "Working time"
  #     end
  #     #=> prints "Working time"
  #
  #     case dt
  #     in year: ...2022
  #       puts "too old"
  #     in month: ..9
  #       puts "quarter 1-3"
  #     in wday: 1..5, month:
  #       puts "working day in month #{month}"
  #     end
  #     #=> prints "working day in month 10"
  #
  # Note that deconstruction by pattern can also be combined with class check:
  #
  #     if d in DateTime(wday: 1..5, hour: 10..18, day: ..7)
  #       puts "Working time, first week of the month"
  #     end
  #
  def deconstruct_keys: (Array[Symbol]?) -> Hash[Symbol, untyped]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - hour -> integer
  # -->
  # Returns the hour in range (0..23):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6).hour # => 4
  #
  def hour: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.iso8601([n=0])    ->  string
  #   - dt.xmlschema([n=0])  ->  string
  # -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def iso8601: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.jisx0301([n=0])  ->  string
  # -->
  # Returns a string in a JIS X 0301 format. The optional argument `n` is the
  # number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').jisx0301(9)
  #                               #=> "H13.02.03T04:05:06.123456789+07:00"
  #
  def jisx0301: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - min -> integer
  # -->
  # Returns the minute in range (0..59):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6).min # => 5
  #
  def min: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the minute in range (0..59):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6).min # => 5
  #
  def minute: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.new_offset([offset=0])  ->  date
  # -->
  # Duplicates self and resets its offset.
  #
  #     d = DateTime.new(2001,2,3,4,5,6,'-02:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06-02:00 ...>
  #     d.new_offset('+09:00')    #=> #<DateTime: 2001-02-03T15:05:06+09:00 ...>
  #
  def new_offset: (?String offset) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.offset  ->  rational
  # -->
  # Returns the offset.
  #
  #     DateTime.parse('04pm+0730').offset        #=> (5/16)
  #
  def offset: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.rfc3339([n=0])  ->  string
  # -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').rfc3339(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def rfc3339: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - sec -> integer
  # -->
  # Returns the second in range (0..59):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6).sec # => 6
  #
  def sec: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - sec_fraction -> rational
  # -->
  # Returns the fractional part of the second in range (Rational(0,
  # 1)...Rational(1, 1)):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6.5).sec_fraction # => (1/2)
  #
  def sec_fraction: () -> Rational

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the second in range (0..59):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6).sec # => 6
  #
  def second: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the fractional part of the second in range (Rational(0,
  # 1)...Rational(1, 1)):
  #
  #     DateTime.new(2001, 2, 3, 4, 5, 6.5).sec_fraction # => (1/2)
  #
  def second_fraction: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - strftime(format = '%FT%T%:z') -> string
  # -->
  # Returns a string representation of `self`, formatted according the given
  # +format:
  #
  #     DateTime.now.strftime # => "2022-07-01T11:03:19-05:00"
  #
  # For other formats, see [Formats for Dates and
  # Times](rdoc-ref:strftime_formatting.rdoc):
  #
  def strftime: (?String format) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_date  ->  date
  # -->
  # Returns a Date object which denotes self.
  #
  def to_date: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_datetime  ->  self
  # -->
  # Returns self.
  #
  def to_datetime: () -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_s  ->  string
  # -->
  # Returns a string in an ISO 8601 format. (This method doesn't use the expanded
  # representations.)
  #
  #     DateTime.new(2001,2,3,4,5,6,'-7').to_s
  #                              #=> "2001-02-03T04:05:06-07:00"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_time  ->  time
  # -->
  # Returns a Time object which denotes self.
  #
  def to_time: () -> Time

  # <!-- rdoc-file=ext/date/date_core.c -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def xmlschema: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.zone  ->  string
  # -->
  # Returns the timezone.
  #
  #     DateTime.parse('04pm+0730').zone          #=> "+07:30"
  #
  def zone: () -> String
end
# <!-- rdoc-file=lib/delegate.rb -->
# A concrete implementation of Delegator, this class provides the means to
# delegate all supported method calls to the object passed into the constructor
# and even to change the object being delegated to at a later time with
# #__setobj__.
#
#     class User
#       def born_on
#         Date.new(1989, 9, 10)
#       end
#     end
#
#     require 'delegate'
#
#     class UserDecorator < SimpleDelegator
#       def birth_year
#         born_on.year
#       end
#     end
#
#     decorated_user = UserDecorator.new(User.new)
#     decorated_user.birth_year  #=> 1989
#     decorated_user.__getobj__  #=> #<User: ...>
#
# A SimpleDelegator instance can take advantage of the fact that SimpleDelegator
# is a subclass of `Delegator` to call `super` to have methods called on the
# object being delegated to.
#
#     class SuperArray < SimpleDelegator
#       def [](*args)
#         super + 1
#       end
#     end
#
#     SuperArray.new([1])[0]  #=> 2
#
# Here's a simple example that takes advantage of the fact that
# SimpleDelegator's delegation object can be changed at any time.
#
#     class Stats
#       def initialize
#         @source = SimpleDelegator.new([])
#       end
#
#       def stats(records)
#         @source.__setobj__(records)
#
#         "Elements:  #{@source.size}\n" +
#         " Non-Nil:  #{@source.compact.size}\n" +
#         "  Unique:  #{@source.uniq.size}\n"
#       end
#     end
#
#     s = Stats.new
#     puts s.stats(%w{James Edward Gray II})
#     puts
#     puts s.stats([1, 2, 3, nil, 4, 5, 1, 2])
#
# Prints:
#
#     Elements:  4
#      Non-Nil:  4
#       Unique:  4
#
#     Elements:  8
#      Non-Nil:  7
#       Unique:  6
#
class SimpleDelegator < Delegator
  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - __getobj__() { || ... }
  # -->
  # Returns the current object method calls are being delegated to.
  #
  def __getobj__: () -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - __setobj__(obj)
  # -->
  # Changes the delegate object to *obj*.
  #
  # It's important to note that this does **not** cause SimpleDelegator's methods
  # to change.  Because of this, you probably only want to change delegation to
  # objects of the same type as the original delegate.
  #
  # Here's an example of changing the delegation object.
  #
  #     names = SimpleDelegator.new(%w{James Edward Gray II})
  #     puts names[1]    # => Edward
  #     names.__setobj__(%w{Gavin Sinclair})
  #     puts names[1]    # => Sinclair
  #
  def __setobj__: (untyped obj) -> untyped
end
# <!-- rdoc-file=lib/delegate.rb -->
# This library provides three different ways to delegate method calls to an
# object.  The easiest to use is SimpleDelegator.  Pass an object to the
# constructor and all methods supported by the object will be delegated.  This
# object can be changed later.
#
# Going a step further, the top level DelegateClass method allows you to easily
# setup delegation through class inheritance.  This is considerably more
# flexible and thus probably the most common use for this library.
#
# Finally, if you need full control over the delegation scheme, you can inherit
# from the abstract class Delegator and customize as needed.  (If you find
# yourself needing this control, have a look at Forwardable which is also in the
# standard library.  It may suit your needs better.)
#
# SimpleDelegator's implementation serves as a nice example of the use of
# Delegator:
#
#     require 'delegate'
#
#     class SimpleDelegator < Delegator
#       def __getobj__
#         @delegate_sd_obj # return object we are delegating to, required
#       end
#
#       def __setobj__(obj)
#         @delegate_sd_obj = obj # change delegation object,
#                                # a feature we're providing
#       end
#     end
#
# ## Notes
#
# Be advised, RDoc will not detect delegated methods.
#
class Delegator < BasicObject
  def self.const_missing: (Symbol n) -> untyped

  def self.delegating_block: (Symbol mid) -> Proc

  def self.public_api: () -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - !()
  # -->
  # Delegates ! to the _*getobj*_
  #
  def !: () -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - !=(obj)
  # -->
  # Returns true if two objects are not considered of equal value.
  #
  def !=: (untyped obj) -> bool

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - ==(obj)
  # -->
  # Returns true if two objects are considered of equal value.
  #
  def ==: (untyped obj) -> bool

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - __getobj__()
  # -->
  # This method must be overridden by subclasses and should return the object
  # method calls are being delegated to.
  #
  def __getobj__: () -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - __setobj__(obj)
  # -->
  # This method must be overridden by subclasses and change the object delegate to
  # *obj*.
  #
  def __setobj__: (untyped obj) -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - eql?(obj)
  # -->
  # Returns true if two objects are considered of equal value.
  #
  def eql?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - freeze()
  # -->
  # :method: freeze Freeze both the object returned by _*getobj*_ and self.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - marshal_dump()
  # -->
  # Serialization support for the object returned by _*getobj*_.
  #
  def marshal_dump: () -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - marshal_load(data)
  # -->
  # Reinitializes delegation from a serialized object.
  #
  def marshal_load: (untyped data) -> void

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - method_missing(m, *args, &block)
  # -->
  #
  def method_missing: (Symbol m, *untyped args, **untyped) { (*untyped, **untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - methods(all=true)
  # -->
  # Returns the methods available to this delegate object as the union of this
  # object's and _*getobj*_ methods.
  #
  def methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - protected_methods(all=true)
  # -->
  # Returns the methods available to this delegate object as the union of this
  # object's and _*getobj*_ protected methods.
  #
  def protected_methods: (?boolish all) -> Array[Symbol]

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - public_methods(all=true)
  # -->
  # Returns the methods available to this delegate object as the union of this
  # object's and _*getobj*_ public methods.
  #
  def public_methods: (?untyped all) -> Array[Symbol]

  private

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - new(obj)
  # -->
  # Pass in the *obj* to delegate method calls to.  All methods supported by *obj*
  # will be delegated to.
  #
  def initialize: (untyped obj) -> void

  def initialize_clone: (self obj, ?freeze: bool?) -> self

  def initialize_dup: (self obj) -> self

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - respond_to_missing?(m, include_private)
  # -->
  # Checks for a method provided by this the delegate object by forwarding the
  # call through _*getobj*_.
  #
  def respond_to_missing?: (Symbol m, bool include_private) -> bool

  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - target_respond_to?(target, m, include_private)
  # -->
  # Handle BasicObject instances
  #
  def target_respond_to?: (untyped target, Symbol m, bool include_private) -> bool

  VERSION: String
end
%a{annotate:rdoc:skip}
class Object
  # <!--
  #   rdoc-file=lib/delegate.rb
  #   - DelegateClass(superclass, &block)
  # -->
  # The primary interface to this library.  Use to setup delegation when defining
  # your class.
  #
  #     class MyClass < DelegateClass(ClassToDelegateTo) # Step 1
  #       def initialize
  #         super(obj_of_ClassToDelegateTo)              # Step 2
  #       end
  #     end
  #
  # or:
  #
  #     MyClass = DelegateClass(ClassToDelegateTo) do    # Step 1
  #       def initialize
  #         super(obj_of_ClassToDelegateTo)              # Step 2
  #       end
  #     end
  #
  # Here's a sample of use from Tempfile which is really a File object with a few
  # special rules about storage location and when the File should be deleted.
  # That makes for an almost textbook perfect example of how to use delegation.
  #
  #     class Tempfile < DelegateClass(File)
  #       # constant and class member data initialization...
  #
  #       def initialize(basename, tmpdir=Dir::tmpdir)
  #         # build up file path/name in var tmpname...
  #
  #         @tmpfile = File.open(tmpname, File::RDWR|File::CREAT|File::EXCL, 0600)
  #
  #         # ...
  #
  #         super(@tmpfile)
  #
  #         # below this point, all methods of File are supported...
  #       end
  #
  #       # ...
  #     end
  #
  def DelegateClass: (Class) -> Class
end
# <!-- rdoc-file=lib/did_you_mean.rb -->
# The `DidYouMean` gem adds functionality to suggest possible method/class names
# upon errors such as `NameError` and `NoMethodError`. In Ruby 2.3 or later, it
# is automatically activated during startup.
#
# @example
#
#     methosd
#     # => NameError: undefined local variable or method `methosd' for main:Object
#     #   Did you mean?  methods
#     #                  method
#
#     OBject
#     # => NameError: uninitialized constant OBject
#     #    Did you mean?  Object
#
#     @full_name = "Yuki Nishijima"
#     first_name, last_name = full_name.split(" ")
#     # => NameError: undefined local variable or method `full_name' for main:Object
#     #    Did you mean?  @full_name
#
#     @@full_name = "Yuki Nishijima"
#     @@full_anme
#     # => NameError: uninitialized class variable @@full_anme in Object
#     #    Did you mean?  @@full_name
#
#     full_name = "Yuki Nishijima"
#     full_name.starts_with?("Y")
#     # => NoMethodError: undefined method `starts_with?' for "Yuki Nishijima":String
#     #    Did you mean?  start_with?
#
#     hash = {foo: 1, bar: 2, baz: 3}
#     hash.fetch(:fooo)
#     # => KeyError: key not found: :fooo
#     #    Did you mean?  :foo
#
# ## Disabling `did_you_mean`
#
# Occasionally, you may want to disable the `did_you_mean` gem for e.g.
# debugging issues in the error object itself. You can disable it entirely by
# specifying `--disable-did_you_mean` option to the `ruby` command:
#
#     $ ruby --disable-did_you_mean -e "1.zeor?"
#     -e:1:in `<main>': undefined method `zeor?' for 1:Integer (NameError)
#
# When you do not have direct access to the `ruby` command (e.g. +rails
# console+, `irb`), you could applyoptions using the `RUBYOPT` environment
# variable:
#
#     $ RUBYOPT='--disable-did_you_mean' irb
#     irb:0> 1.zeor?
#     # => NoMethodError (undefined method `zeor?' for 1:Integer)
#
# ## Getting the original error message
#
# Sometimes, you do not want to disable the gem entirely, but need to get the
# original error message without suggestions (e.g. testing). In this case, you
# could use the `#original_message` method on the error object:
#
#     no_method_error = begin
#                         1.zeor?
#                       rescue NoMethodError => error
#                         error
#                       end
#
#     no_method_error.message
#     # => NoMethodError (undefined method `zeor?' for 1:Integer)
#     #    Did you mean?  zero?
#
#     no_method_error.original_message
#     # => NoMethodError (undefined method `zeor?' for 1:Integer)
#
module DidYouMean
  NameErrorCheckers: Object

  VERSION: String

  class ClassNameChecker
    class ClassName < ::String
    end
  end

  module Correctable
    SKIP_TO_S_FOR_SUPER_LOOKUP: true

    # <!--
    #   rdoc-file=lib/did_you_mean/core_ext/name_error.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[String]
  end

  # <!-- rdoc-file=lib/did_you_mean/formatter.rb -->
  # The `DidYouMean::Formatter` is the basic, default formatter for the gem. The
  # formatter responds to the `message_for` method and it returns a human readable
  # string.
  #
  class Formatter
    # <!--
    #   rdoc-file=lib/did_you_mean/formatter.rb
    #   - message_for(corrections)
    # -->
    # Returns a human readable string that contains `corrections`. This formatter is
    # designed to be less verbose to not take too much screen space while being
    # helpful enough to the user.
    #
    # @example
    #
    #     formatter = DidYouMean::Formatter.new
    #
    #     # displays suggestions in two lines with the leading empty line
    #     puts formatter.message_for(["methods", "method"])
    #
    #     Did you mean?  methods
    #                     method
    #     # => nil
    #
    #     # displays an empty line
    #     puts formatter.message_for([])
    #
    #     # => nil
    #
    def self.message_for: (Array[String] corrections) -> String
  end

  module JaroWinkler
    WEIGHT: Float

    THRESHOLD: Float

    # <!--
    #   rdoc-file=lib/did_you_mean/jaro_winkler.rb
    #   - distance(str1, str2)
    # -->
    #
    def self?.distance: (String, String) -> Integer
  end

  module Jaro
    # <!--
    #   rdoc-file=lib/did_you_mean/jaro_winkler.rb
    #   - distance(str1, str2)
    # -->
    #
    def self?.distance: (String, String) -> Integer
  end

  class KeyErrorChecker
    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/key_error_checker.rb
    #   - new(key_error)
    # -->
    #
    def initialize: (KeyError[_ToS, Hash[_ToS, untyped]]) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/key_error_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[String]
  end

  module Levenshtein
    def self?.distance: (String, String) -> Integer?
  end

  class MethodNameChecker
    NAMES_TO_EXCLUDE: Hash[untyped, Array[Symbol]]

    # <!-- rdoc-file=lib/did_you_mean/spell_checkers/method_name_checker.rb -->
    # `MethodNameChecker::RB_RESERVED_WORDS` is the list of reserved words in Ruby
    # that take an argument. Unlike `VariableNameChecker::RB_RESERVED_WORDS`, these
    # reserved words require an argument, and a `NoMethodError` is raised due to the
    # presence of the argument.
    #
    # The `MethodNameChecker` will use this list to suggest a reversed word if a
    # `NoMethodError` is raised and found closest matches.
    #
    # Also see `VariableNameChecker::RB_RESERVED_WORDS`.
    #
    RB_RESERVED_WORDS: Array[Symbol]

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/method_name_checker.rb
    #   - new(exception)
    # -->
    #
    def initialize: (NoMethodError[untyped] exception) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/method_name_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[Symbol]
  end

  class NullChecker
    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/null_checker.rb
    #   - new(*)
    # -->
    #
    def initialize: (*untyped) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/null_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[untyped]
  end

  class PatternKeyNameChecker
    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/pattern_key_name_checker.rb
    #   - new(no_matching_pattern_key_error)
    # -->
    #
    def initialize: (untyped) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/pattern_key_name_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[String]
  end

  class RequirePathChecker
    INITIAL_LOAD_PATH: Array[String]
    ENV_SPECIFIC_EXT: String

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/require_path_checker.rb
    #   - requireables()
    # -->
    #
    def self.requireables: () -> Array[String]

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/require_path_checker.rb
    #   - new(exception)
    # -->
    #
    def initialize: (untyped exception) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/require_path_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[String]
  end

  class SpellChecker
    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checker.rb
    #   - new(dictionary:)
    # -->
    #
    def initialize: (dictionary: Array[interned]) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checker.rb
    #   - correct(input)
    # -->
    #
    def correct: (interned input) -> Array[String]
  end

  # <!-- rdoc-file=lib/did_you_mean/tree_spell_checker.rb -->
  # spell checker for a dictionary that has a tree structure, see
  # doc/tree_spell_checker_api.md
  #
  class TreeSpellChecker
    # <!--
    #   rdoc-file=lib/did_you_mean/tree_spell_checker.rb
    #   - new(dictionary:, separator: '/', augment: nil)
    # -->
    #
    def initialize: (dictionary: Array[String], ?separator: String, ?augment: bool?) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/tree_spell_checker.rb
    #   - correct(input)
    # -->
    #
    def correct: (String input) -> Array[String]
  end

  class VariableNameChecker
    NAMES_TO_EXCLUDE: Hash[String, Array[Symbol]]

    # <!-- rdoc-file=lib/did_you_mean/spell_checkers/name_error_checkers/variable_name_checker.rb -->
    # `VariableNameChecker::RB_RESERVED_WORDS` is the list of all reserved words in
    # Ruby. They could be declared like methods are, and a typo would cause Ruby to
    # raise a `NameError` because of the way they are declared.
    #
    # The `:VariableNameChecker` will use this list to suggest a reversed word if a
    # `NameError` is raised and found closest matches, excluding:
    #
    #     * +do+
    #     * +if+
    #     * +in+
    #     * +or+
    #
    # Also see `MethodNameChecker::RB_RESERVED_WORDS`.
    #
    RB_RESERVED_WORDS: Array[Symbol]

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/name_error_checkers/variable_name_checker.rb
    #   - new(exception)
    # -->
    #
    def initialize: (NameError[untyped]) -> void

    # <!--
    #   rdoc-file=lib/did_you_mean/spell_checkers/name_error_checkers/variable_name_checker.rb
    #   - corrections()
    # -->
    #
    def corrections: () -> Array[Symbol]
  end
end

%a{annotate:rdoc:skip}
class NameError[T]
# prepend DidYouMean::Correctable
end

%a{annotate:rdoc:skip}
class KeyError[K, R]
# prepend DidYouMean::Correctable
end

%a{annotate:rdoc:skip}
class LoadError
# prepend DidYouMean::Correctable
end
# <!-- rdoc-file=ext/digest/digest.c -->
# This module provides a framework for message digest libraries.
#
# You may want to look at OpenSSL::Digest as it supports more algorithms.
#
# A cryptographic hash function is a procedure that takes data and returns a
# fixed bit string: the hash value, also known as *digest*. Hash functions are
# also called one-way functions, it is easy to compute a digest from a message,
# but it is infeasible to generate a message from a digest.
#
# ## Examples
#
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::SHA256.digest 'message'       #=> "\xABS\n\x13\xE4Y..."
#
#     sha256 = Digest::SHA256.new
#     sha256.digest 'message'               #=> "\xABS\n\x13\xE4Y..."
#
#     # Other encoding formats
#     Digest::SHA256.hexdigest 'message'    #=> "ab530a13e459..."
#     Digest::SHA256.base64digest 'message' #=> "q1MKE+RZFJgr..."
#
#     # Compute digest by chunks
#     md5 = Digest::MD5.new
#     md5.update 'message1'
#     md5 << 'message2'                     # << is an alias for update
#
#     md5.hexdigest                         #=> "94af09c09bb9..."
#
#     # Compute digest for a file
#     sha256 = Digest::SHA256.file 'testfile'
#     sha256.hexdigest
#
# Additionally digests can be encoded in "bubble babble" format as a sequence of
# consonants and vowels which is more recognizable and comparable than a
# hexadecimal digest.
#
#     require 'digest/bubblebabble'
#
#     Digest::SHA256.bubblebabble 'message' #=> "xopoh-fedac-fenyh-..."
#
# See the bubble babble specification at
# http://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt
# .
#
# ## Digest algorithms
#
# Different digest algorithms (or hash functions) are available:
#
# MD5
# :   See RFC 1321 The MD5 Message-Digest Algorithm
#
# RIPEMD-160
# :   As Digest::RMD160. See
#     http://homes.esat.kuleuven.be/~bosselae/ripemd160.html.
#
# SHA1
# :   See FIPS 180 Secure Hash Standard.
#
# SHA2 family
# :   See FIPS 180 Secure Hash Standard which defines the following algorithms:
#     *   SHA512
#     *   SHA384
#     *   SHA256
#
#
# The latest versions of the FIPS publications can be found here:
# http://csrc.nist.gov/publications/PubsFIPS.html.
#
module Digest
  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - Digest.bubblebabble(string) -> bubblebabble_string
  # -->
  # Returns a BubbleBabble encoded version of a given *string*.
  #
  def self.bubblebabble: (string) -> String

  def self.const_missing: (Symbol name) -> singleton(::Digest::Base)

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest.hexencode(string) -> hexencoded_string
  # -->
  # Generates a hex-encoded version of a given *string*.
  #
  def self.hexencode: (string) -> String

  private

  def bubblebabble: (string) -> String

  def hexencode: (string) -> String
end

# <!-- rdoc-file=ext/digest/lib/digest.rb -->
# A mutex for Digest().
#
Digest::REQUIRE_MUTEX: Thread::Mutex

# <!-- rdoc-file=ext/digest/digest.c -->
# This module provides instance methods for a digest implementation object to
# calculate message digest values.
#
module Digest::Instance
  # <!-- rdoc-file=ext/digest/digest.c -->
  # Updates the digest using a given *string* and returns self.
  #
  # The update() method and the left-shift operator are overridden by each
  # implementation subclass. (One should be an alias for the other)
  #
  def <<: (string) -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj == another_digest_obj -> boolean
  #   - digest_obj == string -> boolean
  # -->
  # If a string is given, checks whether it is equal to the hex-encoded hash value
  # of the digest object.  If another digest instance is given, checks whether
  # they have the same hash value.  Otherwise returns false.
  #
  def ==: (instance | string) -> bool

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest(str = nil)
  # -->
  # If none is given, returns the resulting hash value of the digest in a base64
  # encoded form, keeping the digest's state.
  #
  # If a `string` is given, returns the hash value for the given `string` in a
  # base64 encoded form, resetting the digest to the initial state before and
  # after the process.
  #
  # In either case, the return value is properly padded with '=' and contains no
  # line feeds.
  #
  def base64digest: (?string? str) -> String

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest!()
  # -->
  # Returns the resulting hash value and resets the digest to the initial state.
  #
  def base64digest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.block_length -> integer
  # -->
  # Returns the block length of the digest.
  #
  # This method is overridden by each implementation subclass.
  #
  def block_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - digest_obj.bubblebabble -> hash_string
  # -->
  # Returns the resulting hash value in a Bubblebabble encoded form.
  #
  def bubblebabble: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest -> string
  #   - digest_obj.digest(string) -> string
  # -->
  # If none is given, returns the resulting hash value of the digest, keeping the
  # digest's state.
  #
  # If a *string* is given, returns the hash value for the given *string*,
  # resetting the digest to the initial state before and after the process.
  #
  def digest: (?string) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest! -> string
  # -->
  # Returns the resulting hash value and resets the digest to the initial state.
  #
  def digest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest_length -> integer
  # -->
  # Returns the length of the hash value of the digest.
  #
  # This method should be overridden by each implementation subclass. If not,
  # digest_obj.digest().length() is returned.
  #
  def digest_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - file(name)
  # -->
  # Updates the digest with the contents of a given file *name* and returns self.
  #
  def file: (string name) -> instance

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.hexdigest -> string
  #   - digest_obj.hexdigest(string) -> string
  # -->
  # If none is given, returns the resulting hash value of the digest in a
  # hex-encoded form, keeping the digest's state.
  #
  # If a *string* is given, returns the hash value for the given *string* in a
  # hex-encoded form, resetting the digest to the initial state before and after
  # the process.
  #
  def hexdigest: (?string) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.hexdigest! -> string
  # -->
  # Returns the resulting hash value in a hex-encoded form and resets the digest
  # to the initial state.
  #
  def hexdigest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.inspect -> string
  # -->
  # Creates a printable version of the digest object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.length -> integer
  #   - digest_obj.size -> integer
  # -->
  # Returns digest_obj.digest_length().
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.new -> another_digest_obj
  # -->
  # Returns a new, initialized copy of the digest object.  Equivalent to
  # digest_obj.clone().reset().
  #
  def new: () -> instance

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.reset -> digest_obj
  # -->
  # Resets the digest to the initial state and returns self.
  #
  # This method is overridden by each implementation subclass.
  #
  def reset: () -> self

  # <!-- rdoc-file=ext/digest/digest.c -->
  # Returns digest_obj.digest_length().
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.to_s -> string
  # -->
  # Returns digest_obj.hexdigest().
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.update(string) -> digest_obj
  #   - digest_obj << string -> digest_obj
  # -->
  # Updates the digest using a given *string* and returns self.
  #
  # The update() method and the left-shift operator are overridden by each
  # implementation subclass. (One should be an alias for the other)
  #
  def update: (string) -> self

  private

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.instance_eval { finish } -> digest_obj
  # -->
  # Finishes the digest and returns the resulting hash value.
  #
  # This method is overridden by each implementation subclass and often made
  # private, because some of those subclasses may leave internal data
  # uninitialized.  Do not call this method from outside.  Use #digest!() instead,
  # which ensures that internal data be reset for security reasons.
  #
  def finish: () -> self
end

# <!-- rdoc-file=ext/digest/digest.c -->
# This module stands as a base class for digest implementation classes.
#
class Digest::Class
  include ::Digest::Instance

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest(str, *args)
  # -->
  # Returns the base64 encoded hash value of a given *string*.  The return value
  # is properly padded with '=' and contains no line feeds.
  #
  def self.base64digest: (string str) -> String

  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - Digest::Class.bubblebabble(string, ...) -> hash_string
  # -->
  # Returns the BubbleBabble encoded hash value of a given *string*.
  #
  def self.bubblebabble: (string) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest::Class.digest(string, *parameters) -> hash_string
  # -->
  # Returns the hash value of a given *string*.  This is equivalent to
  # Digest::Class.new(*parameters).digest(string), where extra *parameters*, if
  # any, are passed through to the constructor and the *string* is passed to
  # #digest().
  #
  def self.digest: (string) -> String

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - file(name, *args)
  # -->
  # Creates a digest object and reads a given file, *name*. Optional arguments are
  # passed to the constructor of the digest class.
  #
  #     p Digest::SHA256.file("X11R6.8.2-src.tar.bz2").hexdigest
  #     # => "f02e3c85572dc9ad7cb77c2a638e3be24cc1b5bea9fdbb0b0299c9668475c534"
  #
  def self.file: (string name) -> instance

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest::Class.hexdigest(string[, ...]) -> hash_string
  # -->
  # Returns the hex-encoded hash value of a given *string*.  This is almost
  # equivalent to Digest.hexencode(Digest::Class.new(*parameters).digest(string)).
  #
  def self.hexdigest: (string) -> String

  private

  def initialize: () -> void
end

# <!-- rdoc-file=ext/digest/digest.c -->
# This abstract class provides a common interface to message digest
# implementation classes written in C.
#
# ## Write a Digest subclass in C
# Digest::Base provides a common interface to message digest classes written in
# C. These classes must provide a struct of type rb_digest_metadata_t:
#     typedef int (*rb_digest_hash_init_func_t)(void *);
#     typedef void (*rb_digest_hash_update_func_t)(void *, unsigned char *, size_t);
#     typedef int (*rb_digest_hash_finish_func_t)(void *, unsigned char *);
#
#     typedef struct {
#       int api_version;
#       size_t digest_len;
#       size_t block_len;
#       size_t ctx_size;
#       rb_digest_hash_init_func_t init_func;
#       rb_digest_hash_update_func_t update_func;
#       rb_digest_hash_finish_func_t finish_func;
#     } rb_digest_metadata_t;
#
# This structure must be set as an instance variable named `metadata` (without
# the +@+ in front of the name). By example:
#      static const rb_digest_metadata_t sha1 = {
#         RUBY_DIGEST_API_VERSION,
#         SHA1_DIGEST_LENGTH,
#         SHA1_BLOCK_LENGTH,
#         sizeof(SHA1_CTX),
#         (rb_digest_hash_init_func_t)SHA1_Init,
#         (rb_digest_hash_update_func_t)SHA1_Update,
#         (rb_digest_hash_finish_func_t)SHA1_Finish,
#     };
#
#     rb_ivar_set(cDigest_SHA1, rb_intern("metadata"),
#                 rb_digest_make_metadata(&sha1));
#
class Digest::Base < Digest::Class
  # <!-- rdoc-file=ext/digest/digest.c -->
  # Update the digest using given *string* and return `self`.
  #
  def <<: (string) -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.block_length -> Integer
  # -->
  # Return the block length of the digest in bytes.
  #
  def block_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.digest_length -> Integer
  # -->
  # Return the length of the hash value in bytes.
  #
  def digest_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.reset -> digest_base
  # -->
  # Reset the digest to its initial state and return `self`.
  #
  def reset: () -> self

  %a{annotate:rdoc:skip}
  alias update <<

  private

  def finish: () -> String

  def initialize_copy: (self) -> self
end

# <!-- rdoc-file=ext/digest/sha1/sha1init.c -->
# A class for calculating message digests using the SHA-1 Secure Hash Algorithm
# by NIST (the US' National Institute of Standards and Technology), described in
# FIPS PUB 180-1.
#
# See Digest::Instance for digest API.
#
# SHA-1 calculates a digest of 160 bits (20 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::SHA1.hexdigest 'abc'      #=> "a9993e36..."
#
#     # Compute digest by chunks
#     sha1 = Digest::SHA1.new               # =>#<Digest::SHA1>
#     sha1.update "ab"
#     sha1 << "c"                           # alias for #update
#     sha1.hexdigest                        # => "a9993e36..."
#
#     # Use the same object to compute another digest
#     sha1.reset
#     sha1 << "message"
#     sha1.hexdigest                        # => "6f9b9af3..."
#
class Digest::SHA1 < Digest::Base
end

# <!-- rdoc-file=ext/digest/md5/md5init.c -->
# A class for calculating message digests using the MD5 Message-Digest Algorithm
# by RSA Data Security, Inc., described in RFC1321.
#
# MD5 calculates a digest of 128 bits (16 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::MD5.hexdigest 'abc'      #=> "90015098..."
#
#     # Compute digest by chunks
#     md5 = Digest::MD5.new               # =>#<Digest::MD5>
#     md5.update "ab"
#     md5 << "c"                           # alias for #update
#     md5.hexdigest                        # => "90015098..."
#
#     # Use the same object to compute another digest
#     md5.reset
#     md5 << "message"
#     md5.hexdigest                        # => "78e73102..."
#
class Digest::MD5 < Digest::Base
end

# <!-- rdoc-file=ext/digest/rmd160/rmd160init.c -->
# A class for calculating message digests using RIPEMD-160 cryptographic hash
# function, designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.
#
# RMD160 calculates a digest of 160 bits (20 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::RMD160.hexdigest 'abc'      #=> "8eb208f7..."
#
#     # Compute digest by chunks
#     rmd160 = Digest::RMD160.new               # =>#<Digest::RMD160>
#     rmd160.update "ab"
#     rmd160 << "c"                           # alias for #update
#     rmd160.hexdigest                        # => "8eb208f7..."
#
#     # Use the same object to compute another digest
#     rmd160.reset
#     rmd160 << "message"
#     rmd160.hexdigest                        # => "1dddbe1b..."
#
class Digest::RMD160 < Digest::Base
end

# <!-- rdoc-file=ext/digest/sha2/sha2init.c -->
# Classes for calculating message digests using the SHA-256/384/512 Secure Hash
# Algorithm(s) by NIST (the US' National Institute of Standards and Technology),
# described in FIPS PUB 180-2.
#
# See SHA2.
#
class Digest::SHA256 < Digest::Base
end

# <!-- rdoc-file=ext/digest/sha2/sha2init.c -->
# Classes for calculating message digests using the SHA-256/384/512 Secure Hash
# Algorithm(s) by NIST (the US' National Institute of Standards and Technology),
# described in FIPS PUB 180-2.
#
# See SHA2.
#
class Digest::SHA384 < Digest::Base
end

# <!-- rdoc-file=ext/digest/sha2/sha2init.c -->
# Classes for calculating message digests using the SHA-256/384/512 Secure Hash
# Algorithm(s) by NIST (the US' National Institute of Standards and Technology),
# described in FIPS PUB 180-2.
#
# See SHA2.
#
class Digest::SHA512 < Digest::Base
end

%a{annotate:rdoc:skip}
class Object
  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - Digest(name) -> digest_subclass
  # -->
  # Returns a Digest subclass by `name` in a thread-safe manner even when
  # on-demand loading is involved.
  #
  #     require 'digest'
  #
  #     Digest("MD5")
  #     # => Digest::MD5
  #
  #     Digest(:SHA256)
  #     # => Digest::SHA256
  #
  #     Digest(:Foo)
  #     # => LoadError: library not found for class Digest::Foo -- digest/foo
  #
  def Digest: (interned name) -> singleton(::Digest::Base)
end
# <!-- rdoc-file=lib/erb.rb -->
# # ERB -- Ruby Templating
#
# ## Introduction
#
# ERB provides an easy to use but powerful templating system for Ruby.  Using
# ERB, actual Ruby code can be added to any plain text document for the purposes
# of generating document information details and/or flow control.
#
# A very simple example is this:
#
#     require 'erb'
#
#     x = 42
#     template = ERB.new <<-EOF
#       The value of x is: <%= x %>
#     EOF
#     puts template.result(binding)
#
# *Prints:* The value of x is: 42
#
# More complex examples are given below.
#
# ## Recognized Tags
#
# ERB recognizes certain tags in the provided template and converts them based
# on the rules below:
#
#     <% Ruby code -- inline with output %>
#     <%= Ruby expression -- replace with result %>
#     <%# comment -- ignored -- useful in testing %> (`<% #` doesn't work. Don't use Ruby comments.)
#     % a line of Ruby code -- treated as <% line %> (optional -- see ERB.new)
#     %% replaced with % if first thing on a line and % processing is used
#     <%% or %%> -- replace with <% or %> respectively
#
# All other text is passed through ERB filtering unchanged.
#
# ## Options
#
# There are several settings you can change when you use ERB:
# *   the nature of the tags that are recognized;
# *   the binding used to resolve local variables in the template.
#
# See the ERB.new and ERB#result methods for more detail.
#
# ## Character encodings
#
# ERB (or Ruby code generated by ERB) returns a string in the same character
# encoding as the input string.  When the input string has a magic comment,
# however, it returns a string in the encoding specified by the magic comment.
#
#     # -*- coding: utf-8 -*-
#     require 'erb'
#
#     template = ERB.new <<EOF
#     <%#-*- coding: Big5 -*-%>
#       \_\_ENCODING\_\_ is <%= \_\_ENCODING\_\_ %>.
#     EOF
#     puts template.result
#
# *Prints:* _*ENCODING*_ is Big5.
#
# ## Examples
#
# ### Plain Text
#
# ERB is useful for any generic templating situation.  Note that in this
# example, we use the convenient "% at start of line" tag, and we quote the
# template literally with `%q{...}` to avoid trouble with the backslash.
#
#     require "erb"
#
#     # Create template.
#     template = %q{
#       From:  James Edward Gray II <james@grayproductions.net>
#       To:  <%= to %>
#       Subject:  Addressing Needs
#
#       <%= to[/\w+/] %>:
#
#       Just wanted to send a quick note assuring that your needs are being
#       addressed.
#
#       I want you to know that my team will keep working on the issues,
#       especially:
#
#       <%# ignore numerous minor requests -- focus on priorities %>
#       % priorities.each do |priority|
#         * <%= priority %>
#       % end
#
#       Thanks for your patience.
#
#       James Edward Gray II
#     }.gsub(/^  /, '')
#
#     message = ERB.new(template, trim_mode: "%<>")
#
#     # Set up template data.
#     to = "Community Spokesman <spokesman@ruby_community.org>"
#     priorities = [ "Run Ruby Quiz",
#                    "Document Modules",
#                    "Answer Questions on Ruby Talk" ]
#
#     # Produce result.
#     email = message.result
#     puts email
#
# *Generates:*
#
#     From:  James Edward Gray II <james@grayproductions.net>
#     To:  Community Spokesman <spokesman@ruby_community.org>
#     Subject:  Addressing Needs
#
#     Community:
#
#     Just wanted to send a quick note assuring that your needs are being addressed.
#
#     I want you to know that my team will keep working on the issues, especially:
#
#         * Run Ruby Quiz
#         * Document Modules
#         * Answer Questions on Ruby Talk
#
#     Thanks for your patience.
#
#     James Edward Gray II
#
# ### Ruby in HTML
#
# ERB is often used in `.rhtml` files (HTML with embedded Ruby).  Notice the
# need in this example to provide a special binding when the template is run, so
# that the instance variables in the Product object can be resolved.
#
#     require "erb"
#
#     # Build template data class.
#     class Product
#       def initialize( code, name, desc, cost )
#         @code = code
#         @name = name
#         @desc = desc
#         @cost = cost
#
#         @features = [ ]
#       end
#
#       def add_feature( feature )
#         @features << feature
#       end
#
#       # Support templating of member data.
#       def get_binding
#         binding
#       end
#
#       # ...
#     end
#
#     # Create template.
#     template = %{
#       <html>
#         <head><title>Ruby Toys -- <%= @name %></title></head>
#         <body>
#
#           <h1><%= @name %> (<%= @code %>)</h1>
#           <p><%= @desc %></p>
#
#           <ul>
#             <% @features.each do |f| %>
#               <li><b><%= f %></b></li>
#             <% end %>
#           </ul>
#
#           <p>
#             <% if @cost < 10 %>
#               <b>Only <%= @cost %>!!!</b>
#             <% else %>
#                Call for a price, today!
#             <% end %>
#           </p>
#
#         </body>
#       </html>
#     }.gsub(/^  /, '')
#
#     rhtml = ERB.new(template)
#
#     # Set up template data.
#     toy = Product.new( "TZ-1002",
#                        "Rubysapien",
#                        "Geek's Best Friend!  Responds to Ruby commands...",
#                        999.95 )
#     toy.add_feature("Listens for verbal commands in the Ruby language!")
#     toy.add_feature("Ignores Perl, Java, and all C variants.")
#     toy.add_feature("Karate-Chop Action!!!")
#     toy.add_feature("Matz signature on left leg.")
#     toy.add_feature("Gem studded eyes... Rubies, of course!")
#
#     # Produce result.
#     rhtml.run(toy.get_binding)
#
# *Generates (some blank lines removed):*
#
#     <html>
#       <head><title>Ruby Toys -- Rubysapien</title></head>
#       <body>
#
#         <h1>Rubysapien (TZ-1002)</h1>
#         <p>Geek's Best Friend!  Responds to Ruby commands...</p>
#
#         <ul>
#             <li><b>Listens for verbal commands in the Ruby language!</b></li>
#             <li><b>Ignores Perl, Java, and all C variants.</b></li>
#             <li><b>Karate-Chop Action!!!</b></li>
#             <li><b>Matz signature on left leg.</b></li>
#             <li><b>Gem studded eyes... Rubies, of course!</b></li>
#         </ul>
#
#         <p>
#              Call for a price, today!
#         </p>
#
#       </body>
#     </html>
#
# ## Notes
#
# There are a variety of templating solutions available in various Ruby
# projects. For example, RDoc, distributed with Ruby, uses its own template
# engine, which can be reused elsewhere.
#
# Other popular engines could be found in the corresponding
# [Category](https://www.ruby-toolbox.com/categories/template_engines) of The
# Ruby Toolbox.
#
class ERB
  # <!--
  #   rdoc-file=lib/erb.rb
  #   - version()
  # -->
  # Returns revision information for the erb.rb module.
  #
  def self.version: () -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - new(str, safe_level=NOT_GIVEN, legacy_trim_mode=NOT_GIVEN, legacy_eoutvar=NOT_GIVEN, trim_mode: nil, eoutvar: '_erbout')
  # -->
  # Constructs a new ERB object with the template specified in *str*.
  #
  # An ERB object works by building a chunk of Ruby code that will output the
  # completed template when run.
  #
  # If *trim_mode* is passed a String containing one or more of the following
  # modifiers, ERB will adjust its code generation as listed:
  #
  #     %  enables Ruby code processing for lines beginning with %
  #     <> omit newline for lines starting with <% and ending in %>
  #     >  omit newline for lines ending in %>
  #     -  omit blank lines ending in -%>
  #
  # *eoutvar* can be used to set the name of the variable ERB will build up its
  # output in.  This is useful when you need to run multiple ERB templates through
  # the same binding and/or when you want to control where output ends up.  Pass
  # the name of the variable to be used inside a String.
  #
  # ### Example
  #
  #     require "erb"
  #
  #     # build data class
  #     class Listings
  #       PRODUCT = { :name => "Chicken Fried Steak",
  #                   :desc => "A well messages pattie, breaded and fried.",
  #                   :cost => 9.95 }
  #
  #       attr_reader :product, :price
  #
  #       def initialize( product = "", price = "" )
  #         @product = product
  #         @price = price
  #       end
  #
  #       def build
  #         b = binding
  #         # create and run templates, filling member data variables
  #         ERB.new(<<~'END_PRODUCT', trim_mode: "", eoutvar: "@product").result b
  #           <%= PRODUCT[:name] %>
  #           <%= PRODUCT[:desc] %>
  #         END_PRODUCT
  #         ERB.new(<<~'END_PRICE', trim_mode: "", eoutvar: "@price").result b
  #           <%= PRODUCT[:name] %> -- <%= PRODUCT[:cost] %>
  #           <%= PRODUCT[:desc] %>
  #         END_PRICE
  #       end
  #     end
  #
  #     # setup template data
  #     listings = Listings.new
  #     listings.build
  #
  #     puts listings.product + "\n" + listings.price
  #
  # *Generates*
  #
  #     Chicken Fried Steak
  #     A well messages pattie, breaded and fried.
  #
  #     Chicken Fried Steak -- 9.95
  #     A well messages pattie, breaded and fried.
  #
  def initialize: (String, ?eoutvar: String, ?trim_mode: Integer | String | NilClass) -> untyped

  # <!-- rdoc-file=lib/erb.rb -->
  # The Ruby code generated by ERB
  #
  def src: () -> String

  # <!-- rdoc-file=lib/erb.rb -->
  # The encoding to eval
  #
  def encoding: () -> Encoding

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *filename* argument passed to Kernel#eval when the ERB code is
  # run
  #
  def filename: () -> (String | NilClass)

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *filename* argument passed to Kernel#eval when the ERB code is
  # run
  #
  def filename=: (String | NilClass) -> untyped

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *lineno* argument passed to Kernel#eval when the ERB code is run
  #
  def lineno: () -> Integer

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *lineno* argument passed to Kernel#eval when the ERB code is run
  #
  def lineno=: (Integer) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - location=((filename, lineno))
  # -->
  # Sets optional filename and line number that will be used in ERB code
  # evaluation and error reporting. See also #filename= and #lineno=
  #
  #     erb = ERB.new('<%= some_x %>')
  #     erb.render
  #     # undefined local variable or method `some_x'
  #     #   from (erb):1
  #
  #     erb.location = ['file.erb', 3]
  #     # All subsequent error reporting would use new location
  #     erb.render
  #     # undefined local variable or method `some_x'
  #     #   from file.erb:4
  #
  def location=: (Array[String | Integer]) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - run(b=new_toplevel)
  # -->
  # Generate results and print them. (see ERB#result)
  #
  def run: (?Binding) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - result(b=new_toplevel)
  # -->
  # Executes the generated ERB code to produce a completed template, returning the
  # results of that code.  (See ERB::new for details on how this process can be
  # affected by *safe_level*.)
  #
  # *b* accepts a Binding object which is used to set the context of code
  # evaluation.
  #
  def result: (?Binding) -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - result_with_hash(hash)
  # -->
  # Render a template on a new toplevel binding with local variables specified by
  # a Hash object.
  #
  def result_with_hash: (Hash[untyped, untyped]) -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_method(mod, methodname, fname='(ERB)')
  # -->
  # Define *methodname* as instance method of *mod* from compiled Ruby source.
  #
  # example:
  #     filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.def_method(MyClass, 'render(arg1, arg2)', filename)
  #     print MyClass.new.render('foo', 123)
  #
  def def_method: (Module, String, ?String) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_module(methodname='erb')
  # -->
  # Create unnamed module, define *methodname* as instance method of it, and
  # return it.
  #
  # example:
  #     filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.filename = filename
  #     MyModule = erb.def_module('render(arg1, arg2)')
  #     class MyClass
  #       include MyModule
  #     end
  #
  def def_module: (?String) -> Module

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_class(superklass=Object, methodname='result')
  # -->
  # Define unnamed class which has *methodname* as instance method, and return it.
  #
  # example:
  #     class MyClass_
  #       def initialize(arg1, arg2)
  #         @arg1 = arg1;  @arg2 = arg2
  #       end
  #     end
  #     filename = 'example.rhtml'  # @arg1 and @arg2 are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.filename = filename
  #     MyClass = erb.def_class(MyClass_, 'render()')
  #     print MyClass.new('foo', 123).render()
  #
  def def_class: (?Class, ?String) -> Class

  module Util
    # <!--
    #   rdoc-file=lib/erb.rb
    #   - html_escape(s)
    # -->
    # A utility method for escaping HTML tag characters in *s*.
    #
    #     require "erb"
    #     include ERB::Util
    #
    #     puts html_escape("is a > 0 & a < 10?")
    #
    # *Generates*
    #
    #     is a &gt; 0 &amp; a &lt; 10?
    #
    def self?.html_escape: (String str) -> String

    # <!--
    #   rdoc-file=lib/erb.rb
    #   - h(s)
    # -->
    #
    alias h html_escape

    # <!--
    #   rdoc-file=lib/erb.rb
    #   - h(s)
    # -->
    #
    alias self.h self.html_escape

    # <!--
    #   rdoc-file=lib/erb/util.rb
    #   - url_encode(s)
    # -->
    # A utility method for encoding the String *s* as a URL.
    #
    #     require "erb"
    #     include ERB::Util
    #
    #     puts url_encode("Programming Ruby:  The Pragmatic Programmer's Guide")
    #
    # *Generates*
    #
    #     Programming%20Ruby%3A%20%20The%20Pragmatic%20Programmer%27s%20Guide
    #
    def self?.url_encode: (String) -> String

    # <!--
    #   rdoc-file=lib/erb/util.rb
    #   - u(s)
    # -->
    #
    alias u url_encode

    # <!--
    #   rdoc-file=lib/erb/util.rb
    #   - u(s)
    # -->
    #
    alias self.u self.url_encode
  end

  module DefMethod
    # <!--
    #   rdoc-file=lib/erb/def_method.rb
    #   - def_erb_method(methodname, erb_or_fname)
    # -->
    # define *methodname* as instance method of current module, using ERB object or
    # eRuby file
    #
    def self.def_erb_method: (String methodname, (String | ERB) erb_or_fname) -> untyped
  end

  module Escape
    # <!--
    #   rdoc-file=lib/erb/util.rb
    #   - html_escape(s)
    # -->
    #
    def self?.html_escape: (String) -> String
  end
end
# <!-- rdoc-file=ext/etc/etc.c -->
# The Etc module provides access to information typically stored in files in the
# `/etc` directory on Unix systems.
#
# The information accessible consists of the information found in the
# `/etc/passwd` and `/etc/group` files, plus information about the system's
# temporary directory (`/tmp`) and configuration directory (`/etc`).
#
# The Etc module provides a more reliable way to access information about the
# logged in user than environment variables such as +$USER+.
#
# **Example:**
#
#     require 'etc'
#
#     login = Etc.getlogin
#     info = Etc.getpwnam(login)
#     username = info.gecos.split(/,/).first
#     puts "Hello #{username}, I see your login name is #{login}"
#
# Note that the methods provided by this module are not always secure. It should
# be used for informational purposes, and not for security.
#
# All operations defined in this module are class methods, so that you can
# include the Etc module into your class.
#
module Etc
  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - confstr(name)        ->  String
  # -->
  # Returns system configuration variable using confstr().
  #
  # *name* should be a constant under `Etc` which begins with `CS_`.
  #
  # The return value is a string or nil. nil means no configuration-defined value.
  #  (confstr() returns 0 but errno is not set.)
  #
  #     Etc.confstr(Etc::CS_PATH) #=> "/bin:/usr/bin"
  #
  #     # GNU/Linux
  #     Etc.confstr(Etc::CS_GNU_LIBC_VERSION) #=> "glibc 2.18"
  #     Etc.confstr(Etc::CS_GNU_LIBPTHREAD_VERSION) #=> "NPTL 2.18"
  #
  def self?.confstr: (::Integer p1) -> ::String?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - endgrent
  # -->
  # Ends the process of scanning through the `/etc/group` file begun by
  # ::getgrent, and closes the file.
  #
  def self?.endgrent: () -> void

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - endpwent
  # -->
  # Ends the process of scanning through the `/etc/passwd` file begun with
  # ::getpwent, and closes the file.
  #
  def self?.endpwent: () -> void

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getgrent     ->  Etc::Group
  # -->
  # Returns an entry from the `/etc/group` file.
  #
  # The first time it is called it opens the file and returns the first entry;
  # each successive call returns the next entry, or `nil` if the end of the file
  # has been reached.
  #
  # To close the file when processing is complete, call ::endgrent.
  #
  # Each entry is returned as a Group struct
  #
  def self?.getgrent: () -> ::Etc::Group?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getgrgid(group_id)  ->       Etc::Group
  # -->
  # Returns information about the group with specified integer `group_id`, as
  # found in `/etc/group`.
  #
  # The information is returned as a Group struct.
  #
  # See the unix manpage for `getgrgid(3)` for more detail.
  #
  # **Example:**
  #
  #     Etc.getgrgid(100)
  #     #=> #<struct Etc::Group name="users", passwd="x", gid=100, mem=["meta", "root"]>
  #
  def self?.getgrgid: (?::Integer group_id) -> ::Etc::Group

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getgrnam(name)       ->  Etc::Group
  # -->
  # Returns information about the group with specified `name`, as found in
  # `/etc/group`.
  #
  # The information is returned as a Group struct.
  #
  # See the unix manpage for `getgrnam(3)` for more detail.
  #
  # **Example:**
  #
  #     Etc.getgrnam('users')
  #     #=> #<struct Etc::Group name="users", passwd="x", gid=100, mem=["meta", "root"]>
  #
  def self?.getgrnam: (::String name) -> ::Etc::Group

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getlogin     ->  String
  # -->
  # Returns the short user name of the currently logged in user. Unfortunately, it
  # is often rather easy to fool ::getlogin.
  #
  # Avoid ::getlogin for security-related purposes.
  #
  # If ::getlogin fails, try ::getpwuid.
  #
  # See the unix manpage for `getpwuid(3)` for more detail.
  #
  # e.g.
  #     Etc.getlogin -> 'guest'
  #
  def self?.getlogin: () -> ::String?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getpwent     ->  Etc::Passwd
  # -->
  # Returns an entry from the `/etc/passwd` file.
  #
  # The first time it is called it opens the file and returns the first entry;
  # each successive call returns the next entry, or `nil` if the end of the file
  # has been reached.
  #
  # To close the file when processing is complete, call ::endpwent.
  #
  # Each entry is returned as a Passwd struct.
  #
  def self?.getpwent: () -> ::Etc::Passwd?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getpwnam(name)       ->  Etc::Passwd
  # -->
  # Returns the `/etc/passwd` information for the user with specified login
  # `name`.
  #
  # The information is returned as a Passwd struct.
  #
  # See the unix manpage for `getpwnam(3)` for more detail.
  #
  # **Example:**
  #
  #     Etc.getpwnam('root')
  #     #=> #<struct Etc::Passwd name="root", passwd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">
  #
  def self?.getpwnam: (::String name) -> ::Etc::Passwd

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - getpwuid(uid)        ->  Etc::Passwd
  # -->
  # Returns the `/etc/passwd` information for the user with the given integer
  # `uid`.
  #
  # The information is returned as a Passwd struct.
  #
  # If `uid` is omitted, the value from `Passwd[:uid]` is returned instead.
  #
  # See the unix manpage for `getpwuid(3)` for more detail.
  #
  # **Example:**
  #
  #     Etc.getpwuid(0)
  #     #=> #<struct Etc::Passwd name="root", passwd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">
  #
  def self?.getpwuid: (?::Integer uid) -> ::Etc::Passwd

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - group { |struct| block }
  #   - group                                ->  Etc::Group
  # -->
  # Provides a convenient Ruby iterator which executes a block for each entry in
  # the `/etc/group` file.
  #
  # The code block is passed an Group struct.
  #
  # See ::getgrent above for details.
  #
  # **Example:**
  #
  #     require 'etc'
  #
  #     Etc.group {|g|
  #       puts g.name + ": " + g.mem.join(', ')
  #     }
  #
  def self?.group: () { (::Etc::Group group) -> void } -> void
                 | () -> ::Etc::Group?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - nprocessors  ->  Integer
  # -->
  # Returns the number of online processors.
  #
  # The result is intended as the number of processes to use all available
  # processors.
  #
  # This method is implemented using:
  # *   sched_getaffinity(): Linux
  # *   sysconf(_SC_NPROCESSORS_ONLN): GNU/Linux, NetBSD, FreeBSD, OpenBSD,
  #     DragonFly BSD, OpenIndiana, Mac OS X, AIX
  #
  # **Example:**
  #
  #     require 'etc'
  #     p Etc.nprocessors #=> 4
  #
  # The result might be smaller number than physical cpus especially when ruby
  # process is bound to specific cpus. This is intended for getting better
  # parallel processing.
  #
  # **Example:** (Linux)
  #
  #     linux$ taskset 0x3 ./ruby -retc -e "p Etc.nprocessors"  #=> 2
  #
  def self?.nprocessors: () -> ::Integer

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - passwd { |struct| block }
  #   - passwd                               ->  Etc::Passwd
  # -->
  # Provides a convenient Ruby iterator which executes a block for each entry in
  # the `/etc/passwd` file.
  #
  # The code block is passed an Passwd struct.
  #
  # See ::getpwent above for details.
  #
  # **Example:**
  #
  #     require 'etc'
  #
  #     Etc.passwd {|u|
  #       puts u.name + " = " + u.gecos
  #     }
  #
  def self?.passwd: () { (::Etc::Passwd passwd) -> void } -> void
                  | () -> ::Etc::Passwd?

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - setgrent
  # -->
  # Resets the process of reading the `/etc/group` file, so that the next call to
  # ::getgrent will return the first entry again.
  #
  def self?.setgrent: () -> void

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - setpwent
  # -->
  # Resets the process of reading the `/etc/passwd` file, so that the next call to
  # ::getpwent will return the first entry again.
  #
  def self?.setpwent: () -> void

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - sysconf(name)        ->  Integer
  # -->
  # Returns system configuration variable using sysconf().
  #
  # *name* should be a constant under `Etc` which begins with `SC_`.
  #
  # The return value is an integer or nil. nil means indefinite limit.  (sysconf()
  # returns -1 but errno is not set.)
  #
  #     Etc.sysconf(Etc::SC_ARG_MAX) #=> 2097152
  #     Etc.sysconf(Etc::SC_LOGIN_NAME_MAX) #=> 256
  #
  def self?.sysconf: (::Integer p1) -> ::Integer

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - sysconfdir   ->  String
  # -->
  # Returns system configuration directory.
  #
  # This is typically `"/etc"`, but is modified by the prefix used when Ruby was
  # compiled. For example, if Ruby is built and installed in `/usr/local`, returns
  # `"/usr/local/etc"` on other platforms than Windows.
  #
  # On Windows, this always returns the directory provided by the system.
  #
  def self?.sysconfdir: () -> ::String

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - systmpdir    ->  String
  # -->
  # Returns system temporary directory; typically "/tmp".
  #
  def self?.systmpdir: () -> ::String

  # <!--
  #   rdoc-file=ext/etc/etc.c
  #   - uname        -> hash
  # -->
  # Returns the system information obtained by uname system call.
  #
  # The return value is a hash which has 5 keys at least:
  #     :sysname, :nodename, :release, :version, :machine
  #
  # **Example:**
  #
  #     require 'etc'
  #     require 'pp'
  #
  #     pp Etc.uname
  #     #=> {:sysname=>"Linux",
  #     #    :nodename=>"boron",
  #     #    :release=>"2.6.18-6-xen-686",
  #     #    :version=>"#1 SMP Thu Nov 5 19:54:42 UTC 2009",
  #     #    :machine=>"i686"}
  #
  def self?.uname: () -> { sysname: ::String, nodename: ::String, release: ::String, version: ::String, machine: ::String }

  private

  CS_PATH: Integer

  CS_POSIX_V6_ILP32_OFF32_CFLAGS: Integer

  CS_POSIX_V6_ILP32_OFF32_LDFLAGS: Integer

  CS_POSIX_V6_ILP32_OFF32_LIBS: Integer

  CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: Integer

  CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: Integer

  CS_POSIX_V6_ILP32_OFFBIG_LIBS: Integer

  CS_POSIX_V6_LP64_OFF64_CFLAGS: Integer

  CS_POSIX_V6_LP64_OFF64_LDFLAGS: Integer

  CS_POSIX_V6_LP64_OFF64_LIBS: Integer

  CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: Integer

  CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: Integer

  CS_POSIX_V6_LPBIG_OFFBIG_LIBS: Integer

  CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: Integer

  PC_2_SYMLINKS: Integer

  PC_ALLOC_SIZE_MIN: Integer

  PC_ASYNC_IO: Integer

  PC_CHOWN_RESTRICTED: Integer

  PC_FILESIZEBITS: Integer

  PC_LINK_MAX: Integer

  PC_MAX_CANON: Integer

  PC_MAX_INPUT: Integer

  PC_NAME_MAX: Integer

  PC_NO_TRUNC: Integer

  PC_PATH_MAX: Integer

  PC_PIPE_BUF: Integer

  PC_PRIO_IO: Integer

  PC_REC_INCR_XFER_SIZE: Integer

  PC_REC_MAX_XFER_SIZE: Integer

  PC_REC_MIN_XFER_SIZE: Integer

  PC_REC_XFER_ALIGN: Integer

  PC_SYMLINK_MAX: Integer

  PC_SYNC_IO: Integer

  PC_VDISABLE: Integer

  SC_2_CHAR_TERM: Integer

  SC_2_C_BIND: Integer

  SC_2_C_DEV: Integer

  SC_2_FORT_DEV: Integer

  SC_2_FORT_RUN: Integer

  SC_2_LOCALEDEF: Integer

  SC_2_PBS: Integer

  SC_2_PBS_ACCOUNTING: Integer

  SC_2_PBS_CHECKPOINT: Integer

  SC_2_PBS_LOCATE: Integer

  SC_2_PBS_MESSAGE: Integer

  SC_2_PBS_TRACK: Integer

  SC_2_SW_DEV: Integer

  SC_2_UPE: Integer

  SC_2_VERSION: Integer

  SC_ADVISORY_INFO: Integer

  SC_AIO_LISTIO_MAX: Integer

  SC_AIO_MAX: Integer

  SC_AIO_PRIO_DELTA_MAX: Integer

  SC_ARG_MAX: Integer

  SC_ASYNCHRONOUS_IO: Integer

  SC_ATEXIT_MAX: Integer

  SC_BARRIERS: Integer

  SC_BC_BASE_MAX: Integer

  SC_BC_DIM_MAX: Integer

  SC_BC_SCALE_MAX: Integer

  SC_BC_STRING_MAX: Integer

  SC_CHILD_MAX: Integer

  SC_CLK_TCK: Integer

  SC_CLOCK_SELECTION: Integer

  SC_COLL_WEIGHTS_MAX: Integer

  SC_CPUTIME: Integer

  SC_DELAYTIMER_MAX: Integer

  SC_EXPR_NEST_MAX: Integer

  SC_FSYNC: Integer

  SC_GETGR_R_SIZE_MAX: Integer

  SC_GETPW_R_SIZE_MAX: Integer

  SC_HOST_NAME_MAX: Integer

  SC_IOV_MAX: Integer

  SC_IPV6: Integer

  SC_JOB_CONTROL: Integer

  SC_LINE_MAX: Integer

  SC_LOGIN_NAME_MAX: Integer

  SC_MAPPED_FILES: Integer

  SC_MEMLOCK: Integer

  SC_MEMLOCK_RANGE: Integer

  SC_MEMORY_PROTECTION: Integer

  SC_MESSAGE_PASSING: Integer

  SC_MONOTONIC_CLOCK: Integer

  SC_MQ_OPEN_MAX: Integer

  SC_MQ_PRIO_MAX: Integer

  SC_NGROUPS_MAX: Integer

  SC_NPROCESSORS_CONF: Integer

  SC_NPROCESSORS_ONLN: Integer

  SC_OPEN_MAX: Integer

  SC_PAGESIZE: Integer

  SC_PAGE_SIZE: Integer

  SC_PHYS_PAGES: Integer

  SC_PRIORITIZED_IO: Integer

  SC_PRIORITY_SCHEDULING: Integer

  SC_RAW_SOCKETS: Integer

  SC_READER_WRITER_LOCKS: Integer

  SC_REALTIME_SIGNALS: Integer

  SC_REGEXP: Integer

  SC_RE_DUP_MAX: Integer

  SC_RTSIG_MAX: Integer

  SC_SAVED_IDS: Integer

  SC_SEMAPHORES: Integer

  SC_SEM_NSEMS_MAX: Integer

  SC_SEM_VALUE_MAX: Integer

  SC_SHARED_MEMORY_OBJECTS: Integer

  SC_SHELL: Integer

  SC_SIGQUEUE_MAX: Integer

  SC_SPAWN: Integer

  SC_SPIN_LOCKS: Integer

  SC_SPORADIC_SERVER: Integer

  SC_SS_REPL_MAX: Integer

  SC_STREAM_MAX: Integer

  SC_SYMLOOP_MAX: Integer

  SC_SYNCHRONIZED_IO: Integer

  SC_THREADS: Integer

  SC_THREAD_ATTR_STACKADDR: Integer

  SC_THREAD_ATTR_STACKSIZE: Integer

  SC_THREAD_CPUTIME: Integer

  SC_THREAD_DESTRUCTOR_ITERATIONS: Integer

  SC_THREAD_KEYS_MAX: Integer

  SC_THREAD_PRIORITY_SCHEDULING: Integer

  SC_THREAD_PRIO_INHERIT: Integer

  SC_THREAD_PRIO_PROTECT: Integer

  SC_THREAD_PROCESS_SHARED: Integer

  SC_THREAD_SAFE_FUNCTIONS: Integer

  SC_THREAD_SPORADIC_SERVER: Integer

  SC_THREAD_STACK_MIN: Integer

  SC_THREAD_THREADS_MAX: Integer

  SC_TIMEOUTS: Integer

  SC_TIMERS: Integer

  SC_TIMER_MAX: Integer

  SC_TRACE: Integer

  SC_TRACE_EVENT_FILTER: Integer

  SC_TRACE_EVENT_NAME_MAX: Integer

  SC_TRACE_INHERIT: Integer

  SC_TRACE_LOG: Integer

  SC_TRACE_NAME_MAX: Integer

  SC_TRACE_SYS_MAX: Integer

  SC_TRACE_USER_EVENT_MAX: Integer

  SC_TTY_NAME_MAX: Integer

  SC_TYPED_MEMORY_OBJECTS: Integer

  SC_TZNAME_MAX: Integer

  SC_V6_ILP32_OFF32: Integer

  SC_V6_ILP32_OFFBIG: Integer

  SC_V6_LP64_OFF64: Integer

  SC_V6_LPBIG_OFFBIG: Integer

  SC_VERSION: Integer

  SC_XOPEN_CRYPT: Integer

  SC_XOPEN_ENH_I18N: Integer

  SC_XOPEN_REALTIME: Integer

  SC_XOPEN_REALTIME_THREADS: Integer

  SC_XOPEN_SHM: Integer

  SC_XOPEN_STREAMS: Integer

  SC_XOPEN_UNIX: Integer

  SC_XOPEN_VERSION: Integer

  # <!-- rdoc-file=ext/etc/etc.c -->
  # The version
  #
  VERSION: String

  # <!-- rdoc-file=ext/etc/etc.c -->
  # Group is a placeholder Struct for user group database on Unix systems.
  #
  # ### The struct contains the following members
  #
  # name
  # :   contains the name of the group as a String.
  #
  # passwd
  # :   contains the encrypted password as a String. An `'x'` is returned if
  #     password access to the group is not available; an empty string is returned
  #     if no password is needed to obtain membership of the group. This is
  #     system-dependent.
  #
  # gid
  # :   contains the group's numeric ID as an integer.
  #
  # mem
  # :   is an Array of Strings containing the short login names of the members of
  #     the group.
  #
  class Group < Struct[untyped]
    extend Enumerable[untyped]

    def self.[]: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/etc/etc.c
    #   - Etc::Group.each { |group| block }   ->       Etc::Group
    #   - Etc::Group.each                          ->     Enumerator
    # -->
    # Iterates for each entry in the `/etc/group` file if a block is given.
    #
    # If no block is given, returns the Enumerator.
    #
    # The code block is passed a Group struct.
    #
    # **Example:**
    #
    #     require 'etc'
    #
    #     Etc::Group.each {|g|
    #       puts g.name + ": " + g.mem.join(', ')
    #     }
    #
    #     Etc::Group.collect {|g| g.name}
    #     Etc::Group.select {|g| !g.mem.empty?}
    #
    def self.each: () -> untyped

    def self.inspect: () -> untyped

    def self.keyword_init?: () -> untyped

    def self.members: () -> untyped

    def self.new: (*untyped) -> untyped

    def gid: () -> Integer

    def gid=: (Integer new_gid) -> void

    def mem: () -> Array[String]

    def mem=: (Array[String] new_mem) -> void

    def name: () -> String

    def name=: (String new_name) -> void

    def passwd: () -> String

    def passwd=: (String new_passwd) -> void
  end

  # <!-- rdoc-file=ext/etc/etc.c -->
  # Passwd is a placeholder Struct for user database on Unix systems.
  #
  # ### The struct contains the following members
  #
  # name
  # :   contains the short login name of the user as a String.
  #
  # passwd
  # :   contains the encrypted password of the user as a String. an `'x'` is
  #     returned if shadow passwords are in use. An `'*'` is returned if the user
  #     cannot log in using a password.
  #
  # uid
  # :   contains the integer user ID (uid) of the user.
  #
  # gid
  # :   contains the integer group ID (gid) of the user's primary group.
  #
  # dir
  # :   contains the path to the home directory of the user as a String.
  #
  # shell
  # :   contains the path to the login shell of the user as a String.
  #
  #
  # ### The following members below are system-dependent
  #
  # gecos
  # :   contains a longer String description of the user, such as a full name.
  #     Some Unix systems provide structured information in the gecos field, but
  #     this is system-dependent.
  #
  # change
  # :   password change time(integer).
  #
  # quota
  # :   quota value(integer).
  #
  # age
  # :   password age(integer).
  #
  # class
  # :   user access class(string).
  #
  # comment
  # :   comment(string).
  #
  # expire
  # :   account expiration time(integer).
  #
  class Passwd < Struct[untyped]
    extend Enumerable[untyped]

    def self.[]: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/etc/etc.c
    #   - Etc::Passwd.each { |struct| block }  ->  Etc::Passwd
    #   - Etc::Passwd.each                     ->  Enumerator
    # -->
    # Iterates for each entry in the `/etc/passwd` file if a block is given.
    #
    # If no block is given, returns the Enumerator.
    #
    # The code block is passed an Passwd struct.
    #
    # See Etc.getpwent above for details.
    #
    # **Example:**
    #
    #     require 'etc'
    #
    #     Etc::Passwd.each {|u|
    #       puts u.name + " = " + u.gecos
    #     }
    #
    #     Etc::Passwd.collect {|u| u.gecos}
    #     Etc::Passwd.collect {|u| u.gecos}
    #
    def self.each: () -> untyped

    def self.inspect: () -> untyped

    def self.keyword_init?: () -> untyped

    def self.members: () -> untyped

    def self.new: (*untyped) -> untyped

    def change: () -> Integer

    def change=: (Integer new_change) -> void

    def dir: () -> String

    def dir=: (String new_dir) -> void

    def expire: () -> Integer

    def expire=: (Integer new_expire) -> void

    def gecos: () -> String

    def gecos=: (String new_gecos) -> void

    def gid: () -> Integer

    def gid=: (Integer new_gid) -> void

    def name: () -> String

    def name=: (String new_name) -> void

    def passwd: () -> String

    def passwd=: (String new_passwd) -> void

    def shell: () -> String

    def shell=: (String new_shell) -> void

    def uclass: () -> String

    def uclass=: (String new_uclass) -> void

    def uid: () -> Integer

    def uid=: (Integer new_uid) -> void
  end
end
# <!-- rdoc-file=lib/fileutils.rb -->
# Namespace for file utility methods for copying, moving, removing, etc.
#
# ## What's Here
#
# First, whats elsewhere. Module FileUtils:
#
# *   Inherits from [class Object](rdoc-ref:Object).
# *   Supplements [class File](rdoc-ref:File) (but is not included or extended
#     there).
#
# Here, module FileUtils provides methods that are useful for:
#
# *   [Creating](rdoc-ref:FileUtils@Creating).
# *   [Deleting](rdoc-ref:FileUtils@Deleting).
# *   [Querying](rdoc-ref:FileUtils@Querying).
# *   [Setting](rdoc-ref:FileUtils@Setting).
# *   [Comparing](rdoc-ref:FileUtils@Comparing).
# *   [Copying](rdoc-ref:FileUtils@Copying).
# *   [Moving](rdoc-ref:FileUtils@Moving).
# *   [Options](rdoc-ref:FileUtils@Options).
#
# ### Creating
#
# *   ::mkdir: Creates directories.
# *   ::mkdir_p, ::makedirs, ::mkpath: Creates directories, also creating
#     ancestor directories as needed.
# *   ::link_entry: Creates a hard link.
# *   ::ln, ::link: Creates hard links.
# *   ::ln_s, ::symlink: Creates symbolic links.
# *   ::ln_sf: Creates symbolic links, overwriting if necessary.
# *   ::ln_sr: Creates symbolic links relative to targets
#
# ### Deleting
#
# *   ::remove_dir: Removes a directory and its descendants.
# *   ::remove_entry: Removes an entry, including its descendants if it is a
#     directory.
# *   ::remove_entry_secure: Like ::remove_entry, but removes securely.
# *   ::remove_file: Removes a file entry.
# *   ::rm, ::remove: Removes entries.
# *   ::rm_f, ::safe_unlink: Like ::rm, but removes forcibly.
# *   ::rm_r: Removes entries and their descendants.
# *   ::rm_rf, ::rmtree: Like ::rm_r, but removes forcibly.
# *   ::rmdir: Removes directories.
#
# ### Querying
#
# *   ::pwd, ::getwd: Returns the path to the working directory.
# *   ::uptodate?: Returns whether a given entry is newer than given other
#     entries.
#
# ### Setting
#
# *   ::cd, ::chdir: Sets the working directory.
# *   ::chmod: Sets permissions for an entry.
# *   ::chmod_R: Sets permissions for an entry and its descendants.
# *   ::chown: Sets the owner and group for entries.
# *   ::chown_R: Sets the owner and group for entries and their descendants.
# *   ::touch: Sets modification and access times for entries, creating if
#     necessary.
#
# ### Comparing
#
# *   ::compare_file, ::cmp, ::identical?: Returns whether two entries are
#     identical.
# *   ::compare_stream: Returns whether two streams are identical.
#
# ### Copying
#
# *   ::copy_entry: Recursively copies an entry.
# *   ::copy_file: Copies an entry.
# *   ::copy_stream: Copies a stream.
# *   ::cp, ::copy: Copies files.
# *   ::cp_lr: Recursively creates hard links.
# *   ::cp_r: Recursively copies files, retaining mode, owner, and group.
# *   ::install: Recursively copies files, optionally setting mode, owner, and
#     group.
#
# ### Moving
#
# *   ::mv, ::move: Moves entries.
#
# ### Options
#
# *   ::collect_method: Returns the names of methods that accept a given option.
# *   ::commands: Returns the names of methods that accept options.
# *   ::have_option?: Returns whether a given method accepts a given option.
# *   ::options: Returns all option names.
# *   ::options_of: Returns the names of the options for a given method.
#
# ## Path Arguments
#
# Some methods in FileUtils accept *path* arguments, which are interpreted as
# paths to filesystem entries:
#
# *   If the argument is a string, that value is the path.
# *   If the argument has method `:to_path`, it is converted via that method.
# *   If the argument has method `:to_str`, it is converted via that method.
#
# ## About the Examples
#
# Some examples here involve trees of file entries. For these, we sometimes
# display trees using the [tree command-line
# utility](https://en.wikipedia.org/wiki/Tree_(command)), which is a recursive
# directory-listing utility that produces a depth-indented listing of files and
# directories.
#
# We use a helper method to launch the command and control the format:
#
#     def tree(dirpath = '.')
#       command = "tree --noreport --charset=ascii #{dirpath}"
#       system(command)
#     end
#
# To illustrate:
#
#     tree('src0')
#     # => src0
#     #    |-- sub0
#     #    |   |-- src0.txt
#     #    |   `-- src1.txt
#     #    `-- sub1
#     #        |-- src2.txt
#     #        `-- src3.txt
#
# ## Avoiding the TOCTTOU Vulnerability
#
# For certain methods that recursively remove entries, there is a potential
# vulnerability called the [Time-of-check to
# time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use), or
# TOCTTOU, vulnerability that can exist when:
#
# *   An ancestor directory of the entry at the target path is world writable;
#     such directories include `/tmp`.
# *   The directory tree at the target path includes:
#
#     *   A world-writable descendant directory.
#     *   A symbolic link.
#
# To avoid that vulnerability, you can use this method to remove entries:
#
# *   FileUtils.remove_entry_secure: removes recursively if the target path
#     points to a directory.
#
# Also available are these methods, each of which calls
# FileUtils.remove_entry_secure:
#
# *   FileUtils.rm_r with keyword argument `secure: true`.
# *   FileUtils.rm_rf with keyword argument `secure: true`.
#
# Finally, this method for moving entries calls FileUtils.remove_entry_secure if
# the source and destination are on different file systems (which means that the
# "move" is really a copy and remove):
#
# *   FileUtils.mv with keyword argument `secure: true`.
#
# Method FileUtils.remove_entry_secure removes securely by applying a special
# pre-process:
#
# *   If the target path points to a directory, this method uses methods
#     [File#chown](rdoc-ref:File#chown) and [File#chmod](rdoc-ref:File#chmod) in
#     removing directories.
# *   The owner of the target directory should be either the current process or
#     the super user (root).
#
# WARNING: You must ensure that **ALL** parent directories cannot be moved by
# other untrusted users.  For example, parent directories should not be owned by
# untrusted users, and should not be world writable except when the sticky bit
# is set.
#
# For details of this security vulnerability, see Perl cases:
#
# *   [CVE-2005-0448](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-04
#     48).
# *   [CVE-2004-0452](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-04
#     52).
#
module FileUtils
  # <!-- rdoc-file=lib/fileutils.rb -->
  # The version number.
  #
  VERSION: String

  type mode = Integer | String

  type path = string | _ToPath

  type pathlist = path | Array[path]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cd(dir, verbose: nil) { |dir| ... }
  # -->
  # Changes the working directory to the given `dir`, which should be
  # [interpretable as a path](rdoc-ref:FileUtils@Path+Arguments):
  #
  # With no block given, changes the current directory to the directory at `dir`;
  # returns zero:
  #
  #     FileUtils.pwd # => "/rdoc/fileutils"
  #     FileUtils.cd('..')
  #     FileUtils.pwd # => "/rdoc"
  #     FileUtils.cd('fileutils')
  #
  # With a block given, changes the current directory to the directory at `dir`,
  # calls the block with argument `dir`, and restores the original current
  # directory; returns the block's value:
  #
  #     FileUtils.pwd                                     # => "/rdoc/fileutils"
  #     FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # => ["..", "/rdoc"]
  #     FileUtils.pwd                                     # => "/rdoc/fileutils"
  #
  # Keyword arguments:
  #
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.cd('..')
  #         FileUtils.cd('fileutils')
  #
  #     Output:
  #
  #         cd ..
  #         cd fileutils
  #
  # Related: FileUtils.pwd.
  #
  def self?.cd: (path dir, ?verbose: boolish) -> void
              | [X] (path dir, ?verbose: boolish) { (String) -> X } -> X

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chdir(dir, verbose: nil)
  # -->
  #
  alias self.chdir self.cd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chdir(dir, verbose: nil)
  # -->
  #
  alias chdir cd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chmod(mode, list, noop: nil, verbose: nil)
  # -->
  # Changes permissions on the entries at the paths given in `list` (a single path
  # or an array of paths) to the permissions given by `mode`; returns `list` if it
  # is an array, `[list]` otherwise:
  #
  # *   Modifies each entry that is a regular file using
  #     [File.chmod](rdoc-ref:File.chmod).
  # *   Modifies each entry that is a symbolic link using
  #     [File.lchmod](rdoc-ref:File.lchmod).
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Argument `mode` may be either an integer or a string:
  #
  # *   Integer `mode`: represents the permission bits to be set:
  #
  #         FileUtils.chmod(0755, 'src0.txt')
  #         FileUtils.chmod(0644, ['src0.txt', 'src0.dat'])
  #
  # *   String `mode`: represents the permissions to be set:
  #
  #     The string is of the form `[targets][[operator][perms[,perms]]`, where:
  #
  #     *   `targets` may be any combination of these letters:
  #
  #         *   `'u'`: permissions apply to the file's owner.
  #         *   `'g'`: permissions apply to users in the file's group.
  #         *   `'o'`: permissions apply to other users not in the file's group.
  #         *   `'a'` (the default): permissions apply to all users.
  #
  #     *   `operator` may be one of these letters:
  #
  #         *   `'+'`: adds permissions.
  #         *   `'-'`: removes permissions.
  #         *   `'='`: sets (replaces) permissions.
  #
  #     *   `perms` (may be repeated, with separating commas) may be any
  #         combination of these letters:
  #
  #         *   `'r'`: Read.
  #         *   `'w'`: Write.
  #         *   `'x'`: Execute (search, for a directory).
  #         *   `'X'`: Search (for a directories only; must be used with `'+'`)
  #         *   `'s'`: Uid or gid.
  #         *   `'t'`: Sticky bit.
  #
  #     Examples:
  #
  #         FileUtils.chmod('u=wrx,go=rx', 'src1.txt')
  #         FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby')
  #
  # Keyword arguments:
  #
  # *   `noop: true` - does not change permissions; returns `nil`.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.chmod(0755, 'src0.txt', noop: true, verbose: true)
  #         FileUtils.chmod(0644, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #         FileUtils.chmod('u=wrx,go=rx', 'src1.txt', noop: true, verbose: true)
  #         FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby', noop: true, verbose: true)
  #
  #     Output:
  #
  #         chmod 755 src0.txt
  #         chmod 644 src0.txt src0.dat
  #         chmod u=wrx,go=rx src1.txt
  #         chmod u=wrx,go=rx /usr/bin/ruby
  #
  # Related: FileUtils.chmod_R.
  #
  def self?.chmod: (mode mode, pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  # -->
  # Like FileUtils.chmod, but changes permissions recursively.
  #
  def self?.chmod_R: (mode mode, pathlist list, ?noop: boolish, ?verbose: boolish, ?force: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chown(user, group, list, noop: nil, verbose: nil)
  # -->
  # Changes the owner and group on the entries at the paths given in `list` (a
  # single path or an array of paths) to the given `user` and `group`; returns
  # `list` if it is an array, `[list]` otherwise:
  #
  # *   Modifies each entry that is a regular file using
  #     [File.chown](rdoc-ref:File.chown).
  # *   Modifies each entry that is a symbolic link using
  #     [File.lchown](rdoc-ref:File.lchown).
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # User and group:
  #
  # *   Argument `user` may be a user name or a user id; if `nil` or `-1`, the
  #     user is not changed.
  # *   Argument `group` may be a group name or a group id; if `nil` or `-1`, the
  #     group is not changed.
  # *   The user must be a member of the group.
  #
  # Examples:
  #
  #     # One path.
  #     # User and group as string names.
  #     File.stat('src0.txt').uid # => 1004
  #     File.stat('src0.txt').gid # => 1004
  #     FileUtils.chown('user2', 'group1', 'src0.txt')
  #     File.stat('src0.txt').uid # => 1006
  #     File.stat('src0.txt').gid # => 1005
  #
  #     # User and group as uid and gid.
  #     FileUtils.chown(1004, 1004, 'src0.txt')
  #     File.stat('src0.txt').uid # => 1004
  #     File.stat('src0.txt').gid # => 1004
  #
  #     # Array of paths.
  #     FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'])
  #
  #     # Directory (not recursive).
  #     FileUtils.chown('user2', 'group1', '.')
  #
  # Keyword arguments:
  #
  # *   `noop: true` - does not change permissions; returns `nil`.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.chown('user2', 'group1', 'src0.txt', noop: true, verbose: true)
  #         FileUtils.chown(1004, 1004, 'src0.txt', noop: true, verbose: true)
  #         FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #         FileUtils.chown('user2', 'group1', path, noop: true, verbose: true)
  #         FileUtils.chown('user2', 'group1', '.', noop: true, verbose: true)
  #
  #     Output:
  #
  #         chown user2:group1 src0.txt
  #         chown 1004:1004 src0.txt
  #         chown 1006:1005 src0.txt src0.dat
  #         chown user2:group1 src0.txt
  #         chown user2:group1 .
  #
  # Related: FileUtils.chown_R.
  #
  def self?.chown: (String? user, String? group, pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  # -->
  # Like FileUtils.chown, but changes owner and group recursively.
  #
  def self?.chown_R: (String? user, String? group, pathlist list, ?noop: boolish, ?verbose: boolish, ?force: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - collect_method(opt)
  # -->
  # Returns an array of the string method names of the methods that accept the
  # given keyword option `opt`; the argument must be a symbol:
  #
  #     FileUtils.collect_method(:preserve) # => ["cp", "copy", "cp_r", "install"]
  #
  def self.collect_method: (Symbol opt) -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - commands()
  # -->
  # Returns an array of the string names of FileUtils methods that accept one or
  # more keyword arguments:
  #
  #     FileUtils.commands.sort.take(3) # => ["cd", "chdir", "chmod"]
  #
  def self.commands: () -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - compare_file(a, b)
  # -->
  # Returns `true` if the contents of files `a` and `b` are identical, `false`
  # otherwise.
  #
  # Arguments `a` and `b` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # FileUtils.identical? and FileUtils.cmp are aliases for FileUtils.compare_file.
  #
  # Related: FileUtils.compare_stream.
  #
  def self?.compare_file: (path a, path b) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cmp(a, b)
  # -->
  #
  alias self.cmp self.compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cmp(a, b)
  # -->
  #
  alias cmp compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - identical?(a, b)
  # -->
  #
  alias self.identical? self.compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - identical?(a, b)
  # -->
  #
  alias identical? compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - compare_stream(a, b)
  # -->
  # Returns `true` if the contents of streams `a` and `b` are identical, `false`
  # otherwise.
  #
  # Arguments `a` and `b` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Related: FileUtils.compare_file.
  #
  def self?.compare_stream: (IO a, IO b) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  # -->
  # Recursively copies files from `src` to `dest`.
  #
  # Arguments `src` and `dest` should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` is the path to a file, copies `src` to `dest`:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt') # => false
  #     FileUtils.copy_entry('src0.txt', 'dest0.txt')
  #     File.file?('dest0.txt')  # => true
  #
  # If `src` is a directory, recursively copies `src` to `dest`:
  #
  #     tree('src1')
  #     # => src1
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #     FileUtils.copy_entry('src1', 'dest1')
  #     tree('dest1')
  #     # => dest1
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #
  # The recursive copying preserves file types for regular files, directories, and
  # symbolic links; other file types (FIFO streams, device files, etc.) are not
  # supported.
  #
  # Keyword arguments:
  #
  # *   `dereference_root: true` - if `src` is a symbolic link, follows the link.
  # *   `preserve: true` - preserves file times.
  # *   `remove_destination: true` - removes `dest` before copying files.
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.copy_entry: (path src, path dest, ?boolish preserve, ?boolish dereference_root, ?boolish remove_destination) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_file(src, dest, preserve = false, dereference = true)
  # -->
  # Copies file from `src` to `dest`, which should not be directories.
  #
  # Arguments `src` and `dest` should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Examples:
  #
  #     FileUtils.touch('src0.txt')
  #     FileUtils.copy_file('src0.txt', 'dest0.txt')
  #     File.file?('dest0.txt') # => true
  #
  # Keyword arguments:
  #
  # *   `dereference: false` - if `src` is a symbolic link, does not follow the
  #     link.
  # *   `preserve: true` - preserves file times.
  # *   `remove_destination: true` - removes `dest` before copying files.
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.copy_file: (path src, path dest, ?boolish preserve, ?boolish dereference) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_stream(src, dest)
  # -->
  # Copies IO stream `src` to IO stream `dest` via
  # [IO.copy_stream](rdoc-ref:IO.copy_stream).
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.copy_stream: (_Reader src, _Writer dest) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  # Copies files.
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` is the path to a file and `dest` is not the path to a directory,
  # copies `src` to `dest`:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt') # => false
  #     FileUtils.cp('src0.txt', 'dest0.txt')
  #     File.file?('dest0.txt')  # => true
  #
  # If `src` is the path to a file and `dest` is the path to a directory, copies
  # `src` to `dest/src`:
  #
  #     FileUtils.touch('src1.txt')
  #     FileUtils.mkdir('dest1')
  #     FileUtils.cp('src1.txt', 'dest1')
  #     File.file?('dest1/src1.txt') # => true
  #
  # If `src` is an array of paths to files and `dest` is the path to a directory,
  # copies from each `src` to `dest`:
  #
  #     src_file_paths = ['src2.txt', 'src2.dat']
  #     FileUtils.touch(src_file_paths)
  #     FileUtils.mkdir('dest2')
  #     FileUtils.cp(src_file_paths, 'dest2')
  #     File.file?('dest2/src2.txt') # => true
  #     File.file?('dest2/src2.dat') # => true
  #
  # Keyword arguments:
  #
  # *   `preserve: true` - preserves file times.
  # *   `noop: true` - does not copy files.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #         FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
  #         FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
  #
  #     Output:
  #
  #         cp src0.txt dest0.txt
  #         cp src1.txt dest1
  #         cp src2.txt src2.dat dest2
  #
  # Raises an exception if `src` is a directory.
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.cp: (pathlist src, path dest, ?preserve: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.copy self.cp

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  #
  alias copy cp

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp_lr(src, dest, noop: nil, verbose: nil, dereference_root: true, remove_destination: false)
  # -->
  # Creates [hard links](https://en.wikipedia.org/wiki/Hard_link).
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` is the path to a directory and `dest` does not exist, creates links
  # `dest` and descendents pointing to `src` and its descendents:
  #
  #     tree('src0')
  #     # => src0
  #     #    |-- sub0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- sub1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #     File.exist?('dest0') # => false
  #     FileUtils.cp_lr('src0', 'dest0')
  #     tree('dest0')
  #     # => dest0
  #     #    |-- sub0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- sub1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #
  # If `src` and `dest` are both paths to directories, creates links `dest/src`
  # and descendents pointing to `src` and its descendents:
  #
  #     tree('src1')
  #     # => src1
  #     #    |-- sub0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- sub1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #     FileUtils.mkdir('dest1')
  #     FileUtils.cp_lr('src1', 'dest1')
  #     tree('dest1')
  #     # => dest1
  #     #    `-- src1
  #     #        |-- sub0
  #     #        |   |-- src0.txt
  #     #        |   `-- src1.txt
  #     #        `-- sub1
  #     #            |-- src2.txt
  #     #            `-- src3.txt
  #
  # If `src` is an array of paths to entries and `dest` is the path to a
  # directory, for each path `filepath` in `src`, creates a link at
  # `dest/filepath` pointing to that path:
  #
  #     tree('src2')
  #     # => src2
  #     #    |-- sub0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- sub1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #     FileUtils.mkdir('dest2')
  #     FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2')
  #     tree('dest2')
  #     # => dest2
  #     #    |-- sub0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- sub1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #
  # Keyword arguments:
  #
  # *   `dereference_root: false` - if `src` is a symbolic link, does not
  #     dereference it.
  # *   `noop: true` - does not create links.
  # *   `remove_destination: true` - removes `dest` before creating links.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.cp_lr('src0', 'dest0', noop: true, verbose: true)
  #         FileUtils.cp_lr('src1', 'dest1', noop: true, verbose: true)
  #         FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2', noop: true, verbose: true)
  #
  #     Output:
  #
  #         cp -lr src0 dest0
  #         cp -lr src1 dest1
  #         cp -lr src2/sub0 src2/sub1 dest2
  #
  # Raises an exception if `dest` is the path to an existing file or directory and
  # keyword argument `remove_destination: true` is not given.
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.cp_lr: (pathlist src, path dest, ?noop: boolish, ?verbose: boolish, ?dereference_root: boolish, ?remove_destination: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp_r(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)
  # -->
  # Recursively copies files.
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # The mode, owner, and group are retained in the copy; to change those, use
  # FileUtils.install instead.
  #
  # If `src` is the path to a file and `dest` is not the path to a directory,
  # copies `src` to `dest`:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt') # => false
  #     FileUtils.cp_r('src0.txt', 'dest0.txt')
  #     File.file?('dest0.txt')  # => true
  #
  # If `src` is the path to a file and `dest` is the path to a directory, copies
  # `src` to `dest/src`:
  #
  #     FileUtils.touch('src1.txt')
  #     FileUtils.mkdir('dest1')
  #     FileUtils.cp_r('src1.txt', 'dest1')
  #     File.file?('dest1/src1.txt') # => true
  #
  # If `src` is the path to a directory and `dest` does not exist, recursively
  # copies `src` to `dest`:
  #
  #     tree('src2')
  #     # => src2
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #    |-- src2.txt
  #     #    `-- src3.txt
  #     FileUtils.exist?('dest2') # => false
  #     FileUtils.cp_r('src2', 'dest2')
  #     tree('dest2')
  #     # => dest2
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #    |-- src2.txt
  #     #    `-- src3.txt
  #
  # If `src` and `dest` are paths to directories, recursively copies `src` to
  # `dest/src`:
  #
  #     tree('src3')
  #     # => src3
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #    |-- src2.txt
  #     #    `-- src3.txt
  #     FileUtils.mkdir('dest3')
  #     FileUtils.cp_r('src3', 'dest3')
  #     tree('dest3')
  #     # => dest3
  #     #    `-- src3
  #     #      |-- dir0
  #     #      |   |-- src0.txt
  #     #      |   `-- src1.txt
  #     #      `-- dir1
  #     #          |-- src2.txt
  #     #          `-- src3.txt
  #
  # If `src` is an array of paths and `dest` is a directory, recursively copies
  # from each path in `src` to `dest`; the paths in `src` may point to files
  # and/or directories.
  #
  # Keyword arguments:
  #
  # *   `dereference_root: false` - if `src` is a symbolic link, does not
  #     dereference it.
  # *   `noop: true` - does not copy files.
  # *   `preserve: true` - preserves file times.
  # *   `remove_destination: true` - removes `dest` before copying files.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.cp_r('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #         FileUtils.cp_r('src1.txt', 'dest1', noop: true, verbose: true)
  #         FileUtils.cp_r('src2', 'dest2', noop: true, verbose: true)
  #         FileUtils.cp_r('src3', 'dest3', noop: true, verbose: true)
  #
  #     Output:
  #
  #         cp -r src0.txt dest0.txt
  #         cp -r src1.txt dest1
  #         cp -r src2 dest2
  #         cp -r src3 dest3
  #
  # Raises an exception of `src` is the path to a directory and `dest` is the path
  # to a file.
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.cp_r: (pathlist src, path dest, ?preserve: boolish, ?noop: boolish, ?verbose: boolish, ?dereference_root: boolish, ?remove_destination: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - have_option?(mid, opt)
  # -->
  # Returns `true` if method `mid` accepts the given option `opt`, `false`
  # otherwise; the arguments may be strings or symbols:
  #
  #     FileUtils.have_option?(:chmod, :noop) # => true
  #     FileUtils.have_option?('chmod', 'secure') # => false
  #
  def self.have_option?: (Symbol mid, Symbol opt) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)
  # -->
  # Copies a file entry. See
  # [install(1)](https://man7.org/linux/man-pages/man1/install.1.html).
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments);
  #
  # If the entry at `dest` does not exist, copies from `src` to `dest`:
  #
  #     File.read('src0.txt')    # => "aaa\n"
  #     File.exist?('dest0.txt') # => false
  #     FileUtils.install('src0.txt', 'dest0.txt')
  #     File.read('dest0.txt')   # => "aaa\n"
  #
  # If `dest` is a file entry, copies from `src` to `dest`, overwriting:
  #
  #     File.read('src1.txt')  # => "aaa\n"
  #     File.read('dest1.txt') # => "bbb\n"
  #     FileUtils.install('src1.txt', 'dest1.txt')
  #     File.read('dest1.txt') # => "aaa\n"
  #
  # If `dest` is a directory entry, copies from `src` to `dest/src`, overwriting
  # if necessary:
  #
  #     File.read('src2.txt')       # => "aaa\n"
  #     File.read('dest2/src2.txt') # => "bbb\n"
  #     FileUtils.install('src2.txt', 'dest2')
  #     File.read('dest2/src2.txt') # => "aaa\n"
  #
  # If `src` is an array of paths and `dest` points to a directory, copies each
  # path `path` in `src` to `dest/path`:
  #
  #     File.file?('src3.txt') # => true
  #     File.file?('src3.dat') # => true
  #     FileUtils.mkdir('dest3')
  #     FileUtils.install(['src3.txt', 'src3.dat'], 'dest3')
  #     File.file?('dest3/src3.txt') # => true
  #     File.file?('dest3/src3.dat') # => true
  #
  # Keyword arguments:
  #
  # *   `group: *group`* - changes the group if not `nil`, using
  #     [File.chown](rdoc-ref:File.chown).
  # *   `mode: *permissions`* - changes the permissions. using
  #     [File.chmod](rdoc-ref:File.chmod).
  # *   `noop: true` - does not copy entries; returns `nil`.
  # *   `owner: *owner`* - changes the owner if not `nil`, using
  #     [File.chown](rdoc-ref:File.chown).
  # *   `preserve: true` - preserve timestamps using
  #     [File.utime](rdoc-ref:File.utime).
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.install('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #         FileUtils.install('src1.txt', 'dest1.txt', noop: true, verbose: true)
  #         FileUtils.install('src2.txt', 'dest2', noop: true, verbose: true)
  #
  #     Output:
  #
  #         install -c src0.txt dest0.txt
  #         install -c src1.txt dest1.txt
  #         install -c src2.txt dest2
  #
  # Related: [methods for copying](rdoc-ref:FileUtils@Copying).
  #
  def self?.install: (path src, path dest, ?mode: mode?, ?owner: String?, ?group: String?, ?preserve: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link_entry(src, dest, dereference_root = false, remove_destination = false)
  # -->
  # Creates [hard links](https://en.wikipedia.org/wiki/Hard_link); returns `nil`.
  #
  # Arguments `src` and `dest` should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` is the path to a file and `dest` does not exist, creates a hard link
  # at `dest` pointing to `src`:
  #
  #     FileUtils.touch('src0.txt')
  #     File.exist?('dest0.txt') # => false
  #     FileUtils.link_entry('src0.txt', 'dest0.txt')
  #     File.file?('dest0.txt')  # => true
  #
  # If `src` is the path to a directory and `dest` does not exist, recursively
  # creates hard links at `dest` pointing to paths in `src`:
  #
  #     FileUtils.mkdir_p(['src1/dir0', 'src1/dir1'])
  #     src_file_paths = [
  #       'src1/dir0/t0.txt',
  #       'src1/dir0/t1.txt',
  #       'src1/dir1/t2.txt',
  #       'src1/dir1/t3.txt',
  #       ]
  #     FileUtils.touch(src_file_paths)
  #     File.directory?('dest1')        # => true
  #     FileUtils.link_entry('src1', 'dest1')
  #     File.file?('dest1/dir0/t0.txt') # => true
  #     File.file?('dest1/dir0/t1.txt') # => true
  #     File.file?('dest1/dir1/t2.txt') # => true
  #     File.file?('dest1/dir1/t3.txt') # => true
  #
  # Keyword arguments:
  #
  # *   `dereference_root: true` - dereferences `src` if it is a symbolic link.
  # *   `remove_destination: true` - removes `dest` before creating links.
  #
  # Raises an exception if `dest` is the path to an existing file or directory and
  # keyword argument `remove_destination: true` is not given.
  #
  # Related: FileUtils.ln (has different options).
  #
  def self?.link_entry: (path src, path dest, ?boolish dereference_root, ?boolish remove_destination) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - ln(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  # Creates [hard links](https://en.wikipedia.org/wiki/Hard_link).
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # When `src` is the path to an existing file and `dest` is the path to a
  # non-existent file, creates a hard link at `dest` pointing to `src`; returns
  # zero:
  #
  #     Dir.children('tmp0/')                    # => ["t.txt"]
  #     Dir.children('tmp1/')                    # => []
  #     FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # => 0
  #     Dir.children('tmp1/')                    # => ["t.lnk"]
  #
  # When `src` is the path to an existing file and `dest` is the path to an
  # existing directory, creates a hard link at `dest/src` pointing to `src`;
  # returns zero:
  #
  #     Dir.children('tmp2')               # => ["t.dat"]
  #     Dir.children('tmp3')               # => []
  #     FileUtils.ln('tmp2/t.dat', 'tmp3') # => 0
  #     Dir.children('tmp3')               # => ["t.dat"]
  #
  # When `src` is an array of paths to existing files and `dest` is the path to an
  # existing directory, then for each path `target` in `src`, creates a hard link
  # at `dest/target` pointing to `target`; returns `src`:
  #
  #     Dir.children('tmp4/')                               # => []
  #     FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # => ["tmp0/t.txt", "tmp2/t.dat"]
  #     Dir.children('tmp4/')                               # => ["t.dat", "t.txt"]
  #
  # Keyword arguments:
  #
  # *   `force: true` - overwrites `dest` if it exists.
  # *   `noop: true` - does not create links.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
  #         FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
  #         FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
  #
  #     Output:
  #
  #         ln tmp0/t.txt tmp1/t.lnk
  #         ln tmp2/t.dat tmp3
  #         ln tmp0/t.txt tmp2/t.dat tmp4/
  #
  # Raises an exception if `dest` is the path to an existing file and keyword
  # argument `force` is not `true`.
  #
  # Related: FileUtils.link_entry (has different options).
  #
  def self?.ln: (pathlist src, path dest, ?force: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.link self.ln

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias link ln

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - ln_s(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)
  # -->
  # Creates [symbolic links](https://en.wikipedia.org/wiki/Symbolic_link).
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` is the path to an existing file:
  #
  # *   When `dest` is the path to a non-existent file, creates a symbolic link at
  #     `dest` pointing to `src`:
  #
  #         FileUtils.touch('src0.txt')
  #         File.exist?('dest0.txt')   # => false
  #         FileUtils.ln_s('src0.txt', 'dest0.txt')
  #         File.symlink?('dest0.txt') # => true
  #
  # *   When `dest` is the path to an existing file, creates a symbolic link at
  #     `dest` pointing to `src` if and only if keyword argument `force: true` is
  #     given (raises an exception otherwise):
  #
  #         FileUtils.touch('src1.txt')
  #         FileUtils.touch('dest1.txt')
  #         FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
  #         FileTest.symlink?('dest1.txt') # => true
  #
  #         FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
  #
  # If `dest` is the path to a directory, creates a symbolic link at `dest/src`
  # pointing to `src`:
  #
  #     FileUtils.touch('src2.txt')
  #     FileUtils.mkdir('destdir2')
  #     FileUtils.ln_s('src2.txt', 'destdir2')
  #     File.symlink?('destdir2/src2.txt') # => true
  #
  # If `src` is an array of paths to existing files and `dest` is a directory, for
  # each child `child` in `src` creates a symbolic link `dest/child` pointing to
  # `child`:
  #
  #     FileUtils.mkdir('srcdir3')
  #     FileUtils.touch('srcdir3/src0.txt')
  #     FileUtils.touch('srcdir3/src1.txt')
  #     FileUtils.mkdir('destdir3')
  #     FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
  #     File.symlink?('destdir3/src0.txt') # => true
  #     File.symlink?('destdir3/src1.txt') # => true
  #
  # Keyword arguments:
  #
  # *   `force: true` - overwrites `dest` if it exists.
  # *   `relative: false` - create links relative to `dest`.
  # *   `noop: true` - does not create links.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
  #         FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
  #         FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
  #         FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
  #
  #     Output:
  #
  #         ln -s src0.txt dest0.txt
  #         ln -s src1.txt destdir1
  #         ln -sf src2.txt dest2.txt
  #         ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3
  #
  # Related: FileUtils.ln_sf.
  #
  def self?.ln_s: (pathlist src, path dest, ?force: boolish, ?relative: boolish, ?target_directory: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - symlink(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)
  # -->
  #
  alias self.symlink self.ln_s

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - symlink(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)
  # -->
  #
  alias symlink ln_s

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - ln_sf(src, dest, noop: nil, verbose: nil)
  # -->
  # Like FileUtils.ln_s, but always with keyword argument `force: true` given.
  #
  def self?.ln_sf: (pathlist src, path dest, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - ln_sr(src, dest, target_directory: true, force: nil, noop: nil, verbose: nil)
  # -->
  # Like FileUtils.ln_s, but create links relative to `dest`.
  #
  def self?.ln_sr: (pathlist src, path dest, ?target_directory: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkdir(list, mode: nil, noop: nil, verbose: nil)
  # -->
  # Creates directories at the paths in the given `list` (a single path or an
  # array of paths); returns `list` if it is an array, `[list]` otherwise.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # With no keyword arguments, creates a directory at each `path` in `list` by
  # calling: `Dir.mkdir(path, mode)`; see [Dir.mkdir](rdoc-ref:Dir.mkdir):
  #
  #     FileUtils.mkdir(%w[tmp0 tmp1]) # => ["tmp0", "tmp1"]
  #     FileUtils.mkdir('tmp4')        # => ["tmp4"]
  #
  # Keyword arguments:
  #
  # *   `mode: *mode`* - also calls `File.chmod(mode, path)`; see
  #     [File.chmod](rdoc-ref:File.chmod).
  # *   `noop: true` - does not create directories.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.mkdir(%w[tmp0 tmp1], verbose: true)
  #         FileUtils.mkdir(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #     Output:
  #
  #         mkdir tmp0 tmp1
  #         mkdir -m 700 tmp2 tmp3
  #
  # Raises an exception if any path points to an existing file or directory, or if
  # for any reason a directory cannot be created.
  #
  # Related: FileUtils.mkdir_p.
  #
  def self?.mkdir: (pathlist list, ?mode: Integer?, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  # -->
  # Creates directories at the paths in the given `list` (a single path or an
  # array of paths), also creating ancestor directories as needed; returns `list`
  # if it is an array, `[list]` otherwise.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # With no keyword arguments, creates a directory at each `path` in `list`, along
  # with any needed ancestor directories, by calling: `Dir.mkdir(path, mode)`; see
  # [Dir.mkdir](rdoc-ref:Dir.mkdir):
  #
  #     FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #     FileUtils.mkdir_p('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # *   `mode: *mode`* - also calls `File.chmod(mode, path)`; see
  #     [File.chmod](rdoc-ref:File.chmod).
  # *   `noop: true` - does not create directories.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
  #         FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
  #
  #     Output:
  #
  #         mkdir -p tmp0 tmp1
  #         mkdir -p -m 700 tmp2 tmp3
  #
  # Raises an exception if for any reason a directory cannot be created.
  #
  # FileUtils.mkpath and FileUtils.makedirs are aliases for FileUtils.mkdir_p.
  #
  # Related: FileUtils.mkdir.
  #
  def self?.mkdir_p: (pathlist list, ?mode: mode?, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - makedirs(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.makedirs self.mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - makedirs(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias makedirs mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkpath(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.mkpath self.mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkpath(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias mkpath mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  # Moves entries.
  #
  # Arguments `src` (a single path or an array of paths) and `dest` (a single
  # path) should be [interpretable as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # If `src` and `dest` are on different file systems, first copies, then removes
  # `src`.
  #
  # May cause a local vulnerability if not called with keyword argument `secure:
  # true`; see [Avoiding the TOCTTOU
  # Vulnerability](rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability).
  #
  # If `src` is the path to a single file or directory and `dest` does not exist,
  # moves `src` to `dest`:
  #
  #     tree('src0')
  #     # => src0
  #     #    |-- src0.txt
  #     #    `-- src1.txt
  #     File.exist?('dest0') # => false
  #     FileUtils.mv('src0', 'dest0')
  #     File.exist?('src0')  # => false
  #     tree('dest0')
  #     # => dest0
  #     #    |-- src0.txt
  #     #    `-- src1.txt
  #
  # If `src` is an array of paths to files and directories and `dest` is the path
  # to a directory, copies from each path in the array to `dest`:
  #
  #     File.file?('src1.txt') # => true
  #     tree('src1')
  #     # => src1
  #     #    |-- src.dat
  #     #    `-- src.txt
  #     Dir.empty?('dest1')    # => true
  #     FileUtils.mv(['src1.txt', 'src1'], 'dest1')
  #     tree('dest1')
  #     # => dest1
  #     #    |-- src1
  #     #    |   |-- src.dat
  #     #    |   `-- src.txt
  #     #    `-- src1.txt
  #
  # Keyword arguments:
  #
  # *   `force: true` - if the move includes removing `src` (that is, if `src` and
  #     `dest` are on different file systems), ignores raised exceptions of
  #     StandardError and its descendants.
  # *   `noop: true` - does not move files.
  # *   `secure: true` - removes `src` securely; see details at
  #     FileUtils.remove_entry_secure.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
  #         FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
  #
  #     Output:
  #
  #         mv src0 dest0
  #         mv src1.txt src1 dest1
  #
  def self?.mv: (pathlist src, path dest, ?force: boolish, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - move(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias self.move self.mv

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - move(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias move mv

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - options()
  # -->
  # Returns an array of the string keyword names:
  #
  #     FileUtils.options.take(3) # => ["noop", "verbose", "force"]
  #
  def self.options: () -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - options_of(mid)
  # -->
  # Returns an array of the string keyword name for method `mid`; the argument may
  # be a string or a symbol:
  #
  #     FileUtils.options_of(:rm) # => ["force", "noop", "verbose"]
  #     FileUtils.options_of('mv') # => ["force", "noop", "verbose", "secure"]
  #
  def self.options_of: (Symbol mid) -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - pwd()
  # -->
  # Returns a string containing the path to the current directory:
  #
  #     FileUtils.pwd # => "/rdoc/fileutils"
  #
  # Related: FileUtils.cd.
  #
  def self?.pwd: () -> String

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - getwd()
  # -->
  #
  alias self.getwd self.pwd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - getwd()
  # -->
  #
  alias getwd pwd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_dir(path, force = false)
  # -->
  # Recursively removes the directory entry given by `path`, which should be the
  # entry for a regular file, a symbolic link, or a directory.
  #
  # Argument `path` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Optional argument `force` specifies whether to ignore raised exceptions of
  # StandardError and its descendants.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.remove_dir: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_entry(path, force = false)
  # -->
  # Removes the entry given by `path`, which should be the entry for a regular
  # file, a symbolic link, or a directory.
  #
  # Argument `path` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Optional argument `force` specifies whether to ignore raised exceptions of
  # StandardError and its descendants.
  #
  # Related: FileUtils.remove_entry_secure.
  #
  def self?.remove_entry: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_entry_secure(path, force = false)
  # -->
  # Securely removes the entry given by `path`, which should be the entry for a
  # regular file, a symbolic link, or a directory.
  #
  # Argument `path` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Avoids a local vulnerability that can exist in certain circumstances; see
  # [Avoiding the TOCTTOU
  # Vulnerability](rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability).
  #
  # Optional argument `force` specifies whether to ignore raised exceptions of
  # StandardError and its descendants.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.remove_entry_secure: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_file(path, force = false)
  # -->
  # Removes the file entry given by `path`, which should be the entry for a
  # regular file or a symbolic link.
  #
  # Argument `path` should be [interpretable as a
  # path](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Optional argument `force` specifies whether to ignore raised exceptions of
  # StandardError and its descendants.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.remove_file: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm(list, force: nil, noop: nil, verbose: nil)
  # -->
  # Removes entries at the paths in the given `list` (a single path or an array of
  # paths) returns `list`, if it is an array, `[list]` otherwise.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # With no keyword arguments, removes files at the paths given in `list`:
  #
  #     FileUtils.touch(['src0.txt', 'src0.dat'])
  #     FileUtils.rm(['src0.dat', 'src0.txt']) # => ["src0.dat", "src0.txt"]
  #
  # Keyword arguments:
  #
  # *   `force: true` - ignores raised exceptions of StandardError and its
  #     descendants.
  # *   `noop: true` - does not remove files; returns `nil`.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
  #
  #     Output:
  #
  #         rm src0.dat src0.txt
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.rm: (pathlist list, ?force: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove(list, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.remove self.rm

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove(list, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias remove rm

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_f(list, noop: nil, verbose: nil)
  # -->
  # Equivalent to:
  #
  #     FileUtils.rm(list, force: true, **kwargs)
  #
  # Argument `list` (a single path or an array of paths) should be [interpretable
  # as paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # See FileUtils.rm for keyword arguments.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.rm_f: (pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - safe_unlink(list, noop: nil, verbose: nil)
  # -->
  #
  alias self.safe_unlink self.rm_f

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - safe_unlink(list, noop: nil, verbose: nil)
  # -->
  #
  alias safe_unlink rm_f

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  # Removes entries at the paths in the given `list` (a single path or an array of
  # paths); returns `list`, if it is an array, `[list]` otherwise.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # May cause a local vulnerability if not called with keyword argument `secure:
  # true`; see [Avoiding the TOCTTOU
  # Vulnerability](rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability).
  #
  # For each file path, removes the file at that path:
  #
  #     FileUtils.touch(['src0.txt', 'src0.dat'])
  #     FileUtils.rm_r(['src0.dat', 'src0.txt'])
  #     File.exist?('src0.txt') # => false
  #     File.exist?('src0.dat') # => false
  #
  # For each directory path, recursively removes files and directories:
  #
  #     tree('src1')
  #     # => src1
  #     #    |-- dir0
  #     #    |   |-- src0.txt
  #     #    |   `-- src1.txt
  #     #    `-- dir1
  #     #        |-- src2.txt
  #     #        `-- src3.txt
  #     FileUtils.rm_r('src1')
  #     File.exist?('src1') # => false
  #
  # Keyword arguments:
  #
  # *   `force: true` - ignores raised exceptions of StandardError and its
  #     descendants.
  # *   `noop: true` - does not remove entries; returns `nil`.
  # *   `secure: true` - removes `src` securely; see details at
  #     FileUtils.remove_entry_secure.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.rm_r(['src0.dat', 'src0.txt'], noop: true, verbose: true)
  #         FileUtils.rm_r('src1', noop: true, verbose: true)
  #
  #     Output:
  #
  #         rm -r src0.dat src0.txt
  #         rm -r src1
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.rm_r: (pathlist list, ?force: boolish, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_rf(list, noop: nil, verbose: nil, secure: nil)
  # -->
  # Equivalent to:
  #
  #     FileUtils.rm_r(list, force: true, **kwargs)
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # May cause a local vulnerability if not called with keyword argument `secure:
  # true`; see [Avoiding the TOCTTOU
  # Vulnerability](rdoc-ref:FileUtils@Avoiding+the+TOCTTOU+Vulnerability).
  #
  # See FileUtils.rm_r for keyword arguments.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.rm_rf: (pathlist list, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmtree(list, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias self.rmtree self.rm_rf

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmtree(list, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias rmtree rm_rf

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmdir(list, parents: nil, noop: nil, verbose: nil)
  # -->
  # Removes directories at the paths in the given `list` (a single path or an
  # array of paths); returns `list`, if it is an array, `[list]` otherwise.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # With no keyword arguments, removes the directory at each `path` in `list`, by
  # calling: `Dir.rmdir(path)`; see [Dir.rmdir](rdoc-ref:Dir.rmdir):
  #
  #     FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3]) # => ["tmp0/tmp1", "tmp2/tmp3"]
  #     FileUtils.rmdir('tmp4/tmp5')             # => ["tmp4/tmp5"]
  #
  # Keyword arguments:
  #
  # *   `parents: true` - removes successive ancestor directories if empty.
  # *   `noop: true` - does not remove directories.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3], parents: true, verbose: true)
  #         FileUtils.rmdir('tmp4/tmp5', parents: true, verbose: true)
  #
  #     Output:
  #
  #         rmdir -p tmp0/tmp1 tmp2/tmp3
  #         rmdir -p tmp4/tmp5
  #
  # Raises an exception if a directory does not exist or if for any reason a
  # directory cannot be removed.
  #
  # Related: [methods for deleting](rdoc-ref:FileUtils@Deleting).
  #
  def self?.rmdir: (pathlist list, ?parents: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  # -->
  # Updates modification times (mtime) and access times (atime) of the entries
  # given by the paths in `list` (a single path or an array of paths); returns
  # `list` if it is an array, `[list]` otherwise.
  #
  # By default, creates an empty file for any path to a non-existent entry; use
  # keyword argument `nocreate` to raise an exception instead.
  #
  # Argument `list` or its elements should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments).
  #
  # Examples:
  #
  #     # Single path.
  #     f = File.new('src0.txt') # Existing file.
  #     f.atime # => 2022-06-10 11:11:21.200277 -0700
  #     f.mtime # => 2022-06-10 11:11:21.200277 -0700
  #     FileUtils.touch('src0.txt')
  #     f = File.new('src0.txt')
  #     f.atime # => 2022-06-11 08:28:09.8185343 -0700
  #     f.mtime # => 2022-06-11 08:28:09.8185343 -0700
  #
  #     # Array of paths.
  #     FileUtils.touch(['src0.txt', 'src0.dat'])
  #
  # Keyword arguments:
  #
  # *   `mtime: *time`* - sets the entry's mtime to the given time, instead of the
  #     current time.
  # *   `nocreate: true` - raises an exception if the entry does not exist.
  # *   `noop: true` - does not touch entries; returns `nil`.
  # *   `verbose: true` - prints an equivalent command:
  #
  #         FileUtils.touch('src0.txt', noop: true, verbose: true)
  #         FileUtils.touch(['src0.txt', 'src0.dat'], noop: true, verbose: true)
  #         FileUtils.touch(path, noop: true, verbose: true)
  #
  #     Output:
  #
  #         touch src0.txt
  #         touch src0.txt src0.dat
  #         touch src0.txt
  #
  # Related: FileUtils.uptodate?.
  #
  def self?.touch: (pathlist list, ?noop: boolish, ?verbose: boolish, ?mtime: (Time | Numeric)?, ?nocreate: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - uptodate?(new, old_list)
  # -->
  # Returns `true` if the file at path `new` is newer than all the files at paths
  # in array `old_list`; `false` otherwise.
  #
  # Argument `new` and the elements of `old_list` should be [interpretable as
  # paths](rdoc-ref:FileUtils@Path+Arguments):
  #
  #     FileUtils.uptodate?('Rakefile', ['Gemfile', 'README.md']) # => true
  #     FileUtils.uptodate?('Gemfile', ['Rakefile', 'README.md']) # => false
  #
  # A non-existent file is considered to be infinitely old.
  #
  # Related: FileUtils.touch.
  #
  def self?.uptodate?: (path new, _Each[path] old_list) -> bool
end
# <!-- rdoc-file=lib/find.rb -->
# The `Find` module supports the top-down traversal of a set of file paths.
#
# For example, to total the size of all files under your home directory,
# ignoring anything in a "dot" directory (e.g. $HOME/.ssh):
#
#     require 'find'
#
#     total_size = 0
#
#     Find.find(ENV["HOME"]) do |path|
#       if FileTest.directory?(path)
#         if File.basename(path).start_with?('.')
#           Find.prune       # Don't look any further into this directory.
#         else
#           next
#         end
#       else
#         total_size += FileTest.size(path)
#       end
#     end
#
module Find
  # <!--
  #   rdoc-file=lib/find.rb
  #   - find(*paths, ignore_error: true) { |path| ... }
  # -->
  # Calls the associated block with the name of every file and directory listed as
  # arguments, then recursively on their subdirectories, and so on.
  #
  # Returns an enumerator if no block is given.
  #
  # See the `Find` module documentation for an example.
  #
  def self?.find: (*String | _ToPath paths, ?ignore_error: boolish) -> Enumerator[String, nil]
                | (*String | _ToPath paths, ?ignore_error: boolish) { (String) -> void } -> nil

  # <!--
  #   rdoc-file=lib/find.rb
  #   - prune()
  # -->
  # Skips the current file or directory, restarting the loop with the next entry.
  # If the current file is a directory, that directory will not be recursively
  # entered. Meaningful only within the block associated with Find::find.
  #
  # See the `Find` module documentation for an example.
  #
  def self?.prune: () -> void
end
# <!-- rdoc-file=lib/forwardable.rb -->
# The Forwardable module provides delegation of specified methods to a
# designated object, using the methods #def_delegator and #def_delegators.
#
# For example, say you have a class RecordCollection which contains an array
# `@records`.  You could provide the lookup method #record_number(), which
# simply calls #[] on the `@records` array, like this:
#
#     require 'forwardable'
#
#     class RecordCollection
#       attr_accessor :records
#       extend Forwardable
#       def_delegator :@records, :[], :record_number
#     end
#
# We can use the lookup method like so:
#
#     r = RecordCollection.new
#     r.records = [4,5,6]
#     r.record_number(0)  # => 4
#
# Further, if you wish to provide the methods #size, #<<, and #map, all of which
# delegate to @records, this is how you can do it:
#
#     class RecordCollection # re-open RecordCollection class
#       def_delegators :@records, :size, :<<, :map
#     end
#
#     r = RecordCollection.new
#     r.records = [1,2,3]
#     r.record_number(0)   # => 1
#     r.size               # => 3
#     r << 4               # => [1, 2, 3, 4]
#     r.map { |x| x * 2 }  # => [2, 4, 6, 8]
#
# You can even extend regular objects with Forwardable.
#
#     my_hash = Hash.new
#     my_hash.extend Forwardable              # prepare object for delegation
#     my_hash.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
#     my_hash.puts "Howdy!"
#
# ## Another example
#
# You could use Forwardable as an alternative to inheritance, when you don't
# want to inherit all methods from the superclass. For instance, here is how you
# might add a range of `Array` instance methods to a new class `Queue`:
#
#     class Queue
#       extend Forwardable
#
#       def initialize
#         @q = [ ]    # prepare delegate object
#       end
#
#       # setup preferred interface, enq() and deq()...
#       def_delegator :@q, :push, :enq
#       def_delegator :@q, :shift, :deq
#
#       # support some general Array methods that fit Queues well
#       def_delegators :@q, :clear, :first, :push, :shift, :size
#     end
#
#     q = Thread::Queue.new
#     q.enq 1, 2, 3, 4, 5
#     q.push 6
#
#     q.shift    # => 1
#     while q.size > 0
#       puts q.deq
#     end
#
#     q.enq "Ruby", "Perl", "Python"
#     puts q.first
#     q.clear
#     puts q.first
#
# This should output:
#
#     2
#     3
#     4
#     5
#     6
#     Ruby
#     nil
#
# ## Notes
#
# Be advised, RDoc will not detect delegated methods.
#
# `forwardable.rb` provides single-method delegation via the def_delegator and
# def_delegators methods. For full-class delegation via DelegateClass, see
# `delegate.rb`.
#
module Forwardable
  # <!-- rdoc-file=lib/forwardable.rb -->
  # Version of `forwardable.rb`
  #
  VERSION: String

  FORWARDABLE_VERSION: String

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate method => accessor
  #   - delegate [method, method, ...] => accessor
  # -->
  # Takes a hash as its argument.  The key is a symbol or an array of symbols.
  # These symbols correspond to method names, instance variable names, or constant
  # names (see def_delegator).  The value is the accessor to which the methods
  # will be delegated.
  #
  def instance_delegate: (Hash[Symbol | Array[Symbol], Symbol] hash) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate(hash)
  # -->
  #
  alias delegate instance_delegate

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_instance_delegators(accessor, *methods)
  # -->
  # Shortcut for defining multiple delegator methods, but with no provision for
  # using a different name.  The following two code samples have the same effect:
  #
  #     def_delegators :@records, :size, :<<, :map
  #
  #     def_delegator :@records, :size
  #     def_delegator :@records, :<<
  #     def_delegator :@records, :map
  #
  def def_instance_delegators: (interned accessor, *Symbol methods) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegators(accessor, *methods)
  # -->
  #
  alias def_delegators def_instance_delegators

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_instance_delegator(accessor, method, ali = method)
  # -->
  # Define `method` as delegator instance method with an optional alias name
  # `ali`. Method calls to `ali` will be delegated to `accessor.method`.
  # `accessor` should be a method name, instance variable name, or constant name.
  # Use the full path to the constant if providing the constant name. Returns the
  # name of the method defined.
  #
  #     class MyQueue
  #       CONST = 1
  #       extend Forwardable
  #       attr_reader :queue
  #       def initialize
  #         @queue = []
  #       end
  #
  #       def_delegator :@queue, :push, :mypush
  #       def_delegator 'MyQueue::CONST', :to_i
  #     end
  #
  #     q = MyQueue.new
  #     q.mypush 42
  #     q.queue    #=> [42]
  #     q.push 23  #=> NoMethodError
  #     q.to_i     #=> 1
  #
  def def_instance_delegator: (interned accessor, Symbol method, ?Symbol ali) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegator(accessor, method, ali = method)
  # -->
  #
  alias def_delegator def_instance_delegator
end

# <!-- rdoc-file=lib/forwardable.rb -->
# SingleForwardable can be used to setup delegation at the object level as well.
#
#     printer = String.new
#     printer.extend SingleForwardable        # prepare object for delegation
#     printer.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
#     printer.puts "Howdy!"
#
# Also, SingleForwardable can be used to set up delegation for a Class or
# Module.
#
#     class Implementation
#       def self.service
#         puts "serviced!"
#       end
#     end
#
#     module Facade
#       extend SingleForwardable
#       def_delegator :Implementation, :service
#     end
#
#     Facade.service #=> serviced!
#
# If you want to use both Forwardable and SingleForwardable, you can use methods
# def_instance_delegator and def_single_delegator, etc.
#
module SingleForwardable
  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate method => accessor
  #   - delegate [method, method, ...] => accessor
  # -->
  # Takes a hash as its argument.  The key is a symbol or an array of symbols.
  # These symbols correspond to method names.  The value is the accessor to which
  # the methods will be delegated.
  #
  def single_delegate: (Hash[Symbol | Array[Symbol], Symbol] hash) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate(hash)
  # -->
  #
  alias delegate single_delegate

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_single_delegators(accessor, *methods)
  # -->
  # Shortcut for defining multiple delegator methods, but with no provision for
  # using a different name.  The following two code samples have the same effect:
  #
  #     def_delegators :@records, :size, :<<, :map
  #
  #     def_delegator :@records, :size
  #     def_delegator :@records, :<<
  #     def_delegator :@records, :map
  #
  def def_single_delegators: (interned accessor, *Symbol methods) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegators(accessor, *methods)
  # -->
  #
  alias def_delegators def_single_delegators

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_single_delegator(accessor, method, new_name=method)
  # -->
  # Defines a method *method* which delegates to *accessor* (i.e. it calls the
  # method of the same name in *accessor*).  If *new_name* is provided, it is used
  # as the name for the delegate method. Returns the name of the method defined.
  #
  def def_single_delegator: (interned accessor, Symbol method, ?Symbol ali) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegator(accessor, method, ali = method)
  # -->
  #
  alias def_delegator def_single_delegator
end
%a{annotate:rdoc:skip}
class IO
  class ConsoleMode
    def echo=: (bool) -> bool
    def raw: (?min: int, ?time: int, ?intr: bool) -> self
    def raw!: (?min: int, ?time: int, ?intr: bool) -> self
  end

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - IO.console      -> #<File:/dev/tty>
  #   - IO.console(sym, *args)
  # -->
  # Returns an File instance opened console.
  #
  # If `sym` is given, it will be sent to the opened console with `args` and the
  # result will be returned instead of the console IO itself.
  #
  # You must require 'io/console' to use this method.
  #
  def self.console: () -> File?
                  | (:close) -> nil
                  | (Symbol sym, *untyped args) -> untyped

  # <!--
  #   rdoc-file=ext/io/console/lib/console/size.rb
  #   - console_size()
  # -->
  #
  def self.console_size: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/lib/console/size.rb
  #   - default_console_size()
  # -->
  # fallback to console window size
  #
  def self.default_console_size: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.beep
  # -->
  # Beeps on the output console.
  #
  # You must require 'io/console' to use this method.
  #
  def beep: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.check_winsize_changed { ... }   -> io
  # -->
  # Yields while console input events are queued.
  #
  # This method is Windows only.
  #
  # You must require 'io/console' to use this method.
  #
  def check_winsize_changed: () { () -> void } -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.clear_screen            -> io
  # -->
  # Clears the entire screen and moves the cursor top-left corner.
  #
  # You must require 'io/console' to use this method.
  #
  def clear_screen: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.console_mode       -> mode
  # -->
  # Returns a data represents the current console mode.
  #
  # You must require 'io/console' to use this method.
  #
  def console_mode: () -> IO::ConsoleMode

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.console_mode = mode
  # -->
  # Sets the console mode to `mode`.
  #
  # You must require 'io/console' to use this method.
  #
  def console_mode=: (IO::ConsoleMode mode) -> IO::ConsoleMode

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cooked {|io| }
  # -->
  # Yields `self` within cooked mode.
  #
  #     STDIN.cooked(&:gets)
  #
  # will read and return a line with echo back and line editing.
  #
  # You must require 'io/console' to use this method.
  #
  def cooked: [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cooked!
  # -->
  # Enables cooked mode.
  #
  # If the terminal mode needs to be back, use io.cooked { ... }.
  #
  # You must require 'io/console' to use this method.
  #
  def cooked!: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor -> [row, column]
  # -->
  # Returns the current cursor position as a two-element array of integers (row,
  # column)
  #
  #     io.cursor # => [3, 5]
  #
  # You must require 'io/console' to use this method.
  #
  def cursor: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor = [line, column]         -> io
  # -->
  # Same as `io.goto(line, column)`
  #
  # See IO#goto.
  #
  # You must require 'io/console' to use this method.
  #
  def cursor=: ([ Integer, Integer ]) -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor_down(n)          -> io
  # -->
  # Moves the cursor down `n` lines.
  #
  # You must require 'io/console' to use this method.
  #
  def cursor_down: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor_left(n)          -> io
  # -->
  # Moves the cursor left `n` columns.
  #
  # You must require 'io/console' to use this method.
  #
  def cursor_left: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor_right(n)         -> io
  # -->
  # Moves the cursor right `n` columns.
  #
  # You must require 'io/console' to use this method.
  #
  def cursor_right: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cursor_up(n)            -> io
  # -->
  # Moves the cursor up `n` lines.
  #
  # You must require 'io/console' to use this method.
  #
  def cursor_up: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.echo = flag
  # -->
  # Enables/disables echo back. On some platforms, all combinations of this flags
  # and raw/cooked mode may not be valid.
  #
  # You must require 'io/console' to use this method.
  #
  def echo=: (bool flag) -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.echo?       -> true or false
  # -->
  # Returns `true` if echo back is enabled.
  #
  # You must require 'io/console' to use this method.
  #
  def echo?: () -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.erase_line(mode)        -> io
  # -->
  # Erases the line at the cursor corresponding to `mode`. `mode` may be either:
  # 0: after cursor 1: before and cursor 2: entire line
  #
  # You must require 'io/console' to use this method.
  #
  def erase_line: (0 | 1 | 2 | nil) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.erase_screen(mode)      -> io
  # -->
  # Erases the screen at the cursor corresponding to `mode`. `mode` may be either:
  # 0: after cursor 1: before and cursor 2: entire screen
  #
  # You must require 'io/console' to use this method.
  #
  def erase_screen: (0 | 1 | 2 | 3 | nil) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.getch(min: nil, time: nil, intr: nil) -> char
  # -->
  # Reads and returns a character in raw mode.
  #
  # See IO#raw for details on the parameters.
  #
  # You must require 'io/console' to use this method.
  #
  def getch: (?min: int, ?time: int, ?intr: bool) -> String

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.getpass(prompt=nil)       -> string
  # -->
  # Reads and returns a line without echo back. Prints `prompt` unless it is
  # `nil`.
  #
  # The newline character that terminates the read line is removed from the
  # returned string, see String#chomp!.
  #
  # You must require 'io/console' to use this method.
  #
  #     require 'io/console'
  #     IO::console.getpass("Enter password:")
  #     Enter password:
  #     # => "mypassword"
  #
  def getpass: (?String) -> String

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.goto(line, column)      -> io
  # -->
  # Set the cursor position at `line` and `column`.
  #
  # You must require 'io/console' to use this method.
  #
  def goto: (int, int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.goto_column(column)     -> io
  # -->
  # Set the cursor position at `column` in the same line of the current position.
  #
  # You must require 'io/console' to use this method.
  #
  def goto_column: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.iflush
  # -->
  # Flushes input buffer in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def iflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.ioflush
  # -->
  # Flushes input and output buffers in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def ioflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.noecho {|io| }
  # -->
  # Yields `self` with disabling echo back.
  #
  #     STDIN.noecho(&:gets)
  #
  # will read and return a line without echo back.
  #
  # You must require 'io/console' to use this method.
  #
  def noecho: [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.oflush
  # -->
  # Flushes output buffer in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def oflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.pressed?(key)   -> bool
  # -->
  # Returns `true` if `key` is pressed.  `key` may be a virtual key code or its
  # name (String or Symbol) with out "VK_" prefix.
  #
  # This method is Windows only.
  #
  # You must require 'io/console' to use this method.
  #
  def pressed?: (Integer | interned) -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.raw(min: nil, time: nil, intr: nil) {|io| }
  # -->
  # Yields `self` within raw mode, and returns the result of the block.
  #
  #     STDIN.raw(&:gets)
  #
  # will read and return a line without echo back and line editing.
  #
  # The parameter `min` specifies the minimum number of bytes that should be
  # received when a read operation is performed. (default: 1)
  #
  # The parameter `time` specifies the timeout in *seconds* with a precision of
  # 1/10 of a second. (default: 0)
  #
  # If the parameter `intr` is `true`, enables break, interrupt, quit, and suspend
  # special characters.
  #
  # Refer to the manual page of termios for further details.
  #
  # You must require 'io/console' to use this method.
  #
  def raw: [T] (?min: int, ?time: int, ?intr: bool) { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.raw!(min: nil, time: nil, intr: nil) -> io
  # -->
  # Enables raw mode, and returns `io`.
  #
  # If the terminal mode needs to be back, use `io.raw { ... }`.
  #
  # See IO#raw for details on the parameters.
  #
  # You must require 'io/console' to use this method.
  #
  def raw!: (?min: int, ?time: int, ?intr: bool) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.scroll_backward(n)      -> io
  # -->
  # Scrolls the entire scrolls backward `n` lines.
  #
  # You must require 'io/console' to use this method.
  #
  def scroll_backward: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.scroll_forward(n)       -> io
  # -->
  # Scrolls the entire scrolls forward `n` lines.
  #
  # You must require 'io/console' to use this method.
  #
  def scroll_forward: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.winsize     -> [rows, columns]
  # -->
  # Returns console size.
  #
  # You must require 'io/console' to use this method.
  #
  def winsize: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.winsize = [rows, columns]
  # -->
  # Tries to set console size.  The effect depends on the platform and the running
  # environment.
  #
  # You must require 'io/console' to use this method.
  #
  def winsize=: ([ Integer, Integer ]) -> [ Integer, Integer ]
              | ([ Integer, Integer, Integer, Integer ]) -> [ Integer, Integer, Integer, Integer ]
end
# <!-- rdoc-file=lib/ipaddr.rb -->
# IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
# IPv6 are supported.
#
# ## Example
#
#     require 'ipaddr'
#
#     ipaddr1 = IPAddr.new "3ffe:505:2::1"
#
#     p ipaddr1                   #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>
#
#     p ipaddr1.to_s              #=> "3ffe:505:2::1"
#
#     ipaddr2 = ipaddr1.mask(48)  #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>
#
#     p ipaddr2.to_s              #=> "3ffe:505:2::"
#
#     ipaddr3 = IPAddr.new "192.168.2.0/24"
#
#     p ipaddr3                   #=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>
#
class IPAddr
  include Comparable

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - new_ntoh(addr)
  # -->
  # Creates a new ipaddr containing the given network byte ordered string form of
  # an IP address.
  #
  def self.new_ntoh: (String addr) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ntop(addr)
  # -->
  # Convert a network byte ordered string form of an IP address into human
  # readable form. It expects the string to be encoded in Encoding::ASCII_8BIT
  # (BINARY).
  #
  def self.ntop: (String addr) -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - new(addr = '::', family = Socket::AF_UNSPEC)
  # -->
  # Creates a new ipaddr object either from a human readable IP address
  # representation in string, or from a packed in_addr value followed by an
  # address family.
  #
  # In the former case, the following are the valid formats that will be
  # recognized: "address", "address/prefixlen" and "address/mask", where IPv6
  # address may be enclosed in square brackets (`[' and `]').  If a prefixlen or a
  # mask is specified, it returns a masked IP address.  Although the address
  # family is determined automatically from a specified string, you can specify
  # one explicitly by the optional second argument.
  #
  # Otherwise an IP address is generated from a packed in_addr value and an
  # address family.
  #
  # The IPAddr class defines many methods and operators, and some of those, such
  # as &, |, include? and ==, accept a string, or a packed in_addr value instead
  # of an IPAddr object.
  #
  def initialize: (?String addr, ?untyped family) -> void

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - &(other)
  # -->
  # Returns a new ipaddr built by bitwise AND.
  #
  def &: (untyped other) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - <<(num)
  # -->
  # Returns a new ipaddr built by bitwise left shift.
  #
  def <<: (Integer num) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - <=>(other)
  # -->
  # Compares the ipaddr with another.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ==(other)
  # -->
  # Returns true if two ipaddrs are equal.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ===(other)
  # -->
  #
  alias === include?

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - >>(num)
  # -->
  # Returns a new ipaddr built by bitwise right-shift.
  #
  def >>: (Integer num) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - eql?(other)
  # -->
  # Checks equality used by Hash.
  #
  def eql?: (untyped other) -> bool

  # <!-- rdoc-file=lib/ipaddr.rb -->
  # Returns the address family of this IP address.
  #
  attr_reader family: Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - hash()
  # -->
  # Returns a hash value used by Hash, Set, and Array classes
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - hton()
  # -->
  # Returns a network byte ordered string form of the IP address.
  #
  def hton: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - include?(other)
  # -->
  # Returns true if the given ipaddr is in the range.
  #
  # e.g.:
  #     require 'ipaddr'
  #     net1 = IPAddr.new("192.168.2.0/24")
  #     net2 = IPAddr.new("192.168.2.100")
  #     net3 = IPAddr.new("192.168.3.0")
  #     net4 = IPAddr.new("192.168.2.0/16")
  #     p net1.include?(net2)     #=> true
  #     p net1.include?(net3)     #=> false
  #     p net1.include?(net4)     #=> false
  #     p net4.include?(net1)     #=> true
  #
  def include?: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - inspect()
  # -->
  # Returns a string containing a human-readable representation of the ipaddr.
  # ("#<IPAddr: family:address/mask>")
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ip6_arpa()
  # -->
  # Returns a string for DNS reverse lookup compatible with RFC3172.
  #
  def ip6_arpa: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ip6_int()
  # -->
  # Returns a string for DNS reverse lookup compatible with RFC1886.
  #
  def ip6_int: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4?()
  # -->
  # Returns true if the ipaddr is an IPv4 address.
  #
  def ipv4?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_compat()
  # -->
  # Returns a new ipaddr built by converting the native IPv4 address into an
  # IPv4-compatible IPv6 address.
  #
  def ipv4_compat: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_compat?()
  # -->
  # Returns true if the ipaddr is an IPv4-compatible IPv6 address.
  #
  def ipv4_compat?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_mapped()
  # -->
  # Returns a new ipaddr built by converting the native IPv4 address into an
  # IPv4-mapped IPv6 address.
  #
  def ipv4_mapped: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_mapped?()
  # -->
  # Returns true if the ipaddr is an IPv4-mapped IPv6 address.
  #
  def ipv4_mapped?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv6?()
  # -->
  # Returns true if the ipaddr is an IPv6 address.
  #
  def ipv6?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - link_local?()
  # -->
  # Returns true if the ipaddr is a link-local address.  IPv4 addresses in
  # 169.254.0.0/16 reserved by RFC 3927 and link-local IPv6 Unicast Addresses in
  # fe80::/10 reserved by RFC 4291 are considered link-local. Link-local IPv4
  # addresses in the IPv4-mapped IPv6 address range are also considered
  # link-local.
  #
  def link_local?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - loopback?()
  # -->
  # Returns true if the ipaddr is a loopback address. Loopback IPv4 addresses in
  # the IPv4-mapped IPv6 address range are also considered as loopback addresses.
  #
  def loopback?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - mask(prefixlen)
  # -->
  # Returns a new ipaddr built by masking IP address with the given
  # prefixlen/netmask. (e.g. 8, 64, "255.255.255.0", etc.)
  #
  def mask: (String | Integer prefixlen) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - native()
  # -->
  # Returns a new ipaddr built by converting the IPv6 address into a native IPv4
  # address.  If the IP address is not an IPv4-mapped or IPv4-compatible IPv6
  # address, returns self.
  #
  def native: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - prefix()
  # -->
  # Returns the prefix length in bits for the ipaddr.
  #
  def prefix: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - prefix=(prefix)
  # -->
  # Sets the prefix length in bits
  #
  def prefix=: (Integer prefix) -> self

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - private?()
  # -->
  # Returns true if the ipaddr is a private address.  IPv4 addresses in
  # 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 as defined in RFC 1918 and IPv6
  # Unique Local Addresses in fc00::/7 as defined in RFC 4193 are considered
  # private. Private IPv4 addresses in the IPv4-mapped IPv6 address range are also
  # considered private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - reverse()
  # -->
  # Returns a string for DNS reverse lookup.  It returns a string in RFC3172 form
  # for an IPv6 address.
  #
  def reverse: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - succ()
  # -->
  # Returns the successor to the ipaddr.
  #
  def succ: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_i()
  # -->
  # Returns the integer representation of the ipaddr.
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_range()
  # -->
  # Creates a Range object for the network address.
  #
  def to_range: () -> Range[IPAddr]

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_s()
  # -->
  # Returns a string containing the IP address representation.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_string()
  # -->
  # Returns a string containing the IP address representation in canonical form.
  #
  def to_string: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - |(other)
  # -->
  # Returns a new ipaddr built by bitwise OR.
  #
  def |: (untyped other) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ~()
  # -->
  # Returns a new ipaddr built by bitwise negation.
  #
  def ~: () -> IPAddr
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Generic IPAddr related error. Exceptions raised in this class should inherit
# from Error.
#
class IPAddr::Error < ArgumentError
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the provided IP address is an invalid address.
#
class IPAddr::InvalidAddressError < IPAddr::Error
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the address family is invalid such as an address with an
# unsupported family, an address with an inconsistent family, or an address
# who's family cannot be determined.
#
class IPAddr::AddressFamilyError < IPAddr::Error
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the address is an invalid length.
#
class IPAddr::InvalidPrefixError < IPAddr::InvalidAddressError
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# 32 bit mask for IPv4
#
IPAddr::IN4MASK: Integer

# <!-- rdoc-file=lib/ipaddr.rb -->
# Format string for IPv6
#
IPAddr::IN6FORMAT: String

# <!-- rdoc-file=lib/ipaddr.rb -->
# 128 bit mask for IPv6
#
IPAddr::IN6MASK: Integer

# <!-- rdoc-file=lib/ipaddr.rb -->
# Regexp *internally* used for parsing IPv4 address.
#
IPAddr::RE_IPV4ADDRLIKE: Regexp

# <!-- rdoc-file=lib/ipaddr.rb -->
# Regexp *internally* used for parsing IPv6 address.
#
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED: Regexp

# <!-- rdoc-file=lib/ipaddr.rb -->
# Regexp *internally* used for parsing IPv6 address.
#
IPAddr::RE_IPV6ADDRLIKE_FULL: Regexp
interface _ToJson
  def to_json: (?JSON::State state) -> String
end

interface _JsonToWritableIO
  def to_io: () -> _JsonWrite
end

interface _JsonWrite
  def write: (String json) -> void

  def flush: () -> void
end

interface _JsonReadableIO
  def to_io: () -> _JsonRead
end

interface _JsonRead
  def read: () -> string
end

type json_options = Hash[Symbol, untyped]

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# The base exception for JSON errors.
#
class JSON::JSONError < StandardError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if a generator or unparser error occurs.
#
class JSON::GeneratorError < JSON::JSONError
end

class JSON::UnparserError < JSON::GeneratorError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if a parser error occurs.
#
class JSON::ParserError < JSON::JSONError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if the nesting of parsed data structures is too deep.
#
class JSON::NestingError < JSON::ParserError
end

class JSON::State
end

# <!-- rdoc-file=ext/json/lib/json/ext.rb -->
# This module holds all the modules/classes that implement JSON's functionality
# as C extensions.
#
module JSON::Ext
end

# <!-- rdoc-file=ext/json/generator/generator.c -->
# This is the JSON generator implemented as a C extension. It can be configured
# to be used by setting
#
#     JSON.generator = JSON::Ext::Generator
#
# with the method generator= in JSON.
#
module JSON::Ext::Generator
end

class JSON::Ext::Generator::State
end

# <!-- rdoc-file=ext/json/parser/parser.c -->
# This is the JSON parser implemented as a C extension. It can be configured to
# be used by setting
#
#     JSON.parser = JSON::Ext::Parser
#
# with the method parser= in JSON.
#
class JSON::Ext::Parser
end

module JSON::Pure
end

module JSON::Pure::Generator
end

class JSON::Pure::Generator::State
end

class JSON::Pure::Parser
end

type json_generator = singleton(::JSON::Ext::Generator) | singleton(::JSON::Pure::Generator)
type json_parser = singleton(::JSON::Ext::Parser) | singleton(::JSON::Pure::Parser)
type json_state = singleton(JSON::Ext::Generator::State) | singleton(JSON::Pure::Generator::State)

# <!-- rdoc-file=ext/json/lib/json.rb -->
# # JavaScript Object Notation (JSON)
#
# JSON is a lightweight data-interchange format.
#
# A JSON value is one of the following:
# *   Double-quoted text:  `"foo"`.
# *   Number:  `1`, `1.0`, `2.0e2`.
# *   Boolean:  `true`, `false`.
# *   Null: `null`.
# *   Array: an ordered list of values, enclosed by square brackets:
#         ["foo", 1, 1.0, 2.0e2, true, false, null]
#
# *   Object: a collection of name/value pairs, enclosed by curly braces; each
#     name is double-quoted text; the values may be any JSON values:
#         {"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}
#
# A JSON array or object may contain nested arrays, objects, and scalars to any
# depth:
#     {"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}
#     [{"foo": 0, "bar": 1}, ["baz", 2]]
#
# ## Using Module JSON
#
# To make module JSON available in your code, begin with:
#     require 'json'
#
# All examples here assume that this has been done.
#
# ### Parsing JSON
#
# You can parse a String containing JSON data using either of two methods:
# *   `JSON.parse(source, opts)`
# *   `JSON.parse!(source, opts)`
#
# where
# *   `source` is a Ruby object.
# *   `opts` is a Hash object containing options that control both input allowed
#     and output formatting.
#
# The difference between the two methods is that JSON.parse! omits some checks
# and may not be safe for some `source` data; use it only for data from trusted
# sources. Use the safer method JSON.parse for less trusted sources.
#
# #### Parsing JSON Arrays
#
# When `source` is a JSON array, JSON.parse by default returns a Ruby Array:
#     json = '["foo", 1, 1.0, 2.0e2, true, false, null]'
#     ruby = JSON.parse(json)
#     ruby # => ["foo", 1, 1.0, 200.0, true, false, nil]
#     ruby.class # => Array
#
# The JSON array may contain nested arrays, objects, and scalars to any depth:
#     json = '[{"foo": 0, "bar": 1}, ["baz", 2]]'
#     JSON.parse(json) # => [{"foo"=>0, "bar"=>1}, ["baz", 2]]
#
# #### Parsing JSON Objects
#
# When the source is a JSON object, JSON.parse by default returns a Ruby Hash:
#     json = '{"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}'
#     ruby = JSON.parse(json)
#     ruby # => {"a"=>"foo", "b"=>1, "c"=>1.0, "d"=>200.0, "e"=>true, "f"=>false, "g"=>nil}
#     ruby.class # => Hash
#
# The JSON object may contain nested arrays, objects, and scalars to any depth:
#     json = '{"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}'
#     JSON.parse(json) # => {"foo"=>{"bar"=>1, "baz"=>2}, "bat"=>[0, 1, 2]}
#
# #### Parsing JSON Scalars
#
# When the source is a JSON scalar (not an array or object), JSON.parse returns
# a Ruby scalar.
#
# String:
#     ruby = JSON.parse('"foo"')
#     ruby # => 'foo'
#     ruby.class # => String
#
# Integer:
#     ruby = JSON.parse('1')
#     ruby # => 1
#     ruby.class # => Integer
#
# Float:
#     ruby = JSON.parse('1.0')
#     ruby # => 1.0
#     ruby.class # => Float
#     ruby = JSON.parse('2.0e2')
#     ruby # => 200
#     ruby.class # => Float
#
# Boolean:
#     ruby = JSON.parse('true')
#     ruby # => true
#     ruby.class # => TrueClass
#     ruby = JSON.parse('false')
#     ruby # => false
#     ruby.class # => FalseClass
#
# Null:
#     ruby = JSON.parse('null')
#     ruby # => nil
#     ruby.class # => NilClass
#
# #### Parsing Options
#
# ###### Input Options
#
# Option `max_nesting` (Integer) specifies the maximum nesting depth allowed;
# defaults to `100`; specify `false` to disable depth checking.
#
# With the default, `false`:
#     source = '[0, [1, [2, [3]]]]'
#     ruby = JSON.parse(source)
#     ruby # => [0, [1, [2, [3]]]]
#
# Too deep:
#     # Raises JSON::NestingError (nesting of 2 is too deep):
#     JSON.parse(source, {max_nesting: 1})
#
# Bad value:
#     # Raises TypeError (wrong argument type Symbol (expected Fixnum)):
#     JSON.parse(source, {max_nesting: :foo})
#
# ---
#
# Option `allow_nan` (boolean) specifies whether to allow NaN, Infinity, and
# MinusInfinity in `source`; defaults to `false`.
#
# With the default, `false`:
#     # Raises JSON::ParserError (225: unexpected token at '[NaN]'):
#     JSON.parse('[NaN]')
#     # Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
#     JSON.parse('[Infinity]')
#     # Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
#     JSON.parse('[-Infinity]')
#
# Allow:
#     source = '[NaN, Infinity, -Infinity]'
#     ruby = JSON.parse(source, {allow_nan: true})
#     ruby # => [NaN, Infinity, -Infinity]
#
# ###### Output Options
#
# Option `symbolize_names` (boolean) specifies whether returned Hash keys should
# be Symbols; defaults to `false` (use Strings).
#
# With the default, `false`:
#     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
#     ruby = JSON.parse(source)
#     ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
#
# Use Symbols:
#     ruby = JSON.parse(source, {symbolize_names: true})
#     ruby # => {:a=>"foo", :b=>1.0, :c=>true, :d=>false, :e=>nil}
#
# ---
#
# Option `object_class` (Class) specifies the Ruby class to be used for each
# JSON object; defaults to Hash.
#
# With the default, Hash:
#     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
#     ruby = JSON.parse(source)
#     ruby.class # => Hash
#
# Use class OpenStruct:
#     ruby = JSON.parse(source, {object_class: OpenStruct})
#     ruby # => #<OpenStruct a="foo", b=1.0, c=true, d=false, e=nil>
#
# ---
#
# Option `array_class` (Class) specifies the Ruby class to be used for each JSON
# array; defaults to Array.
#
# With the default, Array:
#     source = '["foo", 1.0, true, false, null]'
#     ruby = JSON.parse(source)
#     ruby.class # => Array
#
# Use class Set:
#     ruby = JSON.parse(source, {array_class: Set})
#     ruby # => #<Set: {"foo", 1.0, true, false, nil}>
#
# ---
#
# Option `create_additions` (boolean) specifies whether to use JSON additions in
# parsing. See [\JSON Additions](#module-JSON-label-JSON+Additions).
#
# ### Generating JSON
#
# To generate a Ruby String containing JSON data, use method
# `JSON.generate(source, opts)`, where
# *   `source` is a Ruby object.
# *   `opts` is a Hash object containing options that control both input allowed
#     and output formatting.
#
# #### Generating JSON from Arrays
#
# When the source is a Ruby Array, JSON.generate returns a String containing a
# JSON array:
#     ruby = [0, 's', :foo]
#     json = JSON.generate(ruby)
#     json # => '[0,"s","foo"]'
#
# The Ruby Array array may contain nested arrays, hashes, and scalars to any
# depth:
#     ruby = [0, [1, 2], {foo: 3, bar: 4}]
#     json = JSON.generate(ruby)
#     json # => '[0,[1,2],{"foo":3,"bar":4}]'
#
# #### Generating JSON from Hashes
#
# When the source is a Ruby Hash, JSON.generate returns a String containing a
# JSON object:
#     ruby = {foo: 0, bar: 's', baz: :bat}
#     json = JSON.generate(ruby)
#     json # => '{"foo":0,"bar":"s","baz":"bat"}'
#
# The Ruby Hash array may contain nested arrays, hashes, and scalars to any
# depth:
#     ruby = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
#     json = JSON.generate(ruby)
#     json # => '{"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}'
#
# #### Generating JSON from Other Objects
#
# When the source is neither an Array nor a Hash, the generated JSON data
# depends on the class of the source.
#
# When the source is a Ruby Integer or Float, JSON.generate returns a String
# containing a JSON number:
#     JSON.generate(42) # => '42'
#     JSON.generate(0.42) # => '0.42'
#
# When the source is a Ruby String, JSON.generate returns a String containing a
# JSON string (with double-quotes):
#     JSON.generate('A string') # => '"A string"'
#
# When the source is `true`, `false` or `nil`, JSON.generate returns a String
# containing the corresponding JSON token:
#     JSON.generate(true) # => 'true'
#     JSON.generate(false) # => 'false'
#     JSON.generate(nil) # => 'null'
#
# When the source is none of the above, JSON.generate returns a String
# containing a JSON string representation of the source:
#     JSON.generate(:foo) # => '"foo"'
#     JSON.generate(Complex(0, 0)) # => '"0+0i"'
#     JSON.generate(Dir.new('.')) # => '"#<Dir>"'
#
# #### Generating Options
#
# ###### Input Options
#
# Option `allow_nan` (boolean) specifies whether `NaN`, `Infinity`, and
# `-Infinity` may be generated; defaults to `false`.
#
# With the default, `false`:
#     # Raises JSON::GeneratorError (920: NaN not allowed in JSON):
#     JSON.generate(JSON::NaN)
#     # Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
#     JSON.generate(JSON::Infinity)
#     # Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
#     JSON.generate(JSON::MinusInfinity)
#
# Allow:
#     ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
#     JSON.generate(ruby, allow_nan: true) # => '[NaN,Infinity,-Infinity]'
#
# ---
#
# Option `max_nesting` (Integer) specifies the maximum nesting depth in `obj`;
# defaults to `100`.
#
# With the default, `100`:
#     obj = [[[[[[0]]]]]]
#     JSON.generate(obj) # => '[[[[[[0]]]]]]'
#
# Too deep:
#     # Raises JSON::NestingError (nesting of 2 is too deep):
#     JSON.generate(obj, max_nesting: 2)
#
# ###### Escaping Options
#
# Options `script_safe` (boolean) specifies wether `'\u2028'`, `'\u2029'` and
# `'/'` should be escaped as to make the JSON object safe to interpolate in
# script tags.
#
# Options `ascii_only` (boolean) specifies wether all characters outside the
# ASCII range should be escaped.
#
# ###### Output Options
#
# The default formatting options generate the most compact JSON data, all on one
# line and with no whitespace.
#
# You can use these formatting options to generate JSON data in a more open
# format, using whitespace. See also JSON.pretty_generate.
#
# *   Option `array_nl` (String) specifies a string (usually a newline) to be
#     inserted after each JSON array; defaults to the empty String, `''`.
# *   Option `object_nl` (String) specifies a string (usually a newline) to be
#     inserted after each JSON object; defaults to the empty String, `''`.
# *   Option `indent` (String) specifies the string (usually spaces) to be used
#     for indentation; defaults to the empty String, `''`; defaults to the empty
#     String, `''`; has no effect unless options `array_nl` or `object_nl`
#     specify newlines.
# *   Option `space` (String) specifies a string (usually a space) to be
#     inserted after the colon in each JSON object's pair; defaults to the empty
#     String, `''`.
# *   Option `space_before` (String) specifies a string (usually a space) to be
#     inserted before the colon in each JSON object's pair; defaults to the
#     empty String, `''`.
#
# In this example, `obj` is used first to generate the shortest JSON data (no
# whitespace), then again with all formatting options specified:
#
#     obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
#     json = JSON.generate(obj)
#     puts 'Compact:', json
#     opts = {
#       array_nl: "\n",
#       object_nl: "\n",
#       indent: '  ',
#       space_before: ' ',
#       space: ' '
#     }
#     puts 'Open:', JSON.generate(obj, opts)
#
# Output:
#     Compact:
#     {"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
#     Open:
#     {
#       "foo" : [
#         "bar",
#         "baz"
#     ],
#       "bat" : {
#         "bam" : 0,
#         "bad" : 1
#       }
#     }
#
# ## JSON Additions
#
# When you "round trip" a non-String object from Ruby to JSON and back, you have
# a new String, instead of the object you began with:
#     ruby0 = Range.new(0, 2)
#     json = JSON.generate(ruby0)
#     json # => '0..2"'
#     ruby1 = JSON.parse(json)
#     ruby1 # => '0..2'
#     ruby1.class # => String
#
# You can use JSON *additions* to preserve the original object. The addition is
# an extension of a ruby class, so that:
# *   JSON.generate stores more information in the JSON string.
# *   JSON.parse, called with option `create_additions`, uses that information
#     to create a proper Ruby object.
#
# This example shows a Range being generated into JSON and parsed back into
# Ruby, both without and with the addition for Range:
#     ruby = Range.new(0, 2)
#     # This passage does not use the addition for Range.
#     json0 = JSON.generate(ruby)
#     ruby0 = JSON.parse(json0)
#     # This passage uses the addition for Range.
#     require 'json/add/range'
#     json1 = JSON.generate(ruby)
#     ruby1 = JSON.parse(json1, create_additions: true)
#     # Make a nice display.
#     display = <<~EOT
#       Generated JSON:
#         Without addition:  #{json0} (#{json0.class})
#         With addition:     #{json1} (#{json1.class})
#       Parsed JSON:
#         Without addition:  #{ruby0.inspect} (#{ruby0.class})
#         With addition:     #{ruby1.inspect} (#{ruby1.class})
#     EOT
#     puts display
#
# This output shows the different results:
#     Generated JSON:
#       Without addition:  "0..2" (String)
#       With addition:     {"json_class":"Range","a":[0,2,false]} (String)
#     Parsed JSON:
#       Without addition:  "0..2" (String)
#       With addition:     0..2 (Range)
#
# The JSON module includes additions for certain classes. You can also craft
# custom additions. See [Custom \JSON
# Additions](#module-JSON-label-Custom+JSON+Additions).
#
# ### Built-in Additions
#
# The JSON module includes additions for certain classes. To use an addition,
# `require` its source:
# *   BigDecimal: `require 'json/add/bigdecimal'`
# *   Complex: `require 'json/add/complex'`
# *   Date: `require 'json/add/date'`
# *   DateTime: `require 'json/add/date_time'`
# *   Exception: `require 'json/add/exception'`
# *   OpenStruct: `require 'json/add/ostruct'`
# *   Range: `require 'json/add/range'`
# *   Rational: `require 'json/add/rational'`
# *   Regexp: `require 'json/add/regexp'`
# *   Set: `require 'json/add/set'`
# *   Struct: `require 'json/add/struct'`
# *   Symbol: `require 'json/add/symbol'`
# *   Time: `require 'json/add/time'`
#
# To reduce punctuation clutter, the examples below show the generated JSON via
# `puts`, rather than the usual `inspect`,
#
# BigDecimal:
#     require 'json/add/bigdecimal'
#     ruby0 = BigDecimal(0) # 0.0
#     json = JSON.generate(ruby0) # {"json_class":"BigDecimal","b":"27:0.0"}
#     ruby1 = JSON.parse(json, create_additions: true) # 0.0
#     ruby1.class # => BigDecimal
#
# Complex:
#     require 'json/add/complex'
#     ruby0 = Complex(1+0i) # 1+0i
#     json = JSON.generate(ruby0) # {"json_class":"Complex","r":1,"i":0}
#     ruby1 = JSON.parse(json, create_additions: true) # 1+0i
#     ruby1.class # Complex
#
# Date:
#     require 'json/add/date'
#     ruby0 = Date.today # 2020-05-02
#     json = JSON.generate(ruby0) # {"json_class":"Date","y":2020,"m":5,"d":2,"sg":2299161.0}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02
#     ruby1.class # Date
#
# DateTime:
#     require 'json/add/date_time'
#     ruby0 = DateTime.now # 2020-05-02T10:38:13-05:00
#     json = JSON.generate(ruby0) # {"json_class":"DateTime","y":2020,"m":5,"d":2,"H":10,"M":38,"S":13,"of":"-5/24","sg":2299161.0}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02T10:38:13-05:00
#     ruby1.class # DateTime
#
# Exception (and its subclasses including RuntimeError):
#     require 'json/add/exception'
#     ruby0 = Exception.new('A message') # A message
#     json = JSON.generate(ruby0) # {"json_class":"Exception","m":"A message","b":null}
#     ruby1 = JSON.parse(json, create_additions: true) # A message
#     ruby1.class # Exception
#     ruby0 = RuntimeError.new('Another message') # Another message
#     json = JSON.generate(ruby0) # {"json_class":"RuntimeError","m":"Another message","b":null}
#     ruby1 = JSON.parse(json, create_additions: true) # Another message
#     ruby1.class # RuntimeError
#
# OpenStruct:
#     require 'json/add/ostruct'
#     ruby0 = OpenStruct.new(name: 'Matz', language: 'Ruby') # #<OpenStruct name="Matz", language="Ruby">
#     json = JSON.generate(ruby0) # {"json_class":"OpenStruct","t":{"name":"Matz","language":"Ruby"}}
#     ruby1 = JSON.parse(json, create_additions: true) # #<OpenStruct name="Matz", language="Ruby">
#     ruby1.class # OpenStruct
#
# Range:
#     require 'json/add/range'
#     ruby0 = Range.new(0, 2) # 0..2
#     json = JSON.generate(ruby0) # {"json_class":"Range","a":[0,2,false]}
#     ruby1 = JSON.parse(json, create_additions: true) # 0..2
#     ruby1.class # Range
#
# Rational:
#     require 'json/add/rational'
#     ruby0 = Rational(1, 3) # 1/3
#     json = JSON.generate(ruby0) # {"json_class":"Rational","n":1,"d":3}
#     ruby1 = JSON.parse(json, create_additions: true) # 1/3
#     ruby1.class # Rational
#
# Regexp:
#     require 'json/add/regexp'
#     ruby0 = Regexp.new('foo') # (?-mix:foo)
#     json = JSON.generate(ruby0) # {"json_class":"Regexp","o":0,"s":"foo"}
#     ruby1 = JSON.parse(json, create_additions: true) # (?-mix:foo)
#     ruby1.class # Regexp
#
# Set:
#     require 'json/add/set'
#     ruby0 = Set.new([0, 1, 2]) # #<Set: {0, 1, 2}>
#     json = JSON.generate(ruby0) # {"json_class":"Set","a":[0,1,2]}
#     ruby1 = JSON.parse(json, create_additions: true) # #<Set: {0, 1, 2}>
#     ruby1.class # Set
#
# Struct:
#     require 'json/add/struct'
#     Customer = Struct.new(:name, :address) # Customer
#     ruby0 = Customer.new("Dave", "123 Main") # #<struct Customer name="Dave", address="123 Main">
#     json = JSON.generate(ruby0) # {"json_class":"Customer","v":["Dave","123 Main"]}
#     ruby1 = JSON.parse(json, create_additions: true) # #<struct Customer name="Dave", address="123 Main">
#     ruby1.class # Customer
#
# Symbol:
#     require 'json/add/symbol'
#     ruby0 = :foo # foo
#     json = JSON.generate(ruby0) # {"json_class":"Symbol","s":"foo"}
#     ruby1 = JSON.parse(json, create_additions: true) # foo
#     ruby1.class # Symbol
#
# Time:
#     require 'json/add/time'
#     ruby0 = Time.now # 2020-05-02 11:28:26 -0500
#     json = JSON.generate(ruby0) # {"json_class":"Time","s":1588436906,"n":840560000}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02 11:28:26 -0500
#     ruby1.class # Time
#
# ### Custom JSON Additions
#
# In addition to the JSON additions provided, you can craft JSON additions of
# your own, either for Ruby built-in classes or for user-defined classes.
#
# Here's a user-defined class `Foo`:
#     class Foo
#       attr_accessor :bar, :baz
#       def initialize(bar, baz)
#         self.bar = bar
#         self.baz = baz
#       end
#     end
#
# Here's the JSON addition for it:
#     # Extend class Foo with JSON addition.
#     class Foo
#       # Serialize Foo object with its class name and arguments
#       def to_json(*args)
#         {
#           JSON.create_id  => self.class.name,
#           'a'             => [ bar, baz ]
#         }.to_json(*args)
#       end
#       # Deserialize JSON string by constructing new Foo object with arguments.
#       def self.json_create(object)
#         new(*object['a'])
#       end
#     end
#
# Demonstration:
#     require 'json'
#     # This Foo object has no custom addition.
#     foo0 = Foo.new(0, 1)
#     json0 = JSON.generate(foo0)
#     obj0 = JSON.parse(json0)
#     # Lood the custom addition.
#     require_relative 'foo_addition'
#     # This foo has the custom addition.
#     foo1 = Foo.new(0, 1)
#     json1 = JSON.generate(foo1)
#     obj1 = JSON.parse(json1, create_additions: true)
#     #   Make a nice display.
#     display = <<~EOT
#       Generated JSON:
#         Without custom addition:  #{json0} (#{json0.class})
#         With custom addition:     #{json1} (#{json1.class})
#       Parsed JSON:
#         Without custom addition:  #{obj0.inspect} (#{obj0.class})
#         With custom addition:     #{obj1.inspect} (#{obj1.class})
#     EOT
#     puts display
#
# Output:
#
#     Generated JSON:
#       Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#       With custom addition:     {"json_class":"Foo","a":[0,1]} (String)
#     Parsed JSON:
#       Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#       With custom addition:     #<Foo:0x0000000006473bb8 @bar=0, @baz=1> (Foo)
#
module JSON
  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON[object] -> new_array or new_string
  # -->
  # If `object` is a String, calls JSON.parse with `object` and `opts` (see method
  # #parse):
  #     json = '[0, 1, null]'
  #     JSON[json]# => [0, 1, nil]
  #
  # Otherwise, calls JSON.generate with `object` and `opts` (see method
  # #generate):
  #     ruby = [0, 1, nil]
  #     JSON[ruby] # => '[0,1,null]'
  #
  def self.[]: (untyped object, ?json_options opts) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - create_id()
  # -->
  # Returns the current create identifier. See also JSON.create_id=.
  #
  def self.create_id: () -> _ToS

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - create_id=(new_value)
  # -->
  # Sets create identifier, which is used to decide if the *json_create* hook of a
  # class should be called; initial value is `json_class`:
  #     JSON.create_id # => 'json_class'
  #
  def self.create_id=: (_ToS create_id) -> _ToS

  def self.deep_const_get: (interned path) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.dump(obj, io = nil, limit = nil)
  # -->
  # Dumps `obj` as a JSON string, i.e. calls generate on the object and returns
  # the result.
  #
  # The default options can be changed via method JSON.dump_default_options.
  #
  # *   Argument `io`, if given, should respond to method `write`; the JSON String
  #     is written to `io`, and `io` is returned. If `io` is not given, the JSON
  #     String is returned.
  # *   Argument `limit`, if given, is passed to JSON.generate as option
  #     `max_nesting`.
  #
  # ---
  #
  # When argument `io` is not given, returns the JSON String generated from `obj`:
  #     obj = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
  #     json = JSON.dump(obj)
  #     json # => "{\"foo\":[0,1],\"bar\":{\"baz\":2,\"bat\":3},\"bam\":\"bad\"}"
  #
  # When argument `io` is given, writes the JSON String to `io` and returns `io`:
  #     path = 't.json'
  #     File.open(path, 'w') do |file|
  #       JSON.dump(obj, file)
  #     end # => #<File:t.json (closed)>
  #     puts File.read(path)
  #
  # Output:
  #     {"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}
  #
  def self?.dump: (_ToJson obj, ?Integer limit) -> String
                | (_ToJson obj, _JsonToWritableIO anIO) -> _JsonWrite
                | (_ToJson obj, _JsonWrite anIO, ?Integer limit) -> _JsonWrite

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns the default options for the JSON.dump method. Initially:
  #     opts = JSON.dump_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true}
  #
  def self.dump_default_options: () -> json_options

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns the default options for the JSON.dump method. Initially:
  #     opts = JSON.dump_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true}
  #
  def self.dump_default_options=: (json_options) -> json_options

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.fast_generate(obj, opts) -> new_string
  # -->
  # Arguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
  # JSON.generate.
  #
  # By default, generates JSON data without checking for circular references in
  # `obj` (option `max_nesting` set to `false`, disabled).
  #
  # Raises an exception if `obj` contains circular references:
  #     a = []; b = []; a.push(b); b.push(a)
  #     # Raises SystemStackError (stack level too deep):
  #     JSON.fast_generate(a)
  #
  def self?.fast_generate: (_ToJson obj, ?json_options opts) -> String

  alias self.fast_unparse self.fast_generate

  alias fast_unparse fast_generate

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.generate(obj, opts = nil) -> new_string
  # -->
  # Returns a String containing the generated JSON data.
  #
  # See also JSON.fast_generate, JSON.pretty_generate.
  #
  # Argument `obj` is the Ruby object to be converted to JSON.
  #
  # Argument `opts`, if given, contains a Hash of options for the generation. See
  # [Generating Options](#module-JSON-label-Generating+Options).
  #
  # ---
  #
  # When `obj` is an Array, returns a String containing a JSON array:
  #     obj = ["foo", 1.0, true, false, nil]
  #     json = JSON.generate(obj)
  #     json # => '["foo",1.0,true,false,null]'
  #
  # When `obj` is a Hash, returns a String containing a JSON object:
  #     obj = {foo: 0, bar: 's', baz: :bat}
  #     json = JSON.generate(obj)
  #     json # => '{"foo":0,"bar":"s","baz":"bat"}'
  #
  # For examples of generating from other Ruby objects, see [Generating \JSON from
  # Other Objects](#module-JSON-label-Generating+JSON+from+Other+Objects).
  #
  # ---
  #
  # Raises an exception if any formatting option is not a String.
  #
  # Raises an exception if `obj` contains circular references:
  #     a = []; b = []; a.push(b); b.push(a)
  #     # Raises JSON::NestingError (nesting of 100 is too deep):
  #     JSON.generate(a)
  #
  def self?.generate: (_ToJson obj, ?json_options opts) -> String

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Returns the JSON generator module that is used by JSON.
  #
  def self.generator: () -> json_generator

  def self.generator=: (json_generator generator) -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - iconv(to, from, string)
  # -->
  # Encodes string using String.encode.
  #
  def self.iconv: (encoding to, encoding from, String string) -> String

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.load(source, proc = nil, options = {}) -> object
  # -->
  # Returns the Ruby objects created by parsing the given `source`.
  #
  # BEWARE: This method is meant to serialise data from trusted user input, like
  # from your own database server or clients under your control, it could be
  # dangerous to allow untrusted users to pass JSON sources into it. If you must
  # use it, use JSON.unsafe_load instead to make it clear.
  #
  # Since JSON version 2.8.0, `load` emits a deprecation warning when a non native
  # type is deserialized, without `create_additions` being explicitly enabled, and
  # in JSON version 3.0, `load` will have `create_additions` disabled by default.
  #
  # *   Argument `source` must be, or be convertible to, a String:
  #     *   If `source` responds to instance method `to_str`, `source.to_str`
  #         becomes the source.
  #     *   If `source` responds to instance method `to_io`, `source.to_io.read`
  #         becomes the source.
  #     *   If `source` responds to instance method `read`, `source.read` becomes
  #         the source.
  #     *   If both of the following are true, source becomes the String `'null'`:
  #         *   Option `allow_blank` specifies a truthy value.
  #         *   The source, as defined above, is `nil` or the empty String `''`.
  #     *   Otherwise, `source` remains the source.
  # *   Argument `proc`, if given, must be a Proc that accepts one argument. It
  #     will be called recursively with each result (depth-first order). See
  #     details below.
  # *   Argument `opts`, if given, contains a Hash of options for the parsing. See
  #     [Parsing Options](#module-JSON-label-Parsing+Options). The default options
  #     can be changed via method JSON.load_default_options=.
  #
  # ---
  #
  # When no `proc` is given, modifies `source` as above and returns the result of
  # `parse(source, opts)`;  see #parse.
  #
  # Source for following examples:
  #     source = <<~JSON
  #       {
  #         "name": "Dave",
  #         "age" :40,
  #         "hats": [
  #           "Cattleman's",
  #           "Panama",
  #           "Tophat"
  #         ]
  #       }
  #     JSON
  #
  # Load a String:
  #     ruby = JSON.load(source)
  #     ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # Load an IO object:
  #     require 'stringio'
  #     object = JSON.load(StringIO.new(source))
  #     object # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # Load a File object:
  #     path = 't.json'
  #     File.write(path, source)
  #     File.open(path) do |file|
  #       JSON.load(file)
  #     end # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # ---
  #
  # When `proc` is given:
  # *   Modifies `source` as above.
  # *   Gets the `result` from calling `parse(source, opts)`.
  # *   Recursively calls `proc(result)`.
  # *   Returns the final result.
  #
  # Example:
  #     require 'json'
  #
  #     # Some classes for the example.
  #     class Base
  #       def initialize(attributes)
  #         @attributes = attributes
  #       end
  #     end
  #     class User    < Base; end
  #     class Account < Base; end
  #     class Admin   < Base; end
  #     # The JSON source.
  #     json = <<-EOF
  #     {
  #       "users": [
  #           {"type": "User", "username": "jane", "email": "jane@example.com"},
  #           {"type": "User", "username": "john", "email": "john@example.com"}
  #       ],
  #       "accounts": [
  #           {"account": {"type": "Account", "paid": true, "account_id": "1234"}},
  #           {"account": {"type": "Account", "paid": false, "account_id": "1235"}}
  #       ],
  #       "admins": {"type": "Admin", "password": "0wn3d"}
  #     }
  #     EOF
  #     # Deserializer method.
  #     def deserialize_obj(obj, safe_types = %w(User Account Admin))
  #       type = obj.is_a?(Hash) && obj["type"]
  #       safe_types.include?(type) ? Object.const_get(type).new(obj) : obj
  #     end
  #     # Call to JSON.load
  #     ruby = JSON.load(json, proc {|obj|
  #       case obj
  #       when Hash
  #         obj.each {|k, v| obj[k] = deserialize_obj v }
  #       when Array
  #         obj.map! {|v| deserialize_obj v }
  #       end
  #     })
  #     pp ruby
  #
  # Output:
  #     {"users"=>
  #        [#<User:0x00000000064c4c98
  #          @attributes=
  #            {"type"=>"User", "username"=>"jane", "email"=>"jane@example.com"}>,
  #          #<User:0x00000000064c4bd0
  #          @attributes=
  #            {"type"=>"User", "username"=>"john", "email"=>"john@example.com"}>],
  #      "accounts"=>
  #        [{"account"=>
  #            #<Account:0x00000000064c4928
  #            @attributes={"type"=>"Account", "paid"=>true, "account_id"=>"1234"}>},
  #         {"account"=>
  #            #<Account:0x00000000064c4680
  #            @attributes={"type"=>"Account", "paid"=>false, "account_id"=>"1235"}>}],
  #      "admins"=>
  #        #<Admin:0x00000000064c41f8
  #        @attributes={"type"=>"Admin", "password"=>"0wn3d"}>}
  #
  def self?.load: (string | _JsonReadableIO | _JsonRead source, ?Proc proc, ?json_options options) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.load_file(path, opts={}) -> object
  # -->
  # Calls:
  #     parse(File.read(path), opts)
  #
  # See method #parse.
  #
  def self?.load_file: (string path, ?json_options opts) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.load_file!(path, opts = {})
  # -->
  # Calls:
  #     JSON.parse!(File.read(path, opts))
  #
  # See method #parse!
  #
  def self?.load_file!: (string path, ?json_options opts) -> untyped

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns default options for the JSON.load method. Initially:
  #     opts = JSON.load_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
  #
  def self.load_default_options: () -> json_options

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns default options for the JSON.load method. Initially:
  #     opts = JSON.load_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
  #
  def self.load_default_options=: (json_options) -> json_options

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.parse(source, opts) -> object
  # -->
  # Returns the Ruby objects created by parsing the given `source`.
  #
  # Argument `source` contains the String to be parsed.
  #
  # Argument `opts`, if given, contains a Hash of options for the parsing. See
  # [Parsing Options](#module-JSON-label-Parsing+Options).
  #
  # ---
  #
  # When `source` is a JSON array, returns a Ruby Array:
  #     source = '["foo", 1.0, true, false, null]'
  #     ruby = JSON.parse(source)
  #     ruby # => ["foo", 1.0, true, false, nil]
  #     ruby.class # => Array
  #
  # When `source` is a JSON object, returns a Ruby Hash:
  #     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
  #     ruby = JSON.parse(source)
  #     ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
  #     ruby.class # => Hash
  #
  # For examples of parsing for all JSON data types, see [Parsing
  # \JSON](#module-JSON-label-Parsing+JSON).
  #
  # Parses nested JSON objects:
  #     source = <<~JSON
  #       {
  #       "name": "Dave",
  #         "age" :40,
  #         "hats": [
  #           "Cattleman's",
  #           "Panama",
  #           "Tophat"
  #         ]
  #       }
  #     JSON
  #     ruby = JSON.parse(source)
  #     ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # ---
  #
  # Raises an exception if `source` is not valid JSON:
  #     # Raises JSON::ParserError (783: unexpected token at ''):
  #     JSON.parse('')
  #
  def self?.parse: (string source, ?json_options opts) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.parse!(source, opts) -> object
  # -->
  # Calls
  #     parse(source, opts)
  #
  # with `source` and possibly modified `opts`.
  #
  # Differences from JSON.parse:
  # *   Option `max_nesting`, if not provided, defaults to `false`, which disables
  #     checking for nesting depth.
  # *   Option `allow_nan`, if not provided, defaults to `true`.
  #
  def self?.parse!: (string source, ?json_options opts) -> untyped

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Returns the JSON parser class that is used by JSON.
  #
  def self.parser: () -> json_parser

  def self.parser=: (json_parser parser) -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.pretty_generate(obj, opts = nil) -> new_string
  # -->
  # Arguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
  # JSON.generate.
  #
  # Default options are:
  #     {
  #       indent: '  ',   # Two spaces
  #       space: ' ',     # One space
  #       array_nl: "\n", # Newline
  #       object_nl: "\n" # Newline
  #     }
  #
  # Example:
  #     obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
  #     json = JSON.pretty_generate(obj)
  #     puts json
  #
  # Output:
  #     {
  #       "foo": [
  #         "bar",
  #         "baz"
  #       ],
  #       "bat": {
  #         "bam": 0,
  #         "bad": 1
  #       }
  #     }
  #
  def self?.pretty_generate: (_ToJson obj, ?json_options opts) -> untyped

  alias self.pretty_unparse self.pretty_generate

  alias pretty_unparse pretty_generate

  # Recursively calls passed *Proc* if the parsed data structure is an *Array* or
  # *Hash*
  #
  def self?.recurse_proc: (untyped result) { (*untyped) -> void } -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - restore(source, proc = nil, options = nil)
  # -->
  #
  alias self.restore self.load

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - restore(source, proc = nil, options = nil)
  # -->
  #
  alias restore load

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or Returns the JSON generator state class that is used by JSON.
  #
  def self.state: () -> json_state

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or Returns the JSON generator state class that is used by JSON.
  #
  def self.state=: (json_state) -> json_state

  alias self.unparse self.generate

  alias unparse generate
end

JSON::FAST_STATE_PROTOTYPE: json_state

JSON::Infinity: Float

JSON::JSON_LOADED: bool

JSON::MinusInfinity: Float

JSON::NaN: Float

JSON::PRETTY_STATE_PROTOTYPE: json_state

JSON::SAFE_STATE_PROTOTYPE: json_state

JSON::VERSION: String

JSON::VERSION_ARRAY: Array[Integer]

JSON::VERSION_BUILD: Integer

JSON::VERSION_MAJOR: Integer

JSON::VERSION_MINOR: Integer

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - j(*objs)
  # -->
  # Outputs *objs* to STDOUT as JSON strings in the shortest form, that is in one
  # line.
  #
  def j: (*_ToJson) -> nil

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - jj(*objs)
  # -->
  # Outputs *objs* to STDOUT as JSON strings in a pretty format, with indentation
  # and over many lines.
  #
  def jj: (*_ToJson) -> nil

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON(object, *args)
  # -->
  # If *object* is string-like, parse the string and return the parsed result as a
  # Ruby data structure. Otherwise, generate a JSON text from the Ruby data
  # structure object and return it.
  #
  # The *opts* argument is passed through to generate/parse respectively. See
  # generate and parse for their documentation.
  #
  def JSON: (string source, ?json_options opts) -> untyped
          | (_ToJson obj, ?json_options opts) -> String
end

%a{annotate:rdoc:skip}
class Object
  # Converts this object to a string (calling #to_s), converts
  # it to a JSON string, and returns the result. This is a fallback, if no
  # special method #to_json was defined for some object.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class NilClass
  # Returns a JSON string for nil: 'null'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class TrueClass
  # Returns a JSON string for true: 'true'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class FalseClass
  # Returns a JSON string for false: 'false'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class String
  # This string should be encoded with UTF-8 A call to this method
  # returns a JSON string encoded with UTF16 big endian characters as
  # \u????.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Integer
  # Returns a JSON string representation for this Integer number.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Float
  # Returns a JSON string representation for this Float number.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Hash[unchecked out K, unchecked out V]
  # Returns a JSON string containing a JSON object, that is generated from
  # this Hash instance.
  # _state_ is a JSON::State object, that can also be used to configure the
  # produced JSON string output further.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem]
  # Returns a JSON string containing a JSON array, that is generated from
  # this Array instance.
  # _state_ is a JSON::State object, that can also be used to configure the
  # produced JSON string output further.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class BigDecimal
  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - as_json(*)
  # -->
  # Methods `BigDecimal#as_json` and `BigDecimal.json_create` may be used to
  # serialize and deserialize a BigDecimal object; see
  # [Marshal](rdoc-ref:Marshal).
  #
  # Method `BigDecimal#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/bigdecimal'
  #     x = BigDecimal(2).as_json             # => {"json_class"=>"BigDecimal", "b"=>"27:0.2e1"}
  #     y = BigDecimal(2.0, 4).as_json        # => {"json_class"=>"BigDecimal", "b"=>"36:0.2e1"}
  #     z = BigDecimal(Complex(2, 0)).as_json # => {"json_class"=>"BigDecimal", "b"=>"27:0.2e1"}
  #
  # Method `JSON.create` deserializes such a hash, returning a BigDecimal object:
  #
  #     BigDecimal.json_create(x) # => 0.2e1
  #     BigDecimal.json_create(y) # => 0.2e1
  #     BigDecimal.json_create(z) # => 0.2e1
  #
  def as_json: (*untyped) -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/bigdecimal'
  #     puts BigDecimal(2).to_json
  #     puts BigDecimal(2.0, 4).to_json
  #     puts BigDecimal(Complex(2, 0)).to_json
  #
  # Output:
  #
  #     {"json_class":"BigDecimal","b":"27:0.2e1"}
  #     {"json_class":"BigDecimal","b":"36:0.2e1"}
  #     {"json_class":"BigDecimal","b":"27:0.2e1"}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Complex
  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Numeric] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - as_json(*)
  # -->
  # Methods `Complex#as_json` and `Complex.json_create` may be used to serialize
  # and deserialize a Complex object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Complex#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/complex'
  #     x = Complex(2).as_json      # => {"json_class"=>"Complex", "r"=>2, "i"=>0}
  #     y = Complex(2.0, 4).as_json # => {"json_class"=>"Complex", "r"=>2.0, "i"=>4}
  #
  # Method `JSON.create` deserializes such a hash, returning a Complex object:
  #
  #     Complex.json_create(x) # => (2+0i)
  #     Complex.json_create(y) # => (2.0+4i)
  #
  def as_json: (*untyped) -> Hash[String, String | Numeric]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/complex'
  #     puts Complex(2).to_json
  #     puts Complex(2.0, 4).to_json
  #
  # Output:
  #
  #     {"json_class":"Complex","r":2,"i":0}
  #     {"json_class":"Complex","r":2.0,"i":4}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Date
  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Integer | Float] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - as_json(*)
  # -->
  # Methods `Date#as_json` and `Date.json_create` may be used to serialize and
  # deserialize a Date object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Date#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/date'
  #     x = Date.today.as_json
  #     # => {"json_class"=>"Date", "y"=>2023, "m"=>11, "d"=>21, "sg"=>2299161.0}
  #
  # Method `JSON.create` deserializes such a hash, returning a Date object:
  #
  #     Date.json_create(x)
  #     # => #<Date: 2023-11-21 ((2460270j,0s,0n),+0s,2299161j)>
  #
  def as_json: (*untyped) -> Hash[String, String | Integer | Float]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/date'
  #     puts Date.today.to_json
  #
  # Output:
  #
  #     {"json_class":"Date","y":2023,"m":11,"d":21,"sg":2299161.0}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class DateTime
  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Integer | Float] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - as_json(*)
  # -->
  # Methods `DateTime#as_json` and `DateTime.json_create` may be used to serialize
  # and deserialize a DateTime object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `DateTime#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/datetime'
  #     x = DateTime.now.as_json
  #     # => {"json_class"=>"DateTime", "y"=>2023, "m"=>11, "d"=>21, "sg"=>2299161.0}
  #
  # Method `JSON.create` deserializes such a hash, returning a DateTime object:
  #
  #     DateTime.json_create(x) # BUG? Raises Date::Error "invalid date"
  #
  def as_json: (*untyped) -> Hash[String, String | Integer | Float]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/datetime'
  #     puts DateTime.now.to_json
  #
  # Output:
  #
  #     {"json_class":"DateTime","y":2023,"m":11,"d":21,"sg":2299161.0}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Exception
  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Array[String] | nil] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - as_json(*)
  # -->
  # Methods `Exception#as_json` and `Exception.json_create` may be used to
  # serialize and deserialize a Exception object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Exception#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/exception'
  #     x = Exception.new('Foo').as_json # => {"json_class"=>"Exception", "m"=>"Foo", "b"=>nil}
  #
  # Method `JSON.create` deserializes such a hash, returning a Exception object:
  #
  #     Exception.json_create(x) # => #<Exception: Foo>
  #
  def as_json: (*untyped) -> Hash[String, String | Array[String] | nil]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/exception'
  #     puts Exception.new('Foo').to_json
  #
  # Output:
  #
  #     {"json_class":"Exception","m":"Foo","b":null}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class OpenStruct
  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Hash[Symbol, untyped]] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - as_json(*)
  # -->
  # Methods `OpenStruct#as_json` and `OpenStruct.json_create` may be used to
  # serialize and deserialize a OpenStruct object; see
  # [Marshal](rdoc-ref:Marshal).
  #
  # Method `OpenStruct#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/ostruct'
  #     x = OpenStruct.new('name' => 'Rowdy', :age => nil).as_json
  #     # => {"json_class"=>"OpenStruct", "t"=>{:name=>'Rowdy', :age=>nil}}
  #
  # Method `JSON.create` deserializes such a hash, returning a OpenStruct object:
  #
  #     OpenStruct.json_create(x)
  #     # => #<OpenStruct name='Rowdy', age=nil>
  #
  def as_json: (*untyped) -> Hash[String, String | Hash[Symbol, untyped]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/ostruct'
  #     puts OpenStruct.new('name' => 'Rowdy', :age => nil).to_json
  #
  # Output:
  #
  #     {"json_class":"OpenStruct","t":{'name':'Rowdy',"age":null}}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Range[out Elem]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: [A] (Hash[String, String | [ A, A, bool ]] object) -> Range[A]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - as_json(*)
  # -->
  # Methods `Range#as_json` and `Range.json_create` may be used to serialize and
  # deserialize a Range object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Range#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/range'
  #     x = (1..4).as_json     # => {"json_class"=>"Range", "a"=>[1, 4, false]}
  #     y = (1...4).as_json    # => {"json_class"=>"Range", "a"=>[1, 4, true]}
  #     z = ('a'..'d').as_json # => {"json_class"=>"Range", "a"=>["a", "d", false]}
  #
  # Method `JSON.create` deserializes such a hash, returning a Range object:
  #
  #     Range.json_create(x) # => 1..4
  #     Range.json_create(y) # => 1...4
  #     Range.json_create(z) # => "a".."d"
  #
  def as_json: (*untyped) -> Hash[String, String | [ Elem, Elem, bool ]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/range'
  #     puts (1..4).to_json
  #     puts (1...4).to_json
  #     puts ('a'..'d').to_json
  #
  # Output:
  #
  #     {"json_class":"Range","a":[1,4,false]}
  #     {"json_class":"Range","a":[1,4,true]}
  #     {"json_class":"Range","a":["a","d",false]}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Rational
  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - as_json(*)
  # -->
  # Methods `Rational#as_json` and `Rational.json_create` may be used to serialize
  # and deserialize a Rational object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Rational#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/rational'
  #     x = Rational(2, 3).as_json
  #     # => {"json_class"=>"Rational", "n"=>2, "d"=>3}
  #
  # Method `JSON.create` deserializes such a hash, returning a Rational object:
  #
  #     Rational.json_create(x)
  #     # => (2/3)
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/rational'
  #     puts Rational(2, 3).to_json
  #
  # Output:
  #
  #     {"json_class":"Rational","n":2,"d":3}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Regexp
  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - as_json(*)
  # -->
  # Methods `Regexp#as_json` and `Regexp.json_create` may be used to serialize and
  # deserialize a Regexp object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Regexp#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/regexp'
  #     x = /foo/.as_json
  #     # => {"json_class"=>"Regexp", "o"=>0, "s"=>"foo"}
  #
  # Method `JSON.create` deserializes such a hash, returning a Regexp object:
  #
  #     Regexp.json_create(x) # => /foo/
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/regexp'
  #     puts /foo/.to_json
  #
  # Output:
  #
  #     {"json_class":"Regexp","o":0,"s":"foo"}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Set[unchecked out A]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: [A] (Hash[String, String | Array[A]] object) -> Set[A]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - as_json(*)
  # -->
  # Methods `Set#as_json` and `Set.json_create` may be used to serialize and
  # deserialize a Set object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Set#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/set'
  #     x = Set.new(%w/foo bar baz/).as_json
  #     # => {"json_class"=>"Set", "a"=>["foo", "bar", "baz"]}
  #
  # Method `JSON.create` deserializes such a hash, returning a Set object:
  #
  #     Set.json_create(x) # => #<Set: {"foo", "bar", "baz"}>
  #
  def as_json: (*untyped) -> Hash[String, String | Array[A]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/set'
  #     puts Set.new(%w/foo bar baz/).to_json
  #
  # Output:
  #
  #     {"json_class":"Set","a":["foo","bar","baz"]}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Struct[Elem]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: [Elem] (Hash[String, String | Array[Elem]] object) -> Struct[Elem]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - as_json(*)
  # -->
  # Methods `Struct#as_json` and `Struct.json_create` may be used to serialize and
  # deserialize a Struct object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Struct#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/struct'
  #     Customer = Struct.new('Customer', :name, :address, :zip)
  #     x = Struct::Customer.new.as_json
  #     # => {"json_class"=>"Struct::Customer", "v"=>[nil, nil, nil]}
  #
  # Method `JSON.create` deserializes such a hash, returning a Struct object:
  #
  #     Struct::Customer.json_create(x)
  #     # => #<struct Struct::Customer name=nil, address=nil, zip=nil>
  #
  def as_json: (*untyped) -> Hash[String, String | Array[Elem]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/struct'
  #     Customer = Struct.new('Customer', :name, :address, :zip)
  #     puts Struct::Customer.new.to_json
  #
  # Output:
  #
  #     {"json_class":"Struct","t":{'name':'Rowdy',"age":null}}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Symbol
  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - json_create(o)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - as_json(*)
  # -->
  # Methods `Symbol#as_json` and `Symbol.json_create` may be used to serialize and
  # deserialize a Symbol object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Symbol#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/symbol'
  #     x = :foo.as_json
  #     # => {"json_class"=>"Symbol", "s"=>"foo"}
  #
  # Method `JSON.create` deserializes such a hash, returning a Symbol object:
  #
  #     Symbol.json_create(x) # => :foo
  #
  def as_json: (*untyped) -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - to_json(*a)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/symbol'
  #     puts :foo.to_json
  #
  # Output:
  #
  #     # {"json_class":"Symbol","s":"foo"}
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Time
  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - json_create(object)
  # -->
  # See #as_json.
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - as_json(*)
  # -->
  # Methods `Time#as_json` and `Time.json_create` may be used to serialize and
  # deserialize a Time object; see [Marshal](rdoc-ref:Marshal).
  #
  # Method `Time#as_json` serializes `self`, returning a 2-element hash
  # representing `self`:
  #
  #     require 'json/add/time'
  #     x = Time.now.as_json
  #     # => {"json_class"=>"Time", "s"=>1700931656, "n"=>472846644}
  #
  # Method `JSON.create` deserializes such a hash, returning a Time object:
  #
  #     Time.json_create(x)
  #     # => 2023-11-25 11:00:56.472846644 -0600
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - to_json(*args)
  # -->
  # Returns a JSON string representing `self`:
  #
  #     require 'json/add/time'
  #     puts Time.now.to_json
  #
  # Output:
  #
  #     {"json_class":"Time","s":1700931678,"n":980650786}
  #
  def to_json: (?JSON::State state) -> String
end
# <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
# Kanji Converter for Ruby.
#
module Kconv
  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # ASCII
  #
  ASCII: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # Auto-Detect
  #
  AUTO: nil

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # BINARY
  #
  BINARY: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # EUC-JP
  #
  EUC: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # ISO-2022-JP
  #
  JIS: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # NOCONV
  #
  NOCONV: nil

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # Shift_JIS
  #
  SJIS: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # UNKNOWN
  #
  UNKNOWN: nil

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # UTF-16
  #
  UTF16: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # UTF-32
  #
  UTF32: Encoding

  # <!-- rdoc-file=ext/nkf/lib/kconv.rb -->
  # UTF-8
  #
  UTF8: Encoding

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.guess(str)   => encoding
  # -->
  # Guess input encoding by NKF.guess
  #
  def self.guess: (String str) -> Encoding

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.iseuc(str)   => true or false
  # -->
  # Returns whether input encoding is EUC-JP or not.
  #
  # **Note** don't expect this return value is MatchData.
  #
  def self.iseuc: (String str) -> bool

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.isjis(str)   => true or false
  # -->
  # Returns whether input encoding is ISO-2022-JP or not.
  #
  def self.isjis: (String str) -> bool

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.issjis(str)   => true or false
  # -->
  # Returns whether input encoding is Shift_JIS or not.
  #
  def self.issjis: (String str) -> bool

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.isutf8(str)   => true or false
  # -->
  # Returns whether input encoding is UTF-8 or not.
  #
  def self.isutf8: (String str) -> bool

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.kconv(str, to_enc, from_enc=nil)
  # -->
  # Convert `str` to `to_enc`. `to_enc` and `from_enc` are given as constants of
  # Kconv or Encoding objects.
  #
  def self.kconv: (String str, Encoding? out_code, ?Encoding? in_code) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.toeuc(str)   => string
  # -->
  # Convert `str` to EUC-JP
  #
  def self.toeuc: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.tojis(str)   => string
  # -->
  # Convert `str` to ISO-2022-JP
  #
  def self.tojis: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.tolocale   => string
  # -->
  # Convert `self` to locale encoding
  #
  def self.tolocale: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.tosjis(str)   => string
  # -->
  # Convert `str` to Shift_JIS
  #
  def self.tosjis: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.toutf16(str)   => string
  # -->
  # Convert `str` to UTF-16
  #
  def self.toutf16: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.toutf32(str)   => string
  # -->
  # Convert `str` to UTF-32
  #
  def self.toutf32: (String str) -> String

  # <!--
  #   rdoc-file=ext/nkf/lib/kconv.rb
  #   - Kconv.toutf8(str)   => string
  # -->
  # Convert `str` to UTF-8
  #
  def self.toutf8: (String str) -> String
end
# <!-- rdoc-file=lib/logger/severity.rb -->
# Logging severity.
#
module Logger::Severity
  # <!-- rdoc-file=lib/logger/severity.rb -->
  # Low-level information, mostly for developers.
  #
  DEBUG: 0

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # Generic (useful) information about system operation.
  #
  INFO: 1

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # A warning.
  #
  WARN: 2

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # A handleable error condition.
  #
  ERROR: 3

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # An unhandleable error that results in a program crash.
  #
  FATAL: 4

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # An unknown message that should always be logged.
  #
  UNKNOWN: 5
end
# <!-- rdoc-file=lib/logger.rb -->
# Class Logger provides a simple but sophisticated logging utility that you can
# use to create one or more [event
# logs](https://en.wikipedia.org/wiki/Logging_(software)#Event_logs) for your
# program. Each such log contains a chronological sequence of entries that
# provides a record of the program's activities.
#
# ## About the Examples
#
# All examples on this page assume that Logger has been required:
#
#     require 'logger'
#
# ## Synopsis
#
# Create a log with Logger.new:
#
#     # Single log file.
#     logger = Logger.new('t.log')
#     # Size-based rotated logging: 3 10-megabyte files.
#     logger = Logger.new('t.log', 3, 10485760)
#     # Period-based rotated logging: daily (also allowed: 'weekly', 'monthly').
#     logger = Logger.new('t.log', 'daily')
#     # Log to an IO stream.
#     logger = Logger.new($stdout)
#
# Add entries (level, message) with Logger#add:
#
#     logger.add(Logger::DEBUG, 'Maximal debugging info')
#     logger.add(Logger::INFO, 'Non-error information')
#     logger.add(Logger::WARN, 'Non-error warning')
#     logger.add(Logger::ERROR, 'Non-fatal error')
#     logger.add(Logger::FATAL, 'Fatal error')
#     logger.add(Logger::UNKNOWN, 'Most severe')
#
# Close the log with Logger#close:
#
#     logger.close
#
# ## Entries
#
# You can add entries with method Logger#add:
#
#     logger.add(Logger::DEBUG, 'Maximal debugging info')
#     logger.add(Logger::INFO, 'Non-error information')
#     logger.add(Logger::WARN, 'Non-error warning')
#     logger.add(Logger::ERROR, 'Non-fatal error')
#     logger.add(Logger::FATAL, 'Fatal error')
#     logger.add(Logger::UNKNOWN, 'Most severe')
#
# These shorthand methods also add entries:
#
#     logger.debug('Maximal debugging info')
#     logger.info('Non-error information')
#     logger.warn('Non-error warning')
#     logger.error('Non-fatal error')
#     logger.fatal('Fatal error')
#     logger.unknown('Most severe')
#
# When you call any of these methods, the entry may or may not be written to the
# log, depending on the entry's severity and on the log level; see [Log
# Level](rdoc-ref:Logger@Log+Level)
#
# An entry always has:
#
# *   A severity (the required argument to #add).
# *   An automatically created timestamp.
#
# And may also have:
#
# *   A message.
# *   A program name.
#
# Example:
#
#     logger = Logger.new($stdout)
#     logger.add(Logger::INFO, 'My message.', 'mung')
#     # => I, [2022-05-07T17:21:46.536234 #20536]  INFO -- mung: My message.
#
# The default format for an entry is:
#
#     "%s, [%s #%d] %5s -- %s: %s\n"
#
# where the values to be formatted are:
#
# *   Severity (one letter).
# *   Timestamp.
# *   Process id.
# *   Severity (word).
# *   Program name.
# *   Message.
#
# You can use a different entry format by:
#
# *   Setting a custom format proc (affects following entries); see
#     [formatter=](Logger.html#attribute-i-formatter).
# *   Calling any of the methods above with a block (affects only the one
#     entry). Doing so can have two benefits:
#
#     *   Context: the block can evaluate the entire program context and create
#         a context-dependent message.
#     *   Performance: the block is not evaluated unless the log level permits
#         the entry actually to be written:
#
#             logger.error { my_slow_message_generator }
#
#         Contrast this with the string form, where the string is always
#         evaluated, regardless of the log level:
#
#             logger.error("#{my_slow_message_generator}")
#
# ### Severity
#
# The severity of a log entry has two effects:
#
# *   Determines whether the entry is selected for inclusion in the log; see
#     [Log Level](rdoc-ref:Logger@Log+Level).
# *   Indicates to any log reader (whether a person or a program) the relative
#     importance of the entry.
#
# ### Timestamp
#
# The timestamp for a log entry is generated automatically when the entry is
# created.
#
# The logged timestamp is formatted by method
# [Time#strftime](rdoc-ref:Time#strftime) using this format string:
#
#     '%Y-%m-%dT%H:%M:%S.%6N'
#
# Example:
#
#     logger = Logger.new($stdout)
#     logger.add(Logger::INFO)
#     # => I, [2022-05-07T17:04:32.318331 #20536]  INFO -- : nil
#
# You can set a different format using method #datetime_format=.
#
# ### Message
#
# The message is an optional argument to an entry method:
#
#     logger = Logger.new($stdout)
#     logger.add(Logger::INFO, 'My message')
#     # => I, [2022-05-07T18:15:37.647581 #20536]  INFO -- : My message
#
# For the default entry formatter, `Logger::Formatter`, the message object may
# be:
#
# *   A string: used as-is.
# *   An Exception: `message.message` is used.
# *   Anything else: `message.inspect` is used.
#
# **Note**: Logger::Formatter does not escape or sanitize the message passed to
# it. Developers should be aware that malicious data (user input) may be in the
# message, and should explicitly escape untrusted data.
#
# You can use a custom formatter to escape message data; see the example at
# [formatter=](Logger.html#attribute-i-formatter).
#
# ### Program Name
#
# The program name is an optional argument to an entry method:
#
#     logger = Logger.new($stdout)
#     logger.add(Logger::INFO, 'My message', 'mung')
#     # => I, [2022-05-07T18:17:38.084716 #20536]  INFO -- mung: My message
#
# The default program name for a new logger may be set in the call to Logger.new
# via optional keyword argument `progname`:
#
#     logger = Logger.new('t.log', progname: 'mung')
#
# The default program name for an existing logger may be set by a call to method
# #progname=:
#
#     logger.progname = 'mung'
#
# The current program name may be retrieved with method
# [progname](Logger.html#attribute-i-progname):
#
#     logger.progname # => "mung"
#
# ## Log Level
#
# The log level setting determines whether an entry is actually written to the
# log, based on the entry's severity.
#
# These are the defined severities (least severe to most severe):
#
#     logger = Logger.new($stdout)
#     logger.add(Logger::DEBUG, 'Maximal debugging info')
#     # => D, [2022-05-07T17:57:41.776220 #20536] DEBUG -- : Maximal debugging info
#     logger.add(Logger::INFO, 'Non-error information')
#     # => I, [2022-05-07T17:59:14.349167 #20536]  INFO -- : Non-error information
#     logger.add(Logger::WARN, 'Non-error warning')
#     # => W, [2022-05-07T18:00:45.337538 #20536]  WARN -- : Non-error warning
#     logger.add(Logger::ERROR, 'Non-fatal error')
#     # => E, [2022-05-07T18:02:41.592912 #20536] ERROR -- : Non-fatal error
#     logger.add(Logger::FATAL, 'Fatal error')
#     # => F, [2022-05-07T18:05:24.703931 #20536] FATAL -- : Fatal error
#     logger.add(Logger::UNKNOWN, 'Most severe')
#     # => A, [2022-05-07T18:07:54.657491 #20536]   ANY -- : Most severe
#
# The default initial level setting is Logger::DEBUG, the lowest level, which
# means that all entries are to be written, regardless of severity:
#
#     logger = Logger.new($stdout)
#     logger.level # => 0
#     logger.add(0, "My message")
#     # => D, [2022-05-11T15:10:59.773668 #20536] DEBUG -- : My message
#
# You can specify a different setting in a new logger using keyword argument
# `level` with an appropriate value:
#
#     logger = Logger.new($stdout, level: Logger::ERROR)
#     logger = Logger.new($stdout, level: 'error')
#     logger = Logger.new($stdout, level: :error)
#     logger.level # => 3
#
# With this level, entries with severity Logger::ERROR and higher are written,
# while those with lower severities are not written:
#
#     logger = Logger.new($stdout, level: Logger::ERROR)
#     logger.add(3)
#     # => E, [2022-05-11T15:17:20.933362 #20536] ERROR -- : nil
#     logger.add(2) # Silent.
#
# You can set the log level for an existing logger with method #level=:
#
#     logger.level = Logger::ERROR
#
# These shorthand methods also set the level:
#
#     logger.debug! # => 0
#     logger.info!  # => 1
#     logger.warn!  # => 2
#     logger.error! # => 3
#     logger.fatal! # => 4
#
# You can retrieve the log level with method #level.
#
#     logger.level = Logger::ERROR
#     logger.level # => 3
#
# These methods return whether a given level is to be written:
#
#     logger.level = Logger::ERROR
#     logger.debug? # => false
#     logger.info?  # => false
#     logger.warn?  # => false
#     logger.error? # => true
#     logger.fatal? # => true
#
# ## Log File Rotation
#
# By default, a log file is a single file that grows indefinitely (until
# explicitly closed); there is no file rotation.
#
# To keep log files to a manageable size, you can use *log* *file* *rotation*,
# which uses multiple log files:
#
# *   Each log file has entries for a non-overlapping time interval.
# *   Only the most recent log file is open and active; the others are closed
#     and inactive.
#
# ### Size-Based Rotation
#
# For size-based log file rotation, call Logger.new with:
#
# *   Argument `logdev` as a file path.
# *   Argument `shift_age` with a positive integer: the number of log files to
#     be in the rotation.
# *   Argument `shift_size` as a positive integer: the maximum size (in bytes)
#     of each log file; defaults to 1048576 (1 megabyte).
#
# Examples:
#
#     logger = Logger.new('t.log', 3)           # Three 1-megabyte files.
#     logger = Logger.new('t.log', 5, 10485760) # Five 10-megabyte files.
#
# For these examples, suppose:
#
#     logger = Logger.new('t.log', 3)
#
# Logging begins in the new log file, `t.log`; the log file is "full" and ready
# for rotation when a new entry would cause its size to exceed `shift_size`.
#
# The first time `t.log` is full:
#
# *   `t.log` is closed and renamed to `t.log.0`.
# *   A new file `t.log` is opened.
#
# The second time `t.log` is full:
#
# *   +t.log.0 is renamed as `t.log.1`.
# *   `t.log` is closed and renamed to `t.log.0`.
# *   A new file `t.log` is opened.
#
# Each subsequent time that `t.log` is full, the log files are rotated:
#
# *   `t.log.1` is removed.
# *   +t.log.0 is renamed as `t.log.1`.
# *   `t.log` is closed and renamed to `t.log.0`.
# *   A new file `t.log` is opened.
#
# ### Periodic Rotation
#
# For periodic rotation, call Logger.new with:
#
# *   Argument `logdev` as a file path.
# *   Argument `shift_age` as a string period indicator.
#
# Examples:
#
#     logger = Logger.new('t.log', 'daily')   # Rotate log files daily.
#     logger = Logger.new('t.log', 'weekly')  # Rotate log files weekly.
#     logger = Logger.new('t.log', 'monthly') # Rotate log files monthly.
#
# Example:
#
#     logger = Logger.new('t.log', 'daily')
#
# When the given period expires:
#
# *   The base log file, `t.log` is closed and renamed with a date-based suffix
#     such as `t.log.20220509`.
# *   A new log file `t.log` is opened.
# *   Nothing is removed.
#
# The default format for the suffix is `'%Y%m%d'`, which produces a suffix
# similar to the one above. You can set a different format using create-time
# option `shift_period_suffix`; see details and suggestions at
# [Time#strftime](rdoc-ref:Time#strftime).
#
class Logger
  interface _WriteCloser
    def write: (_ToS) -> untyped

    def close: () -> untyped
  end
  type logdev = _WriteCloser | String

  include Logger::Severity

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - <<(msg)
  # -->
  # Writes the given `msg` to the log with no formatting; returns the number of
  # characters written, or `nil` if no log device exists:
  #
  #     logger = Logger.new($stdout)
  #     logger << 'My message.' # => 10
  #
  # Output:
  #
  #     My message.
  #
  def <<: (untyped msg) -> (untyped | nil)

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - add(severity, message = nil, progname = nil) { || ... }
  # -->
  # Creates a log entry, which may or may not be written to the log, depending on
  # the entry's severity and on the log level. See [Log
  # Level](rdoc-ref:Logger@Log+Level) and [Entries](rdoc-ref:Logger@Entries) for
  # details.
  #
  # Examples:
  #
  #     logger = Logger.new($stdout, progname: 'mung')
  #     logger.add(Logger::INFO)
  #     logger.add(Logger::ERROR, 'No good')
  #     logger.add(Logger::ERROR, 'No good', 'gnum')
  #
  # Output:
  #
  #     I, [2022-05-12T16:25:31.469726 #36328]  INFO -- mung: mung
  #     E, [2022-05-12T16:25:55.349414 #36328] ERROR -- mung: No good
  #     E, [2022-05-12T16:26:35.841134 #36328] ERROR -- gnum: No good
  #
  # These convenience methods have implicit severity:
  #
  # *   #debug.
  # *   #info.
  # *   #warn.
  # *   #error.
  # *   #fatal.
  # *   #unknown.
  #
  def add: (Integer severity, ?untyped message, ?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - close()
  # -->
  # Closes the logger; returns `nil`:
  #
  #     logger = Logger.new('t.log')
  #     logger.close       # => nil
  #     logger.info('foo') # Prints "log writing failed. closed stream"
  #
  # Related: Logger#reopen.
  #
  def close: () -> untyped

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - datetime_format()
  # -->
  # Returns the date-time format; see #datetime_format=.
  #
  def datetime_format: () -> String?

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - datetime_format=(datetime_format)
  # -->
  # Sets the date-time format.
  #
  # Argument `datetime_format` should be either of these:
  #
  # *   A string suitable for use as a format for method
  #     [Time#strftime](rdoc-ref:Time#strftime).
  # *   `nil`: the logger uses `'%Y-%m-%dT%H:%M:%S.%6N'`.
  #
  def datetime_format=: (String datetime_format) -> String
                      | (nil datetime_format) -> nil

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::DEBUG`.
  #
  def debug: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug!()
  # -->
  # Sets the log level to Logger::DEBUG. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  def debug!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug?()
  # -->
  # Returns `true` if the log level allows entries with severity Logger::DEBUG to
  # be written, `false` otherwise. See [Log Level](rdoc-ref:Logger@Log+Level).
  #
  def debug?: () -> bool

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::ERROR`.
  #
  def error: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error!()
  # -->
  # Sets the log level to Logger::ERROR. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  def error!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error?()
  # -->
  # Returns `true` if the log level allows entries with severity Logger::ERROR to
  # be written, `false` otherwise. See [Log Level](rdoc-ref:Logger@Log+Level).
  #
  def error?: () -> bool

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::FATAL`.
  #
  def fatal: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal!()
  # -->
  # Sets the log level to Logger::FATAL. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  def fatal!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal?()
  # -->
  # Returns `true` if the log level allows entries with severity Logger::FATAL to
  # be written, `false` otherwise. See [Log Level](rdoc-ref:Logger@Log+Level).
  #
  def fatal?: () -> bool

  # <!-- rdoc-file=lib/logger.rb -->
  # Sets or retrieves the logger entry formatter proc.
  #
  # When `formatter` is `nil`, the logger uses Logger::Formatter.
  #
  # When `formatter` is a proc, a new entry is formatted by the proc, which is
  # called with four arguments:
  #
  # *   `severity`: The severity of the entry.
  # *   `time`: A Time object representing the entry's timestamp.
  # *   `progname`: The program name for the entry.
  # *   `msg`: The message for the entry (string or string-convertible object).
  #
  # The proc should return a string containing the formatted entry.
  #
  # This custom formatter uses [String#dump](rdoc-ref:String#dump) to escape the
  # message string:
  #
  #     logger = Logger.new($stdout, progname: 'mung')
  #     original_formatter = logger.formatter || Logger::Formatter.new
  #     logger.formatter = proc { |severity, time, progname, msg|
  #       original_formatter.call(severity, time, progname, msg.dump)
  #     }
  #     logger.add(Logger::INFO, "hello \n ''")
  #     logger.add(Logger::INFO, "\f\x00\xff\\\"")
  #
  # Output:
  #
  #     I, [2022-05-13T13:16:29.637488 #8492]  INFO -- mung: "hello \n ''"
  #     I, [2022-05-13T13:16:29.637610 #8492]  INFO -- mung: "\f\x00\xFF\\\""
  #
  def formatter: () -> (_Formatter | nil)

  # <!-- rdoc-file=lib/logger.rb -->
  # Sets or retrieves the logger entry formatter proc.
  #
  # When `formatter` is `nil`, the logger uses Logger::Formatter.
  #
  # When `formatter` is a proc, a new entry is formatted by the proc, which is
  # called with four arguments:
  #
  # *   `severity`: The severity of the entry.
  # *   `time`: A Time object representing the entry's timestamp.
  # *   `progname`: The program name for the entry.
  # *   `msg`: The message for the entry (string or string-convertible object).
  #
  # The proc should return a string containing the formatted entry.
  #
  # This custom formatter uses [String#dump](rdoc-ref:String#dump) to escape the
  # message string:
  #
  #     logger = Logger.new($stdout, progname: 'mung')
  #     original_formatter = logger.formatter || Logger::Formatter.new
  #     logger.formatter = proc { |severity, time, progname, msg|
  #       original_formatter.call(severity, time, progname, msg.dump)
  #     }
  #     logger.add(Logger::INFO, "hello \n ''")
  #     logger.add(Logger::INFO, "\f\x00\xff\\\"")
  #
  # Output:
  #
  #     I, [2022-05-13T13:16:29.637488 #8492]  INFO -- mung: "hello \n ''"
  #     I, [2022-05-13T13:16:29.637610 #8492]  INFO -- mung: "\f\x00\xFF\\\""
  #
  def formatter=: (_Formatter) -> _Formatter
                | (nil) -> nil

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::INFO`.
  #
  def info: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info!()
  # -->
  # Sets the log level to Logger::INFO. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  def info!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info?()
  # -->
  # Returns `true` if the log level allows entries with severity Logger::INFO to
  # be written, `false` otherwise. See [Log Level](rdoc-ref:Logger@Log+Level).
  #
  def info?: () -> bool

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - level()
  # -->
  # Logging severity threshold (e.g. `Logger::INFO`).
  #
  def level: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - level=(severity)
  # -->
  # Sets the log level; returns `severity`. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  # Argument `severity` may be an integer, a string, or a symbol:
  #
  #     logger.level = Logger::ERROR # => 3
  #     logger.level = 3             # => 3
  #     logger.level = 'error'       # => "error"
  #     logger.level = :error        # => :error
  #
  # Logger#sev_threshold= is an alias for Logger#level=.
  #
  def level=: (Integer | interned severity) -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - log(severity, message = nil, progname = nil)
  # -->
  #
  alias log add

  # <!-- rdoc-file=lib/logger.rb -->
  # Program name to include in log messages.
  #
  def progname: () -> untyped

  # <!-- rdoc-file=lib/logger.rb -->
  # Program name to include in log messages.
  #
  def progname=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - reopen(logdev = nil)
  # -->
  # Sets the logger's output stream:
  #
  # *   If `logdev` is `nil`, reopens the current output stream.
  # *   If `logdev` is a filepath, opens the indicated file for append.
  # *   If `logdev` is an IO stream (usually `$stdout`, `$stderr`, or an open File
  #     object), opens the stream for append.
  #
  # Example:
  #
  #     logger = Logger.new('t.log')
  #     logger.add(Logger::ERROR, 'one')
  #     logger.close
  #     logger.add(Logger::ERROR, 'two') # Prints 'log writing failed. closed stream'
  #     logger.reopen
  #     logger.add(Logger::ERROR, 'three')
  #     logger.close
  #     File.readlines('t.log')
  #     # =>
  #     # ["# Logfile created on 2022-05-12 14:21:19 -0500 by logger.rb/v1.5.0\n",
  #     #  "E, [2022-05-12T14:21:27.596726 #22428] ERROR -- : one\n",
  #     #  "E, [2022-05-12T14:23:05.847241 #22428] ERROR -- : three\n"]
  #
  def reopen: () -> self
            | (logdev?) -> self

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - sev_threshold()
  # -->
  #
  alias sev_threshold level

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - sev_threshold=(severity)
  # -->
  #
  alias sev_threshold= level=

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - unknown(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::UNKNOWN`.
  #
  def unknown: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn(progname = nil, &block)
  # -->
  # Equivalent to calling #add with severity `Logger::WARN`.
  #
  def warn: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn!()
  # -->
  # Sets the log level to Logger::WARN. See [Log
  # Level](rdoc-ref:Logger@Log+Level).
  #
  def warn!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn?()
  # -->
  # Returns `true` if the log level allows entries with severity Logger::WARN to
  # be written, `false` otherwise. See [Log Level](rdoc-ref:Logger@Log+Level).
  #
  def warn?: () -> bool

  private

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - format_message(severity, datetime, progname, msg)
  # -->
  #
  def format_message: (String severity, Time datetime, untyped progname, untyped msg) -> _ToS

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - format_severity(severity)
  # -->
  #
  def format_severity: (Integer severity) -> String

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - Logger.new(logdev, shift_age = 0, shift_size = 1048576, **options)
  # -->
  # With the single argument `logdev`, returns a new logger with all default
  # options:
  #
  #     Logger.new('t.log') # => #<Logger:0x000001e685dc6ac8>
  #
  # Argument `logdev` must be one of:
  #
  # *   A string filepath: entries are to be written to the file at that path; if
  #     the file at that path exists, new entries are appended.
  # *   An IO stream (typically +$stdout+, +$stderr+. or an open file): entries
  #     are to be written to the given stream.
  # *   `nil` or `File::NULL`: no entries are to be written.
  #
  # Examples:
  #
  #     Logger.new('t.log')
  #     Logger.new($stdout)
  #
  # The keyword options are:
  #
  # *   `level`: sets the log level; default value is Logger::DEBUG. See [Log
  #     Level](rdoc-ref:Logger@Log+Level):
  #
  #         Logger.new('t.log', level: Logger::ERROR)
  #
  # *   `progname`: sets the default program name; default is `nil`. See [Program
  #     Name](rdoc-ref:Logger@Program+Name):
  #
  #         Logger.new('t.log', progname: 'mung')
  #
  # *   `formatter`: sets the entry formatter; default is `nil`. See
  #     [formatter=](Logger.html#attribute-i-formatter).
  # *   `datetime_format`: sets the format for entry timestamp; default is `nil`.
  #     See #datetime_format=.
  # *   `binmode`: sets whether the logger writes in binary mode; default is
  #     `false`.
  # *   `shift_period_suffix`: sets the format for the filename suffix for
  #     periodic log file rotation; default is `'%Y%m%d'`. See [Periodic
  #     Rotation](rdoc-ref:Logger@Periodic+Rotation).
  # *   `reraise_write_errors`: An array of exception classes, which will be
  #     reraised if there is an error when writing to the log device. The default
  #     is to swallow all exceptions raised.
  #
  def initialize: (logdev? logdev, ?Numeric | String shift_age, ?Integer shift_size, ?shift_period_suffix: String, ?binmode: boolish, ?datetime_format: String, ?formatter: _Formatter, ?progname: String, ?level: Integer | interned) -> void
end

Logger::ProgName: String

# <!-- rdoc-file=lib/logger.rb -->
# Severity label for logging (max 5 chars).
#
Logger::SEV_LABEL: Array[String]

Logger::VERSION: String
module Logger::Period
  # <!--
  #   rdoc-file=lib/logger/period.rb
  #   - next_rotate_time(now, shift_age)
  # -->
  #
  def self?.next_rotate_time: (Time now, String shift_age) -> untyped

  # <!--
  #   rdoc-file=lib/logger/period.rb
  #   - previous_period_end(now, shift_age)
  # -->
  #
  def self?.previous_period_end: (Time now, String shift_age) -> untyped

  SiD: Integer
end
%a{annotate:rdoc:skip}
class Logger
  # <!-- rdoc-file=lib/logger/log_device.rb -->
  # Device used for logging messages.
  #
  class LogDevice
    include MonitorMixin

    include Period

    attr_reader dev: _WriteCloser
    attr_reader filename: String?

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - close()
    # -->
    #
    def close: () -> nil

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - reopen(log = nil)
    # -->
    #
    def reopen: (?logdev log) -> self

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - write(message)
    # -->
    #
    def write: (untyped message) -> untyped

    private

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - add_log_header(file)
    # -->
    #
    def add_log_header: (IO file) -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - check_shift_log()
    # -->
    #
    def check_shift_log: () -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - create_logfile(filename)
    # -->
    #
    def create_logfile: (String filename) -> File

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - new(log = nil, shift_age: nil, shift_size: nil, shift_period_suffix: nil, binmode: false, reraise_write_errors: [])
    # -->
    #
    def initialize: (?untyped logdev, ?binmode: boolish, ?shift_period_suffix: String, ?shift_size: Integer, ?shift_age: Numeric | String) -> void

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - lock_shift_log() { || ... }
    # -->
    #
    def lock_shift_log: () { () -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - open_logfile(filename)
    # -->
    #
    def open_logfile: (String filename) -> File

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - set_dev(log)
    # -->
    #
    def set_dev: (logdev log) -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - shift_log_age()
    # -->
    #
    def shift_log_age: () -> true

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - shift_log_period(period_end)
    # -->
    #
    def shift_log_period: (Time period_end) -> true
  end
end
%a{annotate:rdoc:skip}
class Logger
  # <!-- rdoc-file=lib/logger/formatter.rb -->
  # Default formatter for log messages.
  #
  class Formatter
    attr_accessor datetime_format: String?

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - call(severity, time, progname, msg)
    # -->
    #
    def call: (String severity, Time time, untyped progname, untyped msg) -> String

    private

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - format_datetime(time)
    # -->
    #
    def format_datetime: (Time time) -> untyped

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - new()
    # -->
    #
    def initialize: () -> void

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - msg2str(msg)
    # -->
    #
    def msg2str: (String | Exception | untyped msg) -> String
  end

  interface _Formatter
    def call: (String severity, Time time, untyped progname, untyped msg) -> _ToS
  end
end

Logger::Formatter::Format: String
# <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
# Use the Monitor class when you want to have a lock object for blocks with
# mutual exclusion.
#
#     require 'monitor'
#
#     lock = Monitor.new
#     lock.synchronize do
#       # exclusive access
#     end
#
class Monitor
  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - enter()
  # -->
  #
  def enter: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - exit()
  # -->
  #
  def exit: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_check_owner()
  # -->
  #
  def mon_check_owner: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_enter()
  # -->
  #
  alias mon_enter enter

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_exit()
  # -->
  #
  alias mon_exit exit

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_locked?()
  # -->
  #
  def mon_locked?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_owned?()
  # -->
  #
  def mon_owned?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_synchronize()
  # -->
  #
  alias mon_synchronize synchronize

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_try_enter()
  # -->
  #
  alias mon_try_enter try_enter

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new_cond()
  # -->
  #
  def new_cond: () -> ::MonitorMixin::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - synchronize()
  # -->
  #
  def synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - try_enter()
  # -->
  #
  def try_enter: () -> bool

  # <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
  # for compatibility
  #
  alias try_mon_enter try_enter

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - wait_for_cond(p1, p2)
  # -->
  #
  def wait_for_cond: (::MonitorMixin::ConditionVariable, Numeric? timeout) -> untyped
end

# <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
# In concurrent programming, a monitor is an object or module intended to be
# used safely by more than one thread. The defining characteristic of a monitor
# is that its methods are executed with mutual exclusion. That is, at each point
# in time, at most one thread may be executing any of its methods. This mutual
# exclusion greatly simplifies reasoning about the implementation of monitors
# compared to reasoning about parallel code that updates a data structure.
#
# You can read more about the general principles on the Wikipedia page for
# [Monitors](https://en.wikipedia.org/wiki/Monitor_%28synchronization%29).
#
# ## Examples
#
# ### Simple object.extend
#
#     require 'monitor.rb'
#
#     buf = []
#     buf.extend(MonitorMixin)
#     empty_cond = buf.new_cond
#
#     # consumer
#     Thread.start do
#       loop do
#         buf.synchronize do
#           empty_cond.wait_while { buf.empty? }
#           print buf.shift
#         end
#       end
#     end
#
#     # producer
#     while line = ARGF.gets
#       buf.synchronize do
#         buf.push(line)
#         empty_cond.signal
#       end
#     end
#
# The consumer thread waits for the producer thread to push a line to buf while
# `buf.empty?`. The producer thread (main thread) reads a line from ARGF and
# pushes it into buf then calls `empty_cond.signal` to notify the consumer
# thread of new data.
#
# ### Simple Class include
#
#     require 'monitor'
#
#     class SynchronizedArray < Array
#
#       include MonitorMixin
#
#       def initialize(*args)
#         super(*args)
#       end
#
#       alias :old_shift :shift
#       alias :old_unshift :unshift
#
#       def shift(n=1)
#         self.synchronize do
#           self.old_shift(n)
#         end
#       end
#
#       def unshift(item)
#         self.synchronize do
#           self.old_unshift(item)
#         end
#       end
#
#       # other methods ...
#     end
#
# `SynchronizedArray` implements an Array with synchronized access to items.
# This Class is implemented as subclass of Array which includes the MonitorMixin
# module.
#
module MonitorMixin
  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - extend_object(obj)
  # -->
  #
  def self.extend_object: (untyped obj) -> untyped

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_enter()
  # -->
  # Enters exclusive section.
  #
  def mon_enter: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_exit()
  # -->
  # Leaves exclusive section.
  #
  def mon_exit: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_locked?()
  # -->
  # Returns true if this monitor is locked by any thread
  #
  def mon_locked?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_owned?()
  # -->
  # Returns true if this monitor is locked by current thread.
  #
  def mon_owned?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_synchronize(&b)
  # -->
  # Enters exclusive section and executes the block.  Leaves the exclusive section
  # automatically when the block exits.  See example under `MonitorMixin`.
  #
  def mon_synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_try_enter()
  # -->
  # Attempts to enter exclusive section.  Returns `false` if lock fails.
  #
  def mon_try_enter: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new_cond()
  # -->
  # Creates a new MonitorMixin::ConditionVariable associated with the Monitor
  # object.
  #
  def new_cond: () -> ::MonitorMixin::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - synchronize(&b)
  # -->
  #
  alias synchronize mon_synchronize

  # <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
  # For backward compatibility
  #
  alias try_mon_enter mon_try_enter

  private

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new(...)
  # -->
  # Use `extend MonitorMixin` or `include MonitorMixin` instead of this
  # constructor.  Have look at the examples above to understand how to use this
  # module.
  #
  def initialize: (*untyped) { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_check_owner()
  # -->
  #
  def mon_check_owner: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_initialize()
  # -->
  # Initializes the MonitorMixin after being included in a class or when an object
  # has been extended with the MonitorMixin
  #
  def mon_initialize: () -> untyped
end

# <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
# FIXME: This isn't documented in Nutshell.
#
# Since MonitorMixin.new_cond returns a ConditionVariable, and the example above
# calls while_wait and signal, this class should be documented.
#
class MonitorMixin::ConditionVariable
  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - broadcast()
  # -->
  # Wakes up all threads waiting for this lock.
  #
  def broadcast: () -> Thread::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - signal()
  # -->
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal: () -> Thread::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait(timeout = nil)
  # -->
  # Releases the lock held in the associated monitor and waits; reacquires the
  # lock on wakeup.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed,
  # even if no other thread doesn't signal.
  #
  def wait: (?Numeric? timeout) -> untyped

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait_until()
  # -->
  # Calls wait repeatedly until the given block yields a truthy value.
  #
  def wait_until: () { () -> boolish } -> untyped

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait_while()
  # -->
  # Calls wait repeatedly while the given block yields a truthy value.
  #
  def wait_while: () { () -> boolish } -> untyped

  private

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new(monitor)
  # -->
  #
  def initialize: (Monitor monitor) -> void
end
# <!-- rdoc-file=lib/mutex_m.rb -->
# # mutex_m.rb
#
# When 'mutex_m' is required, any object that extends or includes Mutex_m will
# be treated like a Mutex.
#
# Start by requiring the standard library Mutex_m:
#
#     require "mutex_m.rb"
#
# From here you can extend an object with Mutex instance methods:
#
#     obj = Object.new
#     obj.extend Mutex_m
#
# Or mixin Mutex_m into your module to your class inherit Mutex instance methods
# --- remember to call super() in your class initialize method.
#
#     class Foo
#       include Mutex_m
#       def initialize
#         # ...
#         super()
#       end
#       # ...
#     end
#     obj = Foo.new
#     # this obj can be handled like Mutex
#
module Mutex_m
  def self.append_features: (Module cl) -> untyped

  def self.define_aliases: (Module cl) -> untyped

  def self.extend_object: (Object obj) -> untyped

  def mu_extended: () -> untyped

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_lock()
  # -->
  # See Thread::Mutex#lock
  #
  def mu_lock: () -> Thread::Mutex

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_locked?()
  # -->
  # See Thread::Mutex#locked?
  #
  def mu_locked?: () -> bool

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_synchronize(&block)
  # -->
  # See Thread::Mutex#synchronize
  #
  def mu_synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_try_lock()
  # -->
  # See Thread::Mutex#try_lock
  #
  def mu_try_lock: () -> bool

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_unlock()
  # -->
  # See Thread::Mutex#unlock
  #
  def mu_unlock: () -> Thread::Mutex

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - sleep(timeout = nil)
  # -->
  # See Thread::Mutex#sleep
  #
  def sleep: (?Numeric timeout) -> Integer?

  alias locked? mu_locked?

  alias lock mu_lock

  alias unlock mu_unlock

  alias try_lock mu_try_lock

  alias synchronize mu_synchronize

  private

  def initialize: (*untyped args) -> untyped

  def mu_initialize: () -> untyped
end

Mutex_m::VERSION: String
module Net
  type headers = Hash[String | Symbol, untyped]

  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # <!-- rdoc-file=lib/net/http.rb -->
  # Class Net::HTTP provides a rich library that implements the client in a
  # client-server model that uses the HTTP request-response protocol. For
  # information about HTTP, see:
  #
  # *   [Hypertext Transfer
  #     Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  # *   [Technical
  #     overview](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Techni
  #     cal_overview).
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Strategies
  #
  # *   If you will make only a few GET requests, consider using
  #     [OpenURI](rdoc-ref:OpenURI).
  # *   If you will make only a few requests of all kinds, consider using the
  #     various singleton convenience methods in this class. Each of the following
  #     methods automatically starts and finishes a
  #     [session](rdoc-ref:Net::HTTP@Sessions) that sends a single request:
  #
  #         # Return string response body.
  #         Net::HTTP.get(hostname, path)
  #         Net::HTTP.get(uri)
  #
  #         # Write string response body to $stdout.
  #         Net::HTTP.get_print(hostname, path)
  #         Net::HTTP.get_print(uri)
  #
  #         # Return response as Net::HTTPResponse object.
  #         Net::HTTP.get_response(hostname, path)
  #         Net::HTTP.get_response(uri)
  #         data = '{"title": "foo", "body": "bar", "userId": 1}'
  #         Net::HTTP.post(uri, data)
  #         params = {title: 'foo', body: 'bar', userId: 1}
  #         Net::HTTP.post_form(uri, params)
  #         data = '{"title": "foo", "body": "bar", "userId": 1}'
  #         Net::HTTP.put(uri, data)
  #
  # *   If performance is important, consider using sessions, which lower request
  #     overhead. This [session](rdoc-ref:Net::HTTP@Sessions) has multiple
  #     requests for [HTTP
  #     methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request
  #     _methods) and [WebDAV
  #     methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #         Net::HTTP.start(hostname) do |http|
  #           # Session started automatically before block execution.
  #           http.get(path)
  #           http.head(path)
  #           body = 'Some text'
  #           http.post(path, body)  # Can also have a block.
  #           http.put(path, body)
  #           http.delete(path)
  #           http.options(path)
  #           http.trace(path)
  #           http.patch(path, body) # Can also have a block.
  #           http.copy(path)
  #           http.lock(path, body)
  #           http.mkcol(path, body)
  #           http.move(path)
  #           http.propfind(path, body)
  #           http.proppatch(path, body)
  #           http.unlock(path, body)
  #           # Session finished automatically at block exit.
  #         end
  #
  # The methods cited above are convenience methods that, via their few arguments,
  # allow minimal control over the requests. For greater control, consider using
  # [request objects](rdoc-ref:Net::HTTPRequest).
  #
  # ## URIs
  #
  # On the internet, a URI ([Universal Resource
  # Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)) is a
  # string that identifies a particular resource. It consists of some or all of:
  # scheme, hostname, path, query, and fragment; see [URI
  # syntax](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax).
  #
  # A Ruby [URI::Generic](rdoc-ref:URI::Generic) object represents an internet
  # URI. It provides, among others, methods `scheme`, `hostname`, `path`, `query`,
  # and `fragment`.
  #
  # ### Schemes
  #
  # An internet URI has a
  # [scheme](https://en.wikipedia.org/wiki/List_of_URI_schemes).
  #
  # The two schemes supported in Net::HTTP are `'https'` and `'http'`:
  #
  #     uri.scheme                       # => "https"
  #     URI('http://example.com').scheme # => "http"
  #
  # ### Hostnames
  #
  # A hostname identifies a server (host) to which requests may be sent:
  #
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     Net::HTTP.start(hostname) do |http|
  #       # Some HTTP stuff.
  #     end
  #
  # ### Paths
  #
  # A host-specific path identifies a resource on the host:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #     hostname = _uri.hostname
  #     path = _uri.path
  #     Net::HTTP.get(hostname, path)
  #
  # ### Queries
  #
  # A host-specific query adds name/value pairs to the URI:
  #
  #     _uri = uri.dup
  #     params = {userId: 1, completed: false}
  #     _uri.query = URI.encode_www_form(params)
  #     _uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&completed=false>
  #     Net::HTTP.get(_uri)
  #
  # ### Fragments
  #
  # A [URI fragment](https://en.wikipedia.org/wiki/URI_fragment) has no effect in
  # Net::HTTP; the same data is returned, regardless of whether a fragment is
  # included.
  #
  # ## Request Headers
  #
  # Request headers may be used to pass additional information to the host,
  # similar to arguments passed in a method call; each header is a name/value
  # pair.
  #
  # Each of the Net::HTTP methods that sends a request to the host has optional
  # argument `headers`, where the headers are expressed as a hash of
  # field-name/value pairs:
  #
  #     headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
  #     Net::HTTP.get(uri, headers)
  #
  # See lists of both standard request fields and common request fields at
  # [Request
  # Fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_field
  # s). A host may also accept other custom fields.
  #
  # ## HTTP Sessions
  #
  # A *session* is a connection between a server (host) and a client that:
  #
  # *   Is begun by instance method Net::HTTP#start.
  # *   May contain any number of requests.
  # *   Is ended by instance method Net::HTTP#finish.
  #
  # See example sessions at [Strategies](rdoc-ref:Net::HTTP@Strategies).
  #
  # ### Session Using Net::HTTP.start
  #
  # If you have many requests to make to a single host (and port), consider using
  # singleton method Net::HTTP.start with a block; the method handles the session
  # automatically by:
  #
  # *   Calling #start before block execution.
  # *   Executing the block.
  # *   Calling #finish after block execution.
  #
  # In the block, you can use these instance methods, each of which that sends a
  # single request:
  #
  # *   [HTTP
  #     methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request
  #     _methods):
  #
  #     *   #get, #request_get: GET.
  #     *   #head, #request_head: HEAD.
  #     *   #post, #request_post: POST.
  #     *   #delete: DELETE.
  #     *   #options: OPTIONS.
  #     *   #trace: TRACE.
  #     *   #patch: PATCH.
  #
  # *   [WebDAV methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #     *   #copy: COPY.
  #     *   #lock: LOCK.
  #     *   #mkcol: MKCOL.
  #     *   #move: MOVE.
  #     *   #propfind: PROPFIND.
  #     *   #proppatch: PROPPATCH.
  #     *   #unlock: UNLOCK.
  #
  # ### Session Using Net::HTTP.start and Net::HTTP.finish
  #
  # You can manage a session manually using methods #start and #finish:
  #
  #     http = Net::HTTP.new(hostname)
  #     http.start
  #     http.get('/todos/1')
  #     http.get('/todos/2')
  #     http.delete('/posts/1')
  #     http.finish # Needed to free resources.
  #
  # ### Single-Request Session
  #
  # Certain convenience methods automatically handle a session by:
  #
  # *   Creating an HTTP object
  # *   Starting a session.
  # *   Sending a single request.
  # *   Finishing the session.
  # *   Destroying the object.
  #
  # Such methods that send GET requests:
  #
  # *   ::get: Returns the string response body.
  # *   ::get_print: Writes the string response body to $stdout.
  # *   ::get_response: Returns a Net::HTTPResponse object.
  #
  # Such methods that send POST requests:
  #
  # *   ::post: Posts data to the host.
  # *   ::post_form: Posts form data to the host.
  #
  # ## HTTP Requests and Responses
  #
  # Many of the methods above are convenience methods, each of which sends a
  # request and returns a string without directly using Net::HTTPRequest and
  # Net::HTTPResponse objects.
  #
  # You can, however, directly create a request object, send the request, and
  # retrieve the response object; see:
  #
  # *   Net::HTTPRequest.
  # *   Net::HTTPResponse.
  #
  # ## Following Redirection
  #
  # Each returned response is an instance of a subclass of Net::HTTPResponse. See
  # the [response class
  # hierarchy](rdoc-ref:Net::HTTPResponse@Response+Subclasses).
  #
  # In particular, class Net::HTTPRedirection is the parent of all redirection
  # classes. This allows you to craft a case statement to handle redirections
  # properly:
  #
  #     def fetch(uri, limit = 10)
  #       # You should choose a better exception.
  #       raise ArgumentError, 'Too many HTTP redirects' if limit == 0
  #
  #       res = Net::HTTP.get_response(URI(uri))
  #       case res
  #       when Net::HTTPSuccess     # Any success class.
  #         res
  #       when Net::HTTPRedirection # Any redirection class.
  #         location = res['Location']
  #         warn "Redirected to #{location}"
  #         fetch(location, limit - 1)
  #       else                      # Any other class.
  #         res.value
  #       end
  #     end
  #
  #     fetch(uri)
  #
  # ## Basic Authentication
  #
  # Basic authentication is performed according to
  # [RFC2617](http://www.ietf.org/rfc/rfc2617.txt):
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req.basic_auth('user', 'pass')
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # ## Streaming Response Bodies
  #
  # By default Net::HTTP reads an entire response into memory.  If you are
  # handling large files or wish to implement a progress bar you can instead
  # stream the body directly to an IO.
  #
  #     Net::HTTP.start(hostname) do |http|
  #       req = Net::HTTP::Get.new(uri)
  #       http.request(req) do |res|
  #         open('t.tmp', 'w') do |f|
  #           res.read_body do |chunk|
  #             f.write chunk
  #           end
  #         end
  #       end
  #     end
  #
  # ## HTTPS
  #
  # HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=:
  #
  #     Net::HTTP.start(hostname, :use_ssl => true) do |http|
  #       req = Net::HTTP::Get.new(uri)
  #       res = http.request(req)
  #     end
  #
  # Or if you simply want to make a GET request, you may pass in a URI object that
  # has an HTTPS URL. Net::HTTP automatically turns on TLS verification if the URI
  # object has a 'https' URI scheme:
  #
  #     uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
  #     Net::HTTP.get(uri)
  #
  # ## Proxy Server
  #
  # An HTTP object can have a [proxy
  # server](https://en.wikipedia.org/wiki/Proxy_server).
  #
  # You can create an HTTP object with a proxy server using method Net::HTTP.new
  # or method Net::HTTP.start.
  #
  # The proxy may be defined either by argument `p_addr` or by environment
  # variable `'http_proxy'`.
  #
  # ### Proxy Using Argument `p_addr` as a String
  #
  # When argument `p_addr` is a string hostname, the returned `http` has the given
  # host as its proxy:
  #
  #     http = Net::HTTP.new(hostname, nil, 'proxy.example')
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => false
  #     http.proxy_address   # => "proxy.example"
  #     # These use default values.
  #     http.proxy_port      # => 80
  #     http.proxy_user      # => nil
  #     http.proxy_pass      # => nil
  #
  # The port, username, and password for the proxy may also be given:
  #
  #     http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
  #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => false
  #     http.proxy_address   # => "proxy.example"
  #     http.proxy_port      # => 8000
  #     http.proxy_user      # => "pname"
  #     http.proxy_pass      # => "ppass"
  #
  # ### Proxy Using '`ENV['http_proxy']`'
  #
  # When environment variable `'http_proxy'` is set to a URI string, the returned
  # `http` will have the server at that URI as its proxy; note that the URI string
  # must have a protocol such as `'http'` or `'https'`:
  #
  #     ENV['http_proxy'] = 'http://example.com'
  #     http = Net::HTTP.new(hostname)
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => true
  #     http.proxy_address   # => "example.com"
  #     # These use default values.
  #     http.proxy_port      # => 80
  #     http.proxy_user      # => nil
  #     http.proxy_pass      # => nil
  #
  # The URI string may include proxy username, password, and port number:
  #
  #     ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
  #     http = Net::HTTP.new(hostname)
  #     http.proxy?          # => true
  #     http.proxy_from_env? # => true
  #     http.proxy_address   # => "example.com"
  #     http.proxy_port      # => 8000
  #     http.proxy_user      # => "pname"
  #     http.proxy_pass      # => "ppass"
  #
  # ### Filtering Proxies
  #
  # With method Net::HTTP.new (but not Net::HTTP.start), you can use argument
  # `p_no_proxy` to filter proxies:
  #
  # *   Reject a certain address:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
  #         http.proxy_address # => nil
  #
  # *   Reject certain domains or subdomains:
  #
  #         http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
  #         http.proxy_address # => nil
  #
  # *   Reject certain addresses and port combinations:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
  #         http.proxy_address # => "proxy.example"
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
  #         http.proxy_address # => nil
  #
  # *   Reject a list of the types above delimited using a comma:
  #
  #         http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
  #         http.proxy_address # => nil
  #
  #         http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
  #         http.proxy_address # => nil
  #
  # ## Compression and Decompression
  #
  # Net::HTTP does not compress the body of a request before sending.
  #
  # By default, Net::HTTP adds header `'Accept-Encoding'` to a new [request
  # object](rdoc-ref:Net::HTTPRequest):
  #
  #     Net::HTTP::Get.new(uri)['Accept-Encoding']
  #     # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
  #
  # This requests the server to zip-encode the response body if there is one; the
  # server is not required to do so.
  #
  # Net::HTTP does not automatically decompress a response body if the response
  # has header `'Content-Range'`.
  #
  # Otherwise decompression (or not) depends on the value of header
  # [Content-Encoding](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#co
  # ntent-encoding-response-header):
  #
  # *   `'deflate'`, `'gzip'`, or `'x-gzip'`: decompresses the body and deletes
  #     the header.
  # *   `'none'` or `'identity'`: does not decompress the body, but deletes the
  #     header.
  # *   Any other value: leaves the body and header unchanged.
  #
  # ## What's Here
  #
  # First, what's elsewhere. Class Net::HTTP:
  #
  # *   Inherits from [class Object](rdoc-ref:Object@What-27s+Here).
  #
  # This is a categorized summary of methods and attributes.
  #
  # ### Net::HTTP Objects
  #
  # *   [::new](rdoc-ref:Net::HTTP.new): Creates a new instance.
  # *   [#inspect](rdoc-ref:Net::HTTP#inspect): Returns a string representation of
  #     `self`.
  #
  # ### Sessions
  #
  # *   [::start](rdoc-ref:Net::HTTP.start): Begins a new session in a new
  #     Net::HTTP object.
  # *   [#started?](rdoc-ref:Net::HTTP#started?): Returns whether in a session.
  # *   [#finish](rdoc-ref:Net::HTTP#finish): Ends an active session.
  # *   [#start](rdoc-ref:Net::HTTP#start): Begins a new session in an existing
  #     Net::HTTP object (`self`).
  #
  # ### Connections
  #
  # *   [:continue_timeout](rdoc-ref:Net::HTTP#continue_timeout): Returns the
  #     continue timeout.
  # *   [#continue_timeout=](rdoc-ref:Net::HTTP#continue_timeout=): Sets the
  #     continue timeout seconds.
  # *   [:keep_alive_timeout](rdoc-ref:Net::HTTP#keep_alive_timeout): Returns the
  #     keep-alive timeout.
  # *   [:keep_alive_timeout=](rdoc-ref:Net::HTTP#keep_alive_timeout=): Sets the
  #     keep-alive timeout.
  # *   [:max_retries](rdoc-ref:Net::HTTP#max_retries): Returns the maximum
  #     retries.
  # *   [#max_retries=](rdoc-ref:Net::HTTP#max_retries=): Sets the maximum
  #     retries.
  # *   [:open_timeout](rdoc-ref:Net::HTTP#open_timeout): Returns the open
  #     timeout.
  # *   [:open_timeout=](rdoc-ref:Net::HTTP#open_timeout=): Sets the open timeout.
  # *   [:read_timeout](rdoc-ref:Net::HTTP#read_timeout): Returns the open
  #     timeout.
  # *   [:read_timeout=](rdoc-ref:Net::HTTP#read_timeout=): Sets the read timeout.
  # *   [:ssl_timeout](rdoc-ref:Net::HTTP#ssl_timeout): Returns the ssl timeout.
  # *   [:ssl_timeout=](rdoc-ref:Net::HTTP#ssl_timeout=): Sets the ssl timeout.
  # *   [:write_timeout](rdoc-ref:Net::HTTP#write_timeout): Returns the write
  #     timeout.
  # *   [write_timeout=](rdoc-ref:Net::HTTP#write_timeout=): Sets the write
  #     timeout.
  #
  # ### Requests
  #
  # *   [::get](rdoc-ref:Net::HTTP.get): Sends a GET request and returns the
  #     string response body.
  # *   [::get_print](rdoc-ref:Net::HTTP.get_print): Sends a GET request and write
  #     the string response body to $stdout.
  # *   [::get_response](rdoc-ref:Net::HTTP.get_response): Sends a GET request and
  #     returns a response object.
  # *   [::post_form](rdoc-ref:Net::HTTP.post_form): Sends a POST request with
  #     form data and returns a response object.
  # *   [::post](rdoc-ref:Net::HTTP.post): Sends a POST request with data and
  #     returns a response object.
  # *   [::put](rdoc-ref:Net::HTTP.put): Sends a PUT request with data and returns
  #     a response object.
  # *   [#copy](rdoc-ref:Net::HTTP#copy): Sends a COPY request and returns a
  #     response object.
  # *   [#delete](rdoc-ref:Net::HTTP#delete): Sends a DELETE request and returns a
  #     response object.
  # *   [#get](rdoc-ref:Net::HTTP#get): Sends a GET request and returns a response
  #     object.
  # *   [#head](rdoc-ref:Net::HTTP#head): Sends a HEAD request and returns a
  #     response object.
  # *   [#lock](rdoc-ref:Net::HTTP#lock): Sends a LOCK request and returns a
  #     response object.
  # *   [#mkcol](rdoc-ref:Net::HTTP#mkcol): Sends a MKCOL request and returns a
  #     response object.
  # *   [#move](rdoc-ref:Net::HTTP#move): Sends a MOVE request and returns a
  #     response object.
  # *   [#options](rdoc-ref:Net::HTTP#options): Sends a OPTIONS request and
  #     returns a response object.
  # *   [#patch](rdoc-ref:Net::HTTP#patch): Sends a PATCH request and returns a
  #     response object.
  # *   [#post](rdoc-ref:Net::HTTP#post): Sends a POST request and returns a
  #     response object.
  # *   [#propfind](rdoc-ref:Net::HTTP#propfind): Sends a PROPFIND request and
  #     returns a response object.
  # *   [#proppatch](rdoc-ref:Net::HTTP#proppatch): Sends a PROPPATCH request and
  #     returns a response object.
  # *   [#put](rdoc-ref:Net::HTTP#put): Sends a PUT request and returns a response
  #     object.
  # *   [#request](rdoc-ref:Net::HTTP#request): Sends a request and returns a
  #     response object.
  # *   [#request_get](rdoc-ref:Net::HTTP#request_get): Sends a GET request and
  #     forms a response object; if a block given, calls the block with the
  #     object, otherwise returns the object.
  # *   [#request_head](rdoc-ref:Net::HTTP#request_head): Sends a HEAD request and
  #     forms a response object; if a block given, calls the block with the
  #     object, otherwise returns the object.
  # *   [#request_post](rdoc-ref:Net::HTTP#request_post): Sends a POST request and
  #     forms a response object; if a block given, calls the block with the
  #     object, otherwise returns the object.
  # *   [#send_request](rdoc-ref:Net::HTTP#send_request): Sends a request and
  #     returns a response object.
  # *   [#trace](rdoc-ref:Net::HTTP#trace): Sends a TRACE request and returns a
  #     response object.
  # *   [#unlock](rdoc-ref:Net::HTTP#unlock): Sends an UNLOCK request and returns
  #     a response object.
  #
  # ### Responses
  #
  # *   [:close_on_empty_response](rdoc-ref:Net::HTTP#close_on_empty_response):
  #     Returns whether to close connection on empty response.
  # *   [:close_on_empty_response=](rdoc-ref:Net::HTTP#close_on_empty_response=):
  #     Sets whether to close connection on empty response.
  # *   [:ignore_eof](rdoc-ref:Net::HTTP#ignore_eof): Returns whether to ignore
  #     end-of-file when reading a response body with `Content-Length` headers.
  # *   [:ignore_eof=](rdoc-ref:Net::HTTP#ignore_eof=): Sets whether to ignore
  #     end-of-file when reading a response body with `Content-Length` headers.
  # *   [:response_body_encoding](rdoc-ref:Net::HTTP#response_body_encoding):
  #     Returns the encoding to use for the response body.
  # *   [#response_body_encoding=](rdoc-ref:Net::HTTP#response_body_encoding=):
  #     Sets the response body encoding.
  #
  # ### Proxies
  #
  # *   [:proxy_address](rdoc-ref:Net::HTTP#proxy_address): Returns the proxy
  #     address.
  # *   [:proxy_address=](rdoc-ref:Net::HTTP#proxy_address=): Sets the proxy
  #     address.
  # *   [::proxy_class?](rdoc-ref:Net::HTTP.proxy_class?): Returns whether `self`
  #     is a proxy class.
  # *   [#proxy?](rdoc-ref:Net::HTTP#proxy?): Returns whether `self` has a proxy.
  # *   [#proxy_address](rdoc-ref:Net::HTTP#proxy_address): Returns the proxy
  #     address.
  # *   [#proxy_from_env?](rdoc-ref:Net::HTTP#proxy_from_env?): Returns whether
  #     the proxy is taken from an environment variable.
  # *   [:proxy_from_env=](rdoc-ref:Net::HTTP#proxy_from_env=): Sets whether the
  #     proxy is to be taken from an environment variable.
  # *   [:proxy_pass](rdoc-ref:Net::HTTP#proxy_pass): Returns the proxy password.
  # *   [:proxy_pass=](rdoc-ref:Net::HTTP#proxy_pass=): Sets the proxy password.
  # *   [:proxy_port](rdoc-ref:Net::HTTP#proxy_port): Returns the proxy port.
  # *   [:proxy_port=](rdoc-ref:Net::HTTP#proxy_port=): Sets the proxy port.
  # *   [#proxy_user](rdoc-ref:Net::HTTP#proxy_user): Returns the proxy user name.
  # *   [:proxy_user=](rdoc-ref:Net::HTTP#proxy_user=): Sets the proxy user.
  #
  # ### Security
  #
  # *   [:ca_file](rdoc-ref:Net::HTTP#ca_file): Returns the path to a CA
  #     certification file.
  # *   [:ca_file=](rdoc-ref:Net::HTTP#ca_file=): Sets the path to a CA
  #     certification file.
  # *   [:ca_path](rdoc-ref:Net::HTTP#ca_path): Returns the path of to CA
  #     directory containing certification files.
  # *   [:ca_path=](rdoc-ref:Net::HTTP#ca_path=): Sets the path of to CA directory
  #     containing certification files.
  # *   [:cert](rdoc-ref:Net::HTTP#cert): Returns the OpenSSL::X509::Certificate
  #     object to be used for client certification.
  # *   [:cert=](rdoc-ref:Net::HTTP#cert=): Sets the OpenSSL::X509::Certificate
  #     object to be used for client certification.
  # *   [:cert_store](rdoc-ref:Net::HTTP#cert_store): Returns the X509::Store to
  #     be used for verifying peer certificate.
  # *   [:cert_store=](rdoc-ref:Net::HTTP#cert_store=): Sets the X509::Store to be
  #     used for verifying peer certificate.
  # *   [:ciphers](rdoc-ref:Net::HTTP#ciphers): Returns the available SSL ciphers.
  # *   [:ciphers=](rdoc-ref:Net::HTTP#ciphers=): Sets the available SSL ciphers.
  # *   [:extra_chain_cert](rdoc-ref:Net::HTTP#extra_chain_cert): Returns the
  #     extra X509 certificates to be added to the certificate chain.
  # *   [:extra_chain_cert=](rdoc-ref:Net::HTTP#extra_chain_cert=): Sets the extra
  #     X509 certificates to be added to the certificate chain.
  # *   [:key](rdoc-ref:Net::HTTP#key): Returns the OpenSSL::PKey::RSA or
  #     OpenSSL::PKey::DSA object.
  # *   [:key=](rdoc-ref:Net::HTTP#key=): Sets the OpenSSL::PKey::RSA or
  #     OpenSSL::PKey::DSA object.
  # *   [:max_version](rdoc-ref:Net::HTTP#max_version): Returns the maximum SSL
  #     version.
  # *   [:max_version=](rdoc-ref:Net::HTTP#max_version=): Sets the maximum SSL
  #     version.
  # *   [:min_version](rdoc-ref:Net::HTTP#min_version): Returns the minimum SSL
  #     version.
  # *   [:min_version=](rdoc-ref:Net::HTTP#min_version=): Sets the minimum SSL
  #     version.
  # *   [#peer_cert](rdoc-ref:Net::HTTP#peer_cert): Returns the X509 certificate
  #     chain for the session's socket peer.
  # *   [:ssl_version](rdoc-ref:Net::HTTP#ssl_version): Returns the SSL version.
  # *   [:ssl_version=](rdoc-ref:Net::HTTP#ssl_version=): Sets the SSL version.
  # *   [#use_ssl=](rdoc-ref:Net::HTTP#use_ssl=): Sets whether a new session is to
  #     use Transport Layer Security.
  # *   [#use_ssl?](rdoc-ref:Net::HTTP#use_ssl?): Returns whether `self` uses SSL.
  # *   [:verify_callback](rdoc-ref:Net::HTTP#verify_callback): Returns the
  #     callback for the server certification verification.
  # *   [:verify_callback=](rdoc-ref:Net::HTTP#verify_callback=): Sets the
  #     callback for the server certification verification.
  # *   [:verify_depth](rdoc-ref:Net::HTTP#verify_depth): Returns the maximum
  #     depth for the certificate chain verification.
  # *   [:verify_depth=](rdoc-ref:Net::HTTP#verify_depth=): Sets the maximum depth
  #     for the certificate chain verification.
  # *   [:verify_hostname](rdoc-ref:Net::HTTP#verify_hostname): Returns the flags
  #     for server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_hostname=](rdoc-ref:Net::HTTP#verify_hostname=): Sets he flags
  #     for server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_mode](rdoc-ref:Net::HTTP#verify_mode): Returns the flags for
  #     server the certification verification at the beginning of the SSL/TLS
  #     session.
  # *   [:verify_mode=](rdoc-ref:Net::HTTP#verify_mode=): Sets the flags for
  #     server the certification verification at the beginning of the SSL/TLS
  #     session.
  #
  # ### Addresses and Ports
  #
  # *   [:address](rdoc-ref:Net::HTTP#address): Returns the string host name or
  #     host IP.
  # *   [::default_port](rdoc-ref:Net::HTTP.default_port): Returns integer 80, the
  #     default port to use for HTTP requests.
  # *   [::http_default_port](rdoc-ref:Net::HTTP.http_default_port): Returns
  #     integer 80, the default port to use for HTTP requests.
  # *   [::https_default_port](rdoc-ref:Net::HTTP.https_default_port): Returns
  #     integer 443, the default port to use for HTTPS requests.
  # *   [#ipaddr](rdoc-ref:Net::HTTP#ipaddr): Returns the IP address for the
  #     connection.
  # *   [#ipaddr=](rdoc-ref:Net::HTTP#ipaddr=): Sets the IP address for the
  #     connection.
  # *   [:local_host](rdoc-ref:Net::HTTP#local_host): Returns the string local
  #     host used to establish the connection.
  # *   [:local_host=](rdoc-ref:Net::HTTP#local_host=): Sets the string local host
  #     used to establish the connection.
  # *   [:local_port](rdoc-ref:Net::HTTP#local_port): Returns the integer local
  #     port used to establish the connection.
  # *   [:local_port=](rdoc-ref:Net::HTTP#local_port=): Sets the integer local
  #     port used to establish the connection.
  # *   [:port](rdoc-ref:Net::HTTP#port): Returns the integer port number.
  #
  # ### HTTP Version
  #
  # *   [::version_1_2?](rdoc-ref:Net::HTTP.version_1_2?) (aliased as
  #     [::version_1_2](rdoc-ref:Net::HTTP.version_1_2)): Returns true; retained
  #     for compatibility.
  #
  # ### Debugging
  #
  # *   [#set_debug_output](rdoc-ref:Net::HTTP#set_debug_output): Sets the output
  #     stream for debugging.
  #
  class HTTP < Protocol
    # :stopdoc:
    VERSION: String

    Revision: untyped

    HTTPVersion: String

    HAVE_ZLIB: bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2: () -> ::TrueClass

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2?()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2?: () -> ::TrueClass

    def self.version_1_1?: () -> ::FalseClass

    alias self.is_version_1_1? self.version_1_1?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - is_version_1_2?()
    # -->
    #
    alias self.is_version_1_2? self.version_1_2?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_print(hostname, path, port = 80) -> nil
    #   - Net::HTTP:get_print(uri, headers = {}, port = uri.port) -> nil
    # -->
    # Like Net::HTTP.get, but writes the returned body to $stdout; returns `nil`.
    #
    def self.get_print: (URI::Generic uri, ?headers header) -> void
                      | (String host, String path, ?Integer port) -> void

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get(hostname, path, port = 80) -> body
    #   - Net::HTTP:get(uri, headers = {}, port = uri.port) -> body
    # -->
    # Sends a GET request and returns the HTTP response body as a string.
    #
    # With string arguments `hostname` and `path`:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     path = '/todos/1'
    #     puts Net::HTTP.get(hostname, path)
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #
    # With URI object `uri` and optional hash argument `headers`:
    #
    #     uri = URI('https://jsonplaceholder.typicode.com/todos/1')
    #     headers = {'Content-type' => 'application/json; charset=UTF-8'}
    #     Net::HTTP.get(uri, headers)
    #
    # Related:
    #
    # *   Net::HTTP::Get: request class for HTTP method `GET`.
    # *   Net::HTTP#get: convenience method for HTTP method `GET`.
    #
    def self.get: (URI::Generic uri, ?headers header) -> String
                | (String host, String path, ?Integer port) -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_response(hostname, path, port = 80) -> http_response
    #   - Net::HTTP:get_response(uri, headers = {}, port = uri.port) -> http_response
    # -->
    # Like Net::HTTP.get, but returns a Net::HTTPResponse object instead of the body
    # string.
    #
    def self.get_response: (URI::Generic uri, ?headers header) ?{ (Net::HTTPResponse) -> void } -> Net::HTTPResponse
                         | (String host, String path, ?Integer port) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(url, data, header = nil)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URL; argument `data` must be a string:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = '{"title": "foo", "body": "bar", "userId": 1}'
    #     headers = {'content-type': 'application/json'}
    #     res = Net::HTTP.post(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": 1,
    #       "id": 101
    #     }
    #
    # Related:
    #
    # *   Net::HTTP::Post: request class for HTTP method `POST`.
    # *   Net::HTTP#post: convenience method for HTTP method `POST`.
    #
    def self.post: (URI::Generic url, String data, ?headers header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post_form(url, params)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URI; argument `data` must be a hash:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = {title: 'foo', body: 'bar', userId: 1}
    #     res = Net::HTTP.post_form(_uri, data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": "1",
    #       "id": 101
    #     }
    #
    def self.post_form: (URI::Generic url, Hash[String, untyped] params) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - default_port()
    # -->
    # Returns integer `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.default_port # => 80
    #
    def self.default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - http_default_port()
    # -->
    # Returns integer `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.http_default_port # => 80
    #
    def self.http_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - https_default_port()
    # -->
    # Returns integer `443`, the default port to use for HTTPS requests:
    #
    #     Net::HTTP.https_default_port # => 443
    #
    def self.https_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) -> http
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } -> object
    # -->
    # Creates a new Net::HTTP object, `http`, via Net::HTTP.new:
    #
    # *   For arguments `address` and `port`, see Net::HTTP.new.
    # *   For proxy-defining arguments `p_addr` through `p_pass`, see [Proxy
    #     Server](rdoc-ref:Net::HTTP@Proxy+Server).
    # *   For argument `opts`, see below.
    #
    # With no block given:
    #
    # *   Calls `http.start` with no block (see #start), which opens a TCP
    #     connection and HTTP session.
    # *   Returns `http`.
    # *   The caller should call #finish to close the session:
    #
    #         http = Net::HTTP.start(hostname)
    #         http.started? # => true
    #         http.finish
    #         http.started? # => false
    #
    # With a block given:
    #
    # *   Calls `http.start` with the block (see #start), which:
    #
    #     *   Opens a TCP connection and HTTP session.
    #     *   Calls the block, which may make any number of requests to the host.
    #     *   Closes the HTTP session and TCP connection on block exit.
    #     *   Returns the block's value `object`.
    #
    # *   Returns `object`.
    #
    # Example:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     Net::HTTP.start(hostname) do |http|
    #       puts http.get('/todos/1').body
    #       puts http.get('/todos/2').body
    #     end
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #     {
    #       "userId": 1,
    #       "id": 2,
    #       "title": "quis ut nam facilis et officia qui",
    #       "completed": false
    #     }
    #
    # If the last argument given is a hash, it is the `opts` hash, where each key is
    # a method or accessor to be called, and its value is the value to be set.
    #
    # The keys may include:
    #
    # *   #ca_file
    # *   #ca_path
    # *   #cert
    # *   #cert_store
    # *   #ciphers
    # *   #close_on_empty_response
    # *   `ipaddr` (calls #ipaddr=)
    # *   #keep_alive_timeout
    # *   #key
    # *   #open_timeout
    # *   #read_timeout
    # *   #ssl_timeout
    # *   #ssl_version
    # *   `use_ssl` (calls #use_ssl=)
    # *   #verify_callback
    # *   #verify_depth
    # *   #verify_mode
    # *   #write_timeout
    #
    # Note: If `port` is `nil` and `opts[:use_ssl]` is a truthy value, the value
    # passed to `new` is Net::HTTP.https_default_port, not `port`.
    #
    def self.start: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) -> Net::HTTP
                  | [T] (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) { (Net::HTTP) -> T } -> T

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - newobj(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
    # -->
    #
    alias self.newobj self.new

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - new(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil, p_use_ssl = nil)
    # -->
    # Returns a new Net::HTTP object `http` (but does not open a TCP connection or
    # HTTP session).
    #
    # With only string argument `address` given (and `ENV['http_proxy']` undefined
    # or `nil`), the returned `http`:
    #
    # *   Has the given address.
    # *   Has the default port number, Net::HTTP.default_port (80).
    # *   Has no proxy.
    #
    # Example:
    #
    #     http = Net::HTTP.new(hostname)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.address # => "jsonplaceholder.typicode.com"
    #     http.port    # => 80
    #     http.proxy?  # => false
    #
    # With integer argument `port` also given, the returned `http` has the given
    # port:
    #
    #     http = Net::HTTP.new(hostname, 8000)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:8000 open=false>
    #     http.port # => 8000
    #
    # For proxy-defining arguments `p_addr` through `p_no_proxy`, see [Proxy
    # Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def self.new: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?untyped? p_no_proxy) -> Net::HTTP

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - inspect()
    # -->
    # Returns a string representation of `self`:
    #
    #     Net::HTTP.new(hostname).inspect
    #     # => "#<Net::HTTP jsonplaceholder.typicode.com:80 open=false>"
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - set_debug_output(output)
    # -->
    # **WARNING** This method opens a serious security hole. Never use this method
    # in production code.
    #
    # Sets the output stream for debugging:
    #
    #     http = Net::HTTP.new(hostname)
    #     File.open('t.tmp', 'w') do |file|
    #       http.set_debug_output(file)
    #       http.start
    #       http.get('/nosuch/1')
    #       http.finish
    #     end
    #     puts File.read('t.tmp')
    #
    # Output:
    #
    #     opening connection to jsonplaceholder.typicode.com:80...
    #     opened
    #     <- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
    #     -> "HTTP/1.1 404 Not Found\r\n"
    #     -> "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
    #     -> "Content-Type: application/json; charset=utf-8\r\n"
    #     -> "Content-Length: 2\r\n"
    #     -> "Connection: keep-alive\r\n"
    #     -> "X-Powered-By: Express\r\n"
    #     -> "X-Ratelimit-Limit: 1000\r\n"
    #     -> "X-Ratelimit-Remaining: 999\r\n"
    #     -> "X-Ratelimit-Reset: 1670879660\r\n"
    #     -> "Vary: Origin, Accept-Encoding\r\n"
    #     -> "Access-Control-Allow-Credentials: true\r\n"
    #     -> "Cache-Control: max-age=43200\r\n"
    #     -> "Pragma: no-cache\r\n"
    #     -> "Expires: -1\r\n"
    #     -> "X-Content-Type-Options: nosniff\r\n"
    #     -> "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
    #     -> "Via: 1.1 vegur\r\n"
    #     -> "CF-Cache-Status: MISS\r\n"
    #     -> "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
    #     -> "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "Server: cloudflare\r\n"
    #     -> "CF-RAY: 778977dc484ce591-DFW\r\n"
    #     -> "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
    #     -> "\r\n"
    #     reading 2 bytes...
    #     -> "{}"
    #     read 2 bytes
    #     Conn keep-alive
    #
    def set_debug_output: (IO output) -> void

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the string host name or host IP given as argument `address` in ::new.
    #
    attr_reader address: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the integer port number given as argument `port` in ::new.
    #
    attr_reader port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the string local host used to establish the connection;
    # initially `nil`.
    #
    attr_accessor local_host: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the integer local port used to establish the connection;
    # initially `nil`.
    #
    attr_accessor local_port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets whether to determine the proxy from environment variable
    # '`ENV['http_proxy']`'; see [Proxy Using
    # ENV['http_proxy']](rdoc-ref:Net::HTTP@Proxy+Using+-27ENV-5B-27http_proxy-27-5D
    # -27).
    #
    attr_writer proxy_from_env: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy address; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy port; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy user; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the proxy password; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    attr_accessor proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr()
    # -->
    # Returns the IP address for the connection.
    #
    # If the session has not been started, returns the value set by #ipaddr=, or
    # `nil` if it has not been set:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # If the session has been started, returns the IP address from the socket:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.start
    #     http.ipaddr # => "172.67.155.76"
    #     http.finish
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr=(addr)
    # -->
    # Sets the IP address for the connection:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # The IP address may not be set if the session has been started.
    #
    attr_accessor ipaddr: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the numeric (Integer or Float) number of seconds to wait for a
    # connection to open; initially 60. If the connection is not made in the given
    # interval, an exception is raised.
    #
    attr_accessor open_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the numeric (Integer or Float) number of seconds to wait for one block
    # to be read (via one read(2) call); see #read_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - read_timeout=(sec)
    # -->
    # Sets the read timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.read_timeout # => 60
    #     http.get('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #     http.read_timeout = 0
    #     http.get('/todos/1') # Raises Net::ReadTimeout.
    #
    attr_accessor read_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the numeric (Integer or Float) number of seconds to wait for one block
    # to be written (via one write(2) call); see #write_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - write_timeout=(sec)
    # -->
    # Sets the write timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     body = 'bar' * 200000
    #     data = <<EOF
    #     {"title": "foo", "body": "#{body}", "userId": "1"}
    #     EOF
    #     headers = {'content-type': 'application/json'}
    #     http = Net::HTTP.new(hostname)
    #     http.write_timeout # => 60
    #     http.post(_uri.path, data, headers)
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #     http.write_timeout = 0
    #     http.post(_uri.path, data, headers) # Raises Net::WriteTimeout.
    #
    attr_accessor write_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the maximum number of times to retry an idempotent request; see
    # #max_retries=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - max_retries=(retries)
    # -->
    # Sets the maximum number of times to retry an idempotent request in case of
    # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET, Errno::ECONNABORTED,
    # Errno::EPIPE, OpenSSL::SSL::SSLError, Timeout::Error. The initial value is 1.
    #
    # Argument `retries` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.max_retries = 2   # => 2
    #     http.max_retries       # => 2
    #
    attr_accessor max_retries: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the continue timeout value; see continue_timeout=.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - continue_timeout=(sec)
    # -->
    # Sets the continue timeout value, which is the number of seconds to wait for an
    # expected 100 Continue response. If the HTTP object does not receive a response
    # in this many seconds it sends the request body.
    #
    attr_accessor continue_timeout: Float | Integer | nil

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the numeric (Integer or Float) number of seconds to keep the
    # connection open after a request is sent; initially 2. If a new request is made
    # during the given interval, the still-open connection is used; otherwise the
    # connection will have been closed and a new connection is opened.
    #
    attr_accessor keep_alive_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - started?()
    # -->
    # Returns `true` if the HTTP session has been started:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.started? # => false
    #     http.start
    #     http.started? # => true
    #     http.finish # => nil
    #     http.started? # => false
    #
    #     Net::HTTP.start(hostname) do |http|
    #       http.started?
    #     end # => true
    #     http.started? # => false
    #
    def started?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - active?()
    # -->
    #
    alias active? started?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns whether to close the connection when the response is empty;
    # initially `false`.
    #
    attr_accessor close_on_empty_response: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl?()
    # -->
    # Returns `true` if `self` uses SSL, `false` otherwise. See Net::HTTP#use_ssl=.
    #
    def use_ssl?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl=(flag)
    # -->
    # Sets whether a new session is to use [Transport Layer
    # Security](https://en.wikipedia.org/wiki/Transport_Layer_Security):
    #
    # Raises IOError if attempting to change during a session.
    #
    # Raises OpenSSL::SSL::SSLError if the port is not an HTTPS port.
    #
    def use_ssl=: (boolish flag) -> void

    SSL_IVNAMES: Array[untyped]

    SSL_ATTRIBUTES: Array[Symbol]

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the path to a CA certification file in PEM format.
    #
    attr_accessor ca_file: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the path of to CA directory containing certification files in
    # PEM format.
    #
    attr_accessor ca_path: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the OpenSSL::X509::Certificate object to be used for client
    # certification.
    #
    attr_accessor cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the X509::Store to be used for verifying peer certificate.
    #
    attr_accessor cert_store: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the available SSL ciphers. See
    # [:SSL::SSLContext#ciphers=](OpenSSL::SSL::SSL::Context#ciphers=).
    #
    attr_accessor ciphers: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the extra X509 certificates to be added to the certificate
    # chain. See
    # [:SSL::SSLContext#add_certificate](OpenSSL::SSL::SSL::Context#add_certificate)
    # .
    #
    attr_accessor extra_chain_cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
    #
    attr_accessor key: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the SSL timeout seconds.
    #
    attr_accessor ssl_timeout: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the SSL version. See
    # [:SSL::SSLContext#ssl_version=](OpenSSL::SSL::SSL::Context#ssl_version=).
    #
    attr_accessor ssl_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the minimum SSL version. See
    # [:SSL::SSLContext#min_version=](OpenSSL::SSL::SSL::Context#min_version=).
    #
    attr_accessor min_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the maximum SSL version. See
    # [:SSL::SSLContext#max_version=](OpenSSL::SSL::SSL::Context#max_version=).
    #
    attr_accessor max_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the callback for the server certification verification.
    #
    attr_accessor verify_callback: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the maximum depth for the certificate chain verification.
    #
    attr_accessor verify_depth: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns the flags for server the certification verification at the
    # beginning of the SSL/TLS session. OpenSSL::SSL::VERIFY_NONE or
    # OpenSSL::SSL::VERIFY_PEER are acceptable.
    #
    attr_accessor verify_mode: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets or returns whether to verify that the server certificate is valid for the
    # hostname. See
    # [:SSL::SSLContext#verify_hostname=](OpenSSL::SSL::SSL::Context#verify_hostname
    # =).
    #
    attr_accessor verify_hostname: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - peer_cert()
    # -->
    # Returns the X509 certificate chain (an array of strings) for the session's
    # socket peer, or `nil` if none.
    #
    def peer_cert: () -> (nil | untyped)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - start() { |http| ... }
    # -->
    # Starts an HTTP session.
    #
    # Without a block, returns `self`:
    #
    #     http = Net::HTTP.new(hostname)
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.start
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=true>
    #     http.started? # => true
    #     http.finish
    #
    # With a block, calls the block with `self`, finishes the session when the block
    # exits, and returns the block's value:
    #
    #     http.start do |http|
    #       http
    #     end
    #     # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #     http.started? # => false
    #
    def start: [T] () { (Net::HTTP) -> T } -> T
             | () -> Net::HTTP

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - finish()
    # -->
    # Finishes the HTTP session:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.start
    #     http.started? # => true
    #     http.finish   # => nil
    #     http.started? # => false
    #
    # Raises IOError if not in a session.
    #
    def finish: () -> void

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Proxy(p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil)
    # -->
    # Creates an HTTP proxy class which behaves like Net::HTTP, but performs all
    # access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    def self.Proxy: (?interned p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass) -> untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_class?()
    # -->
    # Returns true if self is a class which was created by HTTP::Proxy.
    #
    def self.proxy_class?: () -> bool

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the address of the proxy host, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the port number of the proxy host, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the user name for accessing the proxy, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Returns the password for accessing the proxy, or `nil` if none; see
    # Net::HTTP@Proxy+Server.
    #
    attr_reader self.proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy?()
    # -->
    # Returns `true` if a proxy server is defined, `false` otherwise; see [Proxy
    # Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def proxy?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_from_env?()
    # -->
    # Returns `true` if the proxy server is defined in the environment, `false`
    # otherwise; see [Proxy Server](rdoc-ref:Net::HTTP@Proxy+Server).
    #
    def proxy_from_env?: () -> bool

    def proxy_uri: () -> (nil | URI::Generic)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyaddr()
    # -->
    #
    alias proxyaddr proxy_address

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyport()
    # -->
    #
    alias proxyport proxy_port

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get(path, initheader = nil) {|res| ... }
    # -->
    # Sends a GET request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Get object created from string `path`
    # and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.get('/todos/1') do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.get('/') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Related:
    #
    # *   Net::HTTP::Get: request class for HTTP method GET.
    # *   Net::HTTP.get: sends GET request, returns response body.
    #
    def get: (String path, ?headers initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head(path, initheader = nil)
    # -->
    # Sends a HEAD request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Head object created from string `path`
    # and initial headers hash `initheader`:
    #
    #     res = http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #     res.body                    # => nil
    #     res.to_hash.take(3)
    #     # =>
    #     [["date", ["Wed, 15 Feb 2023 15:25:42 GMT"]],
    #      ["content-type", ["application/json; charset=utf-8"]],
    #      ["connection", ["close"]]]
    #
    def head: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(path, data, initheader = nil) {|res| ... }
    # -->
    # Sends a POST request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Post object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.post('/todos', data) do |res|
    #       p res
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Output:
    #
    #     "{\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\",\n  \"id\": 201\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.post('/todos', data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Related:
    #
    # *   Net::HTTP::Post: request class for HTTP method POST.
    # *   Net::HTTP.post: sends POST request, returns response body.
    #
    def post: (String path, String data, ?headers initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - patch(path, data, initheader = nil) {|res| ... }
    # -->
    # Sends a PATCH request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Patch object created from string
    # `path`, string `data`, and initial headers hash `initheader`.
    #
    # With a block given, calls the block with the response body:
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.patch('/todos/1', data) do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false,\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\"\n}"
    #
    # With no block given, simply returns the response object:
    #
    #     http.patch('/todos/1', data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def patch: (String path, String data, ?headers initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - put(path, data, initheader = nil)
    # -->
    # Sends a PUT request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Put object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.put('/todos/1', data) # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Related:
    #
    # *   Net::HTTP::Put: request class for HTTP method PUT.
    # *   Net::HTTP.put: sends PUT request, returns response body.
    #
    def put: (String path, String data, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proppatch(path, body, initheader = nil)
    # -->
    # Sends a PROPPATCH request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Proppatch object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.proppatch('/todos/1', data)
    #
    def proppatch: (String path, String body, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - lock(path, body, initheader = nil)
    # -->
    # Sends a LOCK request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Lock object created from string `path`,
    # string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.lock('/todos/1', data)
    #
    def lock: (String path, String body, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - unlock(path, body, initheader = nil)
    # -->
    # Sends an UNLOCK request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Unlock object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.unlock('/todos/1', data)
    #
    def unlock: (String path, String body, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - options(path, initheader = nil)
    # -->
    # Sends an Options request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Options object created from string
    # `path` and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.options('/')
    #
    def options: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - propfind(path, body = nil, initheader = {'Depth' => '0'})
    # -->
    # Sends a PROPFIND request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Propfind object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http = Net::HTTP.new(hostname)
    #     http.propfind('/todos/1', data)
    #
    def propfind: (String path, ?untyped? body, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - delete(path, initheader = {'Depth' => 'Infinity'})
    # -->
    # Sends a DELETE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Delete object created from string
    # `path` and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.delete('/todos/1')
    #
    def delete: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - move(path, initheader = nil)
    # -->
    # Sends a MOVE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Move object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.move('/todos/1')
    #
    def move: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - copy(path, initheader = nil)
    # -->
    # Sends a COPY request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Copy object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.copy('/todos/1')
    #
    def copy: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - mkcol(path, body = nil, initheader = nil)
    # -->
    # Sends a MKCOL request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Mkcol object created from string
    # `path`, string `body`, and initial headers hash `initheader`.
    #
    #     data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
    #     http.mkcol('/todos/1', data)
    #     http = Net::HTTP.new(hostname)
    #
    def mkcol: (String path, ?untyped? body, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - trace(path, initheader = nil)
    # -->
    # Sends a TRACE request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Trace object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.trace('/todos/1')
    #
    def trace: (String path, ?headers initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_get(path, initheader = nil) { |response| ... }
    # -->
    # Sends a GET request to the server; forms the response into a Net::HTTPResponse
    # object.
    #
    # The request is based on the Net::HTTP::Get object created from string `path`
    # and initial headers hash `initheader`.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.request_get('/todos') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # With a block given, calls the block with the response object and returns the
    # response object:
    #
    #     http.request_get('/todos') do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     #<Net::HTTPOK 200 OK readbody=false>
    #
    def request_get: (String path, ?headers initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_head(path, initheader = nil, &block)
    # -->
    # Sends a HEAD request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTP::Head object created from string `path`
    # and initial headers hash `initheader`.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #
    def request_head: (String path, ?headers initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_post(path, data, initheader = nil) { |response| ... }
    # -->
    # Sends a POST request to the server; forms the response into a
    # Net::HTTPResponse object.
    #
    # The request is based on the Net::HTTP::Post object created from string `path`,
    # string `data`, and initial headers hash `initheader`.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.post('/todos', 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # With a block given, calls the block with the response body and returns the
    # response object:
    #
    #     http.post('/todos', 'xyzzy') do |res|
    #       p res
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # Output:
    #
    #     "{\n  \"xyzzy\": \"\",\n  \"id\": 201\n}"
    #
    def request_post: (String path, String data, ?headers initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    def request_put: (String path, String data, ?headers initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get2(path, initheader = nil)
    # -->
    #
    alias get2 request_get

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head2(path, initheader = nil, &block)
    # -->
    #
    alias head2 request_head

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post2(path, data, initheader = nil)
    # -->
    #
    alias post2 request_post

    alias put2 request_put

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - send_request(name, path, data = nil, header = nil)
    # -->
    # Sends an HTTP request to the server; returns an instance of a subclass of
    # Net::HTTPResponse.
    #
    # The request is based on the Net::HTTPRequest object created from string
    # `path`, string `data`, and initial headers hash `header`. That object is an
    # instance of the [subclass of
    # Net::HTTPRequest](rdoc-ref:Net::HTTPRequest@Request+Subclasses), that
    # corresponds to the given uppercase string `name`, which must be an [HTTP
    # request method](https://en.wikipedia.org/wiki/HTTP#Request_methods) or a
    # [WebDAV request method](https://en.wikipedia.org/wiki/WebDAV#Implementation).
    #
    # Examples:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.send_request('GET', '/todos/1')
    #     # => #<Net::HTTPOK 200 OK readbody=true>
    #     http.send_request('POST', '/todos', 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def send_request: (String name, String path, ?String? data, ?headers? header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request(req, body = nil) { |response| ... }
    # -->
    # Sends the given request `req` to the server; forms the response into a
    # Net::HTTPResponse object.
    #
    # The given `req` must be an instance of a [subclass of
    # Net::HTTPRequest](rdoc-ref:Net::HTTPRequest@Request+Subclasses). Argument
    # `body` should be given only if needed for the request.
    #
    # With no block given, returns the response object:
    #
    #     http = Net::HTTP.new(hostname)
    #
    #     req = Net::HTTP::Get.new('/todos/1')
    #     http.request(req)
    #     # => #<Net::HTTPOK 200 OK readbody=true>
    #
    #     req = Net::HTTP::Post.new('/todos')
    #     http.request(req, 'xyzzy')
    #     # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    # With a block given, calls the block with the response and returns the
    # response:
    #
    #     req = Net::HTTP::Get.new('/todos/1')
    #     http.request(req) do |res|
    #       p res
    #     end # => #<Net::HTTPOK 200 OK readbody=true>
    #
    # Output:
    #
    #     #<Net::HTTPOK 200 OK readbody=false>
    #
    def request: (Net::HTTPRequest req, ?String? body) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse
  end

  # <!-- rdoc-file=lib/net/http/generic_request.rb -->
  # HTTPGenericRequest is the parent of the Net::HTTPRequest class.
  #
  # Do not use this directly; instead, use a subclass of Net::HTTPRequest.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  class HTTPGenericRequest
    include Net::HTTPHeader

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - new(m, reqbody, resbody, uri_or_path, initheader = nil)
    # -->
    #
    def initialize: (String m, boolish reqbody, boolish resbody, URI::Generic | String uri_or_path, ?headers initheader) -> void

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string method name for the request:
    #
    #     Net::HTTP::Get.new(uri).method  # => "GET"
    #     Net::HTTP::Post.new(uri).method # => "POST"
    #
    attr_reader method: String

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string path for the request:
    #
    #     Net::HTTP::Get.new(uri).path # => "/"
    #     Net::HTTP::Post.new('example.com').path # => "example.com"
    #
    attr_reader path: String

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the URI object for the request, or `nil` if none:
    #
    #     Net::HTTP::Get.new(uri).uri
    #     # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
    #     Net::HTTP::Get.new('example.com').uri # => nil
    #
    attr_reader uri: URI::Generic

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns `false` if the request's header `'Accept-Encoding'` has been set
    # manually or deleted (indicating that the user intends to handle encoding in
    # the response), `true` otherwise:
    #
    #     req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
    #     req['Accept-Encoding']        # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
    #     req.decode_content            # => true
    #     req['Accept-Encoding'] = 'foo'
    #     req.decode_content            # => false
    #     req.delete('Accept-Encoding')
    #     req.decode_content            # => false
    #
    attr_reader decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - inspect()
    # -->
    # Returns a string representation of the request:
    #
    #     Net::HTTP::Post.new(uri).inspect # => "#<Net::HTTP::Post POST>"
    #
    def inspect: () -> String

    def []=: (untyped key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - request_body_permitted?()
    # -->
    # Returns whether the request may have a body:
    #
    #     Net::HTTP::Post.new(uri).request_body_permitted? # => true
    #     Net::HTTP::Get.new(uri).request_body_permitted?  # => false
    #
    def request_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - response_body_permitted?()
    # -->
    # Returns whether the response may have a body:
    #
    #     Net::HTTP::Post.new(uri).response_body_permitted? # => true
    #     Net::HTTP::Head.new(uri).response_body_permitted? # => false
    #
    def response_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_exist?()
    # -->
    #
    def body_exist?: () -> bool

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the string body for the request, or `nil` if there is none:
    #
    #     req = Net::HTTP::Post.new(uri)
    #     req.body # => nil
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
    # ----
    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body=(str)
    # -->
    # Sets the body for the request:
    #
    #     req = Net::HTTP::Post.new(uri)
    #     req.body # => nil
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
    #
    attr_accessor body: String?

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Returns the body stream object for the request, or `nil` if there is none:
    #
    #     req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
    #     req.body_stream                         # => nil
    #     require 'stringio'
    #     req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
    #     req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
    # ----
    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_stream=(input)
    # -->
    # Sets the body stream for the request:
    #
    #     req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
    #     req.body_stream                         # => nil
    #     require 'stringio'
    #     req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
    #     req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
    #
    attr_accessor body_stream: untyped
  end

  # <!-- rdoc-file=lib/net/http/header.rb -->
  # The HTTPHeader module provides access to HTTP headers.
  #
  # The module is included in:
  #
  # *   Net::HTTPGenericRequest (and therefore Net::HTTPRequest).
  # *   Net::HTTPResponse.
  #
  # The headers are a hash-like collection of key/value pairs called *fields*.
  #
  # ## Request and Response Fields
  #
  # Headers may be included in:
  #
  # *   A Net::HTTPRequest object: the object's headers will be sent with the
  #     request. Any fields may be defined in the request; see
  #     [Setters](rdoc-ref:Net::HTTPHeader@Setters).
  # *   A Net::HTTPResponse object: the objects headers are usually those returned
  #     from the host. Fields may be retrieved from the object; see
  #     [Getters](rdoc-ref:Net::HTTPHeader@Getters) and
  #     [Iterators](rdoc-ref:Net::HTTPHeader@Iterators).
  #
  # Exactly which fields should be sent or expected depends on the host; see:
  #
  # *   [Request
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_f
  #     ields).
  # *   [Response
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_
  #     fields).
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Fields
  #
  # A header field is a key/value pair.
  #
  # ### Field Keys
  #
  # A field key may be:
  #
  # *   A string: Key `'Accept'` is treated as if it were `'Accept'.downcase`;
  #     i.e., `'accept'`.
  # *   A symbol: Key `:Accept` is treated as if it were `:Accept.to_s.downcase`;
  #     i.e., `'accept'`.
  #
  # Examples:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req[:accept]  # => "*/*"
  #     req['Accept'] # => "*/*"
  #     req['ACCEPT'] # => "*/*"
  #
  #     req['accept'] = 'text/html'
  #     req[:accept] = 'text/html'
  #     req['ACCEPT'] = 'text/html'
  #
  # ### Field Values
  #
  # A field value may be returned as an array of strings or as a string:
  #
  # *   These methods return field values as arrays:
  #
  #     *   #get_fields: Returns the array value for the given key, or `nil` if it
  #         does not exist.
  #     *   #to_hash: Returns a hash of all header fields: each key is a field
  #         name; its value is the array value for the field.
  #
  # *   These methods return field values as string; the string value for a field
  #     is equivalent to `self[key.downcase.to_s].join(', '))`:
  #
  #     *   #[]: Returns the string value for the given key, or `nil` if it does
  #         not exist.
  #     *   #fetch: Like #[], but accepts a default value to be returned if the
  #         key does not exist.
  #
  # The field value may be set:
  #
  # *   #[]=: Sets the value for the given key; the given value may be a string, a
  #     symbol, an array, or a hash.
  # *   #add_field: Adds a given value to a value for the given key (not
  #     overwriting the existing value).
  # *   #delete: Deletes the field for the given key.
  #
  # Example field values:
  #
  # *   String:
  #
  #         req['Accept'] = 'text/html' # => "text/html"
  #         req['Accept']               # => "text/html"
  #         req.get_fields('Accept')    # => ["text/html"]
  #
  # *   Symbol:
  #
  #         req['Accept'] = :text    # => :text
  #         req['Accept']            # => "text"
  #         req.get_fields('Accept') # => ["text"]
  #
  # *   Simple array:
  #
  #         req[:foo] = %w[bar baz bat]
  #         req[:foo]            # => "bar, baz, bat"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat"]
  #
  # *   Simple hash:
  #
  #         req[:foo] = {bar: 0, baz: 1, bat: 2}
  #         req[:foo]            # => "bar, 0, baz, 1, bat, 2"
  #         req.get_fields(:foo) # => ["bar", "0", "baz", "1", "bat", "2"]
  #
  # *   Nested:
  #
  #         req[:foo] = [%w[bar baz], {bat: 0, bam: 1}]
  #         req[:foo]            # => "bar, baz, bat, 0, bam, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "0", "bam", "1"]
  #
  #         req[:foo] = {bar: %w[baz bat], bam: {bah: 0, bad: 1}}
  #         req[:foo]            # => "bar, baz, bat, bam, bah, 0, bad, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "bam", "bah", "0", "bad", "1"]
  #
  # ## Convenience Methods
  #
  # Various convenience methods retrieve values, set values, query values, set
  # form values, or iterate over fields.
  #
  # ### Setters
  #
  # Method #[]= can set any field, but does little to validate the new value; some
  # of the other setter methods provide some validation:
  #
  # *   #[]=: Sets the string or array value for the given key.
  # *   #add_field: Creates or adds to the array value for the given key.
  # *   #basic_auth: Sets the string authorization header for `'Authorization'`.
  # *   #content_length=: Sets the integer length for field `'Content-Length`.
  # *   #content_type=: Sets the string value for field `'Content-Type'`.
  # *   #proxy_basic_auth: Sets the string authorization header for
  #     `'Proxy-Authorization'`.
  # *   #set_range: Sets the value for field `'Range'`.
  #
  # ### Form Setters
  #
  # *   #set_form: Sets an HTML form data set.
  # *   #set_form_data: Sets header fields and a body from HTML form data.
  #
  # ### Getters
  #
  # Method #[] can retrieve the value of any field that exists, but always as a
  # string; some of the other getter methods return something different from the
  # simple string value:
  #
  # *   #[]: Returns the string field value for the given key.
  # *   #content_length: Returns the integer value of field `'Content-Length'`.
  # *   #content_range: Returns the Range value of field `'Content-Range'`.
  # *   #content_type: Returns the string value of field `'Content-Type'`.
  # *   #fetch: Returns the string field value for the given key.
  # *   #get_fields: Returns the array field value for the given `key`.
  # *   #main_type: Returns first part of the string value of field
  #     `'Content-Type'`.
  # *   #sub_type: Returns second part of the string value of field
  #     `'Content-Type'`.
  # *   #range: Returns an array of Range objects of field `'Range'`, or `nil`.
  # *   #range_length: Returns the integer length of the range given in field
  #     `'Content-Range'`.
  # *   #type_params: Returns the string parameters for `'Content-Type'`.
  #
  # ### Queries
  #
  # *   #chunked?: Returns whether field `'Transfer-Encoding'` is set to
  #     `'chunked'`.
  # *   #connection_close?: Returns whether field `'Connection'` is set to
  #     `'close'`.
  # *   #connection_keep_alive?: Returns whether field `'Connection'` is set to
  #     `'keep-alive'`.
  # *   #key?: Returns whether a given key exists.
  #
  # ### Iterators
  #
  # *   #each_capitalized: Passes each field capitalized-name/value pair to the
  #     block.
  # *   #each_capitalized_name: Passes each capitalized field name to the block.
  # *   #each_header: Passes each field name/value pair to the block.
  # *   #each_name: Passes each field name to the block.
  # *   #each_value: Passes each string field value to the block.
  #
  module HTTPHeader : BasicObject
    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - initialize_http_header(initheader)
    # -->
    #
    def initialize_http_header: (Hash[untyped, untyped] initheader) -> void

    def size: () -> Integer

    alias length size

    # A previous incarnation of `interned` for backward-compatibility (see #1499)
    %a{steep:deprecated}
    type key = interned

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - [](key)
    # -->
    # Returns the string field value for the case-insensitive field `key`, or `nil`
    # if there is no such key; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Connection'] # => "keep-alive"
    #     res['Nosuch']     # => nil
    #
    # Note that some field values may be retrieved via convenience methods; see
    # [Getters](rdoc-ref:Net::HTTPHeader@Getters).
    #
    def []: (interned key) -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - []=(key, val)
    # -->
    # Sets the value for the case-insensitive `key` to `val`, overwriting the
    # previous value if the field exists; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Accept'] # => "*/*"
    #     req['Accept'] = 'text/html'
    #     req['Accept'] # => "text/html"
    #
    # Note that some field values may be set via convenience methods; see
    # [Setters](rdoc-ref:Net::HTTPHeader@Setters).
    #
    def []=: (interned key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - add_field(key, val)
    # -->
    # Adds value `val` to the value array for field `key` if the field exists;
    # creates the field with the given `key` and `val` if it does not exist. see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.add_field('Foo', 'bar')
    #     req['Foo']            # => "bar"
    #     req.add_field('Foo', 'baz')
    #     req['Foo']            # => "bar, baz"
    #     req.add_field('Foo', %w[baz bam])
    #     req['Foo']            # => "bar, baz, baz, bam"
    #     req.get_fields('Foo') # => ["bar", "baz", "baz", "bam"]
    #
    def add_field: (interned key, untyped val) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_field(key, val)
    # -->
    #
    def set_field: (interned key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - append_field_value(ary, val)
    # -->
    #
    def append_field_value: (untyped ary, untyped val) -> void

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - get_fields(key)
    # -->
    # Returns the array field value for the given `key`, or `nil` if there is no
    # such field; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.get_fields('Connection') # => ["keep-alive"]
    #     res.get_fields('Nosuch')     # => nil
    #
    def get_fields: (interned key) -> (nil | Array[String])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - fetch(key, default_val = nil) {|key| ... } -> object
    #   - fetch(key, default_val = nil) -> value or default_val
    # -->
    # With a block, returns the string value for `key` if it exists; otherwise
    # returns the value of the block; ignores the `default_val`; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #
    #     # Field exists; block not called.
    #     res.fetch('Connection') do |value|
    #       fail 'Cannot happen'
    #     end # => "keep-alive"
    #
    #     # Field does not exist; block called.
    #     res.fetch('Nosuch') do |value|
    #       value.downcase
    #     end # => "nosuch"
    #
    # With no block, returns the string value for `key` if it exists; otherwise,
    # returns `default_val` if it was given; otherwise raises an exception:
    #
    #     res.fetch('Connection', 'Foo') # => "keep-alive"
    #     res.fetch('Nosuch', 'Foo')     # => "Foo"
    #     res.fetch('Nosuch')            # Raises KeyError.
    #
    def fetch: (interned key) -> String
             | (interned key, untyped) -> untyped
             | (interned key) { (String) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_header() { |key| ... }
    # -->
    # Calls the block with each key/value pair:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_header do |key, value|
    #       p [key, value] if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     ["content-type", "application/json; charset=utf-8"]
    #     ["connection", "keep-alive"]
    #     ["cache-control", "max-age=43200"]
    #     ["cf-cache-status", "HIT"]
    #     ["cf-ray", "771d17e9bc542cf5-ORD"]
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
    #
    def each_header: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                   | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each()
    # -->
    #
    alias each each_header

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_name() { |key| ... }
    # -->
    # Calls the block with each field key:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_key do |key|
    #       p key if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "content-type"
    #     "connection"
    #     "cache-control"
    #     "cf-cache-status"
    #     "cf-ray"
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
    #
    def each_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                 | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_key()
    # -->
    #
    alias each_key each_name

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized_name() { |key| ... }
    # -->
    # Calls the block with each capitalized field name:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_capitalized_name do |key|
    #       p key if key.start_with?('C')
    #     end
    #
    # Output:
    #
    #     "Content-Type"
    #     "Connection"
    #     "Cache-Control"
    #     "Cf-Cache-Status"
    #     "Cf-Ray"
    #
    # The capitalization is system-dependent; see [Case
    # Mapping](rdoc-ref:case_mapping.rdoc).
    #
    # Returns an enumerator if no block is given.
    #
    def each_capitalized_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                             | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_value() { |value| ... }
    # -->
    # Calls the block with each string field value:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_value do |value|
    #       p value if value.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "chunked"
    #     "cf-q-config;dur=6.0000002122251e-06"
    #     "cloudflare"
    #
    # Returns an enumerator if no block is given.
    #
    def each_value: () { (String) -> untyped } -> Hash[String, Array[String]]
                  | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - delete(key)
    # -->
    # Removes the header for the given case-insensitive `key` (see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields)); returns the deleted value, or
    # `nil` if no such field exists:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.delete('Accept') # => ["*/*"]
    #     req.delete('Nosuch') # => nil
    #
    def delete: (interned key) -> (Array[String] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - key?(key)
    # -->
    # Returns `true` if the field for the case-insensitive `key` exists, `false`
    # otherwise:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.key?('Accept') # => true
    #     req.key?('Nosuch') # => false
    #
    def key?: (interned key) -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - to_hash()
    # -->
    # Returns a hash of the key/value pairs:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.to_hash
    #     # =>
    #     {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
    #      "accept"=>["*/*"],
    #      "user-agent"=>["Ruby"],
    #      "host"=>["jsonplaceholder.typicode.com"]}
    #
    def to_hash: () -> Hash[String, Array[String]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized() { |capitalize(k), join(', ')| ... }
    # -->
    # Like #each_header, but the keys are returned in capitalized form.
    #
    # Net::HTTPHeader#canonical_each is an alias for
    # Net::HTTPHeader#each_capitalized.
    #
    def each_capitalized: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                        | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - canonical_each()
    # -->
    #
    alias canonical_each each_capitalized

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - capitalize(name)
    # -->
    #
    def capitalize: (interned name) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range()
    # -->
    # Returns an array of Range objects that represent the value of field `'Range'`,
    # or `nil` if there is no such field; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Range'] = 'bytes=0-99,200-299,400-499'
    #     req.range # => [0..99, 200..299, 400..499]
    #     req.delete('Range')
    #     req.range # # => nil
    #
    def range: () -> (nil | Array[Range[Integer]])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_range(length) -> length
    #   - set_range(offset, length) -> range
    #   - set_range(begin..length) -> range
    # -->
    # Sets the value for field `'Range'`; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    # With argument `length`:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_range(100)      # => 100
    #     req['Range']            # => "bytes=0-99"
    #
    # With arguments `offset` and `length`:
    #
    #     req.set_range(100, 100) # => 100...200
    #     req['Range']            # => "bytes=100-199"
    #
    # With argument `range`:
    #
    #     req.set_range(100..199) # => 100..199
    #     req['Range']            # => "bytes=100-199"
    #
    # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
    #
    def set_range: (Range[Integer] | Numeric r, ?Integer? e) -> Range[Integer]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range=(r, e = nil)
    # -->
    #
    alias range= set_range

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length()
    # -->
    # Returns the value of field `'Content-Length'` as an integer, or `nil` if there
    # is no such field; see [Content-Length request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-request-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/nosuch/1')
    #     res.content_length # => 2
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.content_length # => nil
    #
    def content_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length=(len)
    # -->
    # Sets the value of field `'Content-Length'` to the given numeric; see
    # [Content-Length response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-response-header):
    #
    #     _uri = uri.dup
    #     hostname = _uri.hostname           # => "jsonplaceholder.typicode.com"
    #     _uri.path = '/posts'               # => "/posts"
    #     req = Net::HTTP::Post.new(_uri)    # => #<Net::HTTP::Post POST>
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.content_length = req.body.size # => 42
    #     req.content_type = 'application/json'
    #     res = Net::HTTP.start(hostname) do |http|
    #       http.request(req)
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def content_length=: (Integer len) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - chunked?()
    # -->
    # Returns `true` if field `'Transfer-Encoding'` exists and has value
    # `'chunked'`, `false` otherwise; see [Transfer-Encoding response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-enco
    # ding-response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Transfer-Encoding'] # => "chunked"
    #     res.chunked?             # => true
    #
    def chunked?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_range()
    # -->
    # Returns a Range object representing the value of field `'Content-Range'`, or
    # `nil` if no such field exists; see [Content-Range response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res['Content-Range'] # => "bytes 0-499/1000"
    #     res.content_range    # => 0..499
    #
    def content_range: () -> (Range[Integer] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range_length()
    # -->
    # Returns the integer representing length of the value of field
    # `'Content-Range'`, or `nil` if no such field exists; see [Content-Range
    # response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res.range_length     # => 500
    #
    def range_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type()
    # -->
    # Returns the [media type](https://en.wikipedia.org/wiki/Media_type) from the
    # value of field `'Content-Type'`, or `nil` if no such field exists; see
    # [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.content_type    # => "application/json"
    #
    def content_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - main_type()
    # -->
    # Returns the leading ('type') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.main_type       # => "application"
    #
    def main_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - sub_type()
    # -->
    # Returns the trailing ('subtype') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.sub_type        # => "json"
    #
    def sub_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - type_params()
    # -->
    # Returns the trailing ('parameters') part of the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.type_params     # => {"charset"=>"utf-8"}
    #
    def type_params: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_content_type(type, params = {})
    # -->
    # Sets the value of field `'Content-Type'`; returns the new value; see
    # [Content-Type request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # request-header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_content_type('application/json') # => ["application/json"]
    #
    # Net::HTTPHeader#content_type= is an alias for
    # Net::HTTPHeader#set_content_type.
    #
    def set_content_type: (interned `type`, ?Hash[untyped, untyped] params) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type=(type, params = {})
    # -->
    #
    alias content_type= set_content_type

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form_data(params, sep = '&')
    # -->
    # Sets the request body to a URL-encoded string derived from argument `params`,
    # and sets request header field `'Content-Type'` to
    # `'application/x-www-form-urlencoded'`.
    #
    # The resulting request is suitable for HTTP request `POST` or `PUT`.
    #
    # Argument `params` must be suitable for use as argument `enum` to
    # [URI.encode_www_form](rdoc-ref:URI.encode_www_form).
    #
    # With only argument `params` given, sets the body to a URL-encoded string with
    # the default separator `'&'`:
    #
    #     req = Net::HTTP::Post.new('example.com')
    #
    #     req.set_form_data(q: 'ruby', lang: 'en')
    #     req.body            # => "q=ruby&lang=en"
    #     req['Content-Type'] # => "application/x-www-form-urlencoded"
    #
    #     req.set_form_data([['q', 'ruby'], ['lang', 'en']])
    #     req.body            # => "q=ruby&lang=en"
    #
    #     req.set_form_data(q: ['ruby', 'perl'], lang: 'en')
    #     req.body            # => "q=ruby&q=perl&lang=en"
    #
    #     req.set_form_data([['q', 'ruby'], ['q', 'perl'], ['lang', 'en']])
    #     req.body            # => "q=ruby&q=perl&lang=en"
    #
    # With string argument `sep` also given, uses that string as the separator:
    #
    #     req.set_form_data({q: 'ruby', lang: 'en'}, '|')
    #     req.body # => "q=ruby|lang=en"
    #
    # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
    #
    def set_form_data: (Hash[untyped, untyped] params, ?String sep) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - form_data=(params, sep = '&')
    # -->
    #
    alias form_data= set_form_data

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form(params, enctype='application/x-www-form-urlencoded', formopt={})
    # -->
    # Stores form data to be used in a `POST` or `PUT` request.
    #
    # The form data given in `params` consists of zero or more fields; each field
    # is:
    #
    # *   A scalar value.
    # *   A name/value pair.
    # *   An IO stream opened for reading.
    #
    # Argument `params` should be an
    # [Enumerable](rdoc-ref:Enumerable@Enumerable+in+Ruby+Classes) (method
    # `params.map` will be called), and is often an array or hash.
    #
    # First, we set up a request:
    #
    #     _uri = uri.dup
    #     _uri.path ='/posts'
    #     req = Net::HTTP::Post.new(_uri)
    #
    # **Argument `params` As an Array**
    #
    # When `params` is an array, each of its elements is a subarray that defines a
    # field; the subarray may contain:
    #
    # *   One string:
    #
    #         req.set_form([['foo'], ['bar'], ['baz']])
    #
    # *   Two strings:
    #
    #         req.set_form([%w[foo 0], %w[bar 1], %w[baz 2]])
    #
    # *   When argument `enctype` (see below) is given as `'multipart/form-data'`:
    #
    #     *   A string name and an IO stream opened for reading:
    #
    #             require 'stringio'
    #             req.set_form([['file', StringIO.new('Ruby is cool.')]])
    #
    #     *   A string name, an IO stream opened for reading, and an options hash,
    #         which may contain these entries:
    #
    #         *   `:filename`: The name of the file to use.
    #         *   `:content_type`: The content type of the uploaded file.
    #
    #         Example:
    #
    #             req.set_form([['file', file, {filename: "other-filename.foo"}]]
    #
    # The various forms may be mixed:
    #
    #     req.set_form(['foo', %w[bar 1], ['file', file]])
    #
    # **Argument `params` As a Hash**
    #
    # When `params` is a hash, each of its entries is a name/value pair that defines
    # a field:
    #
    # *   The name is a string.
    # *   The value may be:
    #
    #     *   `nil`.
    #     *   Another string.
    #     *   An IO stream opened for reading (only when argument `enctype` -- see
    #         below -- is given as `'multipart/form-data'`).
    #
    # Examples:
    #
    #     # Nil-valued fields.
    #     req.set_form({'foo' => nil, 'bar' => nil, 'baz' => nil})
    #
    #     # String-valued fields.
    #     req.set_form({'foo' => 0, 'bar' => 1, 'baz' => 2})
    #
    #     # IO-valued field.
    #     require 'stringio'
    #     req.set_form({'file' => StringIO.new('Ruby is cool.')})
    #
    #     # Mixture of fields.
    #     req.set_form({'foo' => nil, 'bar' => 1, 'file' => file})
    #
    # Optional argument `enctype` specifies the value to be given to field
    # `'Content-Type'`, and must be one of:
    #
    # *   `'application/x-www-form-urlencoded'` (the default).
    # *   `'multipart/form-data'`; see [RFC
    #     7578](https://www.rfc-editor.org/rfc/rfc7578).
    #
    # Optional argument `formopt` is a hash of options (applicable only when
    # argument `enctype` is `'multipart/form-data'`) that may include the following
    # entries:
    #
    # *   `:boundary`: The value is the boundary string for the multipart message.
    #     If not given, the boundary is a random string. See
    #     [Boundary](https://www.rfc-editor.org/rfc/rfc7578#section-4.1).
    # *   `:charset`: Value is the character set for the form submission. Field
    #     names and values of non-file fields should be encoded with this charset.
    #
    def set_form: (Hash[untyped, untyped] params, ?String enctype, ?Hash[untyped, untyped] formopt) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_auth(account, password)
    # -->
    # Sets header `'Authorization'` using the given `account` and `password`
    # strings:
    #
    #     req.basic_auth('my_account', 'my_password')
    #     req['Authorization']
    #     # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
    #
    def basic_auth: (String account, String password) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - proxy_basic_auth(account, password)
    # -->
    # Sets header `'Proxy-Authorization'` using the given `account` and `password`
    # strings:
    #
    #     req.proxy_basic_auth('my_account', 'my_password')
    #     req['Proxy-Authorization']
    #     # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
    #
    def proxy_basic_auth: (String account, String password) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_encode(account, password)
    # -->
    #
    def basic_encode: (String account, String password) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_close?()
    # -->
    # Returns whether the HTTP session is to be closed.
    #
    def connection_close?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_keep_alive?()
    # -->
    # Returns whether the HTTP session is to be kept alive.
    #
    def connection_keep_alive?: () -> bool
  end

  # <!-- rdoc-file=lib/net/http/request.rb -->
  # This class is the base class for Net::HTTP request classes. The class should
  # not be used directly; instead you should use its subclasses, listed below.
  #
  # ## Creating a Request
  #
  # An request object may be created with either a URI or a string hostname:
  #
  #     require 'net/http'
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     req = Net::HTTP::Get.new(uri)          # => #<Net::HTTP::Get GET>
  #     req = Net::HTTP::Get.new(uri.hostname) # => #<Net::HTTP::Get GET>
  #
  # And with any of the subclasses:
  #
  #     req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
  #     req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
  #     req = Net::HTTP::Put.new(uri)  # => #<Net::HTTP::Put PUT>
  #     # ...
  #
  # The new instance is suitable for use as the argument to Net::HTTP#request.
  #
  # ## Request Headers
  #
  # A new request object has these header fields by default:
  #
  #     req.to_hash
  #     # =>
  #     {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
  #     "accept"=>["*/*"],
  #     "user-agent"=>["Ruby"],
  #     "host"=>["jsonplaceholder.typicode.com"]}
  #
  # See:
  #
  # *   [Request header
  #     Accept-Encoding](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#
  #     Accept-Encoding) and [Compression and
  #     Decompression](rdoc-ref:Net::HTTP@Compression+and+Decompression).
  # *   [Request header
  #     Accept](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#accept-re
  #     quest-header).
  # *   [Request header
  #     User-Agent](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#user-
  #     agent-request-header).
  # *   [Request header
  #     Host](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#host-reques
  #     t-header).
  #
  # You can add headers or override default headers:
  #
  #     #   res = Net::HTTP::Get.new(uri, {'foo' => '0', 'bar' => '1'})
  #
  # This class (and therefore its subclasses) also includes (indirectly) module
  # Net::HTTPHeader, which gives access to its [methods for setting
  # headers](rdoc-ref:Net::HTTPHeader@Setters).
  #
  # ## Request Subclasses
  #
  # Subclasses for HTTP requests:
  #
  # *   Net::HTTP::Get
  # *   Net::HTTP::Head
  # *   Net::HTTP::Post
  # *   Net::HTTP::Put
  # *   Net::HTTP::Delete
  # *   Net::HTTP::Options
  # *   Net::HTTP::Trace
  # *   Net::HTTP::Patch
  #
  # Subclasses for WebDAV requests:
  #
  # *   Net::HTTP::Propfind
  # *   Net::HTTP::Proppatch
  # *   Net::HTTP::Mkcol
  # *   Net::HTTP::Copy
  # *   Net::HTTP::Move
  # *   Net::HTTP::Lock
  # *   Net::HTTP::Unlock
  #
  class HTTPRequest < HTTPGenericRequest
    # <!--
    #   rdoc-file=lib/net/http/request.rb
    #   - new(path, initheader = nil)
    # -->
    # Creates an HTTP request object for `path`.
    #
    # `initheader` are the default headers to use.  Net::HTTP adds Accept-Encoding
    # to enable compression of the response body unless Accept-Encoding or Range are
    # supplied in `initheader`.
    #
    def initialize: (String path, ?headers initheader) -> void
                  | (URI::Generic uri, ?headers initheader) -> void
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # GET](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#GE
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  # Related:
  #
  # *   Net::HTTP.get: sends `GET` request, returns response body.
  # *   Net::HTTP#get: sends `GET` request, returns response object.
  #
  class HTTP::Get < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # HEAD](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#H
  # EAD_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: no.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  # Related:
  #
  # *   Net::HTTP#head: sends `HEAD` request, returns response object.
  #
  class HTTP::Head < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # POST](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#P
  # OST_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  # Related:
  #
  # *   Net::HTTP.post: sends `POST` request, returns response object.
  # *   Net::HTTP#post: sends `POST` request, returns response object.
  #
  class HTTP::Post < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PUT](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#PU
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Put.new(uri) # => #<Net::HTTP::Put PUT>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  # Related:
  #
  # *   Net::HTTP.put: sends `PUT` request, returns response object.
  # *   Net::HTTP#put: sends `PUT` request, returns response object.
  #
  class HTTP::Put < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # DELETE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol
  # #DELETE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts/1'
  #     req = Net::HTTP::Delete.new(uri) # => #<Net::HTTP::Delete DELETE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  # Related:
  #
  # *   Net::HTTP#delete: sends `DELETE` request, returns response object.
  #
  class HTTP::Delete < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # OPTIONS](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protoco
  # l#OPTIONS_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Options.new(uri) # => #<Net::HTTP::Options OPTIONS>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  # Related:
  #
  # *   Net::HTTP#options: sends `OPTIONS` request, returns response object.
  #
  class HTTP::Options < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # TRACE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # TRACE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Trace.new(uri) # => #<Net::HTTP::Trace TRACE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: no.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  # Related:
  #
  # *   Net::HTTP#trace: sends `TRACE` request, returns response object.
  #
  class HTTP::Trace < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PATCH](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # PATCH_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Patch.new(uri) # => #<Net::HTTP::Patch PATCH>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  # Related:
  #
  # *   Net::HTTP#patch: sends `PATCH` request, returns response object.
  #
  class HTTP::Patch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPFIND](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPFIND):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Propfind.new(uri) # => #<Net::HTTP::Propfind PROPFIND>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#propfind: sends `PROPFIND` request, returns response object.
  #
  class HTTP::Propfind < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPPATCH](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPPATCH):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Proppatch.new(uri) # => #<Net::HTTP::Proppatch PROPPATCH>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#proppatch: sends `PROPPATCH` request, returns response object.
  #
  class HTTP::Proppatch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MKCOL](http://www.webdav.org/specs/rfc4918.html#METHOD_MKCOL):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Mkcol.new(uri) # => #<Net::HTTP::Mkcol MKCOL>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#mkcol: sends `MKCOL` request, returns response object.
  #
  class HTTP::Mkcol < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # COPY](http://www.webdav.org/specs/rfc4918.html#METHOD_COPY):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Copy.new(uri) # => #<Net::HTTP::Copy COPY>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#copy: sends `COPY` request, returns response object.
  #
  class HTTP::Copy < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MOVE](http://www.webdav.org/specs/rfc4918.html#METHOD_MOVE):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Move.new(uri) # => #<Net::HTTP::Move MOVE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#move: sends `MOVE` request, returns response object.
  #
  class HTTP::Move < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # LOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_LOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Lock.new(uri) # => #<Net::HTTP::Lock LOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#lock: sends `LOCK` request, returns response object.
  #
  class HTTP::Lock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # UNLOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_UNLOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Unlock.new(uri) # => #<Net::HTTP::Unlock UNLOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # See [Request Headers](rdoc-ref:Net::HTTPRequest@Request+Headers).
  #
  # Related:
  #
  # *   Net::HTTP#unlock: sends `UNLOCK` request, returns response object.
  #
  class HTTP::Unlock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP response classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body_permitted?()
    # -->
    # true if the response has a body.
    #
    def self.body_permitted?: () -> bool

    include Net::HTTPHeader

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP version supported by the server.
    #
    attr_reader http_version: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result code string. For example, '302'.  You can also determine the
    # response type by examining which response subclass the response object is an
    # instance of.
    #
    attr_reader code: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    attr_reader message: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    alias msg message

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The URI used to fetch this response.  The response URI is only available if a
    # URI was used to create the request.
    #
    attr_reader uri: URI::Generic | nil

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # Set to true automatically when the request did not contain an Accept-Encoding
    # header from the user.
    #
    attr_accessor decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def code_type: () -> untyped

    def error!: () -> untyped

    def error_type: () -> (Net::HTTPError | Net::HTTPServerException | Net::HTTPRetriableError | Net::HTTPFatalError)

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - value()
    # -->
    # Raises an HTTP error if the response is not 2xx (success).
    #
    def value: () -> (nil | untyped)

    def uri=: (URI::Generic uri) -> void

    interface _Dest
      def <<: (String) -> void
    end

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - read_body(dest = nil, &block)
    # -->
    # Gets the entity body returned by the remote HTTP server.
    #
    # If a block is given, the body is passed to the block, and the body is provided
    # in fragments, as it is read in from the socket.
    #
    # If `dest` argument is given, response is read into that variable, with
    # `dest#<<` method (it could be String or IO, or any other object responding to
    # `<<`).
    #
    # Calling this method a second or subsequent time for the same HTTPResponse
    # object will return the value already read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.read_body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.read_body.object_id   # 538149362
    #       p res.read_body.object_id   # 538149362
    #     }
    #
    #     # using iterator
    #     http.request_get('/index.html') {|res|
    #       res.read_body do |segment|
    #         print segment
    #       end
    #     }
    #
    def read_body: () -> String
                 | (_Dest dest) -> String
                 | () { (String) -> void } -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body()
    # -->
    # Returns the string response body; note that repeated calls for the unmodified
    # body return a cached string:
    #
    #     path = '/todos/1'
    #     Net::HTTP.start(hostname) do |http|
    #       res = http.get(path)
    #       p res.body
    #       p http.head(path).body # No body.
    #     end
    #
    # Output:
    #
    #     "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
    #     nil
    #
    def body: () -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body=(value)
    # -->
    # Sets the body of the response to the given value.
    #
    def body=: (untyped value) -> void

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - entity()
    # -->
    #
    alias entity body
  end

  class HTTPUnknownResponse < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for informational (1xx) HTTP response classes.
  #
  # An informational response indicates that the request was received and
  # understood.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.1xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#1xx_in
  #     formational_response).
  #
  class HTTPInformation < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for success (2xx) HTTP response classes.
  #
  # A success response indicates the action requested by the client was received,
  # understood, and accepted.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.2xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_su
  #     ccess).
  #
  class HTTPSuccess < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for redirection (3xx) HTTP response classes.
  #
  # A redirection response indicates the client must take additional action to
  # complete the request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.3xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_re
  #     direction).
  #
  class HTTPRedirection < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPRetriableError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for client error (4xx) HTTP response classes.
  #
  # A client error response indicates that the client may have caused an error.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.4xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_cl
  #     ient_errors).
  #
  class HTTPClientError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: untyped
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for server error (5xx) HTTP response classes.
  #
  # A server error response indicates that the server failed to fulfill a request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.5xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_se
  #     rver_errors).
  #
  class HTTPServerError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPFatalError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Continue` responses (status code 100).
  #
  # A `Continue` response indicates that the server has received the request
  # headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-100-continue).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#100).
  #
  class HTTPContinue < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Switching Protocol` responses (status code 101).
  #
  # The <tt>Switching Protocol<tt> response indicates that the server has received
  # a request to switch protocols, and has agreed to do so.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-101-switching-proto
  #     cols).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#101).
  #
  class HTTPSwitchProtocol < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Processing` responses (status code 102).
  #
  # The `Processing` response indicates that the server has received and is
  # processing the request, but no response is available yet.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 2518](https://www.rfc-editor.org/rfc/rfc2518#section-10.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102).
  #
  class HTTPProcessing < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Early Hints` responses (status code 103).
  #
  # The `Early Hints` indicates that the server has received and is processing the
  # request, and contains certain headers; the final response is not available
  # yet.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).
  # *   [RFC 8297](https://www.rfc-editor.org/rfc/rfc8297.html#section-2).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103).
  #
  class HTTPEarlyHints < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `OK` responses (status code 200).
  #
  # The `OK` response indicates that the server has received a request and has
  # responded successfully.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-200-ok).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#200).
  #
  class HTTPOK < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Created` responses (status code 201).
  #
  # The `Created` response indicates that the server has received and has
  # fulfilled a request to create a new resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-201-created).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#201).
  #
  class HTTPCreated < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Accepted` responses (status code 202).
  #
  # The `Accepted` response indicates that the server has received and is
  # processing a request, but the processing has not yet been completed.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-202-accepted).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#202).
  #
  class HTTPAccepted < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Non-Authoritative Information` responses (status code
  # 203).
  #
  # The `Non-Authoritative Information` response indicates that the server is a
  # transforming proxy (such as a Web accelerator) that received a 200 OK response
  # from its origin, and is returning a modified version of the origin's response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-203-non-authoritati
  #     ve-infor).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#203).
  #
  class HTTPNonAuthoritativeInformation < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `No Content` responses (status code 204).
  #
  # The `No Content` response indicates that the server successfully processed the
  # request, and is not returning any content.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-204-no-content).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#204).
  #
  class HTTPNoContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Reset Content` responses (status code 205).
  #
  # The `Reset Content` response indicates that the server successfully processed
  # the request, asks that the client reset its document view, and is not
  # returning any content.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-205-reset-content).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#205).
  #
  class HTTPResetContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Partial Content` responses (status code 206).
  #
  # The `Partial Content` response indicates that the server is delivering only
  # part of the resource (byte serving) due to a Range header in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-206-partial-content
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#206).
  #
  class HTTPPartialContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multi-Status (WebDAV)` responses (status code 207).
  #
  # The `Multi-Status (WebDAV)` response indicates that the server has received
  # the request, and that the message body can contain a number of separate
  # response codes.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4818](https://www.rfc-editor.org/rfc/rfc4918#section-11.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#207).
  #
  class HTTPMultiStatus < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Already Reported (WebDAV)` responses (status code 208).
  #
  # The `Already Reported (WebDAV)` response indicates that the server has
  # received the request, and that the members of a DAV binding have already been
  # enumerated in a preceding part of the (multi-status) response, and are not
  # being included again.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 5842](https://www.rfc-editor.org/rfc/rfc5842.html#section-7.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208).
  #
  class HTTPAlreadyReported < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `IM Used` responses (status code 226).
  #
  # The `IM Used` response indicates that the server has fulfilled a request for
  # the resource, and the response is a representation of the result of one or
  # more instance-manipulations applied to the current instance.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 3229](https://www.rfc-editor.org/rfc/rfc3229.html#section-10.4.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#226).
  #
  class HTTPIMUsed < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-300-multiple-choice
  #     s).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  class HTTPMultipleChoices < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-300-multiple-choice
  #     s).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  HTTPMultipleChoice: HTTPMultipleChoices

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Moved Permanently` responses (status code 301).
  #
  # The `Moved Permanently` response indicates that links or records returning
  # this response should be updated to use the given URL.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-301-moved-permanent
  #     ly).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#301).
  #
  class HTTPMovedPermanently < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Found` responses (status code 302).
  #
  # The `Found` response indicates that the client should look at (browse to)
  # another URL.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-302-found).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#302).
  #
  class HTTPFound < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `See Other` responses (status code 303).
  #
  # The response to the request can be found under another URI using the GET
  # method.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-303-see-other).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#303).
  #
  class HTTPSeeOther < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Modified` responses (status code 304).
  #
  # Indicates that the resource has not been modified since the version specified
  # by the request headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-304-not-modified).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#304).
  #
  class HTTPNotModified < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Use Proxy` responses (status code 305).
  #
  # The requested resource is available only through a proxy, whose address is
  # provided in the response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-305-use-proxy).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#305).
  #
  class HTTPUseProxy < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Temporary Redirect` responses (status code 307).
  #
  # The request should be repeated with another URI; however, future requests
  # should still use the original URI.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-307-temporary-redir
  #     ect).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#307).
  #
  class HTTPTemporaryRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Permanent Redirect` responses (status code 308).
  #
  # This and all future requests should be directed to the given URI.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-308-permanent-redir
  #     ect).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#308).
  #
  class HTTPPermanentRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Request` responses (status code 400).
  #
  # The server cannot or will not process the request due to an apparent client
  # error.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-400-bad-request).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#400).
  #
  class HTTPBadRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unauthorized` responses (status code 401).
  #
  # Authentication is required, but either was not provided or failed.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-401-unauthorized).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#401).
  #
  class HTTPUnauthorized < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payment Required` responses (status code 402).
  #
  # Reserved for future use.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-402-payment-require
  #     d).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#402).
  #
  class HTTPPaymentRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Forbidden` responses (status code 403).
  #
  # The request contained valid data and was understood by the server, but the
  # server is refusing action.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-403-forbidden).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#403).
  #
  class HTTPForbidden < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Found` responses (status code 404).
  #
  # The requested resource could not be found but may be available in the future.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-404-not-found).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#404).
  #
  class HTTPNotFound < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Method Not Allowed` responses (status code 405).
  #
  # The request method is not supported for the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-405-method-not-allo
  #     wed).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#405).
  #
  class HTTPMethodNotAllowed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Acceptable` responses (status code 406).
  #
  # The requested resource is capable of generating only content that not
  # acceptable according to the Accept headers sent in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-406-not-acceptable)
  #     .
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#406).
  #
  class HTTPNotAcceptable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Proxy Authentication Required` responses (status code
  # 407).
  #
  # The client must first authenticate itself with the proxy.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-407-proxy-authentic
  #     ation-re).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#407).
  #
  class HTTPProxyAuthenticationRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Timeout` responses (status code 408).
  #
  # The server timed out waiting for the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-408-request-timeout
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#408).
  #
  class HTTPRequestTimeout < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Conflict` responses (status code 409).
  #
  # The request could not be processed because of conflict in the current state of
  # the resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-409-conflict).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#409).
  #
  class HTTPConflict < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gone` responses (status code 410).
  #
  # The resource requested was previously in use but is no longer available and
  # will not be available again.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-410-gone).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#410).
  #
  class HTTPGone < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Length Required` responses (status code 411).
  #
  # The request did not specify the length of its content, which is required by
  # the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-411-length-required
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#411).
  #
  class HTTPLengthRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Failed` responses (status code 412).
  #
  # The server does not meet one of the preconditions specified in the request
  # headers.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-412-precondition-fa
  #     iled).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#412).
  #
  class HTTPPreconditionFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payload Too Large` responses (status code 413).
  #
  # The request is larger than the server is willing or able to process.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-lar
  #     ge).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413).
  #
  class HTTPPayloadTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `URI Too Long` responses (status code 414).
  #
  # The URI provided was too long for the server to process.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-414-uri-too-long).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414).
  #
  class HTTPURITooLong < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unsupported Media Type` responses (status code 415).
  #
  # The request entity has a media type which the server or resource does not
  # support.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-415-unsupported-med
  #     ia-type).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#415).
  #
  class HTTPUnsupportedMediaType < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Range Not Satisfiable` responses (status code 416).
  #
  # The request entity has a media type which the server or resource does not
  # support.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-416-range-not-satis
  #     fiable).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416).
  #
  class HTTPRangeNotSatisfiable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Expectation Failed` responses (status code 417).
  #
  # The server cannot meet the requirements of the Expect request-header field.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-417-expectation-fai
  #     led).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#417).
  #
  class HTTPExpectationFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Misdirected Request` responses (status code 421).
  #
  # The request was directed at a server that is not able to produce a response.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-421-misdirected-req
  #     uest).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421).
  #
  class HTTPMisdirectedRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unprocessable Entity` responses (status code 422).
  #
  # The request was well-formed but had semantic errors.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-422-unprocessable-c
  #     ontent).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#422).
  #
  class HTTPUnprocessableEntity < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Locked (WebDAV)` responses (status code 423).
  #
  # The requested resource is locked.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#423).
  #
  class HTTPLocked < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Failed Dependency (WebDAV)` responses (status code 424).
  #
  # The request failed because it depended on another request and that request
  # failed. See [424 Failed Dependency
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#424).
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.4).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#424).
  #
  class HTTPFailedDependency < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Upgrade Required` responses (status code 426).
  #
  # The client should switch to the protocol given in the Upgrade header field.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-426-upgrade-require
  #     d).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#426).
  #
  class HTTPUpgradeRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Required` responses (status code 428).
  #
  # The origin server requires the request to be conditional.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#428).
  #
  class HTTPPreconditionRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Too Many Requests` responses (status code 429).
  #
  # The user has sent too many requests in a given amount of time.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-4).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429).
  #
  class HTTPTooManyRequests < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Header Fields Too Large` responses (status code
  # 431).
  #
  # An individual header field is too large, or all the header fields
  # collectively, are too large.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-5).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#431).
  #
  class HTTPRequestHeaderFieldsTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unavailable For Legal Reasons` responses (status code
  # 451).
  #
  # A server operator has received a legal demand to deny access to a resource or
  # to a set of resources that includes the requested resource.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451).
  # *   [RFC 7725](https://www.rfc-editor.org/rfc/rfc7725.html#section-3).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#451).
  #
  class HTTPUnavailableForLegalReasons < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Internal Server Error` responses (status code 500).
  #
  # An unexpected condition was encountered and no more specific message is
  # suitable.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-500-internal-server
  #     -error).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#500).
  #
  class HTTPInternalServerError < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Implemented` responses (status code 501).
  #
  # The server either does not recognize the request method, or it lacks the
  # ability to fulfil the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-501-not-implemented
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#501).
  #
  class HTTPNotImplemented < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Gateway` responses (status code 502).
  #
  # The server was acting as a gateway or proxy and received an invalid response
  # from the upstream server.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-502-bad-gateway).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#502).
  #
  class HTTPBadGateway < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Service Unavailable` responses (status code 503).
  #
  # The server cannot handle the request (because it is overloaded or down for
  # maintenance).
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-503-service-unavail
  #     able).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#503).
  #
  class HTTPServiceUnavailable < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gateway Timeout` responses (status code 504).
  #
  # The server was acting as a gateway or proxy and did not receive a timely
  # response from the upstream server.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-504-gateway-timeout
  #     ).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#504).
  #
  class HTTPGatewayTimeout < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `HTTP Version Not Supported` responses (status code 505).
  #
  # The server does not support the HTTP version used in the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-505-http-version-no
  #     t-suppor).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#505).
  #
  class HTTPVersionNotSupported < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Variant Also Negotiates` responses (status code 506).
  #
  # Transparent content negotiation for the request results in a circular
  # reference.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506).
  # *   [RFC 2295](https://www.rfc-editor.org/rfc/rfc2295#section-8.1).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506).
  #
  class HTTPVariantAlsoNegotiates < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Insufficient Storage (WebDAV)` responses (status code
  # 507).
  #
  # The server is unable to store the representation needed to complete the
  # request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507).
  # *   [RFC 4918](https://www.rfc-editor.org/rfc/rfc4918#section-11.5).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#507).
  #
  class HTTPInsufficientStorage < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Loop Detected (WebDAV)` responses (status code 508).
  #
  # The server detected an infinite loop while processing the request.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508).
  # *   [RFC 5942](https://www.rfc-editor.org/rfc/rfc5842.html#section-7.2).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508).
  #
  class HTTPLoopDetected < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Extended` responses (status code 510).
  #
  # Further extensions to the request are required for the server to fulfill it.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510).
  # *   [RFC 2774](https://www.rfc-editor.org/rfc/rfc2774.html#section-7).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510).
  #
  class HTTPNotExtended < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Network Authentication Required` responses (status code
  # 511).
  #
  # The client needs to authenticate to gain network access.
  #
  # This class also includes (indirectly) module Net::HTTPHeader, which gives
  # access to its [methods for getting headers](rdoc-ref:Net::HTTPHeader@Getters).
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511).
  # *   [RFC 6585](https://www.rfc-editor.org/rfc/rfc6585#section-6).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#511).
  #
  class HTTPNetworkAuthenticationRequired < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP response classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com/')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     path = uri.path         # => "/"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    CODE_CLASS_TO_OBJ: Hash[untyped, untyped]

    CODE_TO_OBJ: Hash[untyped, untyped]
  end

  HTTP::STATUS_CODES: Hash[Integer, String]

  # <!-- rdoc-file=lib/net/http/exceptions.rb -->
  # Net::HTTP exception class. You cannot use Net::HTTPExceptions directly;
  # instead, you must use its subclasses.
  #
  module HTTPExceptions
    def initialize: (untyped msg, untyped res) -> untyped

    attr_reader response: untyped

    alias data response
  end

  class HTTPError < ProtocolError
    include Net::HTTPExceptions
  end

  class HTTPRetriableError < ProtoRetriableError
    include Net::HTTPExceptions
  end

  class HTTPServerException < ProtoServerError
    # We cannot use the name "HTTPServerError", it is the name of the response.
    include Net::HTTPExceptions
  end

  class HTTPFatalError < ProtoFatalError
    include Net::HTTPExceptions
  end
end
module Net
  class Protocol
    VERSION: String
  end

  class ProtocolError < StandardError
  end

  class ProtoSyntaxError < ProtocolError
  end

  class ProtoFatalError < ProtocolError
  end

  class ProtoUnknownError < ProtocolError
  end

  class ProtoServerError < ProtocolError
  end

  class ProtoAuthError < ProtocolError
  end

  class ProtoCommandError < ProtocolError
  end

  class ProtoRetriableError < ProtocolError
  end

  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # OpenTimeout, a subclass of Timeout::Error, is raised if a connection cannot be
  # created within the open_timeout.
  #
  class OpenTimeout < Timeout::Error
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # ReadTimeout, a subclass of Timeout::Error, is raised if a chunk of the
  # response cannot be read within the read_timeout.
  #
  class ReadTimeout < Timeout::Error
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # WriteTimeout, a subclass of Timeout::Error, is raised if a chunk of the
  # response cannot be written within the write_timeout.  Not raised on Windows.
  #
  class WriteTimeout < Timeout::Error
  end
end
module Net
  # Module mixed in to all SMTP error classes
  module SMTPError
    attr_reader response: Response

    def initialize: (Response response, ?message: String) -> void

    def message: () -> String?
  end

  # Represents an SMTP authentication error.
  class SMTPAuthenticationError < ProtoAuthError
    include SMTPError
  end

  # Represents SMTP error code 4xx, a temporary error.
  class SMTPServerBusy < ProtoServerError
    include SMTPError
  end

  # Represents an SMTP command syntax error (error code 500)
  class SMTPSyntaxError < ProtoSyntaxError
    include SMTPError
  end

  # Represents a fatal SMTP error (error code 5xx, except for 500)
  class SMTPFatalError < ProtoFatalError
    include SMTPError
  end

  # Unexpected reply code returned from server.
  class SMTPUnknownError < ProtoUnknownError
    include SMTPError
  end

  # Command is not supported on server.
  class SMTPUnsupportedCommand < ProtocolError
    include SMTPError
  end

  class SMTP < Protocol
    def self.start: (String address, ?Integer port, ?tls_verify: bool, ?tls_hostname: String?, ?helo: String, ?user: String?, ?password: String?, ?auth_type: Symbol) -> instance
                  | [T] (String address, ?Integer port, ?tls_verify: bool, ?tls_hostname: String?, ?helo: String, ?user: String?, ?password: String?, ?auth_type: Symbol) { (instance) -> T } -> T
                  | (String address, ?Integer port, ?String helo, ?String? user, ?String? password, ?Symbol auth_type) -> instance
                  | [T] (String address, ?Integer port, ?String helo, ?String? user, ?String? password, ?Symbol auth_type) { (instance) -> T } -> T

    def initialize: (String address, ?Integer port) -> void
    def send_message: (_Each[String] mail_src, String from_addr, *String to_addrs) -> void
  end

  class Response
  end

  class SMTPSession = SMTP
end
# <!-- rdoc-file=ext/nkf/nkf.c -->
# NKF - Ruby extension for Network Kanji Filter
#
# ## Description
#
# This is a Ruby Extension version of nkf (Network Kanji Filter). It converts
# the first argument and returns converted result. Conversion details are
# specified by flags as the first argument.
#
# **Nkf** is a yet another kanji code converter among networks, hosts and
# terminals. It converts input kanji code to designated kanji code such as
# ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 or UTF-16.
#
# One of the most unique faculty of **nkf** is the guess of the input kanji
# encodings. It currently recognizes ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 and
# UTF-16. So users needn't set the input kanji code explicitly.
#
# By default, X0201 kana is converted into X0208 kana. For X0201 kana, SO/SI,
# SSO and ESC-(-I methods are supported. For automatic code detection, nkf
# assumes no X0201 kana in Shift_JIS. To accept X0201 in Shift_JIS, use **-X**,
# **-x** or **-S**.
#
# ## Flags
#
# ### -b -u
#
# Output is buffered (DEFAULT), Output is unbuffered.
#
# ### -j -s -e -w -w16 -w32
#
# Output code is ISO-2022-JP (7bit JIS), Shift_JIS, EUC-JP, UTF-8N, UTF-16BE,
# UTF-32BE. Without this option and compile option, ISO-2022-JP is assumed.
#
# ### -J -S -E -W -W16 -W32
#
# Input assumption is JIS 7 bit, Shift_JIS, EUC-JP, UTF-8, UTF-16, UTF-32.
#
# #### -J
#
# Assume  JIS input. It also accepts EUC-JP. This is the default. This flag does
# not exclude Shift_JIS.
#
# #### -S
#
# Assume Shift_JIS and X0201 kana input. It also accepts JIS. EUC-JP is
# recognized as X0201 kana. Without **-x** flag, X0201 kana (halfwidth kana) is
# converted into X0208.
#
# #### -E
#
# Assume EUC-JP input. It also accepts JIS. Same as -J.
#
# ### -t
#
# No conversion.
#
# ### -i_
#
# Output sequence to designate JIS-kanji. (DEFAULT B)
#
# ### -o_
#
# Output sequence to designate ASCII. (DEFAULT B)
#
# ### -r
#
# {de/en}crypt ROT13/47
#
# ### -h[123] --hiragana --katakana --katakana-hiragana
#
# -h1 --hiragana
# :   Katakana to Hiragana conversion.
#
#
# -h2 --katakana
# :   Hiragana to Katakana conversion.
#
#
# -h3 --katakana-hiragana
# :   Katakana to Hiragana and Hiragana to Katakana conversion.
#
#
# ### -T
#
# Text mode output (MS-DOS)
#
# ### -l
#
# ISO8859-1 (Latin-1) support
#
# ### -f[`m` [- `n`]]
#
# Folding on `m` length with `n` margin in a line. Without this option, fold
# length is 60 and fold margin is 10.
#
# ### -F
#
# New line preserving line folding.
#
# ### -Z[0-3]
#
# Convert X0208 alphabet (Fullwidth Alphabets) to ASCII.
#
# -Z -Z0
# :   Convert X0208 alphabet to ASCII.
#
#
# -Z1
# :   Converts X0208 kankaku to single ASCII space.
#
#
# -Z2
# :   Converts X0208 kankaku to double ASCII spaces.
#
#
# -Z3
# :   Replacing Fullwidth >, <, ", & into '&gt;', '&lt;', '&quot;', '&amp;' as
#     in HTML.
#
#
# ### -X -x
#
# Assume X0201 kana in MS-Kanji. With **-X** or without this option, X0201 is
# converted into X0208 Kana. With **-x**, try to preserve X0208 kana and do not
# convert X0201 kana to X0208. In JIS output, ESC-(-I is used. In EUC output,
# SSO is used.
#
# ### -B[0-2]
#
# Assume broken JIS-Kanji input, which lost ESC. Useful when your site is using
# old B-News Nihongo patch.
#
# -B1
# :   allows any char after ESC-( or ESC-$.
#
#
# -B2
# :   forces ASCII after NL.
#
#
# ### -I
#
# Replacing non iso-2022-jp char into a geta character (substitute character in
# Japanese).
#
# ### -d -c
#
# Delete r in line feed, Add r in line feed.
#
# ### -m[BQN0]
#
# MIME ISO-2022-JP/ISO8859-1 decode. (DEFAULT) To see ISO8859-1 (Latin-1) -l is
# necessary.
#
# -mB
# :   Decode MIME base64 encoded stream. Remove header or other part before
#
# conversion.
#
# -mQ
# :   Decode MIME quoted stream. '_' in quoted stream is converted to space.
#
#
# -mN
# :   Non-strict decoding.
#
# It allows line break in the middle of the base64 encoding.
#
# -m0
# :   No MIME decode.
#
#
# ### -M
#
# MIME encode. Header style. All ASCII code and control characters are intact.
# Kanji conversion is performed before encoding, so this cannot be used as a
# picture encoder.
#
# -MB
# :   MIME encode Base64 stream.
#
#
# -MQ
# :   Perform quoted encoding.
#
#
# ### -l
#
# Input and output code is ISO8859-1 (Latin-1) and ISO-2022-JP. **-s**, **-e**
# and **-x** are not compatible with this option.
#
# ### -L[uwm]
#
# new line mode Without this option, nkf doesn't convert line breaks.
#
# -Lu
# :   unix (LF)
#
#
# -Lw
# :   windows (CRLF)
#
#
# -Lm
# :   mac (CR)
#
#
# ### --fj --unix --mac --msdos --windows
#
# convert for these system
#
# ### --jis --euc --sjis --mime --base64
#
# convert for named code
#
# ### --jis-input --euc-input --sjis-input --mime-input --base64-input
#
# assume input system
#
# ### --ic=`input codeset` --oc=`output codeset`
#
# Set the input or output codeset. NKF supports following codesets and those
# codeset name are case insensitive.
#
# ISO-2022-JP
# :   a.k.a. RFC1468, 7bit JIS, JUNET
#
#
# EUC-JP (eucJP-nkf)
# :   a.k.a. AT&T JIS, Japanese EUC, UJIS
#
#
# eucJP-ascii
# :   a.k.a. x-eucjp-open-19970715-ascii
#
#
# eucJP-ms
# :   a.k.a. x-eucjp-open-19970715-ms
#
#
# CP51932
# :   Microsoft Version of EUC-JP.
#
#
# Shift_JIS
# :   SJIS, MS-Kanji
#
#
# Windows-31J
# :   a.k.a. CP932
#
#
# UTF-8
# :   same as UTF-8N
#
#
# UTF-8N
# :   UTF-8 without BOM
#
#
# UTF-8-BOM
# :   UTF-8 with BOM
#
#
# UTF-16
# :   same as UTF-16BE
#
#
# UTF-16BE
# :   UTF-16 Big Endian without BOM
#
#
# UTF-16BE-BOM
# :   UTF-16 Big Endian with BOM
#
#
# UTF-16LE
# :   UTF-16 Little Endian without BOM
#
#
# UTF-16LE-BOM
# :   UTF-16 Little Endian with BOM
#
#
# UTF-32
# :   same as UTF-32BE
#
#
# UTF-32BE
# :   UTF-32 Big Endian without BOM
#
#
# UTF-32BE-BOM
# :   UTF-32 Big Endian with BOM
#
#
# UTF-32LE
# :   UTF-32 Little Endian without BOM
#
#
# UTF-32LE-BOM
# :   UTF-32 Little Endian with BOM
#
#
# UTF8-MAC
# :   NKDed UTF-8, a.k.a. UTF8-NFD (input only)
#
#
# ### --fb-{skip, html, xml, perl, java, subchar}
#
# Specify the way that nkf handles unassigned characters. Without this option,
# --fb-skip is assumed.
#
# ### --prefix= `escape character` `target character` ..
#
# When nkf converts to Shift_JIS, nkf adds a specified escape character to
# specified 2nd byte of Shift_JIS characters. 1st byte of argument is the escape
# character and following bytes are target characters.
#
# ### --no-cp932ext
#
# Handle the characters extended in CP932 as unassigned characters.
#
# ## --no-best-fit-chars
#
# When Unicode to Encoded byte conversion, don't convert characters which is not
# round trip safe. When Unicode to Unicode conversion, with this and -x option,
# nkf can be used as UTF converter. (In other words, without this and -x option,
# nkf doesn't save some characters)
#
# When nkf convert string which related to path, you should use this option.
#
# ### --cap-input
#
# Decode hex encoded characters.
#
# ### --url-input
#
# Unescape percent escaped characters.
#
# ### --
#
# Ignore rest of -option.
#
module NKF
  # <!--
  #   rdoc-file=ext/nkf/nkf.c
  #   - NKF.guess(str)  => encoding
  # -->
  # Returns guessed encoding of *str* by nkf routine.
  #
  def self.guess: (String str) -> Encoding

  # <!--
  #   rdoc-file=ext/nkf/nkf.c
  #   - NKF.nkf(opt, str)   => string
  # -->
  # Convert *str* and return converted result. Conversion details are specified by
  # *opt* as String.
  #
  #     require 'nkf'
  #     output = NKF.nkf("-s", input)
  #
  def self.nkf: (String opt, String str) -> String
end

NKF::ASCII: Encoding

NKF::AUTO: nil

NKF::BINARY: Encoding

NKF::EUC: Encoding

NKF::JIS: Encoding

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Release date of nkf
#
NKF::NKF_RELEASE_DATE: String

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Version of nkf
#
NKF::NKF_VERSION: String

NKF::NOCONV: nil

NKF::SJIS: Encoding

NKF::UNKNOWN: nil

NKF::UTF16: Encoding

NKF::UTF32: Encoding

NKF::UTF8: Encoding

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Full version string of nkf
#
NKF::VERSION: String
# <!-- rdoc-file=ext/objspace/objspace.c -->
# The objspace library extends the ObjectSpace module and adds several methods
# to get internal statistic information about object/memory management.
#
# You need to `require 'objspace'` to use this extension module.
#
# Generally, you **SHOULD** **NOT** use this library if you do not know about
# the MRI implementation.  Mainly, this library is for (memory) profiler
# developers and MRI developers who need to know about MRI memory usage.
#
%a{annotate:rdoc:source:from=ext/objspace}
module ObjectSpace
  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_class_path(object) -> string
  # -->
  # Returns the class for the given `object`.
  #
  #     class A
  #       def foo
  #         ObjectSpace::trace_object_allocations do
  #           obj = Object.new
  #           p "#{ObjectSpace::allocation_class_path(obj)}"
  #         end
  #       end
  #     end
  #
  #     A.new.foo #=> "Class"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_class_path: (untyped) -> String

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_generation(object) -> integer or nil
  # -->
  # Returns garbage collector generation for the given `object`.
  #
  #     class B
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "Generation is #{allocation_generation(obj)}"
  #         end
  #       end
  #     end
  #
  #     B.new.foo #=> "Generation is 3"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_generation: (untyped) -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_method_id(object) -> string
  # -->
  # Returns the method identifier for the given `object`.
  #
  #     class A
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "#{allocation_class_path(obj)}##{allocation_method_id(obj)}"
  #         end
  #       end
  #     end
  #
  #     A.new.foo #=> "Class#new"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_method_id: (untyped) -> Symbol

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_sourcefile(object) -> string
  # -->
  # Returns the source file origin from the given `object`.
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_sourcefile: (untyped) -> String

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_sourceline(object) -> integer
  # -->
  # Returns the original line from source for from the given `object`.
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_sourceline: (untyped) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_imemo_objects([result_hash]) -> hash
  # -->
  # Counts objects for each `T_IMEMO` type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {:imemo_ifunc=>8,
  #      :imemo_svar=>7,
  #      :imemo_cref=>509,
  #      :imemo_memo=>1,
  #      :imemo_throw_data=>1}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation specific and may change in
  # the future.
  #
  # In this version, keys are symbol objects.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_imemo_objects: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_nodes([result_hash]) -> hash
  # -->
  # Counts nodes for each node type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {:NODE_METHOD=>2027, :NODE_FBODY=>1927, :NODE_CFUNC=>1798, ...}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # Note: The contents of the returned hash is implementation defined. It may be
  # changed in future.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_nodes: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_objects_size([result_hash]) -> hash
  # -->
  # Counts objects size (in bytes) for each type.
  #
  # Note that this information is incomplete.  You need to deal with this
  # information as only a **HINT**.  Especially, total size of T_DATA may be
  # wrong.
  #
  # It returns a hash as:
  #     {:TOTAL=>1461154, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249, ...}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation defined. It may be changed
  # in future.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_objects_size: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_symbols([result_hash]) -> hash
  # -->
  # Counts symbols for each Symbol type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # Note: The contents of the returned hash is implementation defined. It may be
  # changed in future.
  #
  # This method is only expected to work with C Ruby.
  #
  # On this version of MRI, they have 3 types of Symbols (and 1 total counts).
  #
  #     * mortal_dynamic_symbol: GC target symbols (collected by GC)
  #     * immortal_dynamic_symbol: Immortal symbols promoted from dynamic symbols (do not collected by GC)
  #     * immortal_static_symbol: Immortal symbols (do not collected by GC)
  #     * immortal_symbol: total immortal symbols (immortal_dynamic_symbol+immortal_static_symbol)
  #
  def self?.count_symbols: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_tdata_objects([result_hash]) -> hash
  # -->
  # Counts objects for each `T_DATA` type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {RubyVM::InstructionSequence=>504, :parser=>5, :barrier=>6,
  #      :mutex=>6, Proc=>60, RubyVM::Env=>57, Mutex=>1, Encoding=>99,
  #      ThreadGroup=>1, Binding=>1, Thread=>1, RubyVM=>1, :iseq=>1,
  #      Random=>1, ARGF.class=>1, Data=>1, :autoload=>3, Time=>2}
  #     # T_DATA objects existing at startup on r32276.
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation specific and may change in
  # the future.
  #
  # In this version, keys are Class object or Symbol object.
  #
  # If object is kind of normal (accessible) object, the key is Class object. If
  # object is not a kind of normal (internal) object, the key is symbol name,
  # registered by rb_data_type_struct.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_tdata_objects: (?Hash[untyped, Integer] result_hash) -> Hash[untyped, Integer]

  # <!--
  #   rdoc-file=ext/objspace/lib/objspace.rb
  #   - dump(obj, output: :string)
  # -->
  # Dump the contents of a ruby object as JSON.
  #
  # *output* can be one of: `:stdout`, `:file`, `:string`, or IO object.
  #
  # *   `:file` means dumping to a tempfile and returning corresponding File
  #     object;
  # *   `:stdout` means printing the dump and returning `nil`;
  # *   `:string` means returning a string with the dump;
  # *   if an instance of IO object is provided, the output goes there, and the
  #     object is returned.
  #
  # This method is only expected to work with C Ruby. This is an experimental
  # method and is subject to change. In particular, the function signature and
  # output format are not guaranteed to be compatible in future versions of ruby.
  #
  def self?.dump: (untyped obj, ?output: Symbol) -> (String | File | nil)

  # <!--
  #   rdoc-file=ext/objspace/lib/objspace.rb
  #   - dump_all(output: :file, full: false, since: nil, shapes: true)
  # -->
  # Dump the contents of the ruby heap as JSON.
  #
  # *output* argument is the same as for #dump.
  #
  # *full* must be a boolean. If true, all heap slots are dumped including the
  # empty ones (`T_NONE`).
  #
  # *since* must be a non-negative integer or `nil`.
  #
  # If *since* is a positive integer, only objects of that generation and newer
  # generations are dumped. The current generation can be accessed using
  # GC::count. Objects that were allocated without object allocation tracing
  # enabled are ignored. See ::trace_object_allocations for more information and
  # examples.
  #
  # If *since* is omitted or is `nil`, all objects are dumped.
  #
  # *shapes* must be a boolean or a non-negative integer.
  #
  # If *shapes* is a positive integer, only shapes newer than the provided shape
  # id are dumped. The current shape_id can be accessed using
  # `RubyVM.stat(:next_shape_id)`.
  #
  # If *shapes* is `false`, no shapes are dumped.
  #
  # To only dump objects allocated past a certain point you can combine *since*
  # and *shapes*:
  #     ObjectSpace.trace_object_allocations
  #     GC.start
  #     gc_generation = GC.count
  #     shape_generation = RubyVM.stat(:next_shape_id)
  #     call_method_to_instrument
  #     ObjectSpace.dump_all(since: gc_generation, shapes: shape_generation)
  #
  # This method is only expected to work with C Ruby. This is an experimental
  # method and is subject to change. In particular, the function signature and
  # output format are not guaranteed to be compatible in future versions of ruby.
  #
  def self?.dump_all: (?since: Integer | nil, ?full: boolish, ?output: Symbol) -> (String | File | nil)

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.internal_class_of(obj) -> Class or Module
  # -->
  # MRI specific feature
  # :   Return internal class of obj.
  #
  # obj can be an instance of InternalObjectWrapper.
  #
  # Note that you should not use this method in your application.
  #
  def self?.internal_class_of: (untyped) -> Class

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.internal_super_of(cls) -> Class or Module
  # -->
  # MRI specific feature
  # :   Return internal super class of cls (Class or Module).
  #
  # obj can be an instance of InternalObjectWrapper.
  #
  # Note that you should not use this method in your application.
  #
  def self?.internal_super_of: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.memsize_of(obj) -> Integer
  # -->
  # Return consuming memory size of obj in bytes.
  #
  # Note that the return size is incomplete.  You need to deal with this
  # information as only a **HINT**. Especially, the size of `T_DATA` may not be
  # correct.
  #
  # This method is only expected to work with C Ruby.
  #
  # From Ruby 2.2, memsize_of(obj) returns a memory size includes sizeof(RVALUE).
  #
  def self?.memsize_of: (untyped) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.memsize_of_all([klass]) -> Integer
  # -->
  # Return consuming memory size of all living objects in bytes.
  #
  # If `klass` (should be Class object) is given, return the total memory size of
  # instances of the given class.
  #
  # Note that the returned size is incomplete. You need to deal with this
  # information as only a **HINT**. Especially, the size of `T_DATA` may not be
  # correct.
  #
  # Note that this method does **NOT** return total malloc'ed memory size.
  #
  # This method can be defined by the following Ruby code:
  #
  #     def memsize_of_all klass = false
  #       total = 0
  #       ObjectSpace.each_object{|e|
  #         total += ObjectSpace.memsize_of(e) if klass == false || e.kind_of?(klass)
  #       }
  #       total
  #     end
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.memsize_of_all: (?Class) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.reachable_objects_from(obj) -> array or nil
  # -->
  # MRI specific feature
  # :   Return all reachable objects from `obj'.
  #
  #
  # This method returns all reachable objects from `obj'.
  #
  # If `obj' has two or more references to the same object `x', then returned
  # array only includes one `x' object.
  #
  # If `obj' is a non-markable (non-heap management) object such as true, false,
  # nil, symbols and Fixnums (and Flonum) then it simply returns nil.
  #
  # If `obj' has references to an internal object, then it returns instances of
  # ObjectSpace::InternalObjectWrapper class. This object contains a reference to
  # an internal object and you can check the type of internal object with `type'
  # method.
  #
  # If `obj' is instance of ObjectSpace::InternalObjectWrapper class, then this
  # method returns all reachable object from an internal object, which is pointed
  # by `obj'.
  #
  # With this method, you can find memory leaks.
  #
  # This method is only expected to work with C Ruby.
  #
  # Example:
  #     ObjectSpace.reachable_objects_from(['a', 'b', 'c'])
  #     #=> [Array, 'a', 'b', 'c']
  #
  #     ObjectSpace.reachable_objects_from(['a', 'a', 'a'])
  #     #=> [Array, 'a', 'a', 'a'] # all 'a' strings have different object id
  #
  #     ObjectSpace.reachable_objects_from([v = 'a', v, v])
  #     #=> [Array, 'a']
  #
  #     ObjectSpace.reachable_objects_from(1)
  #     #=> nil # 1 is not markable (heap managed) object
  #
  def self?.reachable_objects_from: (untyped) -> ([ untyped ] | nil)

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.reachable_objects_from_root -> hash
  # -->
  # MRI specific feature
  # :   Return all reachable objects from root.
  #
  def self?.reachable_objects_from_root: () -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations { block }
  # -->
  # Starts tracing object allocations from the ObjectSpace extension module.
  #
  # For example:
  #
  #     require 'objspace'
  #
  #     class C
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "#{allocation_sourcefile(obj)}:#{allocation_sourceline(obj)}"
  #         end
  #       end
  #     end
  #
  #     C.new.foo #=> "objtrace.rb:8"
  #
  # This example has included the ObjectSpace module to make it easier to read,
  # but you can also use the ::trace_object_allocations notation (recommended).
  #
  # Note that this feature introduces a huge performance decrease and huge memory
  # consumption.
  #
  def self.trace_object_allocations: () { (untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_clear
  # -->
  # Clear recorded tracing information.
  #
  def self?.trace_object_allocations_clear: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_debug_start()
  # -->
  #
  def self?.trace_object_allocations_debug_start: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_start
  # -->
  # Starts tracing object allocations.
  #
  def self?.trace_object_allocations_start: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_stop
  # -->
  # Stop tracing object allocations.
  #
  # Note that if ::trace_object_allocations_start is called n-times, then tracing
  # will stop after calling ::trace_object_allocations_stop n-times.
  #
  def self?.trace_object_allocations_stop: () -> void
end
# <!-- rdoc-file=lib/observer.rb -->
# The Observer pattern (also known as publish/subscribe) provides a simple
# mechanism for one object to inform a set of interested third-party objects
# when its state changes.
#
# ## Mechanism
#
# The notifying class mixes in the `Observable` module, which provides the
# methods for managing the associated observer objects.
#
# The observable object must:
# *   assert that it has `#changed`
# *   call `#notify_observers`
#
# An observer subscribes to updates using Observable#add_observer, which also
# specifies the method called via #notify_observers. The default method for
# #notify_observers is #update.
#
# ### Example
#
# The following example demonstrates this nicely.  A `Ticker`, when run,
# continually receives the stock `Price` for its `@symbol`.  A `Warner` is a
# general observer of the price, and two warners are demonstrated, a `WarnLow`
# and a `WarnHigh`, which print a warning if the price is below or above their
# set limits, respectively.
#
# The `update` callback allows the warners to run without being explicitly
# called.  The system is set up with the `Ticker` and several observers, and the
# observers do their duty without the top-level code having to interfere.
#
# Note that the contract between publisher and subscriber (observable and
# observer) is not declared or enforced.  The `Ticker` publishes a time and a
# price, and the warners receive that.  But if you don't ensure that your
# contracts are correct, nothing else can warn you.
#
#     require "observer"
#
#     class Ticker          ### Periodically fetch a stock price.
#       include Observable
#
#       def initialize(symbol)
#         @symbol = symbol
#       end
#
#       def run
#         last_price = nil
#         loop do
#           price = Price.fetch(@symbol)
#           print "Current price: #{price}\n"
#           if price != last_price
#             changed                 # notify observers
#             last_price = price
#             notify_observers(Time.now, price)
#           end
#           sleep 1
#         end
#       end
#     end
#
#     class Price           ### A mock class to fetch a stock price (60 - 140).
#       def self.fetch(symbol)
#         60 + rand(80)
#       end
#     end
#
#     class Warner          ### An abstract observer of Ticker objects.
#       def initialize(ticker, limit)
#         @limit = limit
#         ticker.add_observer(self)
#       end
#     end
#
#     class WarnLow < Warner
#       def update(time, price)       # callback for observer
#         if price < @limit
#           print "--- #{time.to_s}: Price below #@limit: #{price}\n"
#         end
#       end
#     end
#
#     class WarnHigh < Warner
#       def update(time, price)       # callback for observer
#         if price > @limit
#           print "+++ #{time.to_s}: Price above #@limit: #{price}\n"
#         end
#       end
#     end
#
#     ticker = Ticker.new("MSFT")
#     WarnLow.new(ticker, 80)
#     WarnHigh.new(ticker, 120)
#     ticker.run
#
# Produces:
#
#     Current price: 83
#     Current price: 75
#     --- Sun Jun 09 00:10:25 CDT 2002: Price below 80: 75
#     Current price: 90
#     Current price: 134
#     +++ Sun Jun 09 00:10:25 CDT 2002: Price above 120: 134
#     Current price: 134
#     Current price: 112
#     Current price: 79
#     --- Sun Jun 09 00:10:25 CDT 2002: Price below 80: 79
#
# ### Usage with procs
#
# The `#notify_observers` method can also be used with +proc+s by using the
# `:call` as `func` parameter.
#
# The following example illustrates the use of a lambda:
#
#     require 'observer'
#
#     class Ticker
#       include Observable
#
#       def run
#         # logic to retrieve the price (here 77.0)
#         changed
#         notify_observers(77.0)
#       end
#     end
#
#     ticker = Ticker.new
#     warner = ->(price) { puts "New price received: #{price}" }
#     ticker.add_observer(warner, :call)
#     ticker.run
#
module Observable
  # <!--
  #   rdoc-file=lib/observer.rb
  #   - add_observer(observer, func=:update)
  # -->
  # Add `observer` as an observer on this object. So that it will receive
  # notifications.
  #
  # `observer`
  # :   the object that will be notified of changes.
  #
  # `func`
  # :   Symbol naming the method that will be called when this Observable has
  #     changes.
  #
  #     This method must return true for `observer.respond_to?` and will receive
  #     `*arg` when #notify_observers is called, where `*arg` is the value passed
  #     to #notify_observers by this Observable
  #
  def add_observer: (untyped observer, ?Symbol func) -> void

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - changed(state=true)
  # -->
  # Set the changed state of this object.  Notifications will be sent only if the
  # changed `state` is `true`.
  #
  # `state`
  # :   Boolean indicating the changed state of this Observable.
  #
  def changed: (?bool state) -> void

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - changed?()
  # -->
  # Returns true if this object's state has been changed since the last
  # #notify_observers call.
  #
  def changed?: () -> bool

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - count_observers()
  # -->
  # Return the number of observers associated with this object.
  #
  def count_observers: () -> Integer

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - delete_observer(observer)
  # -->
  # Remove `observer` as an observer on this object so that it will no longer
  # receive notifications.
  #
  # `observer`
  # :   An observer of this Observable
  #
  def delete_observer: (untyped observer) -> void

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - delete_observers()
  # -->
  # Remove all observers associated with this object.
  #
  def delete_observers: () -> void

  # <!--
  #   rdoc-file=lib/observer.rb
  #   - notify_observers(*arg)
  # -->
  # Notify observers of a change in state **if** this object's changed state is
  # `true`.
  #
  # This will invoke the method named in #add_observer, passing `*arg`. The
  # changed state is then set to `false`.
  #
  # `*arg`
  # :   Any arguments to pass to the observers.
  #
  def notify_observers: (*untyped arg) -> void

  VERSION: String
end
%a{annotate:rdoc:skip}
module URI
  # <!--
  #   rdoc-file=lib/open-uri.rb
  #   - open(name, *rest, &block)
  # -->
  # Allows the opening of various resources including URIs.
  #
  # If the first argument responds to the 'open' method, 'open' is called on it
  # with the rest of the arguments.
  #
  # If the first argument is a string that begins with `(protocol)://`, it is
  # parsed by URI.parse.  If the parsed object responds to the 'open' method,
  # 'open' is called on it with the rest of the arguments.
  #
  # Otherwise, Kernel#open is called.
  #
  # OpenURI::OpenRead#open provides URI::HTTP#open, URI::HTTPS#open and
  # URI::FTP#open, Kernel#open.
  #
  # We can accept URIs and strings that begin with http://, https:// and ftp://.
  # In these cases, the opened file object is extended by OpenURI::Meta.
  #
  def self.open: (String name, ?String mode, ?Integer perm, ?untyped options) -> ((StringIO & OpenURI::Meta) | (Tempfile & OpenURI::Meta))
               | [T] (String name, ?String mode, ?Integer perm, ?untyped options) { (StringIO | Tempfile) -> T } -> T
end

# <!-- rdoc-file=lib/open-uri.rb -->
# OpenURI is an easy-to-use wrapper for Net::HTTP, Net::HTTPS and Net::FTP.
#
# ## Example
#
# It is possible to open an http, https or ftp URL as though it were a file:
#
#     URI.open("http://www.ruby-lang.org/") {|f|
#       f.each_line {|line| p line}
#     }
#
# The opened file has several getter methods for its meta-information, as
# follows, since it is extended by OpenURI::Meta.
#
#     URI.open("http://www.ruby-lang.org/en") {|f|
#       f.each_line {|line| p line}
#       p f.base_uri         # <URI::HTTP:0x40e6ef2 URL:http://www.ruby-lang.org/en/>
#       p f.content_type     # "text/html"
#       p f.charset          # "iso-8859-1"
#       p f.content_encoding # []
#       p f.last_modified    # Thu Dec 05 02:45:02 UTC 2002
#     }
#
# Additional header fields can be specified by an optional hash argument.
#
#     URI.open("http://www.ruby-lang.org/en/",
#       "User-Agent" => "Ruby/#{RUBY_VERSION}",
#       "From" => "foo@bar.invalid",
#       "Referer" => "http://www.ruby-lang.org/") {|f|
#       # ...
#     }
#
# The environment variables such as http_proxy, https_proxy and ftp_proxy are in
# effect by default. Here we disable proxy:
#
#     URI.open("http://www.ruby-lang.org/en/", :proxy => nil) {|f|
#       # ...
#     }
#
# See OpenURI::OpenRead.open and URI.open for more on available options.
#
# URI objects can be opened in a similar way.
#
#     uri = URI.parse("http://www.ruby-lang.org/en/")
#     uri.open {|f|
#       # ...
#     }
#
# URI objects can be read directly. The returned string is also extended by
# OpenURI::Meta.
#
#     str = uri.read
#     p str.base_uri
#
# Author
# :   Tanaka Akira <akr@m17n.org>
#
module OpenURI
  # <!-- rdoc-file=lib/open-uri.rb -->
  # Mixin for holding meta-information.
  #
  module Meta
    # <!-- rdoc-file=lib/open-uri.rb -->
    # returns an Array that consists of status code and message.
    #
    attr_accessor status: [ String, String ]

    # <!-- rdoc-file=lib/open-uri.rb -->
    # returns a URI that is the base of relative URIs in the data. It may differ
    # from the URI supplied by a user due to redirection.
    #
    attr_accessor base_uri: URI::Generic

    # <!-- rdoc-file=lib/open-uri.rb -->
    # returns a Hash that represents header fields. The Hash keys are downcased for
    # canonicalization. The Hash values are a field body. If there are multiple
    # field with same field name, the field values are concatenated with a comma.
    #
    attr_reader meta: Hash[String, String]

    # <!--
    #   rdoc-file=lib/open-uri.rb
    #   - last_modified()
    # -->
    # returns a Time that represents the Last-Modified field.
    #
    def last_modified: () -> Time?

    # <!--
    #   rdoc-file=lib/open-uri.rb
    #   - content_type()
    # -->
    # returns "type/subtype" which is MIME Content-Type. It is downcased for
    # canonicalization. Content-Type parameters are stripped.
    #
    def content_type: () -> String

    def charet: () -> String?

    # <!--
    #   rdoc-file=lib/open-uri.rb
    #   - content_encoding()
    # -->
    # Returns a list of encodings in Content-Encoding field as an array of strings.
    #
    # The encodings are downcased for canonicalization.
    #
    def content_encoding: () -> Array[String]
  end

  # <!-- rdoc-file=lib/open-uri.rb -->
  # Mixin for HTTP and FTP URIs.
  #
  module OpenRead
    # <!--
    #   rdoc-file=lib/open-uri.rb
    #   - open(*rest, &block)
    # -->
    # OpenURI::OpenRead#open provides `open' for URI::HTTP and URI::FTP.
    #
    # OpenURI::OpenRead#open takes optional 3 arguments as:
    #
    #     OpenURI::OpenRead#open([mode [, perm]] [, options]) [{|io| ... }]
    #
    # OpenURI::OpenRead#open returns an IO-like object if block is not given.
    # Otherwise it yields the IO object and return the value of the block. The IO
    # object is extended with OpenURI::Meta.
    #
    # `mode` and `perm` are the same as Kernel#open.
    #
    # However, `mode` must be read mode because OpenURI::OpenRead#open doesn't
    # support write mode (yet). Also `perm` is ignored because it is meaningful only
    # for file creation.
    #
    # `options` must be a hash.
    #
    # Each option with a string key specifies an extra header field for HTTP. I.e.,
    # it is ignored for FTP without HTTP proxy.
    #
    # The hash may include other options, where keys are symbols:
    #
    # :proxy
    # :   Synopsis:
    #         :proxy => "http://proxy.foo.com:8000/"
    #         :proxy => URI.parse("http://proxy.foo.com:8000/")
    #         :proxy => true
    #         :proxy => false
    #         :proxy => nil
    #
    #     If :proxy option is specified, the value should be String, URI, boolean or
    #     nil.
    #
    #     When String or URI is given, it is treated as proxy URI.
    #
    #     When true is given or the option itself is not specified, environment
    #     variable `scheme_proxy' is examined. `scheme' is replaced by `http',
    #     `https' or `ftp'.
    #
    #     When false or nil is given, the environment variables are ignored and
    #     connection will be made to a server directly.
    #
    #
    # :proxy_http_basic_authentication
    # :   Synopsis:
    #         :proxy_http_basic_authentication =>
    #           ["http://proxy.foo.com:8000/", "proxy-user", "proxy-password"]
    #         :proxy_http_basic_authentication =>
    #           [URI.parse("http://proxy.foo.com:8000/"),
    #            "proxy-user", "proxy-password"]
    #
    #     If :proxy option is specified, the value should be an Array with 3
    #     elements.  It should contain a proxy URI, a proxy user name and a proxy
    #     password.  The proxy URI should be a String, an URI or nil.  The proxy
    #     user name and password should be a String.
    #
    #     If nil is given for the proxy URI, this option is just ignored.
    #
    #     If :proxy and :proxy_http_basic_authentication is specified, ArgumentError
    #     is raised.
    #
    #
    # :http_basic_authentication
    # :   Synopsis:
    #         :http_basic_authentication=>[user, password]
    #
    #     If :http_basic_authentication is specified, the value should be an array
    #     which contains 2 strings: username and password. It is used for HTTP Basic
    #     authentication defined by RFC 2617.
    #
    #
    # :content_length_proc
    # :   Synopsis:
    #         :content_length_proc => lambda {|content_length| ... }
    #
    #     If :content_length_proc option is specified, the option value procedure is
    #     called before actual transfer is started. It takes one argument, which is
    #     expected content length in bytes.
    #
    #     If two or more transfers are performed by HTTP redirection, the procedure
    #     is called only once for the last transfer.
    #
    #     When expected content length is unknown, the procedure is called with nil.
    #      This happens when the HTTP response has no Content-Length header.
    #
    #
    # :progress_proc
    # :   Synopsis:
    #         :progress_proc => lambda {|size| ...}
    #
    #     If :progress_proc option is specified, the proc is called with one
    #     argument each time when `open' gets content fragment from network. The
    #     argument `size` is the accumulated transferred size in bytes.
    #
    #     If two or more transfer is done by HTTP redirection, the procedure is
    #     called only one for a last transfer.
    #
    #     :progress_proc and :content_length_proc are intended to be used for
    #     progress bar. For example, it can be implemented as follows using
    #     Ruby/ProgressBar.
    #
    #         pbar = nil
    #         open("http://...",
    #           :content_length_proc => lambda {|t|
    #             if t && 0 < t
    #               pbar = ProgressBar.new("...", t)
    #               pbar.file_transfer_mode
    #             end
    #           },
    #           :progress_proc => lambda {|s|
    #             pbar.set s if pbar
    #           }) {|f| ... }
    #
    #
    # :read_timeout
    # :   Synopsis:
    #         :read_timeout=>nil     (no timeout)
    #         :read_timeout=>10      (10 second)
    #
    #     :read_timeout option specifies a timeout of read for http connections.
    #
    #
    # :open_timeout
    # :   Synopsis:
    #         :open_timeout=>nil     (no timeout)
    #         :open_timeout=>10      (10 second)
    #
    #     :open_timeout option specifies a timeout of open for http connections.
    #
    #
    # :ssl_ca_cert
    # :   Synopsis:
    #         :ssl_ca_cert=>filename or an Array of filenames
    #
    #     :ssl_ca_cert is used to specify CA certificate for SSL. If it is given,
    #     default certificates are not used.
    #
    #
    # :ssl_verify_mode
    # :   Synopsis:
    #         :ssl_verify_mode=>mode
    #
    #     :ssl_verify_mode is used to specify openssl verify mode.
    #
    #
    # :ssl_min_version
    # :   Synopsis:
    #         :ssl_min_version=>:TLS1_2
    #
    #     :ssl_min_version option specifies the minimum allowed SSL/TLS protocol
    #     version.  See also OpenSSL::SSL::SSLContext#min_version=.
    #
    #
    # :ssl_max_version
    # :   Synopsis:
    #         :ssl_max_version=>:TLS1_2
    #
    #     :ssl_max_version option specifies the maximum allowed SSL/TLS protocol
    #     version.  See also OpenSSL::SSL::SSLContext#max_version=.
    #
    #
    # :ftp_active_mode
    # :   Synopsis:
    #         :ftp_active_mode=>bool
    #
    #     `:ftp_active_mode => true` is used to make ftp active mode. Ruby 1.9 uses
    #     passive mode by default. Note that the active mode is default in Ruby 1.8
    #     or prior.
    #
    #
    # :redirect
    # :   Synopsis:
    #         :redirect=>bool
    #
    #     `:redirect` is true by default.  `:redirect => false` is used to disable
    #     all HTTP redirects.
    #
    #     OpenURI::HTTPRedirect exception raised on redirection. Using `true` also
    #     means that redirections between http and ftp are permitted.
    #
    #
    # :max_redirects
    # :   Synopsis:
    #         :max_redirects=>int
    #
    #     Number of HTTP redirects allowed before OpenURI::TooManyRedirects is
    #     raised. The default is 64.
    #
    #
    # :request_specific_fields
    # :   Synopsis:
    #         :request_specific_fields => {}
    #         :request_specific_fields => lambda {|url| ...}
    #
    #     :request_specific_fields option allows specifying custom header fields
    #     that are sent with the HTTP request. It can be passed as a Hash or a Proc
    #     that gets evaluated on each request and returns a Hash of header fields.
    #
    #     If a Hash is provided, it specifies the headers only for the initial
    #     request and these headers will not be sent on redirects.
    #
    #     If a Proc is provided, it will be executed for each request including
    #     redirects, allowing dynamic header customization based on the request URL.
    #     It is important that the Proc returns a Hash. And this Hash specifies the
    #     headers to be sent with the request.
    #
    #     For Example with Hash
    #         URI.open("http://...",
    #                  request_specific_fields: {"Authorization" => "token dummy"}) {|f| ... }
    #
    #     For Example with Proc:
    #         URI.open("http://...",
    #                  request_specific_fields: lambda { |uri|
    #                    if uri.host == "example.com"
    #                      {"Authorization" => "token dummy"}
    #                    else
    #                      {}
    #                    end
    #                  }) {|f| ... }
    #
    def open: (*untyped) -> IO
            | [T] (*untyped) { (IO) -> T } -> T

    # <!--
    #   rdoc-file=lib/open-uri.rb
    #   - read(options={})
    # -->
    # OpenURI::OpenRead#read([ options ]) reads a content referenced by self and
    # returns the content as string. The string is extended with OpenURI::Meta. The
    # argument `options` is same as OpenURI::OpenRead#open.
    #
    def read: (untyped options) -> String
  end
end

%a{annotate:rdoc:skip}
module URI
  %a{annotate:rdoc:skip}
  class HTTP
    include OpenURI::OpenRead
  end

  %a{annotate:rdoc:skip}
  class FTP
    include OpenURI::OpenRead
  end
end
# <!-- rdoc-file=lib/open3.rb -->
# Module Open3 supports creating child processes with access to their $stdin,
# $stdout, and $stderr streams.
#
# ## What's Here
#
# Each of these methods executes a given command in a new process or subshell,
# or multiple commands in new processes and/or subshells:
#
# *   Each of these methods executes a single command in a process or subshell,
#     accepts a string for input to $stdin, and returns string output from
#     $stdout, $stderr, or both:
#
#     *   Open3.capture2: Executes the command; returns the string from $stdout.
#     *   Open3.capture2e: Executes the command; returns the string from merged
#         $stdout and $stderr.
#     *   Open3.capture3: Executes the command; returns strings from $stdout and
#         $stderr.
#
# *   Each of these methods executes a single command in a process or subshell,
#     and returns pipes for $stdin, $stdout, and/or $stderr:
#
#     *   Open3.popen2: Executes the command; returns pipes for $stdin and
#         $stdout.
#     *   Open3.popen2e: Executes the command; returns pipes for $stdin and
#         merged $stdout and $stderr.
#     *   Open3.popen3: Executes the command; returns pipes for $stdin, $stdout,
#         and $stderr.
#
# *   Each of these methods executes one or more commands in processes and/or
#     subshells, returns pipes for the first $stdin, the last $stdout, or both:
#
#     *   Open3.pipeline_r: Returns a pipe for the last $stdout.
#     *   Open3.pipeline_rw: Returns pipes for the first $stdin and the last
#         $stdout.
#     *   Open3.pipeline_w: Returns a pipe for the first $stdin.
#     *   Open3.pipeline_start: Does not wait for processes to complete.
#     *   Open3.pipeline: Waits for processes to complete.
#
# Each of the methods above accepts:
#
# *   An optional hash of environment variable names and values; see [Execution
#     Environment](rdoc-ref:Process@Execution+Environment).
# *   A required string argument that is a `command_line` or `exe_path`; see
#     [Argument command_line or
#     exe_path](rdoc-ref:Process@Argument+command_line+or+exe_path).
# *   An optional hash of execution options; see [Execution
#     Options](rdoc-ref:Process@Execution+Options).
#
module Open3
  # <!--
  #   rdoc-file=lib/open3.rb
  #   - Open3.capture2e([env, ] command_line, options = {}) -> [stdout_and_stderr_s, status]
  #   - Open3.capture2e([env, ] exe_path, *args, options = {}) -> [stdout_and_stderr_s, status]
  # -->
  # Basically a wrapper for Open3.popen3 that:
  #
  # *   Creates a child process, by calling Open3.popen3 with the given arguments
  #     (except for certain entries in hash `options`; see below).
  # *   Returns as string `stdout_and_stderr_s` the merged standard output and
  #     standard error of the child process.
  # *   Returns as `status` a `Process::Status` object that represents the exit
  #     status of the child process.
  #
  # Returns the array `[stdout_and_stderr_s, status]`:
  #
  #     stdout_and_stderr_s, status = Open3.capture2e('echo "Foo"')
  #     # => ["Foo\n", #<Process::Status: pid 2371692 exit 0>]
  #
  # Like Process.spawn, this method has potential security vulnerabilities if
  # called with untrusted input; see [Command
  # Injection](rdoc-ref:command_injection.rdoc@Command+Injection).
  #
  # Unlike Process.spawn, this method waits for the child process to exit before
  # returning, so the caller need not do so.
  #
  # If the first argument is a hash, it becomes leading argument `env` in the call
  # to Open3.popen3; see [Execution
  # Environment](rdoc-ref:Process@Execution+Environment).
  #
  # If the last argument is a hash, it becomes trailing argument `options` in the
  # call to Open3.popen3; see [Execution
  # Options](rdoc-ref:Process@Execution+Options).
  #
  # The hash `options` is given; two options have local effect in method
  # Open3.capture2e:
  #
  # *   If entry `options[:stdin_data]` exists, the entry is removed and its
  #     string value is sent to the command's standard input:
  #
  #         Open3.capture2e('tee', stdin_data: 'Foo')
  #         # => ["Foo", #<Process::Status: pid 2371732 exit 0>]
  #
  # *   If entry `options[:binmode]` exists, the entry is removed and the internal
  #     streams are set to binary mode.
  #
  # The single required argument is one of the following:
  #
  # *   `command_line` if it is a string, and if it begins with a shell reserved
  #     word or special built-in, or if it contains one or more metacharacters.
  # *   `exe_path` otherwise.
  #
  # **Argument `command_line`**
  #
  # String argument `command_line` is a command line to be passed to a shell; it
  # must begin with a shell reserved word, begin with a special built-in, or
  # contain meta characters:
  #
  #     Open3.capture2e('if true; then echo "Foo"; fi') # Shell reserved word.
  #     # => ["Foo\n", #<Process::Status: pid 2371740 exit 0>]
  #     Open3.capture2e('echo')                         # Built-in.
  #     # => ["\n", #<Process::Status: pid 2371774 exit 0>]
  #     Open3.capture2e('date > date.tmp')              # Contains meta character.
  #     # => ["", #<Process::Status: pid 2371812 exit 0>]
  #
  # The command line may also contain arguments and options for the command:
  #
  #     Open3.capture2e('echo "Foo"')
  #     # => ["Foo\n", #<Process::Status: pid 2326183 exit 0>]
  #
  # **Argument `exe_path`**
  #
  # Argument `exe_path` is one of the following:
  #
  # *   The string path to an executable to be called.
  # *   A 2-element array containing the path to an executable and the string to
  #     be used as the name of the executing process.
  #
  # Example:
  #
  #     Open3.capture2e('/usr/bin/date')
  #     # => ["Sat Sep 30 09:01:46 AM CDT 2023\n", #<Process::Status: pid 2371820 exit 0>]
  #
  # Ruby invokes the executable directly, with no shell and no shell expansion:
  #
  #     Open3.capture2e('doesnt_exist') # Raises Errno::ENOENT
  #
  # If one or more `args` is given, each is an argument or option to be passed to
  # the executable:
  #
  #     Open3.capture2e('echo', 'C #')
  #     # => ["C #\n", #<Process::Status: pid 2371856 exit 0>]
  #     Open3.capture2e('echo', 'hello', 'world')
  #     # => ["hello world\n", #<Process::Status: pid 2371894 exit 0>]
  #
  def self.capture2e: (*String, ?stdin_data: String, ?binmode: boolish) -> [String, Process::Status]
end
# <!-- rdoc-file=ext/openssl/ossl.c -->
# OpenSSL provides SSL, TLS and general purpose cryptography.  It wraps the
# [OpenSSL](https://www.openssl.org/) library.
#
# # Examples
#
# All examples assume you have loaded OpenSSL with:
#
#     require 'openssl'
#
# These examples build atop each other.  For example the key created in the next
# is used in throughout these examples.
#
# ## Keys
#
# ### Creating a Key
#
# This example creates a 2048 bit RSA keypair and writes it to the current
# directory.
#
#     key = OpenSSL::PKey::RSA.new 2048
#
#     File.write 'private_key.pem', key.private_to_pem
#     File.write 'public_key.pem', key.public_to_pem
#
# ### Exporting a Key
#
# Keys saved to disk without encryption are not secure as anyone who gets ahold
# of the key may use it unless it is encrypted.  In order to securely export a
# key you may export it with a password.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     password = 'my secure password goes here'
#
#     key_secure = key.private_to_pem cipher, password
#
#     File.write 'private.secure.pem', key_secure
#
# OpenSSL::Cipher.ciphers returns a list of available ciphers.
#
# ### Loading a Key
#
# A key can also be loaded from a file.
#
#     key2 = OpenSSL::PKey.read File.read 'private_key.pem'
#     key2.public? # => true
#     key2.private? # => true
#
# or
#
#     key3 = OpenSSL::PKey.read File.read 'public_key.pem'
#     key3.public? # => true
#     key3.private? # => false
#
# ### Loading an Encrypted Key
#
# OpenSSL will prompt you for your password when loading an encrypted key. If
# you will not be able to type in the password you may provide it when loading
# the key:
#
#     key4_pem = File.read 'private.secure.pem'
#     password = 'my secure password goes here'
#     key4 = OpenSSL::PKey.read key4_pem, password
#
# ## RSA Encryption
#
# RSA provides encryption and decryption using the public and private keys. You
# can use a variety of padding methods depending upon the intended use of
# encrypted data.
#
# ### Encryption & Decryption
#
# Asymmetric public/private key encryption is slow and victim to attack in cases
# where it is used without padding or directly to encrypt larger chunks of data.
# Typical use cases for RSA encryption involve "wrapping" a symmetric key with
# the public key of the recipient who would "unwrap" that symmetric key again
# using their private key. The following illustrates a simplified example of
# such a key transport scheme. It shouldn't be used in practice, though,
# standardized protocols should always be preferred.
#
#     wrapped_key = key.public_encrypt key
#
# A symmetric key encrypted with the public key can only be decrypted with the
# corresponding private key of the recipient.
#
#     original_key = key.private_decrypt wrapped_key
#
# By default PKCS#1 padding will be used, but it is also possible to use other
# forms of padding, see PKey::RSA for further details.
#
# ### Signatures
#
# Using "private_encrypt" to encrypt some data with the private key is
# equivalent to applying a digital signature to the data. A verifying party may
# validate the signature by comparing the result of decrypting the signature
# with "public_decrypt" to the original data. However, OpenSSL::PKey already has
# methods "sign" and "verify" that handle digital signatures in a standardized
# way - "private_encrypt" and "public_decrypt" shouldn't be used in practice.
#
# To sign a document, a cryptographically secure hash of the document is
# computed first, which is then signed using the private key.
#
#     signature = key.sign 'SHA256', document
#
# To validate the signature, again a hash of the document is computed and the
# signature is decrypted using the public key. The result is then compared to
# the hash just computed, if they are equal the signature was valid.
#
#     if key.verify 'SHA256', signature, document
#       puts 'Valid'
#     else
#       puts 'Invalid'
#     end
#
# ## PBKDF2 Password-based Encryption
#
# If supported by the underlying OpenSSL version used, Password-based Encryption
# should use the features of PKCS5. If not supported or if required by legacy
# applications, the older, less secure methods specified in RFC 2898 are also
# supported (see below).
#
# PKCS5 supports PBKDF2 as it was specified in PKCS#5
# [v2.0](http://www.rsa.com/rsalabs/node.asp?id=2127). It still uses a password,
# a salt, and additionally a number of iterations that will slow the key
# derivation process down. The slower this is, the more work it requires being
# able to brute-force the resulting key.
#
# ### Encryption
#
# The strategy is to first instantiate a Cipher for encryption, and then to
# generate a random IV plus a key derived from the password using PBKDF2. PKCS
# #5 v2.0 recommends at least 8 bytes for the salt, the number of iterations
# largely depends on the hardware being used.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     cipher.encrypt
#     iv = cipher.random_iv
#
#     pwd = 'some hopefully not to easily guessable password'
#     salt = OpenSSL::Random.random_bytes 16
#     iter = 20000
#     key_len = cipher.key_len
#     digest = OpenSSL::Digest.new('SHA256')
#
#     key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
#     cipher.key = key
#
#     Now encrypt the data:
#
#     encrypted = cipher.update document
#     encrypted << cipher.final
#
# ### Decryption
#
# Use the same steps as before to derive the symmetric AES key, this time
# setting the Cipher up for decryption.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     cipher.decrypt
#     cipher.iv = iv # the one generated with #random_iv
#
#     pwd = 'some hopefully not to easily guessable password'
#     salt = ... # the one generated above
#     iter = 20000
#     key_len = cipher.key_len
#     digest = OpenSSL::Digest.new('SHA256')
#
#     key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
#     cipher.key = key
#
#     Now decrypt the data:
#
#     decrypted = cipher.update encrypted
#     decrypted << cipher.final
#
# ## X509 Certificates
#
# ### Creating a Certificate
#
# This example creates a self-signed certificate using an RSA key and a SHA1
# signature.
#
#     key = OpenSSL::PKey::RSA.new 2048
#     name = OpenSSL::X509::Name.parse '/CN=nobody/DC=example'
#
#     cert = OpenSSL::X509::Certificate.new
#     cert.version = 2
#     cert.serial = 0
#     cert.not_before = Time.now
#     cert.not_after = Time.now + 3600
#
#     cert.public_key = key.public_key
#     cert.subject = name
#
# ### Certificate Extensions
#
# You can add extensions to the certificate with OpenSSL::SSL::ExtensionFactory
# to indicate the purpose of the certificate.
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new nil, cert
#
#     cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:FALSE', true)
#
#     cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')
#
#     cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
# The list of supported extensions (and in some cases their possible values) can
# be derived from the "objects.h" file in the OpenSSL source code.
#
# ### Signing a Certificate
#
# To sign a certificate set the issuer and use OpenSSL::X509::Certificate#sign
# with a digest algorithm.  This creates a self-signed cert because we're using
# the same name and key to sign the certificate as was used to create the
# certificate.
#
#     cert.issuer = name
#     cert.sign key, OpenSSL::Digest.new('SHA1')
#
#     open 'certificate.pem', 'w' do |io| io.write cert.to_pem end
#
# ### Loading a Certificate
#
# Like a key, a cert can also be loaded from a file.
#
#     cert2 = OpenSSL::X509::Certificate.new File.read 'certificate.pem'
#
# ### Verifying a Certificate
#
# Certificate#verify will return true when a certificate was signed with the
# given public key.
#
#     raise 'certificate can not be verified' unless cert2.verify key
#
# ## Certificate Authority
#
# A certificate authority (CA) is a trusted third party that allows you to
# verify the ownership of unknown certificates.  The CA issues key signatures
# that indicate it trusts the user of that key.  A user encountering the key can
# verify the signature by using the CA's public key.
#
# ### CA Key
#
# CA keys are valuable, so we encrypt and save it to disk and make sure it is
# not readable by other users.
#
#     ca_key = OpenSSL::PKey::RSA.new 2048
#     password = 'my secure password goes here'
#
#     cipher = 'aes-256-cbc'
#
#     open 'ca_key.pem', 'w', 0400 do |io|
#       io.write ca_key.private_to_pem(cipher, password)
#     end
#
# ### CA Certificate
#
# A CA certificate is created the same way we created a certificate above, but
# with different extensions.
#
#     ca_name = OpenSSL::X509::Name.parse '/CN=ca/DC=example'
#
#     ca_cert = OpenSSL::X509::Certificate.new
#     ca_cert.serial = 0
#     ca_cert.version = 2
#     ca_cert.not_before = Time.now
#     ca_cert.not_after = Time.now + 86400
#
#     ca_cert.public_key = ca_key.public_key
#     ca_cert.subject = ca_name
#     ca_cert.issuer = ca_name
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new
#     extension_factory.subject_certificate = ca_cert
#     extension_factory.issuer_certificate = ca_cert
#
#     ca_cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
# This extension indicates the CA's key may be used as a CA.
#
#     ca_cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:TRUE', true)
#
# This extension indicates the CA's key may be used to verify signatures on both
# certificates and certificate revocations.
#
#     ca_cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'cRLSign,keyCertSign', true)
#
# Root CA certificates are self-signed.
#
#     ca_cert.sign ca_key, OpenSSL::Digest.new('SHA1')
#
# The CA certificate is saved to disk so it may be distributed to all the users
# of the keys this CA will sign.
#
#     open 'ca_cert.pem', 'w' do |io|
#       io.write ca_cert.to_pem
#     end
#
# ### Certificate Signing Request
#
# The CA signs keys through a Certificate Signing Request (CSR).  The CSR
# contains the information necessary to identify the key.
#
#     csr = OpenSSL::X509::Request.new
#     csr.version = 0
#     csr.subject = name
#     csr.public_key = key.public_key
#     csr.sign key, OpenSSL::Digest.new('SHA1')
#
# A CSR is saved to disk and sent to the CA for signing.
#
#     open 'csr.pem', 'w' do |io|
#       io.write csr.to_pem
#     end
#
# ### Creating a Certificate from a CSR
#
# Upon receiving a CSR the CA will verify it before signing it.  A minimal
# verification would be to check the CSR's signature.
#
#     csr = OpenSSL::X509::Request.new File.read 'csr.pem'
#
#     raise 'CSR can not be verified' unless csr.verify csr.public_key
#
# After verification a certificate is created, marked for various usages, signed
# with the CA key and returned to the requester.
#
#     csr_cert = OpenSSL::X509::Certificate.new
#     csr_cert.serial = 0
#     csr_cert.version = 2
#     csr_cert.not_before = Time.now
#     csr_cert.not_after = Time.now + 600
#
#     csr_cert.subject = csr.subject
#     csr_cert.public_key = csr.public_key
#     csr_cert.issuer = ca_cert.subject
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new
#     extension_factory.subject_certificate = csr_cert
#     extension_factory.issuer_certificate = ca_cert
#
#     csr_cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:FALSE')
#
#     csr_cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')
#
#     csr_cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
#     csr_cert.sign ca_key, OpenSSL::Digest.new('SHA1')
#
#     open 'csr_cert.pem', 'w' do |io|
#       io.write csr_cert.to_pem
#     end
#
# ## SSL and TLS Connections
#
# Using our created key and certificate we can create an SSL or TLS connection.
# An SSLContext is used to set up an SSL session.
#
#     context = OpenSSL::SSL::SSLContext.new
#
# ### SSL Server
#
# An SSL server requires the certificate and private key to communicate securely
# with its clients:
#
#     context.cert = cert
#     context.key = key
#
# Then create an SSLServer with a TCP server socket and the context.  Use the
# SSLServer like an ordinary TCP server.
#
#     require 'socket'
#
#     tcp_server = TCPServer.new 5000
#     ssl_server = OpenSSL::SSL::SSLServer.new tcp_server, context
#
#     loop do
#       ssl_connection = ssl_server.accept
#
#       data = ssl_connection.gets
#
#       response = "I got #{data.dump}"
#       puts response
#
#       ssl_connection.puts "I got #{data.dump}"
#       ssl_connection.close
#     end
#
# ### SSL client
#
# An SSL client is created with a TCP socket and the context. SSLSocket#connect
# must be called to initiate the SSL handshake and start encryption.  A key and
# certificate are not required for the client socket.
#
# Note that SSLSocket#close doesn't close the underlying socket by default. Set
# SSLSocket#sync_close to true if you want.
#
#     require 'socket'
#
#     tcp_socket = TCPSocket.new 'localhost', 5000
#     ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
#     ssl_client.sync_close = true
#     ssl_client.connect
#
#     ssl_client.puts "hello server!"
#     puts ssl_client.gets
#
#     ssl_client.close # shutdown the TLS connection and close tcp_socket
#
# ### Peer Verification
#
# An unverified SSL connection does not provide much security.  For enhanced
# security the client or server can verify the certificate of its peer.
#
# The client can be modified to verify the server's certificate against the
# certificate authority's certificate:
#
#     context.ca_file = 'ca_cert.pem'
#     context.verify_mode = OpenSSL::SSL::VERIFY_PEER
#
#     require 'socket'
#
#     tcp_socket = TCPSocket.new 'localhost', 5000
#     ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
#     ssl_client.connect
#
#     ssl_client.puts "hello server!"
#     puts ssl_client.gets
#
# If the server certificate is invalid or `context.ca_file` is not set when
# verifying peers an OpenSSL::SSL::SSLError will be raised.
#
module OpenSSL
  # <!--
  #   rdoc-file=ext/openssl/lib/openssl/digest.rb
  #   - Digest(name)
  # -->
  # Returns a Digest subclass by *name*
  #
  #     require 'openssl'
  #
  #     OpenSSL::Digest("MD5")
  #     # => OpenSSL::Digest::MD5
  #
  #     Digest("Foo")
  #     # => NameError: wrong constant name Foo
  #
  def self.Digest: (String name) -> singleton(Digest)

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.debug -> true | false
  # -->
  #
  def self.debug: () -> bool

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.debug = boolean -> boolean
  # -->
  # Turns on or off debug mode. With debug mode, all errors added to the OpenSSL
  # error queue will be printed to stderr.
  #
  def self.debug=: [U] (boolish) -> U

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.errors -> [String...]
  # -->
  # See any remaining errors held in queue.
  #
  # Any errors you see here are probably due to a bug in Ruby's OpenSSL
  # implementation.
  #
  def self.errors: () -> Array[String]

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fips_mode -> true | false
  # -->
  #
  def self.fips_mode: () -> bool

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fips_mode = boolean -> boolean
  # -->
  # Turns FIPS mode on or off. Turning on FIPS mode will obviously only have an
  # effect for FIPS-capable installations of the OpenSSL library. Trying to do so
  # otherwise will result in an error.
  #
  # ### Examples
  #     OpenSSL.fips_mode = true   # turn FIPS mode on
  #     OpenSSL.fips_mode = false  # and off again
  #
  def self.fips_mode=: [U] (boolish) -> U

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fixed_length_secure_compare(string, string) -> boolean
  # -->
  # Constant time memory comparison for fixed length strings, such as results of
  # HMAC calculations.
  #
  # Returns `true` if the strings are identical, `false` if they are of the same
  # length but not identical. If the length is different, `ArgumentError` is
  # raised.
  #
  def self.fixed_length_secure_compare: (String, String) -> bool

  # <!--
  #   rdoc-file=ext/openssl/lib/openssl.rb
  #   - OpenSSL.secure_compare(string, string) -> boolean
  # -->
  # Constant time memory comparison. Inputs are hashed using SHA-256 to mask the
  # length of the secret. Returns `true` if the strings are identical, `false`
  # otherwise.
  #
  def self.secure_compare: (String a, String b) -> bool

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Boolean indicating whether OpenSSL is FIPS-capable or not
  #
  OPENSSL_FIPS: bool

  OPENSSL_LIBRARY_VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Version of OpenSSL the ruby OpenSSL extension was built with
  #
  OPENSSL_VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Version number of OpenSSL the ruby OpenSSL extension was built with (base 16).
  # The formats are below.
  #
  # OpenSSL 3
  # :   `0xMNN00PP0 (major minor 00 patch 0)`
  #
  # OpenSSL before 3
  # :   `0xMNNFFPPS (major minor fix patch status)`
  #
  # LibreSSL
  # :   `0x20000000 (fixed value)`
  #
  #
  # See also the man page OPENSSL_VERSION_NUMBER(3).
  #
  OPENSSL_VERSION_NUMBER: Integer

  VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
  # Abstract Syntax Notation One (or ASN.1) is a notation syntax to describe data
  # structures and is defined in ITU-T X.680. ASN.1 itself does not mandate any
  # encoding or parsing rules, but usually ASN.1 data structures are encoded using
  # the Distinguished Encoding Rules (DER) or less often the Basic Encoding Rules
  # (BER) described in ITU-T X.690. DER and BER encodings are binary
  # Tag-Length-Value (TLV) encodings that are quite concise compared to other
  # popular data description formats such as XML, JSON etc. ASN.1 data structures
  # are very common in cryptographic applications, e.g. X.509 public key
  # certificates or certificate revocation lists (CRLs) are all defined in ASN.1
  # and DER-encoded. ASN.1, DER and BER are the building blocks of applied
  # cryptography. The ASN1 module provides the necessary classes that allow
  # generation of ASN.1 data structures and the methods to encode them using a DER
  # encoding. The decode method allows parsing arbitrary BER-/DER-encoded data to
  # a Ruby object that can then be modified and re-encoded at will.
  #
  # ## ASN.1 class hierarchy
  #
  # The base class representing ASN.1 structures is ASN1Data. ASN1Data offers
  # attributes to read and set the *tag*, the *tag_class* and finally the *value*
  # of a particular ASN.1 item. Upon parsing, any tagged values (implicit or
  # explicit) will be represented by ASN1Data instances because their "real type"
  # can only be determined using out-of-band information from the ASN.1 type
  # declaration. Since this information is normally known when encoding a type,
  # all sub-classes of ASN1Data offer an additional attribute *tagging* that
  # allows to encode a value implicitly (`:IMPLICIT`) or explicitly (`:EXPLICIT`).
  #
  # ### Constructive
  #
  # Constructive is, as its name implies, the base class for all constructed
  # encodings, i.e. those that consist of several values, opposed to "primitive"
  # encodings with just one single value. The value of an Constructive is always
  # an Array.
  #
  # #### ASN1::Set and ASN1::Sequence
  #
  # The most common constructive encodings are SETs and SEQUENCEs, which is why
  # there are two sub-classes of Constructive representing each of them.
  #
  # ### Primitive
  #
  # This is the super class of all primitive values. Primitive itself is not used
  # when parsing ASN.1 data, all values are either instances of a corresponding
  # sub-class of Primitive or they are instances of ASN1Data if the value was
  # tagged implicitly or explicitly. Please cf. Primitive documentation for
  # details on sub-classes and their respective mappings of ASN.1 data types to
  # Ruby objects.
  #
  # ## Possible values for *tagging*
  #
  # When constructing an ASN1Data object the ASN.1 type definition may require
  # certain elements to be either implicitly or explicitly tagged. This can be
  # achieved by setting the *tagging* attribute manually for sub-classes of
  # ASN1Data. Use the symbol `:IMPLICIT` for implicit tagging and `:EXPLICIT` if
  # the element requires explicit tagging.
  #
  # ## Possible values for *tag_class*
  #
  # It is possible to create arbitrary ASN1Data objects that also support a
  # PRIVATE or APPLICATION tag class. Possible values for the *tag_class*
  # attribute are:
  # *   `:UNIVERSAL` (the default for untagged values)
  # *   `:CONTEXT_SPECIFIC` (the default for tagged values)
  # *   `:APPLICATION`
  # *   `:PRIVATE`
  #
  # ## Tag constants
  #
  # There is a constant defined for each universal tag:
  # *   OpenSSL::ASN1::EOC (0)
  # *   OpenSSL::ASN1::BOOLEAN (1)
  # *   OpenSSL::ASN1::INTEGER (2)
  # *   OpenSSL::ASN1::BIT_STRING (3)
  # *   OpenSSL::ASN1::OCTET_STRING (4)
  # *   OpenSSL::ASN1::NULL (5)
  # *   OpenSSL::ASN1::OBJECT (6)
  # *   OpenSSL::ASN1::ENUMERATED (10)
  # *   OpenSSL::ASN1::UTF8STRING (12)
  # *   OpenSSL::ASN1::SEQUENCE (16)
  # *   OpenSSL::ASN1::SET (17)
  # *   OpenSSL::ASN1::NUMERICSTRING (18)
  # *   OpenSSL::ASN1::PRINTABLESTRING (19)
  # *   OpenSSL::ASN1::T61STRING (20)
  # *   OpenSSL::ASN1::VIDEOTEXSTRING (21)
  # *   OpenSSL::ASN1::IA5STRING (22)
  # *   OpenSSL::ASN1::UTCTIME (23)
  # *   OpenSSL::ASN1::GENERALIZEDTIME (24)
  # *   OpenSSL::ASN1::GRAPHICSTRING (25)
  # *   OpenSSL::ASN1::ISO64STRING (26)
  # *   OpenSSL::ASN1::GENERALSTRING (27)
  # *   OpenSSL::ASN1::UNIVERSALSTRING (28)
  # *   OpenSSL::ASN1::BMPSTRING (30)
  #
  # ## UNIVERSAL_TAG_NAME constant
  #
  # An Array that stores the name of a given tag number. These names are the same
  # as the name of the tag constant that is additionally defined, e.g.
  # `UNIVERSAL_TAG_NAME[2] = "INTEGER"` and `OpenSSL::ASN1::INTEGER = 2`.
  #
  # ## Example usage
  #
  # ### Decoding and viewing a DER-encoded file
  #     require 'openssl'
  #     require 'pp'
  #     der = File.binread('data.der')
  #     asn1 = OpenSSL::ASN1.decode(der)
  #     pp der
  #
  # ### Creating an ASN.1 structure and DER-encoding it
  #     require 'openssl'
  #     version = OpenSSL::ASN1::Integer.new(1)
  #     # Explicitly 0-tagged implies context-specific tag class
  #     serial = OpenSSL::ASN1::Integer.new(12345, 0, :EXPLICIT, :CONTEXT_SPECIFIC)
  #     name = OpenSSL::ASN1::PrintableString.new('Data 1')
  #     sequence = OpenSSL::ASN1::Sequence.new( [ version, serial, name ] )
  #     der = sequence.to_der
  #
  module ASN1
    type tagging = :IMPLICIT | :EXPLICIT

    type tag_class = :UNIVERSAL | :CONTEXT_SPECIFIC | :APPLICATION | :PRIVATE

    def self.BMPString: (String value, ?bn tag, ?tagging tagging) -> BMPString

    def self.BitString: (String value, ?bn tag, ?tagging tagging) -> BitString

    def self.Boolean: (boolish value, ?bn tag, ?tagging tagging) -> Boolean

    def self.EndOfContent: () -> EndOfContent

    def self.Enumerated: (bn value, ?bn tag, ?tagging tagging) -> Enumerated

    def self.GeneralString: (String value, ?bn tag, ?tagging tagging) -> GeneralString

    def self.GeneralizedTime: (::Time value, ?bn tag, ?tagging tagging) -> GeneralizedTime

    def self.GraphicString: (String value, ?bn tag, ?tagging tagging) -> GraphicString

    def self.IA5String: (String value, ?bn tag, ?tagging tagging) -> IA5String

    def self.ISO64String: (String value, ?bn tag, ?tagging tagging) -> ISO64String

    def self.Integer: (bn value, ?bn tag, ?tagging tagging) -> Integer

    def self.Null: (nil) -> Null

    def self.NumericString: (String value, ?bn tag, ?tagging tagging) -> NumericString

    def self.ObjectId: (String value, ?bn tag, ?tagging tagging) -> ObjectId

    def self.OctetString: (String value, ?bn tag, ?tagging tagging) -> OctetString

    def self.PrintableString: (String value, ?bn tag, ?tagging tagging) -> PrintableString

    def self.Sequence: (Array[ASN1Data] value, ?bn tag, ?tagging tagging) -> Sequence

    def self.Set: (Array[ASN1Data] value, ?bn tag, ?tagging tagging) -> Set

    def self.T61String: (String value, ?bn tag, ?tagging tagging) -> T61String

    def self.UTCTime: (::Time value, ?bn tag, ?tagging tagging) -> UTCTime

    def self.UTF8String: (String value, ?bn tag, ?tagging tagging) -> UTF8String

    def self.UniversalString: (String value, ?bn tag, ?tagging tagging) -> UniversalString

    def self.VideotexString: (String value, ?bn tag, ?tagging tagging) -> VideotexString

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.decode(der) -> ASN1Data
    # -->
    # Decodes a BER- or DER-encoded value and creates an ASN1Data instance. *der*
    # may be a String or any object that features a `.to_der` method transforming it
    # into a BER-/DER-encoded String+
    #
    # ## Example
    #     der = File.binread('asn1data')
    #     asn1 = OpenSSL::ASN1.decode(der)
    #
    def self.decode: (String | _ToDer der) -> ASN1Data

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.decode_all(der) -> Array of ASN1Data
    # -->
    # Similar to #decode with the difference that #decode expects one distinct value
    # represented in *der*. #decode_all on the contrary decodes a sequence of
    # sequential BER/DER values lined up in *der* and returns them as an array.
    #
    # ## Example
    #     ders = File.binread('asn1data_seq')
    #     asn1_ary = OpenSSL::ASN1.decode_all(ders)
    #
    def self.decode_all: (String | _ToDer der) -> Array[ASN1Data]

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.traverse(asn1) -> nil
    # -->
    # If a block is given, it prints out each of the elements encountered. Block
    # parameters are (in that order):
    # *   depth: The recursion depth, plus one with each constructed value being
    #     encountered (Integer)
    # *   offset: Current byte offset (Integer)
    # *   header length: Combined length in bytes of the Tag and Length headers.
    #     (Integer)
    # *   length: The overall remaining length of the entire data (Integer)
    # *   constructed: Whether this value is constructed or not (Boolean)
    # *   tag_class: Current tag class (Symbol)
    # *   tag: The current tag number (Integer)
    #
    # ## Example
    #     der = File.binread('asn1data.der')
    #     OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length, constructed, tag_class, tag|
    #       puts "Depth: #{depth} Offset: #{offset} Length: #{length}"
    #       puts "Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class} Constructed: #{constructed}"
    #     end
    #
    def self.traverse: (String | _ToDer der) { ([::Integer, ::Integer, ::Integer, ::Integer, bool, tag_class, ::Integer]) -> void } -> void

    BIT_STRING: Integer

    BMPSTRING: Integer

    BOOLEAN: Integer

    CHARACTER_STRING: Integer

    EMBEDDED_PDV: Integer

    ENUMERATED: Integer

    EOC: Integer

    EXTERNAL: Integer

    GENERALIZEDTIME: Integer

    GENERALSTRING: Integer

    GRAPHICSTRING: Integer

    IA5STRING: Integer

    INTEGER: Integer

    ISO64STRING: Integer

    NULL: Integer

    NUMERICSTRING: Integer

    OBJECT: Integer

    OBJECT_DESCRIPTOR: Integer

    OCTET_STRING: Integer

    PRINTABLESTRING: Integer

    REAL: Integer

    RELATIVE_OID: Integer

    SEQUENCE: Integer

    SET: Integer

    T61STRING: Integer

    UNIVERSALSTRING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Array storing tag names at the tag's index.
    #
    UNIVERSAL_TAG_NAME: Array[untyped]

    UTCTIME: Integer

    UTF8STRING: Integer

    VIDEOTEXSTRING: Integer

    interface _ToDer
      def to_der: () -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The top-level class representing any ASN.1 object. When parsed by ASN1.decode,
    # tagged values are always represented by an instance of ASN1Data.
    #
    # ## The role of ASN1Data for parsing tagged values
    #
    # When encoding an ASN.1 type it is inherently clear what original type (e.g.
    # INTEGER, OCTET STRING etc.) this value has, regardless of its tagging. But
    # opposed to the time an ASN.1 type is to be encoded, when parsing them it is
    # not possible to deduce the "real type" of tagged values. This is why tagged
    # values are generally parsed into ASN1Data instances, but with a different
    # outcome for implicit and explicit tagging.
    #
    # ### Example of a parsed implicitly tagged value
    #
    # An implicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
    # *   *tag* equal to 1
    # *   *tag_class* equal to `:CONTEXT_SPECIFIC`
    # *   *value* equal to a String that carries the raw encoding of the INTEGER.
    # This implies that a subsequent decoding step is required to completely decode
    # implicitly tagged values.
    #
    # ### Example of a parsed explicitly tagged value
    #
    # An explicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
    # *   *tag* equal to 1
    # *   *tag_class* equal to `:CONTEXT_SPECIFIC`
    # *   *value* equal to an Array with one single element, an instance of
    #     OpenSSL::ASN1::Integer, i.e. the inner element is the non-tagged primitive
    #     value, and the tagging is represented in the outer ASN1Data
    #
    # ## Example - Decoding an implicitly tagged INTEGER
    #     int = OpenSSL::ASN1::Integer.new(1, 0, :IMPLICIT) # implicit 0-tagged
    #     seq = OpenSSL::ASN1::Sequence.new( [int] )
    #     der = seq.to_der
    #     asn1 = OpenSSL::ASN1.decode(der)
    #     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #     #              @indefinite_length=false,
    #     #              @tag=16,
    #     #              @tag_class=:UNIVERSAL,
    #     #              @tagging=nil,
    #     #              @value=
    #     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #     #                   @indefinite_length=false,
    #     #                   @tag=0,
    #     #                   @tag_class=:CONTEXT_SPECIFIC,
    #     #                   @value="\x01">]>
    #     raw_int = asn1.value[0]
    #     # manually rewrite tag and tag class to make it an UNIVERSAL value
    #     raw_int.tag = OpenSSL::ASN1::INTEGER
    #     raw_int.tag_class = :UNIVERSAL
    #     int2 = OpenSSL::ASN1.decode(raw_int)
    #     puts int2.value # => 1
    #
    # ## Example - Decoding an explicitly tagged INTEGER
    #     int = OpenSSL::ASN1::Integer.new(1, 0, :EXPLICIT) # explicit 0-tagged
    #     seq = OpenSSL::ASN1::Sequence.new( [int] )
    #     der = seq.to_der
    #     asn1 = OpenSSL::ASN1.decode(der)
    #     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #     #              @indefinite_length=false,
    #     #              @tag=16,
    #     #              @tag_class=:UNIVERSAL,
    #     #              @tagging=nil,
    #     #              @value=
    #     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #     #                   @indefinite_length=false,
    #     #                   @tag=0,
    #     #                   @tag_class=:CONTEXT_SPECIFIC,
    #     #                   @value=
    #     #                     [#<OpenSSL::ASN1::Integer:0x85bf308
    #     #                        @indefinite_length=false,
    #     #                        @tag=2,
    #     #                        @tag_class=:UNIVERSAL
    #     #                        @tagging=nil,
    #     #                        @value=1>]>]>
    #     int2 = asn1.value[0].value[0]
    #     puts int2.value # => 1
    #
    class ASN1Data
      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      def indefinite_length: () -> bool

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      def indefinite_length=: [U] (boolish) -> U

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      alias infinite_length indefinite_length

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      alias infinite_length= indefinite_length=

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # An Integer representing the tag number of this ASN1Data. Never `nil`.
      #
      def tag: () -> bn

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # An Integer representing the tag number of this ASN1Data. Never `nil`.
      #
      def tag=: (::Integer) -> ::Integer
              | (BN) -> BN

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # A Symbol representing the tag class of this ASN1Data. Never `nil`. See
      # ASN1Data for possible values.
      #
      def tag_class: () -> tag_class

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # A Symbol representing the tag class of this ASN1Data. Never `nil`. See
      # ASN1Data for possible values.
      #
      def tag_class=: (tag_class) -> tag_class

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # Encodes this ASN1Data into a DER-encoded String value. The result is
      # DER-encoded except for the possibility of indefinite length forms. Indefinite
      # length forms are not allowed in strict DER, so strictly speaking the result of
      # such an encoding would be a BER-encoding.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Carries the value of a ASN.1 type. Please confer Constructive and Primitive
      # for the mappings between ASN.1 data types and Ruby classes.
      #
      def value: () -> untyped

      # <!-- rdoc-file=ext/openssl/lib/openssl/asn1.rb -->
      # Carries the value of a ASN.1 type. Please confer Constructive and Primitive
      # for the mappings between ASN.1 data types and Ruby classes.
      #
      def value=: (untyped) -> untyped

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/asn1.rb
      #   - OpenSSL::ASN1::ASN1Data.new(value, tag, tag_class) => ASN1Data
      # -->
      # *value*: Please have a look at Constructive and Primitive to see how Ruby
      # types are mapped to ASN.1 types and vice versa.
      #
      # *tag*: An Integer indicating the tag number.
      #
      # *tag_class*: A Symbol indicating the tag class. Please cf. ASN1 for possible
      # values.
      #
      # ## Example
      #     asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # => Same as OpenSSL::ASN1::Integer.new(42)
      #     tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly 0-tagged INTEGER
      #
      def initialize: (untyped value, ::Integer tag, tag_class tag_class) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Generic error class for all errors raised in ASN1 and any of the classes
    # defined in it.
    #
    class ASN1Error < OpenSSL::OpenSSLError
    end

    class BMPString < OpenSSL::ASN1::Primitive
    end

    class BitString < OpenSSL::ASN1::Primitive
      def unused_bits: () -> ::Integer

      def unused_bits=: (::Integer) -> ::Integer

      def value: () -> String

      def value=: (String) -> String
    end

    class Boolean < OpenSSL::ASN1::Primitive
      def value: () -> bool

      def value=: [U] (boolish) -> U
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The parent class for all constructed encodings. The *value* attribute of a
    # Constructive is always an Array. Attributes are the same as for ASN1Data, with
    # the addition of *tagging*.
    #
    # ## SET and SEQUENCE
    #
    # Most constructed encodings come in the form of a SET or a SEQUENCE. These
    # encodings are represented by one of the two sub-classes of Constructive:
    # *   OpenSSL::ASN1::Set
    # *   OpenSSL::ASN1::Sequence
    # Please note that tagged sequences and sets are still parsed as instances of
    # ASN1Data. Find further details on tagged values there.
    #
    # ### Example - constructing a SEQUENCE
    #     int = OpenSSL::ASN1::Integer.new(1)
    #     str = OpenSSL::ASN1::PrintableString.new('abc')
    #     sequence = OpenSSL::ASN1::Sequence.new( [ int, str ] )
    #
    # ### Example - constructing a SET
    #     int = OpenSSL::ASN1::Integer.new(1)
    #     str = OpenSSL::ASN1::PrintableString.new('abc')
    #     set = OpenSSL::ASN1::Set.new( [ int, str ] )
    #
    class Constructive < OpenSSL::ASN1::ASN1Data
      include Enumerable[ASN1Data]

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/asn1.rb
      #   - asn1_ary.each { |asn1| block } => asn1_ary
      # -->
      # Calls the given block once for each element in self, passing that element as
      # parameter *asn1*. If no block is given, an enumerator is returned instead.
      #
      # ## Example
      #     asn1_ary.each do |asn1|
      #       puts asn1
      #     end
      #
      def each: () ?{ (ASN1Data) -> void } -> self

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging: () -> tagging?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging=: (tagging) -> tagging

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # See ASN1Data#to_der for details.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::Primitive.new(value [, tag, tagging, tag_class ]) => Primitive
      # -->
      # *value*: is mandatory.
      #
      # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
      # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
      #
      # *tagging*: may be used as an encoding hint to encode a value either explicitly
      # or implicitly, see ASN1 for possible values.
      #
      # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
      # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
      # used as the default. For possible values please cf. ASN1.
      #
      # ## Example
      #     int = OpenSSL::ASN1::Integer.new(42)
      #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
      #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
      #
      def initialize: (Array[ASN1Data]) -> void
    end

    class EndOfContent < OpenSSL::ASN1::ASN1Data
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/asn1.rb
      #   - new()
      # -->
      #
      def initialize: () -> void
    end

    class Enumerated < OpenSSL::ASN1::Primitive
      def value: () -> ::Integer

      def value=: (::Integer) -> ::Integer
    end

    class GeneralString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class GeneralizedTime < OpenSSL::ASN1::Primitive
      def value: () -> Time

      def value=: (Time) -> Time
    end

    class GraphicString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class IA5String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class ISO64String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class Integer < OpenSSL::ASN1::Primitive
      def value: () -> ::Integer

      def value=: (::Integer) -> ::Integer
    end

    class Null < OpenSSL::ASN1::Primitive
      def value: () -> nil

      def value=: (nil) -> nil
    end

    class NumericString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Represents the primitive object id for OpenSSL::ASN1
    #
    class ObjectId < OpenSSL::ASN1::Primitive
      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::ObjectId.register(object_id, short_name, long_name)
      # -->
      # This adds a new ObjectId to the internal tables. Where *object_id* is the
      # numerical form, *short_name* is the short name, and *long_name* is the long
      # name.
      #
      # Returns `true` if successful. Raises an OpenSSL::ASN1::ASN1Error if it fails.
      #
      def self.register: (String object_id, String short_name, String ong_name) -> bool

      def value: () -> String

      def value=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid == other_oid => true or false
      # -->
      # Returns `true` if *other_oid* is the same as *oid*.
      #
      def ==: (ObjectId other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.ln -> string
      #   - oid.long_name -> string
      # -->
      # The long name of the ObjectId, as defined in <openssl/objects.h>.
      #
      def ln: () -> String?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # The long name of the ObjectId, as defined in <openssl/objects.h>.
      #
      alias long_name ln

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.oid -> string
      # -->
      # Returns a String representing the Object Identifier in the dot notation, e.g.
      # "1.2.3.4.5"
      #
      def oid: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # The short name of the ObjectId, as defined in <openssl/objects.h>.
      #
      alias short_name sn

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.sn -> string
      #   - oid.short_name -> string
      # -->
      # The short name of the ObjectId, as defined in <openssl/objects.h>.
      #
      def sn: () -> String?
    end

    class OctetString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The parent class for all primitive encodings. Attributes are the same as for
    # ASN1Data, with the addition of *tagging*. Primitive values can never be
    # encoded with indefinite length form, thus it is not possible to set the
    # *indefinite_length* attribute for Primitive and its sub-classes.
    #
    # ## Primitive sub-classes and their mapping to Ruby classes
    # *   OpenSSL::ASN1::EndOfContent    <=> *value* is always `nil`
    # *   OpenSSL::ASN1::Boolean         <=> *value* is `true` or `false`
    # *   OpenSSL::ASN1::Integer         <=> *value* is an OpenSSL::BN
    # *   OpenSSL::ASN1::BitString       <=> *value* is a String
    # *   OpenSSL::ASN1::OctetString     <=> *value* is a String
    # *   OpenSSL::ASN1::Null            <=> *value* is always `nil`
    # *   OpenSSL::ASN1::Object          <=> *value* is a String
    # *   OpenSSL::ASN1::Enumerated      <=> *value* is an OpenSSL::BN
    # *   OpenSSL::ASN1::UTF8String      <=> *value* is a String
    # *   OpenSSL::ASN1::NumericString   <=> *value* is a String
    # *   OpenSSL::ASN1::PrintableString <=> *value* is a String
    # *   OpenSSL::ASN1::T61String       <=> *value* is a String
    # *   OpenSSL::ASN1::VideotexString  <=> *value* is a String
    # *   OpenSSL::ASN1::IA5String       <=> *value* is a String
    # *   OpenSSL::ASN1::UTCTime         <=> *value* is a Time
    # *   OpenSSL::ASN1::GeneralizedTime <=> *value* is a Time
    # *   OpenSSL::ASN1::GraphicString   <=> *value* is a String
    # *   OpenSSL::ASN1::ISO64String     <=> *value* is a String
    # *   OpenSSL::ASN1::GeneralString   <=> *value* is a String
    # *   OpenSSL::ASN1::UniversalString <=> *value* is a String
    # *   OpenSSL::ASN1::BMPString       <=> *value* is a String
    #
    # ## OpenSSL::ASN1::BitString
    #
    # ### Additional attributes
    # *unused_bits*: if the underlying BIT STRING's length is a multiple of 8 then
    # *unused_bits* is 0. Otherwise *unused_bits* indicates the number of bits that
    # are to be ignored in the final octet of the BitString's *value*.
    #
    # ## OpenSSL::ASN1::ObjectId
    #
    # NOTE: While OpenSSL::ASN1::ObjectId.new will allocate a new ObjectId, it is
    # not typically allocated this way, but rather that are received from parsed
    # ASN1 encodings.
    #
    # ### Additional attributes
    # *   *sn*: the short name as defined in <openssl/objects.h>.
    # *   *ln*: the long name as defined in <openssl/objects.h>.
    # *   *oid*: the object identifier as a String, e.g. "1.2.3.4.5"
    # *   *short_name*: alias for *sn*.
    # *   *long_name*: alias for *ln*.
    #
    # ## Examples
    # With the Exception of OpenSSL::ASN1::EndOfContent, each Primitive class
    # constructor takes at least one parameter, the *value*.
    #
    # ### Creating EndOfContent
    #     eoc = OpenSSL::ASN1::EndOfContent.new
    #
    # ### Creating any other Primitive
    #     prim = <class>.new(value) # <class> being one of the sub-classes except EndOfContent
    #     prim_zero_tagged_implicit = <class>.new(value, 0, :IMPLICIT)
    #     prim_zero_tagged_explicit = <class>.new(value, 0, :EXPLICIT)
    #
    class Primitive < OpenSSL::ASN1::ASN1Data
      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging: () -> tagging?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging=: (tagging) -> tagging

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # See ASN1Data#to_der for details.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::Primitive.new(value [, tag, tagging, tag_class ]) => Primitive
      # -->
      # *value*: is mandatory.
      #
      # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
      # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
      #
      # *tagging*: may be used as an encoding hint to encode a value either explicitly
      # or implicitly, see ASN1 for possible values.
      #
      # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
      # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
      # used as the default. For possible values please cf. ASN1.
      #
      # ## Example
      #     int = OpenSSL::ASN1::Integer.new(42)
      #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
      #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
      #
      def initialize: (untyped value, ?Integer tag, ?tagging tagging) -> void
    end

    class PrintableString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class Sequence < OpenSSL::ASN1::Constructive
      def value: () -> Array[ASN1Data]

      def value=: (Array[ASN1Data]) -> Array[ASN1Data]
    end

    class Set < OpenSSL::ASN1::Constructive
    end

    class T61String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class UTCTime < OpenSSL::ASN1::Primitive
      def value: () -> Time

      def value=: (Time) -> Time
    end

    class UTF8String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class UniversalString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class VideotexString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end
  end

  type bn = BN | ::Integer

  class BN
    include Comparable

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.generate_prime(bits, [, safe [, add [, rem]]]) => bn
    # -->
    # Generates a random prime number of bit length *bits*. If *safe* is set to
    # `true`, generates a safe prime. If *add* is specified, generates a prime that
    # fulfills condition `p % add = rem`.
    #
    # ### Parameters
    # *   *bits* - integer
    # *   *safe* - boolean
    # *   *add* - BN
    # *   *rem* - BN
    #
    def self.generate_prime: (::Integer bits, ?boolish safe, ?bn add, ?bn rem) -> instance

    def self.pseudo_rand: (*untyped) -> untyped

    def self.pseudo_rand_range: (untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.rand(bits [, fill [, odd]]) -> aBN
    # -->
    # Generates a cryptographically strong pseudo-random number of `bits`.
    #
    # See also the man page BN_rand(3).
    #
    def self.rand: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.rand_range(range) -> aBN
    # -->
    # Generates a cryptographically strong pseudo-random number in the range
    # 0...`range`.
    #
    # See also the man page BN_rand_range(3).
    #
    def self.rand_range: (untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn % bn2 => aBN
    # -->
    #
    def %: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn * bn2 => aBN
    # -->
    #
    def *: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn ** bn2 => aBN
    # -->
    #
    def **: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn + bn2 => aBN
    # -->
    #
    def +: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - +bn -> aBN
    # -->
    #
    def +@: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn - bn2 => aBN
    # -->
    #
    def -: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - -bn -> aBN
    # -->
    #
    def -@: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn1 / bn2 => [result, remainder]
    # -->
    # Division of OpenSSL::BN instances
    #
    def /: (int) -> [ instance, instance ]

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn << bits -> aBN
    # -->
    #
    def <<: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - <=>(p1)
    # -->
    #
    alias <=> cmp

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn == obj => true or false
    # -->
    # Returns `true` only if *obj* has the same value as *bn*. Contrast this with
    # OpenSSL::BN#eql?, which requires obj to be OpenSSL::BN.
    #
    def ==: (untyped) -> bool

    # <!-- rdoc-file=ext/openssl/ossl_bn.c -->
    # Returns `true` only if *obj* has the same value as *bn*. Contrast this with
    # OpenSSL::BN#eql?, which requires obj to be OpenSSL::BN.
    #
    alias === ==

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn >> bits -> aBN
    # -->
    #
    def >>: (int) -> int

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.bit_set?(bit) => true | false
    # -->
    # Tests bit *bit* in *bn* and returns `true` if set, `false` if not set.
    #
    def bit_set?: (int) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.clear_bit!(bit) -> self
    # -->
    #
    def clear_bit!: (int) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.cmp(bn2) => integer
    # -->
    #
    def cmp: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - coerce(p1)
    # -->
    #
    def coerce: (::Integer) -> Array[Integer]
              | (BN) -> Array[BN]

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - copy(p1)
    # -->
    #
    def copy: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.eql?(obj) => true or false
    # -->
    # Returns `true` only if *obj* is a `OpenSSL::BN` with the same value as *bn*.
    # Contrast this with OpenSSL::BN#==, which performs type conversions.
    #
    def eql?: (untyped other) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.gcd(bn2) => aBN
    # -->
    #
    def gcd: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.hash => Integer
    # -->
    # Returns a hash code for this object.
    #
    # See also Object#hash.
    #
    def hash: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.lshift!(bits) -> self
    # -->
    #
    def lshift!: (int bits) -> self

    def mask_bits!: (int) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_add(bn1, bn2) -> aBN
    # -->
    #
    def mod_add: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_exp(bn1, bn2) -> aBN
    # -->
    #
    def mod_exp: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_inverse(bn2) => aBN
    # -->
    #
    def mod_inverse: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_mul(bn1, bn2) -> aBN
    # -->
    #
    def mod_mul: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_sqr(bn2) => aBN
    # -->
    #
    def mod_sqr: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_sub(bn1, bn2) -> aBN
    # -->
    #
    def mod_sub: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.negative? => true | false
    # -->
    #
    def negative?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.num_bits => integer
    # -->
    #
    def num_bits: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.num_bytes => integer
    # -->
    #
    def num_bytes: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.odd? => true | false
    # -->
    #
    def odd?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.one? => true | false
    # -->
    #
    def one?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/bn.rb
    #   - pretty_print(q)
    # -->
    #
    def pretty_print: (untyped q) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.prime? => true | false
    #   - bn.prime?(checks) => true | false
    # -->
    # Performs a Miller-Rabin probabilistic primality test for `bn`.
    #
    # **`checks` parameter is deprecated in version 3.0.** It has no effect.
    #
    def prime?: (?int checks) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.prime_fasttest? => true | false
    #   - bn.prime_fasttest?(checks) => true | false
    #   - bn.prime_fasttest?(checks, trial_div) => true | false
    # -->
    # Performs a Miller-Rabin probabilistic primality test for `bn`.
    #
    # **Deprecated in version 3.0.** Use #prime? instead.
    #
    # `checks` and `trial_div` parameters no longer have any effect.
    #
    def prime_fasttest?: (?int checks, ?int trial_div) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.rshift!(bits) -> self
    # -->
    #
    def rshift!: (int bits) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.set_bit!(bit) -> self
    # -->
    #
    def set_bit!: (int bit) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.sqr => aBN
    # -->
    #
    def sqr: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - to_bn()
    # -->
    #
    def to_bn: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.to_i => integer
    # -->
    #
    def to_i: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - to_int()
    # -->
    #
    alias to_int to_i

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.to_s(base = 10) -> string
    # -->
    # Returns the string representation of the bignum.
    #
    # BN.new can parse the encoded string to convert back into an OpenSSL::BN.
    #
    # `base`
    # :   The format. Must be one of the following:
    #     *   `0`  - MPI format. See the man page BN_bn2mpi(3) for details.
    #     *   `2`  - Variable-length and big-endian binary encoding. The sign of the
    #         bignum is ignored.
    #     *   `10` - Decimal number representation, with a leading '-' for a
    #         negative bignum.
    #     *   `16` - Hexadecimal number representation, with a leading '-' for a
    #         negative bignum.
    #
    def to_s: () -> String
            | (0) -> String
            | (2) -> String
            | (10) -> String
            | (16) -> String
            | (int base) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.ucmp(bn2) => integer
    # -->
    #
    def ucmp: (int bn2) -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.zero? => true | false
    # -->
    #
    def zero?: () -> bool

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - OpenSSL::BN.new(bn) -> aBN
    #   - OpenSSL::BN.new(integer) -> aBN
    #   - OpenSSL::BN.new(string, base = 10) -> aBN
    # -->
    # Construct a new OpenSSL BIGNUM object.
    #
    # If `bn` is an Integer or OpenSSL::BN, a new instance of OpenSSL::BN
    # representing the same value is returned. See also Integer#to_bn for the
    # short-hand.
    #
    # If a String is given, the content will be parsed according to `base`.
    #
    # `string`
    # :   The string to be parsed.
    #
    # `base`
    # :   The format. Must be one of the following:
    #     *   `0`  - MPI format. See the man page BN_mpi2bn(3) for details.
    #     *   `2`  - Variable-length and big-endian binary encoding of a positive
    #         number.
    #     *   `10` - Decimal number representation, with a leading '-' for a
    #         negative number.
    #     *   `16` - Hexadecimal number representation, with a leading '-' for a
    #         negative number.
    #
    def initialize: (instance) -> void
                  | (int) -> void
                  | (string) -> void
                  | (string, 0 | 2 | 10 | 16) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance other) -> instance
  end

  # <!-- rdoc-file=ext/openssl/ossl_bn.c -->
  # Generic Error for all of OpenSSL::BN (big num)
  #
  class BNError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
  # OpenSSL IO buffering mix-in module.
  #
  # This module allows an OpenSSL::SSL::SSLSocket to behave like an IO.
  #
  # You typically won't use this module directly, you can see it implemented in
  # OpenSSL::SSL::SSLSocket.
  #
  module Buffering
    include Enumerable[untyped]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - <<(s)
    # -->
    # Writes *s* to the stream.  *s* will be converted to a String using `.to_s`
    # method.
    #
    def <<: (String s) -> self

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - close()
    # -->
    # Closes the SSLSocket and flushes any unwritten data.
    #
    def close: () -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each(eol=$/) { |line| ... }
    # -->
    # Executes the block for every line in the stream where lines are separated by
    # *eol*.
    #
    # See also #gets
    #
    def each: (?String eol) ?{ (String) -> void } -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each_byte() { |byte| ... }
    # -->
    # Calls the given block once for each byte in the stream.
    #
    def each_byte: () ?{ (Integer) -> void } -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each_line(eol=$/)
    # -->
    #
    alias each_line each

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - eof()
    # -->
    #
    alias eof eof?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - eof?()
    # -->
    # Returns true if the stream is at file which means there is no more data to be
    # read.
    #
    def eof?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - flush()
    # -->
    # Flushes buffered data to the SSLSocket.
    #
    def flush: () -> self

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - getc()
    # -->
    # Reads one character from the stream.  Returns nil if called at end of file.
    #
    def getc: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - gets(eol=$/, limit=nil, chomp: false)
    # -->
    # Reads the next "line" from the stream.  Lines are separated by *eol*.  If
    # *limit* is provided the result will not be longer than the given number of
    # bytes.
    #
    # *eol* may be a String or Regexp.
    #
    # Unlike IO#gets the line read will not be assigned to +$_+.
    #
    # Unlike IO#gets the separator must be provided if a limit is provided.
    #
    def gets: (?String | Regexp eol, ?Integer limit) -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - print(*args)
    # -->
    # Writes *args* to the stream.
    #
    # See IO#print for full details.
    #
    def print: (*untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - printf(s, *args)
    # -->
    # Formats and writes to the stream converting parameters under control of the
    # format string.
    #
    # See Kernel#sprintf for format string details.
    #
    def printf: (String format_string, *untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - puts(*args)
    # -->
    # Writes *args* to the stream along with a record separator.
    #
    # See IO#puts for full details.
    #
    def puts: (*untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - read(size=nil, buf=nil)
    # -->
    # Reads *size* bytes from the stream.  If *buf* is provided it must reference a
    # string which will receive the data.
    #
    # See IO#read for full details.
    #
    def read: (?Integer? size, ?String buf) -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - read_nonblock(maxlen, buf=nil, exception: true)
    # -->
    # Reads at most *maxlen* bytes in the non-blocking manner.
    #
    # When no data can be read without blocking it raises OpenSSL::SSL::SSLError
    # extended by IO::WaitReadable or IO::WaitWritable.
    #
    # IO::WaitReadable means SSL needs to read internally so read_nonblock should be
    # called again when the underlying IO is readable.
    #
    # IO::WaitWritable means SSL needs to write internally so read_nonblock should
    # be called again after the underlying IO is writable.
    #
    # OpenSSL::Buffering#read_nonblock needs two rescue clause as follows:
    #
    #     # emulates blocking read (readpartial).
    #     begin
    #       result = ssl.read_nonblock(maxlen)
    #     rescue IO::WaitReadable
    #       IO.select([io])
    #       retry
    #     rescue IO::WaitWritable
    #       IO.select(nil, [io])
    #       retry
    #     end
    #
    # Note that one reason that read_nonblock writes to the underlying IO is when
    # the peer requests a new TLS/SSL handshake.  See openssl the FAQ for more
    # details.  http://www.openssl.org/support/faq.html
    #
    # By specifying a keyword argument *exception* to `false`, you can indicate that
    # read_nonblock should not raise an IO::Wait*able exception, but return the
    # symbol `:wait_writable` or `:wait_readable` instead. At EOF, it will return
    # `nil` instead of raising EOFError.
    #
    def read_nonblock: (Integer maxlen, ?String buf, ?exception: true) -> String
                     | (Integer maxlen, ?String buf, exception: false) -> (String | :wait_writable | :wait_readable | nil)

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readchar()
    # -->
    # Reads a one-character string from the stream.  Raises an EOFError at end of
    # file.
    #
    def readchar: () -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readline(eol=$/)
    # -->
    # Reads a line from the stream which is separated by *eol*.
    #
    # Raises EOFError if at end of file.
    #
    def readline: (?String eol) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readlines(eol=$/)
    # -->
    # Reads lines from the stream which are separated by *eol*.
    #
    # See also #gets
    #
    def readlines: (?String eol) -> ::Array[String]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readpartial(maxlen, buf=nil)
    # -->
    # Reads at most *maxlen* bytes from the stream.  If *buf* is provided it must
    # reference a string which will receive the data.
    #
    # See IO#readpartial for full details.
    #
    def readpartial: (Integer maxlen, ?String buf) -> String

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # The "sync mode" of the SSLSocket.
    #
    # See IO#sync for full details.
    #
    def sync: () -> bool

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # The "sync mode" of the SSLSocket.
    #
    # See IO#sync for full details.
    #
    def sync=: (boolish) -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - ungetc(c)
    # -->
    # Pushes character *c* back onto the stream such that a subsequent buffered
    # character read will return it.
    #
    # Unlike IO#getc multiple bytes may be pushed back onto the stream.
    #
    # Has no effect on unbuffered reads (such as #sysread).
    #
    def ungetc: (String c) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - write(*s)
    # -->
    # Writes *s* to the stream.  If the argument is not a String it will be
    # converted using `.to_s` method.  Returns the number of bytes written.
    #
    def write: (*_ToS s) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - write_nonblock(s, exception: true)
    # -->
    # Writes *s* in the non-blocking manner.
    #
    # If there is buffered data, it is flushed first.  This may block.
    #
    # write_nonblock returns number of bytes written to the SSL connection.
    #
    # When no data can be written without blocking it raises OpenSSL::SSL::SSLError
    # extended by IO::WaitReadable or IO::WaitWritable.
    #
    # IO::WaitReadable means SSL needs to read internally so write_nonblock should
    # be called again after the underlying IO is readable.
    #
    # IO::WaitWritable means SSL needs to write internally so write_nonblock should
    # be called again after underlying IO is writable.
    #
    # So OpenSSL::Buffering#write_nonblock needs two rescue clause as follows.
    #
    #     # emulates blocking write.
    #     begin
    #       result = ssl.write_nonblock(str)
    #     rescue IO::WaitReadable
    #       IO.select([io])
    #       retry
    #     rescue IO::WaitWritable
    #       IO.select(nil, [io])
    #       retry
    #     end
    #
    # Note that one reason that write_nonblock reads from the underlying IO is when
    # the peer requests a new TLS/SSL handshake.  See the openssl FAQ for more
    # details.  http://www.openssl.org/support/faq.html
    #
    # By specifying a keyword argument *exception* to `false`, you can indicate that
    # write_nonblock should not raise an IO::Wait*able exception, but return the
    # symbol `:wait_writable` or `:wait_readable` instead.
    #
    def write_nonblock: (_ToS s, ?exception: true) -> Integer
                      | (_ToS s, exception: false) -> (Integer | :wait_writable | :wait_readable | nil)

    private

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - consume_rbuff(size=nil)
    # -->
    # Consumes *size* bytes from the buffer
    #
    def consume_rbuff: (?untyped size) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - do_write(s)
    # -->
    # Writes *s* to the buffer.  When the buffer is full or #sync is true the buffer
    # is flushed to the underlying socket.
    #
    def do_write: (untyped s) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - fill_rbuff()
    # -->
    # Fills the buffer from the underlying SSLSocket
    #
    def fill_rbuff: () -> untyped

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # Default size to read from or write to the SSLSocket for buffer operations.
    #
    BLOCK_SIZE: Integer

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # A buffer which will retain binary encoding.
    #
    class Buffer < String
      BINARY: Encoding

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
      #   - <<(string)
      # -->
      #
      def <<: (String string) -> self

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
      #   - concat(string)
      # -->
      #
      alias concat <<
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_cipher.c -->
  # Provides symmetric algorithms for encryption and decryption. The algorithms
  # that are available depend on the particular version of OpenSSL that is
  # installed.
  #
  # ### Listing all supported algorithms
  #
  # A list of supported algorithms can be obtained by
  #
  #     puts OpenSSL::Cipher.ciphers
  #
  # ### Instantiating a Cipher
  #
  # There are several ways to create a Cipher instance. Generally, a Cipher
  # algorithm is categorized by its name, the key length in bits and the cipher
  # mode to be used. The most generic way to create a Cipher is the following
  #
  #     cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')
  #
  # That is, a string consisting of the hyphenated concatenation of the individual
  # components name, key length and mode. Either all uppercase or all lowercase
  # strings may be used, for example:
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-cbc')
  #
  # ### Choosing either encryption or decryption mode
  #
  # Encryption and decryption are often very similar operations for symmetric
  # algorithms, this is reflected by not having to choose different classes for
  # either operation, both can be done using the same class. Still, after
  # obtaining a Cipher instance, we need to tell the instance what it is that we
  # intend to do with it, so we need to call either
  #
  #     cipher.encrypt
  #
  # or
  #
  #     cipher.decrypt
  #
  # on the Cipher instance. This should be the first call after creating the
  # instance, otherwise configuration that has already been set could get lost in
  # the process.
  #
  # ### Choosing a key
  #
  # Symmetric encryption requires a key that is the same for the encrypting and
  # for the decrypting party and after initial key establishment should be kept as
  # private information. There are a lot of ways to create insecure keys, the most
  # notable is to simply take a password as the key without processing the
  # password further. A simple and secure way to create a key for a particular
  # Cipher is
  #
  #     cipher = OpenSSL::Cipher.new('aes-256-cfb')
  #     cipher.encrypt
  #     key = cipher.random_key # also sets the generated key on the Cipher
  #
  # If you absolutely need to use passwords as encryption keys, you should use
  # Password-Based Key Derivation Function 2 (PBKDF2) by generating the key with
  # the help of the functionality provided by OpenSSL::PKCS5.pbkdf2_hmac_sha1 or
  # OpenSSL::PKCS5.pbkdf2_hmac.
  #
  # Although there is Cipher#pkcs5_keyivgen, its use is deprecated and it should
  # only be used in legacy applications because it does not use the newer PKCS#5
  # v2 algorithms.
  #
  # ### Choosing an IV
  #
  # The cipher modes CBC, CFB, OFB and CTR all need an "initialization vector", or
  # short, IV. ECB mode is the only mode that does not require an IV, but there is
  # almost no legitimate use case for this mode because of the fact that it does
  # not sufficiently hide plaintext patterns. Therefore
  #
  # **You should never use ECB mode unless you are absolutely sure that you
  # absolutely need it**
  #
  # Because of this, you will end up with a mode that explicitly requires an IV in
  # any case. Although the IV can be seen as public information, i.e. it may be
  # transmitted in public once generated, it should still stay unpredictable to
  # prevent certain kinds of attacks. Therefore, ideally
  #
  # **Always create a secure random IV for every encryption of your Cipher**
  #
  # A new, random IV should be created for every encryption of data. Think of the
  # IV as a nonce (number used once) - it's public but random and unpredictable. A
  # secure random IV can be created as follows
  #
  #     cipher = ...
  #     cipher.encrypt
  #     key = cipher.random_key
  #     iv = cipher.random_iv # also sets the generated IV on the Cipher
  #
  # Although the key is generally a random value, too, it is a bad choice as an
  # IV. There are elaborate ways how an attacker can take advantage of such an IV.
  # As a general rule of thumb, exposing the key directly or indirectly should be
  # avoided at all cost and exceptions only be made with good reason.
  #
  # ### Calling Cipher#final
  #
  # ECB (which should not be used) and CBC are both block-based modes. This means
  # that unlike for the other streaming-based modes, they operate on fixed-size
  # blocks of data, and therefore they require a "finalization" step to produce or
  # correctly decrypt the last block of data by appropriately handling some form
  # of padding. Therefore it is essential to add the output of
  # OpenSSL::Cipher#final to your encryption/decryption buffer or you will end up
  # with decryption errors or truncated data.
  #
  # Although this is not really necessary for streaming-mode ciphers, it is still
  # recommended to apply the same pattern of adding the output of Cipher#final
  # there as well - it also enables you to switch between modes more easily in the
  # future.
  #
  # ### Encrypting and decrypting some data
  #
  #     data = "Very, very confidential data"
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-cbc')
  #     cipher.encrypt
  #     key = cipher.random_key
  #     iv = cipher.random_iv
  #
  #     encrypted = cipher.update(data) + cipher.final
  #     ...
  #     decipher = OpenSSL::Cipher.new('aes-128-cbc')
  #     decipher.decrypt
  #     decipher.key = key
  #     decipher.iv = iv
  #
  #     plain = decipher.update(encrypted) + decipher.final
  #
  #     puts data == plain #=> true
  #
  # ### Authenticated Encryption and Associated Data (AEAD)
  #
  # If the OpenSSL version used supports it, an Authenticated Encryption mode
  # (such as GCM or CCM) should always be preferred over any unauthenticated mode.
  # Currently, OpenSSL supports AE only in combination with Associated Data (AEAD)
  # where additional associated data is included in the encryption process to
  # compute a tag at the end of the encryption. This tag will also be used in the
  # decryption process and by verifying its validity, the authenticity of a given
  # ciphertext is established.
  #
  # This is superior to unauthenticated modes in that it allows to detect if
  # somebody effectively changed the ciphertext after it had been encrypted. This
  # prevents malicious modifications of the ciphertext that could otherwise be
  # exploited to modify ciphertexts in ways beneficial to potential attackers.
  #
  # An associated data is used where there is additional information, such as
  # headers or some metadata, that must be also authenticated but not necessarily
  # need to be encrypted. If no associated data is needed for encryption and later
  # decryption, the OpenSSL library still requires a value to be set - "" may be
  # used in case none is available.
  #
  # An example using the GCM (Galois/Counter Mode). You have 16 bytes *key*, 12
  # bytes (96 bits) *nonce* and the associated data *auth_data*. Be sure not to
  # reuse the *key* and *nonce* pair. Reusing an nonce ruins the security
  # guarantees of GCM mode.
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-gcm').encrypt
  #     cipher.key = key
  #     cipher.iv = nonce
  #     cipher.auth_data = auth_data
  #
  #     encrypted = cipher.update(data) + cipher.final
  #     tag = cipher.auth_tag # produces 16 bytes tag by default
  #
  # Now you are the receiver. You know the *key* and have received *nonce*,
  # *auth_data*, *encrypted* and *tag* through an untrusted network. Note that GCM
  # accepts an arbitrary length tag between 1 and 16 bytes. You may additionally
  # need to check that the received tag has the correct length, or you allow
  # attackers to forge a valid single byte tag for the tampered ciphertext with a
  # probability of 1/256.
  #
  #     raise "tag is truncated!" unless tag.bytesize == 16
  #     decipher = OpenSSL::Cipher.new('aes-128-gcm').decrypt
  #     decipher.key = key
  #     decipher.iv = nonce
  #     decipher.auth_tag = tag
  #     decipher.auth_data = auth_data
  #
  #     decrypted = decipher.update(encrypted) + decipher.final
  #
  #     puts data == decrypted #=> true
  #
  class Cipher
    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - OpenSSL::Cipher.ciphers -> array[string...]
    # -->
    # Returns the names of all available ciphers in an array.
    #
    def self.ciphers: () -> Array[String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_data = string -> string
    # -->
    # Sets the cipher's additional authenticated data. This field must be set when
    # using AEAD cipher modes such as GCM or CCM. If no associated data shall be
    # used, this method must **still** be called with a value of "". The contents of
    # this field should be non-sensitive data which will be added to the ciphertext
    # to generate the authentication tag which validates the contents of the
    # ciphertext.
    #
    # The AAD must be set prior to encryption or decryption. In encryption mode, it
    # must be set after calling Cipher#encrypt and setting Cipher#key= and
    # Cipher#iv=. When decrypting, the authenticated data must be set after key, iv
    # and especially **after** the authentication tag has been set. I.e. set it only
    # after calling Cipher#decrypt, Cipher#key=, Cipher#iv= and Cipher#auth_tag=
    # first.
    #
    def auth_data=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag(tag_len = 16) -> String
    # -->
    # Gets the authentication tag generated by Authenticated Encryption Cipher modes
    # (GCM for example). This tag may be stored along with the ciphertext, then set
    # on the decryption cipher to authenticate the contents of the ciphertext
    # against changes. If the optional integer parameter *tag_len* is given, the
    # returned tag will be *tag_len* bytes long. If the parameter is omitted, the
    # default length of 16 bytes or the length previously set by #auth_tag_len= will
    # be used. For maximum security, the longest possible should be chosen.
    #
    # The tag may only be retrieved after calling Cipher#final.
    #
    def auth_tag: (?Integer tag_len) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag = string -> string
    # -->
    # Sets the authentication tag to verify the integrity of the ciphertext. This
    # can be called only when the cipher supports AE. The tag must be set after
    # calling Cipher#decrypt, Cipher#key= and Cipher#iv=, but before calling
    # Cipher#final. After all decryption is performed, the tag is verified
    # automatically in the call to Cipher#final.
    #
    # For OCB mode, the tag length must be supplied with #auth_tag_len= beforehand.
    #
    def auth_tag=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag_len = Integer -> Integer
    # -->
    # Sets the length of the authentication tag to be generated or to be given for
    # AEAD ciphers that requires it as in input parameter. Note that not all AEAD
    # ciphers support this method.
    #
    # In OCB mode, the length must be supplied both when encrypting and when
    # decrypting, and must be before specifying an IV.
    #
    def auth_tag_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.authenticated? -> true | false
    # -->
    # Indicated whether this Cipher instance uses an Authenticated Encryption mode.
    #
    def authenticated?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.block_size -> integer
    # -->
    # Returns the size in bytes of the blocks on which this Cipher operates on.
    #
    def block_size: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.decrypt -> self
    # -->
    # Initializes the Cipher for decryption.
    #
    # Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
    # following methods:
    #
    #     #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
    # :
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).
    #
    def decrypt: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.encrypt -> self
    # -->
    # Initializes the Cipher for encryption.
    #
    # Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
    # following methods:
    #
    #     #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
    # :
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).
    #
    def encrypt: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.final -> string
    # -->
    # Returns the remaining data held in the cipher object. Further calls to
    # Cipher#update or Cipher#final will return garbage. This call should always be
    # made as the last call of an encryption or decryption operation, after having
    # fed the entire plaintext or ciphertext to the Cipher instance.
    #
    # If an authenticated cipher was used, a CipherError is raised if the tag could
    # not be authenticated successfully. Only call this method after setting the
    # authentication tag and passing the entire contents of the ciphertext into the
    # cipher.
    #
    def final: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv = string -> string
    # -->
    # Sets the cipher IV. Please note that since you should never be using ECB mode,
    # an IV is always explicitly required and should be set prior to encryption. The
    # IV itself can be safely transmitted in public, but it should be unpredictable
    # to prevent certain kinds of attacks. You may use Cipher#random_iv to create a
    # secure random IV.
    #
    # Only call this method after calling Cipher#encrypt or Cipher#decrypt.
    #
    def iv=: (String iv) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv_len -> integer
    # -->
    # Returns the expected length in bytes for an IV for this Cipher.
    #
    def iv_len: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv_len = integer -> integer
    # -->
    # Sets the IV/nonce length of the Cipher. Normally block ciphers don't allow
    # changing the IV length, but some make use of IV for 'nonce'. You may need this
    # for interoperability with other applications.
    #
    def iv_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key = string -> string
    # -->
    # Sets the cipher key. To generate a key, you should either use a secure random
    # byte string or, if the key is to be derived from a password, you should rely
    # on PBKDF2 functionality provided by OpenSSL::PKCS5. To generate a secure
    # random-based key, Cipher#random_key may be used.
    #
    # Only call this method after calling Cipher#encrypt or Cipher#decrypt.
    #
    def key=: (String key) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key_len -> integer
    # -->
    # Returns the key length in bytes of the Cipher.
    #
    def key_len: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key_len = integer -> integer
    # -->
    # Sets the key length of the cipher.  If the cipher is a fixed length cipher
    # then attempting to set the key length to any value other than the fixed value
    # is an error.
    #
    # Under normal circumstances you do not need to call this method (and probably
    # shouldn't).
    #
    # See EVP_CIPHER_CTX_set_key_length for further information.
    #
    def key_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.name -> string
    # -->
    # Returns the short name of the cipher which may differ slightly from the
    # original name provided.
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.padding = integer -> integer
    # -->
    # Enables or disables padding. By default encryption operations are padded using
    # standard block padding and the padding is checked and removed when decrypting.
    # If the pad parameter is zero then no padding is performed, the total amount of
    # data encrypted or decrypted must then be a multiple of the block size or an
    # error will occur.
    #
    # See EVP_CIPHER_CTX_set_padding for further information.
    #
    def padding=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.pkcs5_keyivgen(pass, salt = nil, iterations = 2048, digest = "MD5") -> nil
    # -->
    # Generates and sets the key/IV based on a password.
    #
    # **WARNING**: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,
    # or DES with MD5 or SHA1. Using anything else (like AES) will generate the
    # key/iv using an OpenSSL specific method. This method is deprecated and should
    # no longer be used. Use a PKCS5 v2 key generation method from OpenSSL::PKCS5
    # instead.
    #
    # ### Parameters
    # *   *salt* must be an 8 byte string if provided.
    # *   *iterations* is an integer with a default of 2048.
    # *   *digest* is a Digest object that defaults to 'MD5'
    #
    # A minimum of 1000 iterations is recommended.
    #
    def pkcs5_keyivgen: (String pass, ?String salt, ?Integer iterations, ?String digest) -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/cipher.rb
    #   - cipher.random_iv -> iv
    # -->
    # Generate a random IV with OpenSSL::Random.random_bytes and sets it to the
    # cipher, and returns it.
    #
    # You must call #encrypt or #decrypt before calling this method.
    #
    def random_iv: () -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/cipher.rb
    #   - cipher.random_key -> key
    # -->
    # Generate a random key with OpenSSL::Random.random_bytes and sets it to the
    # cipher, and returns it.
    #
    # You must call #encrypt or #decrypt before calling this method.
    #
    def random_key: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.reset -> self
    # -->
    # Fully resets the internal state of the Cipher. By using this, the same Cipher
    # instance may be used several times for encryption or decryption tasks.
    #
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).
    #
    def reset: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.update(data [, buffer]) -> string or buffer
    # -->
    # Encrypts data in a streaming fashion. Hand consecutive blocks of data to the
    # #update method in order to encrypt it. Returns the encrypted data chunk. When
    # done, the output of Cipher#final should be additionally added to the result.
    #
    # If *buffer* is given, the encryption/decryption result will be written to it.
    # *buffer* will be resized automatically.
    #
    def update: (String data, ?String buffer) -> String

    private

    def ciphers: () -> Array[String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - Cipher.new(string) -> cipher
    # -->
    # The string must contain a valid cipher name like "aes-256-cbc".
    #
    # A list of cipher names is available by calling OpenSSL::Cipher.ciphers.
    #
    def initialize: (String cipher_name) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (untyped) -> untyped

    class AES < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class AES128 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class AES192 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class AES256 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class BF < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class CAST5 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    # <!-- rdoc-file=ext/openssl/lib/openssl/cipher.rb -->
    # Deprecated.
    #
    # This class is only provided for backwards compatibility. Use OpenSSL::Cipher.
    #
    class Cipher < OpenSSL::Cipher
    end

    class CipherError < OpenSSL::OpenSSLError
    end

    class DES < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class IDEA < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC2 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC4 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC5 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_config.c -->
  # Configuration for the openssl library.
  #
  # Many system's installation of openssl library will depend on your system
  # configuration. See the value of OpenSSL::Config::DEFAULT_CONFIG_FILE for the
  # location of the file for your host.
  #
  # See also http://www.openssl.org/docs/apps/config.html
  #
  class Config
    include Enumerable[[ String, String, String ]]

    def self.load: (?_ToS filename) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.parse(string) -> OpenSSL::Config
    # -->
    # Parses a given *string* as a blob that contains configuration for OpenSSL.
    #
    def self.parse: (String string) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.parse_config(io) -> hash
    # -->
    # Parses the configuration data read from *io* and returns the whole content as
    # a Hash.
    #
    def self.parse_config: (IO io) -> Hash[String, Hash[String, String]]

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config[section] -> hash
    # -->
    # Gets all key-value pairs in a specific *section* from the current
    # configuration.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can get a hash of the specific section like so:
    #
    #     config['default']
    #       #=> {"foo"=>"bar"}
    #
    def []: (String section) -> Hash[String, String]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/config.rb
    #   - []=(section, pairs)
    # -->
    # *Deprecated in v2.2.0*. This method will be removed in a future release.
    #
    # Sets a specific *section* name with a Hash *pairs*.
    #
    # Given the following configuration being created:
    #
    #     config = OpenSSL::Config.new
    #       #=> #<OpenSSL::Config sections=[]>
    #     config['default'] = {"foo"=>"bar","baz"=>"buz"}
    #       #=> {"foo"=>"bar", "baz"=>"buz"}
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #       #   baz=buz
    #
    # It's important to note that this will essentially merge any of the keys in
    # *pairs* with the existing *section*. For example:
    #
    #     config['default']
    #       #=> {"foo"=>"bar", "baz"=>"buz"}
    #     config['default'] = {"foo" => "changed"}
    #       #=> {"foo"=>"changed"}
    #     config['default']
    #       #=> {"foo"=>"changed", "baz"=>"buz"}
    #
    def []=: (String section, _Each[[ String, String ]] pairs) -> _Each[[ String, String ]]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/config.rb
    #   - add_value(section, key, value)
    # -->
    # *Deprecated in v2.2.0*. This method will be removed in a future release.
    #
    # Set the target *key* with a given *value* under a specific *section*.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can set the value of *foo* under the *default* section to a new value:
    #
    #     config.add_value('default', 'foo', 'buzz')
    #       #=> "buzz"
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=buzz
    #
    def add_value: (String section, untyped key, untyped value) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.each { |section, key, value| }
    # -->
    # Retrieves the section and its pairs for the current configuration.
    #
    #     config.each do |section, key, value|
    #       # ...
    #     end
    #
    def each: () { ([ String, String, String ] args0) -> void } -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.get_value(section, key) -> string
    # -->
    # Gets the value of *key* from the given *section*.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can get a specific value from the config if you know the *section* and
    # *key* like so:
    #
    #     config.get_value('default','foo')
    #       #=> "bar"
    #
    def get_value: (String section, String key) -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.inspect -> string
    # -->
    # String representation of this configuration object, including the class name
    # and its sections.
    #
    def inspect: () -> String

    def section: (String name) -> Hash[String, String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.sections -> array of string
    # -->
    # Get the names of all sections in the current configuration.
    #
    def sections: () -> Array[String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.to_s -> string
    # -->
    # Gets the parsable form of the current configuration.
    #
    # Given the following configuration file being loaded:
    #
    #     config = OpenSSL::Config.load('baz.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #       #   baz=buz
    #
    # You can get the serialized configuration using #to_s and then parse it later:
    #
    #     serialized_config = config.to_s
    #     # much later...
    #     new_config = OpenSSL::Config.parse(serialized_config)
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts new_config
    #       #=> [ default ]
    #           foo=bar
    #           baz=buz
    #
    def to_s: () -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.new(filename) -> OpenSSL::Config
    # -->
    # Creates an instance of OpenSSL::Config from the content of the file specified
    # by *filename*.
    #
    # This can be used in contexts like OpenSSL::X509::ExtensionFactory.config=
    #
    # This can raise IO exceptions based on the access, or availability of the file.
    # A ConfigError exception may be raised depending on the validity of the data
    # being configured.
    #
    def initialize: (?_ToS filename) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance other) -> void

    # <!-- rdoc-file=ext/openssl/ossl_config.c -->
    # The default system configuration file for OpenSSL.
    #
    DEFAULT_CONFIG_FILE: String
  end

  # <!-- rdoc-file=ext/openssl/ossl_config.c -->
  # General error for openssl library configuration files. Including formatting,
  # parsing errors, etc.
  #
  class ConfigError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
  # OpenSSL::Digest allows you to compute message digests (sometimes
  # interchangeably called "hashes") of arbitrary data that are cryptographically
  # secure, i.e. a Digest implements a secure one-way function.
  #
  # One-way functions offer some useful properties. E.g. given two distinct inputs
  # the probability that both yield the same output is highly unlikely. Combined
  # with the fact that every message digest algorithm has a fixed-length output of
  # just a few bytes, digests are often used to create unique identifiers for
  # arbitrary data. A common example is the creation of a unique id for binary
  # documents that are stored in a database.
  #
  # Another useful characteristic of one-way functions (and thus the name) is that
  # given a digest there is no indication about the original data that produced
  # it, i.e. the only way to identify the original input is to "brute-force"
  # through every possible combination of inputs.
  #
  # These characteristics make one-way functions also ideal companions for public
  # key signature algorithms: instead of signing an entire document, first a hash
  # of the document is produced with a considerably faster message digest
  # algorithm and only the few bytes of its output need to be signed using the
  # slower public key algorithm. To validate the integrity of a signed document,
  # it suffices to re-compute the hash and verify that it is equal to that in the
  # signature.
  #
  # You can get a list of all digest algorithms supported on your system by
  # running this command in your terminal:
  #
  #     openssl list -digest-algorithms
  #
  # Among the OpenSSL 1.1.1 supported message digest algorithms are:
  # *   SHA224, SHA256, SHA384, SHA512, SHA512-224 and SHA512-256
  # *   SHA3-224, SHA3-256, SHA3-384 and SHA3-512
  # *   BLAKE2s256 and BLAKE2b512
  #
  # Each of these algorithms can be instantiated using the name:
  #
  #     digest = OpenSSL::Digest.new('SHA256')
  #
  # "Breaking" a message digest algorithm means defying its one-way function
  # characteristics, i.e. producing a collision or finding a way to get to the
  # original data by means that are more efficient than brute-forcing etc. Most of
  # the supported digest algorithms can be considered broken in this sense, even
  # the very popular MD5 and SHA1 algorithms. Should security be your highest
  # concern, then you should probably rely on SHA224, SHA256, SHA384 or SHA512.
  #
  # ### Hashing a file
  #
  #     data = File.binread('document')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     digest = sha256.digest(data)
  #
  # ### Hashing several pieces of data at once
  #
  #     data1 = File.binread('file1')
  #     data2 = File.binread('file2')
  #     data3 = File.binread('file3')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     sha256 << data1
  #     sha256 << data2
  #     sha256 << data3
  #     digest = sha256.digest
  #
  # ### Reuse a Digest instance
  #
  #     data1 = File.binread('file1')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     digest1 = sha256.digest(data1)
  #
  #     data2 = File.binread('file2')
  #     sha256.reset
  #     digest2 = sha256.digest(data2)
  #
  class Digest < ::Digest::Class
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/digest.rb
    #   - digest(name, data)
    # -->
    # Return the hash value computed with *name* Digest. *name* is either the long
    # name or short name of a supported digest algorithm.
    #
    # ### Example
    #
    #     OpenSSL::Digest.digest("SHA256", "abc")
    #
    def self.digest: (String name, String data) -> String

    # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
    # Not every message digest can be computed in one single pass. If a message
    # digest is to be computed from several subsequent sources, then each may be
    # passed individually to the Digest instance.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA256')
    #     digest.update('First input')
    #     digest << 'Second input' # equivalent to digest.update('Second input')
    #     result = digest.digest
    #
    alias << update

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.block_length -> integer
    # -->
    # Returns the block length of the digest algorithm, i.e. the length in bytes of
    # an individual block. Most modern algorithms partition a message to be digested
    # into a sequence of fix-sized blocks that are processed consecutively.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA1')
    #     puts digest.block_length # => 64
    #
    def block_length: () -> Integer

    def digest: (?String data) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.digest_length -> integer
    # -->
    # Returns the output size of the digest, i.e. the length in bytes of the final
    # message digest result.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA1')
    #     puts digest.digest_length # => 20
    #
    def digest_length: () -> Integer

    def hexdigest: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.name -> string
    # -->
    # Returns the short name of this Digest algorithm which may differ slightly from
    # the original name provided.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA512')
    #     puts digest.name # => SHA512
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.reset -> self
    # -->
    # Resets the Digest in the sense that any Digest#update that has been performed
    # is abandoned and the Digest is set to its initial state again.
    #
    def reset: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.update(string) -> aString
    # -->
    # Not every message digest can be computed in one single pass. If a message
    # digest is to be computed from several subsequent sources, then each may be
    # passed individually to the Digest instance.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA256')
    #     digest.update('First input')
    #     digest << 'Second input' # equivalent to digest.update('Second input')
    #     result = digest.digest
    #
    def update: (String data) -> self

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.finish -> aString
    # -->
    #
    def finish: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - Digest.new(string [, data]) -> Digest
    # -->
    # Creates a Digest instance based on *string*, which is either the ln (long
    # name) or sn (short name) of a supported digest algorithm. A list of supported
    # algorithms can be obtained by calling OpenSSL::Digest.digests.
    #
    # If *data* (a String) is given, it is used as the initial input to the Digest
    # instance, i.e.
    #
    #     digest = OpenSSL::Digest.new('sha256', 'digestdata')
    #
    # is equivalent to
    #
    #     digest = OpenSSL::Digest.new('sha256')
    #     digest.update('digestdata')
    #
    def initialize: (String name, ?String data) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void

    class Digest < OpenSSL::Digest
    end

    # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
    # Generic Exception class that is raised if an error occurs during a Digest
    # operation.
    #
    class DigestError < OpenSSL::OpenSSLError
    end

    class MD4 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class MD5 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class RIPEMD160 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA1 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA224 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA256 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA384 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA512 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_engine.c -->
  # This class is the access to openssl's ENGINE cryptographic module
  # implementation.
  #
  # See also, https://www.openssl.org/docs/crypto/engine.html
  #
  class Engine
    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.by_id(name) -> engine
    # -->
    # Fetches the engine as specified by the *id* String.
    #
    #     OpenSSL::Engine.by_id("openssl")
    #      => #<OpenSSL::Engine id="openssl" name="Software engine support">
    #
    # See OpenSSL::Engine.engines for the currently loaded engines.
    #
    def self.by_id: (String name) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.cleanup
    # -->
    # It is only necessary to run cleanup when engines are loaded via
    # OpenSSL::Engine.load. However, running cleanup before exit is recommended.
    #
    # Note that this is needed and works only in OpenSSL < 1.1.0.
    #
    def self.cleanup: () -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.engines -> [engine, ...]
    # -->
    # Returns an array of currently loaded engines.
    #
    def self.engines: () -> Array[instance]

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.load(name = nil)
    # -->
    # This method loads engines. If *name* is nil, then all builtin engines are
    # loaded. Otherwise, the given *name*, as a String,  is loaded if available to
    # your runtime, and returns true. If *name* is not found, then nil is returned.
    #
    def self.load: (?String name) -> (true | nil)

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.cipher(name) -> OpenSSL::Cipher
    # -->
    # Returns a new instance of OpenSSL::Cipher by *name*, if it is available in
    # this engine.
    #
    # An EngineError will be raised if the cipher is unavailable.
    #
    #     e = OpenSSL::Engine.by_id("openssl")
    #      => #<OpenSSL::Engine id="openssl" name="Software engine support">
    #     e.cipher("RC4")
    #      => #<OpenSSL::Cipher:0x007fc5cacc3048>
    #
    def cipher: (String cipher) -> Cipher

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.cmds -> [["name", "description", "flags"], ...]
    # -->
    # Returns an array of command definitions for the current engine
    #
    def cmds: () -> Array[[ String, String, String ]]

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.ctrl_cmd(command, value = nil) -> engine
    # -->
    # Sends the given *command* to this engine.
    #
    # Raises an EngineError if the command fails.
    #
    def ctrl_cmd: (String cmd, ?String value) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.digest(name) -> OpenSSL::Digest
    # -->
    # Returns a new instance of OpenSSL::Digest by *name*.
    #
    # Will raise an EngineError if the digest is unavailable.
    #
    #     e = OpenSSL::Engine.by_id("openssl")
    #       #=> #<OpenSSL::Engine id="openssl" name="Software engine support">
    #     e.digest("SHA1")
    #       #=> #<OpenSSL::Digest: da39a3ee5e6b4b0d3255bfef95601890afd80709>
    #     e.digest("zomg")
    #       #=> OpenSSL::Engine::EngineError: no such digest `zomg'
    #
    def digest: (String digest) -> Digest

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.finish -> nil
    # -->
    # Releases all internal structural references for this engine.
    #
    # May raise an EngineError if the engine is unavailable
    #
    def finish: () -> nil

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.id -> string
    # -->
    # Gets the id for this engine.
    #
    #     OpenSSL::Engine.load
    #     OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    #     OpenSSL::Engine.engines.first.id
    #       #=> "rsax"
    #
    def id: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.inspect -> string
    # -->
    # Pretty prints this engine.
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.load_private_key(id = nil, data = nil) -> OpenSSL::PKey
    # -->
    # Loads the given private key identified by *id* and *data*.
    #
    # An EngineError is raised of the OpenSSL::PKey is unavailable.
    #
    def load_private_key: (?String id, ?String data) -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.load_public_key(id = nil, data = nil) -> OpenSSL::PKey
    # -->
    # Loads the given public key identified by *id* and *data*.
    #
    # An EngineError is raised of the OpenSSL::PKey is unavailable.
    #
    def load_public_key: (?String id, ?String data) -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.name -> string
    # -->
    # Get the descriptive name for this engine.
    #
    #     OpenSSL::Engine.load
    #     OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    #     OpenSSL::Engine.engines.first.name
    #       #=> "RSAX engine support"
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.set_default(flag)
    # -->
    # Set the defaults for this engine with the given *flag*.
    #
    # These flags are used to control combinations of algorithm methods.
    #
    # *flag* can be one of the following, other flags are available depending on
    # your OS.
    #
    # All flags
    # :   0xFFFF
    #
    # No flags
    # :   0x0000
    #
    #
    # See also <openssl/engine.h>
    #
    def set_default: (Integer flag) -> bool

    METHOD_ALL: Integer

    METHOD_CIPHERS: Integer

    METHOD_DH: Integer

    METHOD_DIGESTS: Integer

    METHOD_DSA: Integer

    METHOD_NONE: Integer

    METHOD_RAND: Integer

    METHOD_RSA: Integer

    # <!-- rdoc-file=ext/openssl/ossl_engine.c -->
    # This is the generic exception for OpenSSL::Engine related errors
    #
    class EngineError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
  # This module contains configuration information about the SSL extension, for
  # example if socket support is enabled, or the host name TLS extension is
  # enabled.  Constants in this module will always be defined, but contain `true`
  # or `false` values depending on the configuration of your OpenSSL installation.
  #
  module ExtConfig
    HAVE_TLSEXT_HOST_NAME: bool

    OPENSSL_NO_SOCK: bool
  end

  # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
  # OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
  # It is a type of message authentication code (MAC) involving a hash function in
  # combination with a key. HMAC can be used to verify the integrity of a message
  # as well as the authenticity.
  #
  # OpenSSL::HMAC has a similar interface to OpenSSL::Digest.
  #
  # ### HMAC-SHA256 using one-shot interface
  #
  #     key = "key"
  #     data = "message-to-be-authenticated"
  #     mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
  #     #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"
  #
  # ### HMAC-SHA256 using incremental interface
  #
  #     data1 = File.binread("file1")
  #     data2 = File.binread("file2")
  #     key = "key"
  #     hmac = OpenSSL::HMAC.new(key, 'SHA256')
  #     hmac << data1
  #     hmac << data2
  #     mac = hmac.digest
  #
  class HMAC
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - HMAC.digest(digest, key, data) -> aString
    # -->
    # Returns the authentication code as a binary string. The *digest* parameter
    # specifies the digest algorithm to use. This may be a String representing the
    # algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.digest('SHA1', key, data)
    #     #=> "\xDE|\x9B\x85\xB8\xB7\x8A\xA6\xBC\x8Az6\xF7\n\x90p\x1C\x9D\xB4\xD9"
    #
    def self.digest: (String | Digest algo, String key, String data) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - HMAC.hexdigest(digest, key, data) -> aString
    # -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    def self.hexdigest: (String | Digest algo, String key, String data) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - HMAC.base64digest(digest, key, data) -> aString
    # -->
    # Returns the authentication code as a Base64-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.base64digest('SHA1', key, data)
    #     #=> "3nybhbi3iqa8ino29wqQcBydtNk="
    #
    def self.base64digest: (String | Digest algo, String key, String data) -> String

    # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
    # Returns *hmac* updated with the message to be authenticated. Can be called
    # repeatedly with chunks of the message.
    #
    # ### Example
    #
    #     first_chunk = 'The quick brown fox jumps '
    #     second_chunk = 'over the lazy dog'
    #
    #     instance.update(first_chunk)
    #     #=> 5b9a8038a65d571076d97fe783989e52278a492a
    #     instance.update(second_chunk)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #
    alias << update

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - ==(other)
    # -->
    # Securely compare with another HMAC instance in constant time.
    #
    def ==: (instance other) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.digest -> string
    # -->
    # Returns the authentication code an instance represents as a binary string.
    #
    # ### Example
    #     instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance.digest
    #     #=> "\xF4+\xB0\xEE\xB0\x18\xEB\xBDE\x97\xAEr\x13q\x1E\xC6\a`\x84?"
    #
    def digest: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.hexdigest -> string
    # -->
    # Returns the authentication code an instance represents as a hex-encoded
    # string.
    #
    def hexdigest: () -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - hmac.base64digest -> string
    # -->
    # Returns the authentication code an a Base64-encoded string.
    #
    def base64digest: () -> String

    # <!-- rdoc-file=ext/openssl/lib/openssl/hmac.rb -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    alias inspect hexdigest

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.reset -> self
    # -->
    # Returns *hmac* as it was when it was first initialized, with all processed
    # data cleared from it.
    #
    # ### Example
    #
    #     data = "The quick brown fox jumps over the lazy dog"
    #     instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #
    #     instance.update(data)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #     instance.reset
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #
    def reset: () -> self

    # <!-- rdoc-file=ext/openssl/lib/openssl/hmac.rb -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    alias to_s hexdigest

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.update(string) -> self
    # -->
    # Returns *hmac* updated with the message to be authenticated. Can be called
    # repeatedly with chunks of the message.
    #
    # ### Example
    #
    #     first_chunk = 'The quick brown fox jumps '
    #     second_chunk = 'over the lazy dog'
    #
    #     instance.update(first_chunk)
    #     #=> 5b9a8038a65d571076d97fe783989e52278a492a
    #     instance.update(second_chunk)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #
    def update: (String data) -> self

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - HMAC.new(key, digest) -> hmac
    # -->
    # Returns an instance of OpenSSL::HMAC set with the key and digest algorithm to
    # be used. The instance represents the initial state of the message
    # authentication code before any data has been processed. To process data with
    # it, use the instance method #update with your data as an argument.
    #
    # ### Example
    #
    #     key = 'key'
    #     instance = OpenSSL::HMAC.new(key, 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance.class
    #     #=> OpenSSL::HMAC
    #
    # ### A note about comparisons
    #
    # Two instances can be securely compared with #== in constant time:
    #
    #         other_instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance == other_instance
    #     #=> true
    #
    def initialize: (String key, String | Digest digest) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void
  end

  # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
  # Document-class: OpenSSL::HMAC
  #
  # OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
  # It is a type of message authentication code (MAC) involving a hash function in
  # combination with a key. HMAC can be used to verify the integrity of a message
  # as well as the authenticity.
  #
  # OpenSSL::HMAC has a similar interface to OpenSSL::Digest.
  #
  # ### HMAC-SHA256 using one-shot interface
  #
  #     key = "key"
  #     data = "message-to-be-authenticated"
  #     mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
  #     #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"
  #
  # ### HMAC-SHA256 using incremental interface
  #
  #     data1 = File.binread("file1")
  #     data2 = File.binread("file2")
  #     key = "key"
  #     hmac = OpenSSL::HMAC.new(key, 'SHA256')
  #     hmac << data1
  #     hmac << data2
  #     mac = hmac.digest
  #
  class HMACError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/ossl_kdf.c -->
  # Provides functionality of various KDFs (key derivation function).
  #
  # KDF is typically used for securely deriving arbitrary length symmetric keys to
  # be used with an OpenSSL::Cipher from passwords. Another use case is for
  # storing passwords: Due to the ability to tweak the effort of computation by
  # increasing the iteration count, computation can be slowed down artificially in
  # order to render possible attacks infeasible.
  #
  # Currently, OpenSSL::KDF provides implementations for the following KDF:
  #
  # *   PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination
  #     with HMAC
  # *   scrypt
  # *   HKDF
  #
  # ## Examples
  # ### Generating a 128 bit key for a Cipher (e.g. AES)
  #     pass = "secret"
  #     salt = OpenSSL::Random.random_bytes(16)
  #     iter = 20_000
  #     key_len = 16
  #     key = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
  #                                    length: key_len, hash: "sha1")
  #
  # ### Storing Passwords
  #     pass = "secret"
  #     # store this with the generated value
  #     salt = OpenSSL::Random.random_bytes(16)
  #     iter = 20_000
  #     hash = OpenSSL::Digest.new('SHA256')
  #     len = hash.digest_length
  #     # the final value to be stored
  #     value = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
  #                                      length: len, hash: hash)
  #
  # ## Important Note on Checking Passwords
  # When comparing passwords provided by the user with previously stored values, a
  # common mistake made is comparing the two values using "==". Typically, "=="
  # short-circuits on evaluation, and is therefore vulnerable to timing attacks.
  # The proper way is to use a method that always takes the same amount of time
  # when comparing two values, thus not leaking any information to potential
  # attackers. To do this, use `OpenSSL.fixed_length_secure_compare`.
  #
  module KDF
    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.hkdf(ikm, salt:, info:, length:, hash:) -> String
    # -->
    # HMAC-based Extract-and-Expand Key Derivation Function (HKDF) as specified in
    # [RFC 5869](https://www.rfc-editor.org/rfc/rfc5869).
    #
    # New in OpenSSL 1.1.0.
    #
    # ### Parameters
    # *ikm*
    # :   The input keying material.
    #
    # *salt*
    # :   The salt.
    #
    # *info*
    # :   The context and application specific information.
    #
    # *length*
    # :   The output length in octets. Must be <= `255 * HashLen`, where HashLen is
    #     the length of the hash function output in octets.
    #
    # *hash*
    # :   The hash function.
    #
    #
    # ### Example
    #     # The values from https://www.rfc-editor.org/rfc/rfc5869#appendix-A.1
    #     ikm = ["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*")
    #     salt = ["000102030405060708090a0b0c"].pack("H*")
    #     info = ["f0f1f2f3f4f5f6f7f8f9"].pack("H*")
    #     p OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: 42, hash: "SHA256").unpack1("H*")
    #     # => "3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"
    #
    def self.hkdf: (String ikm, salt: String, info: String, length: Integer, hash: String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.pbkdf2_hmac(pass, salt:, iterations:, length:, hash:) -> aString
    # -->
    # PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with
    # HMAC. Takes *pass*, *salt* and *iterations*, and then derives a key of
    # *length* bytes.
    #
    # For more information about PBKDF2, see RFC 2898 Section 5.2
    # (https://www.rfc-editor.org/rfc/rfc2898#section-5.2).
    #
    # ### Parameters
    # pass
    # :   The password.
    #
    # salt
    # :   The salt. Salts prevent attacks based on dictionaries of common passwords
    #     and attacks based on rainbow tables. It is a public value that can be
    #     safely stored along with the password (e.g. if the derived value is used
    #     for password storage).
    #
    # iterations
    # :   The iteration count. This provides the ability to tune the algorithm. It
    #     is better to use the highest count possible for the maximum resistance to
    #     brute-force attacks.
    #
    # length
    # :   The desired length of the derived key in octets.
    #
    # hash
    # :   The hash algorithm used with HMAC for the PRF. May be a String
    #     representing the algorithm name, or an instance of OpenSSL::Digest.
    #
    def self.pbkdf2_hmac: (String pass, salt: String, iterations: Integer, length: Integer, hash: String | Digest) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.scrypt(pass, salt:, N:, r:, p:, length:) -> aString
    # -->
    # Derives a key from *pass* using given parameters with the scrypt
    # password-based key derivation function. The result can be used for password
    # storage.
    #
    # scrypt is designed to be memory-hard and more secure against brute-force
    # attacks using custom hardwares than alternative KDFs such as PBKDF2 or bcrypt.
    #
    # The keyword arguments *N*, *r* and *p* can be used to tune scrypt. RFC 7914
    # (published on 2016-08, https://www.rfc-editor.org/rfc/rfc7914#section-2)
    # states that using values r=8 and p=1 appears to yield good results.
    #
    # See RFC 7914 (https://www.rfc-editor.org/rfc/rfc7914) for more information.
    #
    # ### Parameters
    # pass
    # :   Passphrase.
    #
    # salt
    # :   Salt.
    #
    # N
    # :   CPU/memory cost parameter. This must be a power of 2.
    #
    # r
    # :   Block size parameter.
    #
    # p
    # :   Parallelization parameter.
    #
    # length
    # :   Length in octets of the derived key.
    #
    #
    # ### Example
    #     pass = "password"
    #     salt = SecureRandom.random_bytes(16)
    #     dk = OpenSSL::KDF.scrypt(pass, salt: salt, N: 2**14, r: 8, p: 1, length: 32)
    #     p dk #=> "\xDA\xE4\xE2...\x7F\xA1\x01T"
    #
    def self.scrypt: (String pass, salt: String, N: Integer, r: Integer, p: Integer, length: Integer) -> String

    private

    def hkdf: (*untyped) -> untyped

    def pbkdf2_hmac: (*untyped) -> untyped

    def scrypt: (*untyped) -> untyped

    # <!-- rdoc-file=ext/openssl/ossl_kdf.c -->
    # Generic exception class raised if an error occurs in OpenSSL::KDF module.
    #
    class KDFError < OpenSSL::OpenSSLError
    end
  end

  module Marshal
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
    #   - included(base)
    # -->
    #
    def self.included: (untyped base) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
    #   - _dump(_level)
    # -->
    #
    def _dump: (untyped _level) -> untyped

    module ClassMethods
      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
      #   - _load(string)
      # -->
      #
      def _load: (untyped string) -> untyped
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
  # OpenSSL::Netscape is a namespace for SPKI (Simple Public Key Infrastructure)
  # which implements Signed Public Key and Challenge. See [RFC
  # 2692](https://www.rfc-editor.org/rfc/rfc2692) and [RFC
  # 2693](https://www.rfc-editor.org/rfc/rfc2692) for details.
  #
  module Netscape
    # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
    # A Simple Public Key Infrastructure implementation (pronounced "spooky"). The
    # structure is defined as
    #     PublicKeyAndChallenge ::= SEQUENCE {
    #       spki SubjectPublicKeyInfo,
    #       challenge IA5STRING
    #     }
    #
    #     SignedPublicKeyAndChallenge ::= SEQUENCE {
    #       publicKeyAndChallenge PublicKeyAndChallenge,
    #       signatureAlgorithm AlgorithmIdentifier,
    #       signature BIT STRING
    #     }
    #
    # where the definitions of SubjectPublicKeyInfo and AlgorithmIdentifier can be
    # found in RFC5280. SPKI is typically used in browsers for generating a
    # public/private key pair and a subsequent certificate request, using the HTML
    # <keygen> element.
    #
    # ## Examples
    #
    # ### Creating an SPKI
    #     key = OpenSSL::PKey::RSA.new 2048
    #     spki = OpenSSL::Netscape::SPKI.new
    #     spki.challenge = "RandomChallenge"
    #     spki.public_key = key.public_key
    #     spki.sign(key, OpenSSL::Digest.new('SHA256'))
    #     #send a request containing this to a server generating a certificate
    #
    # ### Verifying an SPKI request
    #     request = #...
    #     spki = OpenSSL::Netscape::SPKI.new request
    #     unless spki.verify(spki.public_key)
    #       # signature is invalid
    #     end
    #     #proceed
    #
    class SPKI
      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.challenge => string
      # -->
      # Returns the challenge string associated with this SPKI.
      #
      def challenge: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.challenge = str => string
      # -->
      # ### Parameters
      # *   *str* - the challenge string to be set for this instance
      #
      # Sets the challenge to be associated with the SPKI. May be used by the server,
      # e.g. to prevent replay.
      #
      def challenge=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.public_key => pkey
      # -->
      # Returns the public key associated with the SPKI, an instance of OpenSSL::PKey.
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.public_key = pub => pkey
      # -->
      # ### Parameters
      # *   *pub* - the public key to be set for this instance
      #
      # Sets the public key to be associated with the SPKI, an instance of
      # OpenSSL::PKey. This should be the public key corresponding to the private key
      # used for signing the SPKI.
      #
      def public_key=: (PKey::PKey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.sign(key, digest) => spki
      # -->
      # ### Parameters
      # *   *key* - the private key to be used for signing this instance
      # *   *digest* - the digest to be used for signing this instance
      #
      # To sign an SPKI, the private key corresponding to the public key set for this
      # instance should be used, in addition to a digest algorithm in the form of an
      # OpenSSL::Digest. The private key should be an instance of OpenSSL::PKey.
      #
      def sign: (PKey::PKey key, Digest digest) -> instance

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_der => DER-encoded string
      # -->
      # Returns the DER encoding of this SPKI.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_pem => PEM-encoded string
      # -->
      # Returns the PEM encoding of this SPKI.
      #
      def to_pem: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
      # Returns the PEM encoding of this SPKI.
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_text => string
      # -->
      # Returns a textual representation of this SPKI, useful for debugging purposes.
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.verify(key) => boolean
      # -->
      # ### Parameters
      # *   *key* - the public key to be used for verifying the SPKI signature
      #
      # Returns `true` if the signature is valid, `false` otherwise. To verify an
      # SPKI, the public key contained within the SPKI should be used.
      #
      def verify: (PKey::PKey key) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - SPKI.new([request]) => spki
      # -->
      # ### Parameters
      # *   *request* - optional raw request, either in PEM or DER format.
      #
      def initialize: (?String request) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
    # Generic Exception class that is raised if an error occurs during an operation
    # on an instance of OpenSSL::Netscape::SPKI.
    #
    class SPKIError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
  # OpenSSL::OCSP implements Online Certificate Status Protocol requests and
  # responses.
  #
  # Creating and sending an OCSP request requires a subject certificate that
  # contains an OCSP URL in an authorityInfoAccess extension and the issuer
  # certificate for the subject certificate.  First, load the issuer and subject
  # certificates:
  #
  #     subject = OpenSSL::X509::Certificate.new subject_pem
  #     issuer  = OpenSSL::X509::Certificate.new issuer_pem
  #
  # To create the request we need to create a certificate ID for the subject
  # certificate so the CA knows which certificate we are asking about:
  #
  #     digest = OpenSSL::Digest.new('SHA1')
  #     certificate_id =
  #       OpenSSL::OCSP::CertificateId.new subject, issuer, digest
  #
  # Then create a request and add the certificate ID to it:
  #
  #     request = OpenSSL::OCSP::Request.new
  #     request.add_certid certificate_id
  #
  # Adding a nonce to the request protects against replay attacks but not all CA
  # process the nonce.
  #
  #     request.add_nonce
  #
  # To submit the request to the CA for verification we need to extract the OCSP
  # URI from the subject certificate:
  #
  #     ocsp_uris = subject.ocsp_uris
  #
  #     require 'uri'
  #
  #     ocsp_uri = URI ocsp_uris[0]
  #
  # To submit the request we'll POST the request to the OCSP URI (per RFC 2560).
  # Note that we only handle HTTP requests and don't handle any redirects in this
  # example, so this is insufficient for serious use.
  #
  #     require 'net/http'
  #
  #     http_response =
  #       Net::HTTP.start ocsp_uri.hostname, ocsp_uri.port do |http|
  #         http.post ocsp_uri.path, request.to_der,
  #                   'content-type' => 'application/ocsp-request'
  #     end
  #
  #     response = OpenSSL::OCSP::Response.new http_response.body
  #     response_basic = response.basic
  #
  # First we check if the response has a valid signature.  Without a valid
  # signature we cannot trust it.  If you get a failure here you may be missing a
  # system certificate store or may be missing the intermediate certificates.
  #
  #     store = OpenSSL::X509::Store.new
  #     store.set_default_paths
  #
  #     unless response_basic.verify [], store then
  #       raise 'response is not signed by a trusted certificate'
  #     end
  #
  # The response contains the status information (success/fail).  We can display
  # the status as a string:
  #
  #     puts response.status_string #=> successful
  #
  # Next we need to know the response details to determine if the response matches
  # our request.  First we check the nonce.  Again, not all CAs support a nonce.
  # See Request#check_nonce for the meanings of the return values.
  #
  #     p request.check_nonce basic_response #=> value from -1 to 3
  #
  # Then extract the status information for the certificate from the basic
  # response.
  #
  #     single_response = basic_response.find_response(certificate_id)
  #
  #     unless single_response
  #       raise 'basic_response does not have the status for the certificate'
  #     end
  #
  # Then check the validity. A status issued in the future must be rejected.
  #
  #     unless single_response.check_validity
  #       raise 'this_update is in the future or next_update time has passed'
  #     end
  #
  #     case single_response.cert_status
  #     when OpenSSL::OCSP::V_CERTSTATUS_GOOD
  #       puts 'certificate is still valid'
  #     when OpenSSL::OCSP::V_CERTSTATUS_REVOKED
  #       puts "certificate has been revoked at #{single_response.revocation_time}"
  #     when OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN
  #       puts 'responder doesn't know about the certificate'
  #     end
  #
  module OCSP
    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # (This flag is not used by OpenSSL 1.0.1g)
    #
    NOCASIGN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not include certificates in the response
    #
    NOCERTS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify the certificate chain on the response
    #
    NOCHAIN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not make additional signing certificate checks
    #
    NOCHECKS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # (This flag is not used by OpenSSL 1.0.1g)
    #
    NODELEGATED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not check trust
    #
    NOEXPLICIT: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not search certificates contained in the response for a signer
    #
    NOINTERN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not check the signature on the response
    #
    NOSIGS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not include producedAt time in response
    #
    NOTIME: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify the response at all
    #
    NOVERIFY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Identify the response by signing the certificate key ID
    #
    RESPID_KEY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Internal error in issuer
    #
    RESPONSE_STATUS_INTERNALERROR: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Illegal confirmation request
    #
    RESPONSE_STATUS_MALFORMEDREQUEST: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # You must sign the request and resubmit
    #
    RESPONSE_STATUS_SIGREQUIRED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Response has valid confirmations
    #
    RESPONSE_STATUS_SUCCESSFUL: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Try again later
    #
    RESPONSE_STATUS_TRYLATER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Your request is unauthorized.
    #
    RESPONSE_STATUS_UNAUTHORIZED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate subject's name or other information changed
    #
    REVOKED_STATUS_AFFILIATIONCHANGED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # This CA certificate was revoked due to a key compromise
    #
    REVOKED_STATUS_CACOMPROMISE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate is on hold
    #
    REVOKED_STATUS_CERTIFICATEHOLD: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate is no longer needed
    #
    REVOKED_STATUS_CESSATIONOFOPERATION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked due to a key compromise
    #
    REVOKED_STATUS_KEYCOMPROMISE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked for an unknown reason
    #
    REVOKED_STATUS_NOSTATUS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was previously on hold and should now be removed from the CRL
    #
    REVOKED_STATUS_REMOVEFROMCRL: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was superseded by a new certificate
    #
    REVOKED_STATUS_SUPERSEDED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked for an unspecified reason
    #
    REVOKED_STATUS_UNSPECIFIED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify additional certificates
    #
    TRUSTOTHER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the certificate is not revoked but does not necessarily mean the
    # certificate was issued or that this response is within the certificate's
    # validity interval
    #
    V_CERTSTATUS_GOOD: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the certificate has been revoked either permanently or temporarily
    # (on hold).
    #
    V_CERTSTATUS_REVOKED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the responder does not know about the certificate being requested.
    #
    V_CERTSTATUS_UNKNOWN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The responder ID is based on the public key.
    #
    V_RESPID_KEY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The responder ID is based on the key name.
    #
    V_RESPID_NAME: Integer

    type ocsp_status = Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::BasicResponse contains the status of a certificate check
    # which is created from an OpenSSL::OCSP::Request.  A BasicResponse is more
    # detailed than a Response.
    #
    class BasicResponse
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.add_nonce(nonce = nil)
      # -->
      # Adds *nonce* to this response.  If no nonce was provided a random nonce will
      # be added.
      #
      def add_nonce: (?String nonce) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.add_status(certificate_id, status, reason, revocation_time, this_update, next_update, extensions) -> basic_response
      # -->
      # Adds a certificate status for *certificate_id*. *status* is the status, and
      # must be one of these:
      #
      # *   OpenSSL::OCSP::V_CERTSTATUS_GOOD
      # *   OpenSSL::OCSP::V_CERTSTATUS_REVOKED
      # *   OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN
      #
      # *reason* and *revocation_time* can be given only when *status* is
      # OpenSSL::OCSP::V_CERTSTATUS_REVOKED. *reason* describes the reason for the
      # revocation, and must be one of OpenSSL::OCSP::REVOKED_STATUS_* constants.
      # *revocation_time* is the time when the certificate is revoked.
      #
      # *this_update* and *next_update* indicate the time at which the status is
      # verified to be correct and the time at or before which newer information will
      # be available, respectively. *next_update* is optional.
      #
      # *extensions* is an Array of OpenSSL::X509::Extension to be included in the
      # SingleResponse. This is also optional.
      #
      # Note that the times, *revocation_time*, *this_update* and *next_update* can be
      # specified in either of Integer or Time object. If they are Integer, it is
      # treated as the relative seconds from the current time.
      #
      def add_status: (CertificateId certificate_id, ocsp_status status, Integer? reason, Integer? revocation_time, ?Integer | Time this_update, ?Integer | Time next_update, ?Array[X509::Extension] extensions) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.copy_nonce(request) -> Integer
      # -->
      # Copies the nonce from *request* into this response.  Returns 1 on success and
      # 0 on failure.
      #
      def copy_nonce: (Request request) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.find_response(certificate_id) -> SingleResponse | nil
      # -->
      # Returns a SingleResponse whose CertId matches with *certificate_id*, or `nil`
      # if this BasicResponse does not contain it.
      #
      def find_response: (CertificateId certificate_id) -> SingleResponse?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.responses -> Array of SingleResponse
      # -->
      # Returns an Array of SingleResponse for this BasicResponse.
      #
      def responses: () -> Array[SingleResponse]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.sign(cert, key, certs = nil, flags = 0, digest = nil) -> self
      # -->
      # Signs this OCSP response using the *cert*, *key* and optional *digest*. This
      # behaves in the similar way as OpenSSL::OCSP::Request#sign.
      #
      # *flags* can include:
      # OpenSSL::OCSP::NOCERTS
      # :   don't include certificates
      #
      # OpenSSL::OCSP::NOTIME
      # :   don't set producedAt
      #
      # OpenSSL::OCSP::RESPID_KEY
      # :   use signer's public key hash as responderID
      #
      def sign: (X509::Certificate cert, PKey::PKey key, ?Array[X509::Certificate] certs, ?Integer flags, ?Digest digest) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.status -> statuses
      # -->
      # Returns an Array of statuses for this response.  Each status contains a
      # CertificateId, the status (0 for good, 1 for revoked, 2 for unknown), the
      # reason for the status, the revocation time, the time of this update, the time
      # for the next update and a list of OpenSSL::X509::Extension.
      #
      # This should be superseded by BasicResponse#responses and #find_response that
      # return SingleResponse.
      #
      def status: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.to_der -> String
      # -->
      # Encodes this basic response into a DER-encoded string.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.verify(certificates, store, flags = 0) -> true or false
      # -->
      # Verifies the signature of the response using the given *certificates* and
      # *store*. This works in the similar way as OpenSSL::OCSP::Request#verify.
      #
      def verify: (Array[X509::Certificate] certs, X509::Store store, ?Integer flags) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::BasicResponse.new(der_string = nil) -> basic_response
      # -->
      # Creates a new BasicResponse. If *der_string* is given, decodes *der_string* as
      # DER.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::CertificateId identifies a certificate to the CA so that a
    # status check can be performed.
    #
    class CertificateId
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.cmp(other) -> true or false
      # -->
      # Compares this certificate id with *other* and returns `true` if they are the
      # same.
      #
      def cmp: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.cmp_issuer(other) -> true or false
      # -->
      # Compares this certificate id's issuer with *other* and returns `true` if they
      # are the same.
      #
      def cmp_issuer: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.hash_algorithm -> String
      # -->
      # Returns the ln (long name) of the hash algorithm used to generate the
      # issuerNameHash and the issuerKeyHash values.
      #
      def hash_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.issuer_key_hash -> String
      # -->
      # Returns the issuerKeyHash of this certificate ID, the hash of the issuer's
      # public key.
      #
      def issuer_key_hash: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.issuer_name_hash -> String
      # -->
      # Returns the issuerNameHash of this certificate ID, the hash of the issuer's
      # distinguished name calculated with the hashAlgorithm.
      #
      def issuer_name_hash: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.serial -> Integer
      # -->
      # Returns the serial number of the certificate for which status is being
      # requested.
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.to_der -> String
      # -->
      # Encodes this certificate identifier into a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::CertificateId.new(subject, issuer, digest = nil) -> certificate_id
      #   - OpenSSL::OCSP::CertificateId.new(der_string)                    -> certificate_id
      #   - OpenSSL::OCSP::CertificateId.new(obj)                           -> certificate_id
      # -->
      # Creates a new OpenSSL::OCSP::CertificateId for the given *subject* and
      # *issuer* X509 certificates.  The *digest* is a digest algorithm that is used
      # to compute the hash values. This defaults to SHA-1.
      #
      # If only one argument is given, decodes it as DER representation of a
      # certificate ID or generates certificate ID from the object that responds to
      # the to_der method.
      #
      def initialize: (String | ASN1::_ToDer der) -> void
                    | (X509::Certificate subject, X509::Certificate issuer, ?Digest digest) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # OCSP error class.
    #
    class OCSPError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::Request contains the certificate information for determining
    # if a certificate has been revoked or not.  A Request can be created for a
    # certificate or from a DER-encoded request created elsewhere.
    #
    class Request
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.add_certid(certificate_id) -> request
      # -->
      # Adds *certificate_id* to the request.
      #
      def add_certid: (CertificateId certificate_id) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.add_nonce(nonce = nil) -> request
      # -->
      # Adds a *nonce* to the OCSP request.  If no nonce is given a random one will be
      # generated.
      #
      # The nonce is used to prevent replay attacks but some servers do not support
      # it.
      #
      def add_nonce: (?String nonce) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.certid -> [certificate_id, ...]
      # -->
      # Returns all certificate IDs in this request.
      #
      def certid: () -> Array[CertificateId]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.check_nonce(response) -> result
      # -->
      # Checks the nonce validity for this request and *response*.
      #
      # The return value is one of the following:
      #
      # -1
      # :   nonce in request only.
      #
      # 0
      # :   nonces both present and not equal.
      #
      # 1
      # :   nonces present and equal.
      #
      # 2
      # :   nonces both absent.
      #
      # 3
      # :   nonce present in response only.
      #
      #
      # For most responses, clients can check *result* > 0.  If a responder doesn't
      # handle nonces `result.nonzero?` may be necessary.  A result of `0` is always
      # an error.
      #
      def check_nonce: (Response response) -> (-1 | 0 | 1 | 2 | 3)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.sign(cert, key, certs = nil, flags = 0, digest = nil) -> self
      # -->
      # Signs this OCSP request using *cert*, *key* and optional *digest*. If *digest*
      # is not specified, SHA-1 is used. *certs* is an optional Array of additional
      # certificates which are included in the request in addition to the signer
      # certificate. Note that if *certs* is `nil` or not given, flag
      # OpenSSL::OCSP::NOCERTS is enabled. Pass an empty array to include only the
      # signer certificate.
      #
      # *flags* is a bitwise OR of the following constants:
      #
      # OpenSSL::OCSP::NOCERTS
      # :   Don't include any certificates in the request. *certs* will be ignored.
      #
      def sign: (X509::Certificate cert, PKey::PKey key, ?Array[X509::Certificate] certs, ?Integer flags, ?Digest digest) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.signed? -> true or false
      # -->
      # Returns `true` if the request is signed, `false` otherwise. Note that the
      # validity of the signature is **not** checked. Use #verify to verify that.
      #
      def signed?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - to_der()
      # -->
      # Returns this request as a DER-encoded string
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.verify(certificates, store, flags = 0) -> true or false
      # -->
      # Verifies this request using the given *certificates* and *store*.
      # *certificates* is an array of OpenSSL::X509::Certificate, *store* is an
      # OpenSSL::X509::Store.
      #
      # Note that `false` is returned if the request does not have a signature. Use
      # #signed? to check whether the request is signed or not.
      #
      def verify: (Array[X509::Certificate] certs, X509::Store store, ?Integer flags) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Request.new              -> request
      #   - OpenSSL::OCSP::Request.new(request_der) -> request
      # -->
      # Creates a new OpenSSL::OCSP::Request.  The request may be created empty or
      # from a *request_der* string.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::Response contains the status of a certificate check which is
    # created from an OpenSSL::OCSP::Request.
    #
    class Response
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Response.create(status, basic_response = nil) -> response
      # -->
      # Creates an OpenSSL::OCSP::Response from *status* and *basic_response*.
      #
      def self.create: (Integer status, ?BasicResponse response) -> instance

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.basic
      # -->
      # Returns a BasicResponse for this response
      #
      def basic: () -> BasicResponse?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.status -> Integer
      # -->
      # Returns the status of the response.
      #
      def status: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.status_string -> String
      # -->
      # Returns a status string for the response.
      #
      def status_string: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.to_der -> String
      # -->
      # Returns this response as a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Response.new               -> response
      #   - OpenSSL::OCSP::Response.new(response_der) -> response
      # -->
      # Creates a new OpenSSL::OCSP::Response.  The response may be created empty or
      # from a *response_der* string.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::SingleResponse represents an OCSP SingleResponse structure,
    # which contains the basic information of the status of the certificate.
    #
    class SingleResponse
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.cert_status -> Integer
      # -->
      # Returns the status of the certificate identified by the certid. The return
      # value may be one of these constant:
      #
      # *   V_CERTSTATUS_GOOD
      # *   V_CERTSTATUS_REVOKED
      # *   V_CERTSTATUS_UNKNOWN
      #
      # When the status is V_CERTSTATUS_REVOKED, the time at which the certificate was
      # revoked can be retrieved by #revocation_time.
      #
      def cert_status: () -> ocsp_status

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.certid -> CertificateId
      # -->
      # Returns the CertificateId for which this SingleResponse is.
      #
      def certid: () -> CertificateId

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.check_validity(nsec = 0, maxsec = -1) -> true | false
      # -->
      # Checks the validity of thisUpdate and nextUpdate fields of this
      # SingleResponse. This checks the current time is within the range thisUpdate to
      # nextUpdate.
      #
      # It is possible that the OCSP request takes a few seconds or the time is not
      # accurate. To avoid rejecting a valid response, this method allows the times to
      # be within *nsec* seconds of the current time.
      #
      # Some responders don't set the nextUpdate field. This may cause a very old
      # response to be considered valid. The *maxsec* parameter can be used to limit
      # the age of responses.
      #
      def check_validity: (?Integer nsec, ?Integer maxsec) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.extensions -> Array of X509::Extension
      # -->
      #
      def extensions: () -> Array[X509::Certificate]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.next_update -> Time | nil
      # -->
      #
      def next_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.revocation_reason -> Integer | nil
      # -->
      #
      def revocation_reason: () -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.revocation_time -> Time | nil
      # -->
      #
      def revocation_time: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.this_update -> Time
      # -->
      #
      def this_update: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.to_der -> String
      # -->
      # Encodes this SingleResponse into a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::SingleResponse.new(der_string) -> SingleResponse
      # -->
      # Creates a new SingleResponse from *der_string*.
      #
      def initialize: (String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Generic error, common for all classes under OpenSSL module
  #
  class OpenSSLError < StandardError
  end

  # <!-- rdoc-file=ext/openssl/ossl_pkcs12.c -->
  # Defines a file format commonly used to store private keys with accompanying
  # public key certificates, protected with a password-based symmetric key.
  #
  class PKCS12
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - PKCS12.create(pass, name, key, cert [, ca, [, key_pbe [, cert_pbe [, key_iter [, mac_iter [, keytype]]]]]])
    # -->
    # ### Parameters
    # *   *pass* - string
    # *   *name* - A string describing the key.
    # *   *key* - Any PKey.
    # *   *cert* - A X509::Certificate.
    #     *   The public_key portion of the certificate must contain a valid public
    #         key.
    #     *   The not_before and not_after fields must be filled in.
    # *   *ca* - An optional array of X509::Certificate's.
    # *   *key_pbe* - string
    # *   *cert_pbe* - string
    # *   *key_iter* - integer
    # *   *mac_iter* - integer
    # *   *keytype* - An integer representing an MSIE specific extension.
    #
    # Any optional arguments may be supplied as `nil` to preserve the OpenSSL
    # defaults.
    #
    # See the OpenSSL documentation for PKCS12_create().
    #
    def self.create: (String pass, String name, PKey::PKey key, X509::Certificate cert, ?Array[X509::Certificate]? ca, ?String? key_pbe, ?String? cert_pbe, ?Integer? key_iter, ?Integer? mac_iter, ?Integer? keytype) -> instance

    def ca_certs: () -> Array[X509::Certificate]?

    def certificate: () -> X509::Certificate

    def key: () -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - to_der()
    # -->
    #
    def to_der: () -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - PKCS12.new -> pkcs12
    #   - PKCS12.new(str) -> pkcs12
    #   - PKCS12.new(str, pass) -> pkcs12
    # -->
    # ### Parameters
    # *   *str* - Must be a DER encoded PKCS12 string.
    # *   *pass* - string
    #
    def initialize: (?String der, ?String pass) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void

    class PKCS12Error < OpenSSL::OpenSSLError
    end
  end

  module PKCS5
    def self.pbkdf2_hmac: (String pass, String salt, Integer iter, Integer keylen, String | Digest digest) -> String

    def self.pbkdf2_hmac_sha1: (String pass, String salt, Integer iter, Integer keylen) -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/pkcs5.rb
    #   - pbkdf2_hmac(pass, salt, iter, keylen, digest)
    # -->
    # OpenSSL::PKCS5.pbkdf2_hmac has been renamed to OpenSSL::KDF.pbkdf2_hmac. This
    # method is provided for backwards compatibility.
    #
    def pbkdf2_hmac: (untyped pass, untyped salt, untyped iter, untyped keylen, untyped digest) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/pkcs5.rb
    #   - pbkdf2_hmac_sha1(pass, salt, iter, keylen)
    # -->
    #
    def pbkdf2_hmac_sha1: (untyped pass, untyped salt, untyped iter, untyped keylen) -> untyped
  end

  class PKCS7
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.encrypt(certs, data, cipher, flags = 0) => pkcs7
    # -->
    # Creates a PKCS #7 enveloped-data structure.
    #
    # Before version 3.3.0, `cipher` was optional and defaulted to `"RC2-40-CBC"`.
    #
    # See also the man page PKCS7_encrypt(3).
    #
    def self.encrypt: (X509::Certificate certs, String data, ?Cipher cipher, ?Integer flags) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.read_smime(string) => pkcs7
    # -->
    #
    def self.read_smime: (String) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.sign(cert, key, data, [, certs [, flags]]) => pkcs7
    # -->
    #
    def self.sign: (X509::Certificate certs, PKey::PKey key, String data, ?OpenSSL::Cipher cipher, ?Integer flags) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.write_smime(pkcs7 [, data [, flags]]) => string
    # -->
    #
    def self.write_smime: (instance pkcs7, ?String data, ?Integer flags) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_certificate(p1)
    # -->
    #
    def add_certificate: (X509::Certificate cert) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_crl(p1)
    # -->
    #
    def add_crl: (X509::CRL crl) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_data(p1)
    # -->
    #
    def add_data: (String data) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_recipient(p1)
    # -->
    #
    def add_recipient: (RecipientInfo recipient) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_signer(p1)
    # -->
    #
    def add_signer: (SignerInfo signer) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - certificates()
    # -->
    #
    def certificates: () -> Array[X509::Certificate]?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - certificates=(p1)
    # -->
    #
    def certificates=: (Array[X509::Certificate]) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - cipher=(p1)
    # -->
    #
    def cipher=: (Cipher cipher) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - crls()
    # -->
    #
    def crls: () -> Array[X509::CRL]?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - crls=(p1)
    # -->
    #
    def crls=: (Array[X509::CRL]) -> self

    def data: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - data=(p1)
    # -->
    #
    alias data= add_data

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - decrypt(p1, p2 = v2, p3 = v3)
    # -->
    #
    def decrypt: (PKey::PKey p1, ?PKey::PKey p2, ?PKey::PKey p3) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached()
    # -->
    #
    def detached: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached=(p1)
    # -->
    #
    def detached=: [U] (boolish) -> U

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached?()
    # -->
    #
    def detached?: () -> bool

    def error_string: () -> String?

    def error_string=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - recipients()
    # -->
    #
    def recipients: () -> Array[RecipientInfo]

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - signers()
    # -->
    #
    def signers: () -> Array[SignerInfo]

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_der()
    # -->
    #
    def to_der: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_pem()
    # -->
    #
    def to_pem: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_s()
    # -->
    #
    alias to_s to_pem

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - pkcs7.type => string or nil
    # -->
    #
    def type: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - pkcs7.type = type => type
    # -->
    #
    def type=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - verify(p1, p2, p3 = v3, p4 = v4)
    # -->
    #
    def verify: (PKey::PKey p1, PKey::PKey p2, ?PKey::PKey p3, ?PKey::PKey p4) -> bool

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.new => pkcs7
    #   - PKCS7.new(string) => pkcs7
    # -->
    # Many methods in this class aren't documented.
    #
    def initialize: (?String der) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> untyped

    BINARY: Integer

    DETACHED: Integer

    NOATTR: Integer

    NOCERTS: Integer

    NOCHAIN: Integer

    NOINTERN: Integer

    NOSIGS: Integer

    NOSMIMECAP: Integer

    NOVERIFY: Integer

    TEXT: Integer

    class PKCS7Error < OpenSSL::OpenSSLError
    end

    class RecipientInfo
      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - enc_key()
      # -->
      #
      def enc_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - new(p1)
      # -->
      #
      def initialize: (X509::Certificate certificate) -> void
    end

    class SignerInfo
      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - signed_time()
      # -->
      #
      def signed_time: () -> Time?

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - new(p1, p2, p3)
      # -->
      #
      def initialize: (X509::Certificate certificate, PKey::PKey key, Digest digest) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
  # ## Asymmetric Public Key Algorithms
  #
  # Asymmetric public key algorithms solve the problem of establishing and sharing
  # secret keys to en-/decrypt messages. The key in such an algorithm consists of
  # two parts: a public key that may be distributed to others and a private key
  # that needs to remain secret.
  #
  # Messages encrypted with a public key can only be decrypted by recipients that
  # are in possession of the associated private key. Since public key algorithms
  # are considerably slower than symmetric key algorithms (cf. OpenSSL::Cipher)
  # they are often used to establish a symmetric key shared between two parties
  # that are in possession of each other's public key.
  #
  # Asymmetric algorithms offer a lot of nice features that are used in a lot of
  # different areas. A very common application is the creation and validation of
  # digital signatures. To sign a document, the signatory generally uses a message
  # digest algorithm (cf. OpenSSL::Digest) to compute a digest of the document
  # that is then encrypted (i.e. signed) using the private key. Anyone in
  # possession of the public key may then verify the signature by computing the
  # message digest of the original document on their own, decrypting the signature
  # using the signatory's public key and comparing the result to the message
  # digest they previously computed. The signature is valid if and only if the
  # decrypted signature is equal to this message digest.
  #
  # The PKey module offers support for three popular public/private key
  # algorithms:
  # *   RSA (OpenSSL::PKey::RSA)
  # *   DSA (OpenSSL::PKey::DSA)
  # *   Elliptic Curve Cryptography (OpenSSL::PKey::EC)
  # Each of these implementations is in fact a sub-class of the abstract PKey
  # class which offers the interface for supporting digital signatures in the form
  # of PKey#sign and PKey#verify.
  #
  # ## Diffie-Hellman Key Exchange
  #
  # Finally PKey also features OpenSSL::PKey::DH, an implementation of the
  # Diffie-Hellman key exchange protocol based on discrete logarithms in finite
  # fields, the same basis that DSA is built on. The Diffie-Hellman protocol can
  # be used to exchange (symmetric) keys over insecure channels without needing
  # any prior joint knowledge between the participating parties. As the security
  # of DH demands relatively long "public keys" (i.e. the part that is overtly
  # transmitted between participants) DH tends to be quite slow. If security or
  # speed is your primary concern, OpenSSL::PKey::EC offers another implementation
  # of the Diffie-Hellman protocol.
  #
  module PKey
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkey.c
    #   - OpenSSL::PKey.read(string [, pwd ]) -> PKey
    #   - OpenSSL::PKey.read(io [, pwd ]) -> PKey
    # -->
    # Reads a DER or PEM encoded string from *string* or *io* and returns an
    # instance of the appropriate PKey class.
    #
    # ### Parameters
    # *   *string* is a DER- or PEM-encoded string containing an arbitrary private
    #     or public key.
    # *   *io* is an instance of IO containing a DER- or PEM-encoded arbitrary
    #     private or public key.
    # *   *pwd* is an optional password in case *string* or *io* is an encrypted PEM
    #     resource.
    #
    def self?.read: (String | IO pem, ?String password) -> PKey

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
    # An implementation of the Diffie-Hellman key exchange protocol based on
    # discrete logarithms in finite fields, the same basis that DSA is built on.
    #
    # ### Accessor methods for the Diffie-Hellman parameters
    # DH#p
    # :   The prime (an OpenSSL::BN) of the Diffie-Hellman parameters.
    #
    # DH#g
    # :   The generator (an OpenSSL::BN) g of the Diffie-Hellman parameters.
    #
    # DH#pub_key
    # :   The per-session public key (an OpenSSL::BN) matching the private key. This
    #     needs to be passed to DH#compute_key.
    #
    # DH#priv_key
    # :   The per-session private key, an OpenSSL::BN.
    #
    #
    # ### Example of a key exchange
    #     # you may send the parameters (der) and own public key (pub1) publicly
    #     # to the participating party
    #     dh1 = OpenSSL::PKey::DH.new(2048)
    #     der = dh1.to_der
    #     pub1 = dh1.pub_key
    #
    #     # the other party generates its per-session key pair
    #     dhparams = OpenSSL::PKey::DH.new(der)
    #     dh2 = OpenSSL::PKey.generate_key(dhparams)
    #     pub2 = dh2.pub_key
    #
    #     symm_key1 = dh1.compute_key(pub2)
    #     symm_key2 = dh2.compute_key(pub1)
    #     puts symm_key1 == symm_key2 # => true
    #
    class DH < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - DH.generate(size, generator = 2) -> dh
      # -->
      # Creates a new DH instance from scratch by generating random parameters and a
      # key pair.
      #
      # See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      #
      # `generator`
      # :   The generator.
      #
      def self.generate: (Integer size, ?Integer generator) -> instance

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.compute_key(pub_bn) -> string
      # -->
      # Returns a String containing a shared secret computed from the other party's
      # public value.
      #
      # This method is provided for backwards compatibility, and calls #derive
      # internally.
      #
      # ### Parameters
      # *   *pub_bn* is a OpenSSL::BN, **not** the DH instance returned by
      #     DH#public_key as that contains the DH parameters only.
      #
      def compute_key: (bn pub_bn) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.export -> aString
      #   - dh.to_pem -> aString
      #   - dh.to_s -> aString
      # -->
      # Serializes the DH parameters to a PEM-encoding.
      #
      # Note that any existing per-session public/private keys will **not** get
      # encoded, just the Diffie-Hellman parameters will be encoded.
      #
      # PEM-encoded parameters will look like:
      #
      #     -----BEGIN DH PARAMETERS-----
      #     [...]
      #     -----END DH PARAMETERS-----
      #
      # See also #public_to_pem (X.509 SubjectPublicKeyInfo) and #private_to_pem (PKCS
      # #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) for serialization with the
      # private or public key components.
      #
      def export: () -> String

      def g: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.generate_key! -> self
      # -->
      # Generates a private and public key unless a private key already exists. If
      # this DH instance was generated from public DH parameters (e.g. by encoding the
      # result of DH#public_key), then this method needs to be called first in order
      # to generate the per-session keys before performing the actual key exchange.
      #
      # **Deprecated in version 3.0**. This method is incompatible with OpenSSL 3.0.0
      # or later.
      #
      # See also OpenSSL::PKey.generate_key.
      #
      # Example:
      #     # DEPRECATED USAGE: This will not work on OpenSSL 3.0 or later
      #     dh0 = OpenSSL::PKey::DH.new(2048)
      #     dh = dh0.public_key # #public_key only copies the DH parameters (contrary to the name)
      #     dh.generate_key!
      #     puts dh.private? # => true
      #     puts dh0.pub_key == dh.pub_key #=> false
      #
      #     # With OpenSSL::PKey.generate_key
      #     dh0 = OpenSSL::PKey::DH.new(2048)
      #     dh = OpenSSL::PKey.generate_key(dh0)
      #     puts dh0.pub_key == dh.pub_key #=> false
      #
      def generate_key!: () -> self

      def p: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.params -> hash
      # -->
      # Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
      # LEAK OUT!!! Don't use :-)) (I's up to you)
      #
      def params: () -> Hash[String, BN]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.params_ok? -> true | false
      # -->
      # Validates the Diffie-Hellman parameters associated with this instance. It
      # checks whether a safe prime and a suitable generator are used. If this is not
      # the case, `false` is returned.
      #
      # See also the man page EVP_PKEY_param_check(3).
      #
      def params_ok?: () -> bool

      def priv_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.private? -> true | false
      # -->
      # Indicates whether this DH instance has a private key associated with it or
      # not. The private key may be retrieved with DH#priv_key.
      #
      def private?: () -> bool

      def pub_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.public? -> true | false
      # -->
      # Indicates whether this DH instance has a public key associated with it or not.
      # The public key may be retrieved with DH#pub_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.public_key -> dhnew
      # -->
      # Returns a new DH instance that carries just the DH parameters.
      #
      # Contrary to the method name, the returned DH object contains only parameters
      # and not the public key.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of re-generating the key pair while keeping the parameters,
      # check OpenSSL::PKey.generate_key.
      #
      # Example:
      #     # OpenSSL::PKey::DH.generate by default generates a random key pair
      #     dh1 = OpenSSL::PKey::DH.generate(2048)
      #     p dh1.priv_key #=> #<OpenSSL::BN 1288347...>
      #     dhcopy = dh1.public_key
      #     p dhcopy.priv_key #=> nil
      #
      def public_key: () -> instance

      def q: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.set_key(pub_key, priv_key) -> self
      # -->
      # Sets *pub_key* and *priv_key* for the DH instance. *priv_key* may be `nil`.
      #
      def set_key: (bn pub_key, bn? priv_key) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.set_pqg(p, q, g) -> self
      # -->
      # Sets *p*, *q*, *g* to the DH instance.
      #
      def set_pqg: (bn p, bn q, bn g) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.to_der -> aString
      # -->
      # Serializes the DH parameters to a DER-encoding
      #
      # Note that any existing per-session public/private keys will **not** get
      # encoded, just the Diffie-Hellman parameters will be encoded.
      #
      # See also #public_to_der (X.509 SubjectPublicKeyInfo) and #private_to_der (PKCS
      # #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) for serialization with the
      # private or public key components.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
      # Serializes the DH parameters to a PEM-encoding.
      #
      # Note that any existing per-session public/private keys will **not** get
      # encoded, just the Diffie-Hellman parameters will be encoded.
      #
      # PEM-encoded parameters will look like:
      #
      #     -----BEGIN DH PARAMETERS-----
      #     [...]
      #     -----END DH PARAMETERS-----
      #
      # See also #public_to_pem (X.509 SubjectPublicKeyInfo) and #private_to_pem (PKCS
      # #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) for serialization with the
      # private or public key components.
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
      # Serializes the DH parameters to a PEM-encoding.
      #
      # Note that any existing per-session public/private keys will **not** get
      # encoded, just the Diffie-Hellman parameters will be encoded.
      #
      # PEM-encoded parameters will look like:
      #
      #     -----BEGIN DH PARAMETERS-----
      #     [...]
      #     -----END DH PARAMETERS-----
      #
      # See also #public_to_pem (X.509 SubjectPublicKeyInfo) and #private_to_pem (PKCS
      # #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) for serialization with the
      # private or public key components.
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.to_text -> aString
      # -->
      # Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
      # OUT!!! Don't use :-)) (I's up to you)
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - DH.new -> dh
      #   - DH.new(string) -> dh
      #   - DH.new(size [, generator]) -> dh
      # -->
      # Creates a new instance of OpenSSL::PKey::DH.
      #
      # If called without arguments, an empty instance without any parameter or key
      # components is created. Use #set_pqg to manually set the parameters afterwards
      # (and optionally #set_key to set private and public key components).
      #
      # If a String is given, tries to parse it as a DER- or PEM- encoded parameters.
      # See also OpenSSL::PKey.read which can parse keys of any kinds.
      #
      # The DH.new(size [, generator]) form is an alias of DH.generate.
      #
      # `string`
      # :   A String that contains the DER or PEM encoded key.
      #
      # `size`
      # :   See DH.generate.
      #
      # `generator`
      # :   See DH.generate.
      #
      #
      # Examples:
      #     # Creating an instance from scratch
      #     # Note that this is deprecated and will not work on OpenSSL 3.0 or later.
      #     dh = OpenSSL::PKey::DH.new
      #     dh.set_pqg(bn_p, nil, bn_g)
      #
      #     # Generating a parameters and a key pair
      #     dh = OpenSSL::PKey::DH.new(2048) # An alias of OpenSSL::PKey::DH.generate(2048)
      #
      #     # Reading DH parameters
      #     dh_params = OpenSSL::PKey::DH.new(File.read('parameters.pem')) # loads parameters only
      #     dh = OpenSSL::PKey.generate_key(dh_params) # generates a key pair
      #
      def initialize: (Integer size, ?Integer generator) -> void
                    | (String pem) -> void
                    | () -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
    # Generic exception that is raised if an operation on a DH PKey fails
    # unexpectedly or in case an instantiation of an instance of DH fails due to
    # non-conformant input data.
    #
    class DHError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
    # DSA, the Digital Signature Algorithm, is specified in NIST's FIPS 186-3. It is
    # an asymmetric public key algorithm that may be used similar to e.g. RSA.
    #
    class DSA < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - DSA.generate(size) -> dsa
      # -->
      # Creates a new DSA instance by generating a private/public key pair from
      # scratch.
      #
      # See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      #
      def self.generate: (Integer size) -> instance

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.export([cipher, password]) -> aString
      #   - dsa.to_pem([cipher, password]) -> aString
      #   - dsa.to_s([cipher, password]) -> aString
      # -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a
      #     private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in
      #     OpenSSL's traditional PEM encryption format. *cipher* must be a cipher
      #     name understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # traditional, non-standard OpenSSL format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      def export: (String cipher, String password) -> String
                | () -> String

      def g: () -> BN

      def p: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.params -> hash
      # -->
      # Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
      # LEAK OUT!!! Don't use :-)) (I's up to you)
      #
      def params: () -> Hash[String, BN]

      def priv_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.private? -> true | false
      # -->
      # Indicates whether this DSA instance has a private key associated with it or
      # not. The private key may be retrieved with DSA#private_key.
      #
      def private?: () -> bool

      def pub_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.public? -> true | false
      # -->
      # Indicates whether this DSA instance has a public key associated with it or
      # not. The public key may be retrieved with DSA#public_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.public_key -> dsanew
      # -->
      # Returns a new DSA instance that carries just the DSA parameters and the public
      # key.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of serializing the public key, to PEM or DER encoding of X.509
      # SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.
      #
      def public_key: () -> instance

      def q: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.set_key(pub_key, priv_key) -> self
      # -->
      # Sets *pub_key* and *priv_key* for the DSA instance. *priv_key* may be `nil`.
      #
      def set_key: (bn pub_key, bn? priv_key) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.set_pqg(p, q, g) -> self
      # -->
      # Sets *p*, *q*, *g* to the DSA instance.
      #
      def set_pqg: (bn p, bn q, bn g) -> self

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.syssign(string) -> string
      # -->
      # Computes and returns the DSA signature of `string`, where `string` is expected
      # to be an already-computed message digest of the original input data. The
      # signature is issued using the private key of this DSA instance.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      # `string`
      # :   A message digest of the original input data to be signed.
      #
      #
      # Example:
      #     dsa = OpenSSL::PKey::DSA.new(2048)
      #     doc = "Sign me"
      #     digest = OpenSSL::Digest.digest('SHA1', doc)
      #
      #     # With legacy #syssign and #sysverify:
      #     sig = dsa.syssign(digest)
      #     p dsa.sysverify(digest, sig) #=> true
      #
      #     # With #sign_raw and #verify_raw:
      #     sig = dsa.sign_raw(nil, digest)
      #     p dsa.verify_raw(nil, sig, digest) #=> true
      #
      def syssign: (String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.sysverify(digest, sig) -> true | false
      # -->
      # Verifies whether the signature is valid given the message digest input. It
      # does so by validating `sig` using the public key of this DSA instance.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      # `digest`
      # :   A message digest of the original input data to be signed.
      #
      # `sig`
      # :   A DSA signature value.
      #
      def sysverify: (String digest, String data) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.to_der -> aString
      # -->
      # Serializes a private or public key to a DER-encoding.
      #
      # See #to_pem for details.
      #
      # **This method is kept for compatibility.** This should only be used when the
      # traditional, non-standard OpenSSL format is required.
      #
      # Consider using #public_to_der or #private_to_der instead.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a
      #     private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in
      #     OpenSSL's traditional PEM encryption format. *cipher* must be a cipher
      #     name understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # traditional, non-standard OpenSSL format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a
      #     private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in
      #     OpenSSL's traditional PEM encryption format. *cipher* must be a cipher
      #     name understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN DSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END DSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # traditional, non-standard OpenSSL format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.to_text -> aString
      # -->
      # Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
      # OUT!!! Don't use :-)) (I's up to you)
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - DSA.new -> dsa
      #   - DSA.new(string [, pass]) -> dsa
      #   - DSA.new(size) -> dsa
      # -->
      # Creates a new DSA instance by reading an existing key from *string*.
      #
      # If called without arguments, creates a new instance with no key components
      # set. They can be set individually by #set_pqg and #set_key.
      #
      # If called with a String, tries to parse as DER or PEM encoding of a DSA key.
      # See also OpenSSL::PKey.read which can parse keys of any kinds.
      #
      # If called with a number, generates random parameters and a key pair. This form
      # works as an alias of DSA.generate.
      #
      # `string`
      # :   A String that contains a DER or PEM encoded key.
      #
      # `pass`
      # :   A String that contains an optional password.
      #
      # `size`
      # :   See DSA.generate.
      #
      #
      # Examples:
      #     p OpenSSL::PKey::DSA.new(1024)
      #     #=> #<OpenSSL::PKey::DSA:0x000055a8d6025bf0 oid=DSA>
      #
      #     p OpenSSL::PKey::DSA.new(File.read('dsa.pem'))
      #     #=> #<OpenSSL::PKey::DSA:0x000055555d6b8110 oid=DSA>
      #
      #     p OpenSSL::PKey::DSA.new(File.read('dsa.pem'), 'mypassword')
      #     #=> #<OpenSSL::PKey::DSA:0x0000556f973c40b8 oid=DSA>
      #
      def initialize: (String pem, ?String pass) -> void
                    | (?Integer size) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
    # Generic exception that is raised if an operation on a DSA PKey fails
    # unexpectedly or in case an instantiation of an instance of DSA fails due to
    # non-conformant input data.
    #
    class DSAError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
    # OpenSSL::PKey::EC provides access to Elliptic Curve Digital Signature
    # Algorithm (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH).
    #
    # ### Key exchange
    #     ec1 = OpenSSL::PKey::EC.generate("prime256v1")
    #     ec2 = OpenSSL::PKey::EC.generate("prime256v1")
    #     # ec1 and ec2 have own private key respectively
    #     shared_key1 = ec1.dh_compute_key(ec2.public_key)
    #     shared_key2 = ec2.dh_compute_key(ec1.public_key)
    #
    #     p shared_key1 == shared_key2 #=> true
    #
    class EC < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - EC.builtin_curves => [[sn, comment], ...]
      # -->
      # Obtains a list of all predefined curves by the OpenSSL. Curve names are
      # returned as sn.
      #
      # See the OpenSSL documentation for EC_get_builtin_curves().
      #
      def self.builtin_curves: () -> Array[[ String, String ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - EC.generate(ec_group) -> ec
      #   - EC.generate(string) -> ec
      # -->
      # Creates a new EC instance with a new random private and public key.
      #
      def self.generate: (String | Group pem_or_der_or_group_or_curve_name) -> instance

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.check_key   => true
      # -->
      # Raises an exception if the key is invalid.
      #
      # See also the man page EVP_PKEY_public_check(3).
      #
      def check_key: () -> true

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - ec.dh_compute_key(pubkey) -> string
      # -->
      # Derives a shared secret by ECDH. *pubkey* must be an instance of
      # OpenSSL::PKey::EC::Point and must belong to the same group.
      #
      # This method is provided for backwards compatibility, and calls #derive
      # internally.
      #
      def dh_compute_key: (Point public_key) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - key.dsa_sign_asn1(data) -> String
      # -->
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      def dsa_sign_asn1: (String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - key.dsa_verify_asn1(data, sig) -> true | false
      # -->
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      def dsa_verify_asn1: (String digest, String signature) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.export([cipher, password]) => String
      #   - key.to_pem([cipher, password]) => String
      # -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a
      #     private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a SEC 1/RFC 5915 ECPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN EC PRIVATE KEY-----
      #         [...]
      #         -----END EC PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a SEC 1/RFC 5915 ECPrivateKey and encrypts it in
      #     OpenSSL's traditional PEM encryption format. *cipher* must be a cipher
      #     name understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN EC PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END EC PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # SEC 1/RFC 5915 ECPrivateKey format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      def export: (String cipher, String password) -> String
                | () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Generates a new random private and public key.
      #
      # See also the OpenSSL documentation for EC_KEY_generate_key()
      #
      # ### Example
      #     ec = OpenSSL::PKey::EC.new("prime256v1")
      #     p ec.private_key # => nil
      #     ec.generate_key!
      #     p ec.private_key # => #<OpenSSL::BN XXXXXX>
      #
      alias generate_key generate_key!

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.generate_key!   => self
      # -->
      # Generates a new random private and public key.
      #
      # See also the OpenSSL documentation for EC_KEY_generate_key()
      #
      # ### Example
      #     ec = OpenSSL::PKey::EC.new("prime256v1")
      #     p ec.private_key # => nil
      #     ec.generate_key!
      #     p ec.private_key # => #<OpenSSL::BN XXXXXX>
      #
      def generate_key!: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.group   => group
      # -->
      # Returns the EC::Group that the key is associated with. Modifying the returned
      # group does not affect *key*.
      #
      def group: () -> Group?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.group = group
      # -->
      # Sets the EC::Group for the key. The group structure is internally copied so
      # modification to *group* after assigning to a key has no effect on the key.
      #
      def group=: (Group) -> Group

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private? => true or false
      # -->
      # Returns whether this EC instance has a private key. The private key (BN) can
      # be retrieved with EC#private_key.
      #
      def private?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private_key   => OpenSSL::BN
      # -->
      # See the OpenSSL documentation for EC_KEY_get0_private_key()
      #
      def private_key: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private_key = openssl_bn
      # -->
      # See the OpenSSL documentation for EC_KEY_set_private_key()
      #
      def private_key=: (bn priv_key) -> self

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Returns whether this EC instance has a private key. The private key (BN) can
      # be retrieved with EC#private_key.
      #
      alias private_key? private?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public? => true or false
      # -->
      # Returns whether this EC instance has a public key. The public key (EC::Point)
      # can be retrieved with EC#public_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public_key   => OpenSSL::PKey::EC::Point
      # -->
      # See the OpenSSL documentation for EC_KEY_get0_public_key()
      #
      def public_key: () -> Point?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public_key = ec_point
      # -->
      # See the OpenSSL documentation for EC_KEY_set_public_key()
      #
      def public_key=: (bn priv_key) -> self

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Returns whether this EC instance has a public key. The public key (EC::Point)
      # can be retrieved with EC#public_key.
      #
      alias public_key? public?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.to_der   => String
      # -->
      # Serializes a private or public key to a DER-encoding.
      #
      # See #to_pem for details.
      #
      # **This method is kept for compatibility.** This should only be used when the
      # SEC 1/RFC 5915 ECPrivateKey format is required.
      #
      # Consider using #public_to_der or #private_to_der instead.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a
      #     private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a SEC 1/RFC 5915 ECPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN EC PRIVATE KEY-----
      #         [...]
      #         -----END EC PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a SEC 1/RFC 5915 ECPrivateKey and encrypts it in
      #     OpenSSL's traditional PEM encryption format. *cipher* must be a cipher
      #     name understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN EC PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END EC PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # SEC 1/RFC 5915 ECPrivateKey format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      alias to_pem export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.to_text   => String
      # -->
      # See the OpenSSL documentation for EC_KEY_print()
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - OpenSSL::PKey::EC.new
      #   - OpenSSL::PKey::EC.new(ec_key)
      #   - OpenSSL::PKey::EC.new(ec_group)
      #   - OpenSSL::PKey::EC.new("secp112r1")
      #   - OpenSSL::PKey::EC.new(pem_string [, pwd])
      #   - OpenSSL::PKey::EC.new(der_string)
      # -->
      # Creates a new EC object from given arguments.
      #
      def initialize: () -> void
                    | (instance ec_key) -> void
                    | (Group group) -> void
                    | (String pem_or_der_or_curve, ?String pass) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      EXPLICIT_CURVE: Integer

      NAMED_CURVE: Integer

      type ec_method = :GFp_simple | :GFp_mont | :GFp_nist | :GF2m_simple

      type point_conversion_format = :compressed | :uncompressed | :hybrid

      class Group
        # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
        # Returns `true` if the two groups use the same curve and have the same
        # parameters, `false` otherwise.
        #
        alias == eql?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.asn1_flag -> Integer
        # -->
        # Returns the flags set on the group.
        #
        # See also #asn1_flag=.
        #
        def asn1_flag: () -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.asn1_flag = flags
        # -->
        # Sets flags on the group. The flag value is used to determine how to encode the
        # group: encode explicit parameters or named curve using an OID.
        #
        # The flag value can be either of:
        #
        # *   EC::NAMED_CURVE
        # *   EC::EXPLICIT_CURVE
        #
        # See the OpenSSL documentation for EC_GROUP_set_asn1_flag().
        #
        def asn1_flag=: (Integer) -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.get_cofactor   => cofactor_bn
        # -->
        # Returns the cofactor of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get_cofactor()
        #
        def cofactor: () -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.curve_name  => String
        # -->
        # Returns the curve name (sn).
        #
        # See the OpenSSL documentation for EC_GROUP_get_curve_name()
        #
        def curve_name: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.degree   => integer
        # -->
        # See the OpenSSL documentation for EC_GROUP_get_degree()
        #
        def degree: () -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group1.eql?(group2)   => true | false
        #   - group1 == group2   => true | false
        # -->
        # Returns `true` if the two groups use the same curve and have the same
        # parameters, `false` otherwise.
        #
        def eql?: (instance other) -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.generator   => ec_point
        # -->
        # Returns the generator of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get0_generator()
        #
        def generator: () -> Point?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.get_order   => order_bn
        # -->
        # Returns the order of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get_order()
        #
        def order: () -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.point_conversion_form -> Symbol
        # -->
        # Returns the form how EC::Point data is encoded as ASN.1.
        #
        # See also #point_conversion_form=.
        #
        def point_conversion_form: () -> point_conversion_format

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.point_conversion_form = form
        # -->
        # Sets the form how EC::Point data is encoded as ASN.1 as defined in X9.62.
        #
        # *format* can be one of these:
        #
        # `:compressed`
        # :   Encoded as z||x, where z is an octet indicating which solution of the
        #     equation y is. z will be 0x02 or 0x03.
        #
        # `:uncompressed`
        # :   Encoded as z||x||y, where z is an octet 0x04.
        #
        # `:hybrid`
        # :   Encodes as z||x||y, where z is an octet indicating which solution of the
        #     equation y is. z will be 0x06 or 0x07.
        #
        #
        # See the OpenSSL documentation for EC_GROUP_set_point_conversion_form()
        #
        def point_conversion_form=: (point_conversion_format format) -> point_conversion_format

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.seed   => String or nil
        # -->
        # See the OpenSSL documentation for EC_GROUP_get0_seed()
        #
        def seed: () -> String?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.seed = seed  => seed
        # -->
        # See the OpenSSL documentation for EC_GROUP_set_seed()
        #
        def seed=: (String seed) -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.set_generator(generator, order, cofactor)   => self
        # -->
        # Sets the curve parameters. *generator* must be an instance of EC::Point that
        # is on the curve. *order* and *cofactor* are integers.
        #
        # See the OpenSSL documentation for EC_GROUP_set_generator()
        #
        def set_generator: (Point generator, Integer order, Integer cofactor) -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_der   => String
        # -->
        # See the OpenSSL documentation for i2d_ECPKParameters_bio()
        #
        def to_der: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_pem   => String
        # -->
        # See the OpenSSL documentation for PEM_write_bio_ECPKParameters()
        #
        def to_pem: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_text   => String
        # -->
        # See the OpenSSL documentation for ECPKParameters_print()
        #
        def to_text: () -> String

        private

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - OpenSSL::PKey::EC::Group.new(ec_group)
        #   - OpenSSL::PKey::EC::Group.new(pem_or_der_encoded)
        #   - OpenSSL::PKey::EC::Group.new(:GFp, bignum_p, bignum_a, bignum_b)
        #   - OpenSSL::PKey::EC::Group.new(:GF2m, bignum_p, bignum_a, bignum_b)
        # -->
        # Creates a new EC::Group object.
        #
        # If the first argument is :GFp or :GF2m, creates a new curve with given
        # parameters.
        #
        def initialize: (instance group) -> void
                      | (String pem_or_der_encoded) -> void
                      | (ec_method ec_method) -> void
                      | (:GFp | :GF2m ec_method, Integer bignum_p, Integer bignum_a, Integer bignum_b) -> void

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - initialize_copy(p1)
        # -->
        #
        def initialize_copy: (instance) -> void

        class Error < OpenSSL::OpenSSLError
        end
      end

      class Point
        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - ==(p1)
        # -->
        #
        alias == eql?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.add(point) => point
        # -->
        # Performs elliptic curve point addition.
        #
        def add: (instance point) -> instance

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point1.eql?(point2) => true | false
        #   - point1 == point2 => true | false
        # -->
        #
        def eql?: (instance other) -> bool

        def group: () -> Group

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.infinity? => true | false
        # -->
        #
        def infinity?: () -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.invert! => self
        # -->
        #
        def invert!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.make_affine! => self
        # -->
        # This method is deprecated and should not be used. This is a no-op.
        #
        def make_affine!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.mul(bn1 [, bn2]) => point
        #   - point.mul(bns, points [, bn2]) => point
        # -->
        # Performs elliptic curve point multiplication.
        #
        # The first form calculates `bn1 * point + bn2 * G`, where `G` is the generator
        # of the group of *point*. *bn2* may be omitted, and in that case, the result is
        # just `bn1 * point`.
        #
        # The second form calculates `bns[0] * point + bns[1] * points[0] + ... +
        # bns[-1] * points[-1] + bn2 * G`. *bn2* may be omitted. *bns* must be an array
        # of OpenSSL::BN. *points* must be an array of OpenSSL::PKey::EC::Point. Please
        # note that `points[0]` is not multiplied by `bns[0]`, but `bns[1]`.
        #
        def mul: (bn bn1, ?bn bn2) -> instance
               | (Array[bn] bns, Array[instance], ?bn bn2) -> instance

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.on_curve? => true | false
        # -->
        #
        def on_curve?: () -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.set_to_infinity! => self
        # -->
        #
        def set_to_infinity!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
        #   - point.to_bn([conversion_form]) -> OpenSSL::BN
        # -->
        # Returns the octet string representation of the EC point as an instance of
        # OpenSSL::BN.
        #
        # If *conversion_form* is not given, the *point_conversion_form* attribute set
        # to the group is used.
        #
        # See #to_octet_string for more information.
        #
        def to_bn: (?point_conversion_format conversion_form) -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.to_octet_string(conversion_form) -> String
        # -->
        # Returns the octet string representation of the elliptic curve point.
        #
        # *conversion_form* specifies how the point is converted. Possible values are:
        #
        # *   `:compressed`
        # *   `:uncompressed`
        # *   `:hybrid`
        #
        def to_octet_string: (point_conversion_format) -> String

        private

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - OpenSSL::PKey::EC::Point.new(point)
        #   - OpenSSL::PKey::EC::Point.new(group [, encoded_point])
        # -->
        # Creates a new instance of OpenSSL::PKey::EC::Point. If the only argument is an
        # instance of EC::Point, a copy is returned. Otherwise, creates a point that
        # belongs to *group*.
        #
        # *encoded_point* is the octet string representation of the point. This must be
        # either a String or an OpenSSL::BN.
        #
        def initialize: (instance point) -> void
                      | (Group group, ?String | BN encoded_point) -> void

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - initialize_copy(p1)
        # -->
        #
        def initialize_copy: (instance) -> void

        class Error < OpenSSL::OpenSSLError
        end
      end
    end

    class ECError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
    # An abstract class that bundles signature creation (PKey#sign) and validation
    # (PKey#verify) that is common to all implementations except OpenSSL::PKey::DH
    # *   OpenSSL::PKey::RSA
    # *   OpenSSL::PKey::DSA
    # *   OpenSSL::PKey::EC
    #
    class PKey
      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.inspect -> string
      # -->
      # Returns a string describing the PKey object.
      #
      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.oid -> string
      # -->
      # Returns the short name of the OID associated with *pkey*.
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.private_to_der                   -> string
      #   - pkey.private_to_der(cipher, password) -> string
      # -->
      # Serializes the private key to DER-encoded PKCS #8 format. If called without
      # arguments, unencrypted PKCS #8 PrivateKeyInfo format is used. If called with a
      # cipher name and a password, PKCS #8 EncryptedPrivateKeyInfo format with PBES2
      # encryption scheme is used.
      #
      def private_to_der: (String cipher, String password) -> String
                        | () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.private_to_pem                   -> string
      #   - pkey.private_to_pem(cipher, password) -> string
      # -->
      # Serializes the private key to PEM-encoded PKCS #8 format. See #private_to_der
      # for more details.
      #
      # An unencrypted PEM-encoded key will look like:
      #
      #     -----BEGIN PRIVATE KEY-----
      #     [...]
      #     -----END PRIVATE KEY-----
      #
      # An encrypted PEM-encoded key will look like:
      #
      #     -----BEGIN ENCRYPTED PRIVATE KEY-----
      #     [...]
      #     -----END ENCRYPTED PRIVATE KEY-----
      #
      def private_to_pem: (String cipher, String password) -> String
                        | () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.public_to_der -> string
      # -->
      # Serializes the public key to DER-encoded X.509 SubjectPublicKeyInfo format.
      #
      def public_to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.public_to_pem -> string
      # -->
      # Serializes the public key to PEM-encoded X.509 SubjectPublicKeyInfo format.
      #
      # A PEM-encoded key will look like:
      #
      #     -----BEGIN PUBLIC KEY-----
      #     [...]
      #     -----END PUBLIC KEY-----
      #
      def public_to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.sign(digest, data [, options]) -> string
      # -->
      # Hashes and signs the `data` using a message digest algorithm `digest` and a
      # private key `pkey`.
      #
      # See #verify for the verification operation.
      #
      # See also the man page EVP_DigestSign(3).
      #
      # `digest`
      # :   A String that represents the message digest algorithm name, or `nil` if
      #     the PKey type requires no digest algorithm. For backwards compatibility,
      #     this can be an instance of OpenSSL::Digest. Its state will not affect the
      #     signature.
      #
      # `data`
      # :   A String. The data to be hashed and signed.
      #
      # `options`
      # :   A Hash that contains algorithm specific control operations to OpenSSL. See
      #     OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details. `options`
      #     parameter was added in version 3.0.
      #
      #
      # Example:
      #     data = "Sign me!"
      #     pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
      #     signopts = { rsa_padding_mode: "pss" }
      #     signature = pkey.sign("SHA256", data, signopts)
      #
      #     # Creates a copy of the RSA key pkey, but without the private components
      #     pub_key = pkey.public_key
      #     puts pub_key.verify("SHA256", signature, data, signopts) # => true
      #
      def sign: (Digest digest, String data) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.verify(digest, signature, data [, options]) -> true or false
      # -->
      # Verifies the `signature` for the `data` using a message digest algorithm
      # `digest` and a public key `pkey`.
      #
      # Returns `true` if the signature is successfully verified, `false` otherwise.
      # The caller must check the return value.
      #
      # See #sign for the signing operation and an example.
      #
      # See also the man page EVP_DigestVerify(3).
      #
      # `digest`
      # :   See #sign.
      #
      # `signature`
      # :   A String containing the signature to be verified.
      #
      # `data`
      # :   See #sign.
      #
      # `options`
      # :   See #sign. `options` parameter was added in version 3.0.
      #
      def verify: (Digest digest, String signature, String data) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - PKeyClass.new -> self
      # -->
      # Because PKey is an abstract class, actually calling this method explicitly
      # will raise a NotImplementedError.
      #
      def initialize: () -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
    # Raised when errors occur during PKey#sign or PKey#verify.
    #
    class PKeyError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
    # RSA is an asymmetric public key algorithm that has been formalized in RFC
    # 3447. It is in widespread use in public key infrastructures (PKI) where
    # certificates (cf. OpenSSL::X509::Certificate) often are issued on the basis of
    # a public/private RSA key pair. RSA is used in a wide field of applications
    # such as secure (symmetric) key exchange, e.g. when establishing a secure
    # TLS/SSL connection. It is also used in various digital signature schemes.
    #
    class RSA < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - RSA.generate(size, exponent = 65537) -> RSA
      # -->
      # Generates an RSA keypair.
      #
      # See also OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      #
      # `exponent`
      # :   An odd Integer, normally 3, 17, or 65537.
      #
      def self.generate: (Integer size, ?Integer exponent) -> instance

      def d: () -> BN?

      def dmp1: () -> BN?

      def dmq1: () -> BN?

      def e: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.export([cipher, password]) => PEM-format String
      #   - rsa.to_pem([cipher, password]) => PEM-format String
      #   - rsa.to_s([cipher, password]) => PEM-format String
      # -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether the key is a public key
      #     or a private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey and encrypts it in OpenSSL's
      #     traditional PEM encryption format. *cipher* must be a cipher name
      #     understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # PKCS #1 RSAPrivateKey format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      def export: (String cipher, String password) -> String
                | () -> String

      def iqmp: () -> BN?

      def n: () -> BN?

      def p: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.params => hash
      # -->
      # THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!
      #
      # Stores all parameters of key to the hash.  The hash has keys 'n', 'e', 'd',
      # 'p', 'q', 'dmp1', 'dmq1', 'iqmp'.
      #
      # Don't use :-)) (It's up to you)
      #
      def params: () -> Hash[String, BN]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.private? => true | false
      # -->
      # Does this keypair contain a private key?
      #
      def private?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.private_decrypt(string)          -> String
      #   - rsa.private_decrypt(string, padding) -> String
      # -->
      # Decrypt `string`, which has been encrypted with the public key, with the
      # private key. `padding` defaults to PKCS1_PADDING, which is known to be
      # insecure but is kept for backwards compatibility.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
      # PKey::PKey#decrypt instead.
      #
      def private_decrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.private_encrypt(string)          -> String
      #   - rsa.private_encrypt(string, padding) -> String
      # -->
      # Encrypt `string` with the private key.  `padding` defaults to PKCS1_PADDING,
      # which is known to be insecure but is kept for backwards compatibility. The
      # encrypted string output can be decrypted using #public_decrypt.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.
      #
      def private_encrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.public? => true
      # -->
      # The return value is always `true` since every private key is also a public
      # key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_decrypt(string)          -> String
      #   - rsa.public_decrypt(string, padding) -> String
      # -->
      # Decrypt `string`, which has been encrypted with the private key, with the
      # public key.  `padding` defaults to PKCS1_PADDING which is known to be insecure
      # but is kept for backwards compatibility.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.
      #
      def public_decrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_encrypt(string)          -> String
      #   - rsa.public_encrypt(string, padding) -> String
      # -->
      # Encrypt `string` with the public key.  `padding` defaults to PKCS1_PADDING,
      # which is known to be insecure but is kept for backwards compatibility. The
      # encrypted string output can be decrypted using #private_decrypt.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
      # PKey::PKey#decrypt instead.
      #
      def public_encrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_key -> rsanew
      # -->
      # Returns a new RSA instance that carries just the public key components.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of serializing the public key, to PEM or DER encoding of X.509
      # SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.
      #
      def public_key: () -> instance

      def q: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_crt_params(dmp1, dmq1, iqmp) -> self
      # -->
      # Sets *dmp1*, *dmq1*, *iqmp* for the RSA instance. They are calculated by `d
      # mod (p - 1)`, `d mod (q - 1)` and `q^(-1) mod p` respectively.
      #
      def set_crt_params: (bn dmp1, bn dmq1, bn iqmp) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_factors(p, q) -> self
      # -->
      # Sets *p*, *q* for the RSA instance.
      #
      def set_factors: (bn p, bn q) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_key(n, e, d) -> self
      # -->
      # Sets *n*, *e*, *d* for the RSA instance.
      #
      def set_key: (bn n, bn e, bn d) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.sign_pss(digest, data, salt_length:, mgf1_hash:) -> String
      # -->
      # Signs *data* using the Probabilistic Signature Scheme (RSA-PSS) and returns
      # the calculated signature.
      #
      # RSAError will be raised if an error occurs.
      #
      # See #verify_pss for the verification operation.
      #
      # ### Parameters
      # *digest*
      # :   A String containing the message digest algorithm name.
      #
      # *data*
      # :   A String. The data to be signed.
      #
      # *salt_length*
      # :   The length in octets of the salt. Two special values are reserved:
      #     `:digest` means the digest length, and `:max` means the maximum possible
      #     length for the combination of the private key and the selected message
      #     digest algorithm.
      #
      # *mgf1_hash*
      # :   The hash algorithm used in MGF1 (the currently supported mask generation
      #     function (MGF)).
      #
      #
      # ### Example
      #     data = "Sign me!"
      #     pkey = OpenSSL::PKey::RSA.new(2048)
      #     signature = pkey.sign_pss("SHA256", data, salt_length: :max, mgf1_hash: "SHA256")
      #     pub_key = OpenSSL::PKey.read(pkey.public_to_der)
      #     puts pub_key.verify_pss("SHA256", signature, data,
      #                             salt_length: :auto, mgf1_hash: "SHA256") # => true
      #
      def sign_pss: (String digest, String data, salt_length: :digest | :max | Integer, mgf1_hash: String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.to_der => DER-format String
      # -->
      # Serializes a private or public key to a DER-encoding.
      #
      # See #to_pem for details.
      #
      # **This method is kept for compatibility.** This should only be used when the
      # PKCS #1 RSAPrivateKey format is required.
      #
      # Consider using #public_to_der or #private_to_der instead.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether the key is a public key
      #     or a private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey and encrypts it in OpenSSL's
      #     traditional PEM encryption format. *cipher* must be a cipher name
      #     understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # PKCS #1 RSAPrivateKey format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
      # Serializes a private or public key to a PEM-encoding.
      #
      # When the key contains public components only
      # :   Serializes it into an X.509 SubjectPublicKeyInfo. The parameters *cipher*
      #     and *password* are ignored.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN PUBLIC KEY-----
      #         [...]
      #         -----END PUBLIC KEY-----
      #
      #     Consider using #public_to_pem instead. This serializes the key into an
      #     X.509 SubjectPublicKeyInfo regardless of whether the key is a public key
      #     or a private key.
      #
      #
      # When the key contains private components, and no parameters are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey.
      #
      #     A PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #
      # When the key contains private components, and *cipher* and *password* are given
      # :   Serializes it into a PKCS #1 RSAPrivateKey and encrypts it in OpenSSL's
      #     traditional PEM encryption format. *cipher* must be a cipher name
      #     understood by OpenSSL::Cipher.new or an instance of OpenSSL::Cipher.
      #
      #     An encrypted PEM-encoded key will look like:
      #
      #         -----BEGIN RSA PRIVATE KEY-----
      #         Proc-Type: 4,ENCRYPTED
      #         DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
      #
      #         [...]
      #         -----END RSA PRIVATE KEY-----
      #
      #     Note that this format uses MD5 to derive the encryption key, and hence
      #     will not be available on FIPS-compliant systems.
      #
      #
      # **This method is kept for compatibility.** This should only be used when the
      # PKCS #1 RSAPrivateKey format is required.
      #
      # Consider using #public_to_pem (X.509 SubjectPublicKeyInfo) or #private_to_pem
      # (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.to_text => String
      # -->
      # THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!
      #
      # Dumps all parameters of a keypair to a String
      #
      # Don't use :-)) (It's up to you)
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.verify_pss(digest, signature, data, salt_length:, mgf1_hash:) -> true | false
      # -->
      # Verifies *data* using the Probabilistic Signature Scheme (RSA-PSS).
      #
      # The return value is `true` if the signature is valid, `false` otherwise.
      # RSAError will be raised if an error occurs.
      #
      # See #sign_pss for the signing operation and an example code.
      #
      # ### Parameters
      # *digest*
      # :   A String containing the message digest algorithm name.
      #
      # *data*
      # :   A String. The data to be signed.
      #
      # *salt_length*
      # :   The length in octets of the salt. Two special values are reserved:
      #     `:digest` means the digest length, and `:auto` means automatically
      #     determining the length based on the signature.
      #
      # *mgf1_hash*
      # :   The hash algorithm used in MGF1.
      #
      def verify_pss: (String digest, String signature, String data, salt_length: :auto | :digest | Integer, mgf1_hash: String) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - RSA.new -> rsa
      #   - RSA.new(encoded_key [, password ]) -> rsa
      #   - RSA.new(encoded_key) { password } -> rsa
      #   - RSA.new(size [, exponent]) -> rsa
      # -->
      # Generates or loads an RSA keypair.
      #
      # If called without arguments, creates a new instance with no key components
      # set. They can be set individually by #set_key, #set_factors, and
      # #set_crt_params.
      #
      # If called with a String, tries to parse as DER or PEM encoding of an RSA key.
      # Note that if *password* is not specified, but the key is encrypted with a
      # password, OpenSSL will prompt for it. See also OpenSSL::PKey.read which can
      # parse keys of any kind.
      #
      # If called with a number, generates a new key pair. This form works as an alias
      # of RSA.generate.
      #
      # Examples:
      #     OpenSSL::PKey::RSA.new 2048
      #     OpenSSL::PKey::RSA.new File.read 'rsa.pem'
      #     OpenSSL::PKey::RSA.new File.read('rsa.pem'), 'my password'
      #
      def initialize: () -> void
                    | (Integer key_size) -> void
                    | (String encoded_key, ?String pass_phrase) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      NO_PADDING: Integer

      PKCS1_OAEP_PADDING: Integer

      PKCS1_PADDING: Integer

      SSLV23_PADDING: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
    # Generic exception that is raised if an operation on an RSA PKey fails
    # unexpectedly or in case an instantiation of an instance of RSA fails due to
    # non-conformant input data.
    #
    class RSAError < OpenSSL::PKey::PKeyError
    end
  end

  module Random
    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - load_random_file(filename) -> true
    # -->
    # Reads bytes from *filename* and adds them to the PRNG.
    #
    def self.load_random_file: (String filename) -> true

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - add(str, entropy) -> self
    # -->
    # Mixes the bytes from *str* into the Pseudo Random Number Generator(PRNG)
    # state.
    #
    # Thus, if the data from *str* are unpredictable to an adversary, this increases
    # the uncertainty about the state and makes the PRNG output less predictable.
    #
    # The *entropy* argument is (the lower bound of) an estimate of how much
    # randomness is contained in *str*, measured in bytes.
    #
    # ### Example
    #
    #     pid = $$
    #     now = Time.now
    #     ary = [now.to_i, now.nsec, 1000, pid]
    #     OpenSSL::Random.add(ary.join, 0.0)
    #     OpenSSL::Random.seed(ary.join)
    #
    def self.random_add: (String str, Numeric entropy) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - random_bytes(length) -> string
    # -->
    # Generates a String with *length* number of cryptographically strong
    # pseudo-random bytes.
    #
    # ### Example
    #
    #     OpenSSL::Random.random_bytes(12)
    #     #=> "..."
    #
    def self.random_bytes: (Integer length) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - seed(str) -> str
    # -->
    # ::seed is equivalent to ::add where *entropy* is length of *str*.
    #
    def self.seed: (String seed) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - status? => true | false
    # -->
    # Return `true` if the PRNG has been seeded with enough data, `false` otherwise.
    #
    def self.status?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - write_random_file(filename) -> true
    # -->
    # Writes a number of random generated bytes (currently 1024) to *filename* which
    # can be used to initialize the PRNG by calling ::load_random_file in a later
    # session.
    #
    def self.write_random_file: (String filename) -> true

    class RandomError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
  # Use SSLContext to set up the parameters for a TLS (former SSL) connection.
  # Both client and server TLS connections are supported, SSLSocket and SSLServer
  # may be used in conjunction with an instance of SSLContext to set up
  # connections.
  #
  module SSL
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
    #   - verify_certificate_identity(cert, hostname)
    # -->
    #
    def self.verify_certificate_identity: (X509::Certificate cert, String hostname) -> bool

    def self.verify_hostname: (String hostname, String san) -> bool

    def self.verify_wildcard: (String domain_component, String san_component) -> bool

    OP_ALL: Integer

    OP_ALLOW_NO_DHE_KEX: Integer

    OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: Integer

    OP_CIPHER_SERVER_PREFERENCE: Integer

    OP_CRYPTOPRO_TLSEXT_BUG: Integer

    OP_DONT_INSERT_EMPTY_FRAGMENTS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1k and 1.0.2.
    #
    OP_EPHEMERAL_RSA: Integer

    OP_LEGACY_SERVER_CONNECT: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_MICROSOFT_BIG_SSLV3_BUFFER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_MICROSOFT_SESS_ID_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 0.9.7h and 0.9.8b.
    #
    OP_MSIE_SSLV2_RSA_PADDING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_CA_DN_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_CHALLENGE_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 0.9.8q and 1.0.0c.
    #
    OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: Integer

    OP_NO_COMPRESSION: Integer

    OP_NO_ENCRYPT_THEN_MAC: Integer

    OP_NO_RENEGOTIATION: Integer

    OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NO_SSLv2: Integer

    OP_NO_SSLv3: Integer

    OP_NO_TICKET: Integer

    OP_NO_TLSv1: Integer

    OP_NO_TLSv1_1: Integer

    OP_NO_TLSv1_2: Integer

    OP_NO_TLSv1_3: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1.
    #
    OP_PKCS1_CHECK_1: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1.
    #
    OP_PKCS1_CHECK_2: Integer

    OP_SAFARI_ECDHE_ECDSA_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SINGLE_DH_USE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SINGLE_ECDH_USE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SSLEAY_080_CLIENT_DH_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1h and 1.0.2.
    #
    OP_SSLREF2_REUSE_CERT_TYPE_BUG: Integer

    OP_TLSEXT_PADDING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_TLS_BLOCK_PADDING_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_TLS_D5_BUG: Integer

    OP_TLS_ROLLBACK_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # SSL 2.0
    #
    SSL2_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # SSL 3.0
    #
    SSL3_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.1
    #
    TLS1_1_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.2
    #
    TLS1_2_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.3
    #
    TLS1_3_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.0
    #
    TLS1_VERSION: Integer

    VERIFY_CLIENT_ONCE: Integer

    VERIFY_FAIL_IF_NO_PEER_CERT: Integer

    VERIFY_NONE: Integer

    VERIFY_PEER: Integer

    type tls_version = Symbol | Integer

    type verify_mode = Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # An SSLContext is used to set various options regarding certificates,
    # algorithms, verification, session caching, etc.  The SSLContext is used to
    # create an SSLSocket.
    #
    # All attributes must be set before creating an SSLSocket as the SSLContext will
    # be frozen afterward.
    #
    class SSLContext
      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.add_certificate(certificate, pkey [, extra_certs]) -> self
      # -->
      # Adds a certificate to the context. *pkey* must be a corresponding private key
      # with *certificate*.
      #
      # Multiple certificates with different public key type can be added by repeated
      # calls of this method, and OpenSSL will choose the most appropriate certificate
      # during the handshake.
      #
      # #cert=, #key=, and #extra_chain_cert= are old accessor methods for setting
      # certificate and internally call this method.
      #
      # ### Parameters
      # *certificate*
      # :   A certificate. An instance of OpenSSL::X509::Certificate.
      #
      # *pkey*
      # :   The private key for *certificate*. An instance of OpenSSL::PKey::PKey.
      #
      # *extra_certs*
      # :   Optional. An array of OpenSSL::X509::Certificate. When sending a
      #     certificate chain, the certificates specified by this are sent following
      #     *certificate*, in the order in the array.
      #
      #
      # ### Example
      #     rsa_cert = OpenSSL::X509::Certificate.new(...)
      #     rsa_pkey = OpenSSL::PKey.read(...)
      #     ca_intermediate_cert = OpenSSL::X509::Certificate.new(...)
      #     ctx.add_certificate(rsa_cert, rsa_pkey, [ca_intermediate_cert])
      #
      #     ecdsa_cert = ...
      #     ecdsa_pkey = ...
      #     another_ca_cert = ...
      #     ctx.add_certificate(ecdsa_cert, ecdsa_pkey, [another_ca_cert])
      #
      def add_certificate: (X509::Certificate certificate, PKey::PKey pkey, ?Array[X509::Certificate] extra_certs) -> self

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Application-Layer Protocol Negotiation.
      # Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
      # not set explicitly, the ALPN extension will not be included in the handshake.
      #
      # ### Example
      #
      #     ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      #
      def alpn_protocols: () -> Array[String]?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Application-Layer Protocol Negotiation.
      # Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
      # not set explicitly, the ALPN extension will not be included in the handshake.
      #
      # ### Example
      #
      #     ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      #
      def alpn_protocols=: (Array[String]) -> Array[String]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the server side when the server needs to select a
      # protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
      # higher. The callback must return a protocol of those advertised by the client.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the ALPN extension on the server - any protocols advertised by the client will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.alpn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def alpn_select_cb: () -> (^(Array[String]) -> String? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the server side when the server needs to select a
      # protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
      # higher. The callback must return a protocol of those advertised by the client.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the ALPN extension on the server - any protocols advertised by the client will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.alpn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def alpn_select_cb=: (^(Array[String]) -> String? alpn_select_callback) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a file containing a PEM-format CA certificate
      #
      def ca_file: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a file containing a PEM-format CA certificate
      #
      def ca_file=: (String ca_file) -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a directory containing CA certificates in PEM format.
      #
      # Files are looked up by subject's X509 name's hash value.
      #
      def ca_path: () -> String?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a directory containing CA certificates in PEM format.
      #
      # Files are looked up by subject's X509 name's hash value.
      #
      def ca_path=: (String ca_path) -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context certificate
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def cert: () -> X509::Certificate?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context certificate
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def cert=: (X509::Certificate cert) -> X509::Certificate

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An OpenSSL::X509::Store used for certificate verification.
      #
      def cert_store: () -> X509::Store?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An OpenSSL::X509::Store used for certificate verification.
      #
      def cert_store=: (X509::Store store) -> X509::Store

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ciphers => [[name, version, bits, alg_bits], ...]
      # -->
      # The list of cipher suites configured for this context.
      #
      def ciphers: () -> Array[[ String, String, Integer, Integer ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ciphers = "cipher1:cipher2:..."
      #   - ctx.ciphers = [name, ...]
      #   - ctx.ciphers = [[name, version, bits, alg_bits], ...]
      # -->
      # Sets the list of available cipher suites for this context.  Note in a server
      # context some ciphers require the appropriate certificates.  For example, an
      # RSA cipher suite can only be chosen when an RSA certificate is available.
      #
      def ciphers=: (Array[[ String, String, Integer, Integer ]] ciphers) -> void
                  | (Array[String] ciphers) -> void
                  | (String colon_sep_ciphers) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A certificate or Array of certificates that will be sent to the client.
      #
      def client_ca: () -> (Array[X509::Certificate] | X509::Certificate)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A certificate or Array of certificates that will be sent to the client.
      #
      def client_ca=: (Array[X509::Certificate] | X509::Certificate client_ca) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a client certificate is requested by a server and no
      # certificate has been set.
      #
      # The callback is invoked with a Session and must return an Array containing an
      # OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
      # returned the handshake is suspended.
      #
      def client_cert_cb: () -> (^(Session) -> [ X509::Certificate, PKey::PKey ]? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a client certificate is requested by a server and no
      # certificate has been set.
      #
      # The callback is invoked with a Session and must return an Array containing an
      # OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
      # returned the handshake is suspended.
      #
      def client_cert_cb=: (^(Session) -> [ X509::Certificate, PKey::PKey ]? client_cert_cb) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ecdh_curves = curve_list -> curve_list
      # -->
      # Sets the list of "supported elliptic curves" for this context.
      #
      # For a TLS client, the list is directly used in the Supported Elliptic Curves
      # Extension. For a server, the list is used by OpenSSL to determine the set of
      # shared curves. OpenSSL will pick the most appropriate one from it.
      #
      # ### Example
      #     ctx1 = OpenSSL::SSL::SSLContext.new
      #     ctx1.ecdh_curves = "X25519:P-256:P-224"
      #     svr = OpenSSL::SSL::SSLServer.new(tcp_svr, ctx1)
      #     Thread.new { svr.accept }
      #
      #     ctx2 = OpenSSL::SSL::SSLContext.new
      #     ctx2.ecdh_curves = "P-256"
      #     cli = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx2)
      #     cli.connect
      #
      #     p cli.tmp_key.group.curve_name
      #     # => "prime256v1" (is an alias for NIST P-256)
      #
      def ecdh_curves=: (String ecdh_curves) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.enable_fallback_scsv() => nil
      # -->
      # Activate TLS_FALLBACK_SCSV for this context. See RFC 7507.
      #
      def enable_fallback_scsv: () -> nil

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Array of extra X509 certificates to be added to the certificate chain.
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def extra_chain_cert: () -> Array[X509::Certificate]?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Array of extra X509 certificates to be added to the certificate chain.
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def extra_chain_cert=: (Array[X509::Certificate] extra_certs) -> Array[X509::Certificate]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.flush_sessions(time) -> self
      # -->
      # Removes sessions in the internal cache that have expired at *time*.
      #
      def flush_sessions: (Time time) -> self

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # This method is called automatically when a new SSLSocket is created. However,
      # it is not thread-safe and must be called before creating SSLSocket objects in
      # a multi-threaded program.
      #
      alias freeze setup

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context private key
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def key: () -> PKey::PKey?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context private key
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def key=: (PKey::PKey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
      #   - ctx.max_version = :TLS1_2
      #   - ctx.max_version = nil
      # -->
      # Sets the upper bound of the supported SSL/TLS protocol version. See
      # #min_version= for the possible values.
      #
      def max_version=: (tls_version version) -> tls_version

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.min_version = OpenSSL::SSL::TLS1_2_VERSION
      #   - ctx.min_version = :TLS1_2
      #   - ctx.min_version = nil
      # -->
      # Sets the lower bound on the supported SSL/TLS protocol version. The version
      # may be specified by an integer constant named OpenSSL::SSL::*_VERSION, a
      # Symbol, or `nil` which means "any version".
      #
      # Be careful that you don't overwrite OpenSSL::SSL::OP_NO_{SSL,TLS}v* options by
      # #options= once you have called #min_version= or #max_version=.
      #
      # ### Example
      #     ctx = OpenSSL::SSL::SSLContext.new
      #     ctx.min_version = OpenSSL::SSL::TLS1_1_VERSION
      #     ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
      #
      #     sock = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx)
      #     sock.connect # Initiates a connection using either TLS 1.1 or TLS 1.2
      #
      def min_version=: (tls_version version) -> tls_version

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Next Protocol Negotiation. Supported in
      # OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
      # explicitly, the NPN extension will not be sent by the server in the handshake.
      #
      # ### Example
      #
      #     ctx.npn_protocols = ["http/1.1", "spdy/2"]
      #
      def npn_protocols: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Next Protocol Negotiation. Supported in
      # OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
      # explicitly, the NPN extension will not be sent by the server in the handshake.
      #
      # ### Example
      #
      #     ctx.npn_protocols = ["http/1.1", "spdy/2"]
      #
      def npn_protocols=: (untyped) -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the client side when the client needs to select a
      # protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
      # higher. The client MUST select a protocol of those advertised by the server.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the NPN extension on the client - any protocols advertised by the server will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.npn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def npn_select_cb: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the client side when the client needs to select a
      # protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
      # higher. The client MUST select a protocol of those advertised by the server.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the NPN extension on the client - any protocols advertised by the server will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.npn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def npn_select_cb=: (untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.options -> integer
      # -->
      # Gets various OpenSSL options.
      #
      def options: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.options = integer
      # -->
      # Sets various OpenSSL options. The options are a bit field and can be combined
      # with the bitwise OR operator (`|`). Available options are defined as constants
      # in OpenSSL::SSL that begin with `OP_`.
      #
      # For backwards compatibility, passing `nil` has the same effect as passing
      # OpenSSL::SSL::OP_ALL.
      #
      # See also man page SSL_CTX_set_options(3).
      #
      def options=: (Integer ssl_options) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked whenever a new handshake is initiated on an established
      # connection. May be used to disable renegotiation entirely.
      #
      # The callback is invoked with the active SSLSocket. The callback's return value
      # is ignored. A normal return indicates "approval" of the renegotiation and will
      # continue the process. To forbid renegotiation and to cancel the process, raise
      # an exception within the callback.
      #
      # ### Disable client renegotiation
      #
      # When running a server, it is often desirable to disable client renegotiation
      # entirely. You may use a callback as follows to implement this feature:
      #
      #     ctx.renegotiation_cb = lambda do |ssl|
      #       raise RuntimeError, "Client renegotiation disabled"
      #     end
      #
      def renegotiation_cb: () -> (^(SSLSocket) -> void | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked whenever a new handshake is initiated on an established
      # connection. May be used to disable renegotiation entirely.
      #
      # The callback is invoked with the active SSLSocket. The callback's return value
      # is ignored. A normal return indicates "approval" of the renegotiation and will
      # continue the process. To forbid renegotiation and to cancel the process, raise
      # an exception within the callback.
      #
      # ### Disable client renegotiation
      #
      # When running a server, it is often desirable to disable client renegotiation
      # entirely. You may use a callback as follows to implement this feature:
      #
      #     ctx.renegotiation_cb = lambda do |ssl|
      #       raise RuntimeError, "Client renegotiation disabled"
      #     end
      #
      def renegotiation_cb=: (^(SSLSocket) -> void) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.security_level -> Integer
      # -->
      # Returns the security level for the context.
      #
      # See also OpenSSL::SSL::SSLContext#security_level=.
      #
      def security_level: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.security_level = integer
      # -->
      # Sets the security level for the context. OpenSSL limits parameters according
      # to the level. The "parameters" include: ciphersuites, curves, key sizes,
      # certificate signature algorithms, protocol version and so on. For example,
      # level 1 rejects parameters offering below 80 bits of security, such as
      # ciphersuites using MD5 for the MAC or RSA keys shorter than 1024 bits.
      #
      # Note that attempts to set such parameters with insufficient security are also
      # blocked. You need to lower the level first.
      #
      # This feature is not supported in OpenSSL < 1.1.0, and setting the level to
      # other than 0 will raise NotImplementedError. Level 0 means everything is
      # permitted, the same behavior as previous versions of OpenSSL.
      #
      # See the manpage of SSL_CTX_set_security_level(3) for details.
      #
      def security_level=: (Integer sec_level) -> Integer

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked at connect time to distinguish between multiple server
      # names.
      #
      # The callback is invoked with an SSLSocket and a server name.  The callback
      # must return an SSLContext for the server name or nil.
      #
      def servername_cb: () -> (^(SSLSocket, String) -> SSLContext? | nil)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked at connect time to distinguish between multiple server
      # names.
      #
      # The callback is invoked with an SSLSocket and a server name.  The callback
      # must return an SSLContext for the server name or nil.
      #
      def servername_cb=: (^(SSLSocket, String) -> SSLContext?) -> ^(SSLSocket, String) -> SSLContext?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_add(session) -> true | false
      # -->
      # Adds *session* to the session cache.
      #
      def session_add: (Session) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_mode -> Integer
      # -->
      # The current session cache mode.
      #
      def session_cache_mode: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_mode=(integer) -> Integer
      # -->
      # Sets the SSL session cache mode.  Bitwise-or together the desired
      # SESSION_CACHE_* constants to set.  See SSL_CTX_set_session_cache_mode(3) for
      # details.
      #
      def session_cache_mode=: (Integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_size -> Integer
      # -->
      # Returns the current session cache size.  Zero is used to represent an
      # unlimited cache size.
      #
      def session_cache_size: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_size=(integer) -> Integer
      # -->
      # Sets the session cache size.  Returns the previously valid session cache size.
      #  Zero is used to represent an unlimited session cache size.
      #
      def session_cache_size=: (Integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_stats -> Hash
      # -->
      # Returns a Hash containing the following keys:
      #
      # :accept
      # :   Number of started SSL/TLS handshakes in server mode
      #
      # :accept_good
      # :   Number of established SSL/TLS sessions in server mode
      #
      # :accept_renegotiate
      # :   Number of start renegotiations in server mode
      #
      # :cache_full
      # :   Number of sessions that were removed due to cache overflow
      #
      # :cache_hits
      # :   Number of successfully reused connections
      #
      # :cache_misses
      # :   Number of sessions proposed by clients that were not found in the cache
      #
      # :cache_num
      # :   Number of sessions in the internal session cache
      #
      # :cb_hits
      # :   Number of sessions retrieved from the external cache in server mode
      #
      # :connect
      # :   Number of started SSL/TLS handshakes in client mode
      #
      # :connect_good
      # :   Number of established SSL/TLS sessions in client mode
      #
      # :connect_renegotiate
      # :   Number of start renegotiations in client mode
      #
      # :timeouts
      # :   Number of sessions proposed by clients that were found in the cache but
      #     had expired due to timeouts
      #
      def session_cache_stats: () -> Hash[Symbol, Integer]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on a server when a session is proposed by the client but
      # the session could not be found in the server's internal cache.
      #
      # The callback is invoked with the SSLSocket and session id.  The callback may
      # return a Session from an external cache.
      #
      def session_get_cb: () -> (^(SSLSocket, Integer) -> Session? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on a server when a session is proposed by the client but
      # the session could not be found in the server's internal cache.
      #
      # The callback is invoked with the SSLSocket and session id.  The callback may
      # return a Session from an external cache.
      #
      def session_get_cb=: (^(SSLSocket, Integer) -> Session?) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Sets the context in which a session can be reused.  This allows sessions for
      # multiple applications to be distinguished, for example, by name.
      #
      def session_id_context: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Sets the context in which a session can be reused.  This allows sessions for
      # multiple applications to be distinguished, for example, by name.
      #
      def session_id_context=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a new session was negotiated.
      #
      # The callback is invoked with an SSLSocket.  If `false` is returned the session
      # will be removed from the internal cache.
      #
      def session_new_cb: () -> (^(SSLSocket) -> untyped | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a new session was negotiated.
      #
      # The callback is invoked with an SSLSocket.  If `false` is returned the session
      # will be removed from the internal cache.
      #
      def session_new_cb=: (^(SSLSocket) -> untyped) -> ^(SSLSocket) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_remove(session) -> true | false
      # -->
      # Removes *session* from the session cache.
      #
      def session_remove: (Session session) -> bool

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a session is removed from the internal cache.
      #
      # The callback is invoked with an SSLContext and a Session.
      #
      # IMPORTANT NOTE: It is currently not possible to use this safely in a
      # multi-threaded application. The callback is called inside a global lock and it
      # can randomly cause deadlock on Ruby thread switching.
      #
      def session_remove_cb: () -> (^(SSLContext, Session) -> void | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a session is removed from the internal cache.
      #
      # The callback is invoked with an SSLContext and a Session.
      #
      # IMPORTANT NOTE: It is currently not possible to use this safely in a
      # multi-threaded application. The callback is called inside a global lock and it
      # can randomly cause deadlock on Ruby thread switching.
      #
      def session_remove_cb=: (^(SSLContext, Session) -> void) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.set_params(params = {}) -> params
      # -->
      # Sets saner defaults optimized for the use with HTTP-like protocols.
      #
      # If a Hash *params* is given, the parameters are overridden with it. The keys
      # in *params* must be assignment methods on SSLContext.
      #
      # If the verify_mode is not VERIFY_NONE and ca_file, ca_path and cert_store are
      # not set then the system default certificate store is used.
      #
      def set_params: (?untyped params) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.setup => Qtrue # first time
      #   - ctx.setup => nil # thereafter
      # -->
      # This method is called automatically when a new SSLSocket is created. However,
      # it is not thread-safe and must be called before creating SSLSocket objects in
      # a multi-threaded program.
      #
      def setup: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      alias ssl_timeout timeout

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      alias ssl_timeout= timeout=

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.ssl_version = :TLSv1
      #   - ctx.ssl_version = "SSLv23"
      # -->
      # Sets the SSL/TLS protocol version for the context. This forces connections to
      # use only the specified protocol version. This is deprecated and only provided
      # for backwards compatibility. Use #min_version= and #max_version= instead.
      #
      # ### History
      # As the name hints, this used to call the SSL_CTX_set_ssl_version() function
      # which sets the SSL method used for connections created from the context. As of
      # Ruby/OpenSSL 2.1, this accessor method is implemented to call #min_version=
      # and #max_version= instead.
      #
      def ssl_version=: (tls_version meth) -> tls_version

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      def timeout: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      def timeout=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked when DH parameters are required for ephemeral DH key
      # exchange.
      #
      # The callback is invoked with the SSLSocket, a flag indicating the use of an
      # export cipher and the keylength required.
      #
      # The callback must return an OpenSSL::PKey::DH instance of the correct key
      # length.
      #
      # **Deprecated in version 3.0.** Use #tmp_dh= instead.
      #
      def tmp_dh_callback: () -> (^(Session, Integer, Integer) -> PKey::DH | nil)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked when DH parameters are required for ephemeral DH key
      # exchange.
      #
      # The callback is invoked with the SSLSocket, a flag indicating the use of an
      # export cipher and the keylength required.
      #
      # The callback must return an OpenSSL::PKey::DH instance of the correct key
      # length.
      #
      # **Deprecated in version 3.0.** Use #tmp_dh= instead.
      #
      def tmp_dh_callback=: (^(Session, Integer, Integer) -> PKey::DH) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback for additional certificate verification.  The callback is invoked
      # for each certificate in the chain.
      #
      # The callback is invoked with two values.  *preverify_ok* indicates indicates
      # if the verification was passed (`true`) or not (`false`). *store_context* is
      # an OpenSSL::X509::StoreContext containing the context used for certificate
      # verification.
      #
      # If the callback returns `false`, the chain verification is immediately stopped
      # and a bad_certificate alert is then sent.
      #
      def verify_callback: () -> (^(bool, X509::StoreContext) -> untyped | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback for additional certificate verification.  The callback is invoked
      # for each certificate in the chain.
      #
      # The callback is invoked with two values.  *preverify_ok* indicates indicates
      # if the verification was passed (`true`) or not (`false`). *store_context* is
      # an OpenSSL::X509::StoreContext containing the context used for certificate
      # verification.
      #
      # If the callback returns `false`, the chain verification is immediately stopped
      # and a bad_certificate alert is then sent.
      #
      def verify_callback=: (^(bool, X509::StoreContext) -> untyped) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Number of CA certificates to walk when verifying a certificate chain.
      #
      def verify_depth: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Number of CA certificates to walk when verifying a certificate chain.
      #
      def verify_depth=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Whether to check the server certificate is valid for the hostname.
      #
      # In order to make this work, verify_mode must be set to VERIFY_PEER and the
      # server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      #
      def verify_hostname: () -> bool?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Whether to check the server certificate is valid for the hostname.
      #
      # In order to make this work, verify_mode must be set to VERIFY_PEER and the
      # server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      #
      def verify_hostname=: [U] (boolish) -> U

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Session verification mode.
      #
      # Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
      # VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL
      #
      # The default mode is VERIFY_NONE, which does not perform any verification at
      # all.
      #
      # See SSL_CTX_set_verify(3) for details.
      #
      def verify_mode: () -> verify_mode?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Session verification mode.
      #
      # Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
      # VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL
      #
      # The default mode is VERIFY_NONE, which does not perform any verification at
      # all.
      #
      # See SSL_CTX_set_verify(3) for details.
      #
      def verify_mode=: (verify_mode) -> verify_mode

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - SSLContext.new           -> ctx
      #   - SSLContext.new(:TLSv1)   -> ctx
      #   - SSLContext.new("SSLv23") -> ctx
      # -->
      # Creates a new SSL context.
      #
      # If an argument is given, #ssl_version= is called with the value. Note that
      # this form is deprecated. New applications should use #min_version= and
      # #max_version= as necessary.
      #
      def initialize: (?tls_version version) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.set_minmax_proto_version(min, max) -> nil
      # -->
      # Sets the minimum and maximum supported protocol versions. See #min_version=
      # and #max_version=.
      #
      def set_minmax_proto_version: (untyped, untyped) -> untyped

      DEFAULT_CERT_STORE: X509::Store

      DEFAULT_PARAMS: Hash[Symbol, untyped]

      DEFAULT_TMP_DH_CALLBACK: Proc

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The list of available SSL/TLS methods. This constant is only provided for
      # backwards compatibility.
      #
      METHODS: Array[Symbol]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Both client and server sessions are added to the session cache
      #
      SESSION_CACHE_BOTH: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Client sessions are added to the session cache
      #
      SESSION_CACHE_CLIENT: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Normally the session cache is checked for expired sessions every 255
      # connections.  Since this may lead to a delay that cannot be controlled, the
      # automatic flushing may be disabled and #flush_sessions can be called
      # explicitly.
      #
      SESSION_CACHE_NO_AUTO_CLEAR: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Enables both SESSION_CACHE_NO_INTERNAL_LOOKUP and
      # SESSION_CACHE_NO_INTERNAL_STORE.
      #
      SESSION_CACHE_NO_INTERNAL: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Always perform external lookups of sessions even if they are in the internal
      # cache.
      #
      # This flag has no effect on clients
      #
      SESSION_CACHE_NO_INTERNAL_LOOKUP: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Never automatically store sessions in the internal store.
      #
      SESSION_CACHE_NO_INTERNAL_STORE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # No session caching for client or server
      #
      SESSION_CACHE_OFF: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Server sessions are added to the session cache
      #
      SESSION_CACHE_SERVER: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Generic error class raised by SSLSocket and SSLContext.
    #
    class SSLError < OpenSSL::OpenSSLError
    end

    class SSLErrorWaitReadable < OpenSSL::SSL::SSLError
      include IO::WaitReadable
    end

    class SSLErrorWaitWritable < OpenSSL::SSL::SSLError
      include IO::WaitWritable
    end

    # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
    # SSLServer represents a TCP/IP server socket with Secure Sockets Layer.
    #
    class SSLServer
      include OpenSSL::SSL::SocketForwarder

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - accept()
      # -->
      # Works similar to TCPServer#accept.
      #
      def accept: () -> SSLSocket

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - close()
      # -->
      # See IO#close for details.
      #
      def close: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - listen(backlog=Socket::SOMAXCONN)
      # -->
      # See TCPServer#listen for details.
      #
      def listen: (Integer backlog) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - shutdown(how=Socket::SHUT_RDWR)
      # -->
      # See BasicSocket#shutdown for details.
      #
      def shutdown: (interned | Integer how) -> void

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # When true then #accept works exactly the same as TCPServer#accept
      #
      def start_immediately: () -> bool

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # When true then #accept works exactly the same as TCPServer#accept
      #
      def start_immediately=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - to_io()
      # -->
      # Returns the TCPServer passed to the SSLServer when initialized.
      #
      def to_io: () -> (TCPServer | UNIXServer)

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - new(svr, ctx)
      # -->
      # Creates a new instance of SSLServer.
      # *   *srv* is an instance of TCPServer.
      # *   *ctx* is an instance of OpenSSL::SSL::SSLContext.
      #
      def initialize: (TCPServer | UNIXServer svr, untyped ctx) -> void
    end

    class SSLSocket
      include OpenSSL::SSL::SocketForwarder

      include OpenSSL::Buffering

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - open(remote_host, remote_port, local_host=nil, local_port=nil, context: nil)
      # -->
      # Creates a new instance of SSLSocket. *remote*host_ and *remote*port_ are used
      # to open TCPSocket. If *local*host_ and *local*port_ are specified, then those
      # parameters are used on the local end to establish the connection. If *context*
      # is provided, the SSL Sockets initial params will be taken from the context.
      #
      # ### Examples
      #
      #     sock = OpenSSL::SSL::SSLSocket.open('localhost', 443)
      #     sock.connect # Initiates a connection to localhost:443
      #
      # with SSLContext:
      #
      #     ctx = OpenSSL::SSL::SSLContext.new
      #     sock = OpenSSL::SSL::SSLSocket.open('localhost', 443, context: ctx)
      #     sock.connect # Initiates a connection to localhost:443 with SSLContext
      #
      def self.open: (untyped remote_host, untyped remote_port, ?untyped local_host, ?untyped local_port, ?context: untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.accept => self
      # -->
      # Waits for a SSL/TLS client to initiate a handshake.
      #
      def accept: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.accept_nonblock([options]) => self
      # -->
      # Initiates the SSL/TLS handshake as a server in non-blocking manner.
      #
      #     # emulates blocking accept
      #     begin
      #       ssl.accept_nonblock
      #     rescue IO::WaitReadable
      #       IO.select([s2])
      #       retry
      #     rescue IO::WaitWritable
      #       IO.select(nil, [s2])
      #       retry
      #     end
      #
      # By specifying a keyword argument *exception* to `false`, you can indicate that
      # accept_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
      # exception, but return the symbol `:wait_readable` or `:wait_writable` instead.
      #
      def accept_nonblock: (?exception: true) -> self
                         | (exception: false) -> (self | :wait_readable | :wait_writable)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.alpn_protocol => String | nil
      # -->
      # Returns the ALPN protocol string that was finally selected by the server
      # during the handshake.
      #
      def alpn_protocol: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.cert => cert or nil
      # -->
      # The X509 certificate for this socket endpoint.
      #
      def cert: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.cipher -> nil or [name, version, bits, alg_bits]
      # -->
      # Returns the cipher suite actually used in the current session, or nil if no
      # session has been established.
      #
      def cipher: () -> [ String, String, Integer, Integer ]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.client_ca => [x509name, ...]
      # -->
      # Returns the list of client CAs. Please note that in contrast to
      # SSLContext#client_ca= no array of X509::Certificate is returned but X509::Name
      # instances of the CA's subject distinguished name.
      #
      # In server mode, returns the list set by SSLContext#client_ca=. In client mode,
      # returns the list of client CAs sent from the server.
      #
      def client_ca: () -> (Array[X509::Name] | Array[X509::Certificate] | X509::Certificate)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.connect => self
      # -->
      # Initiates an SSL/TLS handshake with a server.
      #
      def connect: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.connect_nonblock([options]) => self
      # -->
      # Initiates the SSL/TLS handshake as a client in non-blocking manner.
      #
      #     # emulates blocking connect
      #     begin
      #       ssl.connect_nonblock
      #     rescue IO::WaitReadable
      #       IO.select([s2])
      #       retry
      #     rescue IO::WaitWritable
      #       IO.select(nil, [s2])
      #       retry
      #     end
      #
      # By specifying a keyword argument *exception* to `false`, you can indicate that
      # connect_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
      # exception, but return the symbol `:wait_readable` or `:wait_writable` instead.
      #
      def connect_nonblock: (?exception: true) -> self
                          | (exception: false) -> (self | :wait_readable | :wait_writable)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The SSLContext object used in this connection.
      #
      def context: () -> SSLContext

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.finished_message => "finished message"
      # -->
      # Returns the last **Finished** message sent
      #
      def finished_message: () -> String?

      def hostname: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.hostname = hostname -> hostname
      # -->
      # Sets the server hostname used for SNI. This needs to be set before
      # SSLSocket#connect.
      #
      def hostname=: (String) -> String

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The underlying IO object.
      #
      def io: () -> BasicSocket

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.npn_protocol => String | nil
      # -->
      # Returns the protocol string that was finally selected by the client during the
      # handshake.
      #
      def npn_protocol: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_cert => cert or nil
      # -->
      # The X509 certificate for this socket's peer.
      #
      def peer_cert: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_cert_chain => [cert, ...] or nil
      # -->
      # The X509 certificate chain for this socket's peer.
      #
      def peer_cert_chain: () -> Array[X509::Certificate]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_finished_message => "peer finished message"
      # -->
      # Returns the last **Finished** message received
      #
      def peer_finished_message: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.pending => Integer
      # -->
      # The number of bytes that are immediately available for reading.
      #
      def pending: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.post_connection_check(hostname) -> true
      # -->
      # Perform hostname verification following RFC 6125.
      #
      # This method MUST be called after calling #connect to ensure that the hostname
      # of a remote peer has been verified.
      #
      def post_connection_check: (String hostname) -> true

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.session -> aSession
      # -->
      # Returns the SSLSession object currently used, or nil if the session is not
      # established.
      #
      def session: () -> Session?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.session = session -> session
      # -->
      # Sets the Session to be used when the connection is established.
      #
      def session=: (Session) -> Session

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.session_reused? -> true | false
      # -->
      # Returns `true` if a reused session was negotiated during the handshake.
      #
      def session_reused?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.ssl_version => String
      # -->
      # Returns a String representing the SSL/TLS version that was negotiated for the
      # connection, for example "TLSv1.2".
      #
      def ssl_version: () -> tls_version

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.state => string
      # -->
      # A description of the current connection state. This is for diagnostic purposes
      # only.
      #
      def state: () -> String

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # Whether to close the underlying socket as well, when the SSL/TLS connection is
      # shut down. This defaults to `false`.
      #
      def sync_close: () -> bool

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # Whether to close the underlying socket as well, when the SSL/TLS connection is
      # shut down. This defaults to `false`.
      #
      def sync_close=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.sysclose => nil
      # -->
      # Sends "close notify" to the peer and tries to shut down the SSL connection
      # gracefully.
      #
      # If sync_close is set to `true`, the underlying IO is also closed.
      #
      def sysclose: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.sysread(length) => string
      #   - ssl.sysread(length, buffer) => buffer
      # -->
      # Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
      # provided the data will be written into it.
      #
      def sysread: (Integer length, ?String buffer) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.syswrite(string) => Integer
      # -->
      # Writes *string* to the SSL connection.
      #
      def syswrite: (String data) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.tmp_key => PKey or nil
      # -->
      # Returns the ephemeral key used in case of forward secrecy cipher.
      #
      def tmp_key: () -> PKey::PKey?

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The underlying IO object.
      #
      alias to_io io

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.verify_result => Integer
      # -->
      # Returns the result of the peer certificates verification.  See verify(1) for
      # error values and descriptions.
      #
      # If no peer certificate was presented X509_V_OK is returned.
      #
      def verify_result: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - client_cert_cb()
      # -->
      #
      def client_cert_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - SSLSocket.new(io) => aSSLSocket
      #   - SSLSocket.new(io, ctx) => aSSLSocket
      # -->
      # Creates a new SSL socket from *io* which must be a real IO object (not an
      # IO-like object that responds to read/write).
      #
      # If *ctx* is provided the SSL Sockets initial params will be taken from the
      # context.
      #
      # The OpenSSL::Buffering module provides additional IO methods.
      #
      # This method will freeze the SSLContext if one is provided; however, session
      # management is still allowed in the frozen SSLContext.
      #
      def initialize: (*untyped) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - session_get_cb()
      # -->
      #
      def session_get_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - session_new_cb()
      # -->
      #
      def session_new_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.stop => nil
      # -->
      # Sends "close notify" to the peer and tries to shut down the SSL connection
      # gracefully.
      #
      def stop: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.sysread_nonblock(length) => string
      #   - ssl.sysread_nonblock(length, buffer) => buffer
      #   - ssl.sysread_nonblock(length[, buffer [, opts]) => buffer
      # -->
      # A non-blocking version of #sysread.  Raises an SSLError if reading would
      # block.  If "exception: false" is passed, this method returns a symbol of
      # :wait_readable, :wait_writable, or nil, rather than raising an exception.
      #
      # Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
      # provided the data will be written into it.
      #
      def sysread_nonblock: (*untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.syswrite_nonblock(string) => Integer
      # -->
      # Writes *string* to the SSL connection in a non-blocking manner.  Raises an
      # SSLError if writing would block.
      #
      def syswrite_nonblock: (*untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - tmp_dh_callback()
      # -->
      #
      def tmp_dh_callback: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - tmp_ecdh_callback()
      # -->
      #
      def tmp_ecdh_callback: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - using_anon_cipher?()
      # -->
      #
      def using_anon_cipher?: () -> untyped
    end

    class Session
      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session1 == session2 -> boolean
      # -->
      # Returns `true` if the two Session is the same, `false` if not.
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.id -> String
      # -->
      # Returns the Session ID.
      #
      def id: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.time -> Time
      # -->
      # Returns the time at which the session was established.
      #
      def time: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.time = time
      #   - session.time = integer
      # -->
      # Sets start time of the session. Time resolution is in seconds.
      #
      def time=: (Time | Integer start_time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.timeout -> Integer
      # -->
      # Returns the timeout value set for the session, in seconds from the established
      # time.
      #
      def timeout: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.timeout = integer
      # -->
      # Sets how long until the session expires in seconds.
      #
      def timeout=: (Integer timeout) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_der -> String
      # -->
      # Returns an ASN1 encoded String that contains the Session object.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_pem -> String
      # -->
      # Returns a PEM encoded String that contains the Session object.
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_text -> String
      # -->
      # Shows everything in the Session object. This is for diagnostic purposes.
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - Session.new(ssl_socket) -> Session
      #   - Session.new(string) -> Session
      # -->
      # Creates a new Session object from an instance of SSLSocket or DER/PEM encoded
      # String.
      #
      def initialize: (SSLSocket | String sock_or_str) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      class SessionError < OpenSSL::OpenSSLError
      end
    end

    module SocketForwarder
      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - addr()
      # -->
      #
      def addr: () -> Addrinfo?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - closed?()
      # -->
      #
      def closed?: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - do_not_reverse_lookup=(flag)
      # -->
      #
      def do_not_reverse_lookup=: (boolish flag) -> boolish

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - fcntl(*args)
      # -->
      #
      def fcntl: (*untyped args) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - fileno()
      # -->
      # The file descriptor for the socket.
      #
      def fileno: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - getsockopt(level, optname)
      # -->
      #
      def getsockopt: (Symbol | Integer level, Symbol | Integer optname) -> (Integer | boolish | String)

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - peeraddr()
      # -->
      #
      def peeraddr: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - setsockopt(level, optname, optval)
      # -->
      #
      def setsockopt: (untyped level, untyped optname, untyped optval) -> untyped
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
  # Provides classes and methods to request, create and validate
  # [RFC3161-compliant](http://www.ietf.org/rfc/rfc3161.txt) timestamps. Request
  # may be used to either create requests from scratch or to parse existing
  # requests that again can be used to request timestamps from a timestamp server,
  # e.g. via the net/http. The resulting timestamp response may be parsed using
  # Response.
  #
  # Please note that Response is read-only and immutable. To create a Response, an
  # instance of Factory as well as a valid Request are needed.
  #
  # ### Create a Response:
  #     #Assumes ts.p12 is a PKCS#12-compatible file with a private key
  #     #and a certificate that has an extended key usage of 'timeStamping'
  #     p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
  #     md = OpenSSL::Digest.new('SHA1')
  #     hash = md.digest(data) #some binary data to be timestamped
  #     req = OpenSSL::Timestamp::Request.new
  #     req.algorithm = 'SHA1'
  #     req.message_imprint = hash
  #     req.policy_id = "1.2.3.4.5"
  #     req.nonce = 42
  #     fac = OpenSSL::Timestamp::Factory.new
  #     fac.gen_time = Time.now
  #     fac.serial_number = 1
  #     timestamp = fac.create_timestamp(p12.key, p12.certificate, req)
  #
  # ### Verify a timestamp response:
  #     #Assume we have a timestamp token in a file called ts.der
  #     ts = OpenSSL::Timestamp::Response.new(File.binread('ts.der'))
  #     #Assume we have the Request for this token in a file called req.der
  #     req = OpenSSL::Timestamp::Request.new(File.binread('req.der'))
  #     # Assume the associated root CA certificate is contained in a
  #     # DER-encoded file named root.cer
  #     root = OpenSSL::X509::Certificate.new(File.binread('root.cer'))
  #     # get the necessary intermediate certificates, available in
  #     # DER-encoded form in inter1.cer and inter2.cer
  #     inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
  #     inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
  #     ts.verify(req, root, inter1, inter2) -> ts or raises an exception if validation fails
  #
  module Timestamp
    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Used to generate a Response from scratch.
    #
    # Please bear in mind that the implementation will always apply and prefer the
    # policy object identifier given in the request over the default policy id
    # specified in the Factory. As a consequence, `default_policy_id` will only be
    # applied if no Request#policy_id was given. But this also means that one needs
    # to check the policy identifier in the request manually before creating the
    # Response, e.g. to check whether it complies to a specific set of acceptable
    # policies.
    #
    # There exists also the possibility to add certificates (instances of
    # OpenSSL::X509::Certificate) besides the timestamping certificate that will be
    # included in the resulting timestamp token if Request#cert_requested? is
    # `true`. Ideally, one would also include any intermediate certificates (the
    # root certificate can be left out - in order to trust it any verifying party
    # will have to be in its possession anyway). This simplifies validation of the
    # timestamp since these intermediate certificates are "already there" and need
    # not be passed as external parameters to Response#verify anymore, thus
    # minimizing external resources needed for verification.
    #
    # ### Example: Inclusion of (untrusted) intermediate certificates
    #
    # Assume we received a timestamp request that has set Request#policy_id to `nil`
    # and Request#cert_requested? to true. The raw request bytes are stored in a
    # variable called `req_raw`. We'd still like to integrate the necessary
    # intermediate certificates (in `inter1.cer` and `inter2.cer`) to simplify
    # validation of the resulting Response. `ts.p12` is a PKCS#12-compatible file
    # including the private key and the timestamping certificate.
    #
    #     req = OpenSSL::Timestamp::Request.new(raw_bytes)
    #     p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
    #     inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
    #     inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
    #     fac = OpenSSL::Timestamp::Factory.new
    #     fac.gen_time = Time.now
    #     fac.serial_number = 1
    #     fac.allowed_digests = ["sha256", "sha384", "sha512"]
    #     #needed because the Request contained no policy identifier
    #     fac.default_policy_id = '1.2.3.4.5'
    #     fac.additional_certificates = [ inter1, inter2 ]
    #     timestamp = fac.create_timestamp(p12.key, p12.certificate, req)
    #
    # ## Attributes
    #
    # ### default_policy_id
    #
    # Request#policy_id will always be preferred over this if present in the
    # Request, only if Request#policy_id is nil default_policy will be used. If none
    # of both is present, a TimestampError will be raised when trying to create a
    # Response.
    #
    # call-seq:
    #     factory.default_policy_id = "string" -> string
    #     factory.default_policy_id            -> string or nil
    #
    # ### serial_number
    #
    # Sets or retrieves the serial number to be used for timestamp creation. Must be
    # present for timestamp creation.
    #
    # call-seq:
    #     factory.serial_number = number -> number
    #     factory.serial_number          -> number or nil
    #
    # ### gen_time
    #
    # Sets or retrieves the Time value to be used in the Response. Must be present
    # for timestamp creation.
    #
    # call-seq:
    #     factory.gen_time = Time -> Time
    #     factory.gen_time        -> Time or nil
    #
    # ### additional_certs
    #
    # Sets or retrieves additional certificates apart from the timestamp certificate
    # (e.g. intermediate certificates) to be added to the Response. Must be an Array
    # of OpenSSL::X509::Certificate.
    #
    # call-seq:
    #     factory.additional_certs = [cert1, cert2] -> [ cert1, cert2 ]
    #     factory.additional_certs                  -> array or nil
    #
    # ### allowed_digests
    #
    # Sets or retrieves the digest algorithms that the factory is allowed create
    # timestamps for. Known vulnerable or weak algorithms should not be allowed
    # where possible. Must be an Array of String or OpenSSL::Digest subclass
    # instances.
    #
    # call-seq:
    #     factory.allowed_digests = ["sha1", OpenSSL::Digest.new('SHA256').new] -> [ "sha1", OpenSSL::Digest) ]
    #     factory.allowed_digests                                               -> array or nil
    #
    class Factory
      def additional_certs: () -> Array[X509::Certificate]?

      def additional_certs=: (Array[X509::Certificate]? certs) -> Array[X509::Certificate]?

      def allowed_digests: () -> Array[String | Digest]?

      def allowed_digests=: (Array[String | Digest]) -> Array[String | Digest]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - factory.create_timestamp(key, certificate, request) -> Response
      # -->
      # Creates a Response with the help of an OpenSSL::PKey, an
      # OpenSSL::X509::Certificate and a Request.
      #
      # Mandatory parameters for timestamp creation that need to be set in the
      # Request:
      #
      # *   Request#algorithm
      # *   Request#message_imprint
      #
      # Mandatory parameters that need to be set in the Factory:
      # *   Factory#serial_number
      # *   Factory#gen_time
      # *   Factory#allowed_digests
      #
      # In addition one of either Request#policy_id or Factory#default_policy_id must
      # be set.
      #
      # Raises a TimestampError if creation fails, though successfully created error
      # responses may be returned.
      #
      def create_timestamp: (PKey::PKey key, X509::Certificate cert, Request request) -> Response

      def default_policy_id: () -> String?

      def default_policy_id=: (String) -> String

      def gen_time: () -> Time?

      def gen_time=: (Time) -> Time

      def serial_number: () -> Integer?

      def serial_number=: (Integer) -> Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Allows to create timestamp requests or parse existing ones. A Request is also
    # needed for creating timestamps from scratch with Factory. When created from
    # scratch, some default values are set:
    # *   version is set to `1`
    # *   cert_requested is set to `true`
    # *   algorithm, message_imprint, policy_id, and nonce are set to `false`
    #
    class Request
      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.algorithm    -> string
      # -->
      # Returns the 'short name' of the object identifier that represents the
      # algorithm that was used to create the message imprint digest.
      #
      def algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.algorithm = "string"    -> string
      # -->
      # Allows to set the object identifier  or the 'short name' of the algorithm that
      # was used to create the message imprint digest.
      #
      # ### Example:
      #     request.algorithm = "SHA1"
      #
      def algorithm=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.cert_requested = boolean -> true or false
      # -->
      # Specify whether the response shall contain the timestamp authority's
      # certificate or not. The default value is `true`.
      #
      def cert_requested=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.cert_requested?  -> true or false
      # -->
      # Indicates whether the response shall contain the timestamp authority's
      # certificate or not.
      #
      def cert_requested?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.message_imprint    -> string or nil
      # -->
      # Returns the message imprint (digest) of the data to be timestamped.
      #
      def message_imprint: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.message_imprint = "string"    -> string
      # -->
      # Set the message imprint digest.
      #
      def message_imprint=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.nonce    -> BN or nil
      # -->
      # Returns the nonce (number used once) that the server shall include in its
      # response.
      #
      def nonce: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.nonce = number    -> BN
      # -->
      # Sets the nonce (number used once) that the server shall include in its
      # response. If the nonce is set, the server must return the same nonce value in
      # a valid Response.
      #
      def nonce=: (bn nonce) -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.policy_id    -> string or nil
      # -->
      # Returns the 'short name' of the object identifier that represents the
      # timestamp policy under which the server shall create the timestamp.
      #
      def policy_id: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.policy_id = "string"   -> string
      # -->
      # Allows to set the object identifier that represents the timestamp policy under
      # which the server shall create the timestamp. This may be left `nil`, implying
      # that the timestamp server will issue the timestamp using some default policy.
      #
      # ### Example:
      #     request.policy_id = "1.2.3.4.5"
      #
      def policy_id=: (String policy_id) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.to_der    -> DER-encoded string
      # -->
      # DER-encodes this Request.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.version -> Integer
      # -->
      # Returns the version of this request. `1` is the default value.
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.version = number    -> Integer
      # -->
      # Sets the version number for this Request. This should be `1` for compliant
      # servers.
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::Request.new(file)    -> request
      #   - OpenSSL::Timestamp::Request.new(string)  -> request
      #   - OpenSSL::Timestamp::Request.new          -> empty request
      # -->
      # When creating a Request with the `File` or `string` parameter, the
      # corresponding `File` or `string` must be DER-encoded.
      #
      def initialize: (?File | String request_der) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Immutable and read-only representation of a timestamp response returned from a
    # timestamp server after receiving an associated Request. Allows access to
    # specific information about the response but also allows to verify the
    # Response.
    #
    class Response
      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.failure_info -> nil or symbol
      # -->
      # In cases no timestamp token has been created, this field contains further info
      # about the reason why response creation failed. The method returns either nil
      # (the request was successful and a timestamp token was created) or one of the
      # following:
      # *   :BAD_ALG - Indicates that the timestamp server rejects the message imprint
      #     algorithm used in the Request
      # *   :BAD_REQUEST - Indicates that the timestamp server was not able to process
      #     the Request properly
      # *   :BAD_DATA_FORMAT - Indicates that the timestamp server was not able to
      #     parse certain data in the Request
      # *   :TIME_NOT_AVAILABLE - Indicates that the server could not access its time
      #     source
      # *   :UNACCEPTED_POLICY - Indicates that the requested policy identifier is not
      #     recognized or supported by the timestamp server
      # *   :UNACCEPTED_EXTENSIION - Indicates that an extension in the Request is not
      #     supported by the timestamp server
      # *   :ADD_INFO_NOT_AVAILABLE -Indicates that additional information requested
      #     is either not understood or currently not available
      # *   :SYSTEM_FAILURE - Timestamp creation failed due to an internal error that
      #     occurred on the timestamp server
      #
      def failure_info: () -> Symbol?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.status -> BN (never nil)
      # -->
      # Returns one of GRANTED, GRANTED_WITH_MODS, REJECTION, WAITING,
      # REVOCATION_WARNING or REVOCATION_NOTIFICATION. A timestamp token has been
      # created only in case `status` is equal to GRANTED or GRANTED_WITH_MODS.
      #
      def status: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.status_text -> Array of strings or nil
      # -->
      # In cases of failure this field may contain an array of strings further
      # describing the origin of the failure.
      #
      def status_text: () -> Array[String]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.to_der -> string
      # -->
      # Returns the Response in DER-encoded form.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.token -> nil or OpenSSL::PKCS7
      # -->
      # If a timestamp token is present, this returns it in the form of a
      # OpenSSL::PKCS7.
      #
      def token: () -> PKCS7?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.token_info -> nil or OpenSSL::Timestamp::TokenInfo
      # -->
      # Get the response's token info if present.
      #
      def token_info: () -> TokenInfo?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.tsa_certificate -> OpenSSL::X509::Certificate or nil
      # -->
      # If the Request specified to request the TSA certificate
      # (Request#cert_requested = true), then this field contains the certificate of
      # the timestamp authority.
      #
      def tsa_certificate: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.verify(Request, root_store) -> Response
      #   - response.verify(Request, root_store, [intermediate_cert]) -> Response
      # -->
      # Verifies a timestamp token by checking the signature, validating the
      # certificate chain implied by tsa_certificate and by checking conformance to a
      # given Request. Mandatory parameters are the Request associated to this
      # Response, and an OpenSSL::X509::Store of trusted roots.
      #
      # Intermediate certificates can optionally be supplied for creating the
      # certificate chain. These intermediate certificates must all be instances of
      # OpenSSL::X509::Certificate.
      #
      # If validation fails, several kinds of exceptions can be raised:
      # *   TypeError if types don't fit
      # *   TimestampError if something is wrong with the timestamp token itself, if
      #     it is not conformant to the Request, or if validation of the timestamp
      #     certificate chain fails.
      #
      def verify: (Request request, X509::Store store, ?X509::Certificate intermediate_cert) -> instance

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::Response.new(file)    -> response
      #   - OpenSSL::Timestamp::Response.new(string)  -> response
      # -->
      # Creates a Response from a `File` or `string` parameter, the corresponding
      # `File` or `string` must be DER-encoded. Please note that Response is an
      # immutable read-only class. If you'd like to create timestamps please refer to
      # Factory instead.
      #
      def initialize: (File | String response_der) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a successful response. Equal to `0`.
      #
      GRANTED: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a successful response that probably contains modifications from the
      # initial request. Equal to `1`.
      #
      GRANTED_WITH_MODS: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Equal to `2`.
      #
      REJECTION: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. A certificate has been
      # revoked. Equal to `5`.
      #
      REVOCATION_NOTIFICATION: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Revocation of a
      # certificate is imminent. Equal to `4`.
      #
      REVOCATION_WARNING: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Equal to `3`.
      #
      WAITING: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Generic exception class of the Timestamp module.
    #
    class TimestampError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Immutable and read-only representation of a timestamp token info from a
    # Response.
    #
    class TokenInfo
      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.algorithm -> string or nil
      # -->
      # Returns the 'short name' of the object identifier representing the algorithm
      # that was used to derive the message imprint digest. For valid timestamps, this
      # is the same value that was already given in the Request. If status is GRANTED
      # or GRANTED_WITH_MODS, this is never `nil`.
      #
      # ### Example:
      #     algo = token_info.algorithm
      #     puts algo                -> "SHA1"
      #
      def algorithm: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.gen_time -> Time
      # -->
      # Returns time when this timestamp token was created. If status is GRANTED or
      # GRANTED_WITH_MODS, this is never `nil`.
      #
      def gen_time: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.msg_imprint -> string.
      # -->
      # Returns the message imprint digest. For valid timestamps, this is the same
      # value that was already given in the Request. If status is GRANTED or
      # GRANTED_WITH_MODS, this is never `nil`.
      #
      # ### Example:
      #     mi = token_info.msg_imprint
      #     puts mi                -> "DEADBEEF"
      #
      def message_imprint: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.nonce -> BN or nil
      # -->
      # If the timestamp token is valid then this field contains the same nonce that
      # was passed to the timestamp server in the initial Request.
      #
      def nonce: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.ordering -> true, falses or nil
      # -->
      # If the ordering field is missing, or if the ordering field is present and set
      # to false, then the genTime field only indicates the time at which the
      # time-stamp token has been created by the TSA.  In such a case, the ordering of
      # time-stamp tokens issued by the same TSA or different TSAs is only possible
      # when the difference between the genTime of the first time-stamp token and the
      # genTime of the second time-stamp token is greater than the sum of the
      # accuracies of the genTime for each time-stamp token.
      #
      # If the ordering field is present and set to true, every time-stamp token from
      # the same TSA can always be ordered based on the genTime field, regardless of
      # the genTime accuracy.
      #
      def ordering: () -> bool?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.policy_id -> string or nil
      # -->
      # Returns the timestamp policy object identifier of the policy this timestamp
      # was created under. If status is GRANTED or GRANTED_WITH_MODS, this is never
      # `nil`.
      #
      # ### Example:
      #     id = token_info.policy_id
      #     puts id                 -> "1.2.3.4.5"
      #
      def policy_id: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.serial_number -> BN or nil
      # -->
      # Returns serial number of the timestamp token. This value shall never be the
      # same for two timestamp tokens issued by a dedicated timestamp authority. If
      # status is GRANTED or GRANTED_WITH_MODS, this is never `nil`.
      #
      def serial_number: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.to_der -> string
      # -->
      # Returns the TokenInfo in DER-encoded form.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.version -> Integer or nil
      # -->
      # Returns the version number of the token info. With compliant servers, this
      # value should be `1` if present. If status is GRANTED or GRANTED_WITH_MODS.
      #
      def version: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::TokenInfo.new(file)    -> token-info
      #   - OpenSSL::Timestamp::TokenInfo.new(string)  -> token-info
      # -->
      # Creates a TokenInfo from a `File` or `string` parameter, the corresponding
      # `File` or `string` must be DER-encoded. Please note that TokenInfo is an
      # immutable read-only class. If you'd like to create timestamps please refer to
      # Factory instead.
      #
      def initialize: (File | String token_der) -> void
    end
  end

  module X509
    DEFAULT_CERT_AREA: String

    DEFAULT_CERT_DIR: String

    DEFAULT_CERT_DIR_ENV: String

    DEFAULT_CERT_FILE: String

    DEFAULT_CERT_FILE_ENV: String

    DEFAULT_PRIVATE_DIR: String

    PURPOSE_ANY: Integer

    PURPOSE_CRL_SIGN: Integer

    PURPOSE_NS_SSL_SERVER: Integer

    PURPOSE_OCSP_HELPER: Integer

    PURPOSE_SMIME_ENCRYPT: Integer

    PURPOSE_SMIME_SIGN: Integer

    PURPOSE_SSL_CLIENT: Integer

    PURPOSE_SSL_SERVER: Integer

    PURPOSE_TIMESTAMP_SIGN: Integer

    TRUST_COMPAT: Integer

    TRUST_EMAIL: Integer

    TRUST_OBJECT_SIGN: Integer

    TRUST_OCSP_REQUEST: Integer

    TRUST_OCSP_SIGN: Integer

    TRUST_SSL_CLIENT: Integer

    TRUST_SSL_SERVER: Integer

    TRUST_TSA: Integer

    V_ERR_AKID_ISSUER_SERIAL_MISMATCH: Integer

    V_ERR_AKID_SKID_MISMATCH: Integer

    V_ERR_APPLICATION_VERIFICATION: Integer

    V_ERR_CA_KEY_TOO_SMALL: Integer

    V_ERR_CA_MD_TOO_WEAK: Integer

    V_ERR_CERT_CHAIN_TOO_LONG: Integer

    V_ERR_CERT_HAS_EXPIRED: Integer

    V_ERR_CERT_NOT_YET_VALID: Integer

    V_ERR_CERT_REJECTED: Integer

    V_ERR_CERT_REVOKED: Integer

    V_ERR_CERT_SIGNATURE_FAILURE: Integer

    V_ERR_CERT_UNTRUSTED: Integer

    V_ERR_CRL_HAS_EXPIRED: Integer

    V_ERR_CRL_NOT_YET_VALID: Integer

    V_ERR_CRL_PATH_VALIDATION_ERROR: Integer

    V_ERR_CRL_SIGNATURE_FAILURE: Integer

    V_ERR_DANE_NO_MATCH: Integer

    V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: Integer

    V_ERR_DIFFERENT_CRL_SCOPE: Integer

    V_ERR_EE_KEY_TOO_SMALL: Integer

    V_ERR_EMAIL_MISMATCH: Integer

    V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: Integer

    V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: Integer

    V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: Integer

    V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: Integer

    V_ERR_EXCLUDED_VIOLATION: Integer

    V_ERR_HOSTNAME_MISMATCH: Integer

    V_ERR_INVALID_CA: Integer

    V_ERR_INVALID_CALL: Integer

    V_ERR_INVALID_EXTENSION: Integer

    V_ERR_INVALID_NON_CA: Integer

    V_ERR_INVALID_POLICY_EXTENSION: Integer

    V_ERR_INVALID_PURPOSE: Integer

    V_ERR_IP_ADDRESS_MISMATCH: Integer

    V_ERR_KEYUSAGE_NO_CERTSIGN: Integer

    V_ERR_KEYUSAGE_NO_CRL_SIGN: Integer

    V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: Integer

    V_ERR_NO_EXPLICIT_POLICY: Integer

    V_ERR_NO_VALID_SCTS: Integer

    V_ERR_OCSP_CERT_UNKNOWN: Integer

    V_ERR_OCSP_VERIFY_FAILED: Integer

    V_ERR_OCSP_VERIFY_NEEDED: Integer

    V_ERR_OUT_OF_MEM: Integer

    V_ERR_PATH_LENGTH_EXCEEDED: Integer

    V_ERR_PATH_LOOP: Integer

    V_ERR_PERMITTED_VIOLATION: Integer

    V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: Integer

    V_ERR_PROXY_PATH_LENGTH_EXCEEDED: Integer

    V_ERR_PROXY_SUBJECT_NAME_VIOLATION: Integer

    V_ERR_SELF_SIGNED_CERT_IN_CHAIN: Integer

    V_ERR_STORE_LOOKUP: Integer

    V_ERR_SUBJECT_ISSUER_MISMATCH: Integer

    V_ERR_SUBTREE_MINMAX: Integer

    V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: Integer

    V_ERR_SUITE_B_INVALID_ALGORITHM: Integer

    V_ERR_SUITE_B_INVALID_CURVE: Integer

    V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: Integer

    V_ERR_SUITE_B_INVALID_VERSION: Integer

    V_ERR_SUITE_B_LOS_NOT_ALLOWED: Integer

    V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: Integer

    V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: Integer

    V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: Integer

    V_ERR_UNABLE_TO_GET_CRL: Integer

    V_ERR_UNABLE_TO_GET_CRL_ISSUER: Integer

    V_ERR_UNABLE_TO_GET_ISSUER_CERT: Integer

    V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: Integer

    V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: Integer

    V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: Integer

    V_ERR_UNHANDLED_CRITICAL_EXTENSION: Integer

    V_ERR_UNNESTED_RESOURCE: Integer

    V_ERR_UNSPECIFIED: Integer

    V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: Integer

    V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: Integer

    V_ERR_UNSUPPORTED_EXTENSION_FEATURE: Integer

    V_ERR_UNSUPPORTED_NAME_SYNTAX: Integer

    V_FLAG_ALLOW_PROXY_CERTS: Integer

    V_FLAG_CHECK_SS_SIGNATURE: Integer

    V_FLAG_CRL_CHECK: Integer

    V_FLAG_CRL_CHECK_ALL: Integer

    V_FLAG_EXPLICIT_POLICY: Integer

    V_FLAG_EXTENDED_CRL_SUPPORT: Integer

    V_FLAG_IGNORE_CRITICAL: Integer

    V_FLAG_INHIBIT_ANY: Integer

    V_FLAG_INHIBIT_MAP: Integer

    V_FLAG_NOTIFY_POLICY: Integer

    V_FLAG_NO_ALT_CHAINS: Integer

    V_FLAG_NO_CHECK_TIME: Integer

    V_FLAG_PARTIAL_CHAIN: Integer

    V_FLAG_POLICY_CHECK: Integer

    V_FLAG_SUITEB_128_LOS: Integer

    V_FLAG_SUITEB_128_LOS_ONLY: Integer

    V_FLAG_SUITEB_192_LOS: Integer

    V_FLAG_TRUSTED_FIRST: Integer

    V_FLAG_USE_CHECK_TIME: Integer

    V_FLAG_USE_DELTAS: Integer

    V_FLAG_X509_STRICT: Integer

    V_OK: Integer

    class Attribute
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.oid => string
      # -->
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.oid = string => string
      # -->
      #
      def oid=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.to_der => string
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.value => asn1
      # -->
      #
      def value: () -> ASN1::Set

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.value = asn1 => asn1
      # -->
      #
      def value=: (ASN1::ASN1Data) -> ASN1::Set

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - Attribute.new(oid [, value]) => attr
      # -->
      #
      def initialize: (String der) -> void
                    | (String oid, ASN1::ASN1Data value) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class AttributeError < OpenSSL::OpenSSLError
    end

    class CRL
      include OpenSSL::X509::Extension::AuthorityKeyIdentifier

      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - add_extension(p1)
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - add_revoked(p1)
      # -->
      #
      def add_revoked: (Revoked revoked) -> Revoked

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - extensions()
      # -->
      # Gets X509v3 extensions as array of X509Ext objects
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - extensions=(p1)
      # -->
      # Sets X509_EXTENSIONs
      #
      def extensions=: (Array[Extension] extensions) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - issuer=(p1)
      # -->
      #
      def issuer=: (X509::Name issuer) -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - last_update()
      # -->
      #
      def last_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - last_update=(p1)
      # -->
      #
      def last_update=: (Time last_update) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - next_update()
      # -->
      #
      def next_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - next_update=(p1)
      # -->
      #
      def next_update=: (Time next_update) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - revoked()
      # -->
      #
      def revoked: () -> Array[Revoked]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - revoked=(p1)
      # -->
      #
      def revoked=: (Array[Revoked]) -> Array[Revoked]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - sign(p1, p2)
      # -->
      #
      def sign: (PKey::PKey key, Digest digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - signature_algorithm()
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_pem()
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_text()
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - verify(p1)
      # -->
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - version()
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - version=(p1)
      # -->
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - new(p1 = v1)
      # -->
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class CRLError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509cert.c -->
    # Implementation of an X.509 certificate as specified in RFC 5280. Provides
    # access to a certificate's attributes and allows certificates to be read from a
    # string, but also supports the creation of new certificates from scratch.
    #
    # ### Reading a certificate from a file
    #
    # Certificate is capable of handling DER-encoded certificates and certificates
    # encoded in OpenSSL's PEM format.
    #
    #     raw = File.binread "cert.cer" # DER- or PEM-encoded
    #     certificate = OpenSSL::X509::Certificate.new raw
    #
    # ### Saving a certificate to a file
    #
    # A certificate may be encoded in DER format
    #
    #     cert = ...
    #     File.open("cert.cer", "wb") { |f| f.print cert.to_der }
    #
    # or in PEM format
    #
    #     cert = ...
    #     File.open("cert.pem", "wb") { |f| f.print cert.to_pem }
    #
    # X.509 certificates are associated with a private/public key pair, typically a
    # RSA, DSA or ECC key (see also OpenSSL::PKey::RSA, OpenSSL::PKey::DSA and
    # OpenSSL::PKey::EC), the public key itself is stored within the certificate and
    # can be accessed in form of an OpenSSL::PKey. Certificates are typically used
    # to be able to associate some form of identity with a key pair, for example web
    # servers serving pages over HTTPs use certificates to authenticate themselves
    # to the user.
    #
    # The public key infrastructure (PKI) model relies on trusted certificate
    # authorities ("root CAs") that issue these certificates, so that end users need
    # to base their trust just on a selected few authorities that themselves again
    # vouch for subordinate CAs issuing their certificates to end users.
    #
    # The OpenSSL::X509 module provides the tools to set up an independent PKI,
    # similar to scenarios where the 'openssl' command line tool is used for issuing
    # certificates in a private PKI.
    #
    # ### Creating a root CA certificate and an end-entity certificate
    #
    # First, we need to create a "self-signed" root certificate. To do so, we need
    # to generate a key first. Please note that the choice of "1" as a serial number
    # is considered a security flaw for real certificates. Secure choices are
    # integers in the two-digit byte range and ideally not sequential but secure
    # random numbers, steps omitted here to keep the example concise.
    #
    #     root_key = OpenSSL::PKey::RSA.new 2048 # the CA's public/private key
    #     root_ca = OpenSSL::X509::Certificate.new
    #     root_ca.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
    #     root_ca.serial = 1
    #     root_ca.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby CA"
    #     root_ca.issuer = root_ca.subject # root CA's are "self-signed"
    #     root_ca.public_key = root_key.public_key
    #     root_ca.not_before = Time.now
    #     root_ca.not_after = root_ca.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    #     ef = OpenSSL::X509::ExtensionFactory.new
    #     ef.subject_certificate = root_ca
    #     ef.issuer_certificate = root_ca
    #     root_ca.add_extension(ef.create_extension("basicConstraints","CA:TRUE",true))
    #     root_ca.add_extension(ef.create_extension("keyUsage","keyCertSign, cRLSign", true))
    #     root_ca.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    #     root_ca.add_extension(ef.create_extension("authorityKeyIdentifier","keyid:always",false))
    #     root_ca.sign(root_key, OpenSSL::Digest.new('SHA256'))
    #
    # The next step is to create the end-entity certificate using the root CA
    # certificate.
    #
    #     key = OpenSSL::PKey::RSA.new 2048
    #     cert = OpenSSL::X509::Certificate.new
    #     cert.version = 2
    #     cert.serial = 2
    #     cert.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby certificate"
    #     cert.issuer = root_ca.subject # root CA is the issuer
    #     cert.public_key = key.public_key
    #     cert.not_before = Time.now
    #     cert.not_after = cert.not_before + 1 * 365 * 24 * 60 * 60 # 1 years validity
    #     ef = OpenSSL::X509::ExtensionFactory.new
    #     ef.subject_certificate = cert
    #     ef.issuer_certificate = root_ca
    #     cert.add_extension(ef.create_extension("keyUsage","digitalSignature", true))
    #     cert.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    #     cert.sign(root_key, OpenSSL::Digest.new('SHA256'))
    #
    class Certificate
      include OpenSSL::X509::Extension::AuthorityInfoAccess

      include OpenSSL::X509::Extension::CRLDistributionPoints

      include OpenSSL::X509::Extension::AuthorityKeyIdentifier

      include OpenSSL::X509::Extension::SubjectKeyIdentifier

      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert1 == cert2 -> true | false
      # -->
      # Compares the two certificates. Note that this takes into account all fields,
      # not just the issuer name and the serial number.
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.add_extension(extension) => extension
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.check_private_key(key) -> true | false
      # -->
      # Returns `true` if *key* is the corresponding private key to the Subject Public
      # Key Information, `false` otherwise.
      #
      def check_private_key: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.extensions => [extension...]
      # -->
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.extensions = [ext...] => [ext...]
      # -->
      #
      def extensions=: (Array[Extension]) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - inspect()
      # -->
      #
      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.issuer => name
      # -->
      #
      def issuer: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.issuer = name => name
      # -->
      #
      def issuer=: (Name) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_after => time
      # -->
      #
      def not_after: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_after = time => time
      # -->
      #
      def not_after=: (Time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_before => time
      # -->
      #
      def not_before: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_before = time => time
      # -->
      #
      def not_before=: (Time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - pretty_print(q)
      # -->
      #
      def pretty_print: (untyped q) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.public_key => key
      # -->
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.public_key = key
      # -->
      #
      def public_key=: (PKey::PKey pkey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.serial => integer
      # -->
      #
      def serial: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.serial = integer => integer
      # -->
      #
      def serial=: (bn serial) -> bn

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.sign(key, digest) => self
      # -->
      #
      def sign: (PKey::PKey key, String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.signature_algorithm => string
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.subject => name
      # -->
      #
      def subject: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.subject = name => name
      # -->
      #
      def subject=: (Name) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_der => string
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_pem => string
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_text => string
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.verify(key) => true | false
      # -->
      # Verifies the signature of the certificate, with the public key *key*. *key*
      # must be an instance of OpenSSL::PKey.
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.version => integer
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.version = integer => integer
      # -->
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - Certificate.new => cert
      #   - Certificate.new(string) => cert
      # -->
      #
      def initialize: (?String pem) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class CertificateError < OpenSSL::OpenSSLError
    end

    class Extension
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - critical=(p1)
      # -->
      #
      def critical=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - critical?()
      # -->
      #
      def critical?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - oid()
      # -->
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - oid=(p1)
      # -->
      #
      def oid=: (String oid) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_a()
      # -->
      #
      def to_a: () -> [ String, String, bool ]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_h()
      # -->
      #
      def to_h: () -> Hash[String, untyped]

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_s()
      # -->
      #
      def to_s: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value()
      # -->
      #
      def value: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value=(p1)
      # -->
      #
      def value=: (String | ASN1::_ToDer data) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value_der()
      # -->
      #
      def value_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - OpenSSL::X509::Extension.new(der)
      #   - OpenSSL::X509::Extension.new(oid, value)
      #   - OpenSSL::X509::Extension.new(oid, value, critical)
      # -->
      # Creates an X509 extension.
      #
      # The extension may be created from *der* data or from an extension *oid* and
      # *value*.  The *oid* may be either an OID or an extension name.  If *critical*
      # is `true` the extension is marked critical.
      #
      def initialize: (String der) -> void
                    | (String oid, String value, ?boolish critical) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      module AuthorityInfoAccess
        include OpenSSL::X509::Extension::Helpers

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - ca_issuer_uris()
        # -->
        # Get the information and services for the issuer from the certificate's
        # authority information access extension exteension, as described in RFC5280
        # Section 4.2.2.1.
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def ca_issuer_uris: () -> Array[String]?

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - ocsp_uris()
        # -->
        # Get the URIs for OCSP from the certificate's authority information access
        # extension exteension, as described in RFC5280 Section 4.2.2.1.
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def ocsp_uris: () -> Array[String]?

        private

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - parse_aia_asn1()
        # -->
        #
        def parse_aia_asn1: () -> untyped
      end

      module AuthorityKeyIdentifier
        include OpenSSL::X509::Extension::Helpers

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - authority_key_identifier()
        # -->
        # Get the issuing certificate's key identifier from the authorityKeyIdentifier
        # extension, as described in RFC5280 Section 4.2.1.1
        #
        # Returns the binary String keyIdentifier or nil or raises ASN1::ASN1Error.
        #
        def authority_key_identifier: () -> String?
      end

      module CRLDistributionPoints
        include OpenSSL::X509::Extension::Helpers

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - crl_uris()
        # -->
        # Get the distributionPoint fullName URI from the certificate's CRL distribution
        # points extension, as described in RFC 5280 Section 4.2.1.13.
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def crl_uris: () -> Array[String]?
      end

      module Helpers
        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - find_extension(oid)
        # -->
        #
        def find_extension: (String oid) -> Extension?
      end

      module SubjectKeyIdentifier
        include OpenSSL::X509::Extension::Helpers

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - subject_key_identifier()
        # -->
        # Get the subject's key identifier from the subjectKeyIdentifier exteension, as
        # described in RFC5280 Section 4.2.1.2.
        #
        # Returns the binary String key identifier or nil or raises ASN1::ASN1Error.
        #
        def subject_key_identifier: () -> String?
      end
    end

    class ExtensionError < OpenSSL::OpenSSLError
    end

    class ExtensionFactory
      def config: () -> Config?

      def config=: (Config config) -> Config

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - ef.create_ext(ln_or_sn, "value", critical = false) -> X509::Extension
      #   - ef.create_ext(ln_or_sn, "critical,value")          -> X509::Extension
      # -->
      # Creates a new X509::Extension with passed values. See also x509v3_config(5).
      #
      def create_ext: (String oid, String value, ?boolish critical) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_array(ary)
      # -->
      #
      def create_ext_from_array: ([ String, String ] | [ String, String, boolish ] ary) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_hash(hash)
      # -->
      #
      def create_ext_from_hash: (Hash[String, String | boolish] hash) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_string(str)
      # -->
      #
      def create_ext_from_string: (String str) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_extension(*arg)
      # -->
      #
      def create_extension: (String oid, String value, ?boolish critical) -> Extension

      def crl: () -> CRL?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - crl=(p1)
      # -->
      #
      def crl=: (CRL crl) -> CRL

      def issuer_certificate: () -> Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - issuer_certificate=(p1)
      # -->
      #
      def issuer_certificate=: (Certificate cert) -> Certificate

      def subject_certificate: () -> Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - subject_certificate=(p1)
      # -->
      #
      def subject_certificate=: (Certificate cert) -> Certificate

      def subject_request: () -> Request?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - subject_request=(p1)
      # -->
      #
      def subject_request=: (Request request) -> Request

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)
      # -->
      #
      def initialize: (?Certificate? issuer_cert, ?Certificate? subject_cert, ?Request? request, ?CRL? crl) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
    # An X.509 name represents a hostname, email address or other entity associated
    # with a public key.
    #
    # You can create a Name by parsing a distinguished name String or by supplying
    # the distinguished name as an Array.
    #
    #     name = OpenSSL::X509::Name.parse_rfc2253 'DC=example,CN=nobody'
    #
    #     name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]
    #
    class Name
      type distinguished_name = [ String, String ]

      type template = Hash[String, Integer]

      include OpenSSL::Marshal

      include Comparable

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      #
      alias self.parse self.parse_openssl

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      # Parses the string representation of a distinguished name. Two different forms
      # are supported:
      #
      # *   OpenSSL format (`X509_NAME_oneline()`) used by `#to_s`. For example:
      #     `/DC=com/DC=example/CN=nobody`
      # *   OpenSSL format (`X509_NAME_print()`) used by
      #     `#to_s(OpenSSL::X509::Name::COMPAT)`. For example: `DC=com, DC=example,
      #     CN=nobody`
      #
      # Neither of them is standardized and has quirks and inconsistencies in handling
      # of escaped characters or multi-valued RDNs.
      #
      # Use of this method is discouraged in new applications. See Name.parse_rfc2253
      # and #to_utf8 for the alternative.
      #
      def self.parse_openssl: (String str, ?template template) -> instance

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      # Parses the UTF-8 string representation of a distinguished name, according to
      # RFC 2253.
      #
      # See also #to_utf8 for the opposite operation.
      #
      def self.parse_rfc2253: (String str, ?template template) -> instance

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # Compares this Name with *other* and returns `0` if they are the same and `-1`
      # or `+1` if they are greater or less than each other respectively. Returns
      # `nil` if they are not comparable (i.e. different types).
      #
      alias <=> cmp

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.add_entry(oid, value [, type], loc: -1, set: 0) => self
      # -->
      # Adds a new entry with the given *oid* and *value* to this name.  The *oid* is
      # an object identifier defined in ASN.1.  Some common OIDs are:
      #
      # C
      # :   Country Name
      #
      # CN
      # :   Common Name
      #
      # DC
      # :   Domain Component
      #
      # O
      # :   Organization Name
      #
      # OU
      # :   Organizational Unit Name
      #
      # ST
      # :   State or Province Name
      #
      #
      # The optional keyword parameters *loc* and *set* specify where to insert the
      # new attribute. Refer to the manpage of X509_NAME_add_entry(3) for details.
      # *loc* defaults to -1 and *set* defaults to 0. This appends a single-valued RDN
      # to the end.
      #
      def add_entry: (String oid, String value, ?loc: Integer, ?set: Integer) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.cmp(other) -> -1 | 0 | 1 | nil
      #   - name <=> other  -> -1 | 0 | 1 | nil
      # -->
      # Compares this Name with *other* and returns `0` if they are the same and `-1`
      # or `+1` if they are greater or less than each other respectively. Returns
      # `nil` if they are not comparable (i.e. different types).
      #
      def cmp: (untyped other) -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.eql?(other) -> true | false
      # -->
      # Returns true if *name* and *other* refer to the same hash key.
      #
      def eql?: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.hash => integer
      # -->
      # The hash value returned is suitable for use as a certificate's filename in a
      # CA path.
      #
      def hash: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.hash_old => integer
      # -->
      # Returns an MD5 based hash used in OpenSSL 0.9.X.
      #
      def hash_old: () -> Integer

      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - pretty_print(q)
      # -->
      #
      def pretty_print: (untyped q) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_a => [[name, data, type], ...]
      # -->
      # Returns an Array representation of the distinguished name suitable for passing
      # to ::new
      #
      def to_a: () -> Array[[ String, String, Integer ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_der => string
      # -->
      # Converts the name to DER encoding
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_s         -> string
      #   - name.to_s(format) -> string
      # -->
      # Returns a String representation of the Distinguished Name. *format* is one of:
      #
      # *   OpenSSL::X509::Name::COMPAT
      # *   OpenSSL::X509::Name::RFC2253
      # *   OpenSSL::X509::Name::ONELINE
      # *   OpenSSL::X509::Name::MULTILINE
      #
      # If *format* is omitted, the largely broken and traditional OpenSSL format
      # (`X509_NAME_oneline()` format) is chosen.
      #
      # **Use of this method is discouraged.** None of the formats other than
      # OpenSSL::X509::Name::RFC2253 is standardized and may show an inconsistent
      # behavior through OpenSSL versions.
      #
      # It is recommended to use #to_utf8 instead, which is equivalent to calling
      # `name.to_s(OpenSSL::X509::Name::RFC2253).force_encoding("UTF-8")`.
      #
      def to_s: (?format format) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_utf8 -> string
      # -->
      # Returns an UTF-8 representation of the distinguished name, as specified in
      # [RFC 2253](https://www.ietf.org/rfc/rfc2253.txt).
      #
      def to_utf8: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - X509::Name.new                               => name
      #   - X509::Name.new(der)                          => name
      #   - X509::Name.new(distinguished_name)           => name
      #   - X509::Name.new(distinguished_name, template) => name
      # -->
      # Creates a new Name.
      #
      # A name may be created from a DER encoded string *der*, an Array representing a
      # *distinguished_name* or a *distinguished_name* along with a *template*.
      #
      #     name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]
      #
      #     name = OpenSSL::X509::Name.new name.to_der
      #
      # See add_entry for a description of the *distinguished_name* Array's contents
      #
      def initialize: (distinguished_name name, template template) -> void
                    | (Array[distinguished_name] names) -> void
                    | (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Breaks the name returned into multiple lines if longer than 80 characters.
      #
      COMPAT: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # The default object type for name entries.
      #
      DEFAULT_OBJECT_TYPE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns a multiline format.
      #
      MULTILINE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # The default object type template for name entries.
      #
      OBJECT_TYPE_TEMPLATE: template

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns a more readable format than RFC2253.
      #
      ONELINE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns an RFC2253 format name.
      #
      RFC2253: Integer

      type format = Integer

      module RFC2253DN
        def self.expand_hexstring: (untyped str) -> untyped

        def self.expand_pair: (untyped str) -> untyped

        def self.expand_value: (untyped str1, untyped str2, untyped str3) -> untyped

        def self.scan: (untyped dn) -> untyped

        private

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_hexstring(str)
        # -->
        #
        def expand_hexstring: (untyped str) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_pair(str)
        # -->
        #
        def expand_pair: (untyped str) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_value(str1, str2, str3)
        # -->
        #
        def expand_value: (untyped str1, untyped str2, untyped str3) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - scan(dn)
        # -->
        #
        def scan: (String dn) -> Array[distinguished_name]

        AttributeType: Regexp

        AttributeValue: Regexp

        HexChar: Regexp

        HexPair: Regexp

        HexString: Regexp

        Pair: Regexp

        QuoteChar: Regexp

        Special: String

        StringChar: Regexp

        TypeAndValue: Regexp
      end
    end

    class NameError < OpenSSL::OpenSSLError
    end

    class Request
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (untyped other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - add_attribute(p1)
      # -->
      #
      def add_attribute: (Attribute attribute) -> Attribute

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - attributes()
      # -->
      #
      def attributes: () -> Array[Attribute]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - attributes=(p1)
      # -->
      #
      def attributes=: (Array[Attribute] attributes) -> Array[Attribute]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - public_key()
      # -->
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - public_key=(p1)
      # -->
      #
      def public_key=: (PKey::PKey public_key) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - sign(p1, p2)
      # -->
      #
      def sign: (PKey::PKey key, Digest | String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - signature_algorithm()
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - subject()
      # -->
      #
      def subject: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - subject=(p1)
      # -->
      #
      def subject=: (Name subject) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_pem()
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_text()
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - verify(p1)
      # -->
      # Checks that cert signature is made with PRIVversion of this PUBLIC 'key'
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - version()
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - version=(p1)
      # -->
      #
      def version=: (Integer version) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - new(p1 = v1)
      # -->
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class RequestError < OpenSSL::OpenSSLError
    end

    class Revoked
      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (untyped other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - add_extension(p1)
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - extensions()
      # -->
      # Gets X509v3 extensions as array of X509Ext objects
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - extensions=(p1)
      # -->
      # Sets X509_EXTENSIONs
      #
      def extensions=: (Array[Extension] extensions) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - serial=(p1)
      # -->
      #
      def serial=: (Integer integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - time()
      # -->
      #
      def time: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - time=(p1)
      # -->
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - new(*args)
      # -->
      #
      def initialize: (*untyped) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class RevokedError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
    # The X509 certificate store holds trusted CA certificates used to verify peer
    # certificates.
    #
    # The easiest way to create a useful certificate store is:
    #
    #     cert_store = OpenSSL::X509::Store.new
    #     cert_store.set_default_paths
    #
    # This will use your system's built-in certificates.
    #
    # If your system does not have a default set of certificates you can obtain a
    # set extracted from Mozilla CA certificate store by cURL maintainers here:
    # https://curl.haxx.se/docs/caextract.html (You may wish to use the
    # firefox-db2pem.sh script to extract the certificates from a local install to
    # avoid man-in-the-middle attacks.)
    #
    # After downloading or generating a cacert.pem from the above link you can
    # create a certificate store from the pem file like this:
    #
    #     cert_store = OpenSSL::X509::Store.new
    #     cert_store.add_file 'cacert.pem'
    #
    # The certificate store can be used with an SSLSocket like this:
    #
    #     ssl_context = OpenSSL::SSL::SSLContext.new
    #     ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
    #     ssl_context.cert_store = cert_store
    #
    #     tcp_socket = TCPSocket.open 'example.com', 443
    #
    #     ssl_socket = OpenSSL::SSL::SSLSocket.new tcp_socket, ssl_context
    #
    class Store
      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_cert(cert) -> self
      # -->
      # Adds the OpenSSL::X509::Certificate *cert* to the certificate store.
      #
      # See also the man page X509_STORE_add_cert(3).
      #
      def add_cert: (Certificate certificate) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_crl(crl) -> self
      # -->
      # Adds the OpenSSL::X509::CRL *crl* to the store.
      #
      # See also the man page X509_STORE_add_crl(3).
      #
      def add_crl: (CRL crl) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_file(file) -> self
      # -->
      # Adds the certificates in *file* to the certificate store. *file* is the path
      # to the file, and the file contains one or more certificates in PEM format
      # concatenated together.
      #
      # See also the man page X509_LOOKUP_file(3).
      #
      def add_file: (String file) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_path(path) -> self
      # -->
      # Adds *path* as the hash dir to be looked up by the store.
      #
      # See also the man page X509_LOOKUP_hash_dir(3).
      #
      def add_path: (String path) -> self

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The certificate chain constructed by the last call of #verify.
      #
      # See also StoreContext#chain.
      #
      def chain: () -> Array[Certificate]?

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The error code set by the last call of #verify.
      #
      # See also StoreContext#error.
      #
      def error: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The description for the error code set by the last call of #verify.
      #
      # See also StoreContext#error_string.
      #
      def error_string: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.flags = flags
      # -->
      # Sets the default flags used by certificate chain verification performed with
      # the Store.
      #
      # *flags* consists of zero or more of the constants defined in OpenSSL::X509
      # with name V_FLAG_* or'ed together.
      #
      # OpenSSL::X509::StoreContext#flags= can be used to change the flags for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_flags(3).
      #
      def flags=: (Integer flags) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.purpose = purpose
      # -->
      # Sets the store's default verification purpose. If specified, the verifications
      # on the store will check every certificate's extensions are consistent with the
      # purpose. The purpose is specified by constants:
      #
      # *   X509::PURPOSE_SSL_CLIENT
      # *   X509::PURPOSE_SSL_SERVER
      # *   X509::PURPOSE_NS_SSL_SERVER
      # *   X509::PURPOSE_SMIME_SIGN
      # *   X509::PURPOSE_SMIME_ENCRYPT
      # *   X509::PURPOSE_CRL_SIGN
      # *   X509::PURPOSE_ANY
      # *   X509::PURPOSE_OCSP_HELPER
      # *   X509::PURPOSE_TIMESTAMP_SIGN
      #
      # OpenSSL::X509::StoreContext#purpose= can be used to change the value for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_purpose(3).
      #
      def purpose=: (Integer purpose) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.set_default_paths
      # -->
      # Configures *store* to look up CA certificates from the system default
      # certificate store as needed basis. The location of the store can usually be
      # determined by:
      #
      # *   OpenSSL::X509::DEFAULT_CERT_FILE
      # *   OpenSSL::X509::DEFAULT_CERT_DIR
      #
      # See also the man page X509_STORE_set_default_paths(3).
      #
      def set_default_paths: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.time = time
      # -->
      # Sets the time to be used in the certificate verifications with the store. By
      # default, if not specified, the current system time is used.
      #
      # OpenSSL::X509::StoreContext#time= can be used to change the value for a single
      # verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_time(3).
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.trust = trust
      # -->
      # Sets the default trust settings used by the certificate verification with the
      # store.
      #
      # OpenSSL::X509::StoreContext#trust= can be used to change the value for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_trust(3).
      #
      def trust=: (Integer trust) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.verify(cert, chain = nil) -> true | false
      # -->
      # Performs a certificate verification on the OpenSSL::X509::Certificate *cert*.
      #
      # *chain* can be an array of OpenSSL::X509::Certificate that is used to
      # construct the certificate chain.
      #
      # If a block is given, it overrides the callback set by #verify_callback=.
      #
      # After finishing the verification, the error information can be retrieved by
      # #error, #error_string, and the resulting complete certificate chain can be
      # retrieved by #chain.
      #
      def verify: (Certificate certificate, ?Array[Certificate] chain) ?{ (bool preverify_ok, StoreContext store_ctx) -> boolish } -> boolish

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The callback for additional certificate verification. It is invoked for each
      # certificate in the chain and can be used to implement custom certificate
      # verification conditions.
      #
      # The callback is invoked with two values, a boolean that indicates if the
      # pre-verification by OpenSSL has succeeded or not, and the StoreContext in use.
      #
      # The callback can use StoreContext#error= to change the error code as needed.
      # The callback must return either true or false.
      #
      # NOTE: any exception raised within the callback will be ignored.
      #
      # See also the man page X509_STORE_CTX_set_verify_cb(3).
      #
      def verify_callback: () -> (^(bool preverify_ok, StoreContext store_ctx) -> boolish | nil)

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - verify_callback=(p1)
      # -->
      # General callback for OpenSSL verify
      #
      def verify_callback=: [U] (^(bool preverify_ok, StoreContext store_ctx) -> boolish) -> U

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - X509::Store.new => store
      # -->
      # Creates a new X509::Store.
      #
      def initialize: () -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
    # A StoreContext is used while validating a single certificate and holds the
    # status involved.
    #
    class StoreContext
      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.chain -> nil | Array of X509::Certificate
      # -->
      # Returns the verified chain.
      #
      # See also the man page X509_STORE_CTX_set0_verified_chain(3).
      #
      def chain: () -> Array[Certificate]?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - cleanup()
      # -->
      #
      def cleanup: () -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.current_cert -> X509::Certificate
      # -->
      # Returns the certificate which caused the error.
      #
      # See also the man page X509_STORE_CTX_get_current_cert(3).
      #
      def current_cert: () -> Certificate

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.current_crl -> X509::CRL
      # -->
      # Returns the CRL which caused the error.
      #
      # See also the man page X509_STORE_CTX_get_current_crl(3).
      #
      def current_crl: () -> CRL

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error -> Integer
      # -->
      # Returns the error code of *stctx*. This is typically called after #verify is
      # done, or from the verification callback set to
      # OpenSSL::X509::Store#verify_callback=.
      #
      # See also the man page X509_STORE_CTX_get_error(3).
      #
      def error: () -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error = error_code
      # -->
      # Sets the error code of *stctx*. This is used by the verification callback set
      # to OpenSSL::X509::Store#verify_callback=.
      #
      # See also the man page X509_STORE_CTX_set_error(3).
      #
      def error=: (Integer error) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error_depth -> Integer
      # -->
      # Returns the depth of the chain. This is used in combination with #error.
      #
      # See also the man page X509_STORE_CTX_get_error_depth(3).
      #
      def error_depth: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error_string -> String
      # -->
      # Returns the human readable error string corresponding to the error code
      # retrieved by #error.
      #
      # See also the man page X509_verify_cert_error_string(3).
      #
      def error_string: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.flags = flags
      # -->
      # Sets the verification flags to the context. This overrides the default value
      # set by Store#flags=.
      #
      # See also the man page X509_VERIFY_PARAM_set_flags(3).
      #
      def flags=: (Integer flags) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.purpose = purpose
      # -->
      # Sets the purpose of the context. This overrides the default value set by
      # Store#purpose=.
      #
      # See also the man page X509_VERIFY_PARAM_set_purpose(3).
      #
      def purpose=: (Integer purpose) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.time = time
      # -->
      # Sets the time used in the verification. If not set, the current time is used.
      #
      # See also the man page X509_VERIFY_PARAM_set_time(3).
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.trust = trust
      # -->
      # Sets the trust settings of the context. This overrides the default value set
      # by Store#trust=.
      #
      # See also the man page X509_VERIFY_PARAM_set_trust(3).
      #
      def trust=: (Integer trust) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.verify -> true | false
      # -->
      # Performs the certificate verification using the parameters set to *stctx*.
      #
      # See also the man page X509_verify_cert(3).
      #
      def verify: () -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - StoreContext.new(store, cert = nil, untrusted = nil)
      # -->
      # Sets up a StoreContext for a verification of the X.509 certificate *cert*.
      #
      def initialize: (Store store, ?Certificate cert, ?Array[Certificate] chain) -> void
    end

    class StoreError < OpenSSL::OpenSSLError
    end
  end
end
# <!-- rdoc-file=lib/optparse.rb -->
# ## OptionParser
#
# ### New to `OptionParser`?
#
# See the [Tutorial](optparse/tutorial.rdoc).
#
# ### Introduction
#
# OptionParser is a class for command-line option analysis.  It is much more
# advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
# solution.
#
# ### Features
#
# 1.  The argument specification and the code to handle it are written in the
#     same place.
# 2.  It can output an option summary; you don't need to maintain this string
#     separately.
# 3.  Optional and mandatory arguments are specified very gracefully.
# 4.  Arguments can be automatically converted to a specified class.
# 5.  Arguments can be restricted to a certain set.
#
# All of these features are demonstrated in the examples below.  See
# #make_switch for full documentation.
#
# ### Minimal example
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.banner = "Usage: example.rb [options]"
#
#       parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
#         options[:verbose] = v
#       end
#     end.parse!
#
#     p options
#     p ARGV
#
# ### Generating Help
#
# OptionParser can be used to automatically generate help for the commands you
# write:
#
#     require 'optparse'
#
#     Options = Struct.new(:name)
#
#     class Parser
#       def self.parse(options)
#         args = Options.new("world")
#
#         opt_parser = OptionParser.new do |parser|
#           parser.banner = "Usage: example.rb [options]"
#
#           parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
#             args.name = n
#           end
#
#           parser.on("-h", "--help", "Prints this help") do
#             puts parser
#             exit
#           end
#         end
#
#         opt_parser.parse!(options)
#         return args
#       end
#     end
#     options = Parser.parse %w[--help]
#
#     #=>
#        # Usage: example.rb [options]
#        #     -n, --name=NAME                  Name to say hello to
#        #     -h, --help                       Prints this help
#
# ### Required Arguments
#
# For options that require an argument, option specification strings may include
# an option name in all caps. If an option is used without the required
# argument, an exception will be raised.
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.on("-r", "--require LIBRARY",
#                 "Require the LIBRARY before executing your script") do |lib|
#         puts "You required #{lib}!"
#       end
#     end.parse!
#
# Used:
#
#     $ ruby optparse-test.rb -r
#     optparse-test.rb:9:in `<main>': missing argument: -r (OptionParser::MissingArgument)
#     $ ruby optparse-test.rb -r my-library
#     You required my-library!
#
# ### Type Coercion
#
# OptionParser supports the ability to coerce command line arguments into
# objects for us.
#
# OptionParser comes with a few ready-to-use kinds of type coercion. They are:
#
# *   Date  -- Anything accepted by `Date.parse` (need to require
#     `optparse/date`)
# *   DateTime -- Anything accepted by `DateTime.parse` (need to require
#     `optparse/date`)
# *   Time -- Anything accepted by `Time.httpdate` or `Time.parse` (need to
#     require `optparse/time`)
# *   URI  -- Anything accepted by `URI.parse` (need to require `optparse/uri`)
# *   Shellwords -- Anything accepted by `Shellwords.shellwords` (need to
#     require `optparse/shellwords`)
# *   String -- Any non-empty string
# *   Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
# *   Float -- Any float. (e.g. 10, 3.14, -100E+13)
# *   Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
# *   DecimalInteger -- Like `Integer`, but no octal format.
# *   OctalInteger -- Like `Integer`, but no decimal format.
# *   DecimalNumeric -- Decimal integer or float.
# *   TrueClass --  Accepts '+, yes, true, -, no, false' and defaults as `true`
# *   FalseClass -- Same as `TrueClass`, but defaults to `false`
# *   Array -- Strings separated by ',' (e.g. 1,2,3)
# *   Regexp -- Regular expressions. Also includes options.
#
# We can also add our own coercions, which we will cover below.
#
# #### Using Built-in Conversions
#
# As an example, the built-in `Time` conversion is used. The other built-in
# conversions behave in the same way. OptionParser will attempt to parse the
# argument as a `Time`. If it succeeds, that time will be passed to the handler
# block. Otherwise, an exception will be raised.
#
#     require 'optparse'
#     require 'optparse/time'
#     OptionParser.new do |parser|
#       parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
#         p time
#       end
#     end.parse!
#
# Used:
#
#     $ ruby optparse-test.rb  -t nonsense
#     ... invalid argument: -t nonsense (OptionParser::InvalidArgument)
#     $ ruby optparse-test.rb  -t 10-11-12
#     2010-11-12 00:00:00 -0500
#     $ ruby optparse-test.rb  -t 9:30
#     2014-08-13 09:30:00 -0400
#
# #### Creating Custom Conversions
#
# The `accept` method on OptionParser may be used to create converters. It
# specifies which conversion block to call whenever a class is specified. The
# example below uses it to fetch a `User` object before the `on` handler
# receives it.
#
#     require 'optparse'
#
#     User = Struct.new(:id, :name)
#
#     def find_user id
#       not_found = ->{ raise "No User Found for id #{id}" }
#       [ User.new(1, "Sam"),
#         User.new(2, "Gandalf") ].find(not_found) do |u|
#         u.id == id
#       end
#     end
#
#     op = OptionParser.new
#     op.accept(User) do |user_id|
#       find_user user_id.to_i
#     end
#
#     op.on("--user ID", User) do |user|
#       puts user
#     end
#
#     op.parse!
#
# Used:
#
#     $ ruby optparse-test.rb --user 1
#     #<struct User id=1, name="Sam">
#     $ ruby optparse-test.rb --user 2
#     #<struct User id=2, name="Gandalf">
#     $ ruby optparse-test.rb --user 3
#     optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)
#
# ### Store options to a Hash
#
# The `into` option of `order`, `parse` and so on methods stores command line
# options into a Hash.
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.on('-a')
#       parser.on('-b NUM', Integer)
#       parser.on('-v', '--verbose')
#     end.parse!(into: options)
#
#     p options
#
# Used:
#
#     $ ruby optparse-test.rb -a
#     {:a=>true}
#     $ ruby optparse-test.rb -a -v
#     {:a=>true, :verbose=>true}
#     $ ruby optparse-test.rb -a -b 100
#     {:a=>true, :b=>100}
#
# ### Complete example
#
# The following example is a complete Ruby program.  You can run it and see the
# effect of specifying various options.  This is probably the best way to learn
# the features of `optparse`.
#
#     require 'optparse'
#     require 'optparse/time'
#     require 'ostruct'
#     require 'pp'
#
#     class OptparseExample
#       Version = '1.0.0'
#
#       CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
#       CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }
#
#       class ScriptOptions
#         attr_accessor :library, :inplace, :encoding, :transfer_type,
#                       :verbose, :extension, :delay, :time, :record_separator,
#                       :list
#
#         def initialize
#           self.library = []
#           self.inplace = false
#           self.encoding = "utf8"
#           self.transfer_type = :auto
#           self.verbose = false
#         end
#
#         def define_options(parser)
#           parser.banner = "Usage: example.rb [options]"
#           parser.separator ""
#           parser.separator "Specific options:"
#
#           # add additional options
#           perform_inplace_option(parser)
#           delay_execution_option(parser)
#           execute_at_time_option(parser)
#           specify_record_separator_option(parser)
#           list_example_option(parser)
#           specify_encoding_option(parser)
#           optional_option_argument_with_keyword_completion_option(parser)
#           boolean_verbose_option(parser)
#
#           parser.separator ""
#           parser.separator "Common options:"
#           # No argument, shows at tail.  This will print an options summary.
#           # Try it and see!
#           parser.on_tail("-h", "--help", "Show this message") do
#             puts parser
#             exit
#           end
#           # Another typical switch to print the version.
#           parser.on_tail("--version", "Show version") do
#             puts Version
#             exit
#           end
#         end
#
#         def perform_inplace_option(parser)
#           # Specifies an optional option argument
#           parser.on("-i", "--inplace [EXTENSION]",
#                     "Edit ARGV files in place",
#                     "(make backup if EXTENSION supplied)") do |ext|
#             self.inplace = true
#             self.extension = ext || ''
#             self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
#           end
#         end
#
#         def delay_execution_option(parser)
#           # Cast 'delay' argument to a Float.
#           parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
#             self.delay = n
#           end
#         end
#
#         def execute_at_time_option(parser)
#           # Cast 'time' argument to a Time object.
#           parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
#             self.time = time
#           end
#         end
#
#         def specify_record_separator_option(parser)
#           # Cast to octal integer.
#           parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
#                     "Specify record separator (default \\0)") do |rs|
#             self.record_separator = rs
#           end
#         end
#
#         def list_example_option(parser)
#           # List of arguments.
#           parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
#             self.list = list
#           end
#         end
#
#         def specify_encoding_option(parser)
#           # Keyword completion.  We are specifying a specific set of arguments (CODES
#           # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
#           # the shortest unambiguous text.
#           code_list = (CODE_ALIASES.keys + CODES).join(', ')
#           parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
#                     "(#{code_list})") do |encoding|
#             self.encoding = encoding
#           end
#         end
#
#         def optional_option_argument_with_keyword_completion_option(parser)
#           # Optional '--type' option argument with keyword completion.
#           parser.on("--type [TYPE]", [:text, :binary, :auto],
#                     "Select transfer type (text, binary, auto)") do |t|
#             self.transfer_type = t
#           end
#         end
#
#         def boolean_verbose_option(parser)
#           # Boolean switch.
#           parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
#             self.verbose = v
#           end
#         end
#       end
#
#       #
#       # Return a structure describing the options.
#       #
#       def parse(args)
#         # The options specified on the command line will be collected in
#         # *options*.
#
#         @options = ScriptOptions.new
#         @args = OptionParser.new do |parser|
#           @options.define_options(parser)
#           parser.parse!(args)
#         end
#         @options
#       end
#
#       attr_reader :parser, :options
#     end  # class OptparseExample
#
#     example = OptparseExample.new
#     options = example.parse(ARGV)
#     pp options # example.options
#     pp ARGV
#
# ### Shell Completion
#
# For modern shells (e.g. bash, zsh, etc.), you can use shell completion for
# command line options.
#
# ### Further documentation
#
# The above examples, along with the accompanying
# [Tutorial](optparse/tutorial.rdoc), should be enough to learn how to use this
# class. If you have any questions, file a ticket at http://bugs.ruby-lang.org.
#
class OptionParser
  interface _Pattern
    def match: (untyped other) -> boolish
  end

  interface _Intoable
    def []=: (Symbol, untyped) -> untyped
  end

  interface _LtLtString
    def <<: (String) -> untyped
  end

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(*args, &blk)
  # -->
  # See #accept.
  #
  def self.accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args, symbolize_names: false)
  # -->
  # See #getopts.
  #
  def self.getopts: (*String options) -> Hash[String, untyped]
                  | (Array[String] args, *String options) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inc(arg, default = nil)
  # -->
  # Returns an incremented value of `default` according to `arg`.
  #
  def self.inc: (untyped arg, ?_ToI default) -> Integer?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(*args, &blk)
  # -->
  # See #reject.
  #
  def self.reject: (Class t) -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - terminate(arg = nil)
  # -->
  # See #terminate.
  #
  def self.terminate: (?String arg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - top()
  # -->
  # Returns the global top option list.
  #
  # Do not use directly.
  #
  def self.top: () -> OptionParser::List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - with(*args, &block)
  # -->
  # Initializes a new instance and evaluates the optional block in context of the
  # instance. Arguments `args` are passed to #new, see there for description of
  # parameters.
  #
  # This method is **deprecated**, its behavior corresponds to the older #new
  # method.
  #
  def self.with: (?String banner, ?Integer width, ?String indent) ?{ (instance opts) -> void } -> instance

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - abort(mesg = $!)
  # -->
  # Shows message with the program name then aborts.
  #
  # `mesg`
  # :   Message, defaulted to +$!+.
  #
  #
  # See Kernel#abort.
  #
  def abort: (?_ToS mesg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(*args, &blk)
  # -->
  # Directs to accept specified class `t`. The argument string is passed to the
  # block in which it should be converted to the desired class.
  #
  # `t`
  # :   Argument class specifier, any object including Class.
  #
  # `pat`
  # :   Pattern for argument, defaults to `t` if it responds to match.
  #
  #
  #     accept(t, pat, &block)
  #
  def accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  def add_officious: () -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - additional_message(typ, opt)
  # -->
  # Returns additional info.
  #
  def additional_message: (untyped typ, untyped opt) -> String?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Heading banner preceding summary.
  #
  attr_accessor banner: String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - base()
  # -->
  # Subject of #on_tail.
  #
  def base: () -> List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(word)
  # -->
  # Return candidates for `word`.
  #
  def candidate: (String word) -> Array[untyped]

  def compsys: (untyped to, ?untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_head_option(*opts, &block)
  # -->
  #
  alias def_head_option define_head

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_option(*opts, &block)
  # -->
  #
  alias def_option define

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_tail_option(*opts, &block)
  # -->
  #
  alias def_tail_option define_tail

  # <!-- rdoc-file=lib/optparse.rb -->
  # Strings to be parsed in default.
  #
  attr_accessor default_argv: Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  def define: (*String params) ?{ (*untyped) -> untyped } -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
            | (*String params, Proc | Method handler) -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define_head(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  def define_head: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define_tail(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  def define_tail: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - environment(env = File.basename($0, '.*'), **keywords)
  # -->
  # Parses environment variable `env` or its uppercase with splitting like a
  # shell.
  #
  # `env` defaults to the basename of the program.
  #
  def environment: (?String env) -> Array[String]?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args, symbolize_names: false, **keywords)
  # -->
  # Wrapper method for getopts.rb.
  #
  #     params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
  #     # params["a"] = true   # -a
  #     # params["b"] = "1"    # -b1
  #     # params["foo"] = "1"  # --foo
  #     # params["bar"] = "x"  # --bar x
  #     # params["zot"] = "z"  # --zot Z
  #
  # Option `symbolize_names` (boolean) specifies whether returned Hash keys should
  # be Symbols; defaults to `false` (use Strings).
  #
  #     params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option", symbolize_names: true)
  #     # params[:a] = true   # -a
  #     # params[:b] = "1"    # -b1
  #     # params[:foo] = "1"  # --foo
  #     # params[:bar] = "x"  # --bar x
  #     # params[:zot] = "z"  # --zot Z
  #
  def getopts: (*String options) -> Hash[String, untyped]
             | (Array[String] args, *String options) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - help()
  # -->
  # Returns option summary string.
  #
  def help: () -> String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inc(*args)
  # -->
  # See self.inc
  #
  def inc: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - load(filename = nil, **keywords)
  # -->
  # Loads options from file names as `filename`. Does nothing when the file is not
  # present. Returns whether successfully loaded.
  #
  # `filename` defaults to basename of the program without suffix in a directory
  # ~/.options, then the basename with '.options' suffix under XDG and Haiku
  # standard places.
  #
  # The optional `into` keyword argument works exactly like that accepted in
  # method #parse.
  #
  def load: (?String filename) -> bool

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - make_switch(params, block = nil)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  def make_switch: (Array[untyped] opts, ?Proc block) -> [ untyped, untyped, untyped, untyped, untyped ]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new() { |self| ... }
  # -->
  # Pushes a new List.
  #
  # If a block is given, yields `self` and returns the result of the block,
  # otherwise returns `self`.
  #
  def new: () -> self
         | [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  def on: (*String params) ?{ (*untyped) -> untyped } -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
        | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
        | (*String params, Proc | Method handler) -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
        | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on_head(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  # The new option is added at the head of the summary.
  #
  def on_head: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on_tail(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](optparse/option_params.rdoc).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](optparse/option_params.rdoc#label-Option+Handlers).
  #
  # The new option is added at the tail of the summary.
  #
  def on_tail: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order(*argv, **keywords, &nonopt)
  # -->
  # Parses command line arguments `argv` in order. When a block is given, each
  # non-option argument is yielded. When optional `into` keyword argument is
  # provided, the parsed option values are stored there via `[]=` method (so it
  # can be Hash, or OpenStruct, or other similar object).
  #
  # Returns the rest of `argv` left unparsed.
  #
  def order: (*String argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]
           | (Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order!(argv = default_argv, into: nil, **keywords, &nonopt)
  # -->
  # Same as #order, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def order!: (?Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(*argv, **keywords)
  # -->
  # Parses command line arguments `argv` in order when environment variable
  # POSIXLY_CORRECT is set, and in permutation mode otherwise. When optional
  # `into` keyword argument is provided, the parsed option values are stored there
  # via `[]=` method (so it can be Hash, or OpenStruct, or other similar object).
  #
  def parse: (*String argv, ?into: _Intoable) -> Array[String]
           | (Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse!(argv = default_argv, **keywords)
  # -->
  # Same as #parse, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def parse!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute(*argv, **keywords)
  # -->
  # Parses command line arguments `argv` in permutation mode and returns list of
  # non-option arguments. When optional `into` keyword argument is provided, the
  # parsed option values are stored there via `[]=` method (so it can be Hash, or
  # OpenStruct, or other similar object).
  #
  def permute: (*String argv, ?into: _Intoable) -> Array[String]
             | (Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute!(argv = default_argv, **keywords)
  # -->
  # Same as #permute, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def permute!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!-- rdoc-file=lib/optparse.rb -->
  # Program name to be emitted in error message and default banner, defaults to
  # $0.
  #
  attr_accessor program_name: String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(*args, &blk)
  # -->
  # Directs to reject specified class argument.
  #
  # `type`
  # :   Argument class specifier, any object including Class.
  #
  #
  #     reject(type)
  #
  def reject: (Class t) -> void

  # <!-- rdoc-file=lib/optparse.rb -->
  # Release code
  #
  def release: () -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Release code
  #
  def release=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - remove()
  # -->
  # Removes the last List.
  #
  def remove: () -> List?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Whether to require that options match exactly (disallows providing abbreviated
  # long option as short option).
  #
  attr_accessor require_exact: boolish

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - separator(string)
  # -->
  # Add separator in summary.
  #
  def separator: (String string) -> void

  # Heading banner preceding summary.
  #
  alias set_banner banner=

  # Program name to be emitted in error message and default banner, defaults to
  # $0.
  #
  alias set_program_name program_name=

  # <!-- rdoc-file=lib/optparse.rb -->
  # Indentation for summary. Must be String (or have + String method).
  #
  alias set_summary_indent summary_indent=

  # <!-- rdoc-file=lib/optparse.rb -->
  # Width for option list portion of summary. Must be Numeric.
  #
  alias set_summary_width summary_width=

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)
  # -->
  # Puts option summary into `to` and returns `to`. Yields each line if a block is
  # given.
  #
  # `to`
  # :   Output destination, which must have method <<. Defaults to [].
  #
  # `width`
  # :   Width of left side, defaults to @summary_width.
  #
  # `max`
  # :   Maximum length allowed for left side, defaults to `width` - 1.
  #
  # `indent`
  # :   Indentation, defaults to @summary_indent.
  #
  def summarize: (?_LtLtString to, ?Integer width, ?Integer max, ?String indent) ?{ (String line) -> void } -> _LtLtString

  # <!-- rdoc-file=lib/optparse.rb -->
  # Indentation for summary. Must be String (or have + String method).
  #
  attr_accessor summary_indent: String

  # <!-- rdoc-file=lib/optparse.rb -->
  # Width for option list portion of summary. Must be Numeric.
  #
  attr_accessor summary_width: Integer

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - terminate(arg = nil)
  # -->
  # Terminates option parsing. Optional parameter `arg` is a string pushed back to
  # be the first non-option argument.
  #
  def terminate: (?String arg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_a()
  # -->
  # Returns option summary list.
  #
  def to_a: () -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_s()
  # -->
  #
  alias to_s help

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - top()
  # -->
  # Subject of #on / #on_head, #accept / #reject
  #
  def top: () -> List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - ver()
  # -->
  # Returns version string from program_name, version and release.
  #
  def ver: () -> String?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Version
  #
  attr_accessor version: String?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - warn(mesg = $!)
  # -->
  # Shows warning message with the program name
  #
  # `mesg`
  # :   Message, defaulted to +$!+.
  #
  #
  # See Kernel#warn.
  #
  def warn: (?_ToS mesg) -> void

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(typ, opt, icase = false, *pat)
  # -->
  # Completes shortened long style option switch and returns pair of canonical
  # switch and switch descriptor OptionParser::Switch.
  #
  # `typ`
  # :   Searching table.
  # `opt`
  # :   Searching key.
  # `icase`
  # :   Search case insensitive if true.
  # `pat`
  # :   Optional pattern for completion.
  #
  def complete: (untyped typ, untyped opt, ?untyped icase, *untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(banner = nil, width = 32, indent = ' ' * 4) { |self| ... }
  # -->
  # Initializes the instance and yields itself if called with a block.
  #
  # `banner`
  # :   Banner message.
  #
  # `width`
  # :   Summary width.
  #
  # `indent`
  # :   Summary indent.
  #
  def initialize: (?String banner, ?Integer width, ?String indent) ?{ (OptionParser) -> void } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - notwice(obj, prv, msg)
  # -->
  # Checks if an argument is given twice, in which case an ArgumentError is
  # raised. Called from OptionParser#switch only.
  #
  # `obj`
  # :   New argument.
  # `prv`
  # :   Previously specified argument.
  # `msg`
  # :   Exception message.
  #
  def notwice: (untyped obj, untyped prv, untyped msg) -> untyped

  def parse_in_order: (?untyped argv, ?untyped setter) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - search(id, key) { |k| ... }
  # -->
  # Searches `key` in @stack for `id` hash and returns or yields the result.
  #
  def search: (untyped id, untyped key) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - visit(id, *args, &block)
  # -->
  # Traverses @stack, sending each element method `id` with `args` and `block`.
  #
  def visit: (untyped id, *untyped args) { (*untyped) -> untyped } -> untyped
end

OptionParser::ArgumentStyle: Hash[untyped, untyped]

OptionParser::COMPSYS_HEADER: String

# <!-- rdoc-file=lib/optparse.rb -->
# Decimal integer format, to be converted to Integer.
#
OptionParser::DecimalInteger: Regexp

# <!-- rdoc-file=lib/optparse.rb -->
# Decimal integer/float number format, to be converted to Integer for integer
# format, Float for float format.
#
OptionParser::DecimalNumeric: Regexp

OptionParser::DefaultList: OptionParser::List

OptionParser::NO_ARGUMENT: Symbol

OptionParser::NoArgument: [ :NONE, nil ]

OptionParser::OPTIONAL_ARGUMENT: Symbol

# <!-- rdoc-file=lib/optparse.rb -->
# Ruby/C like octal/hexadecimal/binary integer format, to be converted to
# Integer.
#
OptionParser::OctalInteger: Regexp

OptionParser::Officious: Hash[untyped, untyped]

OptionParser::OptionalArgument: Array[untyped]

OptionParser::REQUIRED_ARGUMENT: Symbol

OptionParser::RequiredArgument: Array[untyped]

OptionParser::SPLAT_PROC: Proc

# <!-- rdoc-file=lib/optparse.rb -->
# The version string
#
OptionParser::Version: String

# <!-- rdoc-file=lib/optparse.rb -->
# Acceptable argument classes. Now contains DecimalInteger, OctalInteger and
# DecimalNumeric. See Acceptable argument classes (in source code).
#
module OptionParser::Acceptables
end

OptionParser::Acceptables::DecimalInteger: Regexp

OptionParser::Acceptables::DecimalNumeric: Regexp

OptionParser::Acceptables::OctalInteger: Regexp

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when the given argument word can't be completed uniquely.
#
class OptionParser::AmbiguousArgument < OptionParser::InvalidArgument
end

OptionParser::AmbiguousArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when ambiguously completable string is encountered.
#
class OptionParser::AmbiguousOption < OptionParser::ParseError
end

OptionParser::AmbiguousOption::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Extends command line arguments array (ARGV) to parse itself.
#
module OptionParser::Arguable
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - extend_object(obj)
  # -->
  # Initializes instance variable.
  #
  def self.extend_object: (untyped obj) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args, symbolize_names: false, **keywords)
  # -->
  # Substitution of getopts is possible as follows. Also see OptionParser#getopts.
  #
  #     def getopts(*args)
  #       ($OPT = ARGV.getopts(*args)).each do |opt, val|
  #         eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"
  #       end
  #     rescue OptionParser::ParseError
  #     end
  #
  def getopts: (*String args) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - options() { |optparse| ... }
  # -->
  # Actual OptionParser object, automatically created if nonexistent.
  #
  # If called with a block, yields the OptionParser object and returns the result
  # of the block. If an OptionParser::ParseError exception occurs in the block, it
  # is rescued, a error message printed to STDERR and `nil` returned.
  #
  def options: () -> OptionParser
             | [T] () { (OptionParser) -> T } -> T?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - options=(opt)
  # -->
  # Sets OptionParser object, when `opt` is `false` or `nil`, methods
  # OptionParser::Arguable#options and OptionParser::Arguable#options= are
  # undefined. Thus, there is no ways to access the OptionParser object via the
  # receiver object.
  #
  def options=: (OptionParser? opt) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order!(**keywords, &blk)
  # -->
  # Parses `self` destructively in order and returns `self` containing the rest
  # arguments left unparsed.
  #
  def order!: () ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse!(**keywords)
  # -->
  # Parses `self` destructively and returns `self` containing the rest arguments
  # left unparsed.
  #
  def parse!: () -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute!(**keywords)
  # -->
  # Parses `self` destructively in permutation mode and returns `self` containing
  # the rest arguments left unparsed.
  #
  def permute!: () -> Array[String]
end

# <!-- rdoc-file=lib/optparse.rb -->
# Hash with completion search feature. See OptionParser::Completion.
#
class OptionParser::CompletingHash < Hash[untyped, untyped]
  include OptionParser::Completion

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - match(key)
  # -->
  # Completion for hash key.
  #
  def match: (untyped key) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Keyword completion module.  This allows partial arguments to be specified and
# resolved against a list of acceptable values.
#
module OptionParser::Completion
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(key, icase = false, pat = nil, &block)
  # -->
  #
  def self.candidate: (untyped key, ?untyped icase, ?untyped pat) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - regexp(key, icase)
  # -->
  #
  def self.regexp: (untyped key, untyped icase) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(key, icase = false, pat = nil)
  # -->
  #
  def candidate: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(key, icase = false, pat = nil) { |key, *sw| ... }
  # -->
  #
  def complete: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - convert(opt = nil, val = nil, *)
  # -->
  #
  def convert: (?untyped opt, ?untyped val, *untyped) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when the given argument does not match required format.
#
class OptionParser::InvalidArgument < OptionParser::ParseError
end

OptionParser::InvalidArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when switch is undefined.
#
class OptionParser::InvalidOption < OptionParser::ParseError
end

OptionParser::InvalidOption::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Simple option list providing mapping from short and/or long option string to
# OptionParser::Switch and mapping from acceptable argument to matching pattern
# and converter pair. Also provides summary feature.
#
class OptionParser::List
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(t, pat = /.*/m, &block)
  # -->
  # See OptionParser.accept.
  #
  def accept: (untyped t, ?untyped pat) { (*untyped) -> untyped } -> untyped

  def add_banner: (untyped to) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - append(*args)
  # -->
  # Appends `switch` at the tail of the list, and associates short, long and
  # negated long options. Arguments are:
  #
  # `switch`
  # :   OptionParser::Switch instance to be inserted.
  #
  # `short_opts`
  # :   List of short style options.
  #
  # `long_opts`
  # :   List of long style options.
  #
  # `nolong_opts`
  # :   List of long style options with "no-" prefix.
  #
  #
  #     append(switch, short_opts, long_opts, nolong_opts)
  #
  def append: (*untyped args) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from acceptable argument types to pattern and converter pairs.
  #
  def atype: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(id, opt, icase = false, *pat, &block)
  # -->
  # Searches list `id` for `opt` and the optional patterns for completion `pat`.
  # If `icase` is true, the search is case insensitive. The result is returned or
  # yielded if a block is given. If it isn't found, nil is returned.
  #
  def complete: (untyped id, untyped opt, ?untyped icase, *untyped pat) { (*untyped) -> untyped } -> untyped

  def compsys: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - each_option(&block)
  # -->
  # Iterates over each option, passing the option to the `block`.
  #
  def each_option: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - get_candidates(id) { |__send__(id).keys| ... }
  # -->
  #
  def get_candidates: (untyped id) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # List of all switches and summary string.
  #
  def list: () -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from long style option switches to actual switch objects.
  #
  def long: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - prepend(*args)
  # -->
  # Inserts `switch` at the head of the list, and associates short, long and
  # negated long options. Arguments are:
  #
  # `switch`
  # :   OptionParser::Switch instance to be inserted.
  #
  # `short_opts`
  # :   List of short style options.
  #
  # `long_opts`
  # :   List of long style options.
  #
  # `nolong_opts`
  # :   List of long style options with "no-" prefix.
  #
  #
  #     prepend(switch, short_opts, long_opts, nolong_opts)
  #
  def prepend: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(t)
  # -->
  # See OptionParser.reject.
  #
  def reject: (untyped t) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - search(id, key) { |val| ... }
  # -->
  # Searches `key` in `id` list. The result is returned or yielded if a block is
  # given. If it isn't found, nil is returned.
  #
  def search: (untyped id, untyped key) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from short style option switches to actual switch objects.
  #
  def short: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(*args, &block)
  # -->
  # Creates the summary table, passing each line to the `block` (without newline).
  # The arguments `args` are passed along to the summarize method which is called
  # on every option.
  #
  def summarize: (*untyped args) { (*untyped) -> untyped } -> untyped

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new()
  # -->
  # Just initializes all instance variables.
  #
  def initialize: () -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - update(sw, sopts, lopts, nsw = nil, nlopts = nil)
  # -->
  # Adds `sw` according to `sopts`, `lopts` and `nlopts`.
  #
  # `sw`
  # :   OptionParser::Switch instance to be added.
  # `sopts`
  # :   Short style option list.
  # `lopts`
  # :   Long style option list.
  # `nlopts`
  # :   Negated long style options list.
  #
  def update: (untyped sw, untyped sopts, untyped lopts, ?untyped nsw, ?untyped nlopts) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when a switch with mandatory argument has no argument.
#
class OptionParser::MissingArgument < OptionParser::ParseError
end

OptionParser::MissingArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when there is an argument for a switch which takes no argument.
#
class OptionParser::NeedlessArgument < OptionParser::ParseError
end

OptionParser::NeedlessArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Map from option/keyword string to object with completion.
#
class OptionParser::OptionMap < Hash[untyped, untyped]
  include OptionParser::Completion
end

# <!-- rdoc-file=lib/optparse.rb -->
# Base class of exceptions from OptionParser.
#
class OptionParser::ParseError < RuntimeError
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - filter_backtrace(array)
  # -->
  #
  def self.filter_backtrace: (untyped array) -> untyped

  def additional: () -> untyped

  def additional=: (untyped) -> untyped

  def args: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inspect()
  # -->
  #
  def inspect: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - message()
  # -->
  # Default stringizing method to emit standard error message.
  #
  def message: () -> String

  # <!-- rdoc-file=lib/optparse.rb -->
  #
  def reason: () -> untyped

  def reason=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - recover(argv)
  # -->
  # Pushes back erred argument(s) to `argv`.
  #
  def recover: (untyped argv) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - set_backtrace(array)
  # -->
  #
  def set_backtrace: (untyped array) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - set_option(opt, eq)
  # -->
  #
  def set_option: (untyped opt, untyped eq) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_s()
  # -->
  #
  alias to_s message

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(*args, additional: nil)
  # -->
  #
  def initialize: (*untyped args, ?additional: untyped) -> void
end

# <!-- rdoc-file=lib/optparse.rb -->
# Reason which caused the error.
#
OptionParser::ParseError::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Individual switch class.  Not important to the user.
#
# Defined within Switch are several Switch-derived classes: NoArgument,
# RequiredArgument, etc.
#
class OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - guess(arg)
  # -->
  # Guesses argument style from `arg`.  Returns corresponding OptionParser::Switch
  # class (OptionalArgument, etc.).
  #
  def self.guess: (untyped arg) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - incompatible_argument_styles(arg, t)
  # -->
  #
  def self.incompatible_argument_styles: (untyped arg, untyped t) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - pattern()
  # -->
  #
  def self.pattern: () -> untyped

  def add_banner: (untyped to) -> untyped

  def arg: () -> untyped

  def block: () -> untyped

  def compsys: (untyped sdone, untyped ldone) -> untyped

  def conv: () -> untyped

  def desc: () -> untyped

  def long: () -> untyped

  def match_nonswitch?: (untyped str) -> untyped

  def pattern: () -> untyped

  def short: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(sdone = {}, ldone = {}, width = 1, max = width - 1, indent = "") { |indent| ... }
  # -->
  # Produces the summary text. Each line of the summary is yielded to the block
  # (without newline).
  #
  # `sdone`
  # :   Already summarized short style options keyed hash.
  #
  # `ldone`
  # :   Already summarized long style options keyed hash.
  #
  # `width`
  # :   Width of left side (option part). In other words, the right side
  #     (description part) starts after `width` columns.
  #
  # `max`
  # :   Maximum width of left side -> the options are filled within `max` columns.
  #
  # `indent`
  # :   Prefix string indents all summarized lines.
  #
  def summarize: (?untyped sdone, ?untyped ldone, ?untyped width, ?untyped max, ?untyped indent) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - switch_name()
  # -->
  # Main name of the switch.
  #
  def switch_name: () -> untyped

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - conv_arg(arg, val = [])
  # -->
  # Parses argument, converts and returns `arg`, `block` and result of conversion.
  # Yields at semi-error condition instead of raising an exception.
  #
  def conv_arg: (untyped arg, ?untyped val) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long), block = nil, &_block)
  # -->
  #
  def initialize: (?untyped pattern, ?untyped conv, ?untyped short, ?untyped long, ?untyped arg, ?untyped desc, ?untyped block) { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse_arg(arg) { |InvalidArgument, arg| ... }
  # -->
  # Parses `arg` and returns rest of `arg` and matched portion to the argument
  # pattern. Yields when the pattern doesn't match substring.
  #
  def parse_arg: (untyped arg) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes no arguments.
#
class OptionParser::Switch::NoArgument < OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - incompatible_argument_styles(*)
  # -->
  #
  def self.incompatible_argument_styles: (*untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - pattern()
  # -->
  #
  def self.pattern: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv) { |NeedlessArgument, arg| ... }
  # -->
  # Raises an exception if any arguments given.
  #
  def parse: (untyped arg, untyped argv) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that can omit argument.
#
class OptionParser::Switch::OptionalArgument < OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv, &error)
  # -->
  # Parses argument if given, or uses default value.
  #
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes an argument, which does not begin with '-' or is '-'.
#
class OptionParser::Switch::PlacedArgument < OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv, &error)
  # -->
  # Returns nil if argument is not present or begins with '-' and is not '-'.
  #
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes an argument.
#
class OptionParser::Switch::RequiredArgument < OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv, &_)
  # -->
  # Raises an exception if argument is not present.
  #
  def parse: (untyped arg, untyped argv) -> untyped
end
# <!-- rdoc-file=ext/pathname/pathname.c -->
# Pathname represents the name of a file or directory on the filesystem, but not
# the file itself.
#
# The pathname depends on the Operating System: Unix, Windows, etc. This library
# works with pathnames of local OS, however non-Unix pathnames are supported
# experimentally.
#
# A Pathname can be relative or absolute.  It's not until you try to reference
# the file that it even matters whether the file exists or not.
#
# Pathname is immutable.  It has no method for destructive update.
#
# The goal of this class is to manipulate file path information in a neater way
# than standard Ruby provides.  The examples below demonstrate the difference.
#
# **All** functionality from File, FileTest, and some from Dir and FileUtils is
# included, in an unsurprising way.  It is essentially a facade for all of
# these, and more.
#
# ## Examples
#
# ### Example 1: Using Pathname
#
#     require 'pathname'
#     pn = Pathname.new("/usr/bin/ruby")
#     size = pn.size              # 27662
#     isdir = pn.directory?       # false
#     dir  = pn.dirname           # Pathname:/usr/bin
#     base = pn.basename          # Pathname:ruby
#     dir, base = pn.split        # [Pathname:/usr/bin, Pathname:ruby]
#     data = pn.read
#     pn.open { |f| _ }
#     pn.each_line { |line| _ }
#
# ### Example 2: Using standard Ruby
#
#     pn = "/usr/bin/ruby"
#     size = File.size(pn)        # 27662
#     isdir = File.directory?(pn) # false
#     dir  = File.dirname(pn)     # "/usr/bin"
#     base = File.basename(pn)    # "ruby"
#     dir, base = File.split(pn)  # ["/usr/bin", "ruby"]
#     data = File.read(pn)
#     File.open(pn) { |f| _ }
#     File.foreach(pn) { |line| _ }
#
# ### Example 3: Special features
#
#     p1 = Pathname.new("/usr/lib")   # Pathname:/usr/lib
#     p2 = p1 + "ruby/1.8"            # Pathname:/usr/lib/ruby/1.8
#     p3 = p1.parent                  # Pathname:/usr
#     p4 = p2.relative_path_from(p3)  # Pathname:lib/ruby/1.8
#     pwd = Pathname.pwd              # Pathname:/home/gavin
#     pwd.absolute?                   # true
#     p5 = Pathname.new "."           # Pathname:.
#     p5 = p5 + "music/../articles"   # Pathname:music/../articles
#     p5.cleanpath                    # Pathname:articles
#     p5.realpath                     # Pathname:/home/gavin/articles
#     p5.children                     # [Pathname:/home/gavin/articles/linux, ...]
#
# ## Breakdown of functionality
#
# ### Core methods
#
# These methods are effectively manipulating a String, because that's all a path
# is.  None of these access the file system except for #mountpoint?, #children,
# #each_child, #realdirpath and #realpath.
#
# *   +
# *   #join
# *   #parent
# *   #root?
# *   #absolute?
# *   #relative?
# *   #relative_path_from
# *   #each_filename
# *   #cleanpath
# *   #realpath
# *   #realdirpath
# *   #children
# *   #each_child
# *   #mountpoint?
#
# ### File status predicate methods
#
# These methods are a facade for FileTest:
# *   #blockdev?
# *   #chardev?
# *   #directory?
# *   #executable?
# *   #executable_real?
# *   #exist?
# *   #file?
# *   #grpowned?
# *   #owned?
# *   #pipe?
# *   #readable?
# *   #world_readable?
# *   #readable_real?
# *   #setgid?
# *   #setuid?
# *   #size
# *   #size?
# *   #socket?
# *   #sticky?
# *   #symlink?
# *   #writable?
# *   #world_writable?
# *   #writable_real?
# *   #zero?
#
# ### File property and manipulation methods
#
# These methods are a facade for File:
# *   #atime
# *   #birthtime
# *   #ctime
# *   #mtime
# *   #chmod(mode)
# *   #lchmod(mode)
# *   #chown(owner, group)
# *   #lchown(owner, group)
# *   #fnmatch(pattern, *args)
# *   #fnmatch?(pattern, *args)
# *   #ftype
# *   #make_link(old)
# *   #open(*args, &block)
# *   #readlink
# *   #rename(to)
# *   #stat
# *   #lstat
# *   #make_symlink(old)
# *   #truncate(length)
# *   #utime(atime, mtime)
# *   #lutime(atime, mtime)
# *   #basename(*args)
# *   #dirname
# *   #extname
# *   #expand_path(*args)
# *   #split
#
# ### Directory methods
#
# These methods are a facade for Dir:
# *   Pathname.glob(*args)
# *   Pathname.getwd / Pathname.pwd
# *   #rmdir
# *   #entries
# *   #each_entry(&block)
# *   #mkdir(*args)
# *   #opendir(*args)
#
# ### IO
#
# These methods are a facade for IO:
# *   #each_line(*args, &block)
# *   #read(*args)
# *   #binread(*args)
# *   #readlines(*args)
# *   #sysopen(*args)
# *   #write(*args)
# *   #binwrite(*args)
#
# ### Utilities
#
# These methods are a mixture of Find, FileUtils, and others:
# *   #find(&block)
# *   #mkpath
# *   #rmtree
# *   #unlink / #delete
#
# ## Method documentation
#
# As the above section shows, most of the methods in Pathname are facades.  The
# documentation for these methods generally just says, for instance, "See
# FileTest.writable?", as you should be familiar with the original method
# anyway, and its documentation (e.g. through `ri`) will contain more
# information.  In some cases, a brief description will follow.
#
class Pathname
  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - getwd()
  # -->
  # Returns the current working directory as a Pathname.
  #
  #     Pathname.getwd
  #         #=> #<Pathname:/home/zzak/projects/ruby>
  #
  # See Dir.getwd.
  #
  def self.getwd: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - glob(p1, p2 = v2, p3 = v3)
  # -->
  # Returns or yields Pathname objects.
  #
  #     Pathname.glob("lib/i*.rb")
  #         #=> [#<Pathname:lib/ipaddr.rb>, #<Pathname:lib/irb.rb>]
  #
  # See Dir.glob.
  #
  def self.glob: (String | Array[String] pattern, ?Integer flags) -> Array[Pathname]
               | (String | Array[String] pattern, ?Integer flags) { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pwd()
  # -->
  # Returns the current working directory as a Pathname.
  #
  #     Pathname.getwd
  #         #=> #<Pathname:/home/zzak/projects/ruby>
  #
  # See Dir.getwd.
  #
  def self.pwd: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - +(other)
  # -->
  # Appends a pathname fragment to `self` to produce a new Pathname object. Since
  # `other` is considered as a path relative to `self`, if `other` is an absolute
  # path, the new Pathname object is created from just `other`.
  #
  #     p1 = Pathname.new("/usr")      # Pathname:/usr
  #     p2 = p1 + "bin/ruby"           # Pathname:/usr/bin/ruby
  #     p3 = p1 + "/etc/passwd"        # Pathname:/etc/passwd
  #
  #     # / is aliased to +.
  #     p4 = p1 / "bin/ruby"           # Pathname:/usr/bin/ruby
  #     p5 = p1 / "/etc/passwd"        # Pathname:/etc/passwd
  #
  # This method doesn't access the file system; it is pure string manipulation.
  #
  def +: (Pathname | String | _ToStr other) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - /(other)
  # -->
  #
  alias / +

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - <=>(p1)
  # -->
  # Provides a case-sensitive comparison operator for pathnames.
  #
  #     Pathname.new('/usr') <=> Pathname.new('/usr/bin')
  #         #=> -1
  #     Pathname.new('/usr/bin') <=> Pathname.new('/usr/bin')
  #         #=> 0
  #     Pathname.new('/usr/bin') <=> Pathname.new('/USR/BIN')
  #         #=> 1
  #
  # It will return `-1`, `0` or `1` depending on the value of the left argument
  # relative to the right argument. Or it will return `nil` if the arguments are
  # not comparable.
  #
  def <=>: (Pathname other) -> Integer
         | (untyped other) -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - ==(p1)
  # -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - absolute?()
  # -->
  # Predicate method for testing whether a path is absolute.
  #
  # It returns `true` if the pathname begins with a slash.
  #
  #     p = Pathname.new('/im/sure')
  #     p.absolute?
  #         #=> true
  #
  #     p = Pathname.new('not/so/sure')
  #     p.absolute?
  #         #=> false
  #
  def absolute?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - ascend() { |self| ... }
  # -->
  # Iterates over and yields a new Pathname object for each element in the given
  # path in ascending order.
  #
  #     Pathname.new('/path/to/some/file.rb').ascend {|v| p v}
  #        #<Pathname:/path/to/some/file.rb>
  #        #<Pathname:/path/to/some>
  #        #<Pathname:/path/to>
  #        #<Pathname:/path>
  #        #<Pathname:/>
  #
  #     Pathname.new('path/to/some/file.rb').ascend {|v| p v}
  #        #<Pathname:path/to/some/file.rb>
  #        #<Pathname:path/to/some>
  #        #<Pathname:path/to>
  #        #<Pathname:path>
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").ascend
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields Pathnames /usr/bin/ruby, /usr/bin, /usr, and /.
  #
  # It doesn't access the filesystem.
  #
  def ascend: () { (Pathname) -> untyped } -> nil
            | () -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.atime     -> time
  # -->
  # Returns the last access time for the file.
  #
  # See File.atime.
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - basename(p1 = v1)
  # -->
  # Returns the last component of the path.
  #
  # See File.basename.
  #
  def basename: (?String | _ToStr suffix) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.binread([length [, offset]]) -> string
  # -->
  # Returns all the bytes from the file, or the first `N` if specified.
  #
  # See File.binread.
  #
  def binread: (?Integer length, ?Integer offset) -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.binwrite(string, [offset] )   => fixnum
  #   - pathname.binwrite(string, [offset], open_args )   => fixnum
  # -->
  # Writes `contents` to the file, opening it in binary mode.
  #
  # See File.binwrite.
  #
  def binwrite: (String, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: Hash[String, String] | Proc | Method, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.birthtime -> time
  # -->
  # Returns the birth time for the file. If the platform doesn't have birthtime,
  # raises NotImplementedError.
  #
  # See File.birthtime.
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - blockdev?()
  # -->
  # See FileTest.blockdev?.
  #
  def blockdev?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - chardev?()
  # -->
  # See FileTest.chardev?.
  #
  def chardev?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - children(with_directory=true)
  # -->
  # Returns the children of the directory (files and subdirectories, not
  # recursive) as an array of Pathname objects.
  #
  # By default, the returned pathnames will have enough information to access the
  # files. If you set `with_directory` to `false`, then the returned pathnames
  # will contain the filename only.
  #
  # For example:
  #     pn = Pathname("/usr/lib/ruby/1.8")
  #     pn.children
  #         # -> [ Pathname:/usr/lib/ruby/1.8/English.rb,
  #                Pathname:/usr/lib/ruby/1.8/Env.rb,
  #                Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]
  #     pn.children(false)
  #         # -> [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]
  #
  # Note that the results never contain the entries `.` and `..` in the directory
  # because they are not children.
  #
  def children: (?boolish with_directory) -> Array[Pathname]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.chmod(mode_int)   -> integer
  # -->
  # Changes file permissions.
  #
  # See File.chmod.
  #
  def chmod: (Integer mode_int) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.chown(owner_int, group_int)       -> integer
  # -->
  # Change owner and group of the file.
  #
  # See File.chown.
  #
  def chown: (Integer owner, Integer group) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - cleanpath(consider_symlink=false)
  # -->
  # Returns clean pathname of `self` with consecutive slashes and useless dots
  # removed.  The filesystem is not accessed.
  #
  # If `consider_symlink` is `true`, then a more conservative algorithm is used to
  # avoid breaking symbolic linkages.  This may retain more `..` entries than
  # absolutely necessary, but without accessing the filesystem, this can't be
  # avoided.
  #
  # See Pathname#realpath.
  #
  def cleanpath: (?boolish consider_symlink) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.ctime     -> time
  # -->
  # Returns the last change time, using directory information, not the file
  # itself.
  #
  # See File.ctime.
  #
  def ctime: () -> Time

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Removes a file or directory, using File.unlink if `self` is a file, or
  # Dir.unlink as necessary.
  #
  def delete: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - descend() { |v| ... }
  # -->
  # Iterates over and yields a new Pathname object for each element in the given
  # path in descending order.
  #
  #     Pathname.new('/path/to/some/file.rb').descend {|v| p v}
  #        #<Pathname:/>
  #        #<Pathname:/path>
  #        #<Pathname:/path/to>
  #        #<Pathname:/path/to/some>
  #        #<Pathname:/path/to/some/file.rb>
  #
  #     Pathname.new('path/to/some/file.rb').descend {|v| p v}
  #        #<Pathname:path>
  #        #<Pathname:path/to>
  #        #<Pathname:path/to/some>
  #        #<Pathname:path/to/some/file.rb>
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").descend
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields Pathnames /, /usr, /usr/bin, and /usr/bin/ruby.
  #
  # It doesn't access the filesystem.
  #
  def descend: () { (Pathname) -> untyped } -> nil
             | () -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - directory?()
  # -->
  # See FileTest.directory?.
  #
  def directory?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - dirname()
  # -->
  # Returns all but the last component of the path.
  #
  # See File.dirname.
  #
  def dirname: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - each_child(with_directory=true, &b)
  # -->
  # Iterates over the children of the directory (files and subdirectories, not
  # recursive).
  #
  # It yields Pathname object for each child.
  #
  # By default, the yielded pathnames will have enough information to access the
  # files.
  #
  # If you set `with_directory` to `false`, then the returned pathnames will
  # contain the filename only.
  #
  #     Pathname("/usr/local").each_child {|f| p f }
  #     #=> #<Pathname:/usr/local/share>
  #     #   #<Pathname:/usr/local/bin>
  #     #   #<Pathname:/usr/local/games>
  #     #   #<Pathname:/usr/local/lib>
  #     #   #<Pathname:/usr/local/include>
  #     #   #<Pathname:/usr/local/sbin>
  #     #   #<Pathname:/usr/local/src>
  #     #   #<Pathname:/usr/local/man>
  #
  #     Pathname("/usr/local").each_child(false) {|f| p f }
  #     #=> #<Pathname:share>
  #     #   #<Pathname:bin>
  #     #   #<Pathname:games>
  #     #   #<Pathname:lib>
  #     #   #<Pathname:include>
  #     #   #<Pathname:sbin>
  #     #   #<Pathname:src>
  #     #   #<Pathname:man>
  #
  # Note that the results never contain the entries `.` and `..` in the directory
  # because they are not children.
  #
  # See Pathname#children
  #
  def each_child: (?boolish with_directory) { (Pathname) -> void } -> Array[Pathname]
                | (?boolish with_directory) -> Enumerator[Pathname, Array[Pathname]]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - each_entry()
  # -->
  # Iterates over the entries (files and subdirectories) in the directory,
  # yielding a Pathname object for each entry.
  #
  def each_entry: () { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - each_filename() { |filename| ... }
  # -->
  # Iterates over each component of the path.
  #
  #     Pathname.new("/usr/bin/ruby").each_filename {|filename| ... }
  #       # yields "usr", "bin", and "ruby".
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").each_filename
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields "usr", "bin", and "ruby".
  #
  def each_filename: () { (String) -> untyped } -> nil
                   | () -> Enumerator[String, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.each_line {|line| ... }
  #   - pathname.each_line(sep=$/ [, open_args]) {|line| block }     -> nil
  #   - pathname.each_line(limit [, open_args]) {|line| block }      -> nil
  #   - pathname.each_line(sep, limit [, open_args]) {|line| block } -> nil
  #   - pathname.each_line(...)                                      -> an_enumerator
  # -->
  # Iterates over each line in the file and yields a String object for each.
  #
  def each_line: (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) { (String) -> untyped } -> nil
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) { (String) -> untyped } -> nil
               | (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Enumerator[String, nil]
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Enumerator[String, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - empty?()
  # -->
  # Tests the file is empty.
  #
  # See Dir#empty? and FileTest.empty?.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - entries()
  # -->
  # Return the entries (files and subdirectories) in the directory, each as a
  # Pathname object.
  #
  # The results contains just the names in the directory, without any trailing
  # slashes or recursive look-up.
  #
  #     pp Pathname.new('/usr/local').entries
  #     #=> [#<Pathname:share>,
  #     #    #<Pathname:lib>,
  #     #    #<Pathname:..>,
  #     #    #<Pathname:include>,
  #     #    #<Pathname:etc>,
  #     #    #<Pathname:bin>,
  #     #    #<Pathname:man>,
  #     #    #<Pathname:games>,
  #     #    #<Pathname:.>,
  #     #    #<Pathname:sbin>,
  #     #    #<Pathname:src>]
  #
  # The result may contain the current directory `#<Pathname:.>` and the parent
  # directory `#<Pathname:..>`.
  #
  # If you don't want `.` and `..` and want directories, consider
  # Pathname#children.
  #
  def entries: () -> Array[Pathname]

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - executable?()
  # -->
  # See FileTest.executable?.
  #
  def executable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - executable_real?()
  # -->
  # See FileTest.executable_real?.
  #
  def executable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - exist?()
  # -->
  # See FileTest.exist?.
  #
  def exist?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - expand_path(p1 = v1)
  # -->
  # Returns the absolute path for the file.
  #
  # See File.expand_path.
  #
  def expand_path: (?String dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - extname()
  # -->
  # Returns the file's extension.
  #
  # See File.extname.
  #
  def extname: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - file?()
  # -->
  # See FileTest.file?.
  #
  def file?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - find(ignore_error: true) { |pathname| ... }
  # -->
  # Iterates over the directory tree in a depth first manner, yielding a Pathname
  # for each file under "this" directory.
  #
  # Returns an Enumerator if no block is given.
  #
  # Since it is implemented by the standard library module Find, Find.prune can be
  # used to control the traversal.
  #
  # If `self` is `.`, yielded pathnames begin with a filename in the current
  # directory, not `./`.
  #
  # See Find.find
  #
  def find: (?ignore_error: boolish) { (Pathname) -> untyped } -> nil
          | (?ignore_error: boolish) -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.fnmatch(pattern, [flags])        -> true or false
  #   - pathname.fnmatch?(pattern, [flags])       -> true or false
  # -->
  # Return `true` if the receiver matches the given pattern.
  #
  # See File.fnmatch.
  #
  def fnmatch: (String pattern, ?Integer flags) -> bool

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Return `true` if the receiver matches the given pattern.
  #
  # See File.fnmatch.
  #
  alias fnmatch? fnmatch

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.freeze -> obj
  # -->
  # Freezes this Pathname.
  #
  # See Object.freeze.
  #
  def freeze: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.ftype     -> string
  # -->
  # Returns "type" of file ("file", "directory", etc).
  #
  # See File.ftype.
  #
  def ftype: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - glob(p1, p2 = v2)
  # -->
  # Returns or yields Pathname objects.
  #
  #     Pathname("ruby-2.4.2").glob("R*.md")
  #     #=> [#<Pathname:ruby-2.4.2/README.md>, #<Pathname:ruby-2.4.2/README.ja.md>]
  #
  # See Dir.glob. This method uses the `base` keyword argument of Dir.glob.
  #
  def glob: (String | Array[String] pattern, ?Integer flags) -> Array[Pathname]
          | (String | Array[String] pattern, ?Integer flags) { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - grpowned?()
  # -->
  # See FileTest.grpowned?.
  #
  def grpowned?: () -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - join(*args)
  # -->
  # Joins the given pathnames onto `self` to create a new Pathname object. This is
  # effectively the same as using Pathname#+ to append `self` and all arguments
  # sequentially.
  #
  #     path0 = Pathname.new("/usr")                # Pathname:/usr
  #     path0 = path0.join("bin/ruby")              # Pathname:/usr/bin/ruby
  #         # is the same as
  #     path1 = Pathname.new("/usr") + "bin/ruby"   # Pathname:/usr/bin/ruby
  #     path0 == path1
  #         #=> true
  #
  def join: (*String | _ToStr | Pathname args) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.lchmod(mode_int)  -> integer
  # -->
  # Same as Pathname.chmod, but does not follow symbolic links.
  #
  # See File.lchmod.
  #
  def lchmod: (Integer mode) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.lchown(owner_int, group_int)      -> integer
  # -->
  # Same as Pathname.chown, but does not follow symbolic links.
  #
  # See File.lchown.
  #
  def lchown: (Integer owner, Integer group) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - lstat()
  # -->
  # See File.lstat.
  #
  def lstat: () -> ::File::Stat

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - lutime(p1, p2)
  # -->
  # Update the access and modification times of the file.
  #
  # Same as Pathname#utime, but does not follow symbolic links.
  #
  # See File.lutime.
  #
  def lutime: (Time | Numeric atime, Time | Numeric mtime) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.make_link(old)
  # -->
  # Creates a hard link at *pathname*.
  #
  # See File.link.
  #
  def make_link: (String | Pathname | _ToStr old) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.make_symlink(old)
  # -->
  # Creates a symbolic link.
  #
  # See File.symlink.
  #
  def make_symlink: (String | Pathname | _ToStr old) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - mkdir(p1 = v1)
  # -->
  # Create the referenced directory.
  #
  # See Dir.mkdir.
  #
  def mkdir: (?Integer perm) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - mkpath(mode: nil)
  # -->
  # Creates a full path, including any intermediate directories that don't yet
  # exist.
  #
  # See FileUtils.mkpath and FileUtils.mkdir_p
  #
  def mkpath: () -> self

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - mountpoint?()
  # -->
  # Returns `true` if `self` points to a mountpoint.
  #
  def mountpoint?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.mtime     -> time
  # -->
  # Returns the last modified time of the file.
  #
  # See File.mtime.
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.open()
  #   - pathname.open(mode="r" [, opt])                        -> file
  #   - pathname.open([mode [, perm]] [, opt])                 -> file
  #   - pathname.open(mode="r" [, opt]) {|file| block }        -> obj
  #   - pathname.open([mode [, perm]] [, opt]) {|file| block } -> obj
  # -->
  # Opens the file for reading or writing.
  #
  # See File.open.
  #
  def open: (?string | int mode, ?int perm) -> File
          | [T] (?string | int mode, ?int perm) { (File) -> T } -> T

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - opendir()
  # -->
  # Opens the referenced directory.
  #
  # See Dir.open.
  #
  def opendir: () -> Dir
             | [U] () { (Dir) -> U } -> U

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - owned?()
  # -->
  # See FileTest.owned?.
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - parent()
  # -->
  # Returns the parent directory.
  #
  # This is same as `self + '..'`.
  #
  def parent: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pipe?()
  # -->
  # See FileTest.pipe?.
  #
  def pipe?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.read([length [, offset]]) -> string
  #   - pathname.read([length [, offset]], open_args) -> string
  # -->
  # Returns all data from the file, or the first `N` bytes if specified.
  #
  # See File.read.
  #
  def read: (?Integer length, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish) -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readable?()
  # -->
  # See FileTest.readable?.
  #
  def readable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readable_real?()
  # -->
  # See FileTest.readable_real?.
  #
  def readable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.readlines(sep=$/ [, open_args])     -> array
  #   - pathname.readlines(limit [, open_args])      -> array
  #   - pathname.readlines(sep, limit [, open_args]) -> array
  # -->
  # Returns all the lines from the file.
  #
  # See File.readlines.
  #
  def readlines: (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Array[String]
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Array[String]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readlink()
  # -->
  # Read symbolic link.
  #
  # See File.readlink.
  #
  def readlink: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - realdirpath(p1 = v1)
  # -->
  # Returns the real (absolute) pathname of `self` in the actual filesystem.
  #
  # Does not contain symlinks or useless dots, `..` and `.`.
  #
  # The last component of the real pathname can be nonexistent.
  #
  def realdirpath: (?string | Pathname base_dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - realpath(p1 = v1)
  # -->
  # Returns the real (absolute) pathname for `self` in the actual filesystem.
  #
  # Does not contain symlinks or useless dots, `..` and `.`.
  #
  # All components of the pathname must exist when this method is called.
  #
  def realpath: (?string | Pathname base_dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - relative?()
  # -->
  # The opposite of Pathname#absolute?
  #
  # It returns `false` if the pathname begins with a slash.
  #
  #     p = Pathname.new('/im/sure')
  #     p.relative?
  #         #=> false
  #
  #     p = Pathname.new('not/so/sure')
  #     p.relative?
  #         #=> true
  #
  def relative?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - relative_path_from(base_directory)
  # -->
  # Returns a relative path from the given `base_directory` to the receiver.
  #
  # If `self` is absolute, then `base_directory` must be absolute too.
  #
  # If `self` is relative, then `base_directory` must be relative too.
  #
  # This method doesn't access the filesystem.  It assumes no symlinks.
  #
  # ArgumentError is raised when it cannot find a relative path.
  #
  # Note that this method does not handle situations where the case sensitivity of
  # the filesystem in use differs from the operating system default.
  #
  def relative_path_from: (Pathname | string base_directory) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - rename(p1)
  # -->
  # Rename the file.
  #
  # See File.rename.
  #
  def rename: (Pathname | string new_name) -> 0

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - rmdir()
  # -->
  # Remove the referenced directory.
  #
  # See Dir.rmdir.
  #
  def rmdir: () -> 0

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - rmtree(noop: nil, verbose: nil, secure: nil)
  # -->
  # Recursively deletes a directory, including all directories beneath it.
  #
  # See FileUtils.rm_rf
  #
  def rmtree: () -> self

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - root?()
  # -->
  # Predicate method for root directories.  Returns `true` if the pathname
  # consists of consecutive slashes.
  #
  # It doesn't access the filesystem.  So it may return `false` for some pathnames
  # which points to roots such as `/usr/..`.
  #
  def root?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - setgid?()
  # -->
  # See FileTest.setgid?.
  #
  def setgid?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - setuid?()
  # -->
  # See FileTest.setuid?.
  #
  def setuid?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - size()
  # -->
  # See FileTest.size.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - size?()
  # -->
  # See FileTest.size?.
  #
  def size?: () -> Integer?

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - socket?()
  # -->
  # See FileTest.socket?.
  #
  def socket?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - split()
  # -->
  # Returns the #dirname and the #basename in an Array.
  #
  # See File.split.
  #
  def split: () -> [ Pathname, Pathname ]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - stat()
  # -->
  # Returns a File::Stat object.
  #
  # See File.stat.
  #
  def stat: () -> File::Stat

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sticky?()
  # -->
  # See FileTest.sticky?.
  #
  def sticky?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sub(*args)
  # -->
  # Return a pathname which is substituted by String#sub.
  #
  #     path1 = Pathname.new('/usr/bin/perl')
  #     path1.sub('perl', 'ruby')
  #         #=> #<Pathname:/usr/bin/ruby>
  #
  def sub: (Regexp | string pattern, string | Hash[String, String] replacement) -> Pathname
         | (Regexp | string pattern) { (String match) -> string } -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sub_ext(p1)
  # -->
  # Return a pathname with `repl` added as a suffix to the basename.
  #
  # If self has no extension part, `repl` is appended.
  #
  #     Pathname.new('/usr/bin/shutdown').sub_ext('.rb')
  #         #=> #<Pathname:/usr/bin/shutdown.rb>
  #
  def sub_ext: (string replacement) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - symlink?()
  # -->
  # See FileTest.symlink?.
  #
  def symlink?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.sysopen([mode, [perm]])  -> fixnum
  # -->
  # See IO.sysopen.
  #
  def sysopen: (?String mode, ?Integer perm) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.taint -> obj
  # -->
  # Returns pathname.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def taint: () -> Pathname

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Return the path as a String.
  #
  # to_path is implemented so Pathname objects are usable with File.open, etc.
  #
  def to_path: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.to_s             -> string
  #   - pathname.to_path          -> string
  # -->
  # Return the path as a String.
  #
  # to_path is implemented so Pathname objects are usable with File.open, etc.
  #
  alias to_s to_path

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - truncate(p1)
  # -->
  # Truncates the file to `length` bytes.
  #
  # See File.truncate.
  #
  def truncate: (Integer length) -> 0

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - unlink()
  # -->
  # Removes a file or directory, using File.unlink if `self` is a file, or
  # Dir.unlink as necessary.
  #
  def unlink: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.untaint -> obj
  # -->
  # Returns pathname.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def untaint: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - utime(p1, p2)
  # -->
  # Update the access and modification times of the file.
  #
  # See File.utime.
  #
  def utime: (Integer | Time atime, Integer | Time mtime) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - world_readable?()
  # -->
  # See FileTest.world_readable?.
  #
  def world_readable?: () -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - world_writable?()
  # -->
  # See FileTest.world_writable?.
  #
  def world_writable?: () -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - writable?()
  # -->
  # See FileTest.writable?.
  #
  def writable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - writable_real?()
  # -->
  # See FileTest.writable_real?.
  #
  def writable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.write(string, [offset] )   => fixnum
  #   - pathname.write(string, [offset], open_args )   => fixnum
  # -->
  # Writes `contents` to the file.
  #
  # See File.write.
  #
  def write: (String content, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - zero?()
  # -->
  # See FileTest.zero?.
  #
  def zero?: () -> bool

  private

  def add_trailing_separator: (untyped path) -> untyped

  def chop_basename: (untyped path) -> untyped

  def cleanpath_aggressive: () -> untyped

  def cleanpath_conservative: () -> untyped

  def del_trailing_separator: (untyped path) -> untyped

  def has_trailing_separator?: (untyped path) -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - new(p1)
  # -->
  # Create a Pathname object from the given String (or String-like object). If
  # `path` contains a NULL character (`\0`), an ArgumentError is raised.
  #
  def initialize: (string | Pathname) -> void

  def plus: (untyped path1, untyped path2) -> untyped

  def prepend_prefix: (untyped prefix, untyped relpath) -> untyped

  def split_names: (untyped path) -> untyped

  SAME_PATHS: Proc

  SEPARATOR_LIST: String

  SEPARATOR_PAT: Regexp

  TO_PATH: Symbol
end

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - Pathname(path)  -> pathname
  # -->
  # Creates a new Pathname object from the given string, `path`, and returns
  # pathname object.
  #
  # In order to use this constructor, you must first require the Pathname standard
  # library extension.
  #
  #     require 'pathname'
  #     Pathname("/home/zzak")
  #     #=> #<Pathname:/home/zzak>
  #
  # See also Pathname::new for more information.
  #
  def self?.Pathname: (string | Pathname) -> Pathname
end
# <!-- rdoc-file=lib/pp.rb -->
# A pretty-printer for Ruby objects.
#
# ## What PP Does
#
# Standard output by #p returns this:
#     #<PP:0x81fedf0 @genspace=#<Proc:0x81feda0>, @group_queue=#<PrettyPrint::GroupQueue:0x81fed3c @queue=[[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], []]>, @buffer=[], @newline="\n", @group_stack=[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], @buffer_width=0, @indent=0, @maxwidth=79, @output_width=2, @output=#<IO:0x8114ee4>>
#
# Pretty-printed output returns this:
#     #<PP:0x81fedf0
#      @buffer=[],
#      @buffer_width=0,
#      @genspace=#<Proc:0x81feda0>,
#      @group_queue=
#       #<PrettyPrint::GroupQueue:0x81fed3c
#        @queue=
#         [[#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
#          []]>,
#      @group_stack=
#       [#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
#      @indent=0,
#      @maxwidth=79,
#      @newline="\n",
#      @output=#<IO:0x8114ee4>,
#      @output_width=2>
#
# ## Usage
#
#     pp(obj)             #=> obj
#     pp obj              #=> obj
#     pp(obj1, obj2, ...) #=> [obj1, obj2, ...]
#     pp()                #=> nil
#
# Output `obj(s)` to `$>` in pretty printed format.
#
# It returns `obj(s)`.
#
# ## Output Customization
#
# To define a customized pretty printing function for your classes, redefine
# method `#pretty_print(pp)` in the class. Note that `require 'pp'` is needed
# before redefining `#pretty_print(pp)`.
#
# `#pretty_print` takes the `pp` argument, which is an instance of the PP class.
# The method uses #text, #breakable, #nest, #group and #pp to print the object.
#
# ## Pretty-Print JSON
#
# To pretty-print JSON refer to JSON#pretty_generate.
#
# ## Author
# Tanaka Akira <akr@fsij.org>
#
class PP < PrettyPrint
  interface _PrettyPrint
    def pretty_print: (untyped q) -> untyped

    def pretty_print_cycle: (untyped q) -> untyped

    def is_a?: (Module) -> bool
  end

  interface _LeftShift
    def <<: (untyped obj) -> self
  end

  interface _PPMethodsRequired
    def text: (String obj, ?Integer width) -> void

    def breakable: (?String sep, ?Integer width) -> void

    def group: (?Integer indent, ?String open_obj, ?String close_obj, ?Integer open_width, ?Integer close_width) { () -> untyped } -> void
  end

  # <!-- rdoc-file=lib/pp.rb -->
  # Module that defines helper methods for pretty_print.
  #
  module PPMethods : _PPMethodsRequired
    # <!--
    #   rdoc-file=lib/pp.rb
    #   - guard_inspect_key() { || ... }
    # -->
    # Yields to a block and preserves the previous set of objects being printed.
    #
    def guard_inspect_key: () { () -> untyped } -> void

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - check_inspect_key(id)
    # -->
    # Check whether the object_id `id` is in the current buffer of objects to be
    # pretty printed. Used to break cycles in chains of objects to be pretty
    # printed.
    #
    def check_inspect_key: (_PrettyPrint id) -> bool

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - push_inspect_key(id)
    # -->
    # Adds the object_id `id` to the set of objects being pretty printed, so as to
    # not repeat objects.
    #
    def push_inspect_key: (_PrettyPrint id) -> void

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - pop_inspect_key(id)
    # -->
    # Removes an object from the set of objects being pretty printed.
    #
    def pop_inspect_key: (_PrettyPrint id) -> void

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - pp(obj)
    # -->
    # Adds `obj` to the pretty printing buffer using Object#pretty_print or
    # Object#pretty_print_cycle.
    #
    # Object#pretty_print_cycle is used when `obj` is already printed, a.k.a the
    # object reference chain has a cycle.
    #
    def pp: (_PrettyPrint obj) -> untyped

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - object_group(obj) { || ... }
    # -->
    # A convenience method which is same as follows:
    #
    #     group(1, '#<' + obj.class.name, '>') { ... }
    #
    def object_group: (untyped obj) { () -> untyped } -> Integer

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - object_address_group(obj, &block)
    # -->
    # A convenience method, like object_group, but also reformats the Object's
    # object_id.
    #
    def object_address_group: (untyped obj) { () -> untyped } -> Integer

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - comma_breakable()
    # -->
    # A convenience method which is same as follows:
    #
    #     text ','
    #     breakable
    #
    def comma_breakable: () -> void

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - seplist(list, sep=nil, iter_method=:each) { |element| ... }
    # -->
    # Adds a separated list. The list is separated by comma with breakable space, by
    # default.
    #
    # #seplist iterates the `list` using `iter_method`. It yields each object to the
    # block given for #seplist. The procedure `separator_proc` is called between
    # each yields.
    #
    # If the iteration is zero times, `separator_proc` is not called at all.
    #
    # If `separator_proc` is nil or not given, +lambda { comma_breakable }+ is used.
    # If `iter_method` is not given, :each is used.
    #
    # For example, following 3 code fragments has similar effect.
    #
    #     q.seplist([1,2,3]) {|v| xxx v }
    #
    #     q.seplist([1,2,3], lambda { q.comma_breakable }, :each) {|v| xxx v }
    #
    #     xxx 1
    #     q.comma_breakable
    #     xxx 2
    #     q.comma_breakable
    #     xxx 3
    #
    def seplist: (untyped list, ?(^() -> void)? sep, ?interned iter_method) { (*untyped, **untyped) -> void } -> void

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - pp_object(obj)
    # -->
    # A present standard failsafe for pretty printing any given Object
    #
    def pp_object: (untyped obj) -> untyped

    # <!--
    #   rdoc-file=lib/pp.rb
    #   - pp_hash(obj)
    # -->
    # A pretty print for a Hash
    #
    def pp_hash: (untyped obj) -> untyped
  end
  include PPMethods

  class SingleLine < ::PrettyPrint::SingleLine
    include PPMethods
  end

  module ObjectMixin : BasicObject
    def pretty_print: (PP q) -> untyped

    def pretty_print_cycle: (PP q) -> untyped

    def pretty_print_instance_variables: () -> Array[Symbol]

    def pretty_print_inspect: () -> untyped
  end

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - width_for(out)
  # -->
  # Returns the usable width for `out`. As the width of `out`:
  # 1.  If `out` is assigned to a tty device, its width is used.
  # 2.  Otherwise, or it could not get the value, the `COLUMN` environment
  #     variable is assumed to be set to the width.
  # 3.  If `COLUMN` is not set to a non-zero number, 80 is assumed.
  #
  # And finally, returns the above width value - 1.
  # *   This -1 is for Windows command prompt, which moves the cursor to the next
  #     line if it reaches the last column.
  #
  def self.width_for: (untyped out) -> Integer

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pp(obj, out=$>, width=width_for(out))
  # -->
  # Outputs `obj` to `out` in pretty printed format of `width` columns in width.
  #
  # If `out` is omitted, `$>` is assumed. If `width` is omitted, the width of
  # `out` is assumed (see width_for).
  #
  # PP.pp returns `out`.
  #
  def self.pp: (_PrettyPrint obj, ?_LeftShift out, ?Integer width) -> untyped

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - singleline_pp(obj, out=$>)
  # -->
  # Outputs `obj` to `out` like PP.pp but with no indent and newline.
  #
  # PP.singleline_pp returns `out`.
  #
  def self.singleline_pp: (_PrettyPrint obj, ?_LeftShift out) -> untyped
  def self.mcall: (untyped obj, Module mod, interned meth, *untyped args) ?{ (*untyped, **untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - sharing_detection()
  # -->
  # Returns the sharing detection flag as a boolean value. It is false (nil) by
  # default.
  # ----
  # <!--
  #   rdoc-file=lib/pp.rb
  #   - sharing_detection=(b)
  # -->
  # Sets the sharing detection flag to b.
  #
  attr_accessor self.sharing_detection: bool?
end

%a{annotate:rdoc:skip}
class RubyVM::AbstractSyntaxTree::Node
  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pretty_print_children(q, names = [])
  # -->
  #
  def pretty_print_children: (PP q, ?Array[untyped] names) -> void
end

%a{annotate:rdoc:skip}
class Object
  include PP::ObjectMixin
end

%a{annotate:rdoc:skip}
module Kernel
  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pretty_inspect()
  # -->
  # Returns a pretty printed object as a string.
  #
  # See the PP module for more information.
  #
  def pretty_inspect: () -> String
end
# <!-- rdoc-file=lib/prettyprint.rb -->
# This class implements a pretty printing algorithm. It finds line breaks and
# nice indentations for grouped structure.
#
# By default, the class assumes that primitive elements are strings and each
# byte in the strings have single column in width. But it can be used for other
# situations by giving suitable arguments for some methods:
# *   newline object and space generation block for PrettyPrint.new
# *   optional width argument for PrettyPrint#text
# *   PrettyPrint#breakable
#
# There are several candidate uses:
# *   text formatting using proportional fonts
# *   multibyte characters which has columns different to number of bytes
# *   non-string formatting
#
# ## Bugs
# *   Box based formatting?
# *   Other (better) model/algorithm?
#
# Report any bugs at http://bugs.ruby-lang.org
#
# ## References
# Christian Lindig, Strictly Pretty, March 2000,
# https://lindig.github.io/papers/strictly-pretty-2000.pdf
#
# Philip Wadler, A prettier printer, March 1998,
# https://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier
#
# ## Author
# Tanaka Akira <akr@fsij.org>
#
class PrettyPrint
  interface _Output
    def <<: (String) -> void
  end

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - format(output=''.dup, maxwidth=79, newline="\n", genspace=lambda {|n| ' ' * n}) { |q| ... }
  # -->
  # This is a convenience method which is same as follows:
  #
  #     begin
  #       q = PrettyPrint.new(output, maxwidth, newline, &genspace)
  #       ...
  #       q.flush
  #       output
  #     end
  #
  def self.format: (?untyped output, ?Integer maxwidth, ?String newline, ?^(Integer) -> Integer genspace) { (PrettyPrint) -> untyped } -> _Output

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - singleline_format(output=''.dup, maxwidth=nil, newline=nil, genspace=nil) { |q| ... }
  # -->
  # This is similar to PrettyPrint::format but the result has no breaks.
  #
  # `maxwidth`, `newline` and `genspace` are ignored.
  #
  # The invocation of `breakable` in the block doesn't break a line and is treated
  # as just an invocation of `text`.
  #
  def self.singleline_format: (?untyped output, ?Integer? maxwidth, ?String? newline, ?^(Integer) -> Integer? genspace) { (PrettyPrint::SingleLine) -> untyped } -> _Output

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - new(output=''.dup, maxwidth=79, newline="\n", &genspace)
  # -->
  # Creates a buffer for pretty printing.
  #
  # `output` is an output target. If it is not specified, '' is assumed. It should
  # have a << method which accepts the first argument `obj` of PrettyPrint#text,
  # the first argument `sep` of PrettyPrint#breakable, the first argument
  # `newline` of PrettyPrint.new, and the result of a given block for
  # PrettyPrint.new.
  #
  # `maxwidth` specifies maximum line length. If it is not specified, 79 is
  # assumed. However actual outputs may overflow `maxwidth` if long non-breakable
  # texts are provided.
  #
  # `newline` is used for line breaks. "n" is used if it is not specified.
  #
  # The block is used to generate spaces. {|width| ' ' * width} is used if it is
  # not given.
  #
  def initialize: (?untyped output, ?Integer maxwidth, ?String newline, ?^(Integer) -> Integer genspace) -> void

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The output object.
  #
  # This defaults to '', and should accept the << method
  #
  attr_reader output: _Output

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The maximum width of a line, before it is separated in to a newline
  #
  # This defaults to 79, and should be an Integer
  #
  attr_reader maxwidth: Integer

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The value that is appended to `output` to add a new line.
  #
  # This defaults to "n", and should be String
  #
  attr_reader newline: String

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # A lambda or Proc, that takes one argument, of an Integer, and returns the
  # corresponding number of spaces.
  #
  # By default this is:
  #     lambda {|n| ' ' * n}
  #
  attr_reader genspace: Proc

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The number of spaces to be indented
  #
  attr_reader indent: Integer

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The PrettyPrint::GroupQueue of groups in stack to be pretty printed
  #
  attr_reader group_queue: PrettyPrint::GroupQueue

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - current_group()
  # -->
  # Returns the group most recently added to the stack.
  #
  # Contrived example:
  #     out = ""
  #     => ""
  #     q = PrettyPrint.new(out)
  #     => #<PrettyPrint:0x82f85c0 @output="", @maxwidth=79, @newline="\n", @genspace=#<Proc:0x82f8368@/home/vbatts/.rvm/rubies/ruby-head/lib/ruby/2.0.0/prettyprint.rb:82 (lambda)>, @output_width=0, @buffer_width=0, @buffer=[], @group_stack=[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>], @group_queue=#<PrettyPrint::GroupQueue:0x82fb7c0 @queue=[[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>]]>, @indent=0>
  #     q.group {
  #       q.text q.current_group.inspect
  #       q.text q.newline
  #       q.group(q.current_group.depth + 1) {
  #         q.text q.current_group.inspect
  #         q.text q.newline
  #         q.group(q.current_group.depth + 1) {
  #           q.text q.current_group.inspect
  #           q.text q.newline
  #           q.group(q.current_group.depth + 1) {
  #             q.text q.current_group.inspect
  #             q.text q.newline
  #           }
  #         }
  #       }
  #     }
  #     => 284
  #      puts out
  #     #<PrettyPrint::Group:0x8354758 @depth=1, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x8354550 @depth=2, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x83541cc @depth=3, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x8347e54 @depth=4, @breakables=[], @break=false>
  #
  def current_group: () -> PrettyPrint::Group

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - break_outmost_groups()
  # -->
  # Breaks the buffer into lines that are shorter than #maxwidth
  #
  def break_outmost_groups: () -> untyped

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - text(obj, width=obj.length)
  # -->
  # This adds `obj` as a text of `width` columns in width.
  #
  # If `width` is not specified, obj.length is used.
  #
  def text: (String obj, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - fill_breakable(sep=' ', width=sep.length)
  # -->
  # This is similar to #breakable except the decision to break or not is
  # determined individually.
  #
  # Two #fill_breakable under a group may cause 4 results: (break,break),
  # (break,non-break), (non-break,break), (non-break,non-break). This is different
  # to #breakable because two #breakable under a group may cause 2 results:
  # (break,break), (non-break,non-break).
  #
  # The text `sep` is inserted if a line is not broken at this point.
  #
  # If `sep` is not specified, " " is used.
  #
  # If `width` is not specified, `sep.length` is used. You will have to specify
  # this when `sep` is a multibyte character, for example.
  #
  def fill_breakable: (?String sep, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - breakable(sep=' ', width=sep.length)
  # -->
  # This says "you can break a line here if necessary", and a `width`-column text
  # `sep` is inserted if a line is not broken at the point.
  #
  # If `sep` is not specified, " " is used.
  #
  # If `width` is not specified, `sep.length` is used. You will have to specify
  # this when `sep` is a multibyte character, for example.
  #
  def breakable: (?String sep, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - group(indent=0, open_obj='', close_obj='', open_width=open_obj.length, close_width=close_obj.length) { || ... }
  # -->
  # Groups line break hints added in the block. The line break hints are all to be
  # used or not.
  #
  # If `indent` is specified, the method call is regarded as nested by
  # nest(indent) { ... }.
  #
  # If `open_obj` is specified, `text open_obj, open_width` is called before
  # grouping. If `close_obj` is specified, `text close_obj, close_width` is called
  # after grouping.
  #
  def group: (?::Integer indent, ?::String open_obj, ?::String close_obj, ?Integer open_width, ?Integer close_width) { () -> untyped } -> Integer

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - group_sub() { || ... }
  # -->
  # Takes a block and queues a new group that is indented 1 level further.
  #
  def group_sub: () { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - nest(indent) { || ... }
  # -->
  # Increases left margin after newline with `indent` for line breaks added in the
  # block.
  #
  def nest: (Integer indent) { () -> untyped } -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - flush()
  # -->
  # outputs buffered data.
  #
  def flush: () -> Integer

  class Text
    def initialize: () -> void

    attr_reader width: Integer

    def output: (untyped `out`, untyped output_width) -> untyped

    def add: (untyped obj, Integer width) -> void
  end

  class Breakable
    def initialize: (String sep, Integer width, PrettyPrint q) -> void

    attr_reader obj: String

    attr_reader width: Integer

    attr_reader indent: Integer

    def output: (untyped `out`, Integer output_width) -> untyped
  end

  class Group
    def initialize: (untyped depth) -> void

    attr_reader depth: untyped

    attr_reader breakables: Array[PrettyPrint::Breakable]

    def break: () -> bool

    def break?: () -> bool

    def first?: () -> bool
  end

  class GroupQueue
    def initialize: (*untyped groups) -> void

    def enq: (untyped group) -> void

    def deq: () -> (PrettyPrint::Group | nil)

    def delete: (PrettyPrint::Group group) -> void
  end

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # PrettyPrint::SingleLine is used by PrettyPrint.singleline_format
  #
  # It is passed to be similar to a PrettyPrint object itself, by responding to:
  # *   #text
  # *   #breakable
  # *   #nest
  # *   #group
  # *   #flush
  # *   #first?
  #
  # but instead, the output has no line breaks
  #
  class SingleLine
    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - new(output, maxwidth=nil, newline=nil)
    # -->
    # Create a PrettyPrint::SingleLine object
    #
    # Arguments:
    # *   `output` - String (or similar) to store rendered text. Needs to respond to
    #     '<<'
    # *   `maxwidth` - Argument position expected to be here for compatibility.
    #         This argument is a noop.
    #
    # *   `newline` - Argument position expected to be here for compatibility.
    #         This argument is a noop.
    #
    def initialize: (String | untyped output, ?Integer? maxwidth, ?String? newline) -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - text(obj, width=nil)
    # -->
    # Add `obj` to the text to be output.
    #
    # `width` argument is here for compatibility. It is a noop argument.
    #
    def text: (String obj, ?Integer? width) -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - breakable(sep=' ', width=nil)
    # -->
    # Appends `sep` to the text to be output. By default `sep` is ' '
    #
    # `width` argument is here for compatibility. It is a noop argument.
    #
    def breakable: (?String sep, ?Integer? width) -> void

    def nest: (untyped indent) { () -> untyped } -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - group(indent=nil, open_obj='', close_obj='', open_width=nil, close_width=nil) { || ... }
    # -->
    # Opens a block for grouping objects to be pretty printed.
    #
    # Arguments:
    # *   `indent` - noop argument. Present for compatibility.
    # *   `open_obj` - text appended before the &blok. Default is ''
    # *   `close_obj` - text appended after the &blok. Default is ''
    # *   `open_width` - noop argument. Present for compatibility.
    # *   `close_width` - noop argument. Present for compatibility.
    #
    def group: (?Integer? indent, ?String open_obj, ?String close_obj, ?Integer? open_width, ?Integer? close_width) { () -> untyped } -> untyped

    def flush: () -> nil

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - first?()
    # -->
    # This is used as a predicate, and ought to be called first.
    #
    def first?: () -> bool
  end
end
# <!-- rdoc-file=lib/pstore.rb -->
# PStore implements a file based persistence mechanism based on a Hash. User
# code can store hierarchies of Ruby objects (values) into the data store by
# name (keys). An object hierarchy may be just a single object. User code may
# later read values back from the data store or even update data, as needed.
#
# The transactional behavior ensures that any changes succeed or fail together.
# This can be used to ensure that the data store is not left in a transitory
# state, where some values were updated but others were not.
#
# Behind the scenes, Ruby objects are stored to the data store file with
# Marshal. That carries the usual limitations. Proc objects cannot be
# marshalled, for example.
#
# There are three important concepts here (details at the links):
#
# *   [Store](rdoc-ref:PStore@The+Store): a store is an instance of PStore.
# *   [Entries](rdoc-ref:PStore@Entries): the store is hash-like; each entry is
#     the key for a stored object.
# *   [Transactions](rdoc-ref:PStore@Transactions): each transaction is a
#     collection of prospective changes to the store; a transaction is defined
#     in the block given with a call to PStore#transaction.
#
# ## About the Examples
#
# Examples on this page need a store that has known properties. They can get a
# new (and populated) store by calling thus:
#
#     example_store do |store|
#       # Example code using store goes here.
#     end
#
# All we really need to know about `example_store` is that it yields a fresh
# store with a known population of entries; its implementation:
#
#     require 'pstore'
#     require 'tempfile'
#     # Yield a pristine store for use in examples.
#     def example_store
#       # Create the store in a temporary file.
#       Tempfile.create do |file|
#         store = PStore.new(file)
#         # Populate the store.
#         store.transaction do
#           store[:foo] = 0
#           store[:bar] = 1
#           store[:baz] = 2
#         end
#         yield store
#       end
#     end
#
# ## The Store
#
# The contents of the store are maintained in a file whose path is specified
# when the store is created (see PStore.new). The objects are stored and
# retrieved using module Marshal, which means that certain objects cannot be
# added to the store; see [Marshal::dump](rdoc-ref:Marshal.dump).
#
# ## Entries
#
# A store may have any number of entries. Each entry has a key and a value, just
# as in a hash:
#
# *   Key: as in a hash, the key can be (almost) any object; see [Hash
#     Keys](rdoc-ref:Hash@Hash+Keys). You may find it convenient to keep it
#     simple by using only symbols or strings as keys.
# *   Value: the value may be any object that can be marshalled by Marshal (see
#     [Marshal::dump](rdoc-ref:Marshal.dump)) and in fact may be a collection
#     (e.g., an array, a hash, a set, a range, etc). That collection may in turn
#     contain nested objects, including collections, to any depth; those objects
#     must also be Marshal-able. See [Hierarchical
#     Values](rdoc-ref:PStore@Hierarchical+Values).
#
# ## Transactions
#
# ### The Transaction Block
#
# The block given with a call to method #transaction# contains a *transaction*,
# which consists of calls to PStore methods that read from or write to the store
# (that is, all PStore methods except #transaction itself, #path, and
# Pstore.new):
#
#     example_store do |store|
#       store.transaction do
#         store.keys # => [:foo, :bar, :baz]
#         store[:bat] = 3
#         store.keys # => [:foo, :bar, :baz, :bat]
#       end
#     end
#
# Execution of the transaction is deferred until the block exits, and is
# executed *atomically* (all-or-nothing): either all transaction calls are
# executed, or none are. This maintains the integrity of the store.
#
# Other code in the block (including even calls to #path and PStore.new) is
# executed immediately, not deferred.
#
# The transaction block:
#
# *   May not contain a nested call to #transaction.
# *   Is the only context where methods that read from or write to the store are
#     allowed.
#
# As seen above, changes in a transaction are made automatically when the block
# exits. The block may be exited early by calling method #commit or #abort.
#
# *   Method #commit triggers the update to the store and exits the block:
#
#         example_store do |store|
#           store.transaction do
#             store.keys # => [:foo, :bar, :baz]
#             store[:bat] = 3
#             store.commit
#             fail 'Cannot get here'
#           end
#           store.transaction do
#             # Update was completed.
#             store.keys # => [:foo, :bar, :baz, :bat]
#           end
#         end
#
# *   Method #abort discards the update to the store and exits the block:
#
#         example_store do |store|
#           store.transaction do
#             store.keys # => [:foo, :bar, :baz]
#             store[:bat] = 3
#             store.abort
#             fail 'Cannot get here'
#           end
#           store.transaction do
#             # Update was not completed.
#             store.keys # => [:foo, :bar, :baz]
#           end
#         end
#
# ### Read-Only Transactions
#
# By default, a transaction allows both reading from and writing to the store:
#
#     store.transaction do
#       # Read-write transaction.
#       # Any code except a call to #transaction is allowed here.
#     end
#
# If argument `read_only` is passed as `true`, only reading is allowed:
#
#     store.transaction(true) do
#       # Read-only transaction:
#       # Calls to #transaction, #[]=, and #delete are not allowed here.
#     end
#
# ## Hierarchical Values
#
# The value for an entry may be a simple object (as seen above). It may also be
# a hierarchy of objects nested to any depth:
#
#     deep_store = PStore.new('deep.store')
#     deep_store.transaction do
#       array_of_hashes = [{}, {}, {}]
#       deep_store[:array_of_hashes] = array_of_hashes
#       deep_store[:array_of_hashes] # => [{}, {}, {}]
#       hash_of_arrays = {foo: [], bar: [], baz: []}
#       deep_store[:hash_of_arrays] = hash_of_arrays
#       deep_store[:hash_of_arrays]  # => {:foo=>[], :bar=>[], :baz=>[]}
#       deep_store[:hash_of_arrays][:foo].push(:bat)
#       deep_store[:hash_of_arrays]  # => {:foo=>[:bat], :bar=>[], :baz=>[]}
#     end
#
# And recall that you can use [dig methods](rdoc-ref:dig_methods.rdoc) in a
# returned hierarchy of objects.
#
# ## Working with the Store
#
# ### Creating a Store
#
# Use method PStore.new to create a store. The new store creates or opens its
# containing file:
#
#     store = PStore.new('t.store')
#
# ### Modifying the Store
#
# Use method #[]= to update or create an entry:
#
#     example_store do |store|
#       store.transaction do
#         store[:foo] = 1 # Update.
#         store[:bam] = 1 # Create.
#       end
#     end
#
# Use method #delete to remove an entry:
#
#     example_store do |store|
#       store.transaction do
#         store.delete(:foo)
#         store[:foo] # => nil
#       end
#     end
#
# ### Retrieving Values
#
# Use method #fetch (allows default) or #[] (defaults to `nil`) to retrieve an
# entry:
#
#     example_store do |store|
#       store.transaction do
#         store[:foo]             # => 0
#         store[:nope]            # => nil
#         store.fetch(:baz)       # => 2
#         store.fetch(:nope, nil) # => nil
#         store.fetch(:nope)      # Raises exception.
#       end
#     end
#
# ### Querying the Store
#
# Use method #key? to determine whether a given key exists:
#
#     example_store do |store|
#       store.transaction do
#         store.key?(:foo) # => true
#       end
#     end
#
# Use method #keys to retrieve keys:
#
#     example_store do |store|
#       store.transaction do
#         store.keys # => [:foo, :bar, :baz]
#       end
#     end
#
# Use method #path to retrieve the path to the store's underlying file; this
# method may be called from outside a transaction block:
#
#     store = PStore.new('t.store')
#     store.path # => "t.store"
#
# ## Transaction Safety
#
# For transaction safety, see:
#
# *   Optional argument `thread_safe` at method PStore.new.
# *   Attribute #ultra_safe.
#
# Needless to say, if you're storing valuable data with PStore, then you should
# backup the PStore file from time to time.
#
# ## An Example Store
#
#     require "pstore"
#
#     # A mock wiki object.
#     class WikiPage
#
#       attr_reader :page_name
#
#       def initialize(page_name, author, contents)
#         @page_name = page_name
#         @revisions = Array.new
#         add_revision(author, contents)
#       end
#
#       def add_revision(author, contents)
#         @revisions << {created: Time.now,
#                        author: author,
#                        contents: contents}
#       end
#
#       def wiki_page_references
#         [@page_name] + @revisions.last[:contents].scan(/\b(?:[A-Z]+[a-z]+){2,}/)
#       end
#
#     end
#
#     # Create a new wiki page.
#     home_page = WikiPage.new("HomePage", "James Edward Gray II",
#                              "A page about the JoysOfDocumentation..." )
#
#     wiki = PStore.new("wiki_pages.pstore")
#     # Update page data and the index together, or not at all.
#     wiki.transaction do
#       # Store page.
#       wiki[home_page.page_name] = home_page
#       # Create page index.
#       wiki[:wiki_index] ||= Array.new
#       # Update wiki index.
#       wiki[:wiki_index].push(*home_page.wiki_page_references)
#     end
#
#     # Read wiki data, setting argument read_only to true.
#     wiki.transaction(true) do
#       wiki.keys.each do |key|
#         puts key
#         puts wiki[key]
#       end
#     end
#
class PStore
  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - [](key)
  # -->
  # Returns the value for the given `key` if the key exists. `nil` otherwise; if
  # not `nil`, the returned value is an object or a hierarchy of objects:
  #
  #     example_store do |store|
  #       store.transaction do
  #         store[:foo]  # => 0
  #         store[:nope] # => nil
  #       end
  #     end
  #
  # Returns `nil` if there is no such key.
  #
  # See also [Hierarchical Values](rdoc-ref:PStore@Hierarchical+Values).
  #
  # Raises an exception if called outside a transaction block.
  #
  def []: (untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - []=(key, value)
  # -->
  # Creates or replaces the value for the given `key`:
  #
  #     example_store do |store|
  #       temp.transaction do
  #         temp[:bat] = 3
  #       end
  #     end
  #
  # See also [Hierarchical Values](rdoc-ref:PStore@Hierarchical+Values).
  #
  # Raises an exception if called outside a transaction block.
  #
  def []=: (untyped name, untyped value) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - abort()
  # -->
  # Exits the current transaction block, discarding any changes specified in the
  # [transaction block](rdoc-ref:PStore@The+Transaction+Block).
  #
  # Raises an exception if called outside a transaction block.
  #
  def abort: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - commit()
  # -->
  # Exits the current transaction block, committing any changes specified in the
  # [transaction block](rdoc-ref:PStore@The+Transaction+Block).
  #
  # Raises an exception if called outside a transaction block.
  #
  def commit: () -> nil

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - delete(key)
  # -->
  # Removes and returns the value at `key` if it exists:
  #
  #     example_store do |store|
  #       store.transaction do
  #         store[:bat] = 3
  #         store.delete(:bat)
  #       end
  #     end
  #
  # Returns `nil` if there is no such key.
  #
  # Raises an exception if called outside a transaction block.
  #
  def delete: (untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - fetch(key, default=PStore::Error)
  # -->
  # Like #[], except that it accepts a default value for the store. If the `key`
  # does not exist:
  #
  # *   Raises an exception if `default` is `PStore::Error`.
  # *   Returns the value of `default` otherwise:
  #
  #         example_store do |store|
  #           store.transaction do
  #             store.fetch(:nope, nil) # => nil
  #             store.fetch(:nope)      # Raises an exception.
  #           end
  #         end
  #
  # Raises an exception if called outside a transaction block.
  #
  def fetch: (untyped name, ?untyped default) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - path()
  # -->
  # Returns the string file path used to create the store:
  #
  #     store.path # => "flat.store"
  #
  def path: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - root?(key)
  # -->
  #
  def root?: (untyped name) -> bool

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - roots()
  # -->
  #
  def roots: () -> Array[untyped]

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - transaction(read_only = false) { |pstore| ... }
  # -->
  # Opens a transaction block for the store. See
  # [Transactions](rdoc-ref:PStore@Transactions).
  #
  # With argument `read_only` as `false`, the block may both read from and write
  # to the store.
  #
  # With argument `read_only` as `true`, the block may not include calls to
  # #transaction, #[]=, or #delete.
  #
  # Raises an exception if called within a transaction block.
  #
  def transaction: (?untyped read_only) -> untyped

  # <!-- rdoc-file=lib/pstore.rb -->
  # Whether PStore should do its best to prevent file corruptions, even when an
  # unlikely error (such as memory-error or filesystem error) occurs:
  #
  # *   `true`: changes are posted by creating a temporary file, writing the
  #     updated data to it, then renaming the file to the given #path. File
  #     integrity is maintained. Note: has effect only if the filesystem has
  #     atomic file rename (as do POSIX platforms Linux, MacOS, FreeBSD and
  #     others).
  #
  # *   `false` (the default): changes are posted by rewinding the open file and
  #     writing the updated data. File integrity is maintained if the filesystem
  #     raises no unexpected I/O error; if such an error occurs during a write to
  #     the store, the file may become corrupted.
  #
  def ultra_safe: () -> untyped

  # <!-- rdoc-file=lib/pstore.rb -->
  # Whether PStore should do its best to prevent file corruptions, even when an
  # unlikely error (such as memory-error or filesystem error) occurs:
  #
  # *   `true`: changes are posted by creating a temporary file, writing the
  #     updated data to it, then renaming the file to the given #path. File
  #     integrity is maintained. Note: has effect only if the filesystem has
  #     atomic file rename (as do POSIX platforms Linux, MacOS, FreeBSD and
  #     others).
  #
  # *   `false` (the default): changes are posted by rewinding the open file and
  #     writing the updated data. File integrity is maintained if the filesystem
  #     raises no unexpected I/O error; if such an error occurs during a write to
  #     the store, the file may become corrupted.
  #
  def ultra_safe=: (untyped) -> untyped

  private

  def dump: (untyped table) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - empty_marshal_checksum()
  # -->
  #
  def empty_marshal_checksum: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - empty_marshal_data()
  # -->
  #
  def empty_marshal_data: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - in_transaction()
  # -->
  # Raises PStore::Error if the calling code is not in a PStore#transaction.
  #
  def in_transaction: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - in_transaction_wr()
  # -->
  # Raises PStore::Error if the calling code is not in a PStore#transaction or if
  # the code is in a read-only PStore#transaction.
  #
  def in_transaction_wr: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - new(file, thread_safe = false)
  # -->
  # Returns a new PStore object.
  #
  # Argument `file` is the path to the file in which objects are to be stored; if
  # the file exists, it should be one that was written by PStore.
  #
  #     path = 't.store'
  #     store = PStore.new(path)
  #
  # A PStore object is
  # [reentrant](https://en.wikipedia.org/wiki/Reentrancy_(computing)). If argument
  # `thread_safe` is given as `true`, the object is also thread-safe (at the cost
  # of a small performance penalty):
  #
  #     store = PStore.new(path, true)
  #
  def initialize: (untyped file, ?boolish thread_safe) -> untyped

  def load: (untyped content) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - load_data(file, read_only)
  # -->
  # Load the given PStore file. If `read_only` is true, the unmarshalled Hash will
  # be returned. If `read_only` is false, a 3-tuple will be returned: the
  # unmarshalled Hash, a checksum of the data, and the size of the data.
  #
  def load_data: (untyped file, untyped read_only) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - on_windows?()
  # -->
  #
  def on_windows?: () -> bool

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - open_and_lock_file(filename, read_only)
  # -->
  # Open the specified filename (either in read-only mode or in read-write mode)
  # and lock it for reading or writing.
  #
  # The opened File object will be returned. If *read_only* is true, and the file
  # does not exist, then nil will be returned.
  #
  # All exceptions are propagated.
  #
  def open_and_lock_file: (untyped filename, untyped read_only) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data(original_checksum, original_file_size, file)
  # -->
  #
  def save_data: (untyped original_checksum, untyped original_file_size, untyped file) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data_with_atomic_file_rename_strategy(data, file)
  # -->
  #
  def save_data_with_atomic_file_rename_strategy: (untyped data, untyped file) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data_with_fast_strategy(data, file)
  # -->
  #
  def save_data_with_fast_strategy: (untyped data, untyped file) -> untyped
end

PStore::EMPTY_MARSHAL_CHECKSUM: String

PStore::EMPTY_MARSHAL_DATA: String

PStore::EMPTY_STRING: String

PStore::RDWR_ACCESS: Hash[untyped, untyped]

PStore::RD_ACCESS: Hash[untyped, untyped]

PStore::VERSION: String

PStore::WR_ACCESS: Hash[untyped, untyped]
# <!-- rdoc-file=ext/psych/lib/psych.rb -->
# # Overview
#
# Psych is a YAML parser and emitter. Psych leverages libyaml [Home page:
# https://pyyaml.org/wiki/LibYAML] or [git repo:
# https://github.com/yaml/libyaml] for its YAML parsing and emitting
# capabilities. In addition to wrapping libyaml, Psych also knows how to
# serialize and de-serialize most Ruby objects to and from the YAML format.
#
# # I NEED TO PARSE OR EMIT YAML RIGHT NOW!
#
#     # Parse some YAML
#     Psych.load("--- foo") # => "foo"
#
#     # Emit some YAML
#     Psych.dump("foo")     # => "--- foo\n...\n"
#     { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
#
# Got more time on your hands?  Keep on reading!
#
# ## YAML Parsing
#
# Psych provides a range of interfaces for parsing a YAML document ranging from
# low level to high level, depending on your parsing needs.  At the lowest
# level, is an event based parser.  Mid level is access to the raw YAML AST, and
# at the highest level is the ability to unmarshal YAML to Ruby objects.
#
# ## YAML Emitting
#
# Psych provides a range of interfaces ranging from low to high level for
# producing YAML documents.  Very similar to the YAML parsing interfaces, Psych
# provides at the lowest level, an event based system, mid-level is building a
# YAML AST, and the highest level is converting a Ruby object straight to a YAML
# document.
#
# ## High-level API
#
# ### Parsing
#
# The high level YAML parser provided by Psych simply takes YAML as input and
# returns a Ruby data structure.  For information on using the high level parser
# see Psych.load
#
# #### Reading from a string
#
#     Psych.safe_load("--- a")             # => 'a'
#     Psych.safe_load("---\n - a\n - b")   # => ['a', 'b']
#     # From a trusted string:
#     Psych.load("--- !ruby/range\nbegin: 0\nend: 42\nexcl: false\n") # => 0..42
#
# #### Reading from a file
#
#     Psych.safe_load_file("data.yml", permitted_classes: [Date])
#     Psych.load_file("trusted_database.yml")
#
# #### Exception handling
#
#     begin
#       # The second argument changes only the exception contents
#       Psych.parse("--- `", "file.txt")
#     rescue Psych::SyntaxError => ex
#       ex.file    # => 'file.txt'
#       ex.message # => "(file.txt): found character that cannot start any token"
#     end
#
# ### Emitting
#
# The high level emitter has the easiest interface.  Psych simply takes a Ruby
# data structure and converts it to a YAML document.  See Psych.dump for more
# information on dumping a Ruby data structure.
#
# #### Writing to a string
#
#     # Dump an array, get back a YAML string
#     Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
#
#     # Dump an array to an IO object
#     Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
#
#     # Dump an array with indentation set
#     Psych.dump(['a', ['b']], :indentation => 3) # => "---\n- a\n-  - b\n"
#
#     # Dump an array to an IO with indentation set
#     Psych.dump(['a', ['b']], StringIO.new, :indentation => 3)
#
# #### Writing to a file
#
# Currently there is no direct API for dumping Ruby structure to file:
#
#     File.open('database.yml', 'w') do |file|
#       file.write(Psych.dump(['a', 'b']))
#     end
#
# ## Mid-level API
#
# ### Parsing
#
# Psych provides access to an AST produced from parsing a YAML document.  This
# tree is built using the Psych::Parser and Psych::TreeBuilder.  The AST can be
# examined and manipulated freely.  Please see Psych::parse_stream,
# Psych::Nodes, and Psych::Nodes::Node for more information on dealing with YAML
# syntax trees.
#
# #### Reading from a string
#
#     # Returns Psych::Nodes::Stream
#     Psych.parse_stream("---\n - a\n - b")
#
#     # Returns Psych::Nodes::Document
#     Psych.parse("---\n - a\n - b")
#
# #### Reading from a file
#
#     # Returns Psych::Nodes::Stream
#     Psych.parse_stream(File.read('database.yml'))
#
#     # Returns Psych::Nodes::Document
#     Psych.parse_file('database.yml')
#
# #### Exception handling
#
#     begin
#       # The second argument changes only the exception contents
#       Psych.parse("--- `", "file.txt")
#     rescue Psych::SyntaxError => ex
#       ex.file    # => 'file.txt'
#       ex.message # => "(file.txt): found character that cannot start any token"
#     end
#
# ### Emitting
#
# At the mid level is building an AST.  This AST is exactly the same as the AST
# used when parsing a YAML document.  Users can build an AST by hand and the AST
# knows how to emit itself as a YAML document.  See Psych::Nodes,
# Psych::Nodes::Node, and Psych::TreeBuilder for more information on building a
# YAML AST.
#
# #### Writing to a string
#
#     # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#     stream = Psych.parse_stream("---\n - a\n - b")
#
#     stream.to_yaml # => "---\n- a\n- b\n"
#
# #### Writing to a file
#
#     # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#     stream = Psych.parse_stream(File.read('database.yml'))
#
#     File.open('database.yml', 'w') do |file|
#       file.write(stream.to_yaml)
#     end
#
# ## Low-level API
#
# ### Parsing
#
# The lowest level parser should be used when the YAML input is already known,
# and the developer does not want to pay the price of building an AST or
# automatic detection and conversion to Ruby objects.  See Psych::Parser for
# more information on using the event based parser.
#
# #### Reading to Psych::Nodes::Stream structure
#
#     parser = Psych::Parser.new(TreeBuilder.new) # => #<Psych::Parser>
#     parser = Psych.parser                       # it's an alias for the above
#
#     parser.parse("---\n - a\n - b")             # => #<Psych::Parser>
#     parser.handler                              # => #<Psych::TreeBuilder>
#     parser.handler.root                         # => #<Psych::Nodes::Stream>
#
# #### Receiving an events stream
#
#     recorder = Psych::Handlers::Recorder.new
#     parser = Psych::Parser.new(recorder)
#
#     parser.parse("---\n - a\n - b")
#     recorder.events # => [list of [event, args] lists]
#                     # event is one of: Psych::Handler::EVENTS
#                     # args are the arguments passed to the event
#
# ### Emitting
#
# The lowest level emitter is an event based system.  Events are sent to a
# Psych::Emitter object.  That object knows how to convert the events to a YAML
# document.  This interface should be used when document format is known in
# advance or speed is a concern.  See Psych::Emitter for more information.
#
# #### Writing to a Ruby structure
#
#     Psych.parser.parse("--- a")       # => #<Psych::Parser>
#
#     parser.handler.first              # => #<Psych::Nodes::Stream>
#     parser.handler.first.to_ruby      # => ["a"]
#
#     parser.handler.root.first         # => #<Psych::Nodes::Document>
#     parser.handler.root.first.to_ruby # => "a"
#
#     # You can instantiate an Emitter manually
#     Psych::Visitors::ToRuby.new.accept(parser.handler.root.first)
#     # => "a"
#
module Psych
  # <!--
  #   rdoc-file=ext/psych/lib/psych.rb
  #   - Psych.dump(o)               -> string of yaml
  #   - Psych.dump(o, options)      -> string of yaml
  #   - Psych.dump(o, io)           -> io object passed in
  #   - Psych.dump(o, io, options)  -> io object passed in
  # -->
  # Dump Ruby object `o` to a YAML string.  Optional `options` may be passed in to
  # control the output format.  If an IO object is passed in, the YAML will be
  # dumped to that IO object.
  #
  # Currently supported options are:
  #
  # `:indentation`
  # :   Number of space characters used to indent. Acceptable value should be in
  #     `0..9` range, otherwise option is ignored.
  #
  #     Default: `2`.
  #
  # `:line_width`
  # :   Max character to wrap line at. For unlimited line width use `-1`.
  #
  #     Default: `0` (meaning "wrap at 81").
  #
  # `:canonical`
  # :   Write "canonical" YAML form (very verbose, yet strictly formal).
  #
  #     Default: `false`.
  #
  # `:header`
  # :   Write `%YAML [version]` at the beginning of document.
  #
  #     Default: `false`.
  #
  #
  # `:stringify_names`
  # :   Dump symbol keys in Hash objects as string.
  #
  #     Default: `false`.
  #
  #
  # Example:
  #
  #     # Dump an array, get back a YAML string
  #     Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
  #
  #     # Dump an array to an IO object
  #     Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
  #
  #     # Dump an array with indentation set
  #     Psych.dump(['a', ['b']], indentation: 3) # => "---\n- a\n-  - b\n"
  #
  #     # Dump an array to an IO with indentation set
  #     Psych.dump(['a', ['b']], StringIO.new, indentation: 3)
  #
  #     # Dump hash with symbol keys as string
  #     Psych.dump({a: "b"}, stringify_names: true) # => "---\na: b\n"
  #
  %a{annotate:rdoc:copy:Psych.dump}
  def self.dump: (untyped o, ?indentation: Integer, ?line_width: Integer, ?canonical: bool, ?header: bool) -> String
               | [IO] (untyped o, IO, ?indentation: Integer, ?line_width: Integer, ?canonical: bool, ?header: bool) -> IO

  # <!--
  #   rdoc-file=ext/psych/lib/psych.rb
  #   - load(yaml, permitted_classes: [Symbol], permitted_symbols: [], aliases: false, filename: nil, fallback: nil, symbolize_names: false, freeze: false, strict_integer: false)
  # -->
  # Load `yaml` in to a Ruby data structure.  If multiple documents are provided,
  # the object contained in the first document will be returned. `filename` will
  # be used in the exception message if any exception is raised while parsing.  If
  # `yaml` is empty, it returns the specified `fallback` return value, which
  # defaults to `nil`.
  #
  # Raises a Psych::SyntaxError when a YAML syntax error is detected.
  #
  # Example:
  #
  #     Psych.load("--- a")             # => 'a'
  #     Psych.load("---\n - a\n - b")   # => ['a', 'b']
  #
  #     begin
  #       Psych.load("--- `", filename: "file.txt")
  #     rescue Psych::SyntaxError => ex
  #       ex.file    # => 'file.txt'
  #       ex.message # => "(file.txt): found character that cannot start any token"
  #     end
  #
  # When the optional `symbolize_names` keyword argument is set to a true value,
  # returns symbols for keys in Hash objects (default: strings).
  #
  #     Psych.load("---\n foo: bar")                         # => {"foo"=>"bar"}
  #     Psych.load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
  #
  # Raises a TypeError when `yaml` parameter is NilClass.  This method is similar
  # to `safe_load` except that `Symbol` objects are allowed by default.
  #
  %a{annotate:rdoc:copy:Psych.load}
  def self.load: (String yaml, ?filename: String | _ToStr | _ToS?, ?fallback: untyped, ?symbolize_names: bool, ?freeze: bool) -> untyped

  # <!--
  #   rdoc-file=ext/psych/lib/psych.rb
  #   - load_file(filename, **kwargs)
  # -->
  # Loads the document contained in `filename`.  Returns the yaml contained in
  # `filename` as a Ruby object, or if the file is empty, it returns the specified
  # `fallback` return value, which defaults to `nil`. See load for options.
  #
  %a{annotate:rdoc:copy:Psych.load_file}
  def self.load_file: (string | _ToPath, ?fallback: untyped, ?symbolize_names: bool, ?freeze: bool) -> untyped

  # <!--
  #   rdoc-file=ext/psych/lib/psych.rb
  #   - safe_load(yaml, permitted_classes: [], permitted_symbols: [], aliases: false, filename: nil, fallback: nil, symbolize_names: false, freeze: false, strict_integer: false)
  # -->
  # Safely load the yaml string in `yaml`.  By default, only the following classes
  # are allowed to be deserialized:
  #
  # *   TrueClass
  # *   FalseClass
  # *   NilClass
  # *   Integer
  # *   Float
  # *   String
  # *   Array
  # *   Hash
  #
  # Recursive data structures are not allowed by default.  Arbitrary classes can
  # be allowed by adding those classes to the `permitted_classes` keyword
  # argument.  They are additive.  For example, to allow Date deserialization:
  #
  #     Psych.safe_load(yaml, permitted_classes: [Date])
  #
  # Now the Date class can be loaded in addition to the classes listed above.
  #
  # Aliases can be explicitly allowed by changing the `aliases` keyword argument.
  # For example:
  #
  #     x = []
  #     x << x
  #     yaml = Psych.dump x
  #     Psych.safe_load yaml               # => raises an exception
  #     Psych.safe_load yaml, aliases: true # => loads the aliases
  #
  # A Psych::DisallowedClass exception will be raised if the yaml contains a class
  # that isn't in the `permitted_classes` list.
  #
  # A Psych::AliasesNotEnabled exception will be raised if the yaml contains
  # aliases but the `aliases` keyword argument is set to false.
  #
  # `filename` will be used in the exception message if any exception is raised
  # while parsing.
  #
  # When the optional `symbolize_names` keyword argument is set to a true value,
  # returns symbols for keys in Hash objects (default: strings).
  #
  #     Psych.safe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
  #     Psych.safe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
  #
  %a{annotate:rdoc:copy:Psych.safe_load}
  def self.safe_load: (String yaml, ?permitted_classes: Array[Class], ?permitted_symbols: Array[Symbol], ?aliases: bool, ?filename: String | _ToStr | _ToS?, ?fallback: untyped, ?symbolize_names: bool, ?freeze: bool) -> untyped

  # <!--
  #   rdoc-file=ext/psych/lib/psych.rb
  #   - unsafe_load(yaml, filename: nil, fallback: false, symbolize_names: false, freeze: false, strict_integer: false)
  # -->
  # Load `yaml` in to a Ruby data structure.  If multiple documents are provided,
  # the object contained in the first document will be returned. `filename` will
  # be used in the exception message if any exception is raised while parsing.  If
  # `yaml` is empty, it returns the specified `fallback` return value, which
  # defaults to `false`.
  #
  # Raises a Psych::SyntaxError when a YAML syntax error is detected.
  #
  # Example:
  #
  #     Psych.unsafe_load("--- a")             # => 'a'
  #     Psych.unsafe_load("---\n - a\n - b")   # => ['a', 'b']
  #
  #     begin
  #       Psych.unsafe_load("--- `", filename: "file.txt")
  #     rescue Psych::SyntaxError => ex
  #       ex.file    # => 'file.txt'
  #       ex.message # => "(file.txt): found character that cannot start any token"
  #     end
  #
  # When the optional `symbolize_names` keyword argument is set to a true value,
  # returns symbols for keys in Hash objects (default: strings).
  #
  #     Psych.unsafe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
  #     Psych.unsafe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
  #
  # Raises a TypeError when `yaml` parameter is NilClass
  #
  # NOTE: This method *should not* be used to parse untrusted documents, such as
  # YAML documents that are supplied via user input.  Instead, please use the load
  # method or the safe_load method.
  #
  %a{annotate:rdoc:copy:Psych.unsafe_load}
  def self.unsafe_load: (String yaml, ?filename: String | _ToStr | _ToS?, ?fallback: untyped, ?symbolize_names: bool, ?freeze: bool, ?strict_integer: bool) -> untyped
end
%a{annotate:rdoc:skip}
module Psych
  # <!-- rdoc-file=lib/yaml/dbm.rb -->
  # YAML + DBM = YDBM
  #
  # YAML::DBM provides the same interface as ::DBM.
  #
  # However, while DBM only allows strings for both keys and values, this library
  # allows one to use most Ruby objects for values by first converting them to
  # YAML. Keys must be strings.
  #
  # Conversion to and from YAML is performed automatically.
  #
  # See the documentation for ::DBM and ::YAML for more information.
  #
  class DBM < ::DBM
    VERSION: ::String

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm[key] -> value
    # -->
    # Return value associated with `key` from database.
    #
    # Returns `nil` if there is no such `key`.
    #
    # See #fetch for more information.
    #
    def []: (String key) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm[key] = value
    # -->
    # Set `key` to `value` in database.
    #
    # `value` will be converted to YAML before storage.
    #
    # See #store for more information.
    #
    def []=: (String key, untyped val) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.fetch( key, ifnone = nil )
    #   - ydbm.fetch( key ) { |key| ... }
    # -->
    # Return value associated with `key`.
    #
    # If there is no value for `key` and no block is given, returns `ifnone`.
    #
    # Otherwise, calls block passing in the given `key`.
    #
    # See ::DBM#fetch for more information.
    #
    def fetch: (String keystr, ?untyped? ifnone) { (untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - index( keystr )
    # -->
    # Deprecated, used YAML::DBM#key instead.
    # ---
    # Note: YAML::DBM#index makes warning from internal of ::DBM#index. It says
    # 'DBM#index is deprecated; use DBM#key', but DBM#key behaves not same as
    # DBM#index.
    #
    def index: (String keystr) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.key(value) -> string
    # -->
    # Returns the key for the specified value.
    #
    def key: (String keystr) -> String

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.values_at(*keys)
    # -->
    # Returns an array containing the values associated with the given keys.
    #
    def values_at: (*untyped keys) -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.delete(key)
    # -->
    # Deletes value from database associated with `key`.
    #
    # Returns value or `nil`.
    #
    def delete: (String key) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.delete_if { |key, value| ... }
    # -->
    # Calls the given block once for each `key`, `value` pair in the database.
    # Deletes all entries for which the block returns true.
    #
    # Returns `self`.
    #
    def delete_if: () { (untyped, untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.reject { |key, value| ... }
    # -->
    # Converts the contents of the database to an in-memory Hash, then calls
    # Hash#reject with the specified code block, returning a new Hash.
    #
    def reject: () { (untyped, untyped) -> untyped } -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.each_pair { |key, value| ... }
    # -->
    # Calls the given block once for each `key`, `value` pair in the database.
    #
    # Returns `self`.
    #
    def each_pair: () { (untyped, untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.each_value { |value| ... }
    # -->
    # Calls the given block for each value in database.
    #
    # Returns `self`.
    #
    def each_value: () { (untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.values
    # -->
    # Returns an array of values from the database.
    #
    def values: () -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.has_value?(value)
    # -->
    # Returns true if specified `value` is found in the database.
    #
    def has_value?: (untyped val) -> (::TrueClass | ::FalseClass)

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.invert -> hash
    # -->
    # Returns a Hash (not a DBM database) created by using each value in the
    # database as a key, with the corresponding key as its value.
    #
    # Note that all values in the hash will be Strings, but the keys will be actual
    # objects.
    #
    def invert: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.replace(hash) -> ydbm
    # -->
    # Replaces the contents of the database with the contents of the specified
    # object. Takes any object which implements the each_pair method, including Hash
    # and DBM objects.
    #
    def replace: (Hash[untyped, untyped] | DBM hsh) -> Psych::DBM

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.shift -> [key, value]
    # -->
    # Removes a [key, value] pair from the database, and returns it. If the database
    # is empty, returns `nil`.
    #
    # The order in which values are removed/returned is not guaranteed.
    #
    def shift: () -> (Array[untyped] | untyped)

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.select { |key, value| ... }
    #   - ydbm.select(*keys)
    # -->
    # If a block is provided, returns a new array containing [key, value] pairs for
    # which the block returns true.
    #
    # Otherwise, same as #values_at
    #
    def select: (*untyped keys) { (untyped, untyped) -> untyped } -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.store(key, value) -> value
    # -->
    # Stores `value` in database with `key` as the index. `value` is converted to
    # YAML before being stored.
    #
    # Returns `value`
    #
    def store: (String key, untyped val) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.update(hash) -> ydbm
    # -->
    # Updates the database with multiple values from the specified object. Takes any
    # object which implements the each_pair method, including Hash and DBM objects.
    #
    # Returns `self`.
    #
    def update: (Hash[untyped, untyped]) -> Psych::DBM

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.to_a -> array
    # -->
    # Converts the contents of the database to an array of [key, value] arrays, and
    # returns it.
    #
    def to_a: () -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.to_hash -> hash
    # -->
    # Converts the contents of the database to an in-memory Hash object, and returns
    # it.
    #
    def to_hash: () -> Hash[untyped, untyped]
  end
end
# <!-- rdoc-file=lib/yaml/store.rb -->
# YAML::Store provides the same functionality as PStore, except it uses YAML to
# dump objects instead of Marshal.
#
# ## Example
#
#     require 'yaml/store'
#
#     Person = Struct.new :first_name, :last_name
#
#     people = [Person.new("Bob", "Smith"), Person.new("Mary", "Johnson")]
#
#     store = YAML::Store.new "test.store"
#
#     store.transaction do
#       store["people"] = people
#       store["greeting"] = { "hello" => "world" }
#     end
#
# After running the above code, the contents of "test.store" will be:
#
#     ---
#     people:
#     - !ruby/struct:Person
#       first_name: Bob
#       last_name: Smith
#     - !ruby/struct:Person
#       first_name: Mary
#       last_name: Johnson
#     greeting:
#       hello: world
#
class Psych::Store < ::PStore
  # <!--
  #   rdoc-file=lib/yaml/store.rb
  #   - initialize( file_name, yaml_opts = {} )
  #   - initialize( file_name, thread_safe = false, yaml_opts = {} )
  # -->
  # Creates a new YAML::Store object, which will store data in `file_name`. If the
  # file does not already exist, it will be created.
  #
  # YAML::Store objects are always reentrant. But if *thread_safe* is set to true,
  # then it will become thread-safe at the cost of a minor performance hit.
  #
  # Options passed in through `yaml_opts` will be used when converting the store
  # to YAML via Hash#to_yaml().
  #
  def initialize: (*untyped o) -> void

  def dump: (untyped table) -> String

  def empty_marshal_checksum: () -> String

  def empty_marshal_data: () -> String

  def load: (String) -> untyped

  def marshal_dump_supports_canonical_option?: () -> ::FalseClass
end
%a{annotate:rdoc:skip}
class Object
  # <!--
  #   rdoc-file=ext/psych/lib/psych/core_ext.rb
  #   - to_yaml(options = {})
  # -->
  # Convert an object to YAML.  See Psych.dump for more information on the
  # available `options`.
  #
  def to_yaml: (?indentation: Integer, ?line_width: Integer, ?canonical: bool, ?header: bool) -> String
             | [IO] (IO, ?indentation: Integer, ?line_width: Integer, ?canonical: bool, ?header: bool) -> IO
end
# <!-- rdoc-file=ext/pty/pty.c -->
# Creates and manages pseudo terminals (PTYs).  See also
# https://en.wikipedia.org/wiki/Pseudo_terminal
#
# PTY allows you to allocate new terminals using ::open or ::spawn a new
# terminal with a specific command.
#
# ## Example
#
# In this example we will change the buffering type in the `factor` command,
# assuming that factor uses stdio for stdout buffering.
#
# If IO.pipe is used instead of PTY.open, this code deadlocks because factor's
# stdout is fully buffered.
#
#     # start by requiring the standard library PTY
#     require 'pty'
#
#     master, slave = PTY.open
#     read, write = IO.pipe
#     pid = spawn("factor", :in=>read, :out=>slave)
#     read.close     # we dont need the read
#     slave.close    # or the slave
#
#     # pipe "42" to the factor command
#     write.puts "42"
#     # output the response from factor
#     p master.gets #=> "42: 2 3 7\n"
#
#     # pipe "144" to factor and print out the response
#     write.puts "144"
#     p master.gets #=> "144: 2 2 2 2 3 3\n"
#     write.close # close the pipe
#
#     # The result of read operation when pty slave is closed is platform
#     # dependent.
#     ret = begin
#             master.gets     # FreeBSD returns nil.
#           rescue Errno::EIO # GNU/Linux raises EIO.
#             nil
#           end
#     p ret #=> nil
#
# ## License
#
# (c) Copyright 1998 by Akinori Ito.
#
# This software may be redistributed freely for this purpose, in full or in
# part, provided that this entire copyright notice is included on any copies of
# this software and applications and derivations thereof.
#
# This software is provided on an "as is" basis, without warranty of any kind,
# either expressed or implied, as to any matter including, but not limited to
# warranty of fitness of purpose, or merchantability, or results obtained from
# use of this software.
#
module PTY
  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.check(pid, raise = false) => Process::Status or nil
  #   - PTY.check(pid, true)          => nil or raises PTY::ChildExited
  # -->
  # Checks the status of the child process specified by `pid`. Returns `nil` if
  # the process is still alive.
  #
  # If the process is not alive, and `raise` was true, a PTY::ChildExited
  # exception will be raised. Otherwise it will return a Process::Status instance.
  #
  # `pid`
  # :   The process id of the process to check
  #
  # `raise`
  # :   If `true` and the process identified by `pid` is no longer alive a
  #     PTY::ChildExited is raised.
  #
  def self.check: (Integer pid, ?boolish raise) -> Process::Status?

  # <!-- rdoc-file=ext/pty/pty.c -->
  # Spawns the specified command on a newly allocated pty. You can also use the
  # alias ::getpty.
  #
  # The command's controlling tty is set to the slave device of the pty and its
  # standard input/output/error is redirected to the slave device.
  #
  # `env` is an optional hash that provides additional environment variables to
  # the spawned pty.
  #
  #     # sets FOO to "bar"
  #     PTY.spawn({"FOO"=>"bar"}, "printenv", "FOO") do |r, w, pid|
  #       p r.read #=> "bar\r\n"
  #     ensure
  #       r.close; w.close; Process.wait(pid)
  #     end
  #     # unsets FOO
  #     PTY.spawn({"FOO"=>nil}, "printenv", "FOO") do |r, w, pid|
  #       p r.read #=> ""
  #     ensure
  #       r.close; w.close; Process.wait(pid)
  #     end
  #
  # `command` and `command_line` are the full commands to run, given a String. Any
  # additional `arguments` will be passed to the command.
  #
  # ### Return values
  #
  # In the non-block form this returns an array of size three, `[r, w, pid]`.
  #
  # In the block form these same values will be yielded to the block:
  #
  # `r`
  # :   A readable IO that contains the command's standard output and standard
  #     error
  #
  # `w`
  # :   A writable IO that is the command's standard input
  #
  # `pid`
  # :   The process identifier for the command.
  #
  #
  # ### Clean up
  #
  # This method does not clean up like closing IOs or waiting for child process,
  # except that the process is detached in the block form to prevent it from
  # becoming a zombie (see Process.detach).  Any other cleanup is the
  # responsibility of the caller.  If waiting for `pid`, be sure to close both `r`
  # and `w` before doing so; doing it in the reverse order may cause deadlock on
  # some OSes.
  #
  alias self.getpty self.spawn

  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.open => [master_io, slave_file]
  #   - PTY.open {|(master_io, slave_file)| ... } => block value
  # -->
  # Allocates a pty (pseudo-terminal).
  #
  # In the block form, yields an array of two elements (`master_io, slave_file`)
  # and the value of the block is returned from `open`.
  #
  # The IO and File are both closed after the block completes if they haven't been
  # already closed.
  #
  #     PTY.open {|master, slave|
  #       p master      #=> #<IO:masterpty:/dev/pts/1>
  #       p slave      #=> #<File:/dev/pts/1>
  #       p slave.path #=> "/dev/pts/1"
  #     }
  #
  # In the non-block form, returns a two element array, `[master_io, slave_file]`.
  #
  #     master, slave = PTY.open
  #     # do something with master for IO, or the slave file
  #
  # The arguments in both forms are:
  #
  # `master_io`
  # :   the master of the pty, as an IO.
  #
  # `slave_file`
  # :   the slave of the pty, as a File.  The path to the terminal device is
  #     available via `slave_file.path`
  #
  #
  # IO#raw! is usable to disable newline conversions:
  #
  #     require 'io/console'
  #     PTY.open {|m, s|
  #       s.raw!
  #       # ...
  #     }
  #
  def self.open: () -> [ IO, File ]
               | [A] () { ([ IO, File ]) -> A } -> A

  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.spawn([env,] command_line)  { |r, w, pid| ... }
  #   - PTY.spawn([env,] command_line)  => [r, w, pid]
  #   - PTY.spawn([env,] command, arguments, ...)  { |r, w, pid| ... }
  #   - PTY.spawn([env,] command, arguments, ...)  => [r, w, pid]
  # -->
  # Spawns the specified command on a newly allocated pty. You can also use the
  # alias ::getpty.
  #
  # The command's controlling tty is set to the slave device of the pty and its
  # standard input/output/error is redirected to the slave device.
  #
  # `env` is an optional hash that provides additional environment variables to
  # the spawned pty.
  #
  #     # sets FOO to "bar"
  #     PTY.spawn({"FOO"=>"bar"}, "printenv", "FOO") do |r, w, pid|
  #       p r.read #=> "bar\r\n"
  #     ensure
  #       r.close; w.close; Process.wait(pid)
  #     end
  #     # unsets FOO
  #     PTY.spawn({"FOO"=>nil}, "printenv", "FOO") do |r, w, pid|
  #       p r.read #=> ""
  #     ensure
  #       r.close; w.close; Process.wait(pid)
  #     end
  #
  # `command` and `command_line` are the full commands to run, given a String. Any
  # additional `arguments` will be passed to the command.
  #
  # ### Return values
  #
  # In the non-block form this returns an array of size three, `[r, w, pid]`.
  #
  # In the block form these same values will be yielded to the block:
  #
  # `r`
  # :   A readable IO that contains the command's standard output and standard
  #     error
  #
  # `w`
  # :   A writable IO that is the command's standard input
  #
  # `pid`
  # :   The process identifier for the command.
  #
  #
  # ### Clean up
  #
  # This method does not clean up like closing IOs or waiting for child process,
  # except that the process is detached in the block form to prevent it from
  # becoming a zombie (see Process.detach).  Any other cleanup is the
  # responsibility of the caller.  If waiting for `pid`, be sure to close both `r`
  # and `w` before doing so; doing it in the reverse order may cause deadlock on
  # some OSes.
  #
  def self.spawn: (*String command) -> [ IO, IO, Integer ]
                | (*String command) { ([ IO, IO, Integer ]) -> void } -> void
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/code_object.rb -->
  # Base class for the RDoc code tree.
  #
  # We contain the common stuff for contexts (which are containers) and other
  # elements (methods, attributes and so on)
  #
  # Here's the tree of the CodeObject subclasses:
  #
  # *   RDoc::Context
  #     *   RDoc::TopLevel
  #     *   RDoc::ClassModule
  #         *   RDoc::AnonClass (never used so far)
  #         *   RDoc::NormalClass
  #         *   RDoc::NormalModule
  #         *   RDoc::SingleClass
  # *   RDoc::MethodAttr
  #     *   RDoc::Attr
  #     *   RDoc::AnyMethod
  #         *   RDoc::GhostMethod
  #         *   RDoc::MetaMethod
  # *   RDoc::Alias
  # *   RDoc::Constant
  # *   RDoc::Mixin
  #     *   RDoc::Require
  #     *   RDoc::Include
  #
  class CodeObject
    # <!-- rdoc-file=lib/rdoc/code_object.rb -->
    # Our comment
    #
    attr_reader comment: Markup::Document | Comment | String

    # <!--
    #   rdoc-file=lib/rdoc/code_object.rb
    #   - new()
    # -->
    # Creates a new CodeObject that will document itself and its children
    #
    def initialize: () -> void

    # <!--
    #   rdoc-file=lib/rdoc/code_object.rb
    #   - comment=(comment)
    # -->
    # Replaces our comment with `comment`, unless it is empty.
    #
    def comment=: (Markup::Document | Comment | String | nil) -> (Markup::Document | Comment | String)
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/store.rb -->
  # A set of rdoc data for a single project (gem, path, etc.).
  #
  # The store manages reading and writing ri data for a project and maintains a
  # cache of methods, classes and ancestors in the store.
  #
  # The store maintains a #cache of its contents for faster lookup.  After adding
  # items to the store it must be flushed using #save_cache.  The cache contains
  # the following structures:
  #
  #     @cache = {
  #       :ancestors        => {}, # class name => ancestor names
  #       :attributes       => {}, # class name => attributes
  #       :class_methods    => {}, # class name => class methods
  #       :instance_methods => {}, # class name => instance methods
  #       :modules          => [], # classes and modules in this store
  #       :pages            => [], # page names
  #     }
  #
  class Store
    # <!--
    #   rdoc-file=lib/rdoc/store.rb
    #   - new(path = nil, type = nil)
    # -->
    # Creates a new Store of `type` that will load or save to `path`
    #
    def initialize: (?String? path, ?Symbol? type) -> void

    # <!--
    #   rdoc-file=lib/rdoc/store.rb
    #   - find_class_or_module(name)
    # -->
    # Finds the class or module with `name`
    #
    def find_class_or_module: (String) -> ClassModule?

    # <!--
    #   rdoc-file=lib/rdoc/store.rb
    #   - load_all()
    # -->
    # Loads all items from this store into memory.  This recreates a documentation
    # tree for use by a generator
    #
    def load_all: () -> void
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/comment.rb -->
  # A comment holds the text comment for a RDoc::CodeObject and provides a unified
  # way of cleaning it up and parsing it into an RDoc::Markup::Document.
  #
  # Each comment may have a different markup format set by #format=.  By default
  # 'rdoc' is used.  The :markup: directive tells RDoc which format to use.
  #
  # See RDoc::MarkupReference@Directive+for+Specifying+RDoc+Source+Format.
  #
  class Comment
    # <!-- rdoc-file=lib/rdoc/comment.rb -->
    # The format of this comment.  Defaults to RDoc::Markup
    #
    attr_reader format: String

    # <!-- rdoc-file=lib/rdoc/comment.rb -->
    # The RDoc::TopLevel this comment was found in
    #
    attr_accessor location: String

    # <!--
    #   rdoc-file=lib/rdoc/comment.rb
    #   - new(text = nil, location = nil, language = nil)
    # -->
    # Creates a new comment with `text` that is found in the RDoc::TopLevel
    # `location`.
    #
    def initialize: (?String? text, ?RDoc::Context? location, ?String? language) -> void

    # <!--
    #   rdoc-file=lib/rdoc/comment.rb
    #   - format=(format)
    # -->
    # Sets the format of this comment and resets any parsed document
    #
    def format=: (String format) -> void

    def normalized?: () -> bool

    # <!--
    #   rdoc-file=lib/rdoc/comment.rb
    #   - normalize()
    # -->
    # Normalizes the text.  See RDoc::Text#normalize_comment for details
    #
    def normalize: () -> self

    # <!--
    #   rdoc-file=lib/rdoc/comment.rb
    #   - parse()
    # -->
    # Parses the comment into an RDoc::Markup::Document.  The parsed document is
    # cached until the text is changed.
    #
    def parse: () -> Markup::Document
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/ri.rb -->
  # Namespace for the ri command line tool's implementation.
  #
  # See `ri --help` for details.
  #
  module RI
    module Paths
      type path_type = :system | :site | :home | :gem | :extra

      type gem_filter = :latest | :all

      def self.each: (?bool system, ?bool site, ?bool home, ?gem_filter | false gems, *String extra_dirs) { (String, path_type) -> void } -> void
    end
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/parser.rb -->
  # A parser is simple a class that subclasses RDoc::Parser and implements #scan
  # to fill in an RDoc::TopLevel with parsed data.
  #
  # The initialize method takes an RDoc::TopLevel to fill with parsed content, the
  # name of the file to be parsed, the content of the file, an RDoc::Options
  # object and an RDoc::Stats object to inform the user of parsed items.  The scan
  # method is then called to parse the file and must return the RDoc::TopLevel
  # object.  By calling super these items will be set for you.
  #
  # In order to be used by RDoc the parser needs to register the file extensions
  # it can parse.  Use ::parse_files_matching to register extensions.
  #
  #     require 'rdoc'
  #
  #     class RDoc::Parser::Xyz < RDoc::Parser
  #       parse_files_matching /\.xyz$/
  #
  #       def initialize top_level, file_name, content, options, stats
  #         super
  #
  #         # extra initialization if needed
  #       end
  #
  #       def scan
  #         # parse file and fill in @top_level
  #       end
  #     end
  #
  class Parser
    # <!--
    #   rdoc-file=lib/rdoc/parser.rb
    #   - parse_files_matching(regexp)
    # -->
    # Record which file types this parser can understand.
    #
    # It is ok to call this multiple times.
    #
    def self?.parse_files_matching: (Regexp path) -> void

    # <!--
    #   rdoc-file=lib/rdoc/parser.rb
    #   - new(top_level, file_name, content, options, stats)
    # -->
    # Creates a new Parser storing `top_level`, `file_name`, `content`, `options`
    # and `stats` in instance variables.  In +@preprocess+ an
    # RDoc::Markup::PreProcess object is created which allows processing of
    # directives.
    #
    def initialize: (RDoc::TopLevel top_level, String filename, String content, Hash[untyped, untyped] options, RDoc::Stats stats) -> void

    def scan: () -> RDoc::TopLevel
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/markup.rb -->
  # RDoc::Markup parses plain text documents and attempts to decompose them into
  # their constituent parts.  Some of these parts are high-level: paragraphs,
  # chunks of verbatim text, list entries and the like.  Other parts happen at the
  # character level: a piece of bold text, a word in code font.  This markup is
  # similar in spirit to that used on WikiWiki webs, where folks create web pages
  # using a simple set of formatting rules.
  #
  # RDoc::Markup and other markup formats do no output formatting, this is handled
  # by the RDoc::Markup::Formatter subclasses.
  #
  # # Markup Formats
  #
  # `RDoc` supports these markup formats:
  #
  # *   `rdoc`: the `RDoc` markup format; see RDoc::MarkupReference.
  # *   `markdown`: The `markdown` markup format as described in the [Markdown
  #     Guide](https://www.markdownguide.org); see RDoc::Markdown.
  # *   `rd`: the `rd` markup format format; see RDoc::RD.
  # *   `tomdoc`: the TomDoc format as described in [TomDoc for
  #     Ruby](http://tomdoc.org); see RDoc::TomDoc.
  #
  # You can choose a markup format using the following methods:
  #
  # per project
  # :   If you build your documentation with rake use RDoc::Task#markup.
  #
  #     If you build your documentation by hand run:
  #
  #         rdoc --markup your_favorite_format --write-options
  #
  #     and commit `.rdoc_options` and ship it with your packaged gem.
  #
  # per file
  # :   At the top of the file use the `:markup:` directive to set the default
  #     format for the rest of the file.
  #
  # per comment
  # :   Use the `:markup:` directive at the top of a comment you want to write in
  #     a different format.
  #
  #
  # # RDoc::Markup
  #
  # RDoc::Markup is extensible at runtime: you can add new markup elements to be
  # recognized in the documents that RDoc::Markup parses.
  #
  # RDoc::Markup is intended to be the basis for a family of tools which share the
  # common requirement that simple, plain-text should be rendered in a variety of
  # different output formats and media.  It is envisaged that RDoc::Markup could
  # be the basis for formatting RDoc style comment blocks, Wiki entries, and
  # online FAQs.
  #
  # ## Synopsis
  #
  # This code converts `input_string` to HTML.  The conversion takes place in the
  # `convert` method, so you can use the same RDoc::Markup converter to convert
  # multiple input strings.
  #
  #     require 'rdoc'
  #
  #     h = RDoc::Markup::ToHtml.new(RDoc::Options.new)
  #
  #     puts h.convert(input_string)
  #
  # You can extend the RDoc::Markup parser to recognize new markup sequences, and
  # to add regexp handling. Here we make WikiWords significant to the parser, and
  # also make the sequences {word} and <no>text...</no> signify strike-through
  # text.  We then subclass the HTML output class to deal with these:
  #
  #     require 'rdoc'
  #
  #     class WikiHtml < RDoc::Markup::ToHtml
  #       def handle_regexp_WIKIWORD(target)
  #         "<font color=red>" + target.text + "</font>"
  #       end
  #     end
  #
  #     markup = RDoc::Markup.new
  #     markup.add_word_pair("{", "}", :STRIKE)
  #     markup.add_html("no", :STRIKE)
  #
  #     markup.add_regexp_handling(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)
  #
  #     wh = WikiHtml.new RDoc::Options.new, markup
  #     wh.add_tag(:STRIKE, "<strike>", "</strike>")
  #
  #     puts "<body>#{wh.convert ARGF.read}</body>"
  #
  # ## Encoding
  #
  # Where Encoding support is available, RDoc will automatically convert all
  # documents to the same output encoding.  The output encoding can be set via
  # RDoc::Options#encoding and defaults to Encoding.default_external.
  #
  # # RDoc Markup Reference
  #
  # See RDoc::MarkupReference.
  #
  class Markup
    class Document
      include Enumerable[Document]

      def each: () { (Document) -> void } -> void
              | () -> Enumerator[Document, void]

      def file: () -> String?

      def accept: (untyped) -> String
    end

    class ToMarkdown
    end
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/top_level.rb -->
  # A TopLevel context is a representation of the contents of a single file
  #
  class TopLevel < Context
    MARSHAL_VERSION: 0

    # <!-- rdoc-file=lib/rdoc/top_level.rb -->
    # Relative name of this file
    #
    attr_accessor relative_name: String

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - new(absolute_name, relative_name = absolute_name)
    # -->
    # Creates a new TopLevel for the file at `absolute_name`.  If documentation is
    # being generated outside the source dir `relative_name` is relative to the
    # source directory.
    #
    def initialize: (String absolute_name, ?String relative_name) -> void

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - ==(other)
    # -->
    # An RDoc::TopLevel is equal to another with the same relative_name
    #
    def ==: (untyped other) -> bool

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - eql?(other)
    # -->
    #
    alias eql? ==

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - add_alias(an_alias)
    # -->
    # Adds `an_alias` to `Object` instead of `self`.
    #
    def add_alias: (RDoc::Alias an_alias) -> RDoc::Alias

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - add_constant(constant)
    # -->
    # Adds `constant` to `Object` instead of `self`.
    #
    def add_constant: (RDoc::Constant constant) -> RDoc::Constant

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - add_include(include)
    # -->
    # Adds `include` to `Object` instead of `self`.
    #
    def add_include: (RDoc::Include `include`) -> RDoc::Include

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - add_method(method)
    # -->
    # Adds `method` to `Object` instead of `self`.
    #
    def add_method: (RDoc::AnyMethod method) -> RDoc::AnyMethod

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - find_class_or_module(name)
    # -->
    # See RDoc::TopLevel::find_class_or_module
    #
    def find_class_or_module: (::String name) -> RDoc::Context

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - find_module_named(name)
    # -->
    # Finds a module or class with `name`
    #
    def find_module_named: (String name) -> RDoc::Context

    # <!--
    #   rdoc-file=lib/rdoc/top_level.rb
    #   - full_name()
    # -->
    # Returns the relative name of this file
    #
    def full_name: () -> String

    def to_s: () -> ::String
  end
end
# <!-- rdoc-file=lib/rdoc.rb -->
# RDoc produces documentation for Ruby source files by parsing the source and
# extracting the definition for classes, modules, methods, includes and
# requires.  It associates these with optional documentation contained in an
# immediately preceding comment block then renders the result using an output
# formatter.
#
# For a simple introduction to writing or generating documentation using RDoc
# see the README.
#
# ## Roadmap
#
# If you think you found a bug in RDoc see CONTRIBUTING@Bugs
#
# If you want to use RDoc to create documentation for your Ruby source files,
# see RDoc::Markup and refer to `rdoc --help` for command line usage.
#
# If you want to set the default markup format see RDoc::Markup@Markup+Formats
#
# If you want to store rdoc configuration in your gem (such as the default
# markup format) see RDoc::Options@Saved+Options
#
# If you want to write documentation for Ruby files see RDoc::Parser::Ruby
#
# If you want to write documentation for extensions written in C see
# RDoc::Parser::C
#
# If you want to generate documentation using `rake` see RDoc::Task.
#
# If you want to drive RDoc programmatically, see RDoc::RDoc.
#
# If you want to use the library to format text blocks into HTML or other
# formats, look at RDoc::Markup.
#
# If you want to make an RDoc plugin such as a generator or directive handler
# see RDoc::RDoc.
#
# If you want to write your own output generator see RDoc::Generator.
#
# If you want an overview of how RDoc works see CONTRIBUTING
#
# ## Credits
#
# RDoc is currently being maintained by Eric Hodel <drbrain@segment7.net>.
#
# Dave Thomas <dave@pragmaticprogrammer.com> is the original author of RDoc.
#
# *   The Ruby parser in rdoc/parse.rb is based heavily on the outstanding work
#     of Keiju ISHITSUKA of Nippon Rational Inc, who produced the Ruby parser
#     for irb and the rtags package.
#
# <!-- rdoc-file=lib/rdoc/rubygems_hook.rb -->
# This class is referenced by RubyGems to create documents. All implementations
# are moved to the above RubyGemsHook.
#
# This class does nothing when this RDoc is installed as a normal gem or a
# bundled gem.
#
# This class does generate/remove documents for compatibility when this RDoc is
# installed as a default gem.
#
# We can remove this when all maintained RubyGems remove `rubygems/rdoc.rb`.
#
module RDoc
  # <!-- rdoc-file=lib/rdoc/token_stream.rb -->
  # A TokenStream is a list of tokens, gathered during the parse of some entity
  # (say a method). Entities populate these streams by being registered with the
  # lexer. Any class can collect tokens by including TokenStream. From the
  # outside, you use such an object by calling the start_collecting_tokens method,
  # followed by calls to add_token and pop_token.
  #
  module TokenStream
    # <!--
    #   rdoc-file=lib/rdoc/token_stream.rb
    #   - add_token(token)
    # -->
    # Adds one `token` to the collected tokens
    #
    def add_token: (Hash[untyped, untyped] token) -> void

    # <!--
    #   rdoc-file=lib/rdoc/token_stream.rb
    #   - collect_tokens()
    # -->
    # Starts collecting tokens
    #
    def collect_tokens: () -> void

    # <!--
    #   rdoc-file=lib/rdoc/token_stream.rb
    #   - start_collecting_tokens()
    # -->
    #
    alias start_collecting_tokens collect_tokens
  end

  # <!-- rdoc-file=lib/rdoc/class_module.rb -->
  # ClassModule is the base class for objects representing either a class or a
  # module.
  #
  class ClassModule < Context
    # <!--
    #   rdoc-file=lib/rdoc/class_module.rb
    #   - new(name, superclass = nil)
    # -->
    # Creates a new ClassModule with `name` with optional `superclass`
    #
    # This is a constructor for subclasses, and must never be called directly.
    #
    def initialize: (String name, ?String superclass) -> void

    # <!--
    #   rdoc-file=lib/rdoc/class_module.rb
    #   - add_comment(comment, location)
    # -->
    # Adds `comment` to this ClassModule's list of comments at `location`.  This
    # method is preferred over #comment= since it allows ri data to be updated
    # across multiple runs.
    #
    def add_comment: (RDoc::Comment comment, RDoc::Context location) -> void
  end

  # <!-- rdoc-file=lib/rdoc/normal_class.rb -->
  # A normal class, neither singleton nor anonymous
  #
  class NormalClass < ClassModule
    def initialize: (String name, ?String superclass) -> void
  end

  # <!-- rdoc-file=lib/rdoc/single_class.rb -->
  # A singleton class
  #
  class SingleClass < ClassModule
    def initialize: (String name, ?String superclass) -> void
  end

  # <!-- rdoc-file=lib/rdoc/normal_module.rb -->
  # A normal module, like NormalClass
  #
  class NormalModule < ClassModule
  end

  # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
  # Abstract class representing either a method or an attribute.
  #
  class MethodAttr < CodeObject
    include Comparable

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # The method/attribute we're aliasing
    #
    attr_reader is_alias_for: MethodAttr?

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # The call_seq or the param_seq with method name, if there is no call_seq.
    #
    attr_reader arglists: String

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # Name of this method/attribute.
    #
    attr_accessor name: String

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # public, protected, private
    #
    attr_accessor visibility: untyped

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # Is this a singleton method/attribute?
    #
    attr_accessor singleton: bool

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # Source file token stream
    #
    attr_reader text: String

    # <!-- rdoc-file=lib/rdoc/method_attr.rb -->
    # Different ways to call this method
    #
    attr_accessor call_seq: String

    # <!--
    #   rdoc-file=lib/rdoc/method_attr.rb
    #   - new(text, name)
    # -->
    # Creates a new MethodAttr from token stream `text` and method or attribute name
    # `name`.
    #
    # Usually this is called by super from a subclass.
    #
    def initialize: (String text, String name) -> void

    # <!--
    #   rdoc-file=lib/rdoc/method_attr.rb
    #   - pretty_name()
    # -->
    # Method/attribute name with class/instance indicator
    #
    def pretty_name: () -> ::String

    # <!--
    #   rdoc-file=lib/rdoc/method_attr.rb
    #   - type()
    # -->
    # Type of method/attribute (class or instance)
    #
    def type: () -> ("class" | "instance")

    # <!--
    #   rdoc-file=lib/rdoc/method_attr.rb
    #   - path()
    # -->
    # Path to this method for use with HTML generator output.
    #
    def path: () -> ::String

    def to_s: () -> ::String
  end

  # <!-- rdoc-file=lib/rdoc/any_method.rb -->
  # AnyMethod is the base class for objects representing methods
  #
  class AnyMethod < MethodAttr
    include TokenStream

    # <!--
    #   rdoc-file=lib/rdoc/any_method.rb
    #   - call_seq()
    # -->
    # Different ways to call this method
    # ----
    # <!--
    #   rdoc-file=lib/rdoc/any_method.rb
    #   - call_seq=(call_seq)
    # -->
    # Sets the different ways you can call this method.  If an empty `call_seq` is
    # given nil is assumed.
    #
    # See also #param_seq
    #
    attr_accessor call_seq: ::String

    # <!-- rdoc-file=lib/rdoc/any_method.rb -->
    # Parameters for this method
    #
    attr_accessor params: ::String

    attr_accessor line: Integer

    # <!--
    #   rdoc-file=lib/rdoc/any_method.rb
    #   - arglists()
    # -->
    # The call_seq or the param_seq with method name, if there is no call_seq.
    #
    # Use this for displaying a method's argument lists.
    #
    def arglists: () -> String?

    def callseq: () -> String?

    # <!--
    #   rdoc-file=lib/rdoc/any_method.rb
    #   - new(text, name)
    # -->
    # Creates a new AnyMethod with a token stream `text` and `name`
    #
    def initialize: (String? text, String name) -> void
  end

  # <!-- rdoc-file=lib/rdoc/attr.rb -->
  # An attribute created by #attr, #attr_reader, #attr_writer or #attr_accessor
  #
  class Attr < MethodAttr
    # <!-- rdoc-file=lib/rdoc/attr.rb -->
    # Is the attribute readable ('R'), writable ('W') or both ('RW')?
    #
    attr_accessor rw: "RW" | "R" | "W"

    # <!--
    #   rdoc-file=lib/rdoc/attr.rb
    #   - new(text, name, rw, comment, singleton = false)
    # -->
    # Creates a new Attr with body `text`, `name`, read/write status `rw` and
    # `comment`.  `singleton` marks this as a class attribute.
    #
    def initialize: (String? text, String name, String rw, RDoc::Comment? comment, ?bool `singleton`) -> void
  end

  # <!-- rdoc-file=lib/rdoc/constant.rb -->
  # A constant
  #
  class Constant < CodeObject
    # <!-- rdoc-file=lib/rdoc/constant.rb -->
    # Sets the module or class this is constant is an alias for.
    #
    attr_writer is_alias_for: String

    # <!-- rdoc-file=lib/rdoc/constant.rb -->
    # The constant's name
    #
    attr_accessor name: String

    # <!-- rdoc-file=lib/rdoc/constant.rb -->
    # The constant's value
    #
    attr_accessor value: String

    # <!-- rdoc-file=lib/rdoc/constant.rb -->
    # The constant's visibility
    #
    attr_accessor visibility: String

    # <!--
    #   rdoc-file=lib/rdoc/constant.rb
    #   - new(name, value, comment)
    # -->
    # Creates a new constant with `name`, `value` and `comment`
    #
    def initialize: (String name, String value, RDoc::Comment? comment) -> void
  end

  # <!-- rdoc-file=lib/rdoc/mixin.rb -->
  # A Mixin adds features from a module into another context.  RDoc::Include and
  # RDoc::Extend are both mixins.
  #
  class Mixin < CodeObject
    # <!-- rdoc-file=lib/rdoc/mixin.rb -->
    # Name of included module
    #
    attr_accessor name: String

    # <!--
    #   rdoc-file=lib/rdoc/mixin.rb
    #   - new(name, comment)
    # -->
    # Creates a new Mixin for `name` with `comment`
    #
    def initialize: (String name, RDoc::Comment? comment) -> void
  end

  # <!-- rdoc-file=lib/rdoc/include.rb -->
  # A Module included in a class with #include
  #
  #     RDoc::Include.new 'Enumerable', 'comment ...'
  #
  class Include < Mixin
  end

  # <!-- rdoc-file=lib/rdoc/extend.rb -->
  # A Module extension to a class with #extend
  #
  #     RDoc::Extend.new 'Enumerable', 'comment ...'
  #
  class Extend < Mixin
  end

  # <!-- rdoc-file=lib/rdoc/alias.rb -->
  # Represent an alias, which is an old_name/new_name pair associated with a
  # particular context
  #
  class Alias < CodeObject
    # <!-- rdoc-file=lib/rdoc/alias.rb -->
    # Aliased method's name
    #
    attr_accessor name: String

    # <!-- rdoc-file=lib/rdoc/alias.rb -->
    # Aliasee method's name
    #
    attr_accessor old_name: String

    # <!--
    #   rdoc-file=lib/rdoc/alias.rb
    #   - new(text, old_name, new_name, comment, singleton = false)
    # -->
    # Creates a new Alias with a token stream of `text` that aliases `old_name` to
    # `new_name`, has `comment` and is a `singleton` context.
    #
    def initialize: (String? text, String name, String old_name, RDoc::Comment? comment, ?bool `singleton`) -> void
  end

  # <!-- rdoc-file=lib/rdoc/stats.rb -->
  # RDoc statistics collector which prints a summary and report of a project's
  # documentation totals.
  #
  class Stats
  end
end
%a{annotate:rdoc:skip}
module RDoc
  # <!-- rdoc-file=lib/rdoc/context.rb -->
  # A Context is something that can hold modules, classes, methods, attributes,
  # aliases, requires, and includes. Classes, modules, and files are all Contexts.
  #
  class Context < CodeObject
    include Comparable

    # <!-- rdoc-file=lib/rdoc/context.rb -->
    # Types of methods
    #
    TYPES: ::Array["class" | "instance"]

    TOMDOC_TITLES: ::Array[nil | "Public" | "Internal" | "Deprecated"]

    type class_types = singleton(RDoc::NormalClass) | singleton(RDoc::SingleClass)

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - new()
    # -->
    # Creates an unnamed empty context with public current visibility
    #
    def initialize: () -> void

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_alias(an_alias)
    # -->
    # Adds `an_alias` that is automatically resolved
    #
    def add_alias: (RDoc::Alias an_alias) -> RDoc::Alias

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_attribute(attribute)
    # -->
    # Adds `attribute` if not already there. If it is (as method(s) or attribute),
    # updates the comment if it was empty.
    #
    # The attribute is registered only if it defines a new method. For instance,
    # `attr_reader :foo` will not be registered if method `foo` exists, but
    # `attr_accessor :foo` will be registered if method `foo` exists, but `foo=`
    # does not.
    #
    def add_attribute: (RDoc::Attr attribute) -> RDoc::Attr

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_class(class_type, given_name, superclass = '::Object')
    # -->
    # Adds a class named `given_name` with `superclass`.
    #
    # Both `given_name` and `superclass` may contain '::', and are interpreted
    # relative to the `self` context. This allows handling correctly examples like
    # these:
    #     class RDoc::Gauntlet < Gauntlet
    #     module Mod
    #       class Object   # implies < ::Object
    #       class SubObject < Object  # this is _not_ ::Object
    #
    # Given `class Container::Item` RDoc assumes `Container` is a module unless it
    # later sees `class Container`.  `add_class` automatically upgrades `given_name`
    # to a class in this case.
    #
    def add_class: (class_types class_type, ::String given_name, ?::String superclass) -> (RDoc::NormalClass | RDoc::SingleClass)

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_constant(constant)
    # -->
    # Adds `constant` if not already there. If it is, updates the comment, value
    # and/or is_alias_for of the known constant if they were empty/nil.
    #
    def add_constant: (RDoc::Constant constant) -> RDoc::Constant

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_include(include)
    # -->
    # Adds included module `include` which should be an RDoc::Include
    #
    def add_include: (RDoc::Include `include`) -> RDoc::Include

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_extend(ext)
    # -->
    # Adds extension module `ext` which should be an RDoc::Extend
    #
    def add_extend: (RDoc::Extend ext) -> RDoc::Extend

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_method(method)
    # -->
    # Adds `method` if not already there. If it is (as method or attribute), updates
    # the comment if it was empty.
    #
    def add_method: (RDoc::AnyMethod method) -> RDoc::AnyMethod

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - add_module(class_type, name)
    # -->
    # Adds a module named `name`.  If RDoc already knows `name` is a class then that
    # class is returned instead.  See also #add_class.
    #
    def add_module: (singleton(RDoc::NormalModule) class_type, String name) -> RDoc::NormalModule

    # <!-- rdoc-file=lib/rdoc/context.rb -->
    # All attr* methods
    #
    def attributes: () -> Array[Attr]

    # <!-- rdoc-file=lib/rdoc/context.rb -->
    # Constants defined
    #
    def constants: () -> Array[Constant]

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - find_module_named(name)
    # -->
    # Find a module with `name` using ruby's scoping rules
    #
    def find_module_named: (untyped name) -> (untyped | self)

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - full_name()
    # -->
    # The full name for this context.  This method is overridden by subclasses.
    #
    def full_name: () -> "(unknown)"

    # <!-- rdoc-file=lib/rdoc/context.rb -->
    # Methods defined in this context
    #
    def method_list: () -> Array[AnyMethod]

    def to_s: () -> ::String

    # <!--
    #   rdoc-file=lib/rdoc/context.rb
    #   - top_level()
    # -->
    # Return the TopLevel that owns us
    #
    def top_level: () -> RDoc::TopLevel
  end
end
# <!-- rdoc-file=lib/resolv.rb -->
# Resolv is a thread-aware DNS resolver library written in Ruby.  Resolv can
# handle multiple DNS requests concurrently without blocking the entire Ruby
# interpreter.
#
# See also resolv-replace.rb to replace the libc resolver with Resolv.
#
# Resolv can look up various DNS resources using the DNS module directly.
#
# Examples:
#
#     p Resolv.getaddress "www.ruby-lang.org"
#     p Resolv.getname "210.251.121.214"
#
#     Resolv::DNS.open do |dns|
#       ress = dns.getresources "www.ruby-lang.org", Resolv::DNS::Resource::IN::A
#       p ress.map(&:address)
#       ress = dns.getresources "ruby-lang.org", Resolv::DNS::Resource::IN::MX
#       p ress.map { |r| [r.exchange.to_s, r.preference] }
#     end
#
# ## Bugs
#
# *   NIS is not supported.
# *   /etc/nsswitch.conf is not supported.
#
%a{annotate:rdoc:source:from=lib/resolv.rb}
class Resolv
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name, &block)
  # -->
  # Iterates over all IP addresses for `name`.
  #
  def self.each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address, &proc)
  # -->
  # Iterates over all hostnames for `address`.
  #
  def self.each_name: (String address) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Looks up the first IP address for `name`.
  #
  def self.getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Looks up all IP address for `name`.
  #
  def self.getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Looks up the hostname of `address`.
  #
  def self.getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Looks up all hostnames for `address`.
  #
  def self.getnames: (String address) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name) { |name| ... }
  # -->
  # Iterates over all IP addresses for `name`.
  #
  def each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address) { |name| ... }
  # -->
  # Iterates over all hostnames for `address`.
  #
  def each_name: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Looks up the first IP address for `name`.
  #
  def getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Looks up all IP address for `name`.
  #
  def getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Looks up the hostname of `address`.
  #
  def getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Looks up all hostnames for `address`.
  #
  def getnames: (String address) -> Array[String]

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(resolvers=(arg_not_set = true; nil), use_ipv6: (keyword_not_set = true; nil))
  # -->
  # Creates a new Resolv using `resolvers`.
  #
  # If `resolvers` is not given, a hash, or `nil`, uses a Hosts resolver and and a
  # DNS resolver.  If `resolvers` is a hash, uses the hash as configuration for
  # the DNS resolver.
  #
  def initialize: (?Resolv::Hosts | Resolv::DNS resolvers) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Address Regexp to use for matching IP addresses.
#
Resolv::AddressRegex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Default resolver to use for Resolv class methods.
#
Resolv::DefaultResolver: Resolv

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::DNS is a DNS stub resolver.
#
# Information taken from the following places:
#
# *   STD0013
# *   RFC 1035
# *   ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters
# *   etc.
#
class Resolv::DNS
  type ip_address = Resolv::IPv4 | Resolv::IPv6

  type dns_name = Name | String

  def self.allocate_request_id: (String host, Integer port) -> Integer

  def self.bind_random_port: (UDPSocket udpsock, ?String bind_host) -> void

  def self.free_request_id: (String host, Integer port, Integer id) -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - open(*args) { |dns| ... }
  # -->
  # Creates a new DNS resolver.  See Resolv::DNS.new for argument details.
  #
  # Yields the created DNS resolver to the block, if given, otherwise returns it.
  #
  def self.open: (*untyped args) -> instance
               | (*untyped args) { (instance) -> void } -> void

  def self.random: (Integer arg) -> (Integer | Float)

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - close()
  # -->
  # Closes the DNS resolver.
  #
  def close: () -> untyped

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name) { |address| ... }
  # -->
  # Iterates over all IP addresses for `name` retrieved from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def each_address: (dns_name name) { (ip_address) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address) { |name| ... }
  # -->
  # Iterates over all hostnames for `address` retrieved from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
  # will be Resolv::DNS::Name instances.
  #
  def each_name: (ip_address | dns_name address) { (Resolv::DNS::Name) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_resource(name, typeclass, &proc)
  # -->
  # Iterates over all `typeclass` DNS resources for `name`.  See #getresource for
  # argument details.
  #
  def each_resource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  def extract_resources: (Resolv::DNS::Message msg, dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - fetch_resource(name, typeclass) { |reply, reply_name| ... }
  # -->
  #
  def fetch_resource: (Resolv::DNS::Name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Message, Resolv::DNS::Name) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Gets the IP address of `name` from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved address will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def getaddress: (dns_name name) -> ip_address

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Gets all IP addresses for `name` from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def getaddresses: (dns_name name) -> Array[ip_address]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Gets the hostname for `address` from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved name
  # will be a Resolv::DNS::Name.
  #
  def getname: (ip_address | dns_name address) -> Resolv::DNS::Name

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Gets all hostnames for `address` from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
  # will be Resolv::DNS::Name instances.
  #
  def getnames: (ip_address | dns_name address) -> Array[Resolv::DNS::Name]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getresource(name, typeclass)
  # -->
  # Look up the `typeclass` DNS resource of `name`.
  #
  # `name` must be a Resolv::DNS::Name or a String.
  #
  # `typeclass` should be one of the following:
  #
  # *   Resolv::DNS::Resource::IN::A
  # *   Resolv::DNS::Resource::IN::AAAA
  # *   Resolv::DNS::Resource::IN::ANY
  # *   Resolv::DNS::Resource::IN::CNAME
  # *   Resolv::DNS::Resource::IN::HINFO
  # *   Resolv::DNS::Resource::IN::MINFO
  # *   Resolv::DNS::Resource::IN::MX
  # *   Resolv::DNS::Resource::IN::NS
  # *   Resolv::DNS::Resource::IN::PTR
  # *   Resolv::DNS::Resource::IN::SOA
  # *   Resolv::DNS::Resource::IN::TXT
  # *   Resolv::DNS::Resource::IN::WKS
  #
  # Returned resource is represented as a Resolv::DNS::Resource instance, i.e.
  # Resolv::DNS::Resource::IN::A.
  #
  def getresource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Resolv::DNS::Resource

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getresources(name, typeclass)
  # -->
  # Looks up all `typeclass` DNS resources for `name`.  See #getresource for
  # argument details.
  #
  def getresources: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Array[Resolv::DNS::Resource]

  def lazy_initialize: () -> untyped

  def make_tcp_requester: (String host, Integer port) -> Requester::TCP

  def make_udp_requester: () -> (Requester::ConnectedUDP | Requester::UnconnectedUDP)

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - timeouts=(values)
  # -->
  # Sets the resolver timeouts.  This may be a single positive number or an array
  # of positive numbers representing timeouts in seconds. If an array is
  # specified, a DNS request will retry and wait for each successive interval in
  # the array until a successful response is received.  Specifying `nil` reverts
  # to the default timeouts:
  # 5, second = 5 * 2 / nameserver_count, 2 * second, 4 * second
  # :   Example:
  #
  #         dns.timeouts = 3
  #
  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(config_info=nil)
  # -->
  # Creates a new DNS resolver.
  #
  # `config_info` can be:
  #
  # nil
  # :   Uses /etc/resolv.conf.
  #
  # String
  # :   Path to a file using /etc/resolv.conf's format.
  #
  # Hash
  # :   Must contain :nameserver, :search and :ndots keys.
  #
  # :nameserver_port can be used to specify port number of nameserver address.
  # :raise_timeout_errors can be used to raise timeout errors as exceptions
  # instead of treating the same as an NXDOMAIN response.
  #
  # The value of :nameserver should be an address string or an array of address
  # strings.
  # *   :nameserver => '8.8.8.8'
  # *   :nameserver => ['8.8.8.8', '8.8.4.4']
  #
  # The value of :nameserver_port should be an array of pair of nameserver address
  # and port number.
  # *   :nameserver_port => [['8.8.8.8', 53], ['8.8.4.4', 53]]
  #
  # Example:
  #
  #     Resolv::DNS.new(:nameserver => ['210.251.121.21'],
  #                     :search => ['ruby-lang.org'],
  #                     :ndots => 1)
  #
  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped

  def use_ipv6?: () -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Default DNS Port
#
Resolv::DNS::Port: Integer

Resolv::DNS::RequestID: Hash[untyped, untyped]

Resolv::DNS::RequestIDMutex: Thread::Mutex

# <!-- rdoc-file=lib/resolv.rb -->
# Default DNS UDP packet size
#
Resolv::DNS::UDPSize: Integer

class Resolv::DNS::Config
  def self.default_config_hash: (?String filename) -> Hash[Symbol, untyped]

  def self.parse_resolv_conf: (String filename) -> Hash[Symbol, untyped]

  def generate_candidates: (String name) -> Array[Resolv::DNS::Name]

  def generate_timeouts: () -> Array[Integer | Float]

  def lazy_initialize: () -> void

  def nameserver_port: () -> Array[[ String, Integer ]]

  def resolv: (String name) { (Resolv::DNS::Name, Integer, String, Integer) -> void } -> void

  def single?: () -> [ String, Integer ]?

  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

Resolv::DNS::Config::InitialTimeout: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates no such domain was found.
#
class Resolv::DNS::Config::NXDomain < Resolv::ResolvError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates some other unhandled resolver error was encountered.
#
class Resolv::DNS::Config::OtherResolvError < Resolv::ResolvError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates that the DNS response was unable to be decoded.
#
class Resolv::DNS::DecodeError < StandardError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates that the DNS request was unable to be encoded.
#
class Resolv::DNS::EncodeError < StandardError
end

module Resolv::DNS::Label
  def self.split: (untyped arg) -> untyped
end

class Resolv::DNS::Label::Str
  def eql?: (Resolv::DNS::Label::Str other) -> bool

  def downcase: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def string: () -> String

  def to_s: () -> String

  private

  def initialize: (String string) -> untyped
end

class Resolv::DNS::Message
  def self.decode: (String m) -> instance

  def ==: (instance other) -> bool

  def aa: () -> Integer

  def aa=: (Integer) -> void

  def add_additional: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_answer: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_authority: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_question: (String name, singleton(Resolv::DNS::Query) typeclass) -> void

  def additional: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def answer: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def authority: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def each_additional: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_answer: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_authority: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_question: () { (Resolv::DNS::Name, singleton(Resolv::DNS::Query)) -> void } -> void

  def each_resource: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def encode: () -> String

  def id: () -> Integer

  def id=: (Integer) -> void

  def opcode: () -> Integer

  def opcode=: (Integer) -> void

  def qr: () -> Integer

  def qr=: (Integer) -> void

  def question: () -> Array[[ Resolv::DNS::Name, singleton(Resolv::DNS::Resource) ]]

  def ra: () -> Integer

  def ra=: (Integer) -> void

  def rcode: () -> Integer

  def rcode=: (Integer) -> void

  def rd: () -> Integer

  def rd=: (Integer) -> void

  def tc: () -> Integer

  def tc=: (Integer) -> void

  private

  def initialize: (?Integer id) -> untyped
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes: (?Integer len) -> String

  def get_label: () -> Resolv::DNS::Label::Str

  def get_labels: () -> Array[Resolv::DNS::Label::Str]

  def get_length16: () { (Integer) -> Integer } -> Integer

  def get_name: () -> Resolv::DNS::Name

  def get_question: () -> Resolv::DNS::Query

  def get_rr: () -> [ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]

  def get_string: () -> String

  def get_string_list: () -> Array[String]

  def get_unpack: (String template) -> Array[untyped]

  def inspect: () -> String

  private

  def initialize: (String data) { (instance) -> void } -> untyped
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes: (string d) -> void

  def put_label: (_ToS d) -> void

  def put_labels: (Array[_ToS] d) -> void

  def put_length16: () { () -> void } -> void

  def put_name: (Resolv::DNS::Name d) -> void

  def put_pack: (String template, *untyped d) -> void

  def put_string: (String d) -> void

  def put_string_list: (_Each[String] ds) -> void

  def to_s: () -> untyped

  private

  def initialize: () -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A representation of a DNS name.
#
class Resolv::DNS::Name
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new DNS name from `arg`.  `arg` can be:
  #
  # Name
  # :   returns `arg`.
  #
  # String
  # :   Creates a new Name.
  #
  def self.create: (Resolv::DNS::dns_name arg) -> untyped

  def ==: (instance other) -> bool

  def []: (Integer i) -> Resolv::DNS::Label::Str?

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - absolute?()
  # -->
  # True if this name is absolute.
  #
  def absolute?: () -> bool

  alias eql? ==

  def hash: () -> Integer

  def inspect: () -> String

  def length: () -> Integer

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - subdomain_of?(other)
  # -->
  # Returns true if `other` is a subdomain.
  #
  # Example:
  #
  #     domain = Resolv::DNS::Name.create("y.z")
  #     p Resolv::DNS::Name.create("w.x.y.z").subdomain_of?(domain) #=> true
  #     p Resolv::DNS::Name.create("x.y.z").subdomain_of?(domain) #=> true
  #     p Resolv::DNS::Name.create("y.z").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("z").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("x.y.z.").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("w.z").subdomain_of?(domain) #=> false
  #
  def subdomain_of?: (instance other) -> bool

  def to_a: () -> Array[Resolv::DNS::Label::Str]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_s()
  # -->
  # returns the domain name as a string.
  #
  # The domain name doesn't have a trailing dot even if the name object is
  # absolute.
  #
  # Example:
  #
  #     p Resolv::DNS::Name.create("x.y.z.").to_s #=> "x.y.z"
  #     p Resolv::DNS::Name.create("x.y.z").to_s #=> "x.y.z"
  #
  def to_s: () -> untyped

  private

  def initialize: (Array[Resolv::DNS::Label::Str] labels, ?bool absolute) -> untyped
end

module Resolv::DNS::OpCode
end

Resolv::DNS::OpCode::IQuery: Integer

Resolv::DNS::OpCode::Notify: Integer

Resolv::DNS::OpCode::Query: Integer

Resolv::DNS::OpCode::Status: Integer

Resolv::DNS::OpCode::Update: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# A DNS query abstract class.
#
class Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void
end

module Resolv::DNS::RCode
end

Resolv::DNS::RCode::BADALG: Integer

Resolv::DNS::RCode::BADKEY: Integer

Resolv::DNS::RCode::BADMODE: Integer

Resolv::DNS::RCode::BADNAME: Integer

Resolv::DNS::RCode::BADSIG: Integer

Resolv::DNS::RCode::BADTIME: Integer

Resolv::DNS::RCode::BADVERS: Integer

Resolv::DNS::RCode::FormErr: Integer

Resolv::DNS::RCode::NXDomain: Integer

Resolv::DNS::RCode::NXRRSet: Integer

Resolv::DNS::RCode::NoError: Integer

Resolv::DNS::RCode::NotAuth: Integer

Resolv::DNS::RCode::NotImp: Integer

Resolv::DNS::RCode::NotZone: Integer

Resolv::DNS::RCode::Refused: Integer

Resolv::DNS::RCode::ServFail: Integer

Resolv::DNS::RCode::YXDomain: Integer

Resolv::DNS::RCode::YXRRSet: Integer

class Resolv::DNS::Requester
  def close: () -> void

  def request: (Resolv::DNS::Requester::Sender sender, Numeric tout) -> [ Resolv::DNS::Message, String ]

  def sender_for: (String addr, Resolv::DNS::Message msg) -> Resolv::DNS::Requester::Sender

  private

  def initialize: () -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP < Resolv::DNS::Requester
  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::MDNSOneShot < Resolv::DNS::Requester::UnconnectedUDP
  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a problem with the DNS request.
#
class Resolv::DNS::Requester::RequestError < StandardError
end

class Resolv::DNS::Requester::Sender
  private

  def initialize: (Resolv::DNS::Message msg, String data, Socket sock) -> untyped
end

class Resolv::DNS::Requester::TCP < Resolv::DNS::Requester
  def close: () -> untyped

  def recv_reply: (Array[TCPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::TCP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::UnconnectedUDP < Resolv::DNS::Requester
  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (*[ String, Integer ] nameserver_port) -> untyped
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void

  private

  def initialize: (Resolv::DNS::Message msg, String data, UDPSocket sock, String host, Integer port) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A DNS resource abstract class.
#
class Resolv::DNS::Resource < Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def self.get_class: (Integer type_value, Integer class_value) -> self

  def eql?: (Resolv::DNS::Resource other) -> bool

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  alias == eql?

  def hash: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Remaining Time To Live for this Resource.
  #
  def ttl: () -> Integer
end

Resolv::DNS::Resource::ClassHash: Hash[[ Integer, Integer ], singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassInsensitiveTypes: Array[singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassValue: Integer?

# <!-- rdoc-file=lib/resolv.rb -->
# A Query type requesting any RR.
#
class Resolv::DNS::Resource::ANY < Resolv::DNS::Query
end

Resolv::DNS::Resource::ANY::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# The canonical name for an alias.
#
class Resolv::DNS::Resource::CNAME < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::CNAME::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Domain Name resource abstract class.
#
class Resolv::DNS::Resource::DomainName < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The name of this DomainName.
  #
  def name: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(name)
  # -->
  # Creates a new DomainName from `name`.
  #
  def initialize: (String name) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A generic resource abstract class.
#
class Resolv::DNS::Resource::Generic < Resolv::DNS::Resource
  def self.create: (Integer type_value, Integer class_value) -> Class

  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # Data for this generic resource.
  #
  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(data)
  # -->
  # Creates a new generic resource.
  #
  def initialize: (String data) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Host Information resource.
#
class Resolv::DNS::Resource::HINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # CPU architecture for this resource.
  #
  def cpu: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Operating system for this resource.
  #
  def os: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(cpu, os)
  # -->
  # Creates a new HINFO running `os` on `cpu`.
  #
  def initialize: (String cpu, String os) -> untyped
end

Resolv::DNS::Resource::HINFO::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# module IN contains ARPA Internet specific RRs.
#
module Resolv::DNS::Resource::IN
end

Resolv::DNS::Resource::IN::ClassValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# IPv4 Address resource
#
class Resolv::DNS::Resource::IN::A < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # The Resolv::IPv4 address for this A.
  #
  def address: () -> Resolv::IPv4

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address)
  # -->
  # Creates a new A for `address`.
  #
  def initialize: (String | Resolv::IPv4 address) -> untyped
end

Resolv::DNS::Resource::IN::A::ClassValue: Integer

Resolv::DNS::Resource::IN::A::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# An IPv6 address record.
#
class Resolv::DNS::Resource::IN::AAAA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # The Resolv::IPv6 address for this AAAA.
  #
  def address: () -> Resolv::IPv6

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address)
  # -->
  # Creates a new AAAA for `address`.
  #
  def initialize: (String | Resolv::IPv6 address) -> untyped
end

Resolv::DNS::Resource::IN::AAAA::ClassValue: Integer

Resolv::DNS::Resource::IN::AAAA::TypeValue: Integer

class Resolv::DNS::Resource::IN::ANY < Resolv::DNS::Resource::ANY
end

Resolv::DNS::Resource::IN::ANY::ClassValue: Integer

Resolv::DNS::Resource::IN::ANY::TypeValue: Integer

class Resolv::DNS::Resource::IN::CNAME < Resolv::DNS::Resource::CNAME
end

Resolv::DNS::Resource::IN::CNAME::ClassValue: Integer

Resolv::DNS::Resource::IN::CNAME::TypeValue: Integer

class Resolv::DNS::Resource::IN::HINFO < Resolv::DNS::Resource::HINFO
end

Resolv::DNS::Resource::IN::HINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::HINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::LOC < Resolv::DNS::Resource::LOC
end

Resolv::DNS::Resource::IN::LOC::ClassValue: Integer

Resolv::DNS::Resource::IN::LOC::TypeValue: Integer

class Resolv::DNS::Resource::IN::MINFO < Resolv::DNS::Resource::MINFO
end

Resolv::DNS::Resource::IN::MINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::MINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::MX < Resolv::DNS::Resource::MX
end

Resolv::DNS::Resource::IN::MX::ClassValue: Integer

Resolv::DNS::Resource::IN::MX::TypeValue: Integer

class Resolv::DNS::Resource::IN::NS < Resolv::DNS::Resource::NS
end

Resolv::DNS::Resource::IN::NS::ClassValue: Integer

Resolv::DNS::Resource::IN::NS::TypeValue: Integer

class Resolv::DNS::Resource::IN::PTR < Resolv::DNS::Resource::PTR
end

Resolv::DNS::Resource::IN::PTR::ClassValue: Integer

Resolv::DNS::Resource::IN::PTR::TypeValue: Integer

class Resolv::DNS::Resource::IN::SOA < Resolv::DNS::Resource::SOA
end

Resolv::DNS::Resource::IN::SOA::ClassValue: Integer

Resolv::DNS::Resource::IN::SOA::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# SRV resource record defined in RFC 2782
#
# These records identify the hostname and port that a service is available at.
#
class Resolv::DNS::Resource::IN::SRV < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The port on this target host of this service.
  #
  # The range is 0-65535.
  #
  def port: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The priority of this target host.
  #
  # A client MUST attempt to contact the target host with the lowest-numbered
  # priority it can reach; target hosts with the same priority SHOULD be tried in
  # an order defined by the weight field. The range is 0-65535.  Note that it is
  # not widely implemented and should be set to zero.
  #
  def priority: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The domain name of the target host.
  #
  # A target of "." means that the service is decidedly not available at this
  # domain.
  #
  def target: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # A server selection mechanism.
  #
  # The weight field specifies a relative weight for entries with the same
  # priority. Larger weights SHOULD be given a proportionately higher probability
  # of being selected. The range of this number is 0-65535.  Domain administrators
  # SHOULD use Weight 0 when there isn't any server selection to do, to make the
  # RR easier to read for humans (less noisy). Note that it is not widely
  # implemented and should be set to zero.
  #
  def weight: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(priority, weight, port, target)
  # -->
  # Create a SRV resource record.
  #
  # See the documentation for #priority, #weight, #port and #target for
  # `priority`, `weight`, +port and `target` respectively.
  #
  def initialize: (Integer priority, Integer weight, Integer port, String target) -> untyped
end

Resolv::DNS::Resource::IN::SRV::ClassValue: Integer

Resolv::DNS::Resource::IN::SRV::TypeValue: Integer

class Resolv::DNS::Resource::IN::TXT < Resolv::DNS::Resource::TXT
end

Resolv::DNS::Resource::IN::TXT::ClassValue: Integer

Resolv::DNS::Resource::IN::TXT::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Well Known Service resource.
#
class Resolv::DNS::Resource::IN::WKS < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # The host these services run on.
  #
  def address: () -> Resolv::IPv4

  # <!-- rdoc-file=lib/resolv.rb -->
  # A bit map of enabled services on this host.
  #
  # If protocol is 6 (TCP) then the 26th bit corresponds to the SMTP service (port
  # 25).  If this bit is set, then an SMTP server should be listening on TCP port
  # 25; if zero, SMTP service is not supported.
  #
  def bitmap: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # IP protocol number for these services.
  #
  def protocol: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address, protocol, bitmap)
  # -->
  #
  def initialize: (String | Resolv::IPv4 address, Integer protocol, Integer bitmap) -> untyped
end

Resolv::DNS::Resource::IN::WKS::ClassValue: Integer

Resolv::DNS::Resource::IN::WKS::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Location resource
#
class Resolv::DNS::Resource::LOC < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # The altitude of the LOC above a reference sphere whose surface sits 100km
  # below the WGS84 spheroid in centimeters as an unsigned 32bit integer
  #
  def altitude: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The horizontal precision using ssize type values in meters using scientific
  # notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m
  #
  def hprecision: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The latitude for this LOC where 2**31 is the equator in thousandths of an arc
  # second as an unsigned 32bit integer
  #
  def latitude: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The longitude for this LOC where 2**31 is the prime meridian in thousandths of
  # an arc second as an unsigned 32bit integer
  #
  def longitude: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The spherical size of this LOC in meters using scientific notation as 2
  # integers of XeY
  #
  def ssize: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Returns the version value for this LOC record which should always be 00
  #
  def version: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The vertical precision using ssize type values in meters using scientific
  # notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m
  #
  def vprecision: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(version, ssize, hprecision, vprecision, latitude, longitude, altitude)
  # -->
  #
  def initialize: (Integer version, Integer ssize, Integer hprecision, Integer vprecision, Integer latitude, Integer longitude, Integer altitude) -> untyped
end

Resolv::DNS::Resource::LOC::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Mailing list or mailbox information.
#
class Resolv::DNS::Resource::MINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!-- rdoc-file=lib/resolv.rb -->
  # Mailbox to use for error messages related to the mail list or mailbox.
  #
  def emailbx: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Domain name responsible for this mail list or mailbox.
  #
  def rmailbx: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(rmailbx, emailbx)
  # -->
  #
  def initialize: (String rmailbx, String emailbx) -> untyped
end

Resolv::DNS::Resource::MINFO::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Mail Exchanger resource.
#
class Resolv::DNS::Resource::MX < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The host of this MX.
  #
  def exchange: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The preference for this MX.
  #
  def preference: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(preference, exchange)
  # -->
  # Creates a new MX record with `preference`, accepting mail at `exchange`.
  #
  def initialize: (Integer preference, String exchange) -> untyped
end

Resolv::DNS::Resource::MX::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# An authoritative name server.
#
class Resolv::DNS::Resource::NS < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::NS::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# A Pointer to another DNS name.
#
class Resolv::DNS::Resource::PTR < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::PTR::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Start Of Authority resource.
#
class Resolv::DNS::Resource::SOA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Time in seconds that a secondary name server is to use the data before
  # refreshing from the primary name server.
  #
  def expire: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The minimum number of seconds to be used for TTL values in RRs.
  #
  def minimum: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Name of the host where the master zone file for this zone resides.
  #
  def mname: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # How often, in seconds, a secondary name server is to check for updates from
  # the primary name server.
  #
  def refresh: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # How often, in seconds, a secondary name server is to retry after a failure to
  # check for a refresh.
  #
  def retry: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The person responsible for this domain name.
  #
  def rname: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The version number of the zone file.
  #
  def serial: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(mname, rname, serial, refresh, retry_, expire, minimum)
  # -->
  # Creates a new SOA record.  See the attr documentation for the details of each
  # argument.
  #
  def initialize: (String mname, String rname, Integer serial, Integer refresh, Integer retry_, Integer expire, Integer minimum) -> untyped
end

Resolv::DNS::Resource::SOA::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Unstructured text resource.
#
class Resolv::DNS::Resource::TXT < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - data()
  # -->
  # Returns the concatenated string from `strings`.
  #
  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Returns an Array of Strings for this TXT record.
  #
  def strings: () -> Array[String]

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(first_string, *rest_strings)
  # -->
  #
  def initialize: (String first_string, *String rest_strings) -> untyped
end

Resolv::DNS::Resource::TXT::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::Hosts is a hostname resolver that uses the system hosts file.
#
class Resolv::Hosts
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name, &proc)
  # -->
  # Iterates over all IP addresses for `name` retrieved from the hosts file.
  #
  def each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address, &proc)
  # -->
  # Iterates over all hostnames for `address` retrieved from the hosts file.
  #
  def each_name: (String address) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Gets the IP address of `name` from the hosts file.
  #
  def getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Gets all IP addresses for `name` from the hosts file.
  #
  def getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Gets the hostname of `address` from the hosts file.
  #
  def getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Gets all hostnames for `address` from the hosts file.
  #
  def getnames: (String address) -> Array[String]

  def lazy_initialize: () -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(filename = DefaultFileName)
  # -->
  # Creates a new Resolv::Hosts, using `filename` for its data source.
  #
  def initialize: (?String filename) -> untyped
end

Resolv::Hosts::DefaultFileName: String

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::DNS IPv4 address.
#
class Resolv::IPv4
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  #
  def self.create: (String | instance arg) -> instance

  def ==: (instance other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw IPv4 address as a String.
  #
  def address: () -> String

  def eql?: (instance other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_name()
  # -->
  # Turns this IPv4 address into a Resolv::DNS::Name.
  #
  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (String address) -> untyped
end

Resolv::IPv4::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Regular expression IPv4 addresses must match.
#
Resolv::IPv4::Regex256: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::DNS IPv6 address.
#
class Resolv::IPv6
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new IPv6 address from `arg` which may be:
  #
  # IPv6
  # :   returns `arg`.
  #
  # String
  # :   `arg` must match one of the IPv6::Regex* constants
  #
  def self.create: (String | instance arg) -> instance

  def ==: (instance other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw IPv6 address as a String.
  #
  def address: () -> String

  def eql?: (instance other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_name()
  # -->
  # Turns this IPv6 address into a Resolv::DNS::Name.
  #
  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (untyped address) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A composite IPv6 address Regexp.
#
Resolv::IPv6::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv4 mapped IPv6 address format a:b:c:d:e:f:w.x.y.z
#
Resolv::IPv6::Regex_6Hex4Dec: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv6 address format a:b:c:d:e:f:g:h
#
Resolv::IPv6::Regex_8Hex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv6 link local address format fe80:b:c:d:e:f:g:h%em1
#
Resolv::IPv6::Regex_8HexLinkLocal: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv6 address format a::b
#
Resolv::IPv6::Regex_CompressedHex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv4 mapped IPv6 address format a::b:w.x.y.z
#
Resolv::IPv6::Regex_CompressedHex4Dec: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv6 link local address format fe80::b%em1
#
Resolv::IPv6::Regex_CompressedHexLinkLocal: Regexp

module Resolv::LOC
end

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Alt
#
class Resolv::LOC::Alt
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Alt from `arg` which may be:
  #
  # LOC::Alt
  # :   returns `arg`.
  #
  # String
  # :   `arg` must match the LOC::Alt::Regex constant
  #
  def self.create: (Resolv::LOC::Alt | String arg) -> instance

  def eql?: (Resolv::LOC::Alt other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw altitude
  #
  def altitude: () -> Integer

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(altitude)
  # -->
  #
  def initialize: (Integer altitude) -> untyped
end

Resolv::LOC::Alt::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Coord
#
class Resolv::LOC::Coord
  type orientation = "lat" | "lon"

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Coord from `arg` which may be:
  #
  # LOC::Coord
  # :   returns `arg`.
  #
  # String
  # :   `arg` must match the LOC::Coord::Regex constant
  #
  def self.create: (Resolv::LOC::Coord | String arg) -> instance

  def eql?: (Resolv::LOC::Coord other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw coordinates
  #
  def coordinates: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The orientation of the hemisphere as 'lat' or 'lon'
  #
  def orientation: () -> orientation

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(coordinates,orientation)
  # -->
  #
  def initialize: (String coordinates, orientation orientation) -> untyped
end

Resolv::LOC::Coord::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Size
#
class Resolv::LOC::Size
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Size from `arg` which may be:
  #
  # LOC::Size
  # :   returns `arg`.
  #
  # String
  # :   `arg` must match the LOC::Size::Regex constant
  #
  def self.create: (Resolv::LOC::Size | String arg) -> instance

  def eql?: (Resolv::LOC::Size other) -> bool

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw size
  #
  def scalar: () -> String

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(scalar)
  # -->
  #
  def initialize: (String scalar) -> untyped
end

Resolv::LOC::Size::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::MDNS is a one-shot Multicast DNS (mDNS) resolver.  It blindly makes
# queries to the mDNS addresses without understanding anything about multicast
# ports.
#
# Information taken form the following places:
#
# *   RFC 6762
#
class Resolv::MDNS < Resolv::DNS
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name)
  # -->
  # Iterates over all IP addresses for `name` retrieved from the mDNS resolver,
  # provided name ends with "local".  If the name does not end in "local" no
  # records will be returned.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def each_address: (Resolv::DNS::dns_name name) -> Resolv::DNS::ip_address

  def make_udp_requester: () -> (Resolv::DNS::Requester::ConnectedUDP | Resolv::DNS::Requester::UnconnectedUDP)

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(config_info=nil)
  # -->
  # Creates a new one-shot Multicast DNS (mDNS) resolver.
  #
  # `config_info` can be:
  #
  # nil
  # :   Uses the default mDNS addresses
  #
  #
  # Hash
  # :   Must contain :nameserver or :nameserver_port like Resolv::DNS#initialize.
  #
  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Default IPv4 mDNS address
#
Resolv::MDNS::AddressV4: String

# <!-- rdoc-file=lib/resolv.rb -->
# Default IPv6 mDNS address
#
Resolv::MDNS::AddressV6: String

# <!-- rdoc-file=lib/resolv.rb -->
# Default mDNS addresses
#
Resolv::MDNS::Addresses: Array[untyped]

# <!-- rdoc-file=lib/resolv.rb -->
# Default mDNS Port
#
Resolv::MDNS::Port: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a failure to resolve a name or address.
#
class Resolv::ResolvError < StandardError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a timeout resolving a name or address.
#
class Resolv::ResolvTimeout < Timeout::Error
end
# <!-- rdoc-file=ext/ripper/lib/ripper.rb -->
# Ripper is a Ruby script parser.
#
# You can get information from the parser with event-based style. Information
# such as abstract syntax trees or simple lexical analysis of the Ruby program.
#
# ## Usage
#
# Ripper provides an easy interface for parsing your program into a symbolic
# expression tree (or S-expression).
#
# Understanding the output of the parser may come as a challenge, it's
# recommended you use PP to format the output for legibility.
#
#     require 'ripper'
#     require 'pp'
#
#     pp Ripper.sexp('def hello(world) "Hello, #{world}!"; end')
#       #=> [:program,
#            [[:def,
#              [:@ident, "hello", [1, 4]],
#              [:paren,
#               [:params, [[:@ident, "world", [1, 10]]], nil, nil, nil, nil, nil, nil]],
#              [:bodystmt,
#               [[:string_literal,
#                 [:string_content,
#                  [:@tstring_content, "Hello, ", [1, 18]],
#                  [:string_embexpr, [[:var_ref, [:@ident, "world", [1, 27]]]]],
#                  [:@tstring_content, "!", [1, 33]]]]],
#               nil,
#               nil,
#               nil]]]]
#
# You can see in the example above, the expression starts with `:program`.
#
# From here, a method definition at `:def`, followed by the method's identifier
# `:@ident`. After the method's identifier comes the parentheses `:paren` and
# the method parameters under `:params`.
#
# Next is the method body, starting at `:bodystmt` (`stmt` meaning statement),
# which contains the full definition of the method.
#
# In our case, we're simply returning a String, so next we have the
# `:string_literal` expression.
#
# Within our `:string_literal` you'll notice two `@tstring_content`, this is the
# literal part for `Hello, ` and `!`. Between the two `@tstring_content`
# statements is a `:string_embexpr`, where *embexpr* is an embedded expression.
# Our expression consists of a local variable, or `var_ref`, with the identifier
# (`@ident`) of `world`.
#
# ## Resources
#
# *   [Ruby
#     Inside](http://www.rubyinside.com/using-ripper-to-see-how-ruby-is-parsing-
#     your-code-5270.html)
#
# ## Requirements
#
# *   ruby 1.9 (support CVS HEAD only)
# *   bison 1.28 or later (Other yaccs do not work)
#
# ## License
#
# Ruby License.
#
# *   Minero Aoki
# *   aamine@loveruby.net
# *   http://i.loveruby.net
#
class Ripper
  # <!-- rdoc-file=ext/ripper/lib/ripper/core.rb -->
  # This array contains name of all ripper events.
  #
  EVENTS: Array[Symbol]

  EXPR_ARG: Integer

  EXPR_ARG_ANY: Integer

  EXPR_BEG: Integer

  EXPR_BEG_ANY: Integer

  EXPR_CLASS: Integer

  EXPR_CMDARG: Integer

  EXPR_DOT: Integer

  EXPR_END: Integer

  EXPR_ENDARG: Integer

  EXPR_ENDFN: Integer

  EXPR_END_ANY: Integer

  EXPR_FITEM: Integer

  EXPR_FNAME: Integer

  EXPR_LABEL: Integer

  EXPR_LABELED: Integer

  EXPR_MID: Integer

  EXPR_NONE: Integer

  EXPR_VALUE: Integer

  # <!-- rdoc-file=ext/ripper/lib/ripper/core.rb -->
  # This array contains name of parser events.
  #
  PARSER_EVENTS: Array[Symbol]

  PARSER_EVENT_TABLE: Hash[Symbol, Integer]

  # <!-- rdoc-file=ext/ripper/lib/ripper/core.rb -->
  # This array contains name of scanner events.
  #
  SCANNER_EVENTS: Array[Symbol]

  SCANNER_EVENT_TABLE: Hash[Symbol, Integer]

  # <!-- rdoc-file=parse.c -->
  # version of Ripper
  #
  Version: String

  # <!-- rdoc-file=ext/ripper/lib/ripper/filter.rb -->
  # This class handles only scanner events, which are dispatched in the 'right'
  # order (same with input).
  #
  class Filter
    private

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - new(src, filename = '-', lineno = 1)
    # -->
    # Creates a new Ripper::Filter instance, passes parameters `src`, `filename`,
    # and `lineno` to Ripper::Lexer.new
    #
    # The lexer is for internal use only.
    #
    def initialize: (File | _Gets | String src, ?String filename, ?Integer lineno) -> void

    public

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - column()
    # -->
    # The column number of the current token. This value starts from 0. This method
    # is valid only in event handlers.
    #
    def column: () -> Integer?

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - filename()
    # -->
    # The file name of the input.
    #
    def filename: () -> String

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - lineno()
    # -->
    # The line number of the current token. This value starts from 1. This method is
    # valid only in event handlers.
    #
    def lineno: () -> Integer?

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - parse(init = nil)
    # -->
    # Starts the parser. `init` is a data accumulator and is passed to the next
    # event handler (as of Enumerable#inject).
    #
    def parse: (?untyped init) -> untyped

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - state()
    # -->
    # The scanner's state of the current token. This value is the bitwise OR of zero
    # or more of the `Ripper::EXPR_*` constants.
    #
    def state: () -> Ripper::Lexer::State

    private

    # <!--
    #   rdoc-file=ext/ripper/lib/ripper/filter.rb
    #   - on_default(event, token, data)
    # -->
    # This method is called when some event handler is undefined. `event` is
    # :on_XXX, `token` is the scanned token, and `data` is a data accumulator.
    #
    # The return value of this method is passed to the next event handler (as of
    # Enumerable#inject).
    #
    def on_default: (untyped event, untyped token, untyped data) -> untyped
  end

  class Lexer < Ripper
    class Elem
      attr_accessor event: Symbol

      attr_accessor message: String?
      attr_accessor pos: [ Integer, Integer ]

      attr_accessor state: Ripper::Lexer::State
      attr_accessor tok: String

      private

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - new(pos, event, tok, state, message = nil)
      # -->
      #
      def initialize: ([ Integer, Integer ] pos, Symbol event, String tok, Integer | Ripper::Lexer::State state, ?String? message) -> void

      public

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - [](index)
      # -->
      #
      def []: (0 | :pos) -> [ Integer, Integer ]
            | (1 | :event) -> Symbol
            | (2 | :tok) -> String
            | (3 | :state) -> Ripper::Lexer::State
            | (4 | :message) -> String?
            | (Integer | Symbol) -> untyped
            | (untyped) -> nil

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - to_a()
      # -->
      #
      def to_a: () -> [ [ Integer, Integer ], Symbol, String, Ripper::Lexer::State, String ]
              | () -> [ [ Integer, Integer ], Symbol, String, Ripper::Lexer::State ]
    end

    class State
      attr_reader to_int: Integer
      attr_reader to_s: String

      private

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - new(i)
      # -->
      #
      def initialize: (Integer | State i) -> void

      public

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - &(i)
      # -->
      #
      def &: (Integer i) -> State

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - ==(i)
      # -->
      #
      def ==: (Integer | State i) -> bool

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - [](index)
      # -->
      #
      def []: (0 | :to_int index) -> (Integer | State)
            | (1 | :to_s index) -> String
            | (untyped) -> nil

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - allbits?(i)
      # -->
      #
      def allbits?: (int i) -> bool

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - anybits?(i)
      # -->
      #
      def anybits?: (int i) -> bool

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - nobits?(i)
      # -->
      #
      def nobits?: (int i) -> bool

      alias to_i to_int

      # <!--
      #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
      #   - |(i)
      # -->
      #
      def |: (Integer i) -> State
    end
    attr_reader errors: Array[Lexer::Elem]

    alias compile_error on_error1
    def lex: (?raise_errors: boolish) -> Array[[ [ Integer, Integer ], Symbol, String, Lexer::State ]]

    alias on_CHAR _push_token

    alias on___end__ _push_token

    alias on_alias_error on_error2

    alias on_assign_error on_error2

    alias on_backref _push_token

    alias on_backtick _push_token

    alias on_class_name_error on_error2

    alias on_comma _push_token

    alias on_comment _push_token

    alias on_const _push_token

    alias on_cvar _push_token

    alias on_embdoc _push_token

    alias on_embdoc_beg _push_token

    alias on_embdoc_end _push_token

    alias on_embexpr_beg _push_token

    alias on_embexpr_end _push_token

    alias on_embvar _push_token

    alias on_float _push_token

    alias on_gvar _push_token

    alias on_ident _push_token

    alias on_ignored_nl _push_token

    alias on_ignored_sp _push_token

    alias on_imaginary _push_token

    alias on_int _push_token

    alias on_ivar _push_token

    alias on_kw _push_token

    alias on_label _push_token

    alias on_label_end _push_token

    alias on_lbrace _push_token

    alias on_lbracket _push_token

    alias on_lparen _push_token

    alias on_nl _push_token

    alias on_op _push_token

    alias on_param_error on_error2

    alias on_parse_error on_error1

    alias on_period _push_token

    alias on_qsymbols_beg _push_token

    alias on_qwords_beg _push_token

    alias on_rational _push_token

    alias on_rbrace _push_token

    alias on_rbracket _push_token

    alias on_regexp_beg _push_token

    alias on_regexp_end _push_token

    alias on_rparen _push_token

    alias on_semicolon _push_token

    alias on_sp _push_token

    alias on_symbeg _push_token

    alias on_symbols_beg _push_token

    alias on_tlambda _push_token

    alias on_tlambeg _push_token

    alias on_tstring_beg _push_token

    alias on_tstring_content _push_token

    alias on_tstring_end _push_token

    alias on_words_beg _push_token

    alias on_words_sep _push_token
    def parse: (?raise_errors: boolish) -> Array[Lexer::Elem]

    def scan: (?raise_errors: boolish) -> Array[Lexer::Elem]

    def tokenize: (?raise_errors: boolish) -> Array[String]

    private

    def _push_token: (untyped tok) -> Lexer::Elem

    def on_error1: (untyped mesg) -> Array[Lexer::Elem]

    def on_error2: (untyped mesg, untyped elem) -> Array[Lexer::Elem]

    def on_heredoc_beg: (untyped tok) -> untyped

    def on_heredoc_dedent: (untyped v, untyped w) -> untyped

    def on_heredoc_end: (untyped tok) -> untyped
  end

  class SexpBuilder < Ripper
    attr_reader error: untyped

    alias compile_error on_error
    def on_BEGIN: (*untyped args) -> untyped

    def on_CHAR: (untyped tok) -> untyped

    def on_END: (*untyped args) -> untyped

    def on___end__: (untyped tok) -> untyped

    def on_alias: (*untyped args) -> untyped

    def on_alias_error: (*untyped args) -> untyped

    def on_aref: (*untyped args) -> untyped

    def on_aref_field: (*untyped args) -> untyped

    def on_arg_ambiguous: (*untyped args) -> untyped

    def on_arg_paren: (*untyped args) -> untyped

    def on_args_add: (*untyped args) -> untyped

    def on_args_add_block: (*untyped args) -> untyped

    def on_args_add_star: (*untyped args) -> untyped

    def on_args_forward: (*untyped args) -> untyped

    def on_args_new: (*untyped args) -> untyped

    def on_array: (*untyped args) -> untyped

    def on_aryptn: (*untyped args) -> untyped

    def on_assign: (*untyped args) -> untyped

    def on_assign_error: (*untyped args) -> untyped

    def on_assoc_new: (*untyped args) -> untyped

    def on_assoc_splat: (*untyped args) -> untyped

    def on_assoclist_from_args: (*untyped args) -> untyped

    def on_backref: (untyped tok) -> untyped

    def on_backtick: (untyped tok) -> untyped

    def on_bare_assoc_hash: (*untyped args) -> untyped

    def on_begin: (*untyped args) -> untyped

    def on_binary: (*untyped args) -> untyped

    def on_block_var: (*untyped args) -> untyped

    def on_blockarg: (*untyped args) -> untyped

    def on_bodystmt: (*untyped args) -> untyped

    def on_brace_block: (*untyped args) -> untyped

    def on_break: (*untyped args) -> untyped

    def on_call: (*untyped args) -> untyped

    def on_case: (*untyped args) -> untyped

    def on_class: (*untyped args) -> untyped

    def on_class_name_error: (*untyped args) -> untyped

    def on_comma: (untyped tok) -> untyped

    def on_command: (*untyped args) -> untyped

    def on_command_call: (*untyped args) -> untyped

    def on_comment: (untyped tok) -> untyped

    def on_const: (untyped tok) -> untyped

    def on_const_path_field: (*untyped args) -> untyped

    def on_const_path_ref: (*untyped args) -> untyped

    def on_const_ref: (*untyped args) -> untyped

    def on_cvar: (untyped tok) -> untyped

    def on_def: (*untyped args) -> untyped

    def on_defined: (*untyped args) -> untyped

    def on_defs: (*untyped args) -> untyped

    def on_do_block: (*untyped args) -> untyped

    def on_dot2: (*untyped args) -> untyped

    def on_dot3: (*untyped args) -> untyped

    def on_dyna_symbol: (*untyped args) -> untyped

    def on_else: (*untyped args) -> untyped

    def on_elsif: (*untyped args) -> untyped

    def on_embdoc: (untyped tok) -> untyped

    def on_embdoc_beg: (untyped tok) -> untyped

    def on_embdoc_end: (untyped tok) -> untyped

    def on_embexpr_beg: (untyped tok) -> untyped

    def on_embexpr_end: (untyped tok) -> untyped

    def on_embvar: (untyped tok) -> untyped

    def on_ensure: (*untyped args) -> untyped

    def on_excessed_comma: (*untyped args) -> untyped

    def on_fcall: (*untyped args) -> untyped

    def on_field: (*untyped args) -> untyped

    def on_float: (untyped tok) -> untyped

    def on_fndptn: (*untyped args) -> untyped

    def on_for: (*untyped args) -> untyped

    def on_gvar: (untyped tok) -> untyped

    def on_hash: (*untyped args) -> untyped

    def on_heredoc_beg: (untyped tok) -> untyped

    def on_heredoc_end: (untyped tok) -> untyped

    def on_hshptn: (*untyped args) -> untyped

    def on_ident: (untyped tok) -> untyped

    def on_if: (*untyped args) -> untyped

    def on_if_mod: (*untyped args) -> untyped

    def on_ifop: (*untyped args) -> untyped

    def on_ignored_nl: (untyped tok) -> untyped

    def on_ignored_sp: (untyped tok) -> untyped

    def on_imaginary: (untyped tok) -> untyped

    def on_in: (*untyped args) -> untyped

    def on_int: (untyped tok) -> untyped

    def on_ivar: (untyped tok) -> untyped

    def on_kw: (untyped tok) -> untyped

    def on_kwrest_param: (*untyped args) -> untyped

    def on_label: (untyped tok) -> untyped

    def on_label_end: (untyped tok) -> untyped

    def on_lambda: (*untyped args) -> untyped

    def on_lbrace: (untyped tok) -> untyped

    def on_lbracket: (untyped tok) -> untyped

    def on_lparen: (untyped tok) -> untyped

    def on_magic_comment: (*untyped args) -> untyped

    def on_massign: (*untyped args) -> untyped

    def on_method_add_arg: (*untyped args) -> untyped

    def on_method_add_block: (*untyped args) -> untyped

    def on_mlhs_add: (*untyped args) -> untyped

    def on_mlhs_add_post: (*untyped args) -> untyped

    def on_mlhs_add_star: (*untyped args) -> untyped

    def on_mlhs_new: (*untyped args) -> untyped

    def on_mlhs_paren: (*untyped args) -> untyped

    def on_module: (*untyped args) -> untyped

    def on_mrhs_add: (*untyped args) -> untyped

    def on_mrhs_add_star: (*untyped args) -> untyped

    def on_mrhs_new: (*untyped args) -> untyped

    def on_mrhs_new_from_args: (*untyped args) -> untyped

    def on_next: (*untyped args) -> untyped

    def on_nl: (untyped tok) -> untyped

    def on_nokw_param: (*untyped args) -> untyped

    def on_op: (untyped tok) -> untyped

    def on_opassign: (*untyped args) -> untyped

    def on_operator_ambiguous: (*untyped args) -> untyped

    def on_param_error: (*untyped args) -> untyped

    def on_params: (*untyped args) -> untyped

    def on_paren: (*untyped args) -> untyped

    alias on_parse_error on_error
    def on_period: (untyped tok) -> untyped

    def on_program: (*untyped args) -> untyped

    def on_qsymbols_add: (*untyped args) -> untyped

    def on_qsymbols_beg: (untyped tok) -> untyped

    def on_qsymbols_new: (*untyped args) -> untyped

    def on_qwords_add: (*untyped args) -> untyped

    def on_qwords_beg: (untyped tok) -> untyped

    def on_qwords_new: (*untyped args) -> untyped

    def on_rational: (untyped tok) -> untyped

    def on_rbrace: (untyped tok) -> untyped

    def on_rbracket: (untyped tok) -> untyped

    def on_redo: (*untyped args) -> untyped

    def on_regexp_add: (*untyped args) -> untyped

    def on_regexp_beg: (untyped tok) -> untyped

    def on_regexp_end: (untyped tok) -> untyped

    def on_regexp_literal: (*untyped args) -> untyped

    def on_regexp_new: (*untyped args) -> untyped

    def on_rescue: (*untyped args) -> untyped

    def on_rescue_mod: (*untyped args) -> untyped

    def on_rest_param: (*untyped args) -> untyped

    def on_retry: (*untyped args) -> untyped

    def on_return: (*untyped args) -> untyped

    def on_return0: (*untyped args) -> untyped

    def on_rparen: (untyped tok) -> untyped

    def on_sclass: (*untyped args) -> untyped

    def on_semicolon: (untyped tok) -> untyped

    def on_sp: (untyped tok) -> untyped

    def on_stmts_add: (*untyped args) -> untyped

    def on_stmts_new: (*untyped args) -> untyped

    def on_string_add: (*untyped args) -> untyped

    def on_string_concat: (*untyped args) -> untyped

    def on_string_content: (*untyped args) -> untyped

    def on_string_dvar: (*untyped args) -> untyped

    def on_string_embexpr: (*untyped args) -> untyped

    def on_string_literal: (*untyped args) -> untyped

    def on_super: (*untyped args) -> untyped

    def on_symbeg: (untyped tok) -> untyped

    def on_symbol: (*untyped args) -> untyped

    def on_symbol_literal: (*untyped args) -> untyped

    def on_symbols_add: (*untyped args) -> untyped

    def on_symbols_beg: (untyped tok) -> untyped

    def on_symbols_new: (*untyped args) -> untyped

    def on_tlambda: (untyped tok) -> untyped

    def on_tlambeg: (untyped tok) -> untyped

    def on_top_const_field: (*untyped args) -> untyped

    def on_top_const_ref: (*untyped args) -> untyped

    def on_tstring_beg: (untyped tok) -> untyped

    def on_tstring_content: (untyped tok) -> untyped

    def on_tstring_end: (untyped tok) -> untyped

    def on_unary: (*untyped args) -> untyped

    def on_undef: (*untyped args) -> untyped

    def on_unless: (*untyped args) -> untyped

    def on_unless_mod: (*untyped args) -> untyped

    def on_until: (*untyped args) -> untyped

    def on_until_mod: (*untyped args) -> untyped

    def on_var_alias: (*untyped args) -> untyped

    def on_var_field: (*untyped args) -> untyped

    def on_var_ref: (*untyped args) -> untyped

    def on_vcall: (*untyped args) -> untyped

    def on_void_stmt: (*untyped args) -> untyped

    def on_when: (*untyped args) -> untyped

    def on_while: (*untyped args) -> untyped

    def on_while_mod: (*untyped args) -> untyped

    def on_word_add: (*untyped args) -> untyped

    def on_word_new: (*untyped args) -> untyped

    def on_words_add: (*untyped args) -> untyped

    def on_words_beg: (untyped tok) -> untyped

    def on_words_new: (*untyped args) -> untyped

    def on_words_sep: (untyped tok) -> untyped

    def on_xstring_add: (*untyped args) -> untyped

    def on_xstring_literal: (*untyped args) -> untyped

    def on_xstring_new: (*untyped args) -> untyped

    def on_yield: (*untyped args) -> untyped

    def on_yield0: (*untyped args) -> untyped

    def on_zsuper: (*untyped args) -> untyped

    private

    def dedent_element: (untyped e, untyped width) -> untyped

    def on_error: (untyped mesg) -> untyped

    def on_heredoc_dedent: (untyped val, untyped width) -> untyped
  end

  class SexpBuilderPP < Ripper::SexpBuilder
    alias on_args_add _dispatch_event_push

    alias on_args_new _dispatch_event_new

    alias on_mlhs_add _dispatch_event_push

    alias on_mlhs_new _dispatch_event_new

    alias on_mrhs_add _dispatch_event_push

    alias on_mrhs_new _dispatch_event_new

    alias on_qsymbols_add _dispatch_event_push

    alias on_qsymbols_new _dispatch_event_new

    alias on_qwords_add _dispatch_event_push

    alias on_qwords_new _dispatch_event_new

    alias on_regexp_add _dispatch_event_push

    alias on_regexp_new _dispatch_event_new

    alias on_stmts_add _dispatch_event_push

    alias on_stmts_new _dispatch_event_new

    alias on_string_add _dispatch_event_push

    alias on_symbols_add _dispatch_event_push

    alias on_symbols_new _dispatch_event_new

    alias on_word_add _dispatch_event_push

    alias on_word_new _dispatch_event_new

    alias on_words_add _dispatch_event_push

    alias on_words_new _dispatch_event_new

    alias on_xstring_add _dispatch_event_push

    alias on_xstring_new _dispatch_event_new

    private

    def _dispatch_event_new: () -> untyped

    def _dispatch_event_push: (untyped list, untyped item) -> untyped

    def on_heredoc_dedent: (untyped val, untyped width) -> untyped

    def on_mlhs_add_post: (untyped list, untyped post) -> untyped

    def on_mlhs_add_star: (untyped list, untyped star) -> untyped

    def on_mlhs_paren: (untyped list) -> untyped
  end

  class TokenPattern
    MAP: Hash[String, String]

    class CompileError < Error
    end
    class Error < StandardError
    end

    class MatchData
      private

      def initialize: (untyped tokens, untyped match) -> void

      public

      def string: (?untyped n) -> untyped

      private

      def match: (?untyped n) -> untyped
    end
    class MatchError < Error
    end
    alias self.compile self.new

    private

    def initialize: (untyped pattern) -> void

    public

    def match: (untyped str) -> untyped

    def match_list: (untyped tokens) -> untyped

    private

    def compile: (untyped pattern) -> untyped

    def map_token: (untyped tok) -> untyped

    def map_tokens: (untyped tokens) -> untyped
  end
  interface _Gets
    def gets: (?String sep, ?Integer limit) -> String?
  end

  # <!--
  #   rdoc-file=parse.c
  #   - Ripper.dedent_string(input, width)   -> Integer
  # -->
  # USE OF RIPPER LIBRARY ONLY.
  #
  # Strips up to `width` leading whitespaces from `input`, and returns the
  # stripped column width.
  #
  def self.dedent_string: (String input, int width) -> Integer

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
  #   - lex(src, filename = '-', lineno = 1, **kw)
  # -->
  # Tokenizes the Ruby program and returns an array of an array, which is
  # formatted like `[[lineno, column], type, token, state]`. The `filename`
  # argument is mostly ignored. By default, this method does not handle syntax
  # errors in `src`, use the `raise_errors` keyword to raise a SyntaxError for an
  # error in `src`.
  #
  #     require 'ripper'
  #     require 'pp'
  #
  #     pp Ripper.lex("def m(a) nil end")
  #     #=> [[[1,  0], :on_kw,     "def", FNAME    ],
  #          [[1,  3], :on_sp,     " ",   FNAME    ],
  #          [[1,  4], :on_ident,  "m",   ENDFN    ],
  #          [[1,  5], :on_lparen, "(",   BEG|LABEL],
  #          [[1,  6], :on_ident,  "a",   ARG      ],
  #          [[1,  7], :on_rparen, ")",   ENDFN    ],
  #          [[1,  8], :on_sp,     " ",   BEG      ],
  #          [[1,  9], :on_kw,     "nil", END      ],
  #          [[1, 12], :on_sp,     " ",   END      ],
  #          [[1, 13], :on_kw,     "end", END      ]]
  #
  def self.lex: (String src, ?String filename, ?Integer lineno, ?raise_errors: boolish) -> Array[[ [ Integer, Integer ], Symbol, String, Lexer::State ]]

  # <!--
  #   rdoc-file=parse.c
  #   - Ripper.lex_state_name(integer)   -> string
  # -->
  # Returns a string representation of lex_state.
  #
  def self.lex_state_name: (int) -> String

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/core.rb
  #   - parse(src, filename = '(ripper)', lineno = 1)
  # -->
  # Parses the given Ruby program read from `src`. `src` must be a String or an IO
  # or a object with a #gets method.
  #
  def self.parse: (File | _Gets | String src, ?String filename, ?Integer lineno) -> nil

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/sexp.rb
  #   - sexp(src, filename = '-', lineno = 1, raise_errors: false)
  # -->
  # EXPERIMENTAL
  # :   Parses `src` and create S-exp tree. Returns more readable tree rather than
  #     Ripper.sexp_raw. This method is mainly for developer use. The `filename`
  #     argument is mostly ignored. By default, this method does not handle syntax
  #     errors in `src`, returning `nil` in such cases. Use the `raise_errors`
  #     keyword to raise a SyntaxError for an error in `src`.
  #
  #         require 'ripper'
  #         require 'pp'
  #
  #         pp Ripper.sexp("def m(a) nil end")
  #           #=> [:program,
  #                [[:def,
  #                 [:@ident, "m", [1, 4]],
  #                 [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil, nil, nil, nil]],
  #                 [:bodystmt, [[:var_ref, [:@kw, "nil", [1, 9]]]], nil, nil, nil]]]]
  #
  def self.sexp: (File | _Gets | String src, ?String filename, ?Integer lineno, ?raise_errors: boolish) -> Array[untyped]

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/sexp.rb
  #   - sexp_raw(src, filename = '-', lineno = 1, raise_errors: false)
  # -->
  # EXPERIMENTAL
  # :   Parses `src` and create S-exp tree. This method is mainly for developer
  #     use. The `filename` argument is mostly ignored. By default, this method
  #     does not handle syntax errors in `src`, returning `nil` in such cases. Use
  #     the `raise_errors` keyword to raise a SyntaxError for an error in `src`.
  #
  #         require 'ripper'
  #         require 'pp'
  #
  #         pp Ripper.sexp_raw("def m(a) nil end")
  #           #=> [:program,
  #                [:stmts_add,
  #                 [:stmts_new],
  #                 [:def,
  #                  [:@ident, "m", [1, 4]],
  #                  [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil]],
  #                  [:bodystmt,
  #                   [:stmts_add, [:stmts_new], [:var_ref, [:@kw, "nil", [1, 9]]]],
  #                   nil,
  #                   nil,
  #                   nil]]]]
  #
  def self.sexp_raw: (File | _Gets | String src, ?String filename, ?Integer lineno, ?raise_errors: boolish) -> Array[untyped]

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
  #   - slice(src, pattern, n = 0)
  # -->
  # EXPERIMENTAL
  # :   Parses `src` and return a string which was matched to `pattern`. `pattern`
  #     should be described as Regexp.
  #
  #         require 'ripper'
  #
  #         p Ripper.slice('def m(a) nil end', 'ident')                   #=> "m"
  #         p Ripper.slice('def m(a) nil end', '[ident lparen rparen]+')  #=> "m(a)"
  #         p Ripper.slice("<<EOS\nstring\nEOS",
  #                        'heredoc_beg nl $(tstring_content*) heredoc_end', 1)
  #             #=> "string\n"
  #
  def self.slice: (String src, String pattern, ?Integer n) -> String?

  def self.token_match: (String src, String pattern) -> Ripper::TokenPattern::MatchData?

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/lexer.rb
  #   - tokenize(src, filename = '-', lineno = 1, **kw)
  # -->
  # Tokenizes the Ruby program and returns an array of strings. The `filename` and
  # `lineno` arguments are mostly ignored, since the return value is just the
  # tokenized input. By default, this method does not handle syntax errors in
  # `src`, use the `raise_errors` keyword to raise a SyntaxError for an error in
  # `src`.
  #
  #     p Ripper.tokenize("def m(a) nil end")
  #        # => ["def", " ", "m", "(", "a", ")", " ", "nil", " ", "end"]
  #
  def self.tokenize: (File | _Gets | String src, ?String filename, ?Integer lineno, ?raise_errors: boolish) -> Array[String]

  private

  # <!--
  #   rdoc-file=parse.c
  #   - Ripper.new(src, filename="(ripper)", lineno=1) -> ripper
  # -->
  # Create a new Ripper object. *src* must be a String, an IO, or an Object which
  # has #gets method.
  #
  # This method does not starts parsing. See also Ripper#parse and Ripper.parse.
  #
  def initialize: (File | _Gets | String src, ?String filename, ?Integer lineno) -> void

  public

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.column   -> Integer
  # -->
  # Return column number of current parsing line. This number starts from 0.
  #
  def column: () -> Integer?

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.debug_output   -> obj
  # -->
  # Get debug output.
  #
  def debug_output: () -> untyped

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.debug_output = obj
  # -->
  # Set debug output.
  #
  def debug_output=: (untyped) -> untyped

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.encoding   -> encoding
  # -->
  # Return encoding of the source.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.end_seen?   -> Boolean
  # -->
  # Return true if parsed source ended by +_*END*_+.
  #
  def end_seen?: () -> bool

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.error?   -> Boolean
  # -->
  # Return true if parsed source has errors.
  #
  def error?: () -> bool

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.filename   -> String
  # -->
  # Return current parsing filename.
  #
  def filename: () -> String

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.lineno   -> Integer
  # -->
  # Return line number of current parsing line. This number starts from 1.
  #
  def lineno: () -> Integer?

  alias on_BEGIN _dispatch_1

  alias on_CHAR _dispatch_1

  alias on_END _dispatch_1

  alias on___end__ _dispatch_1

  alias on_alias _dispatch_2

  alias on_alias_error _dispatch_2

  alias on_aref _dispatch_2

  alias on_aref_field _dispatch_2

  alias on_arg_ambiguous _dispatch_1

  alias on_arg_paren _dispatch_1

  alias on_args_add _dispatch_2

  alias on_args_add_block _dispatch_2

  alias on_args_add_star _dispatch_2

  alias on_args_forward _dispatch_0

  alias on_args_new _dispatch_0

  alias on_array _dispatch_1

  alias on_aryptn _dispatch_4

  alias on_assign _dispatch_2

  alias on_assign_error _dispatch_2

  alias on_assoc_new _dispatch_2

  alias on_assoc_splat _dispatch_1

  alias on_assoclist_from_args _dispatch_1

  alias on_backref _dispatch_1

  alias on_backtick _dispatch_1

  alias on_bare_assoc_hash _dispatch_1

  alias on_begin _dispatch_1

  alias on_binary _dispatch_3

  alias on_block_var _dispatch_2

  alias on_blockarg _dispatch_1

  alias on_bodystmt _dispatch_4

  alias on_brace_block _dispatch_2

  alias on_break _dispatch_1

  alias on_call _dispatch_3

  alias on_case _dispatch_2

  alias on_class _dispatch_3

  alias on_class_name_error _dispatch_2

  alias on_comma _dispatch_1

  alias on_command _dispatch_2

  alias on_command_call _dispatch_4

  alias on_comment _dispatch_1

  alias on_const _dispatch_1

  alias on_const_path_field _dispatch_2

  alias on_const_path_ref _dispatch_2

  alias on_const_ref _dispatch_1

  alias on_cvar _dispatch_1

  alias on_def _dispatch_3

  alias on_defined _dispatch_1

  alias on_defs _dispatch_5

  alias on_do_block _dispatch_2

  alias on_dot2 _dispatch_2

  alias on_dot3 _dispatch_2

  alias on_dyna_symbol _dispatch_1

  alias on_else _dispatch_1

  alias on_elsif _dispatch_3

  alias on_embdoc _dispatch_1

  alias on_embdoc_beg _dispatch_1

  alias on_embdoc_end _dispatch_1

  alias on_embexpr_beg _dispatch_1

  alias on_embexpr_end _dispatch_1

  alias on_embvar _dispatch_1

  alias on_ensure _dispatch_1

  alias on_excessed_comma _dispatch_0

  alias on_fcall _dispatch_1

  alias on_field _dispatch_3

  alias on_float _dispatch_1

  alias on_fndptn _dispatch_4

  alias on_for _dispatch_3

  alias on_gvar _dispatch_1

  alias on_hash _dispatch_1

  alias on_heredoc_beg _dispatch_1

  alias on_heredoc_dedent _dispatch_2

  alias on_heredoc_end _dispatch_1

  alias on_hshptn _dispatch_3

  alias on_ident _dispatch_1

  alias on_if _dispatch_3

  alias on_if_mod _dispatch_2

  alias on_ifop _dispatch_3

  alias on_ignored_nl _dispatch_1

  alias on_imaginary _dispatch_1

  alias on_in _dispatch_3

  alias on_int _dispatch_1

  alias on_ivar _dispatch_1

  alias on_kw _dispatch_1

  alias on_kwrest_param _dispatch_1

  alias on_label _dispatch_1

  alias on_label_end _dispatch_1

  alias on_lambda _dispatch_2

  alias on_lbrace _dispatch_1

  alias on_lbracket _dispatch_1

  alias on_lparen _dispatch_1

  alias on_magic_comment _dispatch_2

  alias on_massign _dispatch_2

  alias on_method_add_arg _dispatch_2

  alias on_method_add_block _dispatch_2

  alias on_mlhs_add _dispatch_2

  alias on_mlhs_add_post _dispatch_2

  alias on_mlhs_add_star _dispatch_2

  alias on_mlhs_new _dispatch_0

  alias on_mlhs_paren _dispatch_1

  alias on_module _dispatch_2

  alias on_mrhs_add _dispatch_2

  alias on_mrhs_add_star _dispatch_2

  alias on_mrhs_new _dispatch_0

  alias on_mrhs_new_from_args _dispatch_1

  alias on_next _dispatch_1

  alias on_nl _dispatch_1

  alias on_nokw_param _dispatch_1

  alias on_op _dispatch_1

  alias on_opassign _dispatch_3

  alias on_operator_ambiguous _dispatch_2

  alias on_param_error _dispatch_2

  alias on_params _dispatch_7

  alias on_paren _dispatch_1

  alias on_parse_error _dispatch_1

  alias on_period _dispatch_1

  alias on_program _dispatch_1

  alias on_qsymbols_add _dispatch_2

  alias on_qsymbols_beg _dispatch_1

  alias on_qsymbols_new _dispatch_0

  alias on_qwords_add _dispatch_2

  alias on_qwords_beg _dispatch_1

  alias on_qwords_new _dispatch_0

  alias on_rational _dispatch_1

  alias on_rbrace _dispatch_1

  alias on_rbracket _dispatch_1

  alias on_redo _dispatch_0

  alias on_regexp_add _dispatch_2

  alias on_regexp_beg _dispatch_1

  alias on_regexp_end _dispatch_1

  alias on_regexp_literal _dispatch_2

  alias on_regexp_new _dispatch_0

  alias on_rescue _dispatch_4

  alias on_rescue_mod _dispatch_2

  alias on_rest_param _dispatch_1

  alias on_retry _dispatch_0

  alias on_return _dispatch_1

  alias on_return0 _dispatch_0

  alias on_rparen _dispatch_1

  alias on_sclass _dispatch_2

  alias on_semicolon _dispatch_1

  alias on_sp _dispatch_1

  alias on_stmts_add _dispatch_2

  alias on_stmts_new _dispatch_0

  alias on_string_add _dispatch_2

  alias on_string_concat _dispatch_2

  alias on_string_content _dispatch_0

  alias on_string_dvar _dispatch_1

  alias on_string_embexpr _dispatch_1

  alias on_string_literal _dispatch_1

  alias on_super _dispatch_1

  alias on_symbeg _dispatch_1

  alias on_symbol _dispatch_1

  alias on_symbol_literal _dispatch_1

  alias on_symbols_add _dispatch_2

  alias on_symbols_beg _dispatch_1

  alias on_symbols_new _dispatch_0

  alias on_tlambda _dispatch_1

  alias on_tlambeg _dispatch_1

  alias on_top_const_field _dispatch_1

  alias on_top_const_ref _dispatch_1

  alias on_tstring_beg _dispatch_1

  alias on_tstring_content _dispatch_1

  alias on_tstring_end _dispatch_1

  alias on_unary _dispatch_2

  alias on_undef _dispatch_1

  alias on_unless _dispatch_3

  alias on_unless_mod _dispatch_2

  alias on_until _dispatch_2

  alias on_until_mod _dispatch_2

  alias on_var_alias _dispatch_2

  alias on_var_field _dispatch_1

  alias on_var_ref _dispatch_1

  alias on_vcall _dispatch_1

  alias on_void_stmt _dispatch_0

  alias on_when _dispatch_3

  alias on_while _dispatch_2

  alias on_while_mod _dispatch_2

  alias on_word_add _dispatch_2

  alias on_word_new _dispatch_0

  alias on_words_add _dispatch_2

  alias on_words_beg _dispatch_1

  alias on_words_new _dispatch_0

  alias on_words_sep _dispatch_1

  alias on_xstring_add _dispatch_2

  alias on_xstring_literal _dispatch_1

  alias on_xstring_new _dispatch_0

  alias on_yield _dispatch_1

  alias on_yield0 _dispatch_0

  alias on_zsuper _dispatch_0

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.parse
  # -->
  # Start parsing and returns the value of the root action.
  #
  def parse: () -> nil

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.state   -> Integer
  # -->
  # Return scanner state of current token.
  #
  def state: () -> Integer?

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.token   -> String
  # -->
  # Return the current token string.
  #
  def token: () -> String?

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.yydebug   -> true or false
  # -->
  # Get yydebug.
  #
  def yydebug: () -> bool

  # <!--
  #   rdoc-file=parse.c
  #   - ripper.yydebug = flag
  # -->
  # Set yydebug.
  #
  def yydebug=: (bool) -> bool

  private

  def _dispatch_0: () -> void

  def _dispatch_1: (untyped a) -> void

  def _dispatch_2: (untyped a, untyped b) -> void

  def _dispatch_3: (untyped a, untyped b, untyped c) -> void

  def _dispatch_4: (untyped a, untyped b, untyped c, untyped d) -> void

  def _dispatch_5: (untyped a, untyped b, untyped c, untyped d, untyped e) -> void

  def _dispatch_6: (untyped a, untyped b, untyped c, untyped d, untyped e, untyped f) -> void

  def _dispatch_7: (untyped a, untyped b, untyped c, untyped d, untyped e, untyped f, untyped g) -> void

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/core.rb
  #   - compile_error(msg)
  # -->
  # This method is called when the parser found syntax error.
  #
  def compile_error: (untyped msg) -> untyped

  # <!--
  #   rdoc-file=parse.c
  #   - Ripper.dedent_string(input, width)   -> Integer
  # -->
  # USE OF RIPPER LIBRARY ONLY.
  #
  # Strips up to `width` leading whitespaces from `input`, and returns the
  # stripped column width.
  #
  def dedent_string: (String input, Integer width) -> Integer

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/core.rb
  #   - warn(fmt, *args)
  # -->
  # This method is called when weak warning is produced by the parser. `fmt` and
  # `args` is printf style.
  #
  def warn: (untyped fmt, *untyped args) -> untyped

  # <!--
  #   rdoc-file=ext/ripper/lib/ripper/core.rb
  #   - warning(fmt, *args)
  # -->
  # This method is called when strong warning is produced by the parser. `fmt` and
  # `args` is printf style.
  #
  def warning: (untyped fmt, *untyped args) -> untyped
end
# <!-- rdoc-file=lib/securerandom.rb -->
# ## Secure random number generator interface.
#
# This library is an interface to secure random number generators which are
# suitable for generating session keys in HTTP cookies, etc.
#
# You can use this library in your application by requiring it:
#
#     require 'securerandom'
#
# It supports the following secure random number generators:
#
# *   openssl
# *   /dev/urandom
# *   Win32
#
# SecureRandom is extended by the Random::Formatter module which defines the
# following methods:
#
# *   alphanumeric
# *   base64
# *   choose
# *   gen_random
# *   hex
# *   rand
# *   random_bytes
# *   random_number
# *   urlsafe_base64
# *   uuid
#
# These methods are usable as class methods of SecureRandom such as
# `SecureRandom.hex`.
#
# If a secure random number generator is not available, `NotImplementedError` is
# raised.
#
module SecureRandom
  extend Random::Formatter

  # <!--
  #   rdoc-file=lib/securerandom.rb
  #   - alphanumeric(n = nil, chars: ALPHANUMERIC)
  # -->
  # Compatibility methods for Ruby 3.2, we can remove this after dropping to
  # support Ruby 3.2
  #
  def self.alphanumeric: (?Integer?) -> String

  def self.base64: (?Integer?) -> String

  def self.hex: (?Integer?) -> String

  def self.random_bytes: (?Integer?) -> String

  def self.random_number: () -> Float
                        | (Integer) -> Integer
                        | (Numeric) -> Numeric

  def self.urlsafe_base64: (?Integer?, ?bool?) -> String

  def self.uuid: () -> String
end
# <!-- rdoc-file=lib/shellwords.rb -->
# ## Manipulates strings like the UNIX Bourne shell
#
# This module manipulates strings according to the word parsing rules of the
# UNIX Bourne shell.
#
# The `shellwords()` function was originally a port of shellwords.pl, but
# modified to conform to [the Shell & Utilities volume of the IEEE Std
# 1003.1-2008, 2016
# Edition](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.ht
# ml)
#
# ### Usage
#
# You can use Shellwords to parse a string into a Bourne shell friendly Array.
#
#     require 'shellwords'
#
#     argv = Shellwords.split('three blind "mice"')
#     argv #=> ["three", "blind", "mice"]
#
# Once you've required Shellwords, you can use the #split alias
# String#shellsplit.
#
#     argv = "see how they run".shellsplit
#     argv #=> ["see", "how", "they", "run"]
#
# They treat quotes as special characters, so an unmatched quote will cause an
# ArgumentError.
#
#     argv = "they all ran after the farmer's wife".shellsplit
#          #=> ArgumentError: Unmatched quote: ...
#
# Shellwords also provides methods that do the opposite. Shellwords.escape, or
# its alias, String#shellescape, escapes shell metacharacters in a string for
# use in a command line.
#
#     filename = "special's.txt"
#
#     system("cat -- #{filename.shellescape}")
#     # runs "cat -- special\\'s.txt"
#
# Note the '--'.  Without it, cat(1) will treat the following argument as a
# command line option if it starts with '-'.  It is guaranteed that
# Shellwords.escape converts a string to a form that a Bourne shell will parse
# back to the original string, but it is the programmer's responsibility to make
# sure that passing an arbitrary argument to a command does no harm.
#
# Shellwords also comes with a core extension for Array, Array#shelljoin.
#
#     dir = "Funny GIFs"
#     argv = %W[ls -lta -- #{dir}]
#     system(argv.shelljoin + " | less")
#     # runs "ls -lta -- Funny\\ GIFs | less"
#
# You can use this method to build a complete command line out of an array of
# arguments.
#
# ### Authors
# *   Wakou Aoyama
# *   Akinori MUSHA <knu@iDaemons.org>
#
# ### Contact
# *   Akinori MUSHA <knu@iDaemons.org> (current maintainer)
#
module Shellwords
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellescape(str)
  # -->
  # Escapes a string so that it can be safely used in a Bourne shell command line.
  #  `str` can be a non-string object that responds to `to_s`.
  #
  # `str` must not contain NUL characters because of nature of `exec` system call.
  #
  # Note that a resulted string should be used unquoted and is not intended for
  # use in double quotes nor in single quotes.
  #
  #     argv = Shellwords.escape("It's better to give than to receive")
  #     argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  # String#shellescape is a shorthand for this function.
  #
  #     argv = "It's better to give than to receive".shellescape
  #     argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  #     # Search files in lib for method definitions
  #     pattern = "^[ \t]*def "
  #     open("| grep -Ern -e #{pattern.shellescape} lib") { |grep|
  #       grep.each_line { |line|
  #         file, lineno, matched_line = line.split(':', 3)
  #         # ...
  #       }
  #     }
  #
  # It is the caller's responsibility to encode the string in the right encoding
  # for the shell environment where this string is used.
  #
  # Multibyte characters are treated as multibyte characters, not as bytes.
  #
  # Returns an empty quoted String if `str` has a length of zero.
  #
  def self?.shellescape: (String str) -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shelljoin(array)
  # -->
  # Builds a command line string from an argument list, `array`.
  #
  # All elements are joined into a single string with fields separated by a space,
  # where each element is escaped for the Bourne shell and stringified using
  # `to_s`. See also Shellwords.shellescape.
  #
  #     ary = ["There's", "a", "time", "and", "place", "for", "everything"]
  #     argv = Shellwords.join(ary)
  #     argv #=> "There\\'s a time and place for everything"
  #
  # Array#shelljoin is a shortcut for this function.
  #
  #     ary = ["Don't", "rock", "the", "boat"]
  #     argv = ary.shelljoin
  #     argv #=> "Don\\'t rock the boat"
  #
  # You can also mix non-string objects in the elements as allowed in Array#join.
  #
  #     output = `#{['ps', '-p', $$].shelljoin}`
  #
  def self?.shelljoin: (Array[String] array) -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellsplit(line)
  # -->
  # Splits a string into an array of tokens in the same way the UNIX Bourne shell
  # does.
  #
  #     argv = Shellwords.split('here are "two words"')
  #     argv #=> ["here", "are", "two words"]
  #
  # `line` must not contain NUL characters because of nature of `exec` system
  # call.
  #
  # Note, however, that this is not a command line parser.  Shell metacharacters
  # except for the single and double quotes and backslash are not treated as such.
  #
  #     argv = Shellwords.split('ruby my_prog.rb | less')
  #     argv #=> ["ruby", "my_prog.rb", "|", "less"]
  #
  # String#shellsplit is a shortcut for this function.
  #
  #     argv = 'here are "two words"'.shellsplit
  #     argv #=> ["here", "are", "two words"]
  #
  def self?.shellsplit: (String line) -> Array[String]

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - escape(str)
  # -->
  #
  alias self.escape self.shellescape

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - join(array)
  # -->
  #
  alias self.join self.shelljoin

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellwords(line)
  # -->
  #
  alias self.shellwords self.shellsplit

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - split(line)
  # -->
  #
  alias self.split self.shellsplit

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellwords(line)
  # -->
  #
  alias shellwords shellsplit
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem]
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - array.shelljoin => string
  # -->
  # Builds a command line string from an argument list `array` joining all
  # elements escaped for the Bourne shell and separated by a space.
  #
  # See Shellwords.shelljoin for details.
  #
  def shelljoin: () -> String
end

%a{annotate:rdoc:skip}
class String
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - str.shellescape => string
  # -->
  # Escapes `str` so that it can be safely used in a Bourne shell command line.
  #
  # See Shellwords.shellescape for details.
  #
  def shellescape: () -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - str.shellsplit => array
  # -->
  # Splits `str` into an array of tokens in the same way the UNIX Bourne shell
  # does.
  #
  # See Shellwords.shellsplit for details.
  #
  def shellsplit: () -> Array[String]
end
# <!-- rdoc-file=lib/singleton.rb -->
# The Singleton module implements the Singleton pattern.
#
# ## Usage
#
# To use Singleton, include the module in your class.
#
#     class Klass
#        include Singleton
#        # ...
#     end
#
# This ensures that only one instance of Klass can be created.
#
#     a,b = Klass.instance, Klass.instance
#
#     a == b
#     # => true
#
#     Klass.new
#     # => NoMethodError - new is private ...
#
# The instance is created at upon the first call of Klass.instance().
#
#     class OtherKlass
#       include Singleton
#       # ...
#     end
#
#     ObjectSpace.each_object(OtherKlass){}
#     # => 0
#
#     OtherKlass.instance
#     ObjectSpace.each_object(OtherKlass){}
#     # => 1
#
# This behavior is preserved under inheritance and cloning.
#
# ## Implementation
#
# This above is achieved by:
#
# *   Making Klass.new and Klass.allocate private.
#
# *   Overriding Klass.inherited(sub_klass) and Klass.clone() to ensure that the
#     Singleton properties are kept when inherited and cloned.
#
# *   Providing the Klass.instance() method that returns the same object each
#     time it is called.
#
# *   Overriding Klass._load(str) to call Klass.instance().
#
# *   Overriding Klass#clone and Klass#dup to raise TypeErrors to prevent
#     cloning or duping.
#
# ## Singleton and Marshal
#
# By default Singleton's #_dump(depth) returns the empty string. Marshalling by
# default will strip state information, e.g. instance variables from the
# instance. Classes using Singleton can provide custom _load(str) and
# _dump(depth) methods to retain some of the previous state of the instance.
#
#     require 'singleton'
#
#     class Example
#       include Singleton
#       attr_accessor :keep, :strip
#       def _dump(depth)
#         # this strips the @strip information from the instance
#         Marshal.dump(@keep, depth)
#       end
#
#       def self._load(str)
#         instance.keep = Marshal.load(str)
#         instance
#       end
#     end
#
#     a = Example.instance
#     a.keep = "keep this"
#     a.strip = "get rid of this"
#
#     stored_state = Marshal.dump(a)
#
#     a.keep = nil
#     a.strip = nil
#     b = Marshal.load(stored_state)
#     p a == b  #  => true
#     p a.keep  #  => "keep this"
#     p a.strip #  => nil
#
module Singleton
  def self.__init__: (Class klass) -> Class

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - instance()
  # -->
  # Returns the singleton instance.
  #
  def self.instance: () -> instance

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - _dump(depth = -1)
  # -->
  # By default, do not retain any state when marshalling.
  #
  def _dump: (?Integer depth) -> String

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - clone()
  # -->
  # Raises a TypeError to prevent cloning.
  #
  def clone: () -> bot

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - dup()
  # -->
  # Raises a TypeError to prevent duping.
  #
  def dup: () -> bot

  module SingletonClassMethods
  end
end

Singleton::VERSION: String
# <!-- rdoc-file=ext/socket/tcpsocket.c -->
# TCPSocket represents a TCP/IP client socket.
#
# A simple client may look like:
#
#     require 'socket'
#
#     s = TCPSocket.new 'localhost', 2000
#
#     while line = s.gets # Read lines from socket
#       puts line         # and print them
#     end
#
#     s.close             # close socket when done
#
class TCPSocket < IPSocket
  # <!--
  #   rdoc-file=ext/socket/tcpsocket.c
  #   - TCPSocket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]
  # -->
  # Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   The 3rd element of the result is the address family of the first address.
  #     The address families of the rest of the addresses are not returned.
  # *   gethostbyname() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  # This method lookups host information by *hostname*.
  #
  #     TCPSocket.gethostbyname("localhost")
  #     #=> ["localhost", ["hal"], 2, "127.0.0.1"]
  #
  def self.gethostbyname: (String host) -> [ String, Array[String], Integer, String ]

  private

  # <!--
  #   rdoc-file=ext/socket/tcpsocket.c
  #   - TCPSocket.new(remote_host, remote_port, local_host=nil, local_port=nil, resolv_timeout: nil, connect_timeout: nil, fast_fallback: true)
  # -->
  # Opens a TCP connection to `remote_host` on `remote_port`.  If `local_host` and
  # `local_port` are specified, then those parameters are used on the local end to
  # establish the connection.
  #
  # Starting from Ruby 3.4, this method operates according to the Happy Eyeballs
  # Version 2 ([RFC 8305](https://datatracker.ietf.org/doc/html/rfc8305))
  # algorithm by default, except on Windows.
  #
  # For details on Happy Eyeballs Version 2, see
  # [Socket.tcp_fast_fallback=](rdoc-ref:Socket.tcp_fast_fallback=).
  #
  # To make it behave the same as in Ruby 3.3 and earlier, explicitly specify the
  # option fast_fallback:false. Or, setting Socket.tcp_fast_fallback=false will
  # disable Happy Eyeballs Version 2 not only for this method but for all Socket
  # globally.
  #
  # When using TCPSocket.new on Windows, Happy Eyeballs Version 2 is not provided,
  # and it behaves the same as in Ruby 3.3 and earlier.
  #
  # :resolv_timeout
  # :   Specifies the timeout in seconds from when the hostname resolution starts.
  #
  # :connect_timeout
  # :   This method sequentially attempts connecting to all candidate destination
  #     addresses.
  #     The `connect_timeout` specifies the timeout in seconds from the start of
  #     the connection attempt to the last candidate.
  #     By default, all connection attempts continue until the timeout occurs.
  #     When `fast_fallback:false` is explicitly specified,
  #     a timeout is set for each connection attempt and any connection attempt
  #     that exceeds its timeout will be canceled.
  #
  # :fast_fallback
  # :   Enables the Happy Eyeballs Version 2 algorithm (enabled by default).
  #
  def initialize: (String remote_host, Integer remote_port, ?String local_host, ?Integer local_port) -> untyped
end
# <!-- rdoc-file=ext/socket/socket.c -->
# Class `Socket` provides access to the underlying operating system socket
# implementations.  It can be used to provide more operating system specific
# functionality than the protocol-specific socket classes.
#
# The constants defined under Socket::Constants are also defined under Socket.
# For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET.
# See Socket::Constants for the list of constants.
#
# ### What's a socket?
#
# Sockets are endpoints of a bidirectional communication channel. Sockets can
# communicate within a process, between processes on the same machine or between
# different machines.  There are many types of socket: TCPSocket, UDPSocket or
# UNIXSocket for example.
#
# Sockets have their own vocabulary:
#
# **domain:** The family of protocols:
# *   Socket::PF_INET
# *   Socket::PF_INET6
# *   Socket::PF_UNIX
# *   etc.
#
# **type:** The type of communications between the two endpoints, typically
# *   Socket::SOCK_STREAM
# *   Socket::SOCK_DGRAM.
#
# **protocol:** Typically *zero*. This may be used to identify a variant of a
# protocol.
#
# **hostname:** The identifier of a network interface:
# *   a string (hostname, IPv4 or IPv6 address or `broadcast` which specifies a
#     broadcast address)
# *   a zero-length string which specifies INADDR_ANY
# *   an integer (interpreted as binary address in host byte order).
#
# ### Quick start
#
# Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
# of sockets comparatively to the equivalent C programming interface.
#
# Let's create an internet socket using the IPv4 protocol in a C-like manner:
#
#     require 'socket'
#
#     s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
#     s.connect Socket.pack_sockaddr_in(80, 'example.com')
#
# You could also use the TCPSocket class:
#
#     s = TCPSocket.new 'example.com', 80
#
# A simple server might look like this:
#
#     require 'socket'
#
#     server = TCPServer.new 2000 # Server bound to port 2000
#
#     loop do
#       client = server.accept    # Wait for a client to connect
#       client.puts "Hello !"
#       client.puts "Time is #{Time.now}"
#       client.close
#     end
#
# A simple client may look like this:
#
#     require 'socket'
#
#     s = TCPSocket.new 'localhost', 2000
#
#     while line = s.gets # Read lines from socket
#       puts line         # and print them
#     end
#
#     s.close             # close socket when done
#
# ### Exception Handling
#
# Ruby's Socket implementation raises exceptions based on the error generated by
# the system dependent implementation.  This is why the methods are documented
# in a way that isolate Unix-based system exceptions from Windows based
# exceptions. If more information on a particular exception is needed, please
# refer to the Unix manual pages or the Windows WinSock reference.
#
# ### Convenience methods
#
# Although the general way to create socket is Socket.new, there are several
# methods of socket creation for most cases.
#
# TCP client socket
# :   Socket.tcp, TCPSocket.open
#
# TCP server socket
# :   Socket.tcp_server_loop, TCPServer.open
#
# UNIX client socket
# :   Socket.unix, UNIXSocket.open
#
# UNIX server socket
# :   Socket.unix_server_loop, UNIXServer.open
#
#
# ### Documentation by
#
# *   Zach Dennis
# *   Sam Roberts
# *   *Programming Ruby* from The Pragmatic Bookshelf.
#
# Much material in this documentation is taken with permission from *Programming
# Ruby* from The Pragmatic Bookshelf.
#
class Socket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - accept_loop(*sockets) { |socket, client_addrinfo| ... }
  # -->
  # yield socket and client address for each a connection accepted via given
  # sockets.
  #
  # The arguments are a list of sockets. The individual argument should be a
  # socket or an array of sockets.
  #
  # This method yields the block sequentially. It means that the next connection
  # is not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  def self.accept_loop: (*_ToIO sockets) { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) => array
  # -->
  # Obtains address information for *nodename*:*servname*.
  #
  # Note that Addrinfo.getaddrinfo provides the same functionality in an object
  # oriented style.
  #
  # *family* should be an address family such as: :INET, :INET6, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the family, and defaults to 0 for
  # the family.
  #
  # *flags* should be bitwise OR of Socket::AI_* constants.
  #
  #     Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
  #     #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #
  #     Socket.getaddrinfo("localhost", nil)
  #     #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
  #
  # *reverse_lookup* directs the form of the third element, and has to be one of
  # below.  If *reverse_lookup* is omitted, the default value is `nil`.
  #
  #     +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
  #     +false+, +:numeric+:  hostname is the same as numeric address.
  #     +nil+:              obey to the current +do_not_reverse_lookup+ flag.
  #
  # If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
  #
  def self.getaddrinfo: (String peer, String | Integer | nil protocol, ?Integer | Symbol | nil family, ?Integer | Symbol | nil socktype, ?Integer | Symbol | nil protocol, ?Integer | nil flags) -> [ String, Integer, String, String, Integer, Integer, Integer ]
                      | (String? peer, String | Integer protocol, ?Integer | Symbol | nil family, ?Integer | Symbol | nil socktype, ?Integer | Symbol | nil protocol, ?Integer | nil flags) -> [ String, Integer, String, String, Integer, Integer, Integer ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostbyaddr(address_string [, address_family]) => hostent
  # -->
  # Use Addrinfo#getnameinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyaddr() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  # This method obtains the host information for *address*.
  #
  #     p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
  #     #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]
  #
  #     p Socket.gethostbyaddr([127,0,0,1].pack("CCCC"))
  #     ["localhost", [], 2, "\x7F\x00\x00\x01"]
  #     p Socket.gethostbyaddr(([0]*15+[1]).pack("C"*16))
  #     #=> ["localhost", ["ip6-localhost", "ip6-loopback"], 10,
  #          "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"]
  #
  def self.gethostbyaddr: (String ip) -> [ String, Array[String], Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]
  # -->
  # Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   The 3rd element of the result is the address family of the first address.
  #     The address families of the rest of the addresses are not returned.
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyname() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  # This method obtains the host information for *hostname*.
  #
  #     p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]
  #
  def self.gethostbyname: (String name) -> [ String, Array[String], Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostname => hostname
  # -->
  # Returns the hostname.
  #
  #     p Socket.gethostname #=> "hal"
  #
  # Note that it is not guaranteed to be able to convert to IP address using
  # gethostbyname, getaddrinfo, etc. If you need local IP address, use
  # Socket.ip_address_list.
  #
  def self.gethostname: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - Socket.getifaddrs => [ifaddr1, ...]
  # -->
  # Returns an array of interface addresses. An element of the array is an
  # instance of Socket::Ifaddr.
  #
  # This method can be used to find multicast-enabled interfaces:
  #
  #     pp Socket.getifaddrs.reject {|ifaddr|
  #       !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
  #     }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
  #     #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
  #     #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]
  #
  # Example result on GNU/Linux:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
  #     #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]
  #
  # Example result on FreeBSD:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
  #     #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]
  #
  def self.getifaddrs: () -> Array[Socket::Ifaddr]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getnameinfo(sockaddr [, flags]) => [hostname, servicename]
  # -->
  # Obtains name information for *sockaddr*.
  #
  # *sockaddr* should be one of follows.
  # *   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
  # *   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
  # *   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]
  #
  # *flags* should be bitwise OR of Socket::NI_* constants.
  #
  # Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.
  #
  #     Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]
  #
  # If Addrinfo object is preferred, use Addrinfo#getnameinfo.
  #
  def self.getnameinfo: ([ String, Integer, String ]) -> Array[String]
                      | ([ String, Integer, String, String ]) -> Array[String]
                      | (String sockaddr) -> Array[String]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getservbyname(service_name)                => port_number
  #   - Socket.getservbyname(service_name, protocol_name) => port_number
  # -->
  # Obtains the port number for *service_name*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyname("smtp")          #=> 25
  #     Socket.getservbyname("shell")         #=> 514
  #     Socket.getservbyname("syslog", "udp") #=> 514
  #
  def self.getservbyname: (String service_proto) -> Integer
                        | (String service_proto, String layer4_proto) -> Integer

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getservbyport(port [, protocol_name]) => service
  # -->
  # Obtains the port number for *port*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyport(80)         #=> "www"
  #     Socket.getservbyport(514, "tcp") #=> "shell"
  #     Socket.getservbyport(514, "udp") #=> "syslog"
  #
  def self.getservbyport: (Integer service_port) -> String
                        | (Integer service_port, String layer4_proto) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.ip_address_list => array
  # -->
  # Returns local IP addresses as an array.
  #
  # The array contains Addrinfo objects.
  #
  #     pp Socket.ip_address_list
  #     #=> [#<Addrinfo: 127.0.0.1>,
  #          #<Addrinfo: 192.168.0.128>,
  #          #<Addrinfo: ::1>,
  #          ...]
  #
  def self.ip_address_list: () -> Array[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_in(port, host)      => sockaddr
  #   - Socket.pack_sockaddr_in(port, host) => sockaddr
  # -->
  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  def self.pack_sockaddr_in: (Integer port, String ip) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_un(path)      => sockaddr
  #   - Socket.pack_sockaddr_un(path) => sockaddr
  # -->
  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  def self.pack_sockaddr_un: (String sockpath) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.pair(domain, type, protocol)       => [socket1, socket2]
  #   - Socket.socketpair(domain, type, protocol) => [socket1, socket2]
  # -->
  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  def self.pair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_in(port, host)      => sockaddr
  #   - Socket.pack_sockaddr_in(port, host) => sockaddr
  # -->
  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  def self.sockaddr_in: (Integer port, String ip) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_un(path)      => sockaddr
  #   - Socket.pack_sockaddr_un(path) => sockaddr
  # -->
  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  def self.sockaddr_un: (String sockpath) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.pair(domain, type, protocol)       => [socket1, socket2]
  #   - Socket.socketpair(domain, type, protocol) => [socket1, socket2]
  # -->
  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  def self.socketpair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }
  #   - Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])
  # -->
  # creates a new socket object connected to host:port using TCP/IP.
  #
  # Starting from Ruby 3.4, this method operates according to the Happy Eyeballs
  # Version 2 ([RFC 8305](https://datatracker.ietf.org/doc/html/rfc8305))
  # algorithm by default.
  #
  # For details on Happy Eyeballs Version 2, see
  # [Socket.tcp_fast_fallback=](rdoc-ref:Socket.tcp_fast_fallback=).
  #
  # To make it behave the same as in Ruby 3.3 and earlier, explicitly specify the
  # option fast_fallback:false. Or, setting Socket.tcp_fast_fallback=false will
  # disable Happy Eyeballs Version 2 not only for this method but for all Socket
  # globally.
  #
  # If local_host:local_port is given, the socket is bound to it.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :resolv_timeout
  # :   Specifies the timeout in seconds from when the hostname resolution starts.
  #
  # :connect_timeout
  # :   This method sequentially attempts connecting to all candidate destination
  #     addresses.
  #     The `connect_timeout` specifies the timeout in seconds from the start of
  #     the connection attempt to the last candidate.
  #     By default, all connection attempts continue until the timeout occurs.
  #     When `fast_fallback:false` is explicitly specified,
  #     a timeout is set for each connection attempt and any connection attempt
  #     that exceeds its timeout will be canceled.
  #
  # :fast_fallback
  # :   Enables the Happy Eyeballs Version 2 algorithm (enabled by default).
  #
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     Socket.tcp("www.ruby-lang.org", 80) {|sock|
  #       sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       sock.close_write
  #       puts sock.read
  #     }
  #
  def self.tcp: (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Time::_Timeout, ?connect_timeout: Time::_Timeout) -> instance
              | (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Time::_Timeout, ?connect_timeout: Time::_Timeout) { (instance) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcp_server_loop(host=nil, port) { |socket, client_addrinfo| ... }
  # -->
  # creates a TCP/IP server on *port* and calls the block for each connection
  # accepted. The block is called with a socket and a client_address as an
  # Addrinfo object.
  #
  # If *host* is specified, it is used with *port* to determine the server
  # addresses.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it explicitly.
  #
  # This method calls the block sequentially. It means that the next connection is
  # not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  # Note that Addrinfo.getaddrinfo is used to determine the server socket
  # addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
  # IPv6 address for example, all of them are used. Socket.tcp_server_loop
  # succeeds if one socket can be used at least.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  #     # Threaded echo server
  #     # It services multiple clients at a time.
  #     # Note that it may accept connections too much.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       Thread.new {
  #         begin
  #           IO.copy_stream(sock, sock)
  #         ensure
  #           sock.close
  #         end
  #       }
  #     }
  #
  def self.tcp_server_loop: (?String host, Integer port) { (instance, Addrinfo) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcp_server_sockets(host=nil, port) { |sockets| ... }
  # -->
  # creates TCP/IP server sockets for *host* and *port*. *host* is optional.
  #
  # If no block given, it returns an array of listening sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If *port* is 0, actual port number is chosen dynamically. However all sockets
  # in the result has same port number.
  #
  #     # tcp_server_sockets returns two sockets.
  #     sockets = Socket.tcp_server_sockets(1296)
  #     p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #
  #     # The sockets contains IPv6 and IPv4 sockets.
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:1296 TCP>
  #     #   #<Addrinfo: 0.0.0.0:1296 TCP>
  #
  #     # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
  #     sockets = Socket.tcp_server_sockets(0)
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:53114 TCP>
  #     #   #<Addrinfo: 0.0.0.0:53114 TCP>
  #
  #     # The block is called with the sockets.
  #     Socket.tcp_server_sockets(0) {|sockets|
  #       p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #     }
  #
  def self.tcp_server_sockets: (?String host, Integer port) -> Array[TCPServer]
                             | (?String host, Integer port) { (Array[TCPServer]) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_loop(port) {|msg, msg_src| ... }
  #   - Socket.udp_server_loop(host, port) {|msg, msg_src| ... }
  # -->
  # creates a UDP/IP server on *port* and calls the block for each message
  # arrived. The block is called with the message and its source information.
  #
  # This method allocates sockets internally using *port*. If *host* is specified,
  # it is used conjunction with *port* to determine the server addresses.
  #
  # The *msg* is a string.
  #
  # The *msg_src* is a Socket::UDPSource object. It is used for reply.
  #
  #     # UDP/IP echo server.
  #     Socket.udp_server_loop(9261) {|msg, msg_src|
  #       msg_src.reply msg
  #     }
  #
  def self.udp_server_loop: (?String host, Integer port) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }
  # -->
  # Run UDP/IP server loop on the given sockets.
  #
  # The return value of Socket.udp_server_sockets is appropriate for the argument.
  #
  # It calls the block for each message received.
  #
  def self.udp_server_loop_on: (UDPSocket sockets) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_recv(sockets) {|msg, msg_src| ... }
  # -->
  # Receive UDP/IP packets from the given *sockets*. For each packet received, the
  # block is called.
  #
  # The block receives *msg* and *msg_src*. *msg* is a string which is the payload
  # of the received packet. *msg_src* is a Socket::UDPSource object which is used
  # for reply.
  #
  # Socket.udp_server_loop can be implemented using this method as follows.
  #
  #     udp_server_sockets(host, port) {|sockets|
  #       loop {
  #         readable, _, _ = IO.select(sockets)
  #         udp_server_recv(readable) {|msg, msg_src| ... }
  #       }
  #     }
  #
  def self.udp_server_recv: (Array[UDPSocket] sockets) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_sockets([host, ] port)
  # -->
  # Creates UDP/IP sockets for a UDP server.
  #
  # If no block given, it returns an array of sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The sockets are closed when this method returns.
  #
  # If *port* is zero, some port is chosen. But the chosen port is used for the
  # all sockets.
  #
  #     # UDP/IP echo server
  #     Socket.udp_server_sockets(0) {|sockets|
  #       p sockets.first.local_address.ip_port     #=> 32963
  #       Socket.udp_server_loop_on(sockets) {|msg, msg_src|
  #         msg_src.reply msg
  #       }
  #     }
  #
  def self.udp_server_sockets: (?String host, Integer port) { (UDPSocket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix(path) { |socket| ... }
  # -->
  # creates a new socket connected to path using UNIX socket socket.
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     # talk to /tmp/sock socket.
  #     Socket.unix("/tmp/sock") {|sock|
  #       t = Thread.new { IO.copy_stream(sock, STDOUT) }
  #       IO.copy_stream(STDIN, sock)
  #       t.join
  #     }
  #
  def self.unix: (String path) -> UNIXSocket
               | (String path) { (UNIXSocket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix_server_loop(path) { |socket, client_addrinfo| ... }
  # -->
  # creates a UNIX socket server on *path*. It calls the block for each socket
  # accepted.
  #
  # If *host* is specified, it is used with *port* to determine the server ports.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it.
  #
  # This method deletes the socket file pointed by *path* at first if the file is
  # a socket file and it is owned by the user of the application. This is safe
  # only if the directory of *path* is not changed by a malicious user. So don't
  # use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
  # /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  def self.unix_server_loop: (String path) { (UNIXSocket, Addrinfo) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix_server_socket(path) { |s| ... }
  # -->
  # creates a UNIX server socket on *path*
  #
  # If no block given, it returns a listening socket.
  #
  # If a block is given, it is called with the socket and the block value is
  # returned. When the block exits, the socket is closed and the socket file is
  # removed.
  #
  #     socket = Socket.unix_server_socket("/tmp/s")
  #     p socket                  #=> #<Socket:fd 3>
  #     p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>
  #
  #     Socket.unix_server_socket("/tmp/sock") {|s|
  #       p s                     #=> #<Socket:fd 3>
  #       p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
  #     }
  #
  def self.unix_server_socket: (String path) -> Socket
                             | (String path) { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.unpack_sockaddr_in(sockaddr) => [port, ip_address]
  # -->
  # Unpacks *sockaddr* into port and ip_address.
  #
  # *sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.
  #
  #     sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
  #     p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]
  #
  def self.unpack_sockaddr_in: (String | Addrinfo sockaddr) -> [ Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.unpack_sockaddr_un(sockaddr) => path
  # -->
  # Unpacks *sockaddr* into path.
  #
  # *sockaddr* should be a string or an addrinfo for AF_UNIX.
  #
  #     sockaddr = Socket.sockaddr_un("/tmp/sock")
  #     p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"
  #
  def self.unpack_sockaddr_un: (String path) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.accept => [client_socket, client_addrinfo]
  # -->
  # Accepts a next connection. Returns a new Socket object and Addrinfo object.
  #
  #     serv = Socket.new(:INET, :STREAM, 0)
  #     serv.listen(5)
  #     c = Socket.new(:INET, :STREAM, 0)
  #     c.connect(serv.connect_address)
  #     p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]
  #
  def accept: () -> [ Socket, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.accept_nonblock([options]) => [client_socket, client_addrinfo]
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an array containing the accepted socket
  # for the incoming connection, *client_socket*, and an Addrinfo,
  # *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     begin # emulate blocking accept
  #       client_socket, client_addrinfo = socket.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([socket])
  #       retry
  #     end
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *accept_nonblock* fails.
  #
  # Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
  # including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> ([ Socket, Addrinfo ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.bind(local_sockaddr) => 0
  # -->
  # Binds to the given local address.
  #
  # ### Parameter
  # *   `local_sockaddr` - the `struct` sockaddr contained in a string or an
  #     Addrinfo object
  #
  # ### Example
  #     require 'socket'
  #
  #     # use Addrinfo
  #     socket = Socket.new(:INET, :STREAM, 0)
  #     socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
  #     p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>
  #
  #     # use struct sockaddr
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *bind* fails:
  # *   Errno::EACCES - the specified *sockaddr* is protected and the current user
  #     does not have permission to bind to it
  # *   Errno::EADDRINUSE - the specified *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the family of the calling `socket`
  # *   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
  # *   Errno::EFAULT - the *sockaddr* argument cannot be accessed
  # *   Errno::EINVAL - the `socket` is already bound to an address, and the
  #     protocol does not support binding to the new *sockaddr* or the `socket`
  #     has been shut down.
  # *   Errno::EINVAL - the address length is not a valid length for the address
  #     family
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
  #     binding to an address
  #
  # On unix-based based systems if the address family of the calling `socket` is
  # Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
  # fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
  # *   Errno::EISDIR - same as Errno::EDESTADDRREQ
  # *   Errno::EIO - an i/o error occurred
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  # *   Errno::EROFS - the name would reside on a read only filesystem
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *bind* fails:
  # *   Errno::ENETDOWN-- the network is down
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
  #     this computer
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space addressed
  # *   Errno::EINVAL - the `socket` is already bound to an address
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  #
  # ### See
  # *   bind manual pages on unix-based systems
  # *   bind function in Microsoft's Winsock functions reference
  #
  def bind: (String | Addrinfo local_sockaddr) -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.connect(remote_sockaddr) => 0
  # -->
  # Requests a connection to be made on the given `remote_sockaddr`. Returns 0 if
  # successful, otherwise an exception is raised.
  #
  # ### Parameter
  # *   `remote_sockaddr` - the `struct` sockaddr contained in a string or
  #     Addrinfo object
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
  #     socket.connect( sockaddr )
  #     socket.write( "GET / HTTP/1.0\r\n\r\n" )
  #     results = socket.read
  #
  # ### Unix-based Exceptions
  # On unix-based systems the following system exceptions may be raised if the
  # call to *connect* fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EADDRINUSE - the *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the address family of the specified `socket`
  # *   Errno::EALREADY - a connection is already in progress for the specified
  #     socket
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::ECONNRESET - the remote host reset the connection request
  # *   Errno::EFAULT - the *sockaddr* cannot be accessed
  # *   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
  #     because the host is down or a remote router cannot reach it)
  # *   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
  #     connection cannot be immediately established; the connection will be
  #     established asynchronously
  # *   Errno::EINTR - the attempt to establish the connection was interrupted by
  #     delivery of a signal that was caught; the connection will be established
  #     asynchronously
  # *   Errno::EISCONN - the specified `socket` is already connected
  # *   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
  #     length for the address family or there is an invalid family in *sockaddr*
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENETDOWN - the local interface used to reach the destination is
  #     down
  # *   Errno::ENETUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
  #     connected
  # *   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
  #     bound to the specified peer address
  # *   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
  #     was made.
  #
  # On unix-based systems if the address family of the calling `socket` is AF_UNIX
  # the follow exceptions may be raised if the call to *connect* fails:
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     file system
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *connect* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EINTR - the socket was cancelled
  # *   Errno::EINPROGRESS - a blocking socket is in progress or the service
  #     provider is still processing a callback function. Or a nonblocking connect
  #     call is in progress on the `socket`.
  # *   Errno::EALREADY - see Errno::EINVAL
  # *   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
  #     ADDR_ANY TODO check ADDRANY TO INADDR_ANY
  # *   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
  #     with with this `socket`
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space address
  # *   Errno::EINVAL - the `socket` is a listening socket
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::ENETUNREACH - the network cannot be reached from this host at this
  #     time
  # *   Errno::EHOSTUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
  #     was made.
  # *   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
  #     connection cannot be completed immediately
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  #
  # ### See
  # *   connect manual pages on unix-based systems
  # *   connect function in Microsoft's Winsock functions reference
  #
  def connect: (String | Addrinfo remote_sockaddr) -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.connect_nonblock(remote_sockaddr, [options]) => 0
  # -->
  # Requests a connection to be made on the given `remote_sockaddr` after
  # O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
  # otherwise an exception is raised.
  #
  # ### Parameter
  # *   `remote_sockaddr` - the `struct` sockaddr contained in a string or
  #     Addrinfo object
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
  #     begin # emulate blocking connect
  #       socket.connect_nonblock(sockaddr)
  #     rescue IO::WaitWritable
  #       IO.select(nil, [socket]) # wait 3-way handshake completion
  #       begin
  #         socket.connect_nonblock(sockaddr) # check connection failure
  #       rescue Errno::EISCONN
  #       end
  #     end
  #     socket.write("GET / HTTP/1.0\r\n\r\n")
  #     results = socket.read
  #
  # Refer to Socket#connect for the exceptions that may be thrown if the call to
  # *connect_nonblock* fails.
  #
  # Socket#connect_nonblock may raise any error corresponding to connect(2)
  # failure, including Errno::EINPROGRESS.
  #
  # If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
  # IO::WaitWritable can be used to rescue the exceptions for retrying
  # connect_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # connect_nonblock should not raise an IO::WaitWritable exception, but return
  # the symbol `:wait_writable` instead.
  #
  # ### See
  # *   Socket#connect
  #
  def connect_nonblock: (untyped addr, ?exception: untyped) -> (Integer | :wait_writable)

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - ipv6only!()
  # -->
  # enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.
  #
  def ipv6only!: () -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog_len) -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.recvfrom(maxlen) => [mesg, sender_addrinfo]
  #   - socket.recvfrom(maxlen, flags) => [mesg, sender_addrinfo]
  # -->
  # Receives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client, client_addrinfo = socket.accept
  #     data = client.recvfrom( 20 )[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *recvfrom* fails:
  # *   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
  #     no data is waiting to be received; or MSG_OOB is set and no out-of-band
  #     data is available and either the `socket` file descriptor is marked as
  #     O_NONBLOCK or the `socket` does not support blocking to wait for
  #     out-of-band-data
  # *   Errno::EWOULDBLOCK - see Errno::EAGAIN
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNRESET - a connection was forcibly closed by a peer
  # *   Errno::EFAULT - the socket's internal buffer, address or address length
  #     cannot be accessed or written
  # *   Errno::EINTR - a signal interrupted *recvfrom* before any data was
  #     available
  # *   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
  #     available
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     filesystem
  # *   Errno::ENOBUFS - insufficient resources were available in the system to
  #     perform the operation
  # *   Errno::ENOMEM - insufficient memory was available to fulfill the request
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
  #     is not connected
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
  #     type
  # *   Errno::ETIMEDOUT - the connection timed out during connection
  #     establishment or due to a transmission timeout on an active connection
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *recvfrom* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EFAULT - the internal buffer and from parameters on `socket` are
  #     not part of the user address space, or the internal fromlen parameter is
  #     too small to accommodate the peer address
  # *   Errno::EINTR - the (blocking) call was cancelled by an internal call to
  #     the WinSock function WSACancelBlockingCall
  # *   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
  #     the service provider is still processing a callback function
  # *   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
  #     unknown flag was specified, or MSG_OOB was specified for a socket with
  #     SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
  #     len parameter on `socket` was zero or negative
  # *   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
  #     not permitted with a connected socket on a socket that is connection
  #     oriented or connectionless.
  # *   Errno::ENETRESET - the connection has been broken due to the keep-alive
  #     activity detecting a failure while the operation was in progress.
  # *   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
  #     stream-style such as type SOCK_STREAM. OOB data is not supported in the
  #     communication domain associated with `socket`, or `socket` is
  #     unidirectional and supports only send operations
  # *   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
  #     *recvfrom* on a socket after *shutdown* has been invoked.
  # *   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
  #     *recvfrom* would block.
  # *   Errno::EMSGSIZE - the message was too large to fit into the specified
  #     buffer and was truncated.
  # *   Errno::ETIMEDOUT - the connection has been dropped, because of a network
  #     failure or because the system on the other end went down without notice
  # *   Errno::ECONNRESET - the virtual circuit was reset by the remote side
  #     executing a hard or abortive close. The application should close the
  #     socket; it is no longer usable. On a UDP-datagram socket this error
  #     indicates a previous send operation resulted in an ICMP Port Unreachable
  #     message.
  #
  def recvfrom: (Integer maxlen, ?Integer flags) -> [ String, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.recvfrom_nonblock(maxlen[, flags[, outbuf[, opts]]]) => [mesg, sender_addrinfo]
  # -->
  # Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
  # is set for the underlying file descriptor. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # When recvfrom(2) returns 0, Socket#recv_nonblock returns nil. In most cases it
  # means the connection was closed, but for UDP connections it may mean an empty
  # packet was received, as the underlying API makes it impossible to distinguish
  # these two cases.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `outbuf` - destination String buffer
  # *   `opts` - keyword hash, supporting `exception: false`
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     client, client_addrinfo = socket.accept
  #     begin # emulate blocking recvfrom
  #       pair = client.recvfrom_nonblock(20)
  #     rescue IO::WaitReadable
  #       IO.select([client])
  #       retry
  #     end
  #     data = pair[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recvfrom_nonblock* fails.
  #
  # Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recvfrom_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recvfrom_nonblock: (Integer maxlen, ?Integer flags, ?untyped outbuf, ?exception: boolish) -> ([ String, Addrinfo ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.sysaccept => [client_socket_fd, client_addrinfo]
  # -->
  # Accepts an incoming connection returning an array containing the (integer)
  # file descriptor for the incoming connection, *client_socket_fd*, and an
  # Addrinfo, *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client_fd, client_addrinfo = socket.sysaccept
  #     client_socket = Socket.for_fd( client_fd )
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *sysaccept* fails.
  #
  # ### See
  # *   Socket#accept
  #
  def sysaccept: () -> [ Integer, Addrinfo ]

  private

  def __accept_nonblock: (untyped) -> untyped

  def __connect_nonblock: (untyped, untyped) -> untyped

  def __recvfrom_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.new(domain, socktype [, protocol]) => socket
  # -->
  # Creates a new socket object.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* is optional and should be a protocol defined in the domain. If
  # protocol is not given, 0 is used internally.
  #
  #     Socket.new(:INET, :STREAM) # TCP socket
  #     Socket.new(:INET, :DGRAM)  # UDP socket
  #     Socket.new(:UNIX, :STREAM) # UNIX stream socket
  #     Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket
  #
  def initialize: (Symbol | Integer domain, Symbol | Integer socktype, ?Integer protocol) -> untyped
end

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Interface to kernel crypto API
#
Socket::AF_ALG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AppleTalk protocol
#
Socket::AF_APPLETALK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Asynchronous Transfer Mode
#
Socket::AF_ATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AX.25 protocol
#
Socket::AF_AX25: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Bluetooth low-level socket protocol
#
Socket::AF_BLUETOOTH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Controller Area Network automotive bus protocol
#
Socket::AF_CAN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (now ITU-T) protocols
#
Socket::AF_CCITT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# MIT CHAOS protocols
#
Socket::AF_CHAOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Computer Network Technology
#
Socket::AF_CNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Connection-oriented IP
#
Socket::AF_COIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Datakit protocol
#
Socket::AF_DATAKIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DECnet protocol
#
Socket::AF_DEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DECnet protocol
#
Socket::AF_DECnet: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DEC Direct Data Link Interface protocol
#
Socket::AF_DLI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (ITU-T) E.164 recommendation
#
Socket::AF_E164: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# European Computer Manufacturers protocols
#
Socket::AF_ECMA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NSC Hyperchannel protocol
#
Socket::AF_HYLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# InfiniBand native addressing
#
Socket::AF_IB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ARPANET IMP protocol
#
Socket::AF_IMPLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv4 protocol
#
Socket::AF_INET: Integer

# <!-- rdoc-file=lib/ipaddr.rb -->
# IPv6 protocol family
#
Socket::AF_INET6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPX protocol
#
Socket::AF_IPX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Integrated Services Digital Network
#
Socket::AF_ISDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::AF_ISO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# KCM (kernel connection multiplexor) interface
#
Socket::AF_KCM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Key management protocol, originally developed for usage with IPsec
#
Socket::AF_KEY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Local Area Transport protocol
#
Socket::AF_LAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Link layer interface
#
Socket::AF_LINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Logical  link control (IEEE 802.2 LLC) protocol
#
Socket::AF_LLC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Host-internal protocols
#
Socket::AF_LOCAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum address family for this platform
#
Socket::AF_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multiprotocol Label Switching
#
Socket::AF_MPLS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Native ATM access
#
Socket::AF_NATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Network driver raw access
#
Socket::AF_NDRV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NetBIOS
#
Socket::AF_NETBIOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Netgraph sockets
#
Socket::AF_NETGRAPH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Kernel user interface device
#
Socket::AF_NETLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XEROX NS protocols
#
Socket::AF_NS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::AF_OSI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Direct link-layer access
#
Socket::AF_PACKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Point-to-Point Protocol
#
Socket::AF_PPP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE)
#
Socket::AF_PPPOX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::AF_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Reliable Datagram Sockets (RDS) protocol
#
Socket::AF_RDS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Internal routing protocol
#
Socket::AF_ROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Simple Internet Protocol
#
Socket::AF_SIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IBM SNA protocol
#
Socket::AF_SNA: Integer
Socket::AF_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TIPC, "cluster domain sockets" protocol
#
Socket::AF_TIPC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UNIX sockets
#
Socket::AF_UNIX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unspecified protocol, any supported address family
#
Socket::AF_UNSPEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# VSOCK (originally "VMWare VSockets") protocol for hypervisor-guest
# communication
#
Socket::AF_VSOCK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XDP (express data path) interface
#
Socket::AF_XDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept only if any address is assigned
#
Socket::AI_ADDRCONFIG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow all addresses
#
Socket::AI_ALL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Fill in the canonical name
#
Socket::AI_CANONNAME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default flags for getaddrinfo
#
Socket::AI_DEFAULT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Valid flag mask for getaddrinfo (not for application use)
#
Socket::AI_MASK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Prevent host name resolution
#
Socket::AI_NUMERICHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Prevent service name resolution
#
Socket::AI_NUMERICSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get address to use with bind()
#
Socket::AI_PASSIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept IPv4-mapped IPv6 addresses
#
Socket::AI_V4MAPPED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept IPv4 mapped addresses if the kernel supports it
#
Socket::AI_V4MAPPED_CFG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Address family for hostname not supported
#
Socket::EAI_ADDRFAMILY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Temporary failure in name resolution
#
Socket::EAI_AGAIN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Invalid flags
#
Socket::EAI_BADFLAGS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Invalid value for hints
#
Socket::EAI_BADHINTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Non-recoverable failure in name resolution
#
Socket::EAI_FAIL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Address family not supported
#
Socket::EAI_FAMILY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum error code from getaddrinfo
#
Socket::EAI_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Memory allocation failure
#
Socket::EAI_MEMORY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# No address associated with hostname
#
Socket::EAI_NODATA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hostname nor servname, or not known
#
Socket::EAI_NONAME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Argument buffer overflow
#
Socket::EAI_OVERFLOW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Resolved protocol is unknown
#
Socket::EAI_PROTOCOL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Servname not supported for socket type
#
Socket::EAI_SERVICE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket type not supported
#
Socket::EAI_SOCKTYPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# System error returned in errno
#
Socket::EAI_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# 802.1Q VLAN device
#
Socket::IFF_802_1Q_VLAN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# receive all multicast packets
#
Socket::IFF_ALLMULTI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# use alternate physical connection
#
Socket::IFF_ALTPHYS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# auto media select active
#
Socket::IFF_AUTOMEDIA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# bonding master or slave
#
Socket::IFF_BONDING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# device used as bridge port
#
Socket::IFF_BRIDGE_PORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# broadcast address valid
#
Socket::IFF_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# flags not changeable
#
Socket::IFF_CANTCHANGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# unconfigurable using ioctl(2)
#
Socket::IFF_CANTCONFIG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# turn on debugging
#
Socket::IFF_DEBUG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# disable netpoll at run-time
#
Socket::IFF_DISABLE_NETPOLL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# disallow bridging this ether dev
#
Socket::IFF_DONT_BRIDGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# driver signals dormant
#
Socket::IFF_DORMANT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# tx hardware queue is full
#
Socket::IFF_DRV_OACTIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# resources allocated
#
Socket::IFF_DRV_RUNNING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# interface is winding down
#
Socket::IFF_DYING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# dialup device with changing addresses
#
Socket::IFF_DYNAMIC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ethernet bridging device
#
Socket::IFF_EBRIDGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# echo sent packets
#
Socket::IFF_ECHO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISATAP interface (RFC4214)
#
Socket::IFF_ISATAP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 0
#
Socket::IFF_LINK0: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 1
#
Socket::IFF_LINK1: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 2
#
Socket::IFF_LINK2: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# hardware address change when it's running
#
Socket::IFF_LIVE_ADDR_CHANGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# loopback net
#
Socket::IFF_LOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# driver signals L1 up
#
Socket::IFF_LOWER_UP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# device used as macvlan port
#
Socket::IFF_MACVLAN_PORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# master of a load balancer
#
Socket::IFF_MASTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# bonding master, 802.3ad.
#
Socket::IFF_MASTER_8023AD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# bonding master, balance-alb.
#
Socket::IFF_MASTER_ALB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# bonding master, ARP mon in use
#
Socket::IFF_MASTER_ARPMON: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# user-requested monitor mode
#
Socket::IFF_MONITOR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# supports multicast
#
Socket::IFF_MULTICAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# no address resolution protocol
#
Socket::IFF_NOARP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# avoid use of trailers
#
Socket::IFF_NOTRAILERS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# transmission in progress
#
Socket::IFF_OACTIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# device used as Open vSwitch datapath port
#
Socket::IFF_OVS_DATAPATH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# point-to-point link
#
Socket::IFF_POINTOPOINT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# can set media type
#
Socket::IFF_PORTSEL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# user-requested promisc mode
#
Socket::IFF_PPROMISC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# receive all packets
#
Socket::IFF_PROMISC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# interface is being renamed
#
Socket::IFF_RENAMING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# routing entry installed
#
Socket::IFF_ROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# resources allocated
#
Socket::IFF_RUNNING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# can't hear own transmissions
#
Socket::IFF_SIMPLEX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# slave of a load balancer
#
Socket::IFF_SLAVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# bonding slave not the curr. active
#
Socket::IFF_SLAVE_INACTIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# need ARPs for validation
#
Socket::IFF_SLAVE_NEEDARP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# interface manages own routes
#
Socket::IFF_SMART: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# static ARP
#
Socket::IFF_STATICARP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# sending custom FCS
#
Socket::IFF_SUPP_NOFCS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# used as team port
#
Socket::IFF_TEAM_PORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# sharing skbs on transmit
#
Socket::IFF_TX_SKB_SHARING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# unicast filtering
#
Socket::IFF_UNICAST_FLT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# interface is up
#
Socket::IFF_UP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# volatile flags
#
Socket::IFF_VOLATILE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# WAN HDLC device
#
Socket::IFF_WAN_HDLC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# dev_hard_start_xmit() is allowed to release skb->dst
#
Socket::IFF_XMIT_DST_RELEASE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum interface name size
#
Socket::IFNAMSIZ: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum interface name size
#
Socket::IF_NAMESIZE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multicast group for all systems on this subset
#
Socket::INADDR_ALLHOSTS_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A socket bound to INADDR_ANY receives packets from all interfaces and sends
# from the default IP address
#
Socket::INADDR_ANY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The network broadcast address
#
Socket::INADDR_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The loopback address
#
Socket::INADDR_LOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The last local network multicast group
#
Socket::INADDR_MAX_LOCAL_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A bitmask for matching no valid IP address
#
Socket::INADDR_NONE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The reserved multicast group
#
Socket::INADDR_UNSPEC_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of an IPv6 address string
#
Socket::INET6_ADDRSTRLEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of an IPv4 address string
#
Socket::INET_ADDRSTRLEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default minimum address for bind or connect
#
Socket::IPPORT_RESERVED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default maximum address for bind or connect
#
Socket::IPPORT_USERRESERVED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 auth header
#
Socket::IPPROTO_AH: Integer
Socket::IPPROTO_BIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 destination option
#
Socket::IPPROTO_DSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Exterior Gateway Protocol
#
Socket::IPPROTO_EGP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO cnlp
#
Socket::IPPROTO_EON: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 Encapsulated Security Payload
#
Socket::IPPROTO_ESP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 fragmentation header
#
Socket::IPPROTO_FRAGMENT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Gateway to Gateway Protocol
#
Socket::IPPROTO_GGP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# "hello" routing protocol
#
Socket::IPPROTO_HELLO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 hop-by-hop options
#
Socket::IPPROTO_HOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Control message protocol
#
Socket::IPPROTO_ICMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ICMP6
#
Socket::IPPROTO_ICMPV6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XNS IDP
#
Socket::IPPROTO_IDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Group Management Protocol
#
Socket::IPPROTO_IGMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Dummy protocol for IP
#
Socket::IPPROTO_IP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 header
#
Socket::IPPROTO_IPV6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum IPPROTO constant
#
Socket::IPPROTO_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Sun net disk protocol
#
Socket::IPPROTO_ND: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 no next header
#
Socket::IPPROTO_NONE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::IPPROTO_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Raw IP packet
#
Socket::IPPROTO_RAW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 routing header
#
Socket::IPPROTO_ROUTING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP
#
Socket::IPPROTO_TCP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO transport protocol class 4
#
Socket::IPPROTO_TP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UDP
#
Socket::IPPROTO_UDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Xpress Transport Protocol
#
Socket::IPPROTO_XTP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Checksum offset for raw sockets
#
Socket::IPV6_CHECKSUM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't fragment packets
#
Socket::IPV6_DONTFRAG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Destination option
#
Socket::IPV6_DSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hop limit
#
Socket::IPV6_HOPLIMIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hop-by-hop option
#
Socket::IPV6_HOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a group membership
#
Socket::IPV6_JOIN_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a group membership
#
Socket::IPV6_LEAVE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast hops
#
Socket::IPV6_MULTICAST_HOPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast interface
#
Socket::IPV6_MULTICAST_IF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast loopback
#
Socket::IPV6_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Next hop address
#
Socket::IPV6_NEXTHOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve current path MTU
#
Socket::IPV6_PATHMTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive packet information with datagram
#
Socket::IPV6_PKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP6 options for response
#
Socket::IPV6_RECVDSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive hop limit with datagram
#
Socket::IPV6_RECVHOPLIMIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive hop-by-hop options
#
Socket::IPV6_RECVHOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive current path MTU with datagram
#
Socket::IPV6_RECVPATHMTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive destination IP address and incoming interface
#
Socket::IPV6_RECVPKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive routing header
#
Socket::IPV6_RECVRTHDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive traffic class
#
Socket::IPV6_RECVTCLASS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allows removal of sticky routing headers
#
Socket::IPV6_RTHDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allows removal of sticky destination options header
#
Socket::IPV6_RTHDRDSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Routing header type 0
#
Socket::IPV6_RTHDR_TYPE_0: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Specify the traffic class
#
Socket::IPV6_TCLASS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 unicast hops
#
Socket::IPV6_UNICAST_HOPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use the minimum MTU size
#
Socket::IPV6_USE_MIN_MTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Only bind IPv6 with a wildcard bind
#
Socket::IPV6_V6ONLY: Integer
Socket::IPX_TYPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Add a multicast group membership
#
Socket::IP_ADD_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Add a multicast group membership
#
Socket::IP_ADD_SOURCE_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Block IPv4 multicast packets with a give source address
#
Socket::IP_BLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default multicast loopback
#
Socket::IP_DEFAULT_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default multicast TTL
#
Socket::IP_DEFAULT_MULTICAST_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't fragment packets
#
Socket::IP_DONTFRAG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Drop a multicast group membership
#
Socket::IP_DROP_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Drop a multicast group membership
#
Socket::IP_DROP_SOURCE_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow binding to nonexistent IP addresses
#
Socket::IP_FREEBIND: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Header is included with data
#
Socket::IP_HDRINCL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPsec security policy
#
Socket::IP_IPSEC_POLICY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum number multicast groups a socket can join
#
Socket::IP_MAX_MEMBERSHIPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Minimum TTL allowed for received packets
#
Socket::IP_MINTTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multicast source filtering
#
Socket::IP_MSFILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The Maximum Transmission Unit of the socket
#
Socket::IP_MTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Path MTU discovery
#
Socket::IP_MTU_DISCOVER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast interface
#
Socket::IP_MULTICAST_IF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast loopback
#
Socket::IP_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast TTL
#
Socket::IP_MULTICAST_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Force outgoing broadcast datagrams to have the undirected broadcast address
#
Socket::IP_ONESBCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP options to be included in packets
#
Socket::IP_OPTIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve security context with datagram
#
Socket::IP_PASSSEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive packet information with datagrams
#
Socket::IP_PKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive packet options with datagrams
#
Socket::IP_PKTOPTIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Always send DF frames
#
Socket::IP_PMTUDISC_DO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Never send DF frames
#
Socket::IP_PMTUDISC_DONT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use per-route hints
#
Socket::IP_PMTUDISC_WANT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the port range for sockets with unspecified port numbers
#
Socket::IP_PORTRANGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive IP destination address with datagram
#
Socket::IP_RECVDSTADDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Enable extended reliable error message passing
#
Socket::IP_RECVERR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive interface information with datagrams
#
Socket::IP_RECVIF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP options with datagram
#
Socket::IP_RECVOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP options for response
#
Socket::IP_RECVRETOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive link-layer address with datagrams
#
Socket::IP_RECVSLLA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive TOS with incoming packets
#
Socket::IP_RECVTOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive IP TTL with datagrams
#
Socket::IP_RECVTTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP options to be included in datagrams
#
Socket::IP_RETOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Notify transit routers to more closely examine the contents of an IP packet
#
Socket::IP_ROUTER_ALERT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Source address for outgoing UDP datagrams
#
Socket::IP_SENDSRCADDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP type-of-service
#
Socket::IP_TOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Transparent proxy
#
Socket::IP_TRANSPARENT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP time-to-live
#
Socket::IP_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unblock IPv4 multicast packets with a give source address
#
Socket::IP_UNBLOCK_SOURCE: Integer
Socket::IP_XFRM_POLICY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Connect blocks until accepted
#
Socket::LOCAL_CONNWAIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Pass credentials to receiver
#
Socket::LOCAL_CREDS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve peer credentials
#
Socket::LOCAL_PEERCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Block multicast packets from this source
#
Socket::MCAST_BLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Exclusive multicast source filter
#
Socket::MCAST_EXCLUDE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Inclusive multicast source filter
#
Socket::MCAST_INCLUDE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a multicast group
#
Socket::MCAST_JOIN_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a multicast source group
#
Socket::MCAST_JOIN_SOURCE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a multicast group
#
Socket::MCAST_LEAVE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a multicast source group
#
Socket::MCAST_LEAVE_SOURCE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multicast source filtering
#
Socket::MCAST_MSFILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unblock multicast packets from this source
#
Socket::MCAST_UNBLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# End of record
#
Socket::MSG_COMPAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Confirm path validity
#
Socket::MSG_CONFIRM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Control data lost before delivery
#
Socket::MSG_CTRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send without using the routing tables
#
Socket::MSG_DONTROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# This message should be non-blocking
#
Socket::MSG_DONTWAIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data completes connection
#
Socket::MSG_EOF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data completes record
#
Socket::MSG_EOR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Fetch message from error queue
#
Socket::MSG_ERRQUEUE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Reduce step of the handshake process
#
Socket::MSG_FASTOPEN: Integer
Socket::MSG_FIN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Start of a hold sequence.  Dumps to so_temp
#
Socket::MSG_FLUSH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data ready to be read
#
Socket::MSG_HAVEMORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hold fragment in so_temp
#
Socket::MSG_HOLD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Sender will send more
#
Socket::MSG_MORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Do not generate SIGPIPE
#
Socket::MSG_NOSIGNAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Process out-of-band data
#
Socket::MSG_OOB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Peek at incoming message
#
Socket::MSG_PEEK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Wait for full request
#
Socket::MSG_PROXY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data remains in the current packet
#
Socket::MSG_RCVMORE: Integer
Socket::MSG_RST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send the packet in so_temp
#
Socket::MSG_SEND: Integer
Socket::MSG_SYN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data discarded before delivery
#
Socket::MSG_TRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Wait for full request or error
#
Socket::MSG_WAITALL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The service specified is a datagram service (looks up UDP ports)
#
Socket::NI_DGRAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of a hostname
#
Socket::NI_MAXHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of a service name
#
Socket::NI_MAXSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A name is required
#
Socket::NI_NAMEREQD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# An FQDN is not required for local hosts, return only the local part
#
Socket::NI_NOFQDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Return a numeric address
#
Socket::NI_NUMERICHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Return the service name as a digit string
#
Socket::NI_NUMERICSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Interface to kernel crypto API
#
Socket::PF_ALG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AppleTalk protocol
#
Socket::PF_APPLETALK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Asynchronous Transfer Mode
#
Socket::PF_ATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AX.25 protocol
#
Socket::PF_AX25: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Bluetooth low-level socket protocol
#
Socket::PF_BLUETOOTH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Controller Area Network automotive bus protocol
#
Socket::PF_CAN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (now ITU-T) protocols
#
Socket::PF_CCITT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# MIT CHAOS protocols
#
Socket::PF_CHAOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Computer Network Technology
#
Socket::PF_CNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Connection-oriented IP
#
Socket::PF_COIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Datakit protocol
#
Socket::PF_DATAKIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DECnet protocol
#
Socket::PF_DEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DECnet protocol
#
Socket::PF_DECnet: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DEC Direct Data Link Interface protocol
#
Socket::PF_DLI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# European Computer Manufacturers protocols
#
Socket::PF_ECMA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NSC Hyperchannel protocol
#
Socket::PF_HYLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# InfiniBand native addressing
#
Socket::PF_IB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ARPANET IMP protocol
#
Socket::PF_IMPLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv4 protocol
#
Socket::PF_INET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv6 protocol
#
Socket::PF_INET6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPX protocol
#
Socket::PF_IPX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Integrated Services Digital Network
#
Socket::PF_ISDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::PF_ISO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# KCM (kernel connection multiplexor) interface
#
Socket::PF_KCM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Key management protocol, originally developed for usage with IPsec
#
Socket::PF_KEY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Local Area Transport protocol
#
Socket::PF_LAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Link layer interface
#
Socket::PF_LINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Logical  link control (IEEE 802.2 LLC) protocol
#
Socket::PF_LLC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Host-internal protocols
#
Socket::PF_LOCAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum address family for this platform
#
Socket::PF_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multiprotocol Label Switching
#
Socket::PF_MPLS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Native ATM access
#
Socket::PF_NATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Network driver raw access
#
Socket::PF_NDRV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NetBIOS
#
Socket::PF_NETBIOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Netgraph sockets
#
Socket::PF_NETGRAPH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Kernel user interface device
#
Socket::PF_NETLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XEROX NS protocols
#
Socket::PF_NS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::PF_OSI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Direct link-layer access
#
Socket::PF_PACKET: Integer
Socket::PF_PIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Point-to-Point Protocol
#
Socket::PF_PPP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE)
#
Socket::PF_PPPOX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::PF_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Reliable Datagram Sockets (RDS) protocol
#
Socket::PF_RDS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Internal routing protocol
#
Socket::PF_ROUTE: Integer
Socket::PF_RTIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Simple Internet Protocol
#
Socket::PF_SIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IBM SNA protocol
#
Socket::PF_SNA: Integer
Socket::PF_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TIPC, "cluster domain sockets" protocol
#
Socket::PF_TIPC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UNIX sockets
#
Socket::PF_UNIX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unspecified protocol, any supported address family
#
Socket::PF_UNSPEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# VSOCK (originally "VMWare VSockets") protocol for hypervisor-guest
# communication
#
Socket::PF_VSOCK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XDP (express data path) interface
#
Socket::PF_XDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# eXpress Transfer Protocol
#
Socket::PF_XTP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Timestamp (bintime)
#
Socket::SCM_BINTIME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The sender's credentials
#
Socket::SCM_CREDENTIALS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Process credentials
#
Socket::SCM_CREDS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Access rights
#
Socket::SCM_RIGHTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Timestamp (timeval)
#
Socket::SCM_TIMESTAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Timestamp (timespec list) (Linux 2.6.30)
#
Socket::SCM_TIMESTAMPING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Timespec (timespec)
#
Socket::SCM_TIMESTAMPNS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# User credentials
#
Socket::SCM_UCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Wifi status (Linux 3.3)
#
Socket::SCM_WIFI_STATUS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the reading side of the socket
#
Socket::SHUT_RD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the both sides of the socket
#
Socket::SHUT_RDWR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the writing side of the socket
#
Socket::SHUT_WR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.
#
Socket::SOCK_CLOEXEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A datagram socket provides connectionless, unreliable messaging
#
Socket::SOCK_DGRAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the O_NONBLOCK file status flag on the open file description (see open(2))
# referred to by the new file descriptor.
#
Socket::SOCK_NONBLOCK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Device-level packet access
#
Socket::SOCK_PACKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A raw socket provides low-level access for direct access or implementing
# network protocols
#
Socket::SOCK_RAW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A reliable datagram socket provides reliable delivery of messages
#
Socket::SOCK_RDM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A sequential packet socket provides sequenced, reliable two-way connection for
# datagrams
#
Socket::SOCK_SEQPACKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A stream socket provides a sequenced, reliable two-way connection for a byte
# stream
#
Socket::SOCK_STREAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AppleTalk socket options
#
Socket::SOL_ATALK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AX.25 socket options
#
Socket::SOL_AX25: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP socket options
#
Socket::SOL_IP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPX socket options
#
Socket::SOL_IPX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket-level options
#
Socket::SOL_SOCKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP socket options
#
Socket::SOL_TCP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UDP socket options
#
Socket::SOL_UDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum connection requests that may be queued for a socket
#
Socket::SOMAXCONN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Background socket priority
#
Socket::SOPRI_BACKGROUND: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Interactive socket priority
#
Socket::SOPRI_INTERACTIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Normal socket priority
#
Socket::SOPRI_NORMAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket has had listen() called on it
#
Socket::SO_ACCEPTCONN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# There is an accept filter
#
Socket::SO_ACCEPTFILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Bypass zone boundaries
#
Socket::SO_ALLZONES: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Attach an accept filter
#
Socket::SO_ATTACH_FILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Only send packets from the given interface
#
Socket::SO_BINDTODEVICE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive timestamp with datagrams (bintime)
#
Socket::SO_BINTIME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Query supported BPF extensions (Linux 3.14)
#
Socket::SO_BPF_EXTENSIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Permit sending of broadcast messages
#
Socket::SO_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the threshold in microseconds for low latency polling (Linux 3.11)
#
Socket::SO_BUSY_POLL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Debug info recording
#
Socket::SO_DEBUG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Detach an accept filter
#
Socket::SO_DETACH_FILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Domain given for socket() (Linux 2.6.32)
#
Socket::SO_DOMAIN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use interface addresses
#
Socket::SO_DONTROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retain unread data
#
Socket::SO_DONTTRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get and clear the error status
#
Socket::SO_ERROR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Obtain filter set by SO_ATTACH_FILTER (Linux 3.8)
#
Socket::SO_GET_FILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive the cpu attached to the socket (Linux 3.19)
#
Socket::SO_INCOMING_CPU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive the napi ID attached to a RX queue (Linux 4.12)
#
Socket::SO_INCOMING_NAPI_ID: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Keep connections alive
#
Socket::SO_KEEPALIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Linger on close if data is present
#
Socket::SO_LINGER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Lock the filter attached to a socket (Linux 3.9)
#
Socket::SO_LOCK_FILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Mandatory Access Control exemption for unlabeled peers
#
Socket::SO_MAC_EXEMPT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the mark for mark-based routing (Linux 2.6.25)
#
Socket::SO_MARK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Cap the rate computed by transport layer. [bytes per second] (Linux 3.13)
#
Socket::SO_MAX_PACING_RATE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Install socket-level Network Kernel Extension
#
Socket::SO_NKE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set netns of a socket (Linux 3.4)
#
Socket::SO_NOFCS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't SIGPIPE on EPIPE
#
Socket::SO_NOSIGPIPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Disable checksums
#
Socket::SO_NO_CHECK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get first packet byte count
#
Socket::SO_NREAD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave received out-of-band data in-line
#
Socket::SO_OOBINLINE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive SCM_CREDENTIALS messages
#
Socket::SO_PASSCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Toggle security context passing (Linux 2.6.18)
#
Socket::SO_PASSSEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the peek offset (Linux 3.4)
#
Socket::SO_PEEK_OFF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The credentials of the foreign process connected to this socket
#
Socket::SO_PEERCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Name of the connecting user
#
Socket::SO_PEERNAME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Obtain the security credentials (Linux 2.6.2)
#
Socket::SO_PEERSEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The protocol-defined priority for all packets on this socket
#
Socket::SO_PRIORITY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Protocol given for socket() (Linux 2.6.32)
#
Socket::SO_PROTOCOL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive buffer size
#
Socket::SO_RCVBUF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive buffer size without rmem_max limit (Linux 2.6.14)
#
Socket::SO_RCVBUFFORCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive low-water mark
#
Socket::SO_RCVLOWAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive timeout
#
Socket::SO_RCVTIMEO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive user credentials with datagram
#
Socket::SO_RECVUCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow local address reuse
#
Socket::SO_REUSEADDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow local address and port reuse
#
Socket::SO_REUSEPORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the routing table for this socket (OpenBSD)
#
Socket::SO_RTABLE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Toggle cmsg for number of packets dropped (Linux 2.6.33)
#
Socket::SO_RXQ_OVFL: Integer
Socket::SO_SECURITY_AUTHENTICATION: Integer
Socket::SO_SECURITY_ENCRYPTION_NETWORK: Integer
Socket::SO_SECURITY_ENCRYPTION_TRANSPORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Make select() detect socket error queue with errorfds (Linux 3.10)
#
Socket::SO_SELECT_ERR_QUEUE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the associated routing table for the socket (FreeBSD)
#
Socket::SO_SETFIB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send buffer size
#
Socket::SO_SNDBUF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send buffer size without wmem_max limit (Linux 2.6.14)
#
Socket::SO_SNDBUFFORCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send low-water mark
#
Socket::SO_SNDLOWAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send timeout
#
Socket::SO_SNDTIMEO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive timestamp with datagrams (timeval)
#
Socket::SO_TIMESTAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Time stamping of incoming and outgoing packets (Linux 2.6.30)
#
Socket::SO_TIMESTAMPING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive nanosecond timestamp with datagrams (timespec)
#
Socket::SO_TIMESTAMPNS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get the socket type
#
Socket::SO_TYPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Bypass hardware when possible
#
Socket::SO_USELOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Setting an identifier for ipfw purpose mainly
#
Socket::SO_USER_COOKIE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Give a hint when more data is ready
#
Socket::SO_WANTMORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# OOB data is wanted in MSG_FLAG on receive
#
Socket::SO_WANTOOBFLAG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Toggle cmsg for wifi status (Linux 3.3)
#
Socket::SO_WIFI_STATUS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve information about this socket (macOS)
#
Socket::TCP_CONNECTION_INFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP congestion control algorithm (Linux 2.6.13, glibc 2.6)
#
Socket::TCP_CONGESTION: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP Cookie Transactions (Linux 2.6.33, glibc 2.18)
#
Socket::TCP_COOKIE_TRANSACTIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't send partial frames (Linux 2.2, glibc 2.2)
#
Socket::TCP_CORK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't notify a listening socket until data is ready (Linux 2.4, glibc 2.2)
#
Socket::TCP_DEFER_ACCEPT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Reduce step of the handshake process (Linux 3.7, glibc 2.18)
#
Socket::TCP_FASTOPEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve information about this socket (Linux 2.4, glibc 2.2)
#
Socket::TCP_INFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Idle time before keepalive probes are sent (macOS)
#
Socket::TCP_KEEPALIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum number of keepalive probes allowed before dropping a connection (Linux
# 2.4, glibc 2.2)
#
Socket::TCP_KEEPCNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Idle time before keepalive probes are sent (Linux 2.4, glibc 2.2)
#
Socket::TCP_KEEPIDLE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Time between keepalive probes (Linux 2.4, glibc 2.2)
#
Socket::TCP_KEEPINTVL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Lifetime of orphaned FIN_WAIT2 sockets (Linux 2.4, glibc 2.2)
#
Socket::TCP_LINGER2: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set maximum segment size
#
Socket::TCP_MAXSEG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use MD5 digests (RFC2385, Linux 2.6.20, glibc 2.7)
#
Socket::TCP_MD5SIG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't delay sending to coalesce packets
#
Socket::TCP_NODELAY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't use TCP options
#
Socket::TCP_NOOPT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't push the last block of write
#
Socket::TCP_NOPUSH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Sequence of a queue for repair mode (Linux 3.5, glibc 2.18)
#
Socket::TCP_QUEUE_SEQ: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Enable quickack mode (Linux 2.4.4, glibc 2.3)
#
Socket::TCP_QUICKACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Repair mode (Linux 3.5, glibc 2.18)
#
Socket::TCP_REPAIR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Options for repair mode (Linux 3.5, glibc 2.18)
#
Socket::TCP_REPAIR_OPTIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Queue for repair mode (Linux 3.5, glibc 2.18)
#
Socket::TCP_REPAIR_QUEUE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Number of SYN retransmits before a connection is dropped (Linux 2.4, glibc
# 2.2)
#
Socket::TCP_SYNCNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Duplicated acknowledgments handling for thin-streams (Linux 2.6.34, glibc
# 2.18)
#
Socket::TCP_THIN_DUPACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Linear timeouts for thin-streams (Linux 2.6.34, glibc 2.18)
#
Socket::TCP_THIN_LINEAR_TIMEOUTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP timestamp (Linux 3.9, glibc 2.18)
#
Socket::TCP_TIMESTAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Max timeout before a TCP connection is aborted (Linux 2.6.37, glibc 2.18)
#
Socket::TCP_USER_TIMEOUT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Clamp the size of the advertised window (Linux 2.4, glibc 2.2)
#
Socket::TCP_WINDOW_CLAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't send partial frames (Linux 2.5.44, glibc 2.11)
#
Socket::UDP_CORK: Integer

# <!-- rdoc-file=ext/socket/ifaddr.c -->
# Socket::Ifaddr represents a result of getifaddrs() function.
#
class Socket::Ifaddr
  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.addr => addrinfo
  # -->
  # Returns the address of *ifaddr*. nil is returned if address is not available
  # in *ifaddr*.
  #
  def addr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.broadaddr => addrinfo
  # -->
  # Returns the broadcast address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_BROADCAST.
  #
  def broadaddr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.dstaddr => addrinfo
  # -->
  # Returns the destination address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_POINTOPOINT.
  #
  def dstaddr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.flags => integer
  # -->
  # Returns the flags of *ifaddr*.
  #
  def flags: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.ifindex => integer
  # -->
  # Returns the interface index of *ifaddr*.
  #
  def ifindex: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.inspect => string
  # -->
  # Returns a string to show contents of *ifaddr*.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.name => string
  # -->
  # Returns the interface name of *ifaddr*.
  #
  def name: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.netmask => addrinfo
  # -->
  # Returns the netmask address of *ifaddr*. nil is returned if netmask is not
  # available in *ifaddr*.
  #
  def netmask: () -> Addrinfo?
end

# <!-- rdoc-file=ext/socket/lib/socket.rb -->
# UDP/IP address information used by Socket.udp_server_loop.
#
class Socket::UDPSource
  def inspect: () -> String

  # <!-- rdoc-file=ext/socket/lib/socket.rb -->
  # Local address
  #
  def local_address: () -> Addrinfo

  # <!-- rdoc-file=ext/socket/lib/socket.rb -->
  # Address of the source
  #
  def remote_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - reply(msg)
  # -->
  # Sends the String `msg` to the source
  #
  def reply: (String msg) -> void

  private

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - new(remote_address, local_address, &reply_proc)
  # -->
  # `remote_address` is an Addrinfo object.
  #
  # `local_address` is an Addrinfo object.
  #
  # `reply_proc` is a Proc used to send reply back to the source.
  #
  def initialize: (Addrinfo remote_address, Addrinfo local_address) { (String) -> void } -> void
end

# <!-- rdoc-file=ext/socket/ancdata.c -->
# Socket::AncillaryData represents the ancillary data (control information) used
# by sendmsg and recvmsg system call.  It contains socket #family, control
# message (cmsg) #level, cmsg #type and cmsg #data.
#
class Socket::AncillaryData
  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.int(family, cmsg_level, cmsg_type, integer) => ancillarydata
  # -->
  # Creates a new Socket::AncillaryData object which contains a int as data.
  #
  # The size and endian is dependent on the host.
  #
  #     require 'socket'
  #
  #     p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.int: (Symbol, Symbol, Symbol, Symbol) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.ip_pktinfo(addr, ifindex) => ancdata
  #   - Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst) => ancdata
  # -->
  # Returns new ancillary data for IP_PKTINFO.
  #
  # If spec_dst is not given, addr is used.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dst = Addrinfo.ip("127.0.0.1")
  #     p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)
  #     #=> #<Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1>
  #
  def self.ip_pktinfo: (Addrinfo addr, Integer ifindex, ?Addrinfo spec_dst) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.ipv6_pktinfo(addr, ifindex) => ancdata
  # -->
  # Returns new ancillary data for IPV6_PKTINFO.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0>
  #
  def self.ipv6_pktinfo: (Addrinfo addr, Integer ifindex) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.unix_rights(io1, io2, ...) => ancillarydata
  # -->
  # Creates a new Socket::AncillaryData object which contains file descriptors as
  # data.
  #
  #     p Socket::AncillaryData.unix_rights(STDERR)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.unix_rights: (IO fd) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.cmsg_is?(level, type) => true or false
  # -->
  # tests the level and type of *ancillarydata*.
  #
  #     ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true
  #     ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true
  #     ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false
  #     ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false
  #
  def cmsg_is?: (Integer level, Integer ancillary_type) -> bool

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.data => string
  # -->
  # returns the cmsg data as a string.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").data
  #     #=> ""
  #
  def data: () -> String

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.family => integer
  # -->
  # returns the socket family as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").family
  #     #=> 10
  #
  def family: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.inspect => string
  # -->
  # returns a string which shows ancillarydata in human-readable form.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").inspect
  #     #=> "#<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.int => integer
  # -->
  # Returns the data in *ancillarydata* as an int.
  #
  # The size and endian is dependent on the host.
  #
  #     ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     p ancdata.int #=> 2
  #
  def int: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ip_pktinfo => [addr, ifindex, spec_dst]
  # -->
  # Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dest = Addrinfo.ip("127.0.0.1")
  #     ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)
  #     p ancdata.ip_pktinfo
  #     #=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]
  #
  def ip_pktinfo: () -> [ Addrinfo, Integer, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo => [addr, ifindex]
  # -->
  # Extracts addr and ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]
  #
  def ipv6_pktinfo: () -> [ Addrinfo, Integer ]

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo_addr => addr
  # -->
  # Extracts addr from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>
  #
  def ipv6_pktinfo_addr: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo_ifindex => addr
  # -->
  # Extracts ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_ifindex #=> 0
  #
  def ipv6_pktinfo_ifindex: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.level => integer
  # -->
  # returns the cmsg level as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").level
  #     #=> 41
  #
  def level: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.timestamp => time
  # -->
  # returns the timestamp as a time object.
  #
  # *ancillarydata* should be one of following type:
  # *   SOL_SOCKET/SCM_TIMESTAMP (microsecond) GNU/Linux, FreeBSD, NetBSD,
  #     OpenBSD, Solaris, MacOS X
  # *   SOL_SOCKET/SCM_TIMESTAMPNS (nanosecond) GNU/Linux
  # *   SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD
  #
  #     Addrinfo.udp("127.0.0.1", 0).bind {|s1|
  #         Addrinfo.udp("127.0.0.1", 0).bind {|s2|
  #           s1.setsockopt(:SOCKET, :TIMESTAMP, true)
  #           s2.send "a", 0, s1.local_address
  #           ctl = s1.recvmsg.last
  #           p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581>
  #           t = ctl.timestamp
  #           p t      #=> 2009-02-24 17:35:46 +0900
  #           p t.usec #=> 775581
  #           p t.nsec #=> 775581000
  #         }
  #
  #     }
  #
  def timestamp: () -> Time

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.type => integer
  # -->
  # returns the cmsg type as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").type
  #     #=> 2
  #
  def type: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.unix_rights => array-of-IOs or nil
  # -->
  # returns the array of IO objects for SCM_RIGHTS control message in UNIX domain
  # socket.
  #
  # The class of the IO objects in the array is IO or Socket.
  #
  # The array is attached to *ancillarydata* when it is instantiated. For example,
  # BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control
  # message and :scm_rights=>true option is given.
  #
  #     # recvmsg needs :scm_rights=>true for unix_rights
  #     s1, s2 = UNIXSocket.pair
  #     p s1                                         #=> #<UNIXSocket:fd 3>
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg(:scm_rights=>true)
  #     p ctl                                        #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]
  #     p File.identical?(STDIN, ctl.unix_rights[0]) #=> true
  #     p File.identical?(s1, ctl.unix_rights[1])    #=> true
  #
  #     # If :scm_rights=>true is not given, unix_rights returns nil
  #     s1, s2 = UNIXSocket.pair
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg
  #     p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights #=> nil
  #
  def unix_rights: () -> Array[IO]?

  private

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.new(family, cmsg_level, cmsg_type, cmsg_data) -> ancillarydata
  # -->
  # *family* should be an integer, a string or a symbol.
  # *   Socket::AF_INET, "AF_INET", "INET", :AF_INET, :INET
  # *   Socket::AF_UNIX, "AF_UNIX", "UNIX", :AF_UNIX, :UNIX
  # *   etc.
  #
  # *cmsg_level* should be an integer, a string or a symbol.
  # *   Socket::SOL_SOCKET, "SOL_SOCKET", "SOCKET", :SOL_SOCKET and :SOCKET
  # *   Socket::IPPROTO_IP, "IP" and :IP
  # *   Socket::IPPROTO_IPV6, "IPV6" and :IPV6
  # *   Socket::IPPROTO_TCP, "TCP" and :TCP
  # *   etc.
  #
  # *cmsg_type* should be an integer, a string or a symbol. If a string/symbol is
  # specified, it is interpreted depend on *cmsg_level*.
  # *   Socket::SCM_RIGHTS, "SCM_RIGHTS", "RIGHTS", :SCM_RIGHTS, :RIGHTS for
  #     SOL_SOCKET
  # *   Socket::IP_RECVTTL, "RECVTTL" and :RECVTTL for IPPROTO_IP
  # *   Socket::IPV6_PKTINFO, "PKTINFO" and :PKTINFO for IPPROTO_IPV6
  # *   etc.
  #
  # *cmsg_data* should be a string.
  #
  #     p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, "")
  #     #=> #<Socket::AncillaryData: INET TCP NODELAY "">
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO "">
  #
  def initialize: (interned | Integer family, interned | Integer cmsg_level, interned | Integer cmsg_data, String cmsg_data) -> untyped
end
# <!-- rdoc-file=ext/socket/unixsocket.c -->
# UNIXSocket represents a UNIX domain stream client socket.
#
class UNIXSocket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.pair([type [, protocol]])       => [unixsocket1, unixsocket2]
  #   - UNIXSocket.socketpair([type [, protocol]]) => [unixsocket1, unixsocket2]
  # -->
  # Creates a pair of sockets connected to each other.
  #
  # *type* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain. 0 is default protocol
  # for the domain.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "ab"
  #
  def self.pair: (?Symbol socktype, ?Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.pair([type [, protocol]])       => [unixsocket1, unixsocket2]
  #   - UNIXSocket.socketpair([type [, protocol]]) => [unixsocket1, unixsocket2]
  # -->
  # Creates a pair of sockets connected to each other.
  #
  # *type* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain. 0 is default protocol
  # for the domain.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "ab"
  #
  def self.socketpair: (?Symbol socktype, ?Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.addr => [address_family, unix_path]
  # -->
  # Returns the local address as an array which contains address_family and
  # unix_path.
  #
  # Example
  #     serv = UNIXServer.new("/tmp/sock")
  #     p serv.addr #=> ["AF_UNIX", "/tmp/sock"]
  #
  def addr: () -> [ String, String ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.path => path
  # -->
  # Returns the path of the local address of unixsocket.
  #
  #     s = UNIXServer.new("/tmp/sock")
  #     p s.path #=> "/tmp/sock"
  #
  def path: () -> String

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.peeraddr => [address_family, unix_path]
  # -->
  # Returns the remote address as an array which contains address_family and
  # unix_path.
  #
  # Example
  #     serv = UNIXServer.new("/tmp/sock")
  #     c = UNIXSocket.new("/tmp/sock")
  #     p c.peeraddr #=> ["AF_UNIX", "/tmp/sock"]
  #
  def peeraddr: () -> [ String, String ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.recv_io([klass [, mode]]) => io
  # -->
  # Example
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         s = serv.accept
  #
  #         c.send_io STDOUT
  #         stdout = s.recv_io
  #
  #         p STDOUT.fileno #=> 1
  #         p stdout.fileno #=> 7
  #
  #         stdout.puts "hello" # outputs "hello\n" to standard output.
  #       }
  #     }
  #
  # *klass* will determine the class of *io* returned (using the IO.for_fd
  # singleton method or similar). If *klass* is `nil`, an integer file descriptor
  # is returned.
  #
  # *mode* is the same as the argument passed to IO.for_fd
  #
  def recv_io: (?singleton(BasicSocket), ?String mode) -> BasicSocket

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.recvfrom(maxlen [, flags[, outbuf]]) => [mesg, unixaddress]
  # -->
  # Receives a message via *unixsocket*.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *outbuf* will contain only the received data after the method call even if it
  # is not empty at the beginning.
  #
  #     s1 = Socket.new(:UNIX, :DGRAM, 0)
  #     s1_ai = Addrinfo.unix("/tmp/sock1")
  #     s1.bind(s1_ai)
  #
  #     s2 = Socket.new(:UNIX, :DGRAM, 0)
  #     s2_ai = Addrinfo.unix("/tmp/sock2")
  #     s2.bind(s2_ai)
  #     s3 = UNIXSocket.for_fd(s2.fileno)
  #
  #     s1.send "a", 0, s2_ai
  #     p s3.recvfrom(10) #=> ["a", ["AF_UNIX", "/tmp/sock1"]]
  #
  def recvfrom: (Integer maxlen, ?Integer flags, ?String outbuf) -> [ String, [ String, String ] ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.send_io(io) => nil
  # -->
  # Sends *io* as file descriptor passing.
  #
  #     s1, s2 = UNIXSocket.pair
  #
  #     s1.send_io STDOUT
  #     stdout = s2.recv_io
  #
  #     p STDOUT.fileno #=> 1
  #     p stdout.fileno #=> 6
  #
  #     stdout.puts "hello" # outputs "hello\n" to standard output.
  #
  # *io* may be any kind of IO object or integer file descriptor.
  #
  def send_io: (BasicSocket | Integer) -> void

  private

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.new(path) => unixsocket
  # -->
  # Creates a new UNIX client socket connected to *path*.
  #
  #     require 'socket'
  #
  #     s = UNIXSocket.new("/tmp/sock")
  #     s.send "hello", 0
  #
  def initialize: (String path) -> untyped
end
# <!-- rdoc-file=ext/socket/ipsocket.c -->
# IPSocket is the super class of TCPSocket and UDPSocket.
#
class IPSocket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - IPSocket.getaddress(host)        => ipaddress
  # -->
  # Lookups the IP address of *host*.
  #
  #     require 'socket'
  #
  #     IPSocket.getaddress("localhost")     #=> "127.0.0.1"
  #     IPSocket.getaddress("ip6-localhost") #=> "::1"
  #
  def self.getaddress: (String host) -> String

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.addr([reverse_lookup]) => [address_family, port, hostname, numeric_address]
  # -->
  # Returns the local address as an array which contains address_family, port,
  # hostname and numeric_address.
  #
  # If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
  # numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
  # hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
  # to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.addr #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(true)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(false) #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
  #       p sock.addr(:hostname)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(:numeric)   #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
  #     }
  #
  def addr: (?boolish | :hostname | :numeric reverse_lookup) -> [ String, Integer, String, String ]

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.inspect   -> string
  # -->
  # Return a string describing this IPSocket object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.peeraddr([reverse_lookup]) => [address_family, port, hostname, numeric_address]
  # -->
  # Returns the remote address as an array which contains address_family, port,
  # hostname and numeric_address. It is defined for connection oriented socket
  # such as TCPSocket.
  #
  # If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
  # numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
  # hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
  # to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.peeraddr #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(true)  #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(false) #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #       p sock.peeraddr(:hostname) #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(:numeric)  #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #     }
  #
  def peeraddr: (?boolish | :hostname | :numeric reverse_lookup) -> [ String, Integer, String, String ]

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.recvfrom(maxlen)        => [mesg, ipaddr]
  #   - ipsocket.recvfrom(maxlen, flags) => [mesg, ipaddr]
  # -->
  # Receives a message and return the message as a string and an address which the
  # message come from.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # ipaddr is the same as IPSocket#{peeraddr,addr}.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u2 = UDPSocket.new
  #     u2.send "uuuu", 0, "127.0.0.1", 4913
  #     p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]
  #
  def recvfrom: (Integer maxlen, ?Integer flags) -> [ String, [ String, Integer, String, String ] ]
end
# <!-- rdoc-file=ext/socket/basicsocket.c -->
# BasicSocket is the super class for all the Socket classes.
#
class BasicSocket < IO
  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.do_not_reverse_lookup => true or false
  # -->
  # Gets the global do_not_reverse_lookup flag.
  #
  #     BasicSocket.do_not_reverse_lookup  #=> false
  #
  def self.do_not_reverse_lookup: () -> bool

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.do_not_reverse_lookup = bool
  # -->
  # Sets the global do_not_reverse_lookup flag.
  #
  # The flag is used for initial value of do_not_reverse_lookup for each socket.
  #
  #     s1 = TCPSocket.new("localhost", 80)
  #     p s1.do_not_reverse_lookup                 #=> true
  #     BasicSocket.do_not_reverse_lookup = false
  #     s2 = TCPSocket.new("localhost", 80)
  #     p s2.do_not_reverse_lookup                 #=> false
  #     p s1.do_not_reverse_lookup                 #=> true
  #
  def self.do_not_reverse_lookup=: (boolish) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.for_fd(fd) => basicsocket
  # -->
  # Returns a socket object which contains the file descriptor, *fd*.
  #
  #     # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
  #     STDIN_SOCK = Socket.for_fd(STDIN.fileno)
  #     p STDIN_SOCK.remote_address
  #
  def self.for_fd: (Integer fileno) -> BasicSocket

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.close_read => nil
  # -->
  # Disallows further read using shutdown system call.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.close_read
  #     s2.puts #=> Broken pipe (Errno::EPIPE)
  #
  def close_read: () -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.close_write => nil
  # -->
  # Disallows further write using shutdown system call.
  #
  #     UNIXSocket.pair {|s1, s2|
  #       s1.print "ping"
  #       s1.close_write
  #       p s2.read        #=> "ping"
  #       s2.print "pong"
  #       s2.close
  #       p s1.read        #=> "pong"
  #     }
  #
  def close_write: () -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - connect_address()
  # -->
  # Returns an address of the socket suitable for connect in the local machine.
  #
  # This method returns *self*.local_address, except following condition.
  #
  # *   IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address
  #     (127.0.0.1).
  # *   IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).
  #
  # If the local address is not suitable for connect, SocketError is raised. IPv4
  # and IPv6 address which port is 0 is not suitable for connect. Unix domain
  # socket which has no path is not suitable for connect.
  #
  #     Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
  #       p serv.connect_address #=> #<Addrinfo: 127.0.0.1:53660 TCP>
  #       serv.connect_address.connect {|c|
  #         s, _ = serv.accept
  #         p [c, s] #=> [#<Socket:fd 4>, #<Socket:fd 6>]
  #       }
  #     }
  #
  def connect_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.do_not_reverse_lookup => true or false
  # -->
  # Gets the do_not_reverse_lookup flag of *basicsocket*.
  #
  #     require 'socket'
  #
  #     BasicSocket.do_not_reverse_lookup = false
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup      #=> false
  #     }
  #     BasicSocket.do_not_reverse_lookup = true
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup      #=> true
  #     }
  #
  def do_not_reverse_lookup: () -> bool

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.do_not_reverse_lookup = bool
  # -->
  # Sets the do_not_reverse_lookup flag of *basicsocket*.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup       #=> true
  #       p sock.peeraddr                    #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #       sock.do_not_reverse_lookup = false
  #       p sock.peeraddr                    #=> ["AF_INET", 80, "carbon.ruby-lang.org", "54.163.249.195"]
  #     }
  #
  def do_not_reverse_lookup=: (boolish) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getpeereid => [euid, egid]
  # -->
  # Returns the user and group on the peer of the UNIX socket. The result is a two
  # element array which contains the effective uid and the effective gid.
  #
  #     Socket.unix_server_loop("/tmp/sock") {|s|
  #       begin
  #         euid, egid = s.getpeereid
  #
  #         # Check the connected client is myself or not.
  #         next if euid != Process.uid
  #
  #         # do something about my resource.
  #
  #       ensure
  #         s.close
  #       end
  #     }
  #
  def getpeereid: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getpeername => sockaddr
  # -->
  # Returns the remote address of the socket as a sockaddr string.
  #
  #     TCPServer.open("127.0.0.1", 1440) {|serv|
  #       c = TCPSocket.new("127.0.0.1", 1440)
  #       s = serv.accept
  #       p s.getpeername #=> "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     }
  #
  # If Addrinfo object is preferred over the binary string, use
  # BasicSocket#remote_address.
  #
  def getpeername: () -> String

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getsockname => sockaddr
  # -->
  # Returns the local address of the socket as a sockaddr string.
  #
  #     TCPServer.open("127.0.0.1", 15120) {|serv|
  #       p serv.getsockname #=> "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     }
  #
  # If Addrinfo object is preferred over the binary string, use
  # BasicSocket#local_address.
  #
  def getsockname: () -> String

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - getsockopt(level, optname) => socketoption
  # -->
  # Gets a socket option. These are protocol and system specific, see your local
  # system documentation for details. The option is returned as a Socket::Option
  # object.
  #
  # ### Parameters
  # *   `level` is an integer, usually one of the SOL_ constants such as
  #     Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
  #     possibly without prefix, is also accepted.
  # *   `optname` is an integer, usually one of the SO_ constants, such as
  #     Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
  #     prefix, is also accepted.
  #
  # ### Examples
  #
  # Some socket options are integers with boolean values, in this case #getsockopt
  # could be called like this:
  #
  #     reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool
  #
  #     optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
  #     optval = optval.unpack "i"
  #     reuseaddr = optval[0] == 0 ? false : true
  #
  # Some socket options are integers with numeric values, in this case #getsockopt
  # could be called like this:
  #
  #     ipttl = sock.getsockopt(:IP, :TTL).int
  #
  #     optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
  #     ipttl = optval.unpack1("i")
  #
  # Option values may be structs. Decoding them can be complex as it involves
  # examining your system headers to determine the correct definition. An example
  # is a +struct linger+, which may be defined in your system headers as:
  #     struct linger {
  #       int l_onoff;
  #       int l_linger;
  #     };
  #
  # In this case #getsockopt could be called like this:
  #
  #     # Socket::Option knows linger structure.
  #     onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger
  #
  #     optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
  #     onoff, linger = optval.unpack "ii"
  #     onoff = onoff == 0 ? false : true
  #
  def getsockopt: (Symbol | Integer, Symbol | Integer) -> (Integer | boolish | String)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - bsock.local_address => addrinfo
  # -->
  # Returns an Addrinfo object for local address obtained by getsockname.
  #
  # Note that addrinfo.protocol is filled by 0.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|s|
  #       p s.local_address #=> #<Addrinfo: 192.168.0.129:36873 TCP>
  #     }
  #
  #     TCPServer.open("127.0.0.1", 1512) {|serv|
  #       p serv.local_address #=> #<Addrinfo: 127.0.0.1:1512 TCP>
  #     }
  #
  def local_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.recv(maxlen[, flags[, outbuf]]) => mesg
  # -->
  # Receives a message.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *outbuf* will contain only the received data after the method call even if it
  # is not empty at the beginning.
  #
  #     UNIXSocket.pair {|s1, s2|
  #       s1.puts "Hello World"
  #       p s2.recv(4)                     #=> "Hell"
  #       p s2.recv(4, Socket::MSG_PEEK)   #=> "o Wo"
  #       p s2.recv(4)                     #=> "o Wo"
  #       p s2.recv(10)                    #=> "rld\n"
  #     }
  #
  def recv: (Integer maxlen, ?Integer flags, ?String outbuf) -> String
          | (Integer maxlen, ?String outbuf) -> String

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recv_nonblock(maxlen [, flags [, buf [, options ]]]) => mesg
  # -->
  # Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
  # is set for the underlying file descriptor. *flags* is zero or more of the
  # `MSG_` options. The result, *mesg*, is the data received.
  #
  # When recvfrom(2) returns 0, Socket#recv_nonblock returns nil. In most cases it
  # means the connection was closed, but for UDP connections it may mean an empty
  # packet was received, as the underlying API makes it impossible to distinguish
  # these two cases.
  #
  # ### Parameters
  # *   `maxlen` - the number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `buf` - destination String buffer
  # *   `options` - keyword hash, supporting `exception: false`
  #
  # ### Example
  #     serv = TCPServer.new("127.0.0.1", 0)
  #     af, port, host, addr = serv.addr
  #     c = TCPSocket.new(addr, port)
  #     s = serv.accept
  #     c.send "aaa", 0
  #     begin # emulate blocking recv.
  #       p s.recv_nonblock(10) #=> "aaa"
  #     rescue IO::WaitReadable
  #       IO.select([s])
  #       retry
  #     end
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recv_nonblock* fails.
  #
  # BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recv_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recv_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recv_nonblock: (Integer maxlen, ?Integer flags, ?String buf, ?exception: boolish) -> (String | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recvmsg(maxmesglen=nil, flags=0, maxcontrollen=nil, opts={}) => [mesg, sender_addrinfo, rflags, *controls]
  # -->
  # recvmsg receives a message using recvmsg(2) system call in blocking manner.
  #
  # *maxmesglen* is the maximum length of mesg to receive.
  #
  # *flags* is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.
  #
  # *maxcontrollen* is the maximum length of controls (ancillary data) to receive.
  #
  # *opts* is option hash. Currently :scm_rights=>bool is the only option.
  #
  # :scm_rights option specifies that application expects SCM_RIGHTS control
  # message. If the value is nil or false, application don't expects SCM_RIGHTS
  # control message. In this case, recvmsg closes the passed file descriptors
  # immediately. This is the default behavior.
  #
  # If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS
  # control message. In this case, recvmsg creates IO objects for each file
  # descriptors for Socket::AncillaryData#unix_rights method.
  #
  # The return value is 4-elements array.
  #
  # *mesg* is a string of the received message.
  #
  # *sender_addrinfo* is a sender socket address for connection-less socket. It is
  # an Addrinfo object. For connection-oriented socket such as TCP,
  # sender_addrinfo is platform dependent.
  #
  # *rflags* is a flags on the received message which is bitwise OR of MSG_*
  # constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD
  # style old recvmsg system call.
  #
  # *controls* is ancillary data which is an array of Socket::AncillaryData
  # objects such as:
  #
  #     #<Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7>
  #
  # *maxmesglen* and *maxcontrollen* can be nil. In that case, the buffer will be
  # grown until the message is not truncated. Internally, MSG_PEEK is used. Buffer
  # full and MSG_CTRUNC are checked for truncation.
  #
  # recvmsg can be used to implement recv_io as follows:
  #
  #     mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=>true)
  #     controls.each {|ancdata|
  #       if ancdata.cmsg_is?(:SOCKET, :RIGHTS)
  #         return ancdata.unix_rights[0]
  #       end
  #     }
  #
  def recvmsg: (?Integer dlen, ?Integer flags, ?Integer clen, ?scm_rights: boolish) -> [ String, Addrinfo, Integer?, Array[Socket::AncillaryData] ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recvmsg_nonblock(maxdatalen=nil, flags=0, maxcontrollen=nil, opts={}) => [data, sender_addrinfo, rflags, *controls]
  # -->
  # recvmsg receives a message using recvmsg(2) system call in non-blocking
  # manner.
  #
  # It is similar to BasicSocket#recvmsg but non-blocking flag is set before the
  # system call and it doesn't retry the system call.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvmsg_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  def recvmsg_nonblock: (?Integer dlen, ?Integer flags, ?Integer clen, ?exception: boolish, ?scm_rights: boolish) -> ([ String, Addrinfo, Integer?, Array[Socket::AncillaryData] ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - bsock.remote_address => addrinfo
  # -->
  # Returns an Addrinfo object for remote address obtained by getpeername.
  #
  # Note that addrinfo.protocol is filled by 0.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|s|
  #       p s.remote_address #=> #<Addrinfo: 221.186.184.68:80 TCP>
  #     }
  #
  #     TCPServer.open("127.0.0.1", 1728) {|serv|
  #       c = TCPSocket.new("127.0.0.1", 1728)
  #       s = serv.accept
  #       p s.remote_address #=> #<Addrinfo: 127.0.0.1:36504 TCP>
  #     }
  #
  def remote_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.send(mesg, flags [, dest_sockaddr]) => numbytes_sent
  # -->
  # send *mesg* via *basicsocket*.
  #
  # *mesg* should be a string.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *dest_sockaddr* should be a packed sockaddr string or an addrinfo.
  #
  #     TCPSocket.open("localhost", 80) {|s|
  #       s.send "GET / HTTP/1.0\r\n\r\n", 0
  #       p s.read
  #     }
  #
  def send: (String msg, ?Integer flags, ?Addrinfo | String dest_sockaddr) -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.sendmsg(mesg, flags=0, dest_sockaddr=nil, *controls) => numbytes_sent
  # -->
  # sendmsg sends a message using sendmsg(2) system call in blocking manner.
  #
  # *mesg* is a string to send.
  #
  # *flags* is bitwise OR of MSG_* constants such as Socket::MSG_OOB.
  #
  # *dest_sockaddr* is a destination socket address for connection-less socket. It
  # should be a sockaddr such as a result of Socket.sockaddr_in. An Addrinfo
  # object can be used too.
  #
  # *controls* is a list of ancillary data. The element of *controls* should be
  # Socket::AncillaryData or 3-elements array. The 3-element array should contains
  # cmsg_level, cmsg_type and data.
  #
  # The return value, *numbytes_sent* is an integer which is the number of bytes
  # sent.
  #
  # sendmsg can be used to implement send_io as follows:
  #
  #     # use Socket::AncillaryData.
  #     ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)
  #     sock.sendmsg("a", 0, nil, ancdata)
  #
  #     # use 3-element array.
  #     ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]
  #     sock.sendmsg("\0", 0, nil, ancdata)
  #
  def sendmsg: (String mesg, ?Integer flags, ?Addrinfo | String dest_sockaddr, *Socket::AncillaryData controls) -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.sendmsg_nonblock(mesg, flags=0, dest_sockaddr=nil, *controls, opts={}) => numbytes_sent
  # -->
  # sendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking
  # manner.
  #
  # It is similar to BasicSocket#sendmsg but the non-blocking flag is set before
  # the system call and it doesn't retry the system call.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # sendmsg_nonblock should not raise an IO::WaitWritable exception, but return
  # the symbol `:wait_writable` instead.
  #
  def sendmsg_nonblock: (String mesg, ?Integer flags, ?Addrinfo | String dest_sockaddr, *Socket::AncillaryData controls, ?exception: boolish) -> (Integer | :wait_writable)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - setsockopt(level, optname, optval)
  #   - setsockopt(socketoption)
  # -->
  # Sets a socket option. These are protocol and system specific, see your local
  # system documentation for details.
  #
  # ### Parameters
  # *   `level` is an integer, usually one of the SOL_ constants such as
  #     Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
  #     possibly without prefix, is also accepted.
  # *   `optname` is an integer, usually one of the SO_ constants, such as
  #     Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
  #     prefix, is also accepted.
  # *   `optval` is the value of the option, it is passed to the underlying
  #     setsockopt() as a pointer to a certain number of bytes. How this is done
  #     depends on the type:
  #     *   Integer: value is assigned to an int, and a pointer to the int is
  #         passed, with length of sizeof(int).
  #     *   true or false: 1 or 0 (respectively) is assigned to an int, and the
  #         int is passed as for an Integer. Note that `false` must be passed, not
  #         `nil`.
  #     *   String: the string's data and length is passed to the socket.
  # *   `socketoption` is an instance of Socket::Option
  #
  # ### Examples
  #
  # Some socket options are integers with boolean values, in this case #setsockopt
  # could be called like this:
  #     sock.setsockopt(:SOCKET, :REUSEADDR, true)
  #     sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
  #     sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
  #
  # Some socket options are integers with numeric values, in this case #setsockopt
  # could be called like this:
  #     sock.setsockopt(:IP, :TTL, 255)
  #     sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
  #     sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
  #
  # Option values may be structs. Passing them can be complex as it involves
  # examining your system headers to determine the correct definition. An example
  # is an `ip_mreq`, which may be defined in your system headers as:
  #     struct ip_mreq {
  #       struct  in_addr imr_multiaddr;
  #       struct  in_addr imr_interface;
  #     };
  #
  # In this case #setsockopt could be called like this:
  #     optval = IPAddr.new("224.0.0.251").hton +
  #              IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
  #     sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
  #
  def setsockopt: (*Symbol | Integer, boolish | Integer | String) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.shutdown([how]) => 0
  # -->
  # Calls shutdown(2) system call.
  #
  # s.shutdown(Socket::SHUT_RD) disallows further read.
  #
  # s.shutdown(Socket::SHUT_WR) disallows further write.
  #
  # s.shutdown(Socket::SHUT_RDWR) disallows further read and write.
  #
  # *how* can be symbol or string:
  # *   :RD, :SHUT_RD, "RD" and "SHUT_RD" are accepted as Socket::SHUT_RD.
  # *   :WR, :SHUT_WR, "WR" and "SHUT_WR" are accepted as Socket::SHUT_WR.
  # *   :RDWR, :SHUT_RDWR, "RDWR" and "SHUT_RDWR" are accepted as
  #     Socket::SHUT_RDWR.
  #
  #     UNIXSocket.pair {|s1, s2|
  #         s1.puts "ping"
  #         s1.shutdown(:WR)
  #         p s2.read          #=> "ping\n"
  #         s2.puts "pong"
  #         s2.close
  #         p s1.read          #=> "pong\n"
  #
  #     }
  #
  def shutdown: (interned | Integer flags) -> void

  private

  def __recv_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  def __recvmsg: (untyped, untyped, untyped, untyped) -> untyped

  def __recvmsg_nonblock: (untyped, untyped, untyped, untyped, untyped) -> untyped

  def __sendmsg: (untyped, untyped, untyped, untyped) -> untyped

  def __sendmsg_nonblock: (untyped, untyped, untyped, untyped, untyped) -> untyped
end
# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket::Constants provides socket-related constants.  All possible socket
# constants are listed in the documentation but they may not all be present on
# your platform.
#
# If the underlying platform doesn't define a constant the corresponding Ruby
# constant is not defined.
#
module Socket::Constants
  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Interface to kernel crypto API
  #
  AF_ALG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AppleTalk protocol
  #
  AF_APPLETALK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Asynchronous Transfer Mode
  #
  AF_ATM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AX.25 protocol
  #
  AF_AX25: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Bluetooth low-level socket protocol
  #
  AF_BLUETOOTH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Controller Area Network automotive bus protocol
  #
  AF_CAN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # CCITT (now ITU-T) protocols
  #
  AF_CCITT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # MIT CHAOS protocols
  #
  AF_CHAOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Computer Network Technology
  #
  AF_CNT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Connection-oriented IP
  #
  AF_COIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Datakit protocol
  #
  AF_DATAKIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DECnet protocol
  #
  AF_DEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DECnet protocol
  #
  AF_DECnet: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DEC Direct Data Link Interface protocol
  #
  AF_DLI: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # CCITT (ITU-T) E.164 recommendation
  #
  AF_E164: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # European Computer Manufacturers protocols
  #
  AF_ECMA: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # NSC Hyperchannel protocol
  #
  AF_HYLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # InfiniBand native addressing
  #
  AF_IB: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ARPANET IMP protocol
  #
  AF_IMPLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPv4 protocol
  #
  AF_INET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPv6 protocol
  #
  AF_INET6: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPX protocol
  #
  AF_IPX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Integrated Services Digital Network
  #
  AF_ISDN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO Open Systems Interconnection protocols
  #
  AF_ISO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # KCM (kernel connection multiplexor) interface
  #
  AF_KCM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Key management protocol, originally developed for usage with IPsec
  #
  AF_KEY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Local Area Transport protocol
  #
  AF_LAT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Link layer interface
  #
  AF_LINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Logical  link control (IEEE 802.2 LLC) protocol
  #
  AF_LLC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Host-internal protocols
  #
  AF_LOCAL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum address family for this platform
  #
  AF_MAX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Multiprotocol Label Switching
  #
  AF_MPLS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Native ATM access
  #
  AF_NATM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Network driver raw access
  #
  AF_NDRV: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # NetBIOS
  #
  AF_NETBIOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Netgraph sockets
  #
  AF_NETGRAPH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Kernel user interface device
  #
  AF_NETLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # XEROX NS protocols
  #
  AF_NS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO Open Systems Interconnection protocols
  #
  AF_OSI: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Direct link-layer access
  #
  AF_PACKET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Point-to-Point Protocol
  #
  AF_PPP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE)
  #
  AF_PPPOX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # PARC Universal Packet protocol
  #
  AF_PUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Reliable Datagram Sockets (RDS) protocol
  #
  AF_RDS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Internal routing protocol
  #
  AF_ROUTE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Simple Internet Protocol
  #
  AF_SIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IBM SNA protocol
  #
  AF_SNA: Integer

  AF_SYSTEM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TIPC, "cluster domain sockets" protocol
  #
  AF_TIPC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # UNIX sockets
  #
  AF_UNIX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Unspecified protocol, any supported address family
  #
  AF_UNSPEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # VSOCK (originally "VMWare VSockets") protocol for hypervisor-guest
  # communication
  #
  AF_VSOCK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # XDP (express data path) interface
  #
  AF_XDP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Accept only if any address is assigned
  #
  AI_ADDRCONFIG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allow all addresses
  #
  AI_ALL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Fill in the canonical name
  #
  AI_CANONNAME: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Default flags for getaddrinfo
  #
  AI_DEFAULT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Valid flag mask for getaddrinfo (not for application use)
  #
  AI_MASK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Prevent host name resolution
  #
  AI_NUMERICHOST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Prevent service name resolution
  #
  AI_NUMERICSERV: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Get address to use with bind()
  #
  AI_PASSIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Accept IPv4-mapped IPv6 addresses
  #
  AI_V4MAPPED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Accept IPv4 mapped addresses if the kernel supports it
  #
  AI_V4MAPPED_CFG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Address family for hostname not supported
  #
  EAI_ADDRFAMILY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Temporary failure in name resolution
  #
  EAI_AGAIN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Invalid flags
  #
  EAI_BADFLAGS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Invalid value for hints
  #
  EAI_BADHINTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Non-recoverable failure in name resolution
  #
  EAI_FAIL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Address family not supported
  #
  EAI_FAMILY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum error code from getaddrinfo
  #
  EAI_MAX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Memory allocation failure
  #
  EAI_MEMORY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # No address associated with hostname
  #
  EAI_NODATA: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Hostname nor servname, or not known
  #
  EAI_NONAME: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Argument buffer overflow
  #
  EAI_OVERFLOW: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Resolved protocol is unknown
  #
  EAI_PROTOCOL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Servname not supported for socket type
  #
  EAI_SERVICE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Socket type not supported
  #
  EAI_SOCKTYPE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # System error returned in errno
  #
  EAI_SYSTEM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # 802.1Q VLAN device
  #
  IFF_802_1Q_VLAN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # receive all multicast packets
  #
  IFF_ALLMULTI: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # use alternate physical connection
  #
  IFF_ALTPHYS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # auto media select active
  #
  IFF_AUTOMEDIA: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # bonding master or slave
  #
  IFF_BONDING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # device used as bridge port
  #
  IFF_BRIDGE_PORT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # broadcast address valid
  #
  IFF_BROADCAST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # flags not changeable
  #
  IFF_CANTCHANGE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # unconfigurable using ioctl(2)
  #
  IFF_CANTCONFIG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # turn on debugging
  #
  IFF_DEBUG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # disable netpoll at run-time
  #
  IFF_DISABLE_NETPOLL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # disallow bridging this ether dev
  #
  IFF_DONT_BRIDGE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # driver signals dormant
  #
  IFF_DORMANT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # tx hardware queue is full
  #
  IFF_DRV_OACTIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # resources allocated
  #
  IFF_DRV_RUNNING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # interface is winding down
  #
  IFF_DYING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # dialup device with changing addresses
  #
  IFF_DYNAMIC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ethernet bridging device
  #
  IFF_EBRIDGE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # echo sent packets
  #
  IFF_ECHO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISATAP interface (RFC4214)
  #
  IFF_ISATAP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # per link layer defined bit 0
  #
  IFF_LINK0: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # per link layer defined bit 1
  #
  IFF_LINK1: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # per link layer defined bit 2
  #
  IFF_LINK2: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # hardware address change when it's running
  #
  IFF_LIVE_ADDR_CHANGE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # loopback net
  #
  IFF_LOOPBACK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # driver signals L1 up
  #
  IFF_LOWER_UP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # device used as macvlan port
  #
  IFF_MACVLAN_PORT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # master of a load balancer
  #
  IFF_MASTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # bonding master, 802.3ad.
  #
  IFF_MASTER_8023AD: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # bonding master, balance-alb.
  #
  IFF_MASTER_ALB: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # bonding master, ARP mon in use
  #
  IFF_MASTER_ARPMON: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # user-requested monitor mode
  #
  IFF_MONITOR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # supports multicast
  #
  IFF_MULTICAST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # no address resolution protocol
  #
  IFF_NOARP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # avoid use of trailers
  #
  IFF_NOTRAILERS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # transmission in progress
  #
  IFF_OACTIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # device used as Open vSwitch datapath port
  #
  IFF_OVS_DATAPATH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # point-to-point link
  #
  IFF_POINTOPOINT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # can set media type
  #
  IFF_PORTSEL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # user-requested promisc mode
  #
  IFF_PPROMISC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # receive all packets
  #
  IFF_PROMISC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # interface is being renamed
  #
  IFF_RENAMING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # routing entry installed
  #
  IFF_ROUTE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # resources allocated
  #
  IFF_RUNNING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # can't hear own transmissions
  #
  IFF_SIMPLEX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # slave of a load balancer
  #
  IFF_SLAVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # bonding slave not the curr. active
  #
  IFF_SLAVE_INACTIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # need ARPs for validation
  #
  IFF_SLAVE_NEEDARP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # interface manages own routes
  #
  IFF_SMART: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # static ARP
  #
  IFF_STATICARP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # sending custom FCS
  #
  IFF_SUPP_NOFCS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # used as team port
  #
  IFF_TEAM_PORT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # sharing skbs on transmit
  #
  IFF_TX_SKB_SHARING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # unicast filtering
  #
  IFF_UNICAST_FLT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # interface is up
  #
  IFF_UP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # volatile flags
  #
  IFF_VOLATILE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # WAN HDLC device
  #
  IFF_WAN_HDLC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # dev_hard_start_xmit() is allowed to release skb->dst
  #
  IFF_XMIT_DST_RELEASE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum interface name size
  #
  IFNAMSIZ: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum interface name size
  #
  IF_NAMESIZE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Multicast group for all systems on this subset
  #
  INADDR_ALLHOSTS_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A socket bound to INADDR_ANY receives packets from all interfaces and sends
  # from the default IP address
  #
  INADDR_ANY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The network broadcast address
  #
  INADDR_BROADCAST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The loopback address
  #
  INADDR_LOOPBACK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The last local network multicast group
  #
  INADDR_MAX_LOCAL_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A bitmask for matching no valid IP address
  #
  INADDR_NONE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The reserved multicast group
  #
  INADDR_UNSPEC_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum length of an IPv6 address string
  #
  INET6_ADDRSTRLEN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum length of an IPv4 address string
  #
  INET_ADDRSTRLEN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Default minimum address for bind or connect
  #
  IPPORT_RESERVED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Default maximum address for bind or connect
  #
  IPPORT_USERRESERVED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 auth header
  #
  IPPROTO_AH: Integer

  IPPROTO_BIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 destination option
  #
  IPPROTO_DSTOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Exterior Gateway Protocol
  #
  IPPROTO_EGP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO cnlp
  #
  IPPROTO_EON: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 Encapsulated Security Payload
  #
  IPPROTO_ESP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 fragmentation header
  #
  IPPROTO_FRAGMENT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Gateway to Gateway Protocol
  #
  IPPROTO_GGP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # "hello" routing protocol
  #
  IPPROTO_HELLO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 hop-by-hop options
  #
  IPPROTO_HOPOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Control message protocol
  #
  IPPROTO_ICMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ICMP6
  #
  IPPROTO_ICMPV6: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # XNS IDP
  #
  IPPROTO_IDP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Group Management Protocol
  #
  IPPROTO_IGMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Dummy protocol for IP
  #
  IPPROTO_IP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 header
  #
  IPPROTO_IPV6: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum IPPROTO constant
  #
  IPPROTO_MAX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Sun net disk protocol
  #
  IPPROTO_ND: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 no next header
  #
  IPPROTO_NONE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # PARC Universal Packet protocol
  #
  IPPROTO_PUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Raw IP packet
  #
  IPPROTO_RAW: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 routing header
  #
  IPPROTO_ROUTING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TCP
  #
  IPPROTO_TCP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO transport protocol class 4
  #
  IPPROTO_TP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # UDP
  #
  IPPROTO_UDP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Xpress Transport Protocol
  #
  IPPROTO_XTP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Checksum offset for raw sockets
  #
  IPV6_CHECKSUM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't fragment packets
  #
  IPV6_DONTFRAG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Destination option
  #
  IPV6_DSTOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Hop limit
  #
  IPV6_HOPLIMIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Hop-by-hop option
  #
  IPV6_HOPOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Join a group membership
  #
  IPV6_JOIN_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Leave a group membership
  #
  IPV6_LEAVE_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 multicast hops
  #
  IPV6_MULTICAST_HOPS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 multicast interface
  #
  IPV6_MULTICAST_IF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 multicast loopback
  #
  IPV6_MULTICAST_LOOP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Next hop address
  #
  IPV6_NEXTHOP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Retrieve current path MTU
  #
  IPV6_PATHMTU: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive packet information with datagram
  #
  IPV6_PKTINFO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive all IP6 options for response
  #
  IPV6_RECVDSTOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive hop limit with datagram
  #
  IPV6_RECVHOPLIMIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive hop-by-hop options
  #
  IPV6_RECVHOPOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive current path MTU with datagram
  #
  IPV6_RECVPATHMTU: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive destination IP address and incoming interface
  #
  IPV6_RECVPKTINFO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive routing header
  #
  IPV6_RECVRTHDR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive traffic class
  #
  IPV6_RECVTCLASS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allows removal of sticky routing headers
  #
  IPV6_RTHDR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allows removal of sticky destination options header
  #
  IPV6_RTHDRDSTOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Routing header type 0
  #
  IPV6_RTHDR_TYPE_0: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Specify the traffic class
  #
  IPV6_TCLASS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP6 unicast hops
  #
  IPV6_UNICAST_HOPS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Use the minimum MTU size
  #
  IPV6_USE_MIN_MTU: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Only bind IPv6 with a wildcard bind
  #
  IPV6_V6ONLY: Integer

  IPX_TYPE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Add a multicast group membership
  #
  IP_ADD_MEMBERSHIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Add a multicast group membership
  #
  IP_ADD_SOURCE_MEMBERSHIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Block IPv4 multicast packets with a give source address
  #
  IP_BLOCK_SOURCE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Default multicast loopback
  #
  IP_DEFAULT_MULTICAST_LOOP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Default multicast TTL
  #
  IP_DEFAULT_MULTICAST_TTL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't fragment packets
  #
  IP_DONTFRAG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Drop a multicast group membership
  #
  IP_DROP_MEMBERSHIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Drop a multicast group membership
  #
  IP_DROP_SOURCE_MEMBERSHIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allow binding to nonexistent IP addresses
  #
  IP_FREEBIND: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Header is included with data
  #
  IP_HDRINCL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPsec security policy
  #
  IP_IPSEC_POLICY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum number multicast groups a socket can join
  #
  IP_MAX_MEMBERSHIPS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Minimum TTL allowed for received packets
  #
  IP_MINTTL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Multicast source filtering
  #
  IP_MSFILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The Maximum Transmission Unit of the socket
  #
  IP_MTU: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Path MTU discovery
  #
  IP_MTU_DISCOVER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP multicast interface
  #
  IP_MULTICAST_IF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP multicast loopback
  #
  IP_MULTICAST_LOOP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP multicast TTL
  #
  IP_MULTICAST_TTL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Force outgoing broadcast datagrams to have the undirected broadcast address
  #
  IP_ONESBCAST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP options to be included in packets
  #
  IP_OPTIONS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Retrieve security context with datagram
  #
  IP_PASSSEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive packet information with datagrams
  #
  IP_PKTINFO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive packet options with datagrams
  #
  IP_PKTOPTIONS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Always send DF frames
  #
  IP_PMTUDISC_DO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Never send DF frames
  #
  IP_PMTUDISC_DONT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Use per-route hints
  #
  IP_PMTUDISC_WANT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the port range for sockets with unspecified port numbers
  #
  IP_PORTRANGE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive IP destination address with datagram
  #
  IP_RECVDSTADDR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Enable extended reliable error message passing
  #
  IP_RECVERR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive interface information with datagrams
  #
  IP_RECVIF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive all IP options with datagram
  #
  IP_RECVOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive all IP options for response
  #
  IP_RECVRETOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive link-layer address with datagrams
  #
  IP_RECVSLLA: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive TOS with incoming packets
  #
  IP_RECVTOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive IP TTL with datagrams
  #
  IP_RECVTTL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP options to be included in datagrams
  #
  IP_RETOPTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Notify transit routers to more closely examine the contents of an IP packet
  #
  IP_ROUTER_ALERT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Source address for outgoing UDP datagrams
  #
  IP_SENDSRCADDR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP type-of-service
  #
  IP_TOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Transparent proxy
  #
  IP_TRANSPARENT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP time-to-live
  #
  IP_TTL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Unblock IPv4 multicast packets with a give source address
  #
  IP_UNBLOCK_SOURCE: Integer

  IP_XFRM_POLICY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Connect blocks until accepted
  #
  LOCAL_CONNWAIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Pass credentials to receiver
  #
  LOCAL_CREDS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Retrieve peer credentials
  #
  LOCAL_PEERCRED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Block multicast packets from this source
  #
  MCAST_BLOCK_SOURCE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Exclusive multicast source filter
  #
  MCAST_EXCLUDE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Inclusive multicast source filter
  #
  MCAST_INCLUDE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Join a multicast group
  #
  MCAST_JOIN_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Join a multicast source group
  #
  MCAST_JOIN_SOURCE_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Leave a multicast group
  #
  MCAST_LEAVE_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Leave a multicast source group
  #
  MCAST_LEAVE_SOURCE_GROUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Multicast source filtering
  #
  MCAST_MSFILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Unblock multicast packets from this source
  #
  MCAST_UNBLOCK_SOURCE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # End of record
  #
  MSG_COMPAT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Confirm path validity
  #
  MSG_CONFIRM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Control data lost before delivery
  #
  MSG_CTRUNC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send without using the routing tables
  #
  MSG_DONTROUTE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # This message should be non-blocking
  #
  MSG_DONTWAIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Data completes connection
  #
  MSG_EOF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Data completes record
  #
  MSG_EOR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Fetch message from error queue
  #
  MSG_ERRQUEUE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Reduce step of the handshake process
  #
  MSG_FASTOPEN: Integer

  MSG_FIN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Start of a hold sequence.  Dumps to so_temp
  #
  MSG_FLUSH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Data ready to be read
  #
  MSG_HAVEMORE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Hold fragment in so_temp
  #
  MSG_HOLD: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Sender will send more
  #
  MSG_MORE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Do not generate SIGPIPE
  #
  MSG_NOSIGNAL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Process out-of-band data
  #
  MSG_OOB: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Peek at incoming message
  #
  MSG_PEEK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Wait for full request
  #
  MSG_PROXY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Data remains in the current packet
  #
  MSG_RCVMORE: Integer

  MSG_RST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send the packet in so_temp
  #
  MSG_SEND: Integer

  MSG_SYN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Data discarded before delivery
  #
  MSG_TRUNC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Wait for full request or error
  #
  MSG_WAITALL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The service specified is a datagram service (looks up UDP ports)
  #
  NI_DGRAM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum length of a hostname
  #
  NI_MAXHOST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum length of a service name
  #
  NI_MAXSERV: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A name is required
  #
  NI_NAMEREQD: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # An FQDN is not required for local hosts, return only the local part
  #
  NI_NOFQDN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Return a numeric address
  #
  NI_NUMERICHOST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Return the service name as a digit string
  #
  NI_NUMERICSERV: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Interface to kernel crypto API
  #
  PF_ALG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AppleTalk protocol
  #
  PF_APPLETALK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Asynchronous Transfer Mode
  #
  PF_ATM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AX.25 protocol
  #
  PF_AX25: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Bluetooth low-level socket protocol
  #
  PF_BLUETOOTH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Controller Area Network automotive bus protocol
  #
  PF_CAN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # CCITT (now ITU-T) protocols
  #
  PF_CCITT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # MIT CHAOS protocols
  #
  PF_CHAOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Computer Network Technology
  #
  PF_CNT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Connection-oriented IP
  #
  PF_COIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Datakit protocol
  #
  PF_DATAKIT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DECnet protocol
  #
  PF_DEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DECnet protocol
  #
  PF_DECnet: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # DEC Direct Data Link Interface protocol
  #
  PF_DLI: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # European Computer Manufacturers protocols
  #
  PF_ECMA: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # NSC Hyperchannel protocol
  #
  PF_HYLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # InfiniBand native addressing
  #
  PF_IB: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ARPANET IMP protocol
  #
  PF_IMPLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPv4 protocol
  #
  PF_INET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPv6 protocol
  #
  PF_INET6: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPX protocol
  #
  PF_IPX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Integrated Services Digital Network
  #
  PF_ISDN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO Open Systems Interconnection protocols
  #
  PF_ISO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # KCM (kernel connection multiplexor) interface
  #
  PF_KCM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Key management protocol, originally developed for usage with IPsec
  #
  PF_KEY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Local Area Transport protocol
  #
  PF_LAT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Link layer interface
  #
  PF_LINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Logical  link control (IEEE 802.2 LLC) protocol
  #
  PF_LLC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Host-internal protocols
  #
  PF_LOCAL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum address family for this platform
  #
  PF_MAX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Multiprotocol Label Switching
  #
  PF_MPLS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Native ATM access
  #
  PF_NATM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Network driver raw access
  #
  PF_NDRV: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # NetBIOS
  #
  PF_NETBIOS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Netgraph sockets
  #
  PF_NETGRAPH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Kernel user interface device
  #
  PF_NETLINK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # XEROX NS protocols
  #
  PF_NS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # ISO Open Systems Interconnection protocols
  #
  PF_OSI: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Direct link-layer access
  #
  PF_PACKET: Integer

  PF_PIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Point-to-Point Protocol
  #
  PF_PPP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE)
  #
  PF_PPPOX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # PARC Universal Packet protocol
  #
  PF_PUP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Reliable Datagram Sockets (RDS) protocol
  #
  PF_RDS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Internal routing protocol
  #
  PF_ROUTE: Integer

  PF_RTIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Simple Internet Protocol
  #
  PF_SIP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IBM SNA protocol
  #
  PF_SNA: Integer

  PF_SYSTEM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TIPC, "cluster domain sockets" protocol
  #
  PF_TIPC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # UNIX sockets
  #
  PF_UNIX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Unspecified protocol, any supported address family
  #
  PF_UNSPEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # VSOCK (originally "VMWare VSockets") protocol for hypervisor-guest
  # communication
  #
  PF_VSOCK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # XDP (express data path) interface
  #
  PF_XDP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # eXpress Transfer Protocol
  #
  PF_XTP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Timestamp (bintime)
  #
  SCM_BINTIME: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The sender's credentials
  #
  SCM_CREDENTIALS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Process credentials
  #
  SCM_CREDS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Access rights
  #
  SCM_RIGHTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Timestamp (timeval)
  #
  SCM_TIMESTAMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Timestamp (timespec list) (Linux 2.6.30)
  #
  SCM_TIMESTAMPING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Timespec (timespec)
  #
  SCM_TIMESTAMPNS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # User credentials
  #
  SCM_UCRED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Wifi status (Linux 3.3)
  #
  SCM_WIFI_STATUS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Shut down the reading side of the socket
  #
  SHUT_RD: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Shut down the both sides of the socket
  #
  SHUT_RDWR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Shut down the writing side of the socket
  #
  SHUT_WR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the close-on-exec (FD_CLOEXEC) flag on the new file  descriptor.
  #
  SOCK_CLOEXEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A datagram socket provides connectionless, unreliable messaging
  #
  SOCK_DGRAM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the O_NONBLOCK file status flag on the open file description (see open(2))
  # referred to by the new file descriptor.
  #
  SOCK_NONBLOCK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Device-level packet access
  #
  SOCK_PACKET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A raw socket provides low-level access for direct access or implementing
  # network protocols
  #
  SOCK_RAW: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A reliable datagram socket provides reliable delivery of messages
  #
  SOCK_RDM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A sequential packet socket provides sequenced, reliable two-way connection for
  # datagrams
  #
  SOCK_SEQPACKET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # A stream socket provides a sequenced, reliable two-way connection for a byte
  # stream
  #
  SOCK_STREAM: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AppleTalk socket options
  #
  SOL_ATALK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # AX.25 socket options
  #
  SOL_AX25: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IP socket options
  #
  SOL_IP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # IPX socket options
  #
  SOL_IPX: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Socket-level options
  #
  SOL_SOCKET: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TCP socket options
  #
  SOL_TCP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # UDP socket options
  #
  SOL_UDP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum connection requests that may be queued for a socket
  #
  SOMAXCONN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Background socket priority
  #
  SOPRI_BACKGROUND: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Interactive socket priority
  #
  SOPRI_INTERACTIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Normal socket priority
  #
  SOPRI_NORMAL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Socket has had listen() called on it
  #
  SO_ACCEPTCONN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # There is an accept filter
  #
  SO_ACCEPTFILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Bypass zone boundaries
  #
  SO_ALLZONES: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Attach an accept filter
  #
  SO_ATTACH_FILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Only send packets from the given interface
  #
  SO_BINDTODEVICE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive timestamp with datagrams (bintime)
  #
  SO_BINTIME: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Query supported BPF extensions (Linux 3.14)
  #
  SO_BPF_EXTENSIONS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Permit sending of broadcast messages
  #
  SO_BROADCAST: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the threshold in microseconds for low latency polling (Linux 3.11)
  #
  SO_BUSY_POLL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Debug info recording
  #
  SO_DEBUG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Detach an accept filter
  #
  SO_DETACH_FILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Domain given for socket() (Linux 2.6.32)
  #
  SO_DOMAIN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Use interface addresses
  #
  SO_DONTROUTE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Retain unread data
  #
  SO_DONTTRUNC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Get and clear the error status
  #
  SO_ERROR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Obtain filter set by SO_ATTACH_FILTER (Linux 3.8)
  #
  SO_GET_FILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Keep connections alive
  #
  SO_KEEPALIVE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Linger on close if data is present
  #
  SO_LINGER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Lock the filter attached to a socket (Linux 3.9)
  #
  SO_LOCK_FILTER: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Mandatory Access Control exemption for unlabeled peers
  #
  SO_MAC_EXEMPT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the mark for mark-based routing (Linux 2.6.25)
  #
  SO_MARK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Cap the rate computed by transport layer. [bytes per second] (Linux 3.13)
  #
  SO_MAX_PACING_RATE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Install socket-level Network Kernel Extension
  #
  SO_NKE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set netns of a socket (Linux 3.4)
  #
  SO_NOFCS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't SIGPIPE on EPIPE
  #
  SO_NOSIGPIPE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Disable checksums
  #
  SO_NO_CHECK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Get first packet byte count
  #
  SO_NREAD: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Leave received out-of-band data in-line
  #
  SO_OOBINLINE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive SCM_CREDENTIALS messages
  #
  SO_PASSCRED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Toggle security context passing (Linux 2.6.18)
  #
  SO_PASSSEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set the peek offset (Linux 3.4)
  #
  SO_PEEK_OFF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The credentials of the foreign process connected to this socket
  #
  SO_PEERCRED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Name of the connecting user
  #
  SO_PEERNAME: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Obtain the security credentials (Linux 2.6.2)
  #
  SO_PEERSEC: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # The protocol-defined priority for all packets on this socket
  #
  SO_PRIORITY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Protocol given for socket() (Linux 2.6.32)
  #
  SO_PROTOCOL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive buffer size
  #
  SO_RCVBUF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive buffer size without rmem_max limit (Linux 2.6.14)
  #
  SO_RCVBUFFORCE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive low-water mark
  #
  SO_RCVLOWAT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive timeout
  #
  SO_RCVTIMEO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive user credentials with datagram
  #
  SO_RECVUCRED: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allow local address reuse
  #
  SO_REUSEADDR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Allow local address and port reuse
  #
  SO_REUSEPORT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Toggle cmsg for number of packets dropped (Linux 2.6.33)
  #
  SO_RXQ_OVFL: Integer

  SO_SECURITY_AUTHENTICATION: Integer

  SO_SECURITY_ENCRYPTION_NETWORK: Integer

  SO_SECURITY_ENCRYPTION_TRANSPORT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Make select() detect socket error queue with errorfds (Linux 3.10)
  #
  SO_SELECT_ERR_QUEUE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send buffer size
  #
  SO_SNDBUF: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send buffer size without wmem_max limit (Linux 2.6.14)
  #
  SO_SNDBUFFORCE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send low-water mark
  #
  SO_SNDLOWAT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Send timeout
  #
  SO_SNDTIMEO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive timestamp with datagrams (timeval)
  #
  SO_TIMESTAMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Time stamping of incoming and outgoing packets (Linux 2.6.30)
  #
  SO_TIMESTAMPING: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Receive nanosecond timestamp with datagrams (timespec)
  #
  SO_TIMESTAMPNS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Get the socket type
  #
  SO_TYPE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Bypass hardware when possible
  #
  SO_USELOOPBACK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Give a hint when more data is ready
  #
  SO_WANTMORE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # OOB data is wanted in MSG_FLAG on receive
  #
  SO_WANTOOBFLAG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Toggle cmsg for wifi status (Linux 3.3)
  #
  SO_WIFI_STATUS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TCP congestion control algorithm (Linux 2.6.13, glibc 2.6)
  #
  TCP_CONGESTION: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TCP Cookie Transactions (Linux 2.6.33, glibc 2.18)
  #
  TCP_COOKIE_TRANSACTIONS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't send partial frames (Linux 2.2, glibc 2.2)
  #
  TCP_CORK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't notify a listening socket until data is ready (Linux 2.4, glibc 2.2)
  #
  TCP_DEFER_ACCEPT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Reduce step of the handshake process (Linux 3.7, glibc 2.18)
  #
  TCP_FASTOPEN: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Retrieve information about this socket (Linux 2.4, glibc 2.2)
  #
  TCP_INFO: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Maximum number of keepalive probes allowed before dropping a connection (Linux
  # 2.4, glibc 2.2)
  #
  TCP_KEEPCNT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Idle time before keepalive probes are sent (Linux 2.4, glibc 2.2)
  #
  TCP_KEEPIDLE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Time between keepalive probes (Linux 2.4, glibc 2.2)
  #
  TCP_KEEPINTVL: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Lifetime of orphaned FIN_WAIT2 sockets (Linux 2.4, glibc 2.2)
  #
  TCP_LINGER2: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Set maximum segment size
  #
  TCP_MAXSEG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Use MD5 digests (RFC2385, Linux 2.6.20, glibc 2.7)
  #
  TCP_MD5SIG: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't delay sending to coalesce packets
  #
  TCP_NODELAY: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't use TCP options
  #
  TCP_NOOPT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't push the last block of write
  #
  TCP_NOPUSH: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Sequence of a queue for repair mode (Linux 3.5, glibc 2.18)
  #
  TCP_QUEUE_SEQ: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Enable quickack mode (Linux 2.4.4, glibc 2.3)
  #
  TCP_QUICKACK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Repair mode (Linux 3.5, glibc 2.18)
  #
  TCP_REPAIR: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Options for repair mode (Linux 3.5, glibc 2.18)
  #
  TCP_REPAIR_OPTIONS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Queue for repair mode (Linux 3.5, glibc 2.18)
  #
  TCP_REPAIR_QUEUE: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Number of SYN retransmits before a connection is dropped (Linux 2.4, glibc
  # 2.2)
  #
  TCP_SYNCNT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Duplicated acknowledgments handling for thin-streams (Linux 2.6.34, glibc
  # 2.18)
  #
  TCP_THIN_DUPACK: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Linear timeouts for thin-streams (Linux 2.6.34, glibc 2.18)
  #
  TCP_THIN_LINEAR_TIMEOUTS: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # TCP timestamp (Linux 3.9, glibc 2.18)
  #
  TCP_TIMESTAMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Max timeout before a TCP connection is aborted (Linux 2.6.37, glibc 2.18)
  #
  TCP_USER_TIMEOUT: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Clamp the size of the advertised window (Linux 2.4, glibc 2.2)
  #
  TCP_WINDOW_CLAMP: Integer

  # <!-- rdoc-file=ext/socket/constdefs.c -->
  # Don't send partial frames (Linux 2.5.44, glibc 2.11)
  #
  UDP_CORK: Integer
end
# <!-- rdoc-file=ext/socket/udpsocket.c -->
# UDPSocket represents a UDP/IP socket.
#
class UDPSocket < IPSocket
  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.bind(host, port) #=> 0
  # -->
  # Binds *udpsocket* to *host*:*port*.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u1.send "message-to-self", 0, "127.0.0.1", 4913
  #     p u1.recvfrom(10) #=> ["message-to", ["AF_INET", 4913, "localhost", "127.0.0.1"]]
  #
  def bind: (String host, Integer port) -> void

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.connect(host, port) => 0
  # -->
  # Connects *udpsocket* to *host*:*port*.
  #
  # This makes possible to send without destination address.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u2 = UDPSocket.new
  #     u2.connect("127.0.0.1", 4913)
  #     u2.send "uuuu", 0
  #     p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]
  #
  def connect: (String host, Integer port) -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - udpsocket.recvfrom_nonblock(maxlen [, flags[, outbuf [, options]]]) => [mesg, sender_inet_addr]
  # -->
  # Receives up to *maxlen* bytes from `udpsocket` using recvfrom(2) after
  # O_NONBLOCK is set for the underlying file descriptor. *flags* is zero or more
  # of the `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_inet_addr*, is an array to represent the
  # sender address.
  #
  # When recvfrom(2) returns 0, Socket#recv_nonblock returns nil. In most cases it
  # means the connection was closed, but it may also mean an empty packet was
  # received, as the underlying API makes it impossible to distinguish these two
  # cases.
  #
  # ### Parameters
  # *   `maxlen` - the number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `outbuf` - destination String buffer
  # *   `options` - keyword hash, supporting `exception: false`
  #
  # ### Example
  #     require 'socket'
  #     s1 = UDPSocket.new
  #     s1.bind("127.0.0.1", 0)
  #     s2 = UDPSocket.new
  #     s2.bind("127.0.0.1", 0)
  #     s2.connect(*s1.addr.values_at(3,1))
  #     s1.connect(*s2.addr.values_at(3,1))
  #     s1.send "aaa", 0
  #     begin # emulate blocking recvfrom
  #       p s2.recvfrom_nonblock(10)  #=> ["aaa", ["AF_INET", 33302, "localhost.localdomain", "127.0.0.1"]]
  #     rescue IO::WaitReadable
  #       IO.select([s2])
  #       retry
  #     end
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recvfrom_nonblock* fails.
  #
  # UDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recvfrom_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recvfrom_nonblock: (Integer len, ?Integer flag, ?String outbuf, ?exception: boolish) -> [ String, [ String, Integer, String, String ] ]

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.send(mesg, flags, host, port)  => numbytes_sent
  #   - udpsocket.send(mesg, flags, sockaddr_to) => numbytes_sent
  #   - udpsocket.send(mesg, flags)              => numbytes_sent
  # -->
  # Sends *mesg* via *udpsocket*.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #
  #     u2 = UDPSocket.new
  #     u2.send "hi", 0, "127.0.0.1", 4913
  #
  #     mesg, addr = u1.recvfrom(10)
  #     u1.send mesg, 0, addr[3], addr[1]
  #
  #     p u2.recv(100) #=> "hi"
  #
  def send: (String msg, ?Integer flags, ?String host, ?Integer port) -> Integer

  private

  def __recvfrom_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - UDPSocket.new([address_family]) => socket
  # -->
  # Creates a new UDPSocket object.
  #
  # *address_family* should be an integer, a string or a symbol: Socket::AF_INET,
  # "AF_INET", :INET, etc.
  #
  #     require 'socket'
  #
  #     UDPSocket.new                   #=> #<UDPSocket:fd 3>
  #     UDPSocket.new(Socket::AF_INET6) #=> #<UDPSocket:fd 4>
  #
  def initialize: (?Integer family) -> untyped
end
# <!-- rdoc-file=ext/socket/init.c -->
# SocketError is the error class for socket.
#
class SocketError < StandardError
end
# <!-- rdoc-file=ext/socket/unixserver.c -->
# UNIXServer represents a UNIX domain stream server socket.
#
class UNIXServer < UNIXSocket
  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - unixserver.accept => unixsocket
  # -->
  # Accepts an incoming connection. It returns a new UNIXSocket object.
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         s = serv.accept
  #         s.puts "hi"
  #         s.close
  #         p c.read #=> "hi\n"
  #       }
  #     }
  #
  def accept: () -> UNIXSocket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unixserver.accept_nonblock([options]) => unixsocket
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an accepted UNIXSocket for the incoming
  # connection.
  #
  # ### Example
  #     require 'socket'
  #     serv = UNIXServer.new("/tmp/sock")
  #     begin # emulate blocking accept
  #       sock = serv.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([serv])
  #       retry
  #     end
  #     # sock is an accepted socket.
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # UNIXServer#accept_nonblock fails.
  #
  # UNIXServer#accept_nonblock may raise any error corresponding to accept(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   UNIXServer#accept
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> (UNIXSocket | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog) -> void

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - unixserver.sysaccept => file_descriptor
  # -->
  # Accepts a new connection. It returns the new file descriptor which is an
  # integer.
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         fd = serv.sysaccept
  #         s = IO.new(fd)
  #         s.puts "hi"
  #         s.close
  #         p c.read #=> "hi\n"
  #       }
  #     }
  #
  def sysaccept: () -> Integer

  private

  def __accept_nonblock: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - UNIXServer.new(path) => unixserver
  # -->
  # Creates a new UNIX server socket bound to *path*.
  #
  #     require 'socket'
  #
  #     serv = UNIXServer.new("/tmp/sock")
  #     s = serv.accept
  #     p s.read
  #
  def initialize: (untyped) -> untyped
end
# <!-- rdoc-file=ext/socket/tcpserver.c -->
# TCPServer represents a TCP/IP server socket.
#
# A simple TCP server may look like:
#
#     require 'socket'
#
#     server = TCPServer.new 2000 # Server bind to port 2000
#     loop do
#       client = server.accept    # Wait for a client to connect
#       client.puts "Hello !"
#       client.puts "Time is #{Time.now}"
#       client.close
#     end
#
# A more usable server (serving multiple clients):
#
#     require 'socket'
#
#     server = TCPServer.new 2000
#     loop do
#       Thread.start(server.accept) do |client|
#         client.puts "Hello !"
#         client.puts "Time is #{Time.now}"
#         client.close
#       end
#     end
#
class TCPServer < TCPSocket
  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - tcpserver.accept => tcpsocket
  # -->
  # Accepts an incoming connection. It returns a new TCPSocket object.
  #
  #     TCPServer.open("127.0.0.1", 14641) {|serv|
  #       s = serv.accept
  #       s.puts Time.now
  #       s.close
  #     }
  #
  def accept: () -> TCPSocket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcpserver.accept_nonblock([options]) => tcpsocket
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an accepted TCPSocket for the incoming
  # connection.
  #
  # ### Example
  #     require 'socket'
  #     serv = TCPServer.new(2202)
  #     begin # emulate blocking accept
  #       sock = serv.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([serv])
  #       retry
  #     end
  #     # sock is an accepted socket.
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # TCPServer#accept_nonblock fails.
  #
  # TCPServer#accept_nonblock may raise any error corresponding to accept(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED,
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   TCPServer#accept
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> (TCPSocket | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog) -> void

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - tcpserver.sysaccept => file_descriptor
  # -->
  # Returns a file descriptor of a accepted connection.
  #
  #     TCPServer.open("127.0.0.1", 28561) {|serv|
  #       fd = serv.sysaccept
  #       s = IO.for_fd(fd)
  #       s.puts Time.now
  #       s.close
  #     }
  #
  def sysaccept: () -> Integer

  private

  def __accept_nonblock: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - TCPServer.new([hostname,] port) => tcpserver
  # -->
  # Creates a new server socket bound to *port*.
  #
  # If *hostname* is given, the socket is bound to it.
  #
  #     serv = TCPServer.new("127.0.0.1", 28561)
  #     s = serv.accept
  #     s.puts Time.now
  #     s.close
  #
  # Internally, TCPServer.new calls getaddrinfo() function to obtain addresses. If
  # getaddrinfo() returns multiple addresses, TCPServer.new tries to create a
  # server socket for each address and returns first one that is successful.
  #
  def initialize: (?String host, Integer port) -> untyped
end
# <!-- rdoc-file=ext/socket/raddrinfo.c -->
# The Addrinfo class maps `struct addrinfo` to ruby.  This structure identifies
# an Internet host and a service.
#
class Addrinfo
  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - foreach(nodename, service, family=nil, socktype=nil, protocol=nil, flags=nil, timeout: nil, &block)
  # -->
  # iterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo.
  #
  #     Addrinfo.foreach(nil, 80) {|x| p x }
  #     #=> #<Addrinfo: 127.0.0.1:80 TCP (:80)>
  #     #   #<Addrinfo: 127.0.0.1:80 UDP (:80)>
  #     #   #<Addrinfo: [::1]:80 TCP (:80)>
  #     #   #<Addrinfo: [::1]:80 UDP (:80)>
  #
  def self.foreach: (String? nodename, String | Integer service, ?Integer? family, ?Symbol socktype, ?Symbol | Integer protocol, ?Integer flags, ?timeout: Numeric) { (Addrinfo) -> void } -> void
                  | (String? nodename, String | Integer service, ?Integer? family, ?Symbol socktype, ?Symbol | Integer protocol, ?Integer flags, ?timeout: Numeric) -> Enumerable[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags) => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol)        => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype)                  => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family)                            => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service)                                    => [addrinfo, ...]
  # -->
  # returns a list of addrinfo objects as an array.
  #
  # This method converts nodename (hostname) and service (port) to addrinfo. Since
  # the conversion is not unique, the result is a list of addrinfo objects.
  #
  # nodename or service can be nil if no conversion intended.
  #
  # family, socktype and protocol are hint for preferred protocol. If the result
  # will be used for a socket with SOCK_STREAM, SOCK_STREAM should be specified as
  # socktype. If so, Addrinfo.getaddrinfo returns addrinfo list appropriate for
  # SOCK_STREAM. If they are omitted or nil is given, the result is not
  # restricted.
  #
  # Similarly, PF_INET6 as family restricts for IPv6.
  #
  # flags should be bitwise OR of Socket::AI_??? constants such as follows. Note
  # that the exact list of the constants depends on OS.
  #
  #     AI_PASSIVE      Get address to use with bind()
  #     AI_CANONNAME    Fill in the canonical name
  #     AI_NUMERICHOST  Prevent host name resolution
  #     AI_NUMERICSERV  Prevent service name resolution
  #     AI_V4MAPPED     Accept IPv4-mapped IPv6 addresses
  #     AI_ALL          Allow all addresses
  #     AI_ADDRCONFIG   Accept only if any address is assigned
  #
  # Note that socktype should be specified whenever application knows the usage of
  # the address. Some platform causes an error when socktype is omitted and
  # servname is specified as an integer because some port numbers, 512 for
  # example, are ambiguous without socktype.
  #
  #     Addrinfo.getaddrinfo("www.kame.net", 80, nil, :STREAM)
  #     #=> [#<Addrinfo: 203.178.141.194:80 TCP (www.kame.net)>,
  #     #    #<Addrinfo: [2001:200:dff:fff1:216:3eff:feb1:44d7]:80 TCP (www.kame.net)>]
  #
  def self.getaddrinfo: (String nodename, ?String | Integer | nil service, ?Symbol? family, ?Symbol | Integer protocol) -> Array[Addrinfo]
                      | (String? nodename, ?String | Integer service, ?Symbol? family, ?Symbol | Integer protocol) -> Array[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.ip(host) => addrinfo
  # -->
  # returns an addrinfo object for IP address.
  #
  # The port, socktype, protocol of the result is filled by zero. So, it is not
  # appropriate to create a socket.
  #
  #     Addrinfo.ip("localhost") #=> #<Addrinfo: 127.0.0.1 (localhost)>
  #
  def self.ip: (String host) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.tcp(host, port) => addrinfo
  # -->
  # returns an addrinfo object for TCP address.
  #
  #     Addrinfo.tcp("localhost", "smtp") #=> #<Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)>
  #
  def self.tcp: (String host, String | Integer service) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.udp(host, port) => addrinfo
  # -->
  # returns an addrinfo object for UDP address.
  #
  #     Addrinfo.udp("localhost", "daytime") #=> #<Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)>
  #
  def self.udp: (String host, String | Integer service) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.unix(path [, socktype]) => addrinfo
  # -->
  # returns an addrinfo object for UNIX socket address.
  #
  # *socktype* specifies the socket type. If it is omitted, :STREAM is used.
  #
  #     Addrinfo.unix("/tmp/sock")         #=> #<Addrinfo: /tmp/sock SOCK_STREAM>
  #     Addrinfo.unix("/tmp/sock", :DGRAM) #=> #<Addrinfo: /tmp/sock SOCK_DGRAM>
  #
  def self.unix: (String path, ?Symbol socktype) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.afamily => integer
  # -->
  # returns the address family as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).afamily == Socket::AF_INET #=> true
  #
  def afamily: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - bind() { |sock| ... }
  # -->
  # creates a socket bound to self.
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.udp("0.0.0.0", 9981).bind {|s|
  #       s.local_address.connect {|s| s.send "hello", 0 }
  #       p s.recv(10) #=> "hello"
  #     }
  #
  def bind: () -> Socket
          | () { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.canonname => string or nil
  # -->
  # returns the canonical name as a string.
  #
  # nil is returned if no canonical name.
  #
  # The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is
  # specified.
  #
  #     list = Addrinfo.getaddrinfo("www.ruby-lang.org", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
  #     p list[0] #=> #<Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org)>
  #     p list[0].canonname #=> "carbon.ruby-lang.org"
  #
  def canonname: () -> String

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect([opts]) {|socket| ... }
  #   - addrinfo.connect([opts])
  # -->
  # creates a socket connected to the address of self.
  #
  # The optional argument *opts* is options represented by a hash. *opts* may have
  # following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect: (?timeout: Numeric) { (Socket) -> void } -> void
             | (?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect_from([local_addr_args], [opts]) {|socket| ... }
  #   - addrinfo.connect_from([local_addr_args], [opts])
  # -->
  # creates a socket connected to the address of self.
  #
  # If one or more arguments given as *local_addr_args*, it is used as the local
  # address of the socket. *local_addr_args* is given for family_addrinfo to
  # obtain actual address.
  #
  # If *local_addr_args* is not given, the local address of the socket is not
  # bound.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect_from("0.0.0.0", 4649) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  #     # Addrinfo object can be taken for the argument.
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect_from(Addrinfo.tcp("0.0.0.0", 4649)) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect_from: (String host, Integer port, ?timeout: Numeric) { (Socket) -> void } -> void
                  | (String host, Integer port, ?timeout: Numeric) -> Socket
                  | (Addrinfo sockaddr, ?timeout: Numeric) { (Socket) -> void } -> void
                  | (Addrinfo sockaddr, ?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect_to([remote_addr_args], [opts]) {|socket| ... }
  #   - addrinfo.connect_to([remote_addr_args], [opts])
  # -->
  # creates a socket connected to *remote_addr_args* and bound to self.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("0.0.0.0", 4649).connect_to("www.ruby-lang.org", 80) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect_to: (String host, Integer port, ?timeout: Numeric) { (Socket) -> void } -> void
                | (String host, Integer port, ?timeout: Numeric) -> Socket
                | (Addrinfo sockaddr, ?timeout: Numeric) { (Socket) -> void } -> void
                | (Addrinfo sockaddr, ?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - family_addrinfo(*args)
  # -->
  # creates an Addrinfo object from the arguments.
  #
  # The arguments are interpreted as similar to self.
  #
  #     Addrinfo.tcp("0.0.0.0", 4649).family_addrinfo("www.ruby-lang.org", 80)
  #     #=> #<Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)>
  #
  #     Addrinfo.unix("/tmp/sock").family_addrinfo("/tmp/sock2")
  #     #=> #<Addrinfo: /tmp/sock2 SOCK_STREAM>
  #
  def family_addrinfo: (String host, Integer port) -> Addrinfo
                     | (String path) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.getnameinfo        => [nodename, service]
  #   - addrinfo.getnameinfo(flags) => [nodename, service]
  # -->
  # returns nodename and service as a pair of strings. This converts struct
  # sockaddr in addrinfo to textual representation.
  #
  # flags should be bitwise OR of Socket::NI_??? constants.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).getnameinfo #=> ["localhost", "www"]
  #
  #     Addrinfo.tcp("127.0.0.1", 80).getnameinfo(Socket::NI_NUMERICSERV)
  #     #=> ["localhost", "80"]
  #
  def getnameinfo: (?Integer flags) -> [ String, Integer ]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.inspect => string
  # -->
  # returns a string which shows addrinfo in human-readable form.
  #
  #     Addrinfo.tcp("localhost", 80).inspect #=> "#<Addrinfo: 127.0.0.1:80 TCP (localhost)>"
  #     Addrinfo.unix("/tmp/sock").inspect    #=> "#<Addrinfo: /tmp/sock SOCK_STREAM>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.inspect_sockaddr => string
  # -->
  # returns a string which shows the sockaddr in *addrinfo* with human-readable
  # form.
  #
  #     Addrinfo.tcp("localhost", 80).inspect_sockaddr     #=> "127.0.0.1:80"
  #     Addrinfo.tcp("ip6-localhost", 80).inspect_sockaddr #=> "[::1]:80"
  #     Addrinfo.unix("/tmp/sock").inspect_sockaddr        #=> "/tmp/sock"
  #
  def inspect_sockaddr: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip? => true or false
  # -->
  # returns true if addrinfo is internet (IPv4/IPv6) address. returns false
  # otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip? #=> true
  #     Addrinfo.tcp("::1", 80).ip?       #=> true
  #     Addrinfo.unix("/tmp/sock").ip?    #=> false
  #
  def ip?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_address => string
  # -->
  # Returns the IP address as a string.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_address    #=> "127.0.0.1"
  #     Addrinfo.tcp("::1", 80).ip_address          #=> "::1"
  #
  def ip_address: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_port => port
  # -->
  # Returns the port number as an integer.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_port    #=> 80
  #     Addrinfo.tcp("::1", 80).ip_port          #=> 80
  #
  def ip_port: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_unpack => [addr, port]
  # -->
  # Returns the IP address and port number as 2-element array.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_unpack    #=> ["127.0.0.1", 80]
  #     Addrinfo.tcp("::1", 80).ip_unpack          #=> ["::1", 80]
  #
  def ip_unpack: () -> [ String, Integer ]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ipv4? => true or false
  # -->
  # returns true if addrinfo is IPv4 address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ipv4? #=> true
  #     Addrinfo.tcp("::1", 80).ipv4?       #=> false
  #     Addrinfo.unix("/tmp/sock").ipv4?    #=> false
  #
  def ipv4?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_loopback?()
  # -->
  # Returns true for IPv4 loopback address (127.0.0.0/8). It returns false
  # otherwise.
  #
  def ipv4_loopback?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_multicast?()
  # -->
  # Returns true for IPv4 multicast address (224.0.0.0/4). It returns false
  # otherwise.
  #
  def ipv4_multicast?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_private?()
  # -->
  # Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,
  # 192.168.0.0/16). It returns false otherwise.
  #
  def ipv4_private?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ipv6? => true or false
  # -->
  # returns true if addrinfo is IPv6 address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ipv6? #=> false
  #     Addrinfo.tcp("::1", 80).ipv6?       #=> true
  #     Addrinfo.unix("/tmp/sock").ipv6?    #=> false
  #
  def ipv6?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_linklocal?()
  # -->
  # Returns true for IPv6 link local address (fe80::/10). It returns false
  # otherwise.
  #
  def ipv6_linklocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_loopback?()
  # -->
  # Returns true for IPv6 loopback address (::1). It returns false otherwise.
  #
  def ipv6_loopback?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_global?()
  # -->
  # Returns true for IPv6 multicast global scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_global?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_linklocal?()
  # -->
  # Returns true for IPv6 multicast link-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_linklocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_nodelocal?()
  # -->
  # Returns true for IPv6 multicast node-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_nodelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_orglocal?()
  # -->
  # Returns true for IPv6 multicast organization-local scope address. It returns
  # false otherwise.
  #
  def ipv6_mc_orglocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_sitelocal?()
  # -->
  # Returns true for IPv6 multicast site-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_sitelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_multicast?()
  # -->
  # Returns true for IPv6 multicast address (ff00::/8). It returns false
  # otherwise.
  #
  def ipv6_multicast?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_sitelocal?()
  # -->
  # Returns true for IPv6 site local address (fec0::/10). It returns false
  # otherwise.
  #
  def ipv6_sitelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_to_ipv4()
  # -->
  # Returns IPv4 address of IPv4 mapped/compatible IPv6 address. It returns nil if
  # `self` is not IPv4 mapped/compatible IPv6 address.
  #
  #     Addrinfo.ip("::192.0.2.3").ipv6_to_ipv4      #=> #<Addrinfo: 192.0.2.3>
  #     Addrinfo.ip("::ffff:192.0.2.3").ipv6_to_ipv4 #=> #<Addrinfo: 192.0.2.3>
  #     Addrinfo.ip("::1").ipv6_to_ipv4              #=> nil
  #     Addrinfo.ip("192.0.2.3").ipv6_to_ipv4        #=> nil
  #     Addrinfo.unix("/tmp/sock").ipv6_to_ipv4      #=> nil
  #
  def ipv6_to_ipv4: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_unique_local?()
  # -->
  # Returns true for IPv6 unique local address (fc00::/7, RFC4193). It returns
  # false otherwise.
  #
  def ipv6_unique_local?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_unspecified?()
  # -->
  # Returns true for IPv6 unspecified address (::). It returns false otherwise.
  #
  def ipv6_unspecified?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_v4compat?()
  # -->
  # Returns true for IPv4-compatible IPv6 address (::/80). It returns false
  # otherwise.
  #
  def ipv6_v4compat?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_v4mapped?()
  # -->
  # Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80). It returns false
  # otherwise.
  #
  def ipv6_v4mapped?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - listen(backlog=Socket::SOMAXCONN) { |sock| ... }
  # -->
  # creates a listening socket bound to self.
  #
  def listen: (Integer backlog) -> void

  def marshal_dump: () -> String

  def marshal_load: (String) -> instance

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.pfamily => integer
  # -->
  # returns the protocol family as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).pfamily == Socket::PF_INET #=> true
  #
  def pfamily: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.protocol => integer
  # -->
  # returns the socket type as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).protocol == Socket::IPPROTO_TCP #=> true
  #
  def protocol: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.socktype => integer
  # -->
  # returns the socket type as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).socktype == Socket::SOCK_STREAM #=> true
  #
  def socktype: () -> Integer

  # <!-- rdoc-file=ext/socket/raddrinfo.c -->
  # returns the socket address as packed struct sockaddr string.
  #
  #     Addrinfo.tcp("localhost", 80).to_sockaddr
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.to_sockaddr => string
  #   - addrinfo.to_s => string
  # -->
  # returns the socket address as packed struct sockaddr string.
  #
  #     Addrinfo.tcp("localhost", 80).to_sockaddr
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  def to_sockaddr: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.unix? => true or false
  # -->
  # returns true if addrinfo is UNIX address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).unix? #=> false
  #     Addrinfo.tcp("::1", 80).unix?       #=> false
  #     Addrinfo.unix("/tmp/sock").unix?    #=> true
  #
  def unix?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.unix_path => path
  # -->
  # Returns the socket path as a string.
  #
  #     Addrinfo.unix("/tmp/sock").unix_path       #=> "/tmp/sock"
  #
  def unix_path: () -> String

  private

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.new(sockaddr)                             => addrinfo
  #   - Addrinfo.new(sockaddr, family)                     => addrinfo
  #   - Addrinfo.new(sockaddr, family, socktype)           => addrinfo
  #   - Addrinfo.new(sockaddr, family, socktype, protocol) => addrinfo
  # -->
  # returns a new instance of Addrinfo. The instance contains sockaddr, family,
  # socktype, protocol. sockaddr means struct sockaddr which can be used for
  # connect(2), etc. family, socktype and protocol are integers which is used for
  # arguments of socket(2).
  #
  # sockaddr is specified as an array or a string. The array should be compatible
  # to the value of IPSocket#addr or UNIXSocket#addr. The string should be struct
  # sockaddr as generated by Socket.sockaddr_in or Socket.unpack_sockaddr_un.
  #
  # sockaddr examples:
  # *   `["AF_INET", 46102, "localhost.localdomain", "127.0.0.1"]`
  # *   `["AF_INET6", 42304, "ip6-localhost", "::1"]`
  # *   `["AF_UNIX", "/tmp/sock"]`
  # *   `Socket.sockaddr_in("smtp", "2001:DB8::1")`
  # *   `Socket.sockaddr_in(80, "172.18.22.42")`
  # *   `Socket.sockaddr_in(80, "www.ruby-lang.org")`
  # *   `Socket.sockaddr_un("/tmp/sock")`
  #
  # In an AF_INET/AF_INET6 sockaddr array, the 4th element, numeric IP address, is
  # used to construct socket address in the Addrinfo instance. If the 3rd element,
  # textual host name, is non-nil, it is also recorded but used only for
  # Addrinfo#inspect.
  #
  # family is specified as an integer to specify the protocol family such as
  # Socket::PF_INET. It can be a symbol or a string which is the constant name
  # with or without PF_ prefix such as :INET, :INET6, :UNIX, "PF_INET", etc. If
  # omitted, PF_UNSPEC is assumed.
  #
  # socktype is specified as an integer to specify the socket type such as
  # Socket::SOCK_STREAM. It can be a symbol or a string which is the constant name
  # with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, "SOCK_STREAM",
  # etc. If omitted, 0 is assumed.
  #
  # protocol is specified as an integer to specify the protocol such as
  # Socket::IPPROTO_TCP. It must be an integer, unlike family and socktype. If
  # omitted, 0 is assumed. Note that 0 is reasonable value for most protocols,
  # except raw socket.
  #
  def initialize: (String sockaddr, ?Symbol family, ?(Symbol | Integer)? socktype, ?Integer? protocol) -> untyped
end
# <!-- rdoc-file=ext/stringio/stringio.c -->
# IO streams for strings, with access similar to [IO](rdoc-ref:IO); see
# [IO](rdoc-ref:IO).
#
# ### About the Examples
#
# Examples on this page assume that StringIO has been required:
#
#     require 'stringio'
#
class StringIO
  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.new(string = '', mode = 'r+') -> new_stringio
  # -->
  # Note that `mode` defaults to `'r'` if `string` is frozen.
  #
  # Returns a new StringIO instance formed from `string` and `mode`; see [Access
  # Modes](rdoc-ref:File@Access+Modes):
  #
  #     strio = StringIO.new # => #<StringIO>
  #     strio.close
  #
  # The instance should be closed when no longer needed.
  #
  # Related: StringIO.open (accepts block; closes automatically).
  #
  def initialize: (?String string, ?String? mode) -> void

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.open(string = '', mode = 'r+') {|strio| ... }
  # -->
  # Note that `mode` defaults to `'r'` if `string` is frozen.
  #
  # Creates a new StringIO instance formed from `string` and `mode`; see [Access
  # Modes](rdoc-ref:File@Access+Modes).
  #
  # With no block, returns the new instance:
  #
  #     strio = StringIO.open # => #<StringIO>
  #
  # With a block, calls the block with the new instance and returns the block's
  # value; closes the instance on block exit.
  #
  #     StringIO.open {|strio| p strio }
  #     # => #<StringIO>
  #
  # Related: StringIO.new.
  #
  def self.open: [U] (?String string, ?String? mode) { (StringIO arg) -> U } -> U

  def <<: (untyped arg0) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - binmode -> self
  # -->
  # Sets the data mode in `self` to binary mode; see [Data
  # Mode](rdoc-ref:File@Data+Mode).
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - close -> nil
  # -->
  # Closes `self` for both reading and writing.
  #
  # Raises IOError if reading or writing is attempted.
  #
  # Related: StringIO#close_read, StringIO#close_write.
  #
  def close: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - close_read -> nil
  # -->
  # Closes `self` for reading; closed-write setting remains unchanged.
  #
  # Raises IOError if reading is attempted.
  #
  # Related: StringIO#close, StringIO#close_write.
  #
  def close_read: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - close_write -> nil
  # -->
  # Closes `self` for writing; closed-read setting remains unchanged.
  #
  # Raises IOError if writing is attempted.
  #
  # Related: StringIO#close, StringIO#close_read.
  #
  def close_write: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - closed? -> true or false
  # -->
  # Returns `true` if `self` is closed for both reading and writing, `false`
  # otherwise.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - closed_read? -> true or false
  # -->
  # Returns `true` if `self` is closed for reading, `false` otherwise.
  #
  def closed_read?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - closed_write? -> true or false
  # -->
  # Returns `true` if `self` is closed for writing, `false` otherwise.
  #
  def closed_write?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - each_line(sep = $/, chomp: false) {|line| ... }   -> self
  #   - each_line(limit, chomp: false) {|line| ... }      -> self
  #   - each_line(sep, limit, chomp: false) {|line| ... } -> self
  # -->
  # Calls the block with each remaining line read from the stream; does nothing if
  # already at end-of-file; returns `self`. See [Line IO](rdoc-ref:IO@Line+IO).
  #
  def each: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
          | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - each_byte {|byte| ... } -> self
  # -->
  # With a block given, calls the block with each remaining byte in the stream;
  # see [Byte IO](rdoc-ref:IO@Byte+IO).
  #
  # With no block given, returns an enumerator.
  #
  def each_byte: () { (Integer arg0) -> untyped } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - each_char {|c| ... } -> self
  # -->
  # With a block given, calls the block with each remaining character in the
  # stream; see [Character IO](rdoc-ref:IO@Character+IO).
  #
  # With no block given, returns an enumerator.
  #
  def each_char: () { (String arg0) -> untyped } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - each_codepoint {|codepoint| ... } -> self
  # -->
  # With a block given, calls the block with each remaining codepoint in the
  # stream; see [Codepoint IO](rdoc-ref:IO@Codepoint+IO).
  #
  # With no block given, returns an enumerator.
  #
  def each_codepoint: () { (Integer arg0) -> untyped } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - eof? -> true or false
  # -->
  # Returns `true` if positioned at end-of-stream, `false` otherwise; see
  # [Position](rdoc-ref:IO@Position).
  #
  # Raises IOError if the stream is not opened for reading.
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fcntl(*args)
  # -->
  # Raises NotImplementedError.
  #
  def fcntl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fileno()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def fileno: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - flush()
  # -->
  # Returns an object itself.  Just for compatibility to IO.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fsync()
  # -->
  # Returns 0.  Just for compatibility to IO.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - getbyte -> byte or nil
  # -->
  # Reads and returns the next 8-bit byte from the stream; see [Byte
  # IO](rdoc-ref:IO@Byte+IO).
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - getc -> character or nil
  # -->
  # Reads and returns the next character from the stream; see [Character
  # IO](rdoc-ref:IO@Character+IO).
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - gets(sep = $/, chomp: false) -> string or nil
  #   - gets(limit, chomp: false) -> string or nil
  #   - gets(sep, limit, chomp: false) -> string or nil
  # -->
  # Reads and returns a line from the stream; assigns the return value to `$_`;
  # see [Line IO](rdoc-ref:IO@Line+IO).
  #
  def gets: (?String sep, ?Integer limit, ?chomp: boolish) -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.internal_encoding   => encoding
  # -->
  # Returns the Encoding of the internal string if conversion is specified.
  # Otherwise returns `nil`.
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.external_encoding   => encoding
  # -->
  # Returns the Encoding object that represents the encoding of the file. If the
  # stream is write mode and no encoding is specified, returns `nil`.
  #
  def external_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - isatty()
  # -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - lineno -> current_line_number
  # -->
  # Returns the current line number in `self`; see [Line
  # Number](rdoc-ref:IO@Line+Number).
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - lineno = new_line_number -> new_line_number
  # -->
  # Sets the current line number in `self` to the given `new_line_number`; see
  # [Line Number](rdoc-ref:IO@Line+Number).
  #
  def lineno=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pid()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def pid: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pos -> stream_position
  # -->
  # Returns the current position (in bytes); see [Position](rdoc-ref:IO@Position).
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pos = new_position -> new_position
  # -->
  # Sets the current position (in bytes); see [Position](rdoc-ref:IO@Position).
  #
  def pos=: (Integer arg0) -> Integer

  def print: (*untyped arg0) -> nil

  def printf: (String format_string, *untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.putc(obj)    -> obj
  # -->
  # See IO#putc.
  #
  def putc: (Numeric | String arg0) -> untyped

  def puts: (*untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.read([length [, outbuf]])    -> string, outbuf, or nil
  # -->
  # See IO#read.
  #
  def read: (?int? length, ?string outbuf) -> String?

  def read_nonblock: (int len, ?string buf) -> String

  def readbyte: () -> Integer

  def readchar: () -> String

  def readline: (?String sep, ?Integer limit) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.readlines(sep=$/, chomp: false)     ->   array
  #   - strio.readlines(limit, chomp: false)      ->   array
  #   - strio.readlines(sep, limit, chomp: false) ->   array
  # -->
  # See IO#readlines.
  #
  def readlines: (?String sep, ?Integer limit, ?chomp: boolish) -> ::Array[String]

  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - reopen(other, mode = 'r+') -> self
  # -->
  # Reinitializes the stream with the given `other` (string or StringIO) and
  # `mode`; see IO.new:
  #
  #     StringIO.open('foo') do |strio|
  #       p strio.string
  #       strio.reopen('bar')
  #       p strio.string
  #       other_strio = StringIO.new('baz')
  #       strio.reopen(other_strio)
  #       p strio.string
  #       other_strio.close
  #     end
  #
  # Output:
  #
  #     "foo"
  #     "bar"
  #     "baz"
  #
  def reopen: (StringIO other) -> self
            | (String other, ?String mode_str) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - rewind -> 0
  # -->
  # Sets the current position and line number to zero; see
  # [Position](rdoc-ref:IO@Position) and [Line Number](rdoc-ref:IO@Line+Number).
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - seek(offset, whence = SEEK_SET) -> 0
  # -->
  # Sets the current position to the given integer `offset` (in bytes), with
  # respect to a given constant `whence`; see [Position](rdoc-ref:IO@Position).
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.set_encoding(ext_enc, [int_enc[, opt]])  => strio
  # -->
  # Specify the encoding of the StringIO as *ext_enc*. Use the default external
  # encoding if *ext_enc* is nil. 2nd argument *int_enc* and optional hash *opt*
  # argument are ignored; they are for API compatibility to IO.
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - string -> string
  # -->
  # Returns underlying string:
  #
  #     StringIO.open('foo') do |strio|
  #       p strio.string
  #       strio.string = 'bar'
  #       p strio.string
  #     end
  #
  # Output:
  #
  #     "foo"
  #     "bar"
  #
  # Related: StringIO#string= (assigns the underlying string).
  #
  def string: () -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - string = other_string -> other_string
  # -->
  # Assigns the underlying string as `other_string`, and sets position to zero;
  # returns `other_string`:
  #
  #     StringIO.open('foo') do |strio|
  #       p strio.string
  #       strio.string = 'bar'
  #       p strio.string
  #     end
  #
  # Output:
  #
  #     "foo"
  #     "bar"
  #
  # Related: StringIO#string (returns the underlying string).
  #
  def string=: (String str) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.length -> integer
  #   - strio.size   -> integer
  # -->
  # Returns the size of the buffer string.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - sync -> true
  # -->
  # Returns `true`; implemented only for compatibility with other stream classes.
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - sync=(p1)
  # -->
  # Returns the argument unchanged.  Just for compatibility to IO.
  #
  def sync=: (boolish) -> bool

  def sysread: (Integer maxlen, String outbuf) -> String

  def syswrite: (String arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pos -> stream_position
  # -->
  # Returns the current position (in bytes); see [Position](rdoc-ref:IO@Position).
  #
  def tell: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.truncate(integer)    -> 0
  # -->
  # Truncates the buffer string to at most *integer* bytes. The stream must be
  # opened for writing.
  #
  def truncate: (Integer) -> 0

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def tty?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - ungetbyte(byte) -> nil
  # -->
  # Pushes back ("unshifts") an 8-bit byte onto the stream; see [Byte
  # IO](rdoc-ref:IO@Byte+IO).
  #
  def ungetbyte: (String | Integer arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - ungetc(character) -> nil
  # -->
  # Pushes back ("unshifts") a character or integer onto the stream; see
  # [Character IO](rdoc-ref:IO@Character+IO).
  #
  def ungetc: (String arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.write(string, ...) -> integer
  #   - strio.syswrite(string)   -> integer
  # -->
  # Appends the given string to the underlying buffer string. The stream must be
  # opened for writing.  If the argument is not a string, it will be converted to
  # a string using `to_s`. Returns the number of bytes written.  See IO#write.
  #
  def write: (*_ToS) -> Integer

  # This is a deprecated alias for #each_byte.
  #
  def bytes: () { (Integer arg0) -> untyped } -> self
           | () -> ::Enumerator[Integer, self]

  # This is a deprecated alias for #each_char.
  #
  def chars: () { (String arg0) -> untyped } -> self
           | () -> ::Enumerator[String, self]

  # This is a deprecated alias for #each_codepoint.
  #
  def codepoints: () { (Integer arg0) -> untyped } -> self
                | () -> ::Enumerator[Integer, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Calls the block with each remaining line read from the stream; does nothing if
  # already at end-of-file; returns `self`. See [Line IO](rdoc-ref:IO@Line+IO).
  #
  def each_line: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
               | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns `true` if positioned at end-of-stream, `false` otherwise; see
  # [Position](rdoc-ref:IO@Position).
  #
  # Raises IOError if the stream is not opened for reading.
  #
  def eof?: () -> bool

  # This is a deprecated alias for #each_line.
  #
  def lines: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
           | (?String sep, ?Integer limit) -> ::Enumerator[String, self]
end
# <!-- rdoc-file=ext/strscan/strscan.c -->
# Class `StringScanner` supports processing a stored string as a stream;
# this code creates a new `StringScanner` object with string `'foobarbaz'`:
#     require 'strscan'
# scanner = StringScanner.new('foobarbaz')
#
# ## About the Examples
# All examples here assume that `StringScanner` has been required:
#     require 'strscan'
#
# Some examples here assume that these constants are defined:
#     MULTILINE_TEXT = <<~EOT
# Go placidly amid the noise and haste,
# and remember what peace there may be in silence.
# EOT
#
# HIRAGANA_TEXT = ''
#
# ENGLISH_TEXT = 'Hello'
#
# Some examples here assume that certain helper methods are defined:
# *   `put_situation(scanner)`:
#      Displays the values of the scanner's
#      methods #pos, #charpos, #rest, and #rest_size.
# *   `put_match_values(scanner)`:
#      Displays the scanner's [match
#     values](rdoc-ref:StringScanner@Match+Values).
# *   `match_values_cleared?(scanner)`:
#      Returns whether the scanner's [match
#     values](rdoc-ref:StringScanner@Match+Values) are cleared.
# See examples [[here]](ext/strscan/helper_methods_md.html).
# ## The `StringScanner` Object
# This code creates a `StringScanner` object
# (we'll call it simply a *scanner*),
# and shows some of its basic properties:
#     scanner = StringScanner.new('foobarbaz')
# scanner.string # => "foobarbaz"
# put_situation(scanner)
# # Situation:
# #   pos:       0
# #   charpos:   0
# #   rest:      "foobarbaz"
# #   rest_size: 9
#
# The scanner has:
# *   A *stored string*, which is:
#     *   Initially set by StringScanner.new(string) to the given `string`
#          (`'foobarbaz'` in the example above).
#     *   Modifiable by methods #string=(new_string) and #concat(more_string).
#     *   Returned by method #string.
#     More at [Stored String](rdoc-ref:StringScanner@Stored+String) below.
# *   A *position*;
#      a zero-based index into the bytes of the stored string (*not* into its
#     characters):
#     *   Initially set by StringScanner.new to `0`.
#     *   Returned by method #pos.
#     *   Modifiable explicitly by methods #reset, #terminate, and
#         #pos=(new_pos).
#     *   Modifiable implicitly (various traversing methods, among others).
#     More at [Byte
#     Position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) below.
# *   A *target substring*,
#      which is a trailing substring of the stored string;
#      it extends from the current position to the end of the stored string:
#     *   Initially set by StringScanner.new(string) to the given `string`
#          (`'foobarbaz'` in the example above).
#     *   Returned by method #rest.
#     *   Modified by any modification to either the stored string or the
#         position.
#     **Most importantly**:
#     the searching and traversing methods operate on the target substring,
#     which may be (and often is) less than the entire stored string.
#     More at [Target Substring](rdoc-ref:StringScanner@Target+Substring) below.
# ## Stored String
# The *stored string* is the string stored in the `StringScanner` object.
# Each of these methods sets, modifies, or returns the stored string:
#        Method       |                    Effect
# --------------------|-----------------------------------------------
#    ::new(string)    |  Creates a new scanner for the given string.
# #string=(new_string)|     Replaces the existing stored string.
# #concat(more_string)|Appends a string to the existing stored string.
#       #string       |          Returns the stored string.
# ## Positions
# A `StringScanner` object maintains a zero-based *byte position*
# and a zero-based *character position*.
# Each of these methods explicitly sets positions:
#          Method         |                         Effect
# ------------------------|--------------------------------------------------------
#          #reset         |Sets both positions to zero (begining of stored string).
#        #terminate       |  Sets both positions to the end of the stored string.
# #pos=(new_byte_position)|    Sets byte position; adjusts character position.
# ### Byte Position (Position)
# The byte position (or simply *position*)
# is a zero-based index into the bytes in the scanner's stored string;
# for a new `StringScanner` object, the byte position is zero.
# When the byte position is:
# *   Zero (at the beginning), the target substring is the entire stored string.
# *   Equal to the size of the stored string (at the end),
#      the target substring is the empty string `''`.
# To get or set the byte position:
# *   #pos: returns the byte position.
# *   #pos=(new_pos): sets the byte position.
# Many methods use the byte position as the basis for finding matches;
# many others set, increment, or decrement the byte position:
#     scanner = StringScanner.new('foobar')
# scanner.pos # => 0
# scanner.scan(/foo/) # => "foo" # Match found.
# scanner.pos         # => 3     # Byte position incremented.
# scanner.scan(/foo/) # => nil   # Match not found.
# scanner.pos # => 3             # Byte position not changed.
#
# Some methods implicitly modify the byte position;
# see:
# *   [Setting the Target
#     Substring](rdoc-ref:StringScanner@Setting+the+Target+Substring).
# *   [Traversing the Target
#     Substring](rdoc-ref:StringScanner@Traversing+the+Target+Substring).
# The values of these methods are derived directly from the values of #pos and
# #string:
# *   #charpos: the [character
#     position](rdoc-ref:StringScanner@Character+Position).
# *   #rest: the [target substring](rdoc-ref:StringScanner@Target+Substring).
# *   #rest_size: `rest.size`.
# ### Character Position
# The character position is a zero-based index into the *characters*
# in the stored string;
# for a new `StringScanner` object, the character position is zero.
# Method #charpos returns the character position;
# its value may not be reset explicitly.
# Some methods change (increment or reset) the character position;
# see:
# *   [Setting the Target
#     Substring](rdoc-ref:StringScanner@Setting+the+Target+Substring).
# *   [Traversing the Target
#     Substring](rdoc-ref:StringScanner@Traversing+the+Target+Substring).
# Example (string includes multi-byte characters):
#     scanner = StringScanner.new(ENGLISH_TEXT) # Five 1-byte characters.
# scanner.concat(HIRAGANA_TEXT)             # Five 3-byte characters
# scanner.string # => "Hello"       # Twenty bytes in all.
# put_situation(scanner)
# # Situation:
# #   pos:       0
# #   charpos:   0
# #   rest:      "Hello"
# #   rest_size: 20
# scanner.scan(/Hello/) # => "Hello" # Five 1-byte characters.
# put_situation(scanner)
# # Situation:
# #   pos:       5
# #   charpos:   5
# #   rest:      ""
# #   rest_size: 15
# scanner.getch         # => ""    # One 3-byte character.
# put_situation(scanner)
# # Situation:
# #   pos:       8
# #   charpos:   6
# #   rest:      ""
# #   rest_size: 12
#
# ## Target Substring
# The target substring is the the part of the [stored
# string](rdoc-ref:StringScanner@Stored+String)
# that extends from the current [byte
# position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) to the end of
# the stored string;
# it is always either:
# *   The entire stored string (byte position is zero).
# *   A trailing substring of the stored string (byte position positive).
# The target substring is returned by method #rest,
# and its size is returned by method #rest_size.
# Examples:
#     scanner = StringScanner.new('foobarbaz')
# put_situation(scanner)
# # Situation:
# #   pos:       0
# #   charpos:   0
# #   rest:      "foobarbaz"
# #   rest_size: 9
# scanner.pos = 3
# put_situation(scanner)
# # Situation:
# #   pos:       3
# #   charpos:   3
# #   rest:      "barbaz"
# #   rest_size: 6
# scanner.pos = 9
# put_situation(scanner)
# # Situation:
# #   pos:       9
# #   charpos:   9
# #   rest:      ""
# #   rest_size: 0
#
# ### Setting the Target Substring
# The target substring is set whenever:
# *   The [stored string](rdoc-ref:StringScanner@Stored+String) is set (position
#     reset to zero; target substring set to stored string).
# *   The [byte position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
#     is set (target substring adjusted accordingly).
# ### Querying the Target Substring
# This table summarizes (details and examples at the links):
#   Method  |             Returns
# ----------|---------------------------------
#   #rest   |        Target substring.
# #rest_size|Size (bytes) of target substring.
# ### Searching the Target Substring
# A *search* method examines the target substring,
# but does not advance the [positions](rdoc-ref:StringScanner@Positions)
# or (by implication) shorten the target substring.
# This table summarizes (details and examples at the links):
#        Method        |                   Returns                   |Sets Match Values?
# ---------------------|---------------------------------------------|------------------
#    #check(pattern)   |     Matched leading substring or +nil+.     |       Yes.
# #check_until(pattern)|   Matched substring (anywhere) or +nil+.    |       Yes.
#   #exist?(pattern)   |   Matched substring (anywhere) end index.   |       Yes.
#   #match?(pattern)   | Size of matched leading substring or +nil+. |       Yes.
#      #peek(size)     | Leading substring of given length (bytes).  |       No.
#      #peek_byte      |       Integer leading byte or +nil+.        |       No.
#         #rest        |Target substring (from byte position to end).|       No.
# ### Traversing the Target Substring
# A *traversal* method examines the target substring,
# and, if successful:
# *   Advances the [positions](rdoc-ref:StringScanner@Positions).
# *   Shortens the target substring.
# This table summarizes (details and examples at links):
#        Method       |                      Returns                       |Sets Match Values?
# --------------------|----------------------------------------------------|------------------
#      #get_byte      |               Leading byte or +nil+.               |       No.
#        #getch       |            Leading character or +nil+.             |       No.
#    #scan(pattern)   |        Matched leading substring or +nil+.         |       Yes.
#      #scan_byte     |           Integer leading byte or +nil+.           |       No.
# #scan_until(pattern)|       Matched substring (anywhere) or +nil+.       |       Yes.
#    #skip(pattern)   |      Matched leading substring size or +nil+.      |       Yes.
# #skip_until(pattern)|Position delta to end-of-matched-substring or +nil+.|       Yes.
#       #unscan       |                      +self+.                       |       No.
# ## Querying the Scanner
# Each of these methods queries the scanner object
# without modifying it (details and examples at links)
#       Method       |            Returns
# -------------------|--------------------------------
# #beginning_of_line?|       +true+ or +false+.
#      #charpos      |      Character position.
#        #eos?       |       +true+ or +false+.
#   #fixed_anchor?   |       +true+ or +false+.
#      #inspect      |String representation of +self+.
#        #pos        |         Byte position.
#        #rest       |       Target substring.
#     #rest_size     |   Size of target substring.
#       #string      |         Stored string.
# ## Matching
# `StringScanner` implements pattern matching via Ruby class
# [Regexp](https://docs.ruby-lang.org/en/master/Regexp.html),
# and its matching behaviors are the same as Ruby's
# except for the [fixed-anchor
# property](rdoc-ref:StringScanner@Fixed-Anchor+Property).
# ### Matcher Methods
# Each *matcher method* takes a single argument `pattern`,
# and attempts to find a matching substring in the [target
# substring](rdoc-ref:StringScanner@Target+Substring).
#    Method   |  Pattern Type   |Matches Target Substring|  Success Return  |May Update Positions?
# ------------|-----------------|------------------------|------------------|---------------------
#    #check   |Regexp or String.|     At beginning.      |Matched substring.|         No.
# #check_until|Regexp or String.|       Anywhere.        |    Substring.    |         No.
#   #match?   |Regexp or String.|     At beginning.      |   Match size.    |         No.
#   #exist?   |Regexp or String.|       Anywhere.        | Substring size.  |         No.
#    #scan    |Regexp or String.|     At beginning.      |Matched substring.|        Yes.
# #scan_until |Regexp or String.|       Anywhere.        |    Substring.    |        Yes.
#    #skip    |Regexp or String.|     At beginning.      |   Match size.    |        Yes.
# #skip_until |Regexp or String.|       Anywhere.        | Substring size.  |        Yes.
#
# Which matcher you choose will depend on:
# *   Where you want to find a match:
#     *   Only at the beginning of the target substring:
#          #check, #match?, #scan, #skip.
#     *   Anywhere in the target substring:
#          #check_until, #exist?, #scan_until, #skip_until.
# *   Whether you want to:
#     *   Traverse, by advancing the positions:
#          #scan, #scan_until, #skip, #skip_until.
#     *   Keep the positions unchanged:
#          #check, #check_until, #match?, #exist?.
# *   What you want for the return value:
#     *   The matched substring: #check, #scan.
#     *   The substring: #check_until, #scan_until.
#     *   The match size: #match?, #skip.
#     *   The substring size: #exist?, #skip_until.
# ### Match Values
# The *match values* in a `StringScanner` object
# generally contain the results of the most recent attempted match.
# Each match value may be thought of as:
# *   *Clear*: Initially, or after an unsuccessful match attempt:
#      usually, `false`, `nil`, or `{}`.
# *   *Set*: After a successful match attempt:
#      `true`, string, array, or hash.
# Each of these methods clears match values:
# *   ::new(string).
# *   #reset.
# *   #terminate.
# Each of these methods attempts a match based on a pattern,
# and either sets match values (if successful) or clears them (if not);
# *   #check(pattern)
# *   #check_until(pattern)
# *   #exist?(pattern)
# *   #match?(pattern)
# *   #scan(pattern)
# *   #scan_until(pattern)
# *   #skip(pattern)
# *   #skip_until(pattern)
# #### Basic Match Values
# Basic match values are those not related to captures.
# Each of these methods returns a basic match value:
#    Method    |          Return After Match          |Return After No Match
# -------------|--------------------------------------|---------------------
#   #matched?  |               +true+.                |      +false+.
# #matched_size|      Size of matched substring.      |       +nil+.
#   #matched   |          Matched substring.          |       +nil+.
#  #pre_match  |Substring preceding matched substring.|       +nil+.
#  #post_match |Substring following matched substring.|       +nil+.
#
# See examples below.
# #### Captured Match Values
# Captured match values are those related to
# [captures](https://docs.ruby-lang.org/en/master/Regexp.html#class-Regexp-label
# -Groups+and+Captures).
# Each of these methods returns a captured match value:
#     Method     |          Return After Match           |Return After No Match
# ---------------|---------------------------------------|---------------------
#      #size     |     Count of captured substrings.     |       +nil+.
#     #[](n)     |   <tt>n</tt>th captured substring.    |       +nil+.
#    #captures   |   Array of all captured substrings.   |       +nil+.
# #values_at(*n) |Array of specified captured substrings.|       +nil+.
# #named_captures|        Hash of named captures.        |    <tt>{}</tt>.
#
# See examples below.
# #### Match Values Examples
# Successful basic match attempt (no captures):
#     scanner = StringScanner.new('foobarbaz')
# scanner.exist?(/bar/)
# put_match_values(scanner)
# # Basic match values:
# #   matched?:       true
# #   matched_size:   3
# #   pre_match:      "foo"
# #   matched  :      "bar"
# #   post_match:     "baz"
# # Captured match values:
# #   size:           1
# #   captures:       []
# #   named_captures: {}
# #   values_at:      ["bar", nil]
# #   []:
# #     [0]:          "bar"
# #     [1]:          nil
#
# Failed basic match attempt (no captures);
#     scanner = StringScanner.new('foobarbaz')
# scanner.exist?(/nope/)
# match_values_cleared?(scanner) # => true
#
# Successful unnamed capture match attempt:
#     scanner = StringScanner.new('foobarbazbatbam')
# scanner.exist?(/(foo)bar(baz)bat(bam)/)
# put_match_values(scanner)
# # Basic match values:
# #   matched?:       true
# #   matched_size:   15
# #   pre_match:      ""
# #   matched  :      "foobarbazbatbam"
# #   post_match:     ""
# # Captured match values:
# #   size:           4
# #   captures:       ["foo", "baz", "bam"]
# #   named_captures: {}
# #   values_at:      ["foobarbazbatbam", "foo", "baz", "bam", nil]
# #   []:
# #     [0]:          "foobarbazbatbam"
# #     [1]:          "foo"
# #     [2]:          "baz"
# #     [3]:          "bam"
# #     [4]:          nil
#
# Successful named capture match attempt;
# same as unnamed above, except for #named_captures:
#     scanner = StringScanner.new('foobarbazbatbam')
# scanner.exist?(/(?<x>foo)bar(?<y>baz)bat(?<z>bam)/)
# scanner.named_captures # => {"x"=>"foo", "y"=>"baz", "z"=>"bam"}
#
# Failed unnamed capture match attempt:
#     scanner = StringScanner.new('somestring')
# scanner.exist?(/(foo)bar(baz)bat(bam)/)
# match_values_cleared?(scanner) # => true
#
# Failed named capture match attempt;
# same as unnamed above, except for #named_captures:
#     scanner = StringScanner.new('somestring')
# scanner.exist?(/(?<x>foo)bar(?<y>baz)bat(?<z>bam)/)
# match_values_cleared?(scanner) # => false
# scanner.named_captures # => {"x"=>nil, "y"=>nil, "z"=>nil}
#
# ## Fixed-Anchor Property
# Pattern matching in `StringScanner` is the same as in Ruby's,
# except for its fixed-anchor property,
# which determines the meaning of `'\A'`:
# *   `false` (the default): matches the current byte position.
#         scanner = StringScanner.new('foobar')
# scanner.scan(/\A./) # => "f"
# scanner.scan(/\A./) # => "o"
# scanner.scan(/\A./) # => "o"
# scanner.scan(/\A./) # => "b"
#
# *   `true`: matches the beginning of the target substring;
#      never matches unless the byte position is zero:
#         scanner = StringScanner.new('foobar', fixed_anchor: true)
# scanner.scan(/\A./) # => "f"
# scanner.scan(/\A./) # => nil
# scanner.reset
# scanner.scan(/\A./) # => "f"
#
# The fixed-anchor property is set when the `StringScanner` object is created,
# and may not be modified
# (see StringScanner.new);
# method #fixed_anchor? returns the setting.
#
class StringScanner
  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - StringScanner.must_C_version
  # -->
  # This method is defined for backward compatibility.
  #
  def self.must_C_version: () -> self

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # *   Appends the given `more_string`
  #      to the [stored string](rdoc-ref:StringScanner@Stored+String).
  # *   Returns `self`.
  # *   Does not affect the [positions](rdoc-ref:StringScanner@Positions)
  #      or [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new('foo')
  # scanner.string           # => "foo"
  # scanner.terminate
  # scanner.concat('barbaz') # => #<StringScanner 3/9 "foo" @ "barba...">
  # scanner.string           # => "foobarbaz"
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "barbaz"
  # #   rest_size: 6
  #
  def <<: (String) -> self

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - [](specifier) -> substring or nil
  # -->
  # Returns a captured substring or `nil`;
  # see [Captured Match Values](rdoc-ref:StringScanner@Captured+Match+Values).
  # When there are captures:
  #     scanner = StringScanner.new('Fri Dec 12 1975 14:39')
  # scanner.scan(/(?<wday>\w+) (?<month>\w+) (?<day>\d+) /)
  #
  # *   `specifier` zero: returns the entire matched substring:
  #         scanner[0]         # => "Fri Dec 12 "
  # scanner.pre_match  # => ""
  # scanner.post_match # => "1975 14:39"
  #
  # *   `specifier` positive integer. returns the `n`th capture, or `nil` if out
  #     of range:
  #         scanner[1] # => "Fri"
  # scanner[2] # => "Dec"
  # scanner[3] # => "12"
  # scanner[4] # => nil
  #
  # *   `specifier` negative integer. counts backward from the last subgroup:
  #         scanner[-1] # => "12"
  # scanner[-4] # => "Fri Dec 12 "
  # scanner[-5] # => nil
  #
  # *   `specifier` symbol or string. returns the named subgroup, or `nil` if no
  #     such:
  #         scanner[:wday]  # => "Fri"
  # scanner['wday'] # => "Fri"
  # scanner[:month] # => "Dec"
  # scanner[:day]   # => "12"
  # scanner[:nope]  # => nil
  #
  # When there are no captures, only `[0]` returns non-`nil`:
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.exist?(/bar/)
  # scanner[0] # => "bar"
  # scanner[1] # => nil
  #
  # For a failed match, even `[0]` returns `nil`:
  #     scanner.scan(/nope/) # => nil
  # scanner[0]           # => nil
  # scanner[1]           # => nil
  #
  def []: (Integer) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - beginning_of_line? -> true or false
  # -->
  # Returns whether the
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) is at the
  # beginning of a line;
  # that is, at the beginning of the [stored
  # string](rdoc-ref:StringScanner@Stored+String)
  # or immediately after a newline:
  #     scanner = StringScanner.new(MULTILINE_TEXT)
  #     scanner.string
  #     # => "Go placidly amid the noise and haste,\nand remember what peace there may be in silence.\n"
  #     scanner.pos                # => 0
  #     scanner.beginning_of_line? # => true
  #
  #     scanner.scan_until(/,/)    # => "Go placidly amid the noise and haste,"
  #     scanner.beginning_of_line? # => false
  #
  #     scanner.scan(/\n/)         # => "\n"
  #     scanner.beginning_of_line? # => true
  #
  #     scanner.terminate
  #     scanner.beginning_of_line? # => true
  #
  #     scanner.concat('x')
  #     scanner.terminate
  #     scanner.beginning_of_line? # => false
  #
  # StringScanner#bol? is an alias for StringScanner#beginning_of_line?.
  #
  def beginning_of_line?: () -> bool

  alias bol? beginning_of_line?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - captures -> substring_array or nil
  # -->
  # Returns the array of [captured match
  # values](rdoc-ref:StringScanner@Captured+Match+Values) at indexes `(1..)`
  # if the most recent match attempt succeeded, or `nil` otherwise:
  #     scanner = StringScanner.new('Fri Dec 12 1975 14:39')
  # scanner.captures         # => nil
  #
  # scanner.exist?(/(?<wday>\w+) (?<month>\w+) (?<day>\d+) /)
  # scanner.captures         # => ["Fri", "Dec", "12"]
  # scanner.values_at(*0..4) # => ["Fri Dec 12 ", "Fri", "Dec", "12", nil]
  #
  # scanner.exist?(/Fri/)
  # scanner.captures         # => []
  #
  # scanner.scan(/nope/)
  # scanner.captures         # => nil
  #
  def captures: () -> Array[String]?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - charpos()
  # -->
  # call-seq:
  #  charpos -> character_position
  # Returns the [character position](rdoc-ref:StringScanner@Character+Position)
  # (initially zero),
  # which may be different from the [byte
  # position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  # given by method #pos:
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string # => ""
  # scanner.getch  # => "" # 3-byte character.
  # scanner.getch  # => "" # 3-byte character.
  # put_situation(scanner)
  # # Situation:
  # #   pos:       6
  # #   charpos:   2
  # #   rest:      ""
  # #   rest_size: 9
  #
  def charpos: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - check(pattern) -> matched_substring or nil
  # -->
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # at the beginning of the [target
  # substring](rdoc-ref:StringScanner@Target+Substring);
  # does not modify the [positions](rdoc-ref:StringScanner@Positions).
  # If the match succeeds:
  # *   Returns the matched substring.
  # *   Sets all [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.pos = 3
  # scanner.check('bar') # => "bar"
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      "foo"
  # #   matched  :      "bar"
  # #   post_match:     "baz"
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["bar", nil]
  # #   []:
  # #     [0]:          "bar"
  # #     [1]:          nil
  # # => 0..1
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "barbaz"
  # #   rest_size: 6
  #
  # If the match fails:
  # *   Returns `nil`.
  # *   Clears all [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner.check(/nope/)          # => nil
  # match_values_cleared?(scanner) # => true
  #
  def check: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - check_until(pattern) -> substring or nil
  # -->
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # anywhere (at any
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29))
  # in the [target substring](rdoc-ref:StringScanner@Target+Substring);
  # does not modify the [positions](rdoc-ref:StringScanner@Positions).
  # If the match succeeds:
  # *   Sets all [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns the matched substring,
  #      which extends from the current
  #     [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  #      to the end of the matched substring.
  #     scanner = StringScanner.new('foobarbazbatbam')
  # scanner.pos = 6
  # scanner.check_until(/bat/) # => "bazbat"
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      "foobarbaz"
  # #   matched  :      "bat"
  # #   post_match:     "bam"
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["bat", nil]
  # #   []:
  # #     [0]:          "bat"
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       6
  # #   charpos:   6
  # #   rest:      "bazbatbam"
  # #   rest_size: 9
  #
  # If the match fails:
  # *   Clears all [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns `nil`.
  #     scanner.check_until(/nope/)    # => nil
  # match_values_cleared?(scanner) # => true
  #
  def check_until: (Regexp) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - clear()
  # -->
  # Equivalent to #terminate. This method is obsolete; use #terminate instead.
  #
  def clear: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - concat(more_string) -> self
  # -->
  # *   Appends the given `more_string`
  #      to the [stored string](rdoc-ref:StringScanner@Stored+String).
  # *   Returns `self`.
  # *   Does not affect the [positions](rdoc-ref:StringScanner@Positions)
  #      or [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new('foo')
  # scanner.string           # => "foo"
  # scanner.terminate
  # scanner.concat('barbaz') # => #<StringScanner 3/9 "foo" @ "barba...">
  # scanner.string           # => "foobarbaz"
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "barbaz"
  # #   rest_size: 6
  #
  alias concat <<

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - empty?()
  # -->
  # Equivalent to #eos?. This method is obsolete, use #eos? instead.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - eos? -> true or false
  # -->
  # Returns whether the
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  # is at the end of the [stored string](rdoc-ref:StringScanner@Stored+String):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.eos? # => false
  # pos = 3
  # scanner.eos? # => false
  # scanner.terminate
  # scanner.eos? # => true
  #
  def eos?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - exist?(pattern) -> byte_offset or nil
  # -->
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # anywhere (at any
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29))
  # n the [target substring](rdoc-ref:StringScanner@Target+Substring);
  # does not modify the [positions](rdoc-ref:StringScanner@Positions).
  # If the match succeeds:
  # *   Returns a byte offset:
  #      the distance in bytes between the current
  #     [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  #      and the end of the matched substring.
  # *   Sets all [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new('foobarbazbatbam')
  # scanner.pos = 6
  # scanner.exist?(/bat/) # => 6
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      "foobarbaz"
  # #   matched  :      "bat"
  # #   post_match:     "bam"
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["bat", nil]
  # #   []:
  # #     [0]:          "bat"
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       6
  # #   charpos:   6
  # #   rest:      "bazbatbam"
  # #   rest_size: 9
  #
  # If the match fails:
  # *   Returns `nil`.
  # *   Clears all [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner.exist?(/nope/)         # => nil
  # match_values_cleared?(scanner) # => true
  #
  def exist?: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - fixed_anchor? -> true or false
  # -->
  # Returns whether the [fixed-anchor
  # property](rdoc-ref:StringScanner@Fixed-Anchor+Property) is set.
  #
  def fixed_anchor?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - get_byte()
  # -->
  # call-seq:
  #  get_byte -> byte_as_character or nil
  # Returns the next byte, if available:
  # *   If the [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  #      is not at the end of the [stored
  #     string](rdoc-ref:StringScanner@Stored+String):
  #     *   Returns the next byte.
  #     *   Increments the [byte
  #         position](rdoc-ref:StringScanner@Byte+Position+-28Position-29).
  #     *   Adjusts the [character
  #         position](rdoc-ref:StringScanner@Character+Position).
  #         scanner = StringScanner.new(HIRAGANA_TEXT)
  # # => #<StringScanner 0/15 @ "\xE3\x81\x93\xE3\x82...">
  # scanner.string                                   # => ""
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\xE3", 1, 1]
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\x81", 2, 2]
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\x93", 3, 1]
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\xE3", 4, 2]
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\x82", 5, 3]
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => ["\x93", 6, 2]
  #
  # *   Otherwise, returns `nil`, and does not change the positions.
  #         scanner.terminate
  # [scanner.get_byte, scanner.pos, scanner.charpos] # => [nil, 15, 5]
  #
  def get_byte: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - getbyte()
  # -->
  # Equivalent to #get_byte. This method is obsolete; use #get_byte instead.
  #
  def getbyte: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - getch()
  # -->
  # call-seq:
  #  getch -> character or nil
  # Returns the next (possibly multibyte) character,
  # if available:
  # *   If the [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  #      is at the beginning of a character:
  #     *   Returns the character.
  #     *   Increments the [character
  #         position](rdoc-ref:StringScanner@Character+Position) by 1.
  #     *   Increments the [byte
  #         position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  #          by the size (in bytes) of the character.
  #         scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string                                # => ""
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 3, 1]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 6, 2]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 9, 3]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 12, 4]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 15, 5]
  # [scanner.getch, scanner.pos, scanner.charpos] # => [nil, 15, 5]
  #
  # *   If the [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) is
  #     within a multi-byte character
  #      (that is, not at its beginning),
  #      behaves like #get_byte (returns a 1-byte character):
  #         scanner.pos = 1
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["\x81", 2, 2]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["\x93", 3, 1]
  # [scanner.getch, scanner.pos, scanner.charpos] # => ["", 6, 2]
  #
  # *   If the [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) is
  #     at the end of the [stored string](rdoc-ref:StringScanner@Stored+String),
  #      returns `nil` and does not modify the positions:
  #         scanner.terminate
  # [scanner.getch, scanner.pos, scanner.charpos] # => [nil, 15, 5]
  #
  def getch: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self` that may show:
  # 1.  The current
  #     [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29).
  # 2.  The size (in bytes) of the [stored
  #     string](rdoc-ref:StringScanner@Stored+String).
  # 3.  The substring preceding the current position.
  # 4.  The substring following the current position (which is also the [target
  #     substring](rdoc-ref:StringScanner@Target+Substring)).
  #     scanner = StringScanner.new("Fri Dec 12 1975 14:39")
  # scanner.pos = 11
  # scanner.inspect # => "#<StringScanner 11/21 \"...c 12 \" @ \"1975 ...\">"
  #
  # If at beginning-of-string, item 4 above (following substring) is omitted:
  #     scanner.reset
  # scanner.inspect # => "#<StringScanner 0/21 @ \"Fri D...\">"
  #
  # If at end-of-string, all items above are omitted:
  #     scanner.terminate
  # scanner.inspect # => "#<StringScanner fin>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - match?(pattern) -> updated_position or nil
  # -->
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # at the beginning of the [target
  # substring](rdoc-ref:StringScanner@Target+Substring);
  # does not modify the [positions](rdoc-ref:StringScanner@Positions).
  # If the match succeeds:
  # *   Sets [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns the size in bytes of the matched substring.
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.pos = 3
  # scanner.match?(/bar/) => 3
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      "foo"
  # #   matched  :      "bar"
  # #   post_match:     "baz"
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["bar", nil]
  # #   []:
  # #     [0]:          "bar"
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "barbaz"
  # #   rest_size: 6
  #
  # If the match fails:
  # *   Clears match values.
  # *   Returns `nil`.
  # *   Does not increment positions.
  #     scanner.match?(/nope/)         # => nil
  # match_values_cleared?(scanner) # => true
  #
  def match?: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched -> matched_substring or nil
  # -->
  # Returns the matched substring from the most recent
  # [match](rdoc-ref:StringScanner@Matching) attempt
  # if it was successful,
  # or `nil` otherwise;
  # see [Basic Matched Values](rdoc-ref:StringScanner@Basic+Match+Values):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.matched        # => nil
  # scanner.pos = 3
  # scanner.match?(/bar/)  # => 3
  # scanner.matched        # => "bar"
  # scanner.match?(/nope/) # => nil
  # scanner.matched        # => nil
  #
  def matched: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched? -> true or false
  # -->
  # Returns `true` of the most recent [match
  # attempt](rdoc-ref:StringScanner@Matching) was successful,
  # `false` otherwise;
  # see [Basic Matched Values](rdoc-ref:StringScanner@Basic+Match+Values):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.matched?       # => false
  # scanner.pos = 3
  # scanner.exist?(/baz/)  # => 6
  # scanner.matched?       # => true
  # scanner.exist?(/nope/) # => nil
  # scanner.matched?       # => false
  #
  def matched?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched_size -> substring_size or nil
  # -->
  # Returns the size (in bytes) of the matched substring
  # from the most recent match [match attempt](rdoc-ref:StringScanner@Matching) if
  # it was successful,
  # or `nil` otherwise;
  # see [Basic Matched Values](rdoc-ref:StringScanner@Basic+Match+Values):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.matched_size   # => nil
  #
  # pos = 3
  # scanner.exist?(/baz/)  # => 9
  # scanner.matched_size   # => 3
  #
  # scanner.exist?(/nope/) # => nil
  # scanner.matched_size   # => nil
  #
  def matched_size: () -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - peek(length) -> substring
  # -->
  # Returns the substring `string[pos, length]`;
  # does not update [match values](rdoc-ref:StringScanner@Match+Values) or
  # [positions](rdoc-ref:StringScanner@Positions):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.pos = 3
  # scanner.peek(3)   # => "bar"
  # scanner.terminate
  # scanner.peek(3)   # => ""
  #
  def peek: (Integer) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - peep(p1)
  # -->
  # Equivalent to #peek. This method is obsolete; use #peek instead.
  #
  def peep: (Integer) -> String

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # call-seq:
  #  pos -> byte_position
  # Returns the integer [byte
  # position](rdoc-ref:StringScanner@Byte+Position+-28Position-29),
  # which may be different from the [character
  # position](rdoc-ref:StringScanner@Character+Position):
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string  # => ""
  # scanner.pos     # => 0
  # scanner.getch   # => "" # 3-byte character.
  # scanner.charpos # => 1
  # scanner.pos     # => 3
  #
  def pointer: () -> Integer

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # call-seq:
  #  pos = n -> n
  #  pointer = n -> n
  # Sets the [byte position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  # and the [character position](rdoc-ref:StringScanner@Positions);
  # returns `n`.
  # Does not affect [match values](rdoc-ref:StringScanner@Match+Values).
  # For non-negative `n`, sets the position to `n`:
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string  # => ""
  # scanner.pos = 3 # => 3
  # scanner.rest    # => ""
  # scanner.charpos # => 1
  #
  # For negative `n`, counts from the end of the [stored
  # string](rdoc-ref:StringScanner@Stored+String):
  #     scanner.pos = -9 # => -9
  # scanner.pos      # => 6
  # scanner.rest     # => ""
  # scanner.charpos  # => 2
  #
  def pointer=: (Integer) -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pos()
  # -->
  # call-seq:
  #  pos -> byte_position
  # Returns the integer [byte
  # position](rdoc-ref:StringScanner@Byte+Position+-28Position-29),
  # which may be different from the [character
  # position](rdoc-ref:StringScanner@Character+Position):
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string  # => ""
  # scanner.pos     # => 0
  # scanner.getch   # => "" # 3-byte character.
  # scanner.charpos # => 1
  # scanner.pos     # => 3
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pos=(p1)
  # -->
  # call-seq:
  #  pos = n -> n
  #  pointer = n -> n
  # Sets the [byte position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  # and the [character position](rdoc-ref:StringScanner@Positions);
  # returns `n`.
  # Does not affect [match values](rdoc-ref:StringScanner@Match+Values).
  # For non-negative `n`, sets the position to `n`:
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string  # => ""
  # scanner.pos = 3 # => 3
  # scanner.rest    # => ""
  # scanner.charpos # => 1
  #
  # For negative `n`, counts from the end of the [stored
  # string](rdoc-ref:StringScanner@Stored+String):
  #     scanner.pos = -9 # => -9
  # scanner.pos      # => 6
  # scanner.rest     # => ""
  # scanner.charpos  # => 2
  #
  def pos=: (Integer) -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - post_match -> substring
  # -->
  # Returns the substring that follows the matched substring
  # from the most recent match attempt if it was successful,
  # or `nil` otherwise;
  # see [Basic Match Values](rdoc-ref:StringScanner@Basic+Match+Values):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.post_match     # => nil
  #
  # scanner.pos = 3
  # scanner.match?(/bar/)  # => 3
  # scanner.post_match     # => "baz"
  #
  # scanner.match?(/nope/) # => nil
  # scanner.post_match     # => nil
  #
  def post_match: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pre_match -> substring
  # -->
  # Returns the substring that precedes the matched substring
  # from the most recent match attempt if it was successful,
  # or `nil` otherwise;
  # see [Basic Match Values](rdoc-ref:StringScanner@Basic+Match+Values):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.pre_match      # => nil
  #
  # scanner.pos = 3
  # scanner.exist?(/baz/)  # => 6
  # scanner.pre_match      # => "foobar" # Substring of entire string, not just target string.
  #
  # scanner.exist?(/nope/) # => nil
  # scanner.pre_match      # => nil
  #
  def pre_match: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - reset -> self
  # -->
  # Sets both [byte position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)
  # and [character position](rdoc-ref:StringScanner@Character+Position) to zero,
  # and clears [match values](rdoc-ref:StringScanner@Match+Values);
  # returns `self`:
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.exist?(/bar/)          # => 6
  # scanner.reset                  # => #<StringScanner 0/9 @ "fooba...">
  # put_situation(scanner)
  # # Situation:
  # #   pos:       0
  # #   charpos:   0
  # #   rest:      "foobarbaz"
  # #   rest_size: 9
  # # => nil
  # match_values_cleared?(scanner) # => true
  #
  def reset: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest -> target_substring
  # -->
  # Returns the 'rest' of the [stored
  # string](rdoc-ref:StringScanner@Stored+String) (all after the current
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)),
  # which is the [target substring](rdoc-ref:StringScanner@Target+Substring):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.rest # => "foobarbaz"
  # scanner.pos = 3
  # scanner.rest # => "barbaz"
  # scanner.terminate
  # scanner.rest # => ""
  #
  def rest: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest?()
  # -->
  # Returns true if and only if there is more data in the string.  See #eos?. This
  # method is obsolete; use #eos? instead.
  #
  #     s = StringScanner.new('test string')
  #     # These two are opposites
  #     s.eos? # => false
  #     s.rest? # => true
  #
  def rest?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest_size -> integer
  # -->
  # Returns the size (in bytes) of the #rest of the [stored
  # string](rdoc-ref:StringScanner@Stored+String):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.rest      # => "foobarbaz"
  # scanner.rest_size # => 9
  # scanner.pos = 3
  # scanner.rest      # => "barbaz"
  # scanner.rest_size # => 6
  # scanner.terminate
  # scanner.rest      # => ""
  # scanner.rest_size # => 0
  #
  def rest_size: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - restsize()
  # -->
  # `s.restsize` is equivalent to `s.rest_size`. This method is obsolete; use
  # #rest_size instead.
  #
  def restsize: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan(p1)
  # -->
  # call-seq:
  #  scan(pattern) -> substring or nil
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # at the beginning of the [target
  # substring](rdoc-ref:StringScanner@Target+Substring).
  # If the match succeeds:
  # *   Returns the matched substring.
  # *   Increments the [byte
  #     position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) by
  #     `substring.bytesize`,
  #      and may increment the [character
  #     position](rdoc-ref:StringScanner@Character+Position).
  # *   Sets [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string     # => ""
  # scanner.pos = 6
  # scanner.scan(//) # => ""
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      ""
  # #   matched  :      ""
  # #   post_match:     ""
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["", nil]
  # #   []:
  # #     [0]:          ""
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       9
  # #   charpos:   3
  # #   rest:      ""
  # #   rest_size: 6
  #
  # If the match fails:
  # *   Returns `nil`.
  # *   Does not increment byte and character positions.
  # *   Clears match values.
  #     scanner.scan(/nope/)           # => nil
  # match_values_cleared?(scanner) # => true
  #
  def scan: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan_full(pattern, advance_pointer_p, return_string_p)
  # -->
  # Tests whether the given `pattern` is matched from the current scan pointer.
  # Advances the scan pointer if `advance_pointer_p` is true. Returns the matched
  # string if `return_string_p` is true. The match register is affected.
  #
  # "full" means "#scan with full parameters".
  #
  def scan_full: (Regexp pattern, bool advance_pointer_p, bool return_string_p) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan_until(p1)
  # -->
  # call-seq:
  #  scan_until(pattern) -> substring or nil
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # anywhere (at any
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)) in the
  # [target substring](rdoc-ref:StringScanner@Target+Substring).
  # If the match attempt succeeds:
  # *   Sets [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Sets the [byte
  #     position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) to the end
  #     of the matched substring;
  #      may adjust the [character
  #     position](rdoc-ref:StringScanner@Character+Position).
  # *   Returns the matched substring.
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string           # => ""
  # scanner.pos = 6
  # scanner.scan_until(//) # => ""
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      ""
  # #   matched  :      ""
  # #   post_match:     ""
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["", nil]
  # #   []:
  # #     [0]:          ""
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       12
  # #   charpos:   4
  # #   rest:      ""
  # #   rest_size: 3
  #
  # If the match attempt fails:
  # *   Clears match data.
  # *   Returns `nil`.
  # *   Does not update positions.
  #     scanner.scan_until(/nope/)     # => nil
  # match_values_cleared?(scanner) # => true
  #
  def scan_until: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - search_full(pattern, advance_pointer_p, return_string_p)
  # -->
  # Scans the string *until* the `pattern` is matched. Advances the scan pointer
  # if `advance_pointer_p`, otherwise not. Returns the matched string if
  # `return_string_p` is true, otherwise returns the number of bytes advanced.
  # This method does affect the match register.
  #
  def search_full: (Regexp pattern, bool advance_pointer_p, bool return_string_p) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - size -> captures_count
  # -->
  # Returns the count of captures if the most recent match attempt succeeded,
  # `nil` otherwise;
  # see [Captures Match Values](rdoc-ref:StringScanner@Captured+Match+Values):
  #     scanner = StringScanner.new('Fri Dec 12 1975 14:39')
  # scanner.size                        # => nil
  #
  # pattern = /(?<wday>\w+) (?<month>\w+) (?<day>\d+) /
  # scanner.match?(pattern)
  # scanner.values_at(*0..scanner.size) # => ["Fri Dec 12 ", "Fri", "Dec", "12", nil]
  # scanner.size                        # => 4
  #
  # scanner.match?(/nope/)              # => nil
  # scanner.size                        # => nil
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - skip(p1)
  # -->
  # call-seq:
  #  skip(pattern) match_size or nil
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # at the beginning of the [target
  # substring](rdoc-ref:StringScanner@Target+Substring);
  # If the match succeeds:
  # *   Increments the [byte
  #     position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) by
  #     substring.bytesize,
  #      and may increment the [character
  #     position](rdoc-ref:StringScanner@Character+Position).
  # *   Sets [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns the size (bytes) of the matched substring.
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string                  # => ""
  # scanner.pos = 6
  # scanner.skip(//)              # => 3
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      ""
  # #   matched  :      ""
  # #   post_match:     ""
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["", nil]
  # #   []:
  # #     [0]:          ""
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       9
  # #   charpos:   3
  # #   rest:      ""
  # #   rest_size: 6
  #
  # scanner.skip(/nope/)            # => nil
  # match_values_cleared?(scanner)  # => true
  #
  def skip: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - skip_until(p1)
  # -->
  # call-seq:
  #  skip_until(pattern) -> matched_substring_size or nil
  # Attempts to [match](rdoc-ref:StringScanner@Matching) the given `pattern`
  # anywhere (at any
  # [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29)) in the
  # [target substring](rdoc-ref:StringScanner@Target+Substring);
  # does not modify the positions.
  # If the match attempt succeeds:
  # *   Sets [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns the size of the matched substring.
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string           # => ""
  # scanner.pos = 6
  # scanner.skip_until(//) # => 6
  # put_match_values(scanner)
  # # Basic match values:
  # #   matched?:       true
  # #   matched_size:   3
  # #   pre_match:      ""
  # #   matched  :      ""
  # #   post_match:     ""
  # # Captured match values:
  # #   size:           1
  # #   captures:       []
  # #   named_captures: {}
  # #   values_at:      ["", nil]
  # #   []:
  # #     [0]:          ""
  # #     [1]:          nil
  # put_situation(scanner)
  # # Situation:
  # #   pos:       12
  # #   charpos:   4
  # #   rest:      ""
  # #   rest_size: 3
  #
  # If the match attempt fails:
  # *   Clears match values.
  # *   Returns `nil`.
  #     scanner.skip_until(/nope/)     # => nil
  # match_values_cleared?(scanner) # => true
  #
  def skip_until: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - string -> stored_string
  # -->
  # Returns the [stored string](rdoc-ref:StringScanner@Stored+String):
  #     scanner = StringScanner.new('foobar')
  # scanner.string # => "foobar"
  # scanner.concat('baz')
  # scanner.string # => "foobarbaz"
  #
  def string: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - string = other_string -> other_string
  # -->
  # Replaces the [stored string](rdoc-ref:StringScanner@Stored+String) with the
  # given `other_string`:
  # *   Sets both [positions](rdoc-ref:StringScanner@Positions) to zero.
  # *   Clears [match values](rdoc-ref:StringScanner@Match+Values).
  # *   Returns `other_string`.
  #     scanner = StringScanner.new('foobar')
  # scanner.scan(/foo/)
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "bar"
  # #   rest_size: 3
  # match_values_cleared?(scanner) # => false
  #
  # scanner.string = 'baz'         # => "baz"
  # put_situation(scanner)
  # # Situation:
  # #   pos:       0
  # #   charpos:   0
  # #   rest:      "baz"
  # #   rest_size: 3
  # match_values_cleared?(scanner) # => true
  #
  def string=: (String) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - terminate()
  # -->
  # call-seq:
  #  terminate -> self
  # Sets the scanner to end-of-string;
  # returns `self`:
  # *   Sets both [positions](rdoc-ref:StringScanner@Positions) to end-of-stream.
  # *   Clears [match values](rdoc-ref:StringScanner@Match+Values).
  #     scanner = StringScanner.new(HIRAGANA_TEXT)
  # scanner.string                 # => ""
  # scanner.scan_until(//)
  # put_situation(scanner)
  # # Situation:
  # #   pos:       9
  # #   charpos:   3
  # #   rest:      ""
  # #   rest_size: 6
  # match_values_cleared?(scanner) # => false
  #
  # scanner.terminate              # => #<StringScanner fin>
  # put_situation(scanner)
  # # Situation:
  # #   pos:       15
  # #   charpos:   5
  # #   rest:      ""
  # #   rest_size: 0
  # match_values_cleared?(scanner) # => true
  #
  def terminate: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - unscan -> self
  # -->
  # Sets the [position](rdoc-ref:StringScanner@Byte+Position+-28Position-29) to
  # its value previous to the recent successful
  # [match](rdoc-ref:StringScanner@Matching) attempt:
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.scan(/foo/)
  # put_situation(scanner)
  # # Situation:
  # #   pos:       3
  # #   charpos:   3
  # #   rest:      "barbaz"
  # #   rest_size: 6
  # scanner.unscan
  # # => #<StringScanner 0/9 @ "fooba...">
  # put_situation(scanner)
  # # Situation:
  # #   pos:       0
  # #   charpos:   0
  # #   rest:      "foobarbaz"
  # #   rest_size: 9
  #
  # Raises an exception if match values are clear:
  #     scanner.scan(/nope/)           # => nil
  # match_values_cleared?(scanner) # => true
  # scanner.unscan                 # Raises StringScanner::Error.
  #
  def unscan: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - values_at(*specifiers) -> array_of_captures or nil
  # -->
  # Returns an array of captured substrings, or `nil` of none.
  # For each `specifier`, the returned substring is `[specifier]`;
  # see #[].
  #     scanner = StringScanner.new('Fri Dec 12 1975 14:39')
  # pattern = /(?<wday>\w+) (?<month>\w+) (?<day>\d+) /
  # scanner.match?(pattern)
  # scanner.values_at(*0..3)               # => ["Fri Dec 12 ", "Fri", "Dec", "12"]
  # scanner.values_at(*%i[wday month day]) # => ["Fri", "Dec", "12"]
  #
  def values_at: (*Integer) -> Array[String]?

  private

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - StringScanner.new(string, fixed_anchor: false) -> string_scanner
  # -->
  # Returns a new `StringScanner` object whose [stored
  # string](rdoc-ref:StringScanner@Stored+String)
  # is the given `string`;
  # sets the [fixed-anchor
  # property](rdoc-ref:StringScanner@Fixed-Anchor+Property):
  #     scanner = StringScanner.new('foobarbaz')
  # scanner.string        # => "foobarbaz"
  # scanner.fixed_anchor? # => false
  # put_situation(scanner)
  # # Situation:
  # #   pos:       0
  # #   charpos:   0
  # #   rest:      "foobarbaz"
  # #   rest_size: 9
  #
  def initialize: (String, ?bool dup, ?fixed_anchor: bool) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - dup -> shallow_copy
  # -->
  # Returns a shallow copy of `self`;
  # the [stored string](rdoc-ref:StringScanner@Stored+String) in the copy is the
  # same string as in `self`.
  #
  def initialize_copy: (StringScanner) -> void
end

StringScanner::Id: String

StringScanner::Version: String
# <!-- rdoc-file=lib/tempfile.rb -->
# A utility class for managing temporary files.
#
# There are two kind of methods of creating a temporary file:
#
# *   Tempfile.create (recommended)
# *   Tempfile.new and Tempfile.open (mostly for backward compatibility, not
#     recommended)
#
# Tempfile.create creates a usual File object. The timing of file deletion is
# predictable. Also, it supports open-and-unlink technique which removes the
# temporary file immediately after creation.
#
# Tempfile.new and Tempfile.open creates a Tempfile object. The created file is
# removed by the GC (finalizer). The timing of file deletion is not predictable.
#
# ## Synopsis
#
#     require 'tempfile'
#
#     # Tempfile.create with a block
#     # The filename are choosen automatically.
#     # (You can specify the prefix and suffix of the filename by an optional argument.)
#     Tempfile.create {|f|
#       f.puts "foo"
#       f.rewind
#       f.read                # => "foo\n"
#     }                       # The file is removed at block exit.
#
#     # Tempfile.create without a block
#     # You need to unlink the file in non-block form.
#     f = Tempfile.create
#     f.puts "foo"
#     f.close
#     File.unlink(f.path)     # You need to unlink the file.
#
#     # Tempfile.create(anonymous: true) without a block
#     f = Tempfile.create(anonymous: true)
#     # The file is already removed because anonymous.
#     f.path                  # => "/tmp/"  (no filename since no file)
#     f.puts "foo"
#     f.rewind
#     f.read                  # => "foo\n"
#     f.close
#
#     # Tempfile.create(anonymous: true) with a block
#     Tempfile.create(anonymous: true) {|f|
#       # The file is already removed because anonymous.
#       f.path                # => "/tmp/"  (no filename since no file)
#       f.puts "foo"
#       f.rewind
#       f.read                # => "foo\n"
#     }
#
#     # Not recommended: Tempfile.new without a block
#     file = Tempfile.new('foo')
#     file.path      # => A unique filename in the OS's temp directory,
#                    #    e.g.: "/tmp/foo.24722.0"
#                    #    This filename contains 'foo' in its basename.
#     file.write("hello world")
#     file.rewind
#     file.read      # => "hello world"
#     file.close
#     file.unlink    # deletes the temp file
#
# ## About Tempfile.new and Tempfile.open
#
# This section does not apply to Tempfile.create because it returns a File
# object (not a Tempfile object).
#
# When you create a Tempfile object, it will create a temporary file with a
# unique filename. A Tempfile objects behaves just like a File object, and you
# can perform all the usual file operations on it: reading data, writing data,
# changing its permissions, etc. So although this class does not explicitly
# document all instance methods supported by File, you can in fact call any File
# instance method on a Tempfile object.
#
# A Tempfile object has a finalizer to remove the temporary file. This means
# that the temporary file is removed via GC. This can cause several problems:
#
# *   Long GC intervals and conservative GC can accumulate temporary files that
#     are not removed.
# *   Temporary files are not removed if Ruby exits abnormally (such as SIGKILL,
#     SEGV).
#
# There are legacy good practices for Tempfile.new and Tempfile.open as follows.
#
# ### Explicit close
#
# When a Tempfile object is garbage collected, or when the Ruby interpreter
# exits, its associated temporary file is automatically deleted. This means that
# it's unnecessary to explicitly delete a Tempfile after use, though it's a good
# practice to do so: not explicitly deleting unused Tempfiles can potentially
# leave behind a large number of temp files on the filesystem until they're
# garbage collected. The existence of these temp files can make it harder to
# determine a new Tempfile filename.
#
# Therefore, one should always call #unlink or close in an ensure block, like
# this:
#
#     file = Tempfile.new('foo')
#     begin
#        # ...do something with file...
#     ensure
#        file.close
#        file.unlink   # deletes the temp file
#     end
#
# Tempfile.create { ... } exists for this purpose and is more convenient to use.
# Note that Tempfile.create returns a File instance instead of a Tempfile, which
# also avoids the overhead and complications of delegation.
#
#     Tempfile.create('foo') do |file|
#        # ...do something with file...
#     end
#
# ### Unlink after creation
#
# On POSIX systems, it's possible to unlink a file right after creating it, and
# before closing it. This removes the filesystem entry without closing the file
# handle, so it ensures that only the processes that already had the file handle
# open can access the file's contents. It's strongly recommended that you do
# this if you do not want any other processes to be able to read from or write
# to the Tempfile, and you do not need to know the Tempfile's filename either.
#
# Also, this guarantees the temporary file is removed even if Ruby exits
# abnormally. The OS reclaims the storage for the temporary file when the file
# is closed or the Ruby process exits (normally or abnormally).
#
# For example, a practical use case for unlink-after-creation would be this: you
# need a large byte buffer that's too large to comfortably fit in RAM, e.g. when
# you're writing a web server and you want to buffer the client's file upload
# data.
#
# `Tempfile.create(anonymous: true)` supports this behavior. It also works on
# Windows.
#
# ## Minor notes
#
# Tempfile's filename picking method is both thread-safe and inter-process-safe:
# it guarantees that no other threads or processes will pick the same filename.
#
# Tempfile itself however may not be entirely thread-safe. If you access the
# same Tempfile object from multiple threads then you should protect it with a
# mutex.
#
class Tempfile < File
  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - create(basename="", tmpdir=nil, mode: 0, anonymous: false, **options, &block)
  # -->
  # Creates a file in the underlying file system; returns a new File object based
  # on that file.
  #
  # With no block given and no arguments, creates and returns file whose:
  #
  # *   Class is [File](rdoc-ref:File) (not Tempfile).
  # *   Directory is the system temporary directory (system-dependent).
  # *   Generated filename is unique in that directory.
  # *   Permissions are `0600`; see [File
  #     Permissions](rdoc-ref:File@File+Permissions).
  # *   Mode is `'w+'` (read/write mode, positioned at the end).
  #
  # The temporary file removal depends on the keyword argument `anonymous` and
  # whether a block is given or not. See the description about the `anonymous`
  # keyword argument later.
  #
  # Example:
  #
  #     f = Tempfile.create     # => #<File:/tmp/20220505-9795-17ky6f6>
  #     f.class                 # => File
  #     f.path                  # => "/tmp/20220505-9795-17ky6f6"
  #     f.stat.mode.to_s(8)     # => "100600"
  #     f.close
  #     File.exist?(f.path)     # => true
  #     File.unlink(f.path)
  #     File.exist?(f.path)     # => false
  #
  #     Tempfile.create {|f|
  #       f.puts "foo"
  #       f.rewind
  #       f.read                # => "foo\n"
  #       f.path                # => "/tmp/20240524-380207-oma0ny"
  #       File.exist?(f.path)   # => true
  #     }                       # The file is removed at block exit.
  #
  #     f = Tempfile.create(anonymous: true)
  #     # The file is already removed because anonymous
  #     f.path                  # => "/tmp/"  (no filename since no file)
  #     f.puts "foo"
  #     f.rewind
  #     f.read                  # => "foo\n"
  #     f.close
  #
  #     Tempfile.create(anonymous: true) {|f|
  #       # The file is already removed because anonymous
  #       f.path                # => "/tmp/"  (no filename since no file)
  #       f.puts "foo"
  #       f.rewind
  #       f.read                # => "foo\n"
  #     }
  #
  # The argument `basename`, if given, may be one of the following:
  #
  # *   A string: the generated filename begins with `basename`:
  #
  #         Tempfile.create('foo') # => #<File:/tmp/foo20220505-9795-1gok8l9>
  #
  # *   An array of two strings `[prefix, suffix]`: the generated filename begins
  #     with `prefix` and ends with `suffix`:
  #
  #         Tempfile.create(%w/foo .jpg/) # => #<File:/tmp/foo20220505-17839-tnjchh.jpg>
  #
  # With arguments `basename` and `tmpdir`, the file is created in the directory
  # `tmpdir`:
  #
  #     Tempfile.create('foo', '.') # => #<File:./foo20220505-9795-1emu6g8>
  #
  # Keyword arguments `mode` and `options` are passed directly to the method
  # [File.open](rdoc-ref:File.open):
  #
  # *   The value given for `mode` must be an integer and may be expressed as the
  #     logical OR of constants defined in
  #     [File::Constants](rdoc-ref:File::Constants).
  # *   For `options`, see [Open Options](rdoc-ref:IO@Open+Options).
  #
  # The keyword argument `anonymous` specifies when the file is removed.
  #
  # *   `anonymous=false` (default) without a block: the file is not removed.
  # *   `anonymous=false` (default) with a block: the file is removed after the
  #     block exits.
  # *   `anonymous=true` without a block: the file is removed before returning.
  # *   `anonymous=true` with a block: the file is removed before the block is
  #     called.
  #
  # In the first case (`anonymous=false` without a block), the file is not removed
  # automatically. It should be explicitly closed. It can be used to rename to the
  # desired filename. If the file is not needed, it should be explicitly removed.
  #
  # The File#path method of the created file object returns the temporary
  # directory with a trailing slash when `anonymous` is true.
  #
  # When a block is given, it creates the file as described above, passes it to
  # the block, and returns the block's value. Before the returning, the file
  # object is closed and the underlying file is removed:
  #
  #     Tempfile.create {|file| file.path } # => "/tmp/20220505-9795-rkists"
  #
  # Implementation note:
  #
  # The keyword argument +anonymous=true+ is implemented using FILE_SHARE_DELETE
  # on Windows. O_TMPFILE is used on Linux.
  #
  # Related: Tempfile.new.
  #
  def self.create: (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, ?anonymous: bool, **untyped) -> File
                 | [A] (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, ?anonymous: bool, **untyped) { (File) -> A } -> A

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - open(*args, **kw) { |tempfile| ... }
  # -->
  # Creates a new Tempfile.
  #
  # This method is not recommended and exists mostly for backward compatibility.
  # Please use Tempfile.create instead, which avoids the cost of delegation, does
  # not rely on a finalizer, and also unlinks the file when given a block.
  #
  # Tempfile.open is still appropriate if you need the Tempfile to be unlinked by
  # a finalizer and you cannot explicitly know where in the program the Tempfile
  # can be unlinked safely.
  #
  # If no block is given, this is a synonym for Tempfile.new.
  #
  # If a block is given, then a Tempfile object will be constructed, and the block
  # is run with the Tempfile object as argument. The Tempfile object will be
  # automatically closed after the block terminates. However, the file will
  # **not** be unlinked and needs to be manually unlinked with Tempfile#close! or
  # Tempfile#unlink. The finalizer will try to unlink but should not be relied
  # upon as it can keep the file on the disk much longer than intended. For
  # instance, on CRuby, finalizers can be delayed due to conservative stack
  # scanning and references left in unused memory.
  #
  # The call returns the value of the block.
  #
  # In any case, all arguments (`*args`) will be passed to Tempfile.new.
  #
  #     Tempfile.open('foo', '/home/temp') do |f|
  #        # ... do something with f ...
  #     end
  #
  #     # Equivalent:
  #     f = Tempfile.open('foo', '/home/temp')
  #     begin
  #        # ... do something with f ...
  #     ensure
  #        f.close
  #     end
  #
  def self.open: (*untyped args, **untyped) -> Tempfile
               | [A] (*untyped args, **untyped) { (Tempfile) -> A } -> A

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - close(unlink_now=false)
  # -->
  # Closes the file. If `unlink_now` is true, then the file will be unlinked
  # (deleted) after closing. Of course, you can choose to later call #unlink if
  # you do not unlink it now.
  #
  # If you don't explicitly unlink the temporary file, the removal will be delayed
  # until the object is finalized.
  #
  def close: (?boolish unlink_now) -> void

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - close!()
  # -->
  # Closes and unlinks (deletes) the file. Has the same effect as called
  # `close(true)`.
  #
  def close!: () -> void

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - delete()
  # -->
  #
  alias delete unlink

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - length()
  # -->
  #
  alias length size

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - open()
  # -->
  # Opens or reopens the file with mode "r+".
  #
  def open: () -> File

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - path()
  # -->
  # Returns the full path name of the temporary file. This will be nil if #unlink
  # has been called.
  #
  def path: () -> String?

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - size()
  # -->
  # Returns the size of the temporary file.  As a side effect, the IO buffer is
  # flushed before determining the size.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - unlink()
  # -->
  # Unlinks (deletes) the file from the filesystem. One should always unlink the
  # file after using it, as is explained in the "Explicit close" good practice
  # section in the Tempfile overview:
  #
  #     file = Tempfile.new('foo')
  #     begin
  #        # ...do something with file...
  #     ensure
  #        file.close
  #        file.unlink   # deletes the temp file
  #     end
  #
  # ### Unlink-before-close
  #
  # On POSIX systems it's possible to unlink a file before closing it. This
  # practice is explained in detail in the Tempfile overview (section "Unlink
  # after creation"); please refer there for more information.
  #
  # However, unlink-before-close may not be supported on non-POSIX operating
  # systems. Microsoft Windows is the most notable case: unlinking a non-closed
  # file will result in an error, which this method will silently ignore. If you
  # want to practice unlink-before-close whenever possible, then you should write
  # code like this:
  #
  #     file = Tempfile.new('foo')
  #     file.unlink   # On Windows this silently fails.
  #     begin
  #        # ... do something with file ...
  #     ensure
  #        file.close!   # Closes the file handle. If the file wasn't unlinked
  #                      # because #unlink failed, then this method will attempt
  #                      # to do so again.
  #     end
  #
  def unlink: () -> void

  class Remover
    def call: (*untyped args) -> void

    private

    def initialize: (::Tempfile tmpfile) -> void
  end

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - new(basename="", tmpdir=nil, mode: 0, **options)
  # -->
  # Creates a file in the underlying file system; returns a new Tempfile object
  # based on that file.
  #
  # If possible, consider instead using Tempfile.create, which:
  #
  # *   Avoids the performance cost of delegation, incurred when Tempfile.new
  #     calls its superclass `DelegateClass(File)`.
  # *   Does not rely on a finalizer to close and unlink the file, which can be
  #     unreliable.
  #
  # Creates and returns file whose:
  #
  # *   Class is Tempfile (not File, as in Tempfile.create).
  # *   Directory is the system temporary directory (system-dependent).
  # *   Generated filename is unique in that directory.
  # *   Permissions are `0600`; see [File
  #     Permissions](rdoc-ref:File@File+Permissions).
  # *   Mode is `'w+'` (read/write mode, positioned at the end).
  #
  # The underlying file is removed when the Tempfile object dies and is reclaimed
  # by the garbage collector.
  #
  # Example:
  #
  #     f = Tempfile.new # => #<Tempfile:/tmp/20220505-17839-1s0kt30>
  #     f.class               # => Tempfile
  #     f.path                # => "/tmp/20220505-17839-1s0kt30"
  #     f.stat.mode.to_s(8)   # => "100600"
  #     File.exist?(f.path)   # => true
  #     File.unlink(f.path)   #
  #     File.exist?(f.path)   # => false
  #
  # Argument `basename`, if given, may be one of:
  #
  # *   A string: the generated filename begins with `basename`:
  #
  #         Tempfile.new('foo') # => #<Tempfile:/tmp/foo20220505-17839-1whk2f>
  #
  # *   An array of two strings `[prefix, suffix]`: the generated filename begins
  #     with `prefix` and ends with `suffix`:
  #
  #         Tempfile.new(%w/foo .jpg/) # => #<Tempfile:/tmp/foo20220505-17839-58xtfi.jpg>
  #
  # With arguments `basename` and `tmpdir`, the file is created in directory
  # `tmpdir`:
  #
  #     Tempfile.new('foo', '.') # => #<Tempfile:./foo20220505-17839-xfstr8>
  #
  # Keyword arguments `mode` and `options` are passed directly to method
  # [File.open](rdoc-ref:File.open):
  #
  # *   The value given with `mode` must be an integer, and may be expressed as
  #     the logical OR of constants defined in
  #     [File::Constants](rdoc-ref:File::Constants).
  # *   For `options`, see [Open Options](rdoc-ref:IO@Open+Options).
  #
  # Related: Tempfile.create.
  #
  def self.new: (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) -> instance
              | [A] (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) { (instance) -> A } -> A
end
%a{annotate:rdoc:skip}
class Time
  interface _TimeLike
    def year: () -> Integer

    def mon: () -> Integer

    def day: () -> Integer
  end

  # <!--
  #   rdoc-file=lib/time.rb
  #   - zone_offset(zone, year=self.now.year)
  # -->
  # Return the number of seconds the specified time zone differs from UTC.
  #
  # Numeric time zones that include minutes, such as `-10:00` or `+1330` will
  # work, as will simpler hour-only time zones like `-10` or `+13`.
  #
  # Textual time zones listed in ZoneOffset are also supported.
  #
  # If the time zone does not match any of the above, `zone_offset` will check if
  # the local time zone (both with and without potential Daylight Saving Time
  # changes being in effect) matches `zone`. Specifying a value for `year` will
  # change the year used to find the local time zone.
  #
  # If `zone_offset` is unable to determine the offset, nil will be returned.
  #
  #     require 'time'
  #
  #     Time.zone_offset("EST") #=> -18000
  #
  # You must require 'time' to use this method.
  #
  def self.zone_offset: (String zone, ?Integer year) -> Integer

  # <!--
  #   rdoc-file=lib/time.rb
  #   - parse(date, now=self.now) { |year| ... }
  # -->
  # Takes a string representation of a Time and attempts to parse it using a
  # heuristic.
  #
  # This method **does not** function as a validator.  If the input string does
  # not match valid formats strictly, you may get a cryptic result.  Should
  # consider to use Time.strptime instead of this method as possible.
  #
  #     require 'time'
  #
  #     Time.parse("2010-10-31") #=> 2010-10-31 00:00:00 -0500
  #
  # Any missing pieces of the date are inferred based on the current date.
  #
  #     require 'time'
  #
  #     # assuming the current date is "2011-10-31"
  #     Time.parse("12:00") #=> 2011-10-31 12:00:00 -0500
  #
  # We can change the date used to infer our missing elements by passing a second
  # object that responds to #mon, #day and #year, such as Date, Time or DateTime.
  # We can also use our own object.
  #
  #     require 'time'
  #
  #     class MyDate
  #       attr_reader :mon, :day, :year
  #
  #       def initialize(mon, day, year)
  #         @mon, @day, @year = mon, day, year
  #       end
  #     end
  #
  #     d  = Date.parse("2010-10-28")
  #     t  = Time.parse("2010-10-29")
  #     dt = DateTime.parse("2010-10-30")
  #     md = MyDate.new(10,31,2010)
  #
  #     Time.parse("12:00", d)  #=> 2010-10-28 12:00:00 -0500
  #     Time.parse("12:00", t)  #=> 2010-10-29 12:00:00 -0500
  #     Time.parse("12:00", dt) #=> 2010-10-30 12:00:00 -0500
  #     Time.parse("12:00", md) #=> 2010-10-31 12:00:00 -0500
  #
  # If a block is given, the year described in `date` is converted by the block.
  # This is specifically designed for handling two digit years. For example, if
  # you wanted to treat all two digit years prior to 70 as the year 2000+ you
  # could write this:
  #
  #     require 'time'
  #
  #     Time.parse("01-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
  #     #=> 2001-10-31 00:00:00 -0500
  #     Time.parse("70-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
  #     #=> 1970-10-31 00:00:00 -0500
  #
  # If the upper components of the given time are broken or missing, they are
  # supplied with those of `now`.  For the lower components, the minimum values (1
  # or 0) are assumed if broken or missing.  For example:
  #
  #     require 'time'
  #
  #     # Suppose it is "Thu Nov 29 14:33:20 2001" now and
  #     # your time zone is EST which is GMT-5.
  #     now = Time.parse("Thu Nov 29 14:33:20 2001")
  #     Time.parse("16:30", now)     #=> 2001-11-29 16:30:00 -0500
  #     Time.parse("7/23", now)      #=> 2001-07-23 00:00:00 -0500
  #     Time.parse("Aug 31", now)    #=> 2001-08-31 00:00:00 -0500
  #     Time.parse("Aug 2000", now)  #=> 2000-08-01 00:00:00 -0500
  #
  # Since there are numerous conflicts among locally defined time zone
  # abbreviations all over the world, this method is not intended to understand
  # all of them.  For example, the abbreviation "CST" is used variously as:
  #
  #     -06:00 in America/Chicago,
  #     -05:00 in America/Havana,
  #     +08:00 in Asia/Harbin,
  #     +09:30 in Australia/Darwin,
  #     +10:30 in Australia/Adelaide,
  #     etc.
  #
  # Based on this fact, this method only understands the time zone abbreviations
  # described in RFC 822 and the system time zone, in the order named. (i.e. a
  # definition in RFC 822 overrides the system time zone definition.)  The system
  # time zone is taken from `Time.local(year, 1, 1).zone` and `Time.local(year, 7,
  # 1).zone`. If the extracted time zone abbreviation does not match any of them,
  # it is ignored and the given time is regarded as a local time.
  #
  # ArgumentError is raised if Date._parse cannot extract information from `date`
  # or if the Time class cannot represent specified date.
  #
  # This method can be used as a fail-safe for other parsing methods as:
  #
  #     Time.rfc2822(date) rescue Time.parse(date)
  #     Time.httpdate(date) rescue Time.parse(date)
  #     Time.xmlschema(date) rescue Time.parse(date)
  #
  # A failure of Time.parse should be checked, though.
  #
  # You must require 'time' to use this method.
  #
  def self.parse: (String date, ?_TimeLike now) ?{ (Integer) -> Integer } -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - strptime(date, format, now=self.now) { |year| ... }
  # -->
  # Works similar to `parse` except that instead of using a heuristic to detect
  # the format of the input string, you provide a second argument that describes
  # the format of the string.
  #
  # Raises ArgumentError if the date or format is invalid.
  #
  # If a block is given, the year described in `date` is converted by the block.
  # For example:
  #
  #     Time.strptime(...) {|y| y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}
  #
  # Below is a list of the formatting options:
  #
  # %a
  # :   The abbreviated weekday name ("Sun")
  #
  # %A
  # :   The  full  weekday  name ("Sunday")
  #
  # %b
  # :   The abbreviated month name ("Jan")
  #
  # %B
  # :   The  full  month  name ("January")
  #
  # %c
  # :   The preferred local date and time representation
  #
  # %C
  # :   Century (20 in 2009)
  #
  # %d
  # :   Day of the month (01..31)
  #
  # %D
  # :   Date (%m/%d/%y)
  #
  # %e
  # :   Day of the month, blank-padded ( 1..31)
  #
  # %F
  # :   Equivalent to %Y-%m-%d (the ISO 8601 date format)
  #
  # %g
  # :   The last two digits of the commercial year
  #
  # %G
  # :   The week-based year according to ISO-8601 (week 1 starts on Monday and
  #     includes January 4)
  #
  # %h
  # :   Equivalent to %b
  #
  # %H
  # :   Hour of the day, 24-hour clock (00..23)
  #
  # %I
  # :   Hour of the day, 12-hour clock (01..12)
  #
  # %j
  # :   Day of the year (001..366)
  #
  # %k
  # :   hour, 24-hour clock, blank-padded ( 0..23)
  #
  # %l
  # :   hour, 12-hour clock, blank-padded ( 0..12)
  #
  # %L
  # :   Millisecond of the second (000..999)
  #
  # %m
  # :   Month of the year (01..12)
  #
  # %M
  # :   Minute of the hour (00..59)
  #
  # %n
  # :   Newline (n)
  #
  # %N
  # :   Fractional seconds digits
  #
  # %p
  # :   Meridian indicator ("AM" or "PM")
  #
  # %P
  # :   Meridian indicator ("am" or "pm")
  #
  # %r
  # :   time, 12-hour (same as %I:%M:%S %p)
  #
  # %R
  # :   time, 24-hour (%H:%M)
  #
  # %s
  # :   Number of seconds since 1970-01-01 00:00:00 UTC.
  #
  # %S
  # :   Second of the minute (00..60)
  #
  # %t
  # :   Tab character (t)
  #
  # %T
  # :   time, 24-hour (%H:%M:%S)
  #
  # %u
  # :   Day of the week as a decimal, Monday being 1. (1..7)
  #
  # %U
  # :   Week number of the current year, starting with the first Sunday as the
  #     first day of the first week (00..53)
  #
  # %v
  # :   VMS date (%e-%b-%Y)
  #
  # %V
  # :   Week number of year according to ISO 8601 (01..53)
  #
  # %W
  # :   Week  number  of the current year, starting with the first Monday as the
  #     first day of the first week (00..53)
  #
  # %w
  # :   Day of the week (Sunday is 0, 0..6)
  #
  # %x
  # :   Preferred representation for the date alone, no time
  #
  # %X
  # :   Preferred representation for the time alone, no date
  #
  # %y
  # :   Year without a century (00..99)
  #
  # %Y
  # :   Year which may include century, if provided
  #
  # %z
  # :   Time zone as hour offset from UTC (e.g. +0900)
  #
  # %Z
  # :   Time zone name
  #
  # %%
  # :   Literal "%" character
  #
  # %+
  # :   date(1) (%a %b %e %H:%M:%S %Z %Y)
  #
  #
  #     require 'time'
  #
  #     Time.strptime("2000-10-31", "%Y-%m-%d") #=> 2000-10-31 00:00:00 -0500
  #
  # You must require 'time' to use this method.
  #
  def self.strptime: (String date, String format, ?_TimeLike now) ?{ (Integer) -> Integer } -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc2822(date)
  # -->
  # Parses `date` as date-time defined by RFC 2822 and converts it to a Time
  # object.  The format is identical to the date format defined by RFC 822 and
  # updated by RFC 1123.
  #
  # ArgumentError is raised if `date` is not compliant with RFC 2822 or if the
  # Time class cannot represent specified date.
  #
  # See #rfc2822 for more information on this format.
  #
  #     require 'time'
  #
  #     Time.rfc2822("Wed, 05 Oct 2011 22:26:12 -0400")
  #     #=> 2010-10-05 22:26:12 -0400
  #
  # You must require 'time' to use this method.
  #
  def self.rfc2822: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc822(date)
  # -->
  #
  alias self.rfc822 self.rfc2822

  # <!--
  #   rdoc-file=lib/time.rb
  #   - httpdate(date)
  # -->
  # Parses `date` as an HTTP-date defined by RFC 2616 and converts it to a Time
  # object.
  #
  # ArgumentError is raised if `date` is not compliant with RFC 2616 or if the
  # Time class cannot represent specified date.
  #
  # See #httpdate for more information on this format.
  #
  #     require 'time'
  #
  #     Time.httpdate("Thu, 06 Oct 2011 02:26:12 GMT")
  #     #=> 2011-10-06 02:26:12 UTC
  #
  # You must require 'time' to use this method.
  #
  def self.httpdate: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - xmlschema(time)
  # -->
  # Parses `time` as a dateTime defined by the XML Schema and converts it to a
  # Time object.  The format is a restricted version of the format defined by ISO
  # 8601.
  #
  # ArgumentError is raised if `time` is not compliant with the format or if the
  # Time class cannot represent the specified time.
  #
  # See #xmlschema for more information on this format.
  #
  #     require 'time'
  #
  #     Time.xmlschema("2011-10-05T22:26:12-04:00")
  #     #=> 2011-10-05 22:26:12-04:00
  #
  # You must require 'time' to use this method.
  #
  def self.xmlschema: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - iso8601(time)
  # -->
  #
  alias self.iso8601 self.xmlschema

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc2822()
  # -->
  # Returns a string which represents the time as date-time defined by RFC 2822:
  #
  #     day-of-week, DD month-name CCYY hh:mm:ss zone
  #
  # where zone is [+-]hhmm.
  #
  # If `self` is a UTC time, -0000 is used as zone.
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.rfc2822  # => "Wed, 05 Oct 2011 22:26:12 -0400"
  #
  # You must require 'time' to use this method.
  #
  def rfc2822: () -> String

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc822()
  # -->
  #
  alias rfc822 rfc2822

  # <!--
  #   rdoc-file=lib/time.rb
  #   - httpdate()
  # -->
  # Returns a string which represents the time as RFC 1123 date of HTTP-date
  # defined by RFC 2616:
  #
  #     day-of-week, DD month-name CCYY hh:mm:ss GMT
  #
  # Note that the result is always UTC (GMT).
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.httpdate # => "Thu, 06 Oct 2011 02:26:12 GMT"
  #
  # You must require 'time' to use this method.
  #
  def httpdate: () -> String
end
# <!-- rdoc-file=lib/timeout.rb -->
# Timeout long-running blocks
#
# ## Synopsis
#
#     require 'timeout'
#     status = Timeout.timeout(5) {
#       # Something that should be interrupted if it takes more than 5 seconds...
#     }
#
# ## Description
#
# Timeout provides a way to auto-terminate a potentially long-running operation
# if it hasn't finished in a fixed amount of time.
#
# ## Copyright
#
# Copyright
# :   (C) 2000  Network Applied Communication Laboratory, Inc.
#
# Copyright
# :   (C) 2000  Information-technology Promotion Agency, Japan
#
module Timeout
  # <!--
  #   rdoc-file=lib/timeout.rb
  #   - timeout(sec, klass = nil, message = nil) { |sec| ... }
  # -->
  # Perform an operation in a block, raising an error if it takes longer than
  # `sec` seconds to complete.
  #
  # `sec`
  # :   Number of seconds to wait for the block to terminate. Any non-negative
  #     number or nil may be used, including Floats to specify fractional seconds.
  #     A value of 0 or `nil` will execute the block without any timeout. Any
  #     negative number will raise an ArgumentError.
  #
  # `klass`
  # :   Exception Class to raise if the block fails to terminate in `sec` seconds.
  #      Omitting will use the default, Timeout::Error
  #
  # `message`
  # :   Error message to raise with Exception Class. Omitting will use the
  #     default, "execution expired"
  #
  #
  # Returns the result of the block **if** the block completed before `sec`
  # seconds, otherwise throws an exception, based on the value of `klass`.
  #
  # The exception thrown to terminate the given block cannot be rescued inside the
  # block unless `klass` is given explicitly. However, the block can use ensure to
  # prevent the handling of the exception.  For that reason, this method cannot be
  # relied on to enforce timeouts for untrusted blocks.
  #
  # If a scheduler is defined, it will be used to handle the timeout by invoking
  # Scheduler#timeout_after.
  #
  # Note that this is both a method of module Timeout, so you can `include
  # Timeout` into your classes so they have a #timeout method, as well as a module
  # method, so you can call it directly as Timeout.timeout().
  #
  def self?.timeout: [T] (Numeric? sec, ?singleton(Exception) klass, ?String message) { (Numeric sec) -> T } -> T
end

# <!-- rdoc-file=lib/timeout.rb -->
# Internal error raised to when a timeout is triggered.
#
class Timeout::ExitException < Exception
end

# <!-- rdoc-file=lib/timeout.rb -->
# Raised by Timeout.timeout when the block times out.
#
class Timeout::Error < RuntimeError
  attr_reader thread: Thread?
end

# <!-- rdoc-file=lib/timeout.rb -->
# The version
#
Timeout::VERSION: String
%a{annotate:rdoc:skip}
class Dir
  # <!--
  #   rdoc-file=lib/tmpdir.rb
  #   - tmpdir()
  # -->
  # Returns the operating system's temporary file path.
  #
  #     require 'tmpdir'
  #     Dir.tmpdir # => "/tmp"
  #
  def self.tmpdir: () -> String

  # <!--
  #   rdoc-file=lib/tmpdir.rb
  #   - mktmpdir(prefix_suffix=nil, *rest, **options) { |dup| ... }
  # -->
  # Dir.mktmpdir creates a temporary directory.
  #
  #     require 'tmpdir'
  #     Dir.mktmpdir {|dir|
  #       # use the directory
  #     }
  #
  # The directory is created with 0700 permission. Application should not change
  # the permission to make the temporary directory accessible from other users.
  #
  # The prefix and suffix of the name of the directory is specified by the
  # optional first argument, *prefix_suffix*.
  # *   If it is not specified or nil, "d" is used as the prefix and no suffix is
  #     used.
  # *   If it is a string, it is used as the prefix and no suffix is used.
  # *   If it is an array, first element is used as the prefix and second element
  #     is used as a suffix.
  #
  #     Dir.mktmpdir {|dir| dir is ".../d..." }
  #     Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }
  #     Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }
  #
  # The directory is created under Dir.tmpdir or the optional second argument
  # *tmpdir* if non-nil value is given.
  #
  #     Dir.mktmpdir {|dir| dir is "#{Dir.tmpdir}/d..." }
  #     Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }
  #
  # If a block is given, it is yielded with the path of the directory. The
  # directory and its contents are removed using FileUtils.remove_entry before
  # Dir.mktmpdir returns. The value of the block is returned.
  #
  #     Dir.mktmpdir {|dir|
  #       # use the directory...
  #       open("#{dir}/foo", "w") { something using the file }
  #     }
  #
  # If a block is not given, The path of the directory is returned. In this case,
  # Dir.mktmpdir doesn't remove the directory.
  #
  #     dir = Dir.mktmpdir
  #     begin
  #       # use the directory...
  #       open("#{dir}/foo", "w") { something using the file }
  #     ensure
  #       # remove the directory.
  #       FileUtils.remove_entry dir
  #     end
  #
  def self.mktmpdir: (?string | [ string, string ] | nil, ?path?, ?max_try: Integer?) -> String
                   | [X] (?string | [string, string ] | nil, ?path?, ?max_try: Integer?) { (String) -> X } -> X
end
%a{annotate:rdoc:skip}
module TSort[Node]
  interface _Sortable[Node]
    # #tsort_each_node is used to iterate for all nodes over a graph.
    #
    def tsort_each_node: () { (Node) -> void } -> void

    # #tsort_each_child is used to iterate for child nodes of node.
    #
    def tsort_each_child: (Node) { (Node) -> void } -> void
  end

  interface _EachNode[Node]
    def call: () { (Node) -> void } -> void
  end

  interface _EachChild[Node]
    def call: (Node) { (Node) -> void } -> void
  end
end
%a{annotate:rdoc:skip}
module TSort[Node]
  class Cyclic < StandardError
  end
end
# <!-- rdoc-file=lib/tsort.rb -->
# TSort implements topological sorting using Tarjan's algorithm for strongly
# connected components.
#
# TSort is designed to be able to be used with any object which can be
# interpreted as a directed graph.
#
# TSort requires two methods to interpret an object as a graph, tsort_each_node
# and tsort_each_child.
#
# *   tsort_each_node is used to iterate for all nodes over a graph.
# *   tsort_each_child is used to iterate for child nodes of a given node.
#
# The equality of nodes are defined by eql? and hash since TSort uses Hash
# internally.
#
# ## A Simple Example
#
# The following example demonstrates how to mix the TSort module into an
# existing class (in this case, Hash). Here, we're treating each key in the hash
# as a node in the graph, and so we simply alias the required #tsort_each_node
# method to Hash's #each_key method. For each key in the hash, the associated
# value is an array of the node's child nodes. This choice in turn leads to our
# implementation of the required #tsort_each_child method, which fetches the
# array of child nodes and then iterates over that array using the user-supplied
# block.
#
#     require 'tsort'
#
#     class Hash
#       include TSort
#       alias tsort_each_node each_key
#       def tsort_each_child(node, &block)
#         fetch(node).each(&block)
#       end
#     end
#
#     {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
#     #=> [3, 2, 1, 4]
#
#     {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
#     #=> [[4], [2, 3], [1]]
#
# ## A More Realistic Example
#
# A very simple `make' like tool can be implemented as follows:
#
#     require 'tsort'
#
#     class Make
#       def initialize
#         @dep = {}
#         @dep.default = []
#       end
#
#       def rule(outputs, inputs=[], &block)
#         triple = [outputs, inputs, block]
#         outputs.each {|f| @dep[f] = [triple]}
#         @dep[triple] = inputs
#       end
#
#       def build(target)
#         each_strongly_connected_component_from(target) {|ns|
#           if ns.length != 1
#             fs = ns.delete_if {|n| Array === n}
#             raise TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
#           end
#           n = ns.first
#           if Array === n
#             outputs, inputs, block = n
#             inputs_time = inputs.map {|f| File.mtime f}.max
#             begin
#               outputs_time = outputs.map {|f| File.mtime f}.min
#             rescue Errno::ENOENT
#               outputs_time = nil
#             end
#             if outputs_time == nil ||
#                inputs_time != nil && outputs_time <= inputs_time
#               sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
#               block.call
#             end
#           end
#         }
#       end
#
#       def tsort_each_child(node, &block)
#         @dep[node].each(&block)
#       end
#       include TSort
#     end
#
#     def command(arg)
#       print arg, "\n"
#       system arg
#     end
#
#     m = Make.new
#     m.rule(%w[t1]) { command 'date > t1' }
#     m.rule(%w[t2]) { command 'date > t2' }
#     m.rule(%w[t3]) { command 'date > t3' }
#     m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
#     m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
#     m.build('t5')
#
# ## Bugs
#
# *   'tsort.rb' is wrong name because this library uses Tarjan's algorithm for
#     strongly connected components. Although 'strongly_connected_components.rb'
#     is correct but too long.
#
# ## References
#
#     1.  Tarjan, "Depth First Search and Linear Graph Algorithms",
# *SIAM Journal on Computing*, Vol. 1, No. 2, pp. 146-160, June 1972.
#
module TSort[Node] : TSort::_Sortable[Node]
  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component(each_node, each_child) { |nodes| ... }
  # -->
  # The iterator version of the TSort.strongly_connected_components method.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #     #   [3]
  #     #   [1]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def self.each_strongly_connected_component: [T] (_EachNode[T] each_node, _EachChild[T] each_child) { (Array[T]) -> void } -> void
                                            | [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Enumerator[Array[T], void]
                                            | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) { (Array[T]) -> void } -> void
                                            | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Enumerator[Array[T], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component_from(node, each_child, id_map={}, stack=[]) { |nodes| ... }
  # -->
  # Iterates over strongly connected components in a graph. The graph is
  # represented by *node* and *each_child*.
  #
  # *node* is the first node. *each_child* should have `call` method which takes a
  # node argument and yields for each child node.
  #
  # Return value is unspecified.
  #
  # #TSort.each_strongly_connected_component_from is a class method and it doesn't
  # need a class to represent a graph which includes TSort.
  #
  #     graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_child = lambda {|n, &b| graph[n].each(&b) }
  #     TSort.each_strongly_connected_component_from(1, each_child) {|scc|
  #       p scc
  #     }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def self.each_strongly_connected_component_from: [T] (T node, _EachChild[T] each_child, ?untyped id_map, ?untyped stack) { (Array[T]) -> void } -> void
                                                 | [T] (T node, _EachChild[T] each_child, ?untyped id_map, ?untyped stack) -> Enumerator[Array[T], void]
                                                 | [T] (T node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack) { (Array[T]) -> void } -> void
                                                 | [T] (T node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack) -> Enumerator[Array[T], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - strongly_connected_components(each_node, each_child)
  # -->
  # Returns strongly connected components as an array of arrays of nodes. The
  # array is sorted from children to parents. Each elements of the array
  # represents a strongly connected component.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.strongly_connected_components(each_node, each_child)
  #     #=> [[4], [2], [3], [1]]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.strongly_connected_components(each_node, each_child)
  #     #=> [[4], [2, 3], [1]]
  #
  def self.strongly_connected_components: [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Array[Array[T]]
                                        | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Array[Array[T]]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort(each_node, each_child)
  # -->
  # Returns a topologically sorted array of nodes. The array is sorted from
  # children to parents, i.e. the first element has no child and the last node has
  # no parent.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  # If there is a cycle, TSort::Cyclic is raised.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.tsort(each_node, each_child) # raises TSort::Cyclic
  #
  def self.tsort: [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Array[T]
                | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Array[T]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort_each(each_node, each_child) { |node| ... }
  # -->
  # The iterator version of the TSort.tsort method.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.tsort_each(each_node, each_child) {|n| p n }
  #     #=> 4
  #     #   2
  #     #   3
  #     #   1
  #
  def self.tsort_each: [T] (_EachNode[T] each_node, _EachChild[T] each_child) { (T) -> void } -> void
                     | [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Enumerator[T, void]
                     | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) { (T) -> void } -> void
                     | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Enumerator[T, void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component() { |nodes| ... }
  # -->
  # The iterator version of the #strongly_connected_components method.
  # *`obj*.each_strongly_connected_component` is similar to
  # *`obj*.strongly_connected_components.each`, but modification of *obj* during
  # the iteration may lead to unexpected results.
  #
  # #each_strongly_connected_component returns `nil`.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.each_strongly_connected_component {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #     #   [3]
  #     #   [1]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     graph.each_strongly_connected_component {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def each_strongly_connected_component: () { (Array[Node]) -> void } -> void
                                       | () -> Enumerator[Array[Node], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component_from(node, id_map={}, stack=[]) { |nodes| ... }
  # -->
  # Iterates over strongly connected component in the subgraph reachable from
  # *node*.
  #
  # Return value is unspecified.
  #
  # #each_strongly_connected_component_from doesn't call #tsort_each_node.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.each_strongly_connected_component_from(2) {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     graph.each_strongly_connected_component_from(2) {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #
  def each_strongly_connected_component_from: (Node, ?untyped id_map, ?untyped stack) { (Array[Node]) -> void } -> void
                                            | (Node, ?untyped id_map, ?untyped stack) -> Enumerator[Array[Node], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - strongly_connected_components()
  # -->
  # Returns strongly connected components as an array of arrays of nodes. The
  # array is sorted from children to parents. Each elements of the array
  # represents a strongly connected component.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     p graph.strongly_connected_components #=> [[4], [2], [3], [1]]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     p graph.strongly_connected_components #=> [[4], [2, 3], [1]]
  #
  def strongly_connected_components: () -> Array[Array[Node]]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort()
  # -->
  # Returns a topologically sorted array of nodes. The array is sorted from
  # children to parents, i.e. the first element has no child and the last node has
  # no parent.
  #
  # If there is a cycle, TSort::Cyclic is raised.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     p graph.tsort #=> [4, 2, 3, 1]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     p graph.tsort # raises TSort::Cyclic
  #
  def tsort: () -> Array[Node]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort_each() { |node| ... }
  # -->
  # The iterator version of the #tsort method. *`obj*.tsort_each` is similar to
  # *`obj*.tsort.each`, but modification of *obj* during the iteration may lead to
  # unexpected results.
  #
  # #tsort_each returns `nil`. If there is a cycle, TSort::Cyclic is raised.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.tsort_each {|n| p n }
  #     #=> 4
  #     #   2
  #     #   3
  #     #   1
  #
  def tsort_each: () { (Node) -> void } -> void
                | () -> Enumerator[Node, void]
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/https.rb -->
  # The default port for HTTPS URIs is 443, and the scheme is 'https:' rather than
  # 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs; see
  # URI::HTTP.
  #
  class HTTPS < HTTP
    # <!-- rdoc-file=lib/uri/https.rb -->
    # A Default port of 443 for URI::HTTPS
    #
    DEFAULT_PORT: Integer
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/mailto.rb -->
  # RFC6068, the mailto URL scheme.
  #
  class MailTo < Generic
    EMAIL_REGEXP: Regexp

    # <!--
    #   rdoc-file=lib/uri/mailto.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::MailTo object from components, with syntax checking.
    #
    # Components can be provided as an Array or Hash. If an Array is used, the
    # components must be supplied as `[to, headers]`.
    #
    # If a Hash is used, the keys are the component names preceded by colons.
    #
    # The headers can be supplied as a pre-encoded string, such as
    # `"subject=subscribe&cc=address"`, or as an Array of Arrays like `[['subject',
    # 'subscribe'], ['cc', 'address']]`.
    #
    # Examples:
    #
    #     require 'uri'
    #
    #     m1 = URI::MailTo.build(['joe@example.com', 'subject=Ruby'])
    #     m1.to_s  # => "mailto:joe@example.com?subject=Ruby"
    #
    #     m2 = URI::MailTo.build(['john@example.com', [['Subject', 'Ruby'], ['Cc', 'jack@example.com']]])
    #     m2.to_s  # => "mailto:john@example.com?Subject=Ruby&Cc=jack@example.com"
    #
    #     m3 = URI::MailTo.build({:to => 'listman@example.com', :headers => [['subject', 'subscribe']]})
    #     m3.to_s  # => "mailto:listman@example.com?subject=subscribe"
    #
    def self.build: (Array[String]) -> instance
                  | ([String, Array[Array[String]]]) -> instance
                  | (Hash[Symbol, String | Array[Array[String]]]) -> instance

    # <!-- rdoc-file=lib/uri/mailto.rb -->
    # E-mail headers set by the URL, as an Array of Arrays.
    #
    def headers: () -> Array[[String, String]]

    # <!--
    #   rdoc-file=lib/uri/mailto.rb
    #   - headers=(v)
    # -->
    # Setter for headers `v`.
    #
    def headers=: (String) -> String

    # <!-- rdoc-file=lib/uri/mailto.rb -->
    # The primary e-mail address of the URL, as a String.
    #
    def to: () -> String

    # <!--
    #   rdoc-file=lib/uri/mailto.rb
    #   - to=(v)
    # -->
    # Setter for to `v`.
    #
    def to=: (String) -> String

    # <!--
    #   rdoc-file=lib/uri/mailto.rb
    #   - to_mailtext()
    # -->
    # Returns the RFC822 e-mail text equivalent of the URL, as a String.
    #
    # Example:
    #
    #     require 'uri'
    #
    #     uri = URI.parse("mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr")
    #     uri.to_mailtext
    #     # => "To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n"
    #
    def to_mailtext: () -> String

    # <!--
    #   rdoc-file=lib/uri/mailto.rb
    #   - to_rfc822text()
    # -->
    #
    def to_rfc822text: () -> String
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ldaps.rb -->
  # The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather than
  # 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs; see
  # URI::LDAP.
  #
  class LDAPS < LDAP
    # <!-- rdoc-file=lib/uri/ldaps.rb -->
    # A Default port of 636 for URI::LDAPS
    #
    DEFAULT_PORT: Integer
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/http.rb -->
  # The syntax of HTTP URIs is defined in RFC1738 section 3.3.
  #
  # Note that the Ruby URI library allows HTTP URLs containing usernames and
  # passwords. This is not legal as per the RFC, but used to be supported in
  # Internet Explorer 5 and 6, before the MS04-004 security update. See
  # <URL:http://support.microsoft.com/kb/834489>.
  #
  class HTTP < Generic
    # <!-- rdoc-file=lib/uri/http.rb -->
    # A Default port of 80 for URI::HTTP.
    #
    DEFAULT_PORT: Integer

    # <!-- rdoc-file=lib/uri/http.rb -->
    # An Array of the available components for URI::HTTP.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::HTTP object from components, with syntax checking.
    #
    # The components accepted are userinfo, host, port, path, query, and fragment.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[userinfo,
    # host, port, path, query, fragment]`.
    #
    # Example:
    #
    #     uri = URI::HTTP.build(host: 'www.example.com', path: '/foo/bar')
    #
    #     uri = URI::HTTP.build([nil, "www.example.com", nil, "/path",
    #       "query", 'fragment'])
    #
    # Currently, if passed userinfo components this method generates invalid HTTP
    # URIs as per RFC 1738.
    #
    def self.build: (Array[String | Integer] args) -> instance
                  | ({ userinfo: String?, host: String?, port: Integer?, path: String?, query: String?, fragment: String? }) -> instance

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - authority()
    # -->
    # ## Description
    #
    # Returns the authority for an HTTP uri, as defined in
    # https://www.rfc-editor.org/rfc/rfc3986#section-3.2.
    #
    # Example:
    #
    #     URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').authority #=> "www.example.com"
    #     URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').authority #=> "www.example.com:8000"
    #     URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').authority #=> "www.example.com"
    #
    def authority: () -> String

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - origin()
    # -->
    # ## Description
    #
    # Returns the origin for an HTTP uri, as defined in
    # https://www.rfc-editor.org/rfc/rfc6454.
    #
    # Example:
    #
    #     URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').origin #=> "http://www.example.com"
    #     URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').origin #=> "http://www.example.com:8000"
    #     URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').origin #=> "http://www.example.com"
    #     URI::HTTPS.build(host: 'www.example.com', path: '/foo/bar').origin #=> "https://www.example.com"
    #
    def origin: () -> String

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - request_uri()
    # -->
    # ## Description
    #
    # Returns the full path for an HTTP request, as required by Net::HTTP::Get.
    #
    # If the URI contains a query, the full path is URI#path + '?' + URI#query.
    # Otherwise, the path is simply URI#path.
    #
    # Example:
    #
    #     uri = URI::HTTP.build(path: '/foo/bar', query: 'test=true')
    #     uri.request_uri #  => "/foo/bar?test=true"
    #
    def request_uri: () -> String
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ws.rb -->
  # The syntax of WS URIs is defined in RFC6455 section 3.
  #
  # Note that the Ruby URI library allows WS URLs containing usernames and
  # passwords. This is not legal as per the RFC, but used to be supported in
  # Internet Explorer 5 and 6, before the MS04-004 security update. See
  # <URL:http://support.microsoft.com/kb/834489>.
  #
  class WS < Generic
  end
end
# <!-- rdoc-file=lib/uri.rb -->
# URI is a module providing classes to handle Uniform Resource Identifiers
# ([RFC2396](https://www.rfc-editor.org/rfc/rfc2396)).
#
# ## Features
#
# *   Uniform way of handling URIs.
# *   Flexibility to introduce custom URI schemes.
# *   Flexibility to have an alternate URI::Parser (or just different patterns
#     and regexp's).
#
# ## Basic example
#
#     require 'uri'
#
#     uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
#     #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>
#
#     uri.scheme    #=> "http"
#     uri.host      #=> "foo.com"
#     uri.path      #=> "/posts"
#     uri.query     #=> "id=30&limit=5"
#     uri.fragment  #=> "time=1305298413"
#
#     uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"
#
# ## Adding custom URIs
#
#     module URI
#       class RSYNC < Generic
#         DEFAULT_PORT = 873
#       end
#       register_scheme 'RSYNC', RSYNC
#     end
#     #=> URI::RSYNC
#
#     URI.scheme_list
#     #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
#     #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
#     #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}
#
#     uri = URI("rsync://rsync.foo.com")
#     #=> #<URI::RSYNC rsync://rsync.foo.com>
#
# ## RFC References
#
# A good place to view an RFC spec is http://www.ietf.org/rfc.html.
#
# Here is a list of all related RFC's:
# *   [RFC822](https://www.rfc-editor.org/rfc/rfc822)
# *   [RFC1738](https://www.rfc-editor.org/rfc/rfc1738)
# *   [RFC2255](https://www.rfc-editor.org/rfc/rfc2255)
# *   [RFC2368](https://www.rfc-editor.org/rfc/rfc2368)
# *   [RFC2373](https://www.rfc-editor.org/rfc/rfc2373)
# *   [RFC2396](https://www.rfc-editor.org/rfc/rfc2396)
# *   [RFC2732](https://www.rfc-editor.org/rfc/rfc2732)
# *   [RFC3986](https://www.rfc-editor.org/rfc/rfc3986)
#
# ## Class tree
#
# *   URI::Generic (in uri/generic.rb)
#     *   URI::File - (in uri/file.rb)
#     *   URI::FTP - (in uri/ftp.rb)
#     *   URI::HTTP - (in uri/http.rb)
#         *   URI::HTTPS - (in uri/https.rb)
#     *   URI::LDAP - (in uri/ldap.rb)
#         *   URI::LDAPS - (in uri/ldaps.rb)
#     *   URI::MailTo - (in uri/mailto.rb)
# *   URI::Parser - (in uri/common.rb)
# *   URI::REGEXP - (in uri/common.rb)
#     *   URI::REGEXP::PATTERN - (in uri/common.rb)
# *   URI::Util - (in uri/common.rb)
# *   URI::Error - (in uri/common.rb)
#     *   URI::InvalidURIError - (in uri/common.rb)
#     *   URI::InvalidComponentError - (in uri/common.rb)
#     *   URI::BadURIError - (in uri/common.rb)
#
# ## Copyright Info
#
# Author
# :   Akira Yamada <akira@ruby-lang.org>
#
# Documentation
# :   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
#     Vincent Batts <vbatts@hashbangbash.com>
#
# License
# :   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
#     it and/or modify it under the same term as Ruby.
#
module URI
  # <!-- rdoc-file=lib/uri/generic.rb -->
  # Base class for all URI classes. Implements generic URI syntax as per RFC 2396.
  #
  class Generic
    include URI

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # A Default port of nil for URI::Generic.
    #
    DEFAULT_PORT: nil | Integer

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - default_port()
    # -->
    # Returns default port.
    #
    def self.default_port: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - default_port()
    # -->
    # Returns default port.
    #
    def default_port: () -> (nil | Integer)

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # An Array of the available components for URI::Generic.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component()
    # -->
    # Components of the URI in the order.
    #
    def self.component: () -> Array[Symbol]

    USE_REGISTRY: bool

    def self.use_registry: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - build2(args)
    # -->
    # ## Synopsis
    #
    # See ::new.
    #
    # ## Description
    #
    # At first, tries to create a new URI::Generic instance using
    # URI::Generic::build. But, if exception URI::InvalidComponentError is raised,
    # then it does URI::Escape.escape all URI components and tries again.
    #
    def self.build2: (Array[nil | String | Integer]) -> URI::Generic
                   | ({ scheme: String?, userinfo: String?, host: String?, port: Integer?, registry: String?, path: String?, opaque: String?, query: String?, fragment: String? }) -> instance

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - build(args)
    # -->
    # ## Synopsis
    #
    # See ::new.
    #
    # ## Description
    #
    # Creates a new URI::Generic instance from components of URI::Generic with
    # check.  Components are: scheme, userinfo, host, port, registry, path, opaque,
    # query, and fragment. You can provide arguments either by an Array or a Hash.
    # See ::new for hash keys to use or for order of array items.
    #
    def self.build: (Array[nil | String | Integer]) -> URI::Generic
                  | ({ scheme: String?, userinfo: String?, host: String?, port: Integer?, registry: String?, path: String?, opaque: String?, query: String?, fragment: String? }) -> instance

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - new(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = DEFAULT_PARSER, arg_check = false)
    # -->
    # ## Args
    #
    # `scheme`
    # :   Protocol scheme, i.e. 'http','ftp','mailto' and so on.
    #
    # `userinfo`
    # :   User name and password, i.e. 'sdmitry:bla'.
    #
    # `host`
    # :   Server host name.
    #
    # `port`
    # :   Server port.
    #
    # `registry`
    # :   Registry of naming authorities.
    #
    # `path`
    # :   Path on server.
    #
    # `opaque`
    # :   Opaque part.
    #
    # `query`
    # :   Query data.
    #
    # `fragment`
    # :   Part of the URI after '#' character.
    #
    # `parser`
    # :   Parser for internal use [URI::DEFAULT_PARSER by default].
    #
    # `arg_check`
    # :   Check arguments [false by default].
    #
    #
    # ## Description
    #
    # Creates a new URI::Generic instance from ``generic'' components without check.
    #
    def initialize: (String? scheme, String? userinfo, String? host, (String | Integer)? port, nil registry, String? path, String? opaque, String? query, String? fragment, ?untyped parser, ?boolish arg_check) -> void

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the scheme component of the URI.
    #
    #     URI("http://foo/bar/baz").scheme #=> "http"
    #
    attr_reader scheme: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the host component of the URI.
    #
    #     URI("http://foo/bar/baz").host #=> "foo"
    #
    # It returns nil if no host component exists.
    #
    #     URI("mailto:foo@example.org").host #=> nil
    #
    # The component does not contain the port number.
    #
    #     URI("http://foo:8080/bar/baz").host #=> "foo"
    #
    # Since IPv6 addresses are wrapped with brackets in URIs, this method returns
    # IPv6 addresses wrapped with brackets. This form is not appropriate to pass to
    # socket methods such as TCPSocket.open. If unwrapped host names are required,
    # use the #hostname method.
    #
    #     URI("http://[::1]/bar/baz").host     #=> "[::1]"
    #     URI("http://[::1]/bar/baz").hostname #=> "::1"
    #
    attr_reader host: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the port component of the URI.
    #
    #     URI("http://foo/bar/baz").port      #=> 80
    #     URI("http://foo:8080/bar/baz").port #=> 8080
    #
    attr_reader port: Integer?

    def registry: () -> nil

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the path component of the URI.
    #
    #     URI("http://foo/bar/baz").path #=> "/bar/baz"
    #
    attr_reader path: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the query component of the URI.
    #
    #     URI("http://foo/bar/baz?search=FooBar").query #=> "search=FooBar"
    #
    attr_reader query: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the opaque part of the URI.
    #
    #     URI("mailto:foo@example.org").opaque #=> "foo@example.org"
    #     URI("http://foo/bar/baz").opaque     #=> nil
    #
    # The portion of the path that does not make use of the slash '/'. The path
    # typically refers to an absolute path or an opaque part. (See RFC2396 Section 3
    # and 5.2.)
    #
    attr_reader opaque: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the fragment component of the URI.
    #
    #     URI("http://foo/bar/baz?search=FooBar#ponies").fragment #=> "ponies"
    #
    attr_reader fragment: String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - parser()
    # -->
    # Returns the parser to be used.
    #
    # Unless a URI::Parser is defined, DEFAULT_PARSER is used.
    #
    def parser: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - replace!(oth)
    # -->
    # Replaces self by other URI object.
    #
    def replace!: (URI::Generic oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component()
    # -->
    # Components of the URI in the order.
    #
    def component: () -> Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_scheme(v)
    # -->
    # Checks the scheme `v` component against the URI::Parser Regexp for :SCHEME.
    #
    def check_scheme: (String? v) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_scheme(v)
    # -->
    # Protected setter for the scheme component `v`.
    #
    # See also URI::Generic.scheme=.
    #
    def set_scheme: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - scheme=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the scheme component `v` (with validation).
    #
    # See also URI::Generic.check_scheme.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.scheme = "https"
    #     uri.to_s  #=> "https://my.example.com"
    #
    def scheme=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_userinfo(user, password = nil)
    # -->
    # Checks the `user` and `password`.
    #
    # If `password` is not provided, then `user` is split, using
    # URI::Generic.split_userinfo, to pull `user` and +password.
    #
    # See also URI::Generic.check_user, URI::Generic.check_password.
    #
    def check_userinfo: (String user, ?String? password) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_user(v)
    # -->
    # Checks the user `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :USERINFO.
    #
    # Can not have a registry or opaque component defined, with a user component
    # defined.
    #
    def check_user: (String v) -> (String | true)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_password(v, user = @user)
    # -->
    # Checks the password `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :USERINFO.
    #
    # Can not have a registry or opaque component defined, with a user component
    # defined.
    #
    def check_password: (String? v, ?String user) -> (String? | true)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - userinfo=(userinfo)
    # -->
    # Sets userinfo, argument is string like 'name:pass'.
    #
    def userinfo=: (String? userinfo) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - user=(user)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the `user` component (with validation).
    #
    # See also URI::Generic.check_user.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #     uri.user = "sam"
    #     uri.to_s  #=> "http://sam:V3ry_S3nsit1ve@my.example.com"
    #
    def user=: (String? user) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - password=(password)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the `password` component (with validation).
    #
    # See also URI::Generic.check_password.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #     uri.password = "V3ry_S3nsit1ve"
    #     uri.to_s  #=> "http://john:V3ry_S3nsit1ve@my.example.com"
    #
    def password=: (String? password) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_userinfo(user, password = nil)
    # -->
    # Protected setter for the `user` component, and `password` if available (with
    # validation).
    #
    # See also URI::Generic.userinfo=.
    #
    def set_userinfo: (String? user, ?String? password) -> [ String?, String? ]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_user(v)
    # -->
    # Protected setter for the user component `v`.
    #
    # See also URI::Generic.user=.
    #
    def set_user: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_password(v)
    # -->
    # Protected setter for the password component `v`.
    #
    # See also URI::Generic.password=.
    #
    def set_password: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - split_userinfo(ui)
    # -->
    # Returns the userinfo `ui` as `[user, password]` if properly formatted as
    # 'user:password'.
    #
    def split_userinfo: (String ui) -> Array[String | nil]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - escape_userpass(v)
    # -->
    # Escapes 'user:password' `v` based on RFC 1738 section 3.1.
    #
    def escape_userpass: (String v) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - userinfo()
    # -->
    # Returns the userinfo, either as 'user' or 'user:password'.
    #
    def userinfo: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - user()
    # -->
    # Returns the user component (without URI decoding).
    #
    def user: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - password()
    # -->
    # Returns the password component (without URI decoding).
    #
    def password: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_host(v)
    # -->
    # Checks the host `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :HOST.
    #
    # Can not have a registry or opaque component defined, with a host component
    # defined.
    #
    def check_host: (String? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_host(v)
    # -->
    # Protected setter for the host component `v`.
    #
    # See also URI::Generic.host=.
    #
    def set_host: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - host=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the host component `v` (with validation).
    #
    # See also URI::Generic.check_host.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.host = "foo.com"
    #     uri.to_s  #=> "http://foo.com"
    #
    def host=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hostname()
    # -->
    # Extract the host part of the URI and unwrap brackets for IPv6 addresses.
    #
    # This method is the same as URI::Generic#host except brackets for IPv6 (and
    # future IP) addresses are removed.
    #
    #     uri = URI("http://[::1]/bar")
    #     uri.hostname      #=> "::1"
    #     uri.host          #=> "[::1]"
    #
    def hostname: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hostname=(v)
    # -->
    # Sets the host part of the URI as the argument with brackets for IPv6
    # addresses.
    #
    # This method is the same as URI::Generic#host= except the argument can be a
    # bare IPv6 address.
    #
    #     uri = URI("http://foo/bar")
    #     uri.hostname = "::1"
    #     uri.to_s  #=> "http://[::1]/bar"
    #
    # If the argument seems to be an IPv6 address, it is wrapped with brackets.
    #
    def hostname=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_port(v)
    # -->
    # Checks the port `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :PORT.
    #
    # Can not have a registry or opaque component defined, with a port component
    # defined.
    #
    def check_port: ((String | Integer)? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_port(v)
    # -->
    # Protected setter for the port component `v`.
    #
    # See also URI::Generic.port=.
    #
    def set_port: ((String | Integer)? v) -> (String | Integer)?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - port=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the port component `v` (with validation).
    #
    # See also URI::Generic.check_port.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.port = 8080
    #     uri.to_s  #=> "http://my.example.com:8080"
    #
    def port=: ((String | Integer)? v) -> (String | Integer)?

    def check_registry: (String v) -> nil

    def set_registry: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - registry=(v)
    # -->
    #
    def registry=: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_path(v)
    # -->
    # Checks the path `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :ABS_PATH and :REL_PATH.
    #
    # Can not have a opaque component defined, with a path component defined.
    #
    def check_path: (String? v) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_path(v)
    # -->
    # Protected setter for the path component `v`.
    #
    # See also URI::Generic.path=.
    #
    def set_path: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - path=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the path component `v` (with validation).
    #
    # See also URI::Generic.check_path.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/pub/files")
    #     uri.path = "/faq/"
    #     uri.to_s  #=> "http://my.example.com/faq/"
    #
    def path=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - query=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the query component `v`.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/?id=25")
    #     uri.query = "id=1"
    #     uri.to_s  #=> "http://my.example.com/?id=1"
    #
    def query=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_opaque(v)
    # -->
    # Checks the opaque `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :OPAQUE.
    #
    # Can not have a host, port, user, or path component defined, with an opaque
    # component defined.
    #
    def check_opaque: (String? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_opaque(v)
    # -->
    # Protected setter for the opaque component `v`.
    #
    # See also URI::Generic.opaque=.
    #
    def set_opaque: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - opaque=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the opaque component `v` (with validation).
    #
    # See also URI::Generic.check_opaque.
    #
    def opaque=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - fragment=(v)
    # -->
    # Checks the fragment `v` component against the URI::Parser Regexp for
    # :FRAGMENT.
    #
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the fragment component `v` (with validation).
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/?id=25#time=1305212049")
    #     uri.fragment = "time=1305212086"
    #     uri.to_s  #=> "http://my.example.com/?id=25#time=1305212086"
    #
    def fragment=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hierarchical?()
    # -->
    # Returns true if URI is hierarchical.
    #
    # ## Description
    #
    # URI has components listed in order of decreasing significance from left to
    # right, see RFC3986 https://www.rfc-editor.org/rfc/rfc3986 1.2.3.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/")
    #     uri.hierarchical?
    #     #=> true
    #     uri = URI.parse("mailto:joe@example.com")
    #     uri.hierarchical?
    #     #=> false
    #
    def hierarchical?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - absolute?()
    # -->
    # Returns true if URI has a scheme (e.g. http:// or https://) specified.
    #
    def absolute?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - relative?()
    # -->
    # Returns true if URI does not have a scheme (e.g. http:// or https://)
    # specified.
    #
    def relative?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - split_path(path)
    # -->
    # Returns an Array of the path split on '/'.
    #
    def split_path: (String path) -> Array[String]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge_path(base, rel)
    # -->
    # Merges a base path `base`, with relative path `rel`, returns a modified base
    # path.
    #
    def merge_path: (String base, String rel) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge!(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Destructive form of #merge.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.merge!("/main.rbx?page=1")
    #     uri.to_s  # => "http://my.example.com/main.rbx?page=1"
    #
    def merge!: (URI::Generic | string oth) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Merges two URIs.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.merge("/main.rbx?page=1")
    #     # => "http://my.example.com/main.rbx?page=1"
    #
    def merge: (URI::Generic | string oth) -> URI::Generic

    # :stopdoc:
    def route_from_path: (String src, String dst) -> String

    # :stopdoc:
    def route_from0: (String oth) -> Array[URI::Generic]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - route_from(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Calculates relative path from oth to self.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://my.example.com/main.rbx?page=1')
    #     uri.route_from('http://my.example.com')
    #     #=> #<URI::Generic /main.rbx?page=1>
    #
    def route_from: (String oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - route_to(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Calculates relative path to oth from self.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://my.example.com')
    #     uri.route_to('http://my.example.com/main.rbx?page=1')
    #     #=> #<URI::Generic /main.rbx?page=1>
    #
    def route_to: (String oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - normalize()
    # -->
    # Returns normalized URI.
    #
    #     require 'uri'
    #
    #     URI("HTTP://my.EXAMPLE.com").normalize
    #     #=> #<URI::HTTP http://my.example.com/>
    #
    # Normalization here means:
    #
    # *   scheme and host are converted to lowercase,
    # *   an empty path component is set to "/".
    #
    def normalize: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - normalize!()
    # -->
    # Destructive version of #normalize.
    #
    def normalize!: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - to_s()
    # -->
    # Constructs String from URI.
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - ==(oth)
    # -->
    # Compares two URIs.
    #
    def ==: (URI::Generic oth) -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hash()
    # -->
    #
    def hash: () -> Integer

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - eql?(oth)
    # -->
    #
    def eql?: (URI::Generic oth) -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component_ary()
    # -->
    # Returns an Array of the components defined from the COMPONENT Array.
    #
    def component_ary: () -> Array[nil | String | Integer]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - select(*components)
    # -->
    # ## Args
    #
    # `components`
    # :   Multiple Symbol arguments defined in URI::HTTP.
    #
    #
    # ## Description
    #
    # Selects specified components from URI.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
    #     uri.select(:userinfo, :host, :path)
    #     # => ["myuser:mypass", "my.example.com", "/test.rbx"]
    #
    def select: (*Symbol components) -> Array[nil | String | Integer]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - coerce(oth)
    # -->
    # ## Args
    #
    # `v`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Attempts to parse other URI `oth`, returns [parsed_oth, self].
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.coerce("http://foo.com")
    #     #=> [#<URI::HTTP http://foo.com>, #<URI::HTTP http://my.example.com>]
    #
    def coerce: (URI::Generic | String oth) -> Array[URI::Generic]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - find_proxy(env=ENV)
    # -->
    # Returns a proxy URI. The proxy URI is obtained from environment variables such
    # as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is
    # returned.
    #
    # If the optional parameter `env` is specified, it is used instead of ENV.
    #
    # Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.) are
    # examined, too.
    #
    # But http_proxy and HTTP_PROXY is treated specially under CGI environment. It's
    # because HTTP_PROXY may be set by Proxy: header. So HTTP_PROXY is not used.
    # http_proxy is not used too if the variable is case insensitive. CGI_HTTP_PROXY
    # can be used instead.
    #
    def find_proxy: (?String env) -> (nil | URI::Generic)

    def self.use_proxy?: (String hostname, String addr, Integer port, String no_proxy) -> bool
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/wss.rb -->
  # The default port for WSS URIs is 443, and the scheme is 'wss:' rather than
  # 'ws:'. Other than that, WSS URIs are identical to WS URIs; see URI::WS.
  #
  class WSS < WS
  end
end
# <!-- rdoc-file=lib/uri/common.rb -->
# Base class for all URI exceptions.
#
class URI::Error < StandardError
end

# <!-- rdoc-file=lib/uri/common.rb -->
# Not a URI.
#
class URI::InvalidURIError < URI::Error
end

# <!-- rdoc-file=lib/uri/common.rb -->
# Not a URI component.
#
class URI::InvalidComponentError < URI::Error
end

# <!-- rdoc-file=lib/uri/common.rb -->
# URI is valid, bad usage is not.
#
class URI::BadURIError < URI::Error
end

# <!-- rdoc-file=lib/uri.rb -->
# URI is a module providing classes to handle Uniform Resource Identifiers
# ([RFC2396](https://www.rfc-editor.org/rfc/rfc2396)).
#
# ## Features
#
# *   Uniform way of handling URIs.
# *   Flexibility to introduce custom URI schemes.
# *   Flexibility to have an alternate URI::Parser (or just different patterns
#     and regexp's).
#
# ## Basic example
#
#     require 'uri'
#
#     uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
#     #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>
#
#     uri.scheme    #=> "http"
#     uri.host      #=> "foo.com"
#     uri.path      #=> "/posts"
#     uri.query     #=> "id=30&limit=5"
#     uri.fragment  #=> "time=1305298413"
#
#     uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"
#
# ## Adding custom URIs
#
#     module URI
#       class RSYNC < Generic
#         DEFAULT_PORT = 873
#       end
#       register_scheme 'RSYNC', RSYNC
#     end
#     #=> URI::RSYNC
#
#     URI.scheme_list
#     #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
#     #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
#     #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}
#
#     uri = URI("rsync://rsync.foo.com")
#     #=> #<URI::RSYNC rsync://rsync.foo.com>
#
# ## RFC References
#
# A good place to view an RFC spec is http://www.ietf.org/rfc.html.
#
# Here is a list of all related RFC's:
# *   [RFC822](https://www.rfc-editor.org/rfc/rfc822)
# *   [RFC1738](https://www.rfc-editor.org/rfc/rfc1738)
# *   [RFC2255](https://www.rfc-editor.org/rfc/rfc2255)
# *   [RFC2368](https://www.rfc-editor.org/rfc/rfc2368)
# *   [RFC2373](https://www.rfc-editor.org/rfc/rfc2373)
# *   [RFC2396](https://www.rfc-editor.org/rfc/rfc2396)
# *   [RFC2732](https://www.rfc-editor.org/rfc/rfc2732)
# *   [RFC3986](https://www.rfc-editor.org/rfc/rfc3986)
#
# ## Class tree
#
# *   URI::Generic (in uri/generic.rb)
#     *   URI::File - (in uri/file.rb)
#     *   URI::FTP - (in uri/ftp.rb)
#     *   URI::HTTP - (in uri/http.rb)
#         *   URI::HTTPS - (in uri/https.rb)
#     *   URI::LDAP - (in uri/ldap.rb)
#         *   URI::LDAPS - (in uri/ldaps.rb)
#     *   URI::MailTo - (in uri/mailto.rb)
# *   URI::Parser - (in uri/common.rb)
# *   URI::REGEXP - (in uri/common.rb)
#     *   URI::REGEXP::PATTERN - (in uri/common.rb)
# *   URI::Util - (in uri/common.rb)
# *   URI::Error - (in uri/common.rb)
#     *   URI::InvalidURIError - (in uri/common.rb)
#     *   URI::InvalidComponentError - (in uri/common.rb)
#     *   URI::BadURIError - (in uri/common.rb)
#
# ## Copyright Info
#
# Author
# :   Akira Yamada <akira@ruby-lang.org>
#
# Documentation
# :   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
#     Vincent Batts <vbatts@hashbangbash.com>
#
# License
# :   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
#     it and/or modify it under the same term as Ruby.
#
module URI
  include URI::RFC2396_REGEXP

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - decode_www_form(str, enc=Encoding::UTF_8, separator: '&', use__charset_: false, isindex: false)
  # -->
  # Returns name/value pairs derived from the given string `str`, which must be an
  # ASCII string.
  #
  # The method may be used to decode the body of Net::HTTPResponse object `res`
  # for which `res['Content-Type']` is `'application/x-www-form-urlencoded'`.
  #
  # The returned data is an array of 2-element subarrays; each subarray is a
  # name/value pair (both are strings). Each returned string has encoding `enc`,
  # and has had invalid characters removed via
  # [String#scrub](rdoc-ref:String#scrub).
  #
  # A simple example:
  #
  #     URI.decode_www_form('foo=0&bar=1&baz')
  #     # => [["foo", "0"], ["bar", "1"], ["baz", ""]]
  #
  # The returned strings have certain conversions, similar to those performed in
  # URI.decode_www_form_component:
  #
  #     URI.decode_www_form('f%23o=%2F&b-r=%24&b+z=%40')
  #     # => [["f#o", "/"], ["b-r", "$"], ["b z", "@"]]
  #
  # The given string may contain consecutive separators:
  #
  #     URI.decode_www_form('foo=0&&bar=1&&baz=2')
  #     # => [["foo", "0"], ["", ""], ["bar", "1"], ["", ""], ["baz", "2"]]
  #
  # A different separator may be specified:
  #
  #     URI.decode_www_form('foo=0--bar=1--baz', separator: '--')
  #     # => [["foo", "0"], ["bar", "1"], ["baz", ""]]
  #
  def self.decode_www_form: (String str, ?encoding enc, ?isindex: boolish, ?use__charset_: boolish, ?separator: String) -> Array[[ String, String ]]

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - decode_www_form_component(str, enc=Encoding::UTF_8)
  # -->
  # Returns a string decoded from the given URL-encoded string `str`.
  #
  # The given string is first encoded as Encoding::ASCII-8BIT (using String#b),
  # then decoded (as below), and finally force-encoded to the given encoding
  # `enc`.
  #
  # The returned string:
  #
  # *   Preserves:
  #
  #     *   Characters `'*'`, `'.'`, `'-'`, and `'_'`.
  #     *   Character in ranges `'a'..'z'`, `'A'..'Z'`, and `'0'..'9'`.
  #
  #     Example:
  #
  #         URI.decode_www_form_component('*.-_azAZ09')
  #         # => "*.-_azAZ09"
  #
  # *   Converts:
  #
  #     *   Character `'+'` to character `' '`.
  #     *   Each "percent notation" to an ASCII character.
  #
  #     Example:
  #
  #         URI.decode_www_form_component('Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A')
  #         # => "Here are some punctuation characters: ,;?:"
  #
  # Related: URI.decode_uri_component (preserves `'+'`).
  #
  def self.decode_www_form_component: (String str, ?encoding enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - encode_www_form(enum, enc=nil)
  # -->
  # Returns a URL-encoded string derived from the given
  # [Enumerable](rdoc-ref:Enumerable@Enumerable+in+Ruby+Classes) `enum`.
  #
  # The result is suitable for use as form data for an HTTP request whose
  # `Content-Type` is `'application/x-www-form-urlencoded'`.
  #
  # The returned string consists of the elements of `enum`, each converted to one
  # or more URL-encoded strings, and all joined with character `'&'`.
  #
  # Simple examples:
  #
  #     URI.encode_www_form([['foo', 0], ['bar', 1], ['baz', 2]])
  #     # => "foo=0&bar=1&baz=2"
  #     URI.encode_www_form({foo: 0, bar: 1, baz: 2})
  #     # => "foo=0&bar=1&baz=2"
  #
  # The returned string is formed using method URI.encode_www_form_component,
  # which converts certain characters:
  #
  #     URI.encode_www_form('f#o': '/', 'b-r': '$', 'b z': '@')
  #     # => "f%23o=%2F&b-r=%24&b+z=%40"
  #
  # When `enum` is Array-like, each element `ele` is converted to a field:
  #
  # *   If `ele` is an array of two or more elements, the field is formed from its
  #     first two elements (and any additional elements are ignored):
  #
  #         name = URI.encode_www_form_component(ele[0], enc)
  #         value = URI.encode_www_form_component(ele[1], enc)
  #         "#{name}=#{value}"
  #
  #     Examples:
  #
  #         URI.encode_www_form([%w[foo bar], %w[baz bat bah]])
  #         # => "foo=bar&baz=bat"
  #         URI.encode_www_form([['foo', 0], ['bar', :baz, 'bat']])
  #         # => "foo=0&bar=baz"
  #
  # *   If `ele` is an array of one element, the field is formed from `ele[0]`:
  #
  #         URI.encode_www_form_component(ele[0])
  #
  #     Example:
  #
  #         URI.encode_www_form([['foo'], [:bar], [0]])
  #         # => "foo&bar&0"
  #
  # *   Otherwise the field is formed from `ele`:
  #
  #         URI.encode_www_form_component(ele)
  #
  #     Example:
  #
  #         URI.encode_www_form(['foo', :bar, 0])
  #         # => "foo&bar&0"
  #
  # The elements of an Array-like `enum` may be mixture:
  #
  #     URI.encode_www_form([['foo', 0], ['bar', 1, 2], ['baz'], :bat])
  #     # => "foo=0&bar=1&baz&bat"
  #
  # When `enum` is Hash-like, each `key`/`value` pair is converted to one or more
  # fields:
  #
  # *   If `value` is
  #     [Array-convertible](rdoc-ref:implicit_conversion.rdoc@Array-Convertible+Ob
  #     jects), each element `ele` in `value` is paired with `key` to form a
  #     field:
  #
  #         name = URI.encode_www_form_component(key, enc)
  #         value = URI.encode_www_form_component(ele, enc)
  #         "#{name}=#{value}"
  #
  #     Example:
  #
  #         URI.encode_www_form({foo: [:bar, 1], baz: [:bat, :bam, 2]})
  #         # => "foo=bar&foo=1&baz=bat&baz=bam&baz=2"
  #
  # *   Otherwise, `key` and `value` are paired to form a field:
  #
  #         name = URI.encode_www_form_component(key, enc)
  #         value = URI.encode_www_form_component(value, enc)
  #         "#{name}=#{value}"
  #
  #     Example:
  #
  #         URI.encode_www_form({foo: 0, bar: 1, baz: 2})
  #         # => "foo=0&bar=1&baz=2"
  #
  # The elements of a Hash-like `enum` may be mixture:
  #
  #     URI.encode_www_form({foo: [0, 1], bar: 2})
  #     # => "foo=0&foo=1&bar=2"
  #
  def self.encode_www_form: (Enumerable[[ _ToS, _ToS ]] enum, ?encoding? enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - encode_www_form_component(str, enc=nil)
  # -->
  # Returns a URL-encoded string derived from the given string `str`.
  #
  # The returned string:
  #
  # *   Preserves:
  #
  #     *   Characters `'*'`, `'.'`, `'-'`, and `'_'`.
  #     *   Character in ranges `'a'..'z'`, `'A'..'Z'`, and `'0'..'9'`.
  #
  #     Example:
  #
  #         URI.encode_www_form_component('*.-_azAZ09')
  #         # => "*.-_azAZ09"
  #
  # *   Converts:
  #
  #     *   Character `' '` to character `'+'`.
  #     *   Any other character to "percent notation"; the percent notation for
  #         character *c* is `'%%%X' % c.ord`.
  #
  #     Example:
  #
  #         URI.encode_www_form_component('Here are some punctuation characters: ,;?:')
  #         # => "Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A"
  #
  # Encoding:
  #
  # *   If `str` has encoding Encoding::ASCII_8BIT, argument `enc` is ignored.
  # *   Otherwise `str` is converted first to Encoding::UTF_8 (with suitable
  #     character replacements), and then to encoding `enc`.
  #
  # In either case, the returned string has forced encoding Encoding::US_ASCII.
  #
  # Related: URI.encode_uri_component (encodes `' '` as `'%20'`).
  #
  def self.encode_www_form_component: (_ToS str, ?encoding? enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - extract(str, schemes = nil, &block)
  # -->
  # ## Synopsis
  #
  #     URI::extract(str[, schemes][,&blk])
  #
  # ## Args
  #
  # `str`
  # :   String to extract URIs from.
  # `schemes`
  # :   Limit URI matching to specific schemes.
  #
  #
  # ## Description
  #
  # Extracts URIs from a string. If block given, iterates through all matched
  # URIs. Returns nil if block given or array with matches.
  #
  # ## Usage
  #
  #     require "uri"
  #
  #     URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
  #     # => ["http://foo.example.com/bla", "mailto:test@example.com"]
  #
  def self.extract: (String str, ?Array[String] schemes) -> Array[String]
                  | (String str, ?Array[String] schemes) { (String) -> void } -> nil

  def self.get_encoding: (String label) -> Encoding?

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - join(*str)
  # -->
  # Merges the given URI strings `str` per [RFC
  # 2396](https://www.rfc-editor.org/rfc/rfc2396.html).
  #
  # Each string in `str` is converted to an [RFC3986
  # URI](https://www.rfc-editor.org/rfc/rfc3986.html) before being merged.
  #
  # Examples:
  #
  #     URI.join("http://example.com/","main.rbx")
  #     # => #<URI::HTTP http://example.com/main.rbx>
  #
  #     URI.join('http://example.com', 'foo')
  #     # => #<URI::HTTP http://example.com/foo>
  #
  #     URI.join('http://example.com', '/foo', '/bar')
  #     # => #<URI::HTTP http://example.com/bar>
  #
  #     URI.join('http://example.com', '/foo', 'bar')
  #     # => #<URI::HTTP http://example.com/bar>
  #
  #     URI.join('http://example.com', '/foo/', 'bar')
  #     # => #<URI::HTTP http://example.com/foo/bar>
  #
  def self.join: (_ToStr | URI::Generic str, *_ToStr | URI::Generic strs) -> URI::Generic

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - parse(uri)
  # -->
  # Returns a new URI object constructed from the given string `uri`:
  #
  #     URI.parse('https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
  #     # => #<URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
  #     URI.parse('http://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
  #     # => #<URI::HTTP http://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
  #
  # It's recommended to first ::escape string `uri` if it may contain invalid URI
  # characters.
  #
  def self.parse: (_ToStr uri) -> (File | FTP | HTTP | HTTPS | LDAP | LDAPS | MailTo | WS | WSS | Generic)

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - regexp(schemes = nil)
  # -->
  # ## Synopsis
  #
  #     URI::regexp([match_schemes])
  #
  # ## Args
  #
  # `match_schemes`
  # :   Array of schemes. If given, resulting regexp matches to URIs whose scheme
  #     is one of the match_schemes.
  #
  #
  # ## Description
  #
  # Returns a Regexp object which matches to URI-like strings. The Regexp object
  # returned by this method includes arbitrary number of capture group
  # (parentheses).  Never rely on its number.
  #
  # ## Usage
  #
  #     require 'uri'
  #
  #     # extract first URI from html_string
  #     html_string.slice(URI.regexp)
  #
  #     # remove ftp URIs
  #     html_string.sub(URI.regexp(['ftp']), '')
  #
  #     # You should not rely on the number of parentheses
  #     html_string.scan(URI.regexp) do |*matches|
  #       p $&
  #     end
  #
  def self.regexp: (?Array[String]? schemes) -> Regexp

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - scheme_list()
  # -->
  # Returns a hash of the defined schemes:
  #
  #     URI.scheme_list
  #     # =>
  #     {"MAILTO"=>URI::MailTo,
  #      "LDAPS"=>URI::LDAPS,
  #      "WS"=>URI::WS,
  #      "HTTP"=>URI::HTTP,
  #      "HTTPS"=>URI::HTTPS,
  #      "LDAP"=>URI::LDAP,
  #      "FILE"=>URI::File,
  #      "FTP"=>URI::FTP}
  #
  # Related: URI.register_scheme.
  #
  def self.scheme_list: () -> Hash[String, Class]

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - for(scheme, *arguments, default: Generic)
  # -->
  # Returns a new object constructed from the given `scheme`, `arguments`, and
  # `default`:
  #
  # *   The new object is an instance of `URI.scheme_list[scheme.upcase]`.
  # *   The object is initialized by calling the class initializer using `scheme`
  #     and `arguments`. See URI::Generic.new.
  #
  # Examples:
  #
  #     values = ['john.doe', 'www.example.com', '123', nil, '/forum/questions/', nil, 'tag=networking&order=newest', 'top']
  #     URI.for('https', *values)
  #     # => #<URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
  #     URI.for('foo', *values, default: URI::HTTP)
  #     # => #<URI::HTTP foo://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
  #
  def self.for: (String scheme, *untyped arguments, ?default: Class) -> (File | FTP | HTTP | HTTPS | LDAP | LDAPS | MailTo | WS | WSS | Generic)

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - split(uri)
  # -->
  # Returns a 9-element array representing the parts of the URI formed from the
  # string `uri`; each array element is a string or `nil`:
  #
  #     names = %w[scheme userinfo host port registry path opaque query fragment]
  #     values = URI.split('https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
  #     names.zip(values)
  #     # =>
  #     [["scheme", "https"],
  #      ["userinfo", "john.doe"],
  #      ["host", "www.example.com"],
  #      ["port", "123"],
  #      ["registry", nil],
  #      ["path", "/forum/questions/"],
  #      ["opaque", nil],
  #      ["query", "tag=networking&order=newest"],
  #      ["fragment", "top"]]
  #
  def self.split: (_ToStr uri) -> [ String?, String?, String?, String?, nil, String?, String?, String?, String? ]
end

URI::ABS_PATH: Regexp

URI::ABS_URI: Regexp

URI::ABS_URI_REF: Regexp

URI::DEFAULT_PARSER: URI::RFC2396_Parser

URI::ESCAPED: Regexp

URI::FRAGMENT: Regexp

URI::HOST: Regexp

URI::OPAQUE: Regexp

URI::PORT: Regexp

URI::QUERY: Regexp

URI::REGISTRY: Regexp

URI::REL_PATH: Regexp

URI::REL_URI: Regexp

URI::REL_URI_REF: Regexp

URI::RFC3986_PARSER: URI::RFC3986_Parser

URI::SCHEME: Regexp

URI::TBLDECWWWCOMP_: Hash[String, String]

URI::TBLENCWWWCOMP_: Hash[String, String]

URI::UNSAFE: Regexp

URI::URI_REF: Regexp

URI::USERINFO: Regexp

URI::VERSION: String

URI::VERSION_CODE: String

URI::WEB_ENCODINGS_: Hash[String, String]

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - URI(uri)
  # -->
  # Returns a URI object derived from the given `uri`, which may be a URI string
  # or an existing URI object:
  #
  #     # Returns a new URI.
  #     uri = URI('http://github.com/ruby/ruby')
  #     # => #<URI::HTTP http://github.com/ruby/ruby>
  #     # Returns the given URI.
  #     URI(uri)
  #     # => #<URI::HTTP http://github.com/ruby/ruby>
  #
  def self?.URI: (URI::Generic | String uri) -> URI::Generic
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
  # Includes URI::REGEXP::PATTERN
  #
  module RFC2396_REGEXP
  end

  # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
  # Class that parses String's into URI's.
  #
  # It contains a Hash set of patterns and Regexp's that match and validate.
  #
  class RFC2396_Parser
    include RFC2396_REGEXP

    # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
    # The Hash of patterns.
    #
    # See also URI::Parser.initialize_pattern.
    #
    attr_reader pattern: Hash[Symbol, String]

    # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
    # The Hash of Regexp.
    #
    # See also URI::Parser.initialize_regexp.
    #
    attr_reader regexp: Hash[Symbol, Regexp]

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - new(opts = {})
    # -->
    # ## Synopsis
    #
    #     URI::Parser.new([opts])
    #
    # ## Args
    #
    # The constructor accepts a hash as options for parser. Keys of options are
    # pattern names of URI components and values of options are pattern strings. The
    # constructor generates set of regexps for parsing URIs.
    #
    # You can use the following keys:
    #
    #     * :ESCAPED (URI::PATTERN::ESCAPED in default)
    #     * :UNRESERVED (URI::PATTERN::UNRESERVED in default)
    #     * :DOMLABEL (URI::PATTERN::DOMLABEL in default)
    #     * :TOPLABEL (URI::PATTERN::TOPLABEL in default)
    #     * :HOSTNAME (URI::PATTERN::HOSTNAME in default)
    #
    # ## Examples
    #
    #     p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
    #     u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP http://example.jp/%uABCD>
    #     URI.parse(u.to_s) #=> raises URI::InvalidURIError
    #
    #     s = "http://example.com/ABCD"
    #     u1 = p.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    #     u2 = URI.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    #     u1 == u2 #=> true
    #     u1.eql?(u2) #=> false
    #
    def initialize: (?Hash[Symbol, String] opts) -> void

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - escape( str )
    #   - escape( str, unsafe )
    # -->
    # ## Args
    #
    # `str`
    # :   String to make safe
    #
    # `unsafe`
    # :   Regexp to apply. Defaults to `self.regexp[:UNSAFE]`
    #
    #
    # ## Description
    #
    # Constructs a safe String from `str`, removing unsafe characters, replacing
    # them with codes.
    #
    def escape: (String str, ?Regexp unsafe) -> String

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - extract( str )
    #   - extract( str, schemes )
    #   - extract( str, schemes ) {|item| block }
    # -->
    # ## Args
    #
    # `str`
    # :   String to search
    #
    # `schemes`
    # :   Patterns to apply to `str`
    #
    #
    # ## Description
    #
    # Attempts to parse and merge a set of URIs. If no `block` given, then returns
    # the result, else it calls `block` for each element in result.
    #
    # See also URI::Parser.make_regexp.
    #
    def extract: (String str, ?Array[String] schemes) -> Array[String]
               | (String str, ?Array[String] schemes) { (String) -> untyped } -> nil

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - join(*uris)
    # -->
    # ## Args
    #
    # `uris`
    # :   an Array of Strings
    #
    #
    # ## Description
    #
    # Attempts to parse and merge a set of URIs.
    #
    def join: (*String uris) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - make_regexp(schemes = nil)
    # -->
    # Returns Regexp that is default `self.regexp[:ABS_URI_REF]`, unless `schemes`
    # is provided. Then it is a Regexp.union with `self.pattern[:X_ABS_URI]`.
    #
    def make_regexp: (?Array[String] schemes) -> Regexp

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - parse(uri)
    # -->
    # ## Args
    #
    # `uri`
    # :   String
    #
    #
    # ## Description
    #
    # Parses `uri` and constructs either matching URI scheme object (File, FTP,
    # HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic.
    #
    # ## Usage
    #
    #     p = URI::Parser.new
    #     p.parse("ldap://ldap.example.com/dc=example?user=john")
    #     #=> #<URI::LDAP ldap://ldap.example.com/dc=example?user=john>
    #
    def parse: (String uri) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - split(uri)
    # -->
    # Returns a split URI against `regexp[:ABS_URI]`.
    #
    def split: (String uri) -> [ String?, String?, String?, String?, String?, String?, String?, String?, String? ]

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - unescape( str )
    #   - unescape( str, escaped )
    # -->
    # ## Args
    #
    # `str`
    # :   String to remove escapes from
    #
    # `escaped`
    # :   Regexp to apply. Defaults to `self.regexp[:ESCAPED]`
    #
    #
    # ## Description
    #
    # Removes escapes from `str`.
    #
    def unescape: (String str, ?Regexp escaped) -> String
  end
end
class URI::RFC3986_Parser
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/file.rb -->
  # The "file" URI is defined by RFC8089.
  #
  class File < Generic
    # <!-- rdoc-file=lib/uri/file.rb -->
    # A Default port of nil for URI::File.
    #
    DEFAULT_PORT: Integer?

    # <!-- rdoc-file=lib/uri/file.rb -->
    # An Array of the available components for URI::File.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::File object from components, with syntax checking.
    #
    # The components accepted are `host` and `path`.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[host,
    # path]`.
    #
    # A path from e.g. the File class should be escaped before being passed.
    #
    # Examples:
    #
    #     require 'uri'
    #
    #     uri1 = URI::File.build(['host.example.com', '/path/file.zip'])
    #     uri1.to_s  # => "file://host.example.com/path/file.zip"
    #
    #     uri2 = URI::File.build({:host => 'host.example.com',
    #       :path => '/ruby/src'})
    #     uri2.to_s  # => "file://host.example.com/ruby/src"
    #
    #     uri3 = URI::File.build({:path => URI::escape('/path/my file.txt')})
    #     uri3.to_s  # => "file:///path/my%20file.txt"
    #
    def self.build: (Array[String] args) -> URI::File
                  | ({ host: String?, path: String? }) -> URI::File

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_host(v)
    # -->
    # Protected setter for the host component `v`.
    #
    # See also URI::Generic.host=.
    #
    def set_host: (String? v) -> String

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_port(v)
    # -->
    # do nothing
    #
    def set_port: (Integer v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_userinfo(user)
    # -->
    # raise InvalidURIError
    #
    def check_userinfo: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_user(user)
    # -->
    # raise InvalidURIError
    #
    def check_user: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_password(user)
    # -->
    # raise InvalidURIError
    #
    def check_password: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_userinfo(v)
    # -->
    # do nothing
    #
    def set_userinfo: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_user(v)
    # -->
    # do nothing
    #
    def set_user: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_password(v)
    # -->
    # do nothing
    #
    def set_password: (String v) -> nil
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ldap.rb -->
  # LDAP URI SCHEMA (described in RFC2255).
  #
  class LDAP < Generic
    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # A Default port of 389 for URI::LDAP.
    #
    DEFAULT_PORT: Integer

    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # An Array of the available components for URI::LDAP.
    #
    COMPONENT: Array[Symbol]

    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # Scopes available for the starting point.
    #
    # *   SCOPE_BASE - the Base DN
    # *   SCOPE_ONE  - one level under the Base DN, not including the base DN and
    #     not including any entries under this
    # *   SCOPE_SUB  - subtrees, all entries at all levels
    #
    SCOPE: Array[String]

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::LDAP object from components, with syntax checking.
    #
    # The components accepted are host, port, dn, attributes, scope, filter, and
    # extensions.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[host, port,
    # dn, attributes, scope, filter, extensions]`.
    #
    # Example:
    #
    #     uri = URI::LDAP.build({:host => 'ldap.example.com',
    #       :dn => '/dc=example'})
    #
    #     uri = URI::LDAP.build(["ldap.example.com", nil,
    #       "/dc=example;dc=com", "query", nil, nil, nil])
    #
    def self.build: (Array[nil | String | Integer] args) -> URI::LDAP
                  | ({ host: String?, port: Integer?, dn: String?, attributes: String?, scope: String?, filter: String?, extensions: String? }) -> URI::LDAP

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - new(*arg)
    # -->
    # ## Description
    #
    # Creates a new URI::LDAP object from generic URI components as per RFC 2396. No
    # LDAP-specific syntax checking is performed.
    #
    # Arguments are `scheme`, `userinfo`, `host`, `port`, `registry`, `path`,
    # `opaque`, `query`, and `fragment`, in that order.
    #
    # Example:
    #
    #     uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil, nil,
    #       "/dc=example;dc=com", nil, "query", nil)
    #
    # See also URI::Generic.new.
    #
    def initialize: (String schema, String? userinfo, String host, Integer? port, String? registry, String? path, String? opaque, String query, String? fragment) -> void

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - parse_dn()
    # -->
    # Private method to cleanup `dn` from using the `path` component attribute.
    #
    def parse_dn: () -> nil

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - parse_query()
    # -->
    # Private method to cleanup `attributes`, `scope`, `filter`, and `extensions`
    # from using the `query` component attribute.
    #
    def parse_query: () -> nil

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - build_path_query()
    # -->
    # Private method to assemble `query` from `attributes`, `scope`, `filter`, and
    # `extensions`.
    #
    def build_path_query: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - dn()
    # -->
    # Returns dn.
    #
    def dn: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_dn(val)
    # -->
    # Private setter for dn `val`.
    #
    def set_dn: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - dn=(val)
    # -->
    # Setter for dn `val`.
    #
    def dn=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - attributes()
    # -->
    # Returns attributes.
    #
    def attributes: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_attributes(val)
    # -->
    # Private setter for attributes `val`.
    #
    def set_attributes: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - attributes=(val)
    # -->
    # Setter for attributes `val`.
    #
    def attributes=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - scope()
    # -->
    # Returns scope.
    #
    def scope: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_scope(val)
    # -->
    # Private setter for scope `val`.
    #
    def set_scope: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - scope=(val)
    # -->
    # Setter for scope `val`.
    #
    def scope=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - filter()
    # -->
    # Returns filter.
    #
    def filter: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_filter(val)
    # -->
    # Private setter for filter `val`.
    #
    def set_filter: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - filter=(val)
    # -->
    # Setter for filter `val`.
    #
    def filter=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - extensions()
    # -->
    # Returns extensions.
    #
    def extensions: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_extensions(val)
    # -->
    # Private setter for extensions `val`.
    #
    def set_extensions: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - extensions=(val)
    # -->
    # Setter for extensions `val`.
    #
    def extensions=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - hierarchical?()
    # -->
    # Checks if URI has a path. For URI::LDAP this will return `false`.
    #
    def hierarchical?: () -> ::FalseClass
  end
end
%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ftp.rb -->
  # FTP URI syntax is defined by RFC1738 section 3.2.
  #
  # This class will be redesigned because of difference of implementations; the
  # structure of its path. draft-hoffman-ftp-uri-04 is a draft but it is a good
  # summary about the de facto spec.
  # https://datatracker.ietf.org/doc/html/draft-hoffman-ftp-uri-04
  #
  class FTP < Generic
  end
end
module YAML = Psych
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error when zlib returns a Z_BUF_ERROR.
  #
  # Usually if no progress is possible.
  #
  class BufError < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error
  #
  # When zlib returns a Z_STREAM_ERROR, usually if the stream state was
  # inconsistent.
  #
  class StreamError < Zlib::Error
  end
end
# <!-- rdoc-file=ext/zlib/zlib.c -->
# This module provides access to the [zlib library](http://zlib.net). Zlib is
# designed to be a portable, free, general-purpose, legally unencumbered -- that
# is, not covered by any patents -- lossless data-compression library for use on
# virtually any computer hardware and operating system.
#
# The zlib compression library provides in-memory compression and decompression
# functions, including integrity checks of the uncompressed data.
#
# The zlib compressed data format is described in RFC 1950, which is a wrapper
# around a deflate stream which is described in RFC 1951.
#
# The library also supports reading and writing files in gzip (.gz) format with
# an interface similar to that of IO. The gzip format is described in RFC 1952
# which is also a wrapper around a deflate stream.
#
# The zlib format was designed to be compact and fast for use in memory and on
# communications channels. The gzip format was designed for single-file
# compression on file systems, has a larger header than zlib to maintain
# directory information, and uses a different, slower check method than zlib.
#
# See your system's zlib.h for further information about zlib
#
# ## Sample usage
#
# Using the wrapper to compress strings with default parameters is quite simple:
#
#     require "zlib"
#
#     data_to_compress = File.read("don_quixote.txt")
#
#     puts "Input size: #{data_to_compress.size}"
#     #=> Input size: 2347740
#
#     data_compressed = Zlib::Deflate.deflate(data_to_compress)
#
#     puts "Compressed size: #{data_compressed.size}"
#     #=> Compressed size: 887238
#
#     uncompressed_data = Zlib::Inflate.inflate(data_compressed)
#
#     puts "Uncompressed data is: #{uncompressed_data}"
#     #=> Uncompressed data is: The Project Gutenberg EBook of Don Quixote...
#
# ## Class tree
#
# *   Zlib::Deflate
# *   Zlib::Inflate
# *   Zlib::ZStream
# *   Zlib::Error
#     *   Zlib::StreamEnd
#     *   Zlib::NeedDict
#     *   Zlib::DataError
#     *   Zlib::StreamError
#     *   Zlib::MemError
#     *   Zlib::BufError
#     *   Zlib::VersionError
#     *   Zlib::InProgressError
#
# (if you have GZIP_SUPPORT)
# *   Zlib::GzipReader
# *   Zlib::GzipWriter
# *   Zlib::GzipFile
# *   Zlib::GzipFile::Error
#     *   Zlib::GzipFile::LengthError
#     *   Zlib::GzipFile::CRCError
#     *   Zlib::GzipFile::NoFooter
#
module Zlib
  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.adler32(string, adler)
  # -->
  # Calculates Adler-32 checksum for `string`, and returns updated value of
  # `adler`. If `string` is omitted, it returns the Adler-32 initial value. If
  # `adler` is omitted, it assumes that the initial value is given to `adler`. If
  # `string` is an IO instance, reads from the IO until the IO returns nil and
  # returns Adler-32 of all read data.
  #
  # Example usage:
  #
  #     require "zlib"
  #
  #     data = "foo"
  #     puts "Adler32 checksum: #{Zlib.adler32(data).to_s(16)}"
  #     #=> Adler32 checksum: 2820145
  #
  def self.adler32: () -> Integer
                  | (String) -> Integer
                  | (String, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.adler32_combine(adler1, adler2, len2)
  # -->
  # Combine two Adler-32 check values in to one.  `adler1` is the first Adler-32
  # value, `adler2` is the second Adler-32 value.  `len2` is the length of the
  # string used to generate `adler2`.
  #
  def self.adler32_combine: (Integer, Integer, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.crc32(string, crc)
  # -->
  # Calculates CRC checksum for `string`, and returns updated value of `crc`. If
  # `string` is omitted, it returns the CRC initial value. If `crc` is omitted, it
  # assumes that the initial value is given to `crc`. If `string` is an IO
  # instance, reads from the IO until the IO returns nil and returns CRC checksum
  # of all read data.
  #
  # FIXME: expression.
  #
  def self.crc32: () -> Integer
                | (String) -> Integer
                | (String, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.crc32_combine(crc1, crc2, len2)
  # -->
  # Combine two CRC-32 check values in to one.  `crc1` is the first CRC-32 value,
  # `crc2` is the second CRC-32 value.  `len2` is the length of the string used to
  # generate `crc2`.
  #
  def self.crc32_combine: (Integer, Integer, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - crc_table()
  # -->
  # Returns the table for calculating CRC checksum as an array.
  #
  def self.crc_table: () -> Array[Integer]

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.deflate(string[, level])
  #   - Zlib::Deflate.deflate(string[, level])
  # -->
  # Compresses the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
  # Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, or an
  # integer from 0 to 9.
  #
  # This method is almost equivalent to the following code:
  #
  #     def deflate(string, level)
  #       z = Zlib::Deflate.new(level)
  #       dst = z.deflate(string, Zlib::FINISH)
  #       z.close
  #       dst
  #     end
  #
  # See also Zlib.inflate
  #
  def self.deflate: (String) -> String
                  | (String, Integer) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.gunzip(src) -> String
  # -->
  # Decode the given gzipped `string`.
  #
  # This method is almost equivalent to the following code:
  #
  #     def gunzip(string)
  #       sio = StringIO.new(string)
  #       gz = Zlib::GzipReader.new(sio, encoding: Encoding::ASCII_8BIT)
  #       gz.read
  #     ensure
  #       gz&.close
  #     end
  #
  # See also Zlib.gzip
  #
  def self.gunzip: (String) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.gzip(src, level: nil, strategy: nil) -> String
  # -->
  # Gzip the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
  # Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION (default),
  # or an integer from 0 to 9.
  #
  # This method is almost equivalent to the following code:
  #
  #     def gzip(string, level: nil, strategy: nil)
  #       sio = StringIO.new
  #       sio.binmode
  #       gz = Zlib::GzipWriter.new(sio, level, strategy)
  #       gz.write(string)
  #       gz.close
  #       sio.string
  #     end
  #
  # See also Zlib.gunzip
  #
  def self.gzip: (String) -> String
               | (String, level: Integer) -> String
               | (String, strategy: Integer) -> String
               | (String, level: Integer, strategy: Integer) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.inflate(string)
  #   - Zlib::Inflate.inflate(string)
  # -->
  # Decompresses `string`. Raises a Zlib::NeedDict exception if a preset
  # dictionary is needed for decompression.
  #
  # This method is almost equivalent to the following code:
  #
  #     def inflate(string)
  #       zstream = Zlib::Inflate.new
  #       buf = zstream.inflate(string)
  #       zstream.finish
  #       zstream.close
  #       buf
  #     end
  #
  # See also Zlib.deflate
  #
  def self.inflate: (String) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - zlib_version()
  # -->
  # Returns the string which represents the version of zlib library.
  #
  def self.zlib_version: () -> String
end

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents text data as guessed by deflate.
#
# NOTE: The underlying constant Z_ASCII was deprecated in favor of Z_TEXT in
# zlib 1.2.2.  New applications should not use this constant.
#
# See Zlib::Deflate#data_type.
#
Zlib::ASCII: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Slowest compression level, but with the best space savings.
#
Zlib::BEST_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Fastest compression level, but with the lowest space savings.
#
Zlib::BEST_SPEED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents binary data as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::BINARY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Default compression level which is a good trade-off between space and time
#
Zlib::DEFAULT_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Default deflate strategy which is used for normal data.
#
Zlib::DEFAULT_STRATEGY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The default memory level for allocating zlib deflate compression state.
#
Zlib::DEF_MEM_LEVEL: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy for data produced by a filter (or predictor). The effect of
# FILTERED is to force more Huffman codes and less string matching; it is
# somewhat intermediate between DEFAULT_STRATEGY and HUFFMAN_ONLY. Filtered data
# consists mostly of small values with a somewhat random distribution.
#
Zlib::FILTERED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Processes all pending input and flushes pending output.
#
Zlib::FINISH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy which prevents the use of dynamic Huffman codes, allowing for
# a simpler decoder for specialized applications.
#
Zlib::FIXED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Flushes all output as with SYNC_FLUSH, and the compression state is reset so
# that decompression can restart from this point if previous compressed data has
# been damaged or if random access is desired. Like SYNC_FLUSH, using FULL_FLUSH
# too often can seriously degrade compression.
#
Zlib::FULL_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy which uses Huffman codes only (no string matching).
#
Zlib::HUFFMAN_ONLY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The maximum memory level for allocating zlib deflate compression state.
#
Zlib::MAX_MEM_LEVEL: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The maximum size of the zlib history buffer.  Note that zlib allows larger
# values to enable different inflate modes.  See Zlib::Inflate.new for details.
#
Zlib::MAX_WBITS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# No compression, passes through data untouched.  Use this for appending
# pre-compressed data to a deflate stream.
#
Zlib::NO_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# NO_FLUSH is the default flush method and allows deflate to decide how much
# data to accumulate before producing output in order to maximize compression.
#
Zlib::NO_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Amiga hosts
#
Zlib::OS_AMIGA: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Atari hosts
#
Zlib::OS_ATARI: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The OS code of current host
#
Zlib::OS_CODE: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for CP/M hosts
#
Zlib::OS_CPM: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Mac OS hosts
#
Zlib::OS_MACOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for MSDOS hosts
#
Zlib::OS_MSDOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for OS2 hosts
#
Zlib::OS_OS2: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for QDOS hosts
#
Zlib::OS_QDOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for RISC OS hosts
#
Zlib::OS_RISCOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for TOPS-20 hosts
#
Zlib::OS_TOPS20: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for UNIX hosts
#
Zlib::OS_UNIX: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for unknown hosts
#
Zlib::OS_UNKNOWN: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for VM OS hosts
#
Zlib::OS_VMCMS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for VMS hosts
#
Zlib::OS_VMS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Win32 hosts
#
Zlib::OS_WIN32: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Z-System hosts
#
Zlib::OS_ZSYSTEM: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate compression strategy designed to be almost as fast as HUFFMAN_ONLY,
# but give better compression for PNG image data.
#
Zlib::RLE: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The SYNC_FLUSH method flushes all pending output to the output buffer and the
# output is aligned on a byte boundary. Flushing may degrade compression so it
# should be used only when necessary, such as at a request or response boundary
# for a network stream.
#
Zlib::SYNC_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents text data as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::TEXT: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents an unknown data type as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::UNKNOWN: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The Ruby/zlib version string.
#
Zlib::VERSION: String

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The string which represents the version of zlib.h
#
Zlib::ZLIB_VERSION: String
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib::GzipFile is an abstract class for handling a gzip formatted compressed
  # file. The operations are defined in the subclasses, Zlib::GzipReader for
  # reading, and Zlib::GzipWriter for writing.
  #
  # GzipReader should be used by associating an IO, or IO-like, object.
  #
  # ## Method Catalogue
  #
  # *   ::wrap
  # *   ::open (Zlib::GzipReader::open and Zlib::GzipWriter::open)
  # *   #close
  # *   #closed?
  # *   #comment
  # *   comment= (Zlib::GzipWriter#comment=)
  # *   #crc
  # *   eof? (Zlib::GzipReader#eof?)
  # *   #finish
  # *   #level
  # *   lineno (Zlib::GzipReader#lineno)
  # *   lineno= (Zlib::GzipReader#lineno=)
  # *   #mtime
  # *   mtime= (Zlib::GzipWriter#mtime=)
  # *   #orig_name
  # *   orig_name (Zlib::GzipWriter#orig_name=)
  # *   #os_code
  # *   path (when the underlying IO supports #path)
  # *   #sync
  # *   #sync=
  # *   #to_io
  #
  # (due to internal structure, documentation may appear under Zlib::GzipReader or
  # Zlib::GzipWriter)
  #
  class GzipFile
    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipReader.wrap(io, ...) { |gz| ... }
    #   - Zlib::GzipWriter.wrap(io, ...) { |gz| ... }
    # -->
    # Creates a GzipReader or GzipWriter associated with `io`, passing in any
    # necessary extra options, and executes the block with the newly created object
    # just like File.open.
    #
    # The GzipFile object will be closed automatically after executing the block. If
    # you want to keep the associated IO object open, you may call
    # Zlib::GzipFile#finish method in the block.
    #
    def self.wrap: (IO io, *untyped) { (instance gz) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - close()
    # -->
    # Closes the GzipFile object. This method calls close method of the associated
    # IO object. Returns the associated IO object.
    #
    def close: () -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - closed?()
    # -->
    # Same as IO#closed?
    #
    def closed?: () -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - comment()
    # -->
    # Returns comments recorded in the gzip file header, or nil if the comments is
    # not present.
    #
    def comment: () -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - crc()
    # -->
    # Returns CRC value of the uncompressed data.
    #
    def crc: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - finish()
    # -->
    # Closes the GzipFile object. Unlike Zlib::GzipFile#close, this method never
    # calls the close method of the associated IO object. Returns the associated IO
    # object.
    #
    def finish: () -> IO

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - level()
    # -->
    # Returns compression level.
    #
    def level: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - mtime()
    # -->
    # Returns last modification time recorded in the gzip file header.
    #
    def mtime: () -> Time

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - orig_name()
    # -->
    # Returns original filename recorded in the gzip file header, or `nil` if
    # original filename is not present.
    #
    def orig_name: () -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - os_code()
    # -->
    # Returns OS code number recorded in the gzip file header.
    #
    def os_code: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - sync()
    # -->
    # Same as IO#sync
    #
    def sync: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - sync = flag
    # -->
    # Same as IO.  If flag is `true`, the associated IO object must respond to the
    # `flush` method.  While `sync` mode is `true`, the compression ratio decreases
    # sharply.
    #
    def sync=: (boolish) -> untyped

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - to_io()
    # -->
    # Same as IO.
    #
    def to_io: () -> IO
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib::ZStream is the abstract class for the stream which handles the
  # compressed data. The operations are defined in the subclasses: Zlib::Deflate
  # for compression, and Zlib::Inflate for decompression.
  #
  # An instance of Zlib::ZStream has one stream (struct zstream in the source) and
  # two variable-length buffers which associated to the input (next_in) of the
  # stream and the output (next_out) of the stream. In this document, "input
  # buffer" means the buffer for input, and "output buffer" means the buffer for
  # output.
  #
  # Data input into an instance of Zlib::ZStream are temporally stored into the
  # end of input buffer, and then data in input buffer are processed from the
  # beginning of the buffer until no more output from the stream is produced (i.e.
  # until avail_out > 0 after processing).  During processing, output buffer is
  # allocated and expanded automatically to hold all output data.
  #
  # Some particular instance methods consume the data in output buffer and return
  # them as a String.
  #
  # Here is an ascii art for describing above:
  #
  #     +================ an instance of Zlib::ZStream ================+
  #     ||                                                            ||
  #     ||     +--------+          +-------+          +--------+      ||
  #     ||  +--| output |<---------|zstream|<---------| input  |<--+  ||
  #     ||  |  | buffer |  next_out+-------+next_in   | buffer |   |  ||
  #     ||  |  +--------+                             +--------+   |  ||
  #     ||  |                                                      |  ||
  #     +===|======================================================|===+
  #         |                                                      |
  #         v                                                      |
  #     "output data"                                         "input data"
  #
  # If an error occurs during processing input buffer, an exception which is a
  # subclass of Zlib::Error is raised.  At that time, both input and output buffer
  # keep their conditions at the time when the error occurs.
  #
  # ## Method Catalogue
  #
  # Many of the methods in this class are fairly low-level and unlikely to be of
  # interest to users.  In fact, users are unlikely to use this class directly;
  # rather they will be interested in Zlib::Inflate and Zlib::Deflate.
  #
  # The higher level methods are listed below.
  #
  # *   #total_in
  # *   #total_out
  # *   #data_type
  # *   #adler
  # *   #reset
  # *   #finish
  # *   #finished?
  # *   #close
  # *   #closed?
  #
  class ZStream
    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - adler()
    # -->
    # Returns the adler-32 checksum.
    #
    def adler: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - avail_in()
    # -->
    # Returns bytes of data in the input buffer. Normally, returns 0.
    #
    def avail_in: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - avail_out()
    # -->
    # Returns number of bytes of free spaces in output buffer.  Because the free
    # space is allocated automatically, this method returns 0 normally.
    #
    def avail_out: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - avail_out=(p1)
    # -->
    # Allocates `size` bytes of free space in the output buffer. If there are more
    # than `size` bytes already in the buffer, the buffer is truncated. Because free
    # space is allocated automatically, you usually don't need to use this method.
    #
    def avail_out=: (Integer p1) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - close()
    # -->
    # Closes the stream. All operations on the closed stream will raise an
    # exception.
    #
    def close: () -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - closed?()
    # -->
    # Returns true if the stream is closed.
    #
    def closed?: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - data_type()
    # -->
    # Guesses the type of the data which have been inputted into the stream. The
    # returned value is either `BINARY`, `ASCII`, or `UNKNOWN`.
    #
    def data_type: () -> String

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Closes the stream. All operations on the closed stream will raise an
    # exception.
    #
    def end: () -> void

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Returns true if the stream is closed.
    #
    def ended?: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - finish                 -> String
    #   - finish { |chunk| ... } -> nil
    # -->
    # Finishes the stream and flushes output buffer.  If a block is given each chunk
    # is yielded to the block until the input buffer has been flushed to the output
    # buffer.
    #
    def finish: () -> String
              | () { (String chunk) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - finished?()
    # -->
    # Returns true if the stream is finished.
    #
    def finished?: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - flush_next_in -> input
    # -->
    #
    def flush_next_in: () -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - flush_next_out                 -> String
    #   - flush_next_out { |chunk| ... } -> nil
    # -->
    # Flushes output buffer and returns all data in that buffer.  If a block is
    # given each chunk is yielded to the block until the current output buffer has
    # been flushed.
    #
    def flush_next_out: () -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - reset()
    # -->
    # Resets and initializes the stream. All data in both input and output buffer
    # are discarded.
    #
    def reset: () -> void

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Returns true if the stream is finished.
    #
    def stream_end?: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - total_in()
    # -->
    # Returns the total bytes of the input data to the stream.  FIXME
    #
    def total_in: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - total_out()
    # -->
    # Returns the total bytes of the output data from the stream.  FIXME
    #
    def total_out: () -> Integer
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib:Inflate is the class for decompressing compressed data.  Unlike
  # Zlib::Deflate, an instance of this class is not able to duplicate (clone, dup)
  # itself.
  #
  class Inflate < Zlib::ZStream
    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib.inflate(string)
    #   - Zlib::Inflate.inflate(string)
    # -->
    # Decompresses `string`. Raises a Zlib::NeedDict exception if a preset
    # dictionary is needed for decompression.
    #
    # This method is almost equivalent to the following code:
    #
    #     def inflate(string)
    #       zstream = Zlib::Inflate.new
    #       buf = zstream.inflate(string)
    #       zstream.finish
    #       zstream.close
    #       buf
    #     end
    #
    # See also Zlib.deflate
    #
    def self.inflate: (string string) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - <<(p1)
    # -->
    # Same as IO.
    #
    def <<: (_ToS obj) -> self

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - add_dictionary(string)
    # -->
    # Provide the inflate stream with a dictionary that may be required in the
    # future.  Multiple dictionaries may be provided.  The inflate stream will
    # automatically choose the correct user-provided dictionary based on the
    # stream's required dictionary.
    #
    def add_dictionary: (String arg0) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - inflate(deflate_string, buffer: nil)                 -> String
    #   - inflate(deflate_string, buffer: nil) { |chunk| ... } -> nil
    # -->
    # Inputs `deflate_string` into the inflate stream and returns the output from
    # the stream.  Calling this method, both the input and the output buffer of the
    # stream are flushed.  If string is `nil`, this method finishes the stream, just
    # like Zlib::ZStream#finish.
    #
    # If a block is given consecutive inflated chunks from the `deflate_string` are
    # yielded to the block and `nil` is returned.
    #
    # If a :buffer keyword argument is given and not nil:
    #
    # *   The :buffer keyword should be a String, and will used as the output
    #     buffer. Using this option can reuse the memory required during inflation.
    # *   When not passing a block, the return value will be the same object as the
    #     :buffer keyword argument.
    # *   When passing a block, the yielded chunks will be the same value as the
    #     :buffer keyword argument.
    #
    # Raises a Zlib::NeedDict exception if a preset dictionary is needed to
    # decompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then call
    # this method again with an empty string to flush the stream:
    #
    #     inflater = Zlib::Inflate.new
    #
    #     begin
    #       out = inflater.inflate compressed
    #     rescue Zlib::NeedDict
    #       # ensure the dictionary matches the stream's required dictionary
    #       raise unless inflater.adler == Zlib.adler32(dictionary)
    #
    #       inflater.set_dictionary dictionary
    #       inflater.inflate ''
    #     end
    #
    #     # ...
    #
    #     inflater.close
    #
    # See also Zlib::Inflate.new
    #
    def inflate: (string string, ?buffer: String) -> String
               | (string string, ?buffer: String) { (String chunk) -> nil } -> nil

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - set_dictionary(p1)
    # -->
    # Sets the preset dictionary and returns `string`.  This method is available
    # just only after a Zlib::NeedDict exception was raised.  See zlib.h for
    # details.
    #
    def set_dictionary: (String p1) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - sync(string)
    # -->
    # Inputs `string` into the end of input buffer and skips data until a full flush
    # point can be found.  If the point is found in the buffer, this method flushes
    # the buffer and returns false.  Otherwise it returns `true` and the following
    # data of full flush point is preserved in the buffer.
    #
    def sync: (String string) -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - sync_point?()
    # -->
    # Quoted verbatim from original documentation:
    #
    #     What is this?
    #
    # `:)`
    #
    def sync_point?: () -> bool

    private

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::Inflate.new(window_bits = Zlib::MAX_WBITS)
    # -->
    # Creates a new inflate stream for decompression.  `window_bits` sets the size
    # of the history buffer and can have the following values:
    #
    # 0
    # :   Have inflate use the window size from the zlib header of the compressed
    #     stream.
    #
    #
    # (8..15)
    # :   Overrides the window size of the inflate header in the compressed stream.
    #     The window size must be greater than or equal to the window size of the
    #     compressed stream.
    #
    #
    # Greater than 15
    # :   Add 32 to window_bits to enable zlib and gzip decoding with automatic
    #     header detection, or add 16 to decode only the gzip format (a
    #     Zlib::DataError will be raised for a non-gzip stream).
    #
    #
    # (-8..-15)
    # :   Enables raw deflate mode which will not generate a check value, and will
    #     not look for any check values for comparison at the end of the stream.
    #
    #     This is for use with other formats that use the deflate compressed data
    #     format such as zip which provide their own check values.
    #
    #
    # ## Example
    #
    #     open "compressed.file" do |compressed_io|
    #       zi = Zlib::Inflate.new(Zlib::MAX_WBITS + 32)
    #
    #       begin
    #         open "uncompressed.file", "w+" do |uncompressed_io|
    #           uncompressed_io << zi.inflate(compressed_io.read)
    #         end
    #       ensure
    #         zi.close
    #       end
    #     end
    #
    def initialize: (?Integer window_bits) -> void
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error
  #
  # When zlib returns a Z_STREAM_END is return if the end of the compressed data
  # has been reached and all uncompressed out put has been produced.
  #
  class StreamEnd < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error when zlib returns a Z_DATA_ERROR.
  #
  # Usually if a stream was prematurely freed.
  #
  class DataError < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib::Deflate is the class for compressing data.  See Zlib::ZStream for more
  # information.
  #
  class Deflate < Zlib::ZStream
    type compression_level = Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib.deflate(string[, level])
    #   - Zlib::Deflate.deflate(string[, level])
    # -->
    # Compresses the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
    # Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, or an
    # integer from 0 to 9.
    #
    # This method is almost equivalent to the following code:
    #
    #     def deflate(string, level)
    #       z = Zlib::Deflate.new(level)
    #       dst = z.deflate(string, Zlib::FINISH)
    #       z.close
    #       dst
    #     end
    #
    # See also Zlib.inflate
    #
    def self.deflate: (string string, ?compression_level level) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - << string
    # -->
    # Inputs `string` into the deflate stream just like Zlib::Deflate#deflate, but
    # returns the Zlib::Deflate object itself.  The output from the stream is
    # preserved in output buffer.
    #
    def <<: (string string) -> self

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - z.deflate(string, flush = Zlib::NO_FLUSH)                 -> String
    #   - z.deflate(string, flush = Zlib::NO_FLUSH) { |chunk| ... } -> nil
    # -->
    # Inputs `string` into the deflate stream and returns the output from the
    # stream.  On calling this method, both the input and the output buffers of the
    # stream are flushed.  If `string` is nil, this method finishes the stream, just
    # like Zlib::ZStream#finish.
    #
    # If a block is given consecutive deflated chunks from the `string` are yielded
    # to the block and `nil` is returned.
    #
    # The `flush` parameter specifies the flush mode.  The following constants may
    # be used:
    #
    # Zlib::NO_FLUSH
    # :   The default
    #
    # Zlib::SYNC_FLUSH
    # :   Flushes the output to a byte boundary
    #
    # Zlib::FULL_FLUSH
    # :   SYNC_FLUSH + resets the compression state
    #
    # Zlib::FINISH
    # :   Pending input is processed, pending output is flushed.
    #
    #
    # See the constants for further description.
    #
    def deflate: (string string, ?Integer flush) -> String
               | (string string, ?Integer flush) { (String chunk) -> nil } -> nil

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - flush(flush = Zlib::SYNC_FLUSH)                 -> String
    #   - flush(flush = Zlib::SYNC_FLUSH) { |chunk| ... } -> nil
    # -->
    # This method is equivalent to `deflate('', flush)`. This method is just
    # provided to improve the readability of your Ruby program.  If a block is given
    # chunks of deflate output are yielded to the block until the buffer is flushed.
    #
    # See Zlib::Deflate#deflate for detail on the `flush` constants NO_FLUSH,
    # SYNC_FLUSH, FULL_FLUSH and FINISH.
    #
    def flush: (?Integer flush) -> String
             | (?Integer flush) { (String chunk) -> nil } -> nil

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - params(level, strategy)
    # -->
    # Changes the parameters of the deflate stream to allow changes between
    # different types of data that require different types of compression.  Any
    # unprocessed data is flushed before changing the params.
    #
    # See Zlib::Deflate.new for a description of `level` and `strategy`.
    #
    def params: (compression_level level, Integer strategy) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - set_dictionary(string)
    # -->
    # Sets the preset dictionary and returns `string`. This method is available just
    # only after Zlib::Deflate.new or Zlib::ZStream#reset method was called. See
    # zlib.h for details.
    #
    # Can raise errors of Z_STREAM_ERROR if a parameter is invalid (such as NULL
    # dictionary) or the stream state is inconsistent, Z_DATA_ERROR if the given
    # dictionary doesn't match the expected one (incorrect adler32 value)
    #
    def set_dictionary: (String dictionary) -> String

    private

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::Deflate.new(level=DEFAULT_COMPRESSION, window_bits=MAX_WBITS, mem_level=DEF_MEM_LEVEL, strategy=DEFAULT_STRATEGY)
    # -->
    # Creates a new deflate stream for compression. If a given argument is nil, the
    # default value of that argument is used.
    #
    # The `level` sets the compression level for the deflate stream between 0 (no
    # compression) and 9 (best compression). The following constants have been
    # defined to make code more readable:
    #
    # *   Zlib::DEFAULT_COMPRESSION
    # *   Zlib::NO_COMPRESSION
    # *   Zlib::BEST_SPEED
    # *   Zlib::BEST_COMPRESSION
    #
    # See http://www.zlib.net/manual.html#Constants for further information.
    #
    # The `window_bits` sets the size of the history buffer and should be between 8
    # and 15.  Larger values of this parameter result in better compression at the
    # expense of memory usage.
    #
    # The `mem_level` specifies how much memory should be allocated for the internal
    # compression state.  1 uses minimum memory but is slow and reduces compression
    # ratio while 9 uses maximum memory for optimal speed.  The default value is 8.
    # Two constants are defined:
    #
    # *   Zlib::DEF_MEM_LEVEL
    # *   Zlib::MAX_MEM_LEVEL
    #
    # The `strategy` sets the deflate compression strategy.  The following
    # strategies are available:
    #
    # Zlib::DEFAULT_STRATEGY
    # :   For normal data
    #
    # Zlib::FILTERED
    # :   For data produced by a filter or predictor
    #
    # Zlib::FIXED
    # :   Prevents dynamic Huffman codes
    #
    # Zlib::HUFFMAN_ONLY
    # :   Prevents string matching
    #
    # Zlib::RLE
    # :   Designed for better compression of PNG image data
    #
    #
    # See the constants for further description.
    #
    # ## Examples
    #
    # ### Basic
    #
    #     open "compressed.file", "w+" do |io|
    #       io << Zlib::Deflate.new.deflate(File.read("big.file"))
    #     end
    #
    # ### Custom compression
    #
    #     open "compressed.file", "w+" do |compressed_io|
    #       deflate = Zlib::Deflate.new(Zlib::BEST_COMPRESSION,
    #                                   Zlib::MAX_WBITS,
    #                                   Zlib::MAX_MEM_LEVEL,
    #                                   Zlib::HUFFMAN_ONLY)
    #
    #       begin
    #         open "big.file" do |big_io|
    #           until big_io.eof? do
    #             compressed_io << zd.deflate(big_io.read(16384))
    #           end
    #         end
    #       ensure
    #         deflate.close
    #       end
    #     end
    #
    # While this example will work, for best optimization review the flags for your
    # specific time, memory usage and output space requirements.
    #
    def initialize: (?compression_level level, ?Integer window_bits, ?Integer mem_level, ?Integer strategy) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - initialize_copy(p1)
    # -->
    # Duplicates the deflate stream.
    #
    def initialize_copy: (self other) -> self
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib::GzipReader is the class for reading a gzipped file.  GzipReader should
  # be used as an IO, or -IO-like, object.
  #
  #     Zlib::GzipReader.open('hoge.gz') {|gz|
  #       print gz.read
  #     }
  #
  #     File.open('hoge.gz') do |f|
  #       gz = Zlib::GzipReader.new(f)
  #       print gz.read
  #       gz.close
  #     end
  #
  # ## Method Catalogue
  #
  # The following methods in Zlib::GzipReader are just like their counterparts in
  # IO, but they raise Zlib::Error or Zlib::GzipFile::Error exception if an error
  # was found in the gzip file.
  # *   #each
  # *   #each_line
  # *   #each_byte
  # *   #gets
  # *   #getc
  # *   #lineno
  # *   #lineno=
  # *   #read
  # *   #readchar
  # *   #readline
  # *   #readlines
  # *   #ungetc
  #
  # Be careful of the footer of the gzip file. A gzip file has the checksum of
  # pre-compressed data in its footer. GzipReader checks all uncompressed data
  # against that checksum at the following cases, and if it fails, raises
  # `Zlib::GzipFile::NoFooter`, `Zlib::GzipFile::CRCError`, or
  # `Zlib::GzipFile::LengthError` exception.
  #
  # *   When an reading request is received beyond the end of file (the end of
  #     compressed data). That is, when Zlib::GzipReader#read,
  #     Zlib::GzipReader#gets, or some other methods for reading returns nil.
  # *   When Zlib::GzipFile#close method is called after the object reaches the
  #     end of file.
  # *   When Zlib::GzipReader#unused method is called after the object reaches the
  #     end of file.
  #
  # The rest of the methods are adequately described in their own documentation.
  #
  class GzipReader < Zlib::GzipFile
    include Enumerable[String]

    def self.wrap: (IO io) -> instance
                 | (IO io) { (instance gz) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipReader.open(filename) {|gz| ... }
    # -->
    # Opens a file specified by `filename` as a gzipped file, and returns a
    # GzipReader object associated with that file.  Further details of this method
    # are in Zlib::GzipReader.new and ZLib::GzipFile.wrap.
    #
    def self.open: (String | _ToPath filename) -> instance
                 | (String | _ToPath filename) { (instance gz) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipReader.zcat(io, options = {}, &block) => nil
    #   - Zlib::GzipReader.zcat(io, options = {}) => string
    # -->
    # Decompresses all gzip data in the `io`, handling multiple gzip streams until
    # the end of the `io`.  There should not be any non-gzip data after the gzip
    # streams.
    #
    # If a block is given, it is yielded strings of uncompressed data, and the
    # method returns `nil`. If a block is not given, the method returns the
    # concatenation of all uncompressed data in all gzip streams.
    #
    def self.zcat: (IO io, **untyped) -> String
                 | (IO io, **untyped) { (String chunk) -> void } -> nil

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - each(*args)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def each: (*untyped) { (String) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - each_byte()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def each_byte: () { (String) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - each_char()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def each_char: () { (String) -> void } -> void

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # See Zlib::GzipReader documentation for a description.
    #
    def each_line: (*untyped) { (String) -> void } -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - eof()
    # -->
    # Returns `true` or `false` whether the stream has reached the end.
    #
    def eof: () -> bool

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Returns `true` or `false` whether the stream has reached the end.
    #
    def eof?: () -> bool

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - external_encoding()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def external_encoding: () -> Encoding

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - getbyte()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def getbyte: () -> Integer?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - getc()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def getc: () -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - gets(*args)
    # -->
    # See Zlib::GzipReader documentation for a description. However, note that this
    # method can return `nil` even if #eof? returns false, unlike the behavior of
    # File#gets.
    #
    def gets: (?String sep, ?Integer limit) -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - lineno()
    # -->
    # The line number of the last row read from this file.
    #
    def lineno: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - lineno=(p1)
    # -->
    # Specify line number of the last row read from this file.
    #
    def lineno=: (Integer arg0) -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - pos()
    # -->
    # Total number of output bytes output so far.
    #
    def pos: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - read(p1 = v1, p2 = v2)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def read: (?int? length, ?string outbuf) -> String?

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - readbyte()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def readbyte: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - readchar()
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def readchar: () -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - readline(*args)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def readline: (?String sep, ?Integer limit) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - readlines(*args)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def readlines: (?String sep, ?Integer limit) -> ::Array[String]

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - gzipreader.readpartial(maxlen [, outbuf]) => string, outbuf
    # -->
    # Reads at most *maxlen* bytes from the gzipped stream but it blocks only if
    # *gzipreader* has no data immediately available. If the optional *outbuf*
    # argument is present, it must reference a String, which will receive the data.
    # It raises `EOFError` on end of file.
    #
    def readpartial: (int maxlen, ?string outbuf) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - rewind()
    # -->
    # Resets the position of the file pointer to the point created the GzipReader
    # object.  The associated IO object needs to respond to the `seek` method.
    #
    def rewind: () -> Integer

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Total number of output bytes output so far.
    #
    def tell: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - ungetbyte(p1)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def ungetbyte: (String | Integer arg0) -> NilClass

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - ungetc(p1)
    # -->
    # See Zlib::GzipReader documentation for a description.
    #
    def ungetc: (String arg0) -> NilClass

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - unused()
    # -->
    # Returns the rest of the data which had read for parsing gzip format, or `nil`
    # if the whole gzip file is not parsed yet.
    #
    def unused: () -> String?

    private

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipReader.new(io, options = {})
    # -->
    # Creates a GzipReader object associated with `io`. The GzipReader object reads
    # gzipped data from `io`, and parses/decompresses it.  The `io` must have a
    # `read` method that behaves same as the IO#read.
    #
    # The `options` hash may be used to set the encoding of the data.
    # `:external_encoding`, `:internal_encoding` and `:encoding` may be set as in
    # IO::new.
    #
    # If the gzip file header is incorrect, raises an Zlib::GzipFile::Error
    # exception.
    #
    def initialize: (_Reader io, **untyped opts) -> void
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error
  #
  # When zlib returns a Z_VERSION_ERROR, usually if the zlib library version is
  # incompatible with the version assumed by the caller.
  #
  class VersionError < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error
  #
  # When zlib returns a Z_NEED_DICT if a preset dictionary is needed at this
  # point.
  #
  # Used by Zlib::Inflate.inflate and `Zlib.inflate`
  #
  class NeedDict < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Zlib::GzipWriter is a class for writing gzipped files.  GzipWriter should be
  # used with an instance of IO, or IO-like, object.
  #
  # Following two example generate the same result.
  #
  #     Zlib::GzipWriter.open('hoge.gz') do |gz|
  #       gz.write 'jugemu jugemu gokou no surikire...'
  #     end
  #
  #     File.open('hoge.gz', 'w') do |f|
  #       gz = Zlib::GzipWriter.new(f)
  #       gz.write 'jugemu jugemu gokou no surikire...'
  #       gz.close
  #     end
  #
  # To make like gzip(1) does, run following:
  #
  #     orig = 'hoge.txt'
  #     Zlib::GzipWriter.open('hoge.gz') do |gz|
  #       gz.mtime = File.mtime(orig)
  #       gz.orig_name = orig
  #       gz.write IO.binread(orig)
  #     end
  #
  # NOTE: Due to the limitation of Ruby's finalizer, you must explicitly close
  # GzipWriter objects by Zlib::GzipWriter#close etc.  Otherwise, GzipWriter will
  # be not able to write the gzip footer and will generate a broken gzip file.
  #
  class GzipWriter < Zlib::GzipFile
    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipWriter.open(filename, level=nil, strategy=nil) { |gz| ... }
    # -->
    # Opens a file specified by `filename` for writing gzip compressed data, and
    # returns a GzipWriter object associated with that file.  Further details of
    # this method are found in Zlib::GzipWriter.new and Zlib::GzipFile.wrap.
    #
    def self.open: (String filename) { (instance gz) -> void } -> instance

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - <<(p1)
    # -->
    # Same as IO.
    #
    def <<: (_ToS obj) -> self

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - comment=(p1)
    # -->
    # Specify the comment (`str`) in the gzip header.
    #
    def comment=: (String arg0) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - flush(flush=nil)
    # -->
    # Flushes all the internal buffers of the GzipWriter object.  The meaning of
    # `flush` is same as in Zlib::Deflate#deflate.  `Zlib::SYNC_FLUSH` is used if
    # `flush` is omitted.  It is no use giving flush `Zlib::NO_FLUSH`.
    #
    def flush: (?Integer flush) -> String

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - mtime=(p1)
    # -->
    # Specify the modification time (`mtime`) in the gzip header. Using an Integer.
    #
    # Setting the mtime in the gzip header does not effect the mtime of the file
    # generated. Different utilities that expand the gzipped files may use the mtime
    # header. For example the gunzip utility can use the `-N` flag which will set
    # the resultant file's mtime to the value in the header. By default many tools
    # will set the mtime of the expanded file to the mtime of the gzipped file, not
    # the mtime in the header.
    #
    # If you do not set an mtime, the default value will be the time when
    # compression started. Setting a value of 0 indicates no time stamp is
    # available.
    #
    def mtime=: (string | _ToPath | IO file_name) -> Time

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - orig_name=(p1)
    # -->
    # Specify the original name (`str`) in the gzip header.
    #
    def orig_name=: (String arg0) -> void

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - pos()
    # -->
    # Total number of input bytes read so far.
    #
    def pos: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - print(*args)
    # -->
    # Same as IO.
    #
    def print: (*untyped arg0) -> NilClass

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - printf(*args)
    # -->
    # Same as IO.
    #
    def printf: (String format_string, *untyped arg0) -> NilClass

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - putc(p1)
    # -->
    # Same as IO.
    #
    def putc: (Numeric | String arg0) -> untyped

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - puts(*args)
    # -->
    # Same as IO.
    #
    def puts: (*untyped arg0) -> NilClass

    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Total number of input bytes read so far.
    #
    def tell: () -> Integer

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - write(*args)
    # -->
    # Same as IO.
    #
    def write: (*_ToS string) -> Integer

    private

    # <!--
    #   rdoc-file=ext/zlib/zlib.c
    #   - Zlib::GzipWriter.new(io, level = nil, strategy = nil, options = {})
    # -->
    # Creates a GzipWriter object associated with `io`. `level` and `strategy`
    # should be the same as the arguments of Zlib::Deflate.new.  The GzipWriter
    # object writes gzipped data to `io`.  `io` must respond to the `write` method
    # that behaves the same as IO#write.
    #
    # The `options` hash may be used to set the encoding of the data.
    # `:external_encoding`, `:internal_encoding` and `:encoding` may be set as in
    # IO::new.
    #
    def initialize: (_Writer io, Integer level, Integer strategy, **untyped opts) -> void
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # Subclass of Zlib::Error
  #
  # When zlib returns a Z_MEM_ERROR, usually if there was not enough memory.
  #
  class MemError < Zlib::Error
  end
end
%a{annotate:rdoc:skip}
module Zlib
  %a{annotate:rdoc:skip}
  class GzipFile
    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Raised when gzip file footer is not found.
    #
    class NoFooter < Zlib::GzipFile::Error
    end
  end
end
%a{annotate:rdoc:skip}
module Zlib
  %a{annotate:rdoc:skip}
  class GzipFile
    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Raised when the CRC checksum recorded in gzip file footer is not equivalent to
    # the CRC checksum of the actual uncompressed data.
    #
    class CRCError < Zlib::GzipFile::Error
    end
  end
end
%a{annotate:rdoc:skip}
module Zlib
  %a{annotate:rdoc:skip}
  class GzipFile
    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Raised when the data length recorded in the gzip file footer is not equivalent
    # to the length of the actual uncompressed data.
    #
    class LengthError < Zlib::GzipFile::Error
    end
  end
end
%a{annotate:rdoc:skip}
module Zlib
  %a{annotate:rdoc:skip}
  class GzipFile
    # <!-- rdoc-file=ext/zlib/zlib.c -->
    # Base class of errors that occur when processing GZIP files.
    #
    class Error < Zlib::Error
      # <!-- rdoc-file=ext/zlib/zlib.c -->
      # input gzipped string
      #
      def input: () -> String

      # <!--
      #   rdoc-file=ext/zlib/zlib.c
      #   - inspect()
      # -->
      # Constructs a String of the GzipFile Error
      #
      def inspect: () -> String
    end
  end
end
%a{annotate:rdoc:skip}
module Zlib
  # <!-- rdoc-file=ext/zlib/zlib.c -->
  # The superclass for all exceptions raised by Ruby/zlib.
  #
  # The following exceptions are defined as subclasses of Zlib::Error. These
  # exceptions are raised when zlib library functions return with an error status.
  #
  # *   Zlib::StreamEnd
  # *   Zlib::NeedDict
  # *   Zlib::DataError
  # *   Zlib::StreamError
  # *   Zlib::MemError
  # *   Zlib::BufError
  # *   Zlib::VersionError
  # *   Zlib::InProgressError
  #
  class Error < StandardError
  end
end
%a{annotate:rdoc:skip}
class Integer
  # <!--
  #   rdoc-file=lib/prime.rb
  #   - each_prime(ubound) { |prime| ... }
  # -->
  # Iterates the given block over all prime numbers.
  #
  # See `Prime`#each for more details.
  #
  def self.each_prime: (Integer) { (Integer) -> void } -> void

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - from_prime_division(pd)
  # -->
  # Re-composes a prime factorization and returns the product.
  #
  # See Prime#int_from_prime_division for more details.
  #
  def self.from_prime_division: (Array[[ String ]]) -> Integer

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime_division(generator = Prime::Generator23.new)
  # -->
  # Returns the factorization of `self`.
  #
  # See Prime#prime_division for more details.
  #
  def prime_division: (?Prime::PseudoPrimeGenerator) -> Array[[ Integer, Integer ]]

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime?()
  # -->
  # Returns true if `self` is a prime number, else returns false. Not recommended
  # for very big integers (> 10**23).
  #
  def prime?: () -> bool
end
# <!-- rdoc-file=lib/prime.rb -->
# The set of all prime numbers.
#
# ## Example
#
#     Prime.each(100) do |prime|
#       p prime  #=> 2, 3, 5, 7, 11, ...., 97
#     end
#
# Prime is Enumerable:
#
#     Prime.first 5 # => [2, 3, 5, 7, 11]
#
# ## Retrieving the instance
#
# For convenience, each instance method of `Prime`.instance can be accessed as a
# class method of `Prime`.
#
# e.g.
#     Prime.instance.prime?(2)  #=> true
#     Prime.prime?(2)           #=> true
#
# ## Generators
#
# A "generator" provides an implementation of enumerating pseudo-prime numbers
# and it remembers the position of enumeration and upper bound. Furthermore, it
# is an external iterator of prime enumeration which is compatible with an
# Enumerator.
#
# `Prime`::`PseudoPrimeGenerator` is the base class for generators. There are
# few implementations of generator.
#
# `Prime`::`EratosthenesGenerator`
# :   Uses Eratosthenes' sieve.
# `Prime`::`TrialDivisionGenerator`
# :   Uses the trial division method.
# `Prime`::`Generator23`
# :   Generates all positive integers which are not divisible by either 2 or 3.
#     This sequence is very bad as a pseudo-prime sequence. But this is faster
#     and uses much less memory than the other generators. So, it is suitable
#     for factorizing an integer which is not large but has many prime factors.
#     e.g. for Prime#prime? .
#
class Prime
  include Singleton

  include Enumerable[Integer]

  extend Enumerable[Integer]

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - each(ubound = nil, generator = EratosthenesGenerator.new, &block)
  # -->
  # Iterates the given block over all prime numbers.
  #
  # ## Parameters
  #
  # `ubound`
  # :   Optional. An arbitrary positive number. The upper bound of enumeration.
  #     The method enumerates prime numbers infinitely if `ubound` is nil.
  # `generator`
  # :   Optional. An implementation of pseudo-prime generator.
  #
  #
  # ## Return value
  #
  # An evaluated value of the given block at the last time. Or an enumerator which
  # is compatible to an `Enumerator` if no block given.
  #
  # ## Description
  #
  # Calls `block` once for each prime number, passing the prime as a parameter.
  #
  # `ubound`
  # :   Upper bound of prime numbers. The iterator stops after it yields all prime
  #     numbers p <= `ubound`.
  #
  def self.each: (?Integer? ubound, ?PseudoPrimeGenerator generator) { (Integer) -> void } -> void
                | (?Integer? ubound, ?PseudoPrimeGenerator generator) -> PseudoPrimeGenerator

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - each(ubound = nil, generator = EratosthenesGenerator.new, &block)
  # -->
  # Iterates the given block over all prime numbers.
  #
  # ## Parameters
  #
  # `ubound`
  # :   Optional. An arbitrary positive number. The upper bound of enumeration.
  #     The method enumerates prime numbers infinitely if `ubound` is nil.
  # `generator`
  # :   Optional. An implementation of pseudo-prime generator.
  #
  #
  # ## Return value
  #
  # An evaluated value of the given block at the last time. Or an enumerator which
  # is compatible to an `Enumerator` if no block given.
  #
  # ## Description
  #
  # Calls `block` once for each prime number, passing the prime as a parameter.
  #
  # `ubound`
  # :   Upper bound of prime numbers. The iterator stops after it yields all prime
  #     numbers p <= `ubound`.
  #
  def each: (?Integer? ubound, ?PseudoPrimeGenerator generator) { (Integer) -> void } -> void
          | (?Integer? ubound, ?PseudoPrimeGenerator generator) -> PseudoPrimeGenerator

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - int_from_prime_division(pd)
  # -->
  # Re-composes a prime factorization and returns the product.
  #
  # For the decomposition:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]],
  #
  # it returns:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n.
  #
  # ## Parameters
  # `pd`
  # :   Array of pairs of integers. Each pair consists of a prime number -- a
  #     prime factor -- and a natural number -- its exponent (multiplicity).
  #
  #
  # ## Example
  #     Prime.int_from_prime_division([[3, 2], [5, 1]])  #=> 45
  #     3**2 * 5                                         #=> 45
  #
  def self.int_from_prime_division: (Array[[ Integer, Integer ]]) -> (Integer | Rational)

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - int_from_prime_division(pd)
  # -->
  # Re-composes a prime factorization and returns the product.
  #
  # For the decomposition:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]],
  #
  # it returns:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n.
  #
  # ## Parameters
  # `pd`
  # :   Array of pairs of integers. Each pair consists of a prime number -- a
  #     prime factor -- and a natural number -- its exponent (multiplicity).
  #
  #
  # ## Example
  #     Prime.int_from_prime_division([[3, 2], [5, 1]])  #=> 45
  #     3**2 * 5                                         #=> 45
  #
  def int_from_prime_division: (Array[[ Integer, Integer ]]) -> (Integer | Rational)

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime?(value, generator = Prime::Generator23.new)
  # -->
  # Returns true if `value` is a prime number, else returns false. Integer#prime?
  # is much more performant.
  #
  # ## Parameters
  #
  # `value`
  # :   an arbitrary integer to be checked.
  # `generator`
  # :   optional. A pseudo-prime generator.
  #
  def self.prime?: (Integer value, ?PseudoPrimeGenerator generator) -> bool

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime?(value, generator = Prime::Generator23.new)
  # -->
  # Returns true if `value` is a prime number, else returns false. Integer#prime?
  # is much more performant.
  #
  # ## Parameters
  #
  # `value`
  # :   an arbitrary integer to be checked.
  # `generator`
  # :   optional. A pseudo-prime generator.
  #
  def prime?: (Integer value, ?PseudoPrimeGenerator generator) -> bool

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime_division(value, generator = Prime::Generator23.new)
  # -->
  # Returns the factorization of `value`.
  #
  # For an arbitrary integer:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n,
  #
  # prime_division returns an array of pairs of integers:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]].
  #
  # Each pair consists of a prime number -- a prime factor -- and a natural number
  # -- its exponent (multiplicity).
  #
  # ## Parameters
  # `value`
  # :   An arbitrary integer.
  # `generator`
  # :   Optional. A pseudo-prime generator. `generator`.succ must return the next
  #     pseudo-prime number in ascending order. It must generate all prime
  #     numbers, but may also generate non-prime numbers, too.
  #
  #
  # ### Exceptions
  # `ZeroDivisionError`
  # :   when `value` is zero.
  #
  #
  # ## Example
  #
  #     Prime.prime_division(45)  #=> [[3, 2], [5, 1]]
  #     3**2 * 5                  #=> 45
  #
  def self.prime_division: (Integer, ?PseudoPrimeGenerator generator) -> Array[[ Integer, Integer ]]

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime_division(value, generator = Prime::Generator23.new)
  # -->
  # Returns the factorization of `value`.
  #
  # For an arbitrary integer:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n,
  #
  # prime_division returns an array of pairs of integers:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]].
  #
  # Each pair consists of a prime number -- a prime factor -- and a natural number
  # -- its exponent (multiplicity).
  #
  # ## Parameters
  # `value`
  # :   An arbitrary integer.
  # `generator`
  # :   Optional. A pseudo-prime generator. `generator`.succ must return the next
  #     pseudo-prime number in ascending order. It must generate all prime
  #     numbers, but may also generate non-prime numbers, too.
  #
  #
  # ### Exceptions
  # `ZeroDivisionError`
  # :   when `value` is zero.
  #
  #
  # ## Example
  #
  #     Prime.prime_division(45)  #=> [[3, 2], [5, 1]]
  #     3**2 * 5                  #=> 45
  #
  def prime_division: (Integer, ?PseudoPrimeGenerator generator) -> Array[[ Integer, Integer ]]

  # Returns the singleton instance.
  #
  def self.instance: () -> Prime

  # <!-- rdoc-file=lib/prime.rb -->
  # An abstract class for enumerating pseudo-prime numbers.
  #
  # Concrete subclasses should override succ, next, rewind.
  #
  class PseudoPrimeGenerator
    # <!--
    #   rdoc-file=lib/prime.rb
    #   - new(ubound = nil)
    # -->
    #
    def initialize: (?Integer?) -> void

    include Enumerable[Integer]

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - upper_bound()
    # -->
    # ----
    # <!--
    #   rdoc-file=lib/prime.rb
    #   - upper_bound=(ubound)
    # -->
    #
    attr_accessor upper_bound(): Integer?

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - each() { |prime| ... }
    # -->
    # Iterates the given block for each prime number.
    #
    def each: () { (Integer) -> void } -> void

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - next()
    # -->
    # alias of `succ`.
    #
    def next: () -> Integer

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - rewind()
    # -->
    # Rewinds the internal position for enumeration.
    #
    # See `Enumerator`#rewind.
    #
    def rewind: () -> void

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - size()
    # -->
    #
    def size: () -> Float

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - succ()
    # -->
    # returns the next pseudo-prime number, and move the internal position forward.
    #
    # `PseudoPrimeGenerator`#succ raises `NotImplementedError`.
    #
    def succ: () -> Integer
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # An implementation of `PseudoPrimeGenerator`.
  #
  # Uses `EratosthenesSieve`.
  #
  class EratosthenesGenerator < PseudoPrimeGenerator
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # An implementation of `PseudoPrimeGenerator` which uses a prime table generated
  # by trial division.
  #
  class TrialDivisionGenerator < PseudoPrimeGenerator
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # Generates all integers which are greater than 2 and are not divisible by
  # either 2 or 3.
  #
  # This is a pseudo-prime generator, suitable on checking primality of an integer
  # by brute force method.
  #
  class Generator23 < PseudoPrimeGenerator
  end
end
