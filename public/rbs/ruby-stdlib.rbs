# <!-- rdoc-file=thread.c -->
# ThreadGroup provides a means of keeping track of a number of threads as a
# group.
#
# A given Thread object can only belong to one ThreadGroup at a time; adding a
# thread to a new group will remove it from any previous group.
#
# Newly created threads belong to the same group as the thread from which they
# were created.
#
class ThreadGroup < Object
  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.add(thread)   -> thgrp
  # -->
  # Adds the given `thread` to this group, removing it from any other group to
  # which it may have previously been a member.
  #
  #     puts "Initial group is #{ThreadGroup::Default.list}"
  #     tg = ThreadGroup.new
  #     t1 = Thread.new { sleep }
  #     t2 = Thread.new { sleep }
  #     puts "t1 is #{t1}"
  #     puts "t2 is #{t2}"
  #     tg.add(t1)
  #     puts "Initial group now #{ThreadGroup::Default.list}"
  #     puts "tg group now #{tg.list}"
  #
  # This will produce:
  #
  #     Initial group is #<Thread:0x401bdf4c>
  #     t1 is #<Thread:0x401b3c90>
  #     t2 is #<Thread:0x401b3c18>
  #     Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>
  #     tg group now #<Thread:0x401b3c90>
  #
  def add: (Thread thread) -> ThreadGroup

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclose   -> thgrp
  # -->
  # Prevents threads from being added to or removed from the receiving
  # ThreadGroup.
  #
  # New threads can still be started in an enclosed ThreadGroup.
  #
  #     ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>
  #     thr = Thread.new { Thread.stop }    #=> #<Thread:0x402a7210 sleep>
  #     tg = ThreadGroup.new                #=> #<ThreadGroup:0x402752d4>
  #     tg.add thr
  #     #=> ThreadError: can't move from the enclosed thread group
  #
  def enclose: () -> self

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.enclosed?   -> true or false
  # -->
  # Returns `true` if the `thgrp` is enclosed. See also ThreadGroup#enclose.
  #
  def enclosed?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thgrp.list   -> array
  # -->
  # Returns an array of all existing Thread objects that belong to this group.
  #
  #     ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]
  #
  def list: () -> ::Array[Thread]
end

# <!-- rdoc-file=thread.c -->
# The default ThreadGroup created when Ruby starts; all Threads belong to it by
# default.
#
ThreadGroup::Default: ThreadGroup

# <!-- rdoc-file=ractor.rb -->
# Ractor is a Actor-model abstraction for Ruby that provides thread-safe
# parallel execution.
#
# Ractor.new can make a new Ractor, and it will run in parallel.
#
#     # The simplest ractor
#     r = Ractor.new {puts "I am in Ractor!"}
#     r.take # wait for it to finish
#     # here "I am in Ractor!" would be printed
#
# Ractors do not share usual objects, so the same kinds of thread-safety
# concerns such as data-race, race-conditions are not available on multi-ractor
# programming.
#
# To achieve this, ractors severely limit object sharing between different
# ractors. For example, unlike threads, ractors can't access each other's
# objects, nor any objects through variables of the outer scope.
#
#     a = 1
#     r = Ractor.new {puts "I am in Ractor! a=#{a}"}
#     # fails immediately with
#     # ArgumentError (can not isolate a Proc because it accesses outer variables (a).)
#
# On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is
# held per ractor, so ractors are performed in parallel without locking each
# other.
#
# Instead of accessing the shared state, the objects should be passed to and
# from ractors via sending and receiving objects as messages.
#
#     a = 1
#     r = Ractor.new do
#       a_in_ractor = receive # receive blocks till somebody will pass message
#       puts "I am in Ractor! a=#{a_in_ractor}"
#     end
#     r.send(a)  # pass it
#     r.take
#     # here "I am in Ractor! a=1" would be printed
#
# There are two pairs of methods for sending/receiving messages:
#
# *   Ractor#send and Ractor.receive for when the *sender* knows the receiver
#     (push);
# *   Ractor.yield and Ractor#take for when the *receiver* knows the sender
#     (pull);
#
#
# In addition to that, an argument to Ractor.new would be passed to block and
# available there as if received by Ractor.receive, and the last block value
# would be sent outside of the ractor as if sent by Ractor.yield.
#
# A little demonstration on a classic ping-pong:
#
#     server = Ractor.new do
#       puts "Server starts: #{self.inspect}"
#       puts "Server sends: ping"
#       Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested
#       received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent
#       puts "Server received: #{received}"
#     end
#
#     client = Ractor.new(server) do |srv|        # The server is sent inside client, and available as srv
#       puts "Client starts: #{self.inspect}"
#       received = srv.take                       # The Client takes a message specifically from the server
#       puts "Client received from " \
#            "#{srv.inspect}: #{received}"
#       puts "Client sends to " \
#            "#{srv.inspect}: pong"
#       srv.send 'pong'                           # The client sends a message specifically to the server
#     end
#
#     [client, server].each(&:take)               # Wait till they both finish
#
# This will output:
#
#     Server starts: #<Ractor:#2 test.rb:1 running>
#     Server sends: ping
#     Client starts: #<Ractor:#3 test.rb:8 running>
#     Client received from #<Ractor:#2 rac.rb:1 blocking>: ping
#     Client sends to #<Ractor:#2 rac.rb:1 blocking>: pong
#     Server received: pong
#
# It is said that Ractor receives messages via the *incoming port*, and sends
# them to the *outgoing port*. Either one can be disabled with
# Ractor#close_incoming and Ractor#close_outgoing respectively. If a ractor
# terminated, its ports will be closed automatically.
#
# ## Shareable and unshareable objects
#
# When the object is sent to and from the ractor, it is important to understand
# whether the object is shareable or unshareable. Most of objects are
# unshareable objects.
#
# Shareable objects are basically those which can be used by several threads
# without compromising thread-safety; e.g. immutable ones. Ractor.shareable?
# allows to check this, and Ractor.make_shareable tries to make object shareable
# if it is not.
#
#     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are
#     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
#     Ractor.shareable?('foo'.freeze) #=> true
#
#     ary = ['hello', 'world']
#     ary.frozen?                 #=> false
#     ary[0].frozen?              #=> false
#     Ractor.make_shareable(ary)
#     ary.frozen?                 #=> true
#     ary[0].frozen?              #=> true
#     ary[1].frozen?              #=> true
#
# When a shareable object is sent (via #send or Ractor.yield), no additional
# processing happens, and it just becomes usable by both ractors. When an
# unshareable object is sent, it can be either *copied* or *moved*. The first is
# the default, and it makes the object's full copy by deep cloning of
# non-shareable parts of its structure.
#
#     data = ['foo', 'bar'.freeze]
#     r = Ractor.new do
#       data2 = Ractor.receive
#       puts "In ractor: #{data2.object_id}, #{data2[0].object_id}, #{data2[1].object_id}"
#     end
#     r.send(data)
#     r.take
#     puts "Outside  : #{data.object_id}, #{data[0].object_id}, #{data[1].object_id}"
#
# This will output:
#
#     In ractor: 340, 360, 320
#     Outside  : 380, 400, 320
#
# (Note that object id of both array and non-frozen string inside array have
# changed inside the ractor, showing it is different objects. But the second
# array's element, which is a shareable frozen string, has the same object_id.)
#
# Deep cloning of the objects may be slow, and sometimes impossible.
# Alternatively, `move: true` may be used on sending. This will *move* the
# object to the receiving ractor, making it inaccessible for a sending ractor.
#
#     data = ['foo', 'bar']
#     r = Ractor.new do
#       data_in_ractor = Ractor.receive
#       puts "In ractor: #{data_in_ractor.object_id}, #{data_in_ractor[0].object_id}"
#     end
#     r.send(data, move: true)
#     r.take
#     puts "Outside: moved? #{Ractor::MovedObject === data}"
#     puts "Outside: #{data.inspect}"
#
# This will output:
#
#     In ractor: 100, 120
#     Outside: moved? true
#     test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError)
#
# Notice that even `inspect` (and more basic methods like `__id__`) is
# inaccessible on a moved object.
#
# Besides frozen objects, there are shareable objects. Class and Module objects
# are shareable so the Class/Module definitions are shared between ractors.
# Ractor objects are also shareable objects. All operations for the shareable
# mutable objects are thread-safe, so the thread-safety property will be kept.
# We can not define mutable shareable objects in Ruby, but C extensions can
# introduce them.
#
# It is prohibited to access instance variables of mutable shareable objects
# (especially Modules and classes) from ractors other than main:
#
#     class C
#       class << self
#         attr_accessor :tricky
#       end
#     end
#
#     C.tricky = 'test'
#
#     r = Ractor.new(C) do |cls|
#       puts "I see #{cls}"
#       puts "I can't see #{cls.tricky}"
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# Ractors can access constants if they are shareable. The main Ractor is the
# only one that can access non-shareable constants.
#
#     GOOD = 'good'.freeze
#     BAD = 'bad'
#
#     r = Ractor.new do
#       puts "GOOD=#{GOOD}"
#       puts "BAD=#{BAD}"
#     end
#     r.take
#     # GOOD=good
#     # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError)
#
#     # Consider the same C class from above
#
#     r = Ractor.new do
#       puts "I see #{C}"
#       puts "I can't see #{C.tricky}"
#     end
#     r.take
#     # I see C
#     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)
#
# See also the description of `# shareable_constant_value` pragma in [Comments
# syntax](rdoc-ref:syntax/comments.rdoc) explanation.
#
# ## Ractors vs threads
#
# Each ractor creates its own thread. New threads can be created from inside
# ractor (and, on CRuby, sharing GVL with other threads of this ractor).
#
#     r = Ractor.new do
#       a = 1
#       Thread.new {puts "Thread in ractor: a=#{a}"}.join
#     end
#     r.take
#     # Here "Thread in ractor: a=1" will be printed
#
# ## Note on code examples
#
# In examples below, sometimes we use the following method to wait till ractors
# that are not currently blocked will finish (or process till next blocking)
# method.
#
#     def wait
#       sleep(0.1)
#     end
#
# It is **only for demonstration purposes** and shouldn't be used in a real
# code. Most of the times, just #take is used to wait till ractor will finish.
#
# ## Reference
#
# See [Ractor design doc](rdoc-ref:ractor.md) for more details.
#
class Ractor
  # <!--
  #   rdoc-file=ractor.rb
  #   - count()
  # -->
  # Returns total count of Ractors currently running.
  #
  #     Ractor.count                   #=> 1
  #     r = Ractor.new(name: 'example') { Ractor.yield(1) }
  #     Ractor.count                   #=> 2 (main + example ractor)
  #     r.take                         # wait for Ractor.yield(1)
  #     r.take                         # wait till r will finish
  #     Ractor.count                   #=> 1
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=ractor.rb
  #   - current()
  # -->
  # Returns the currently executing Ractor.
  #
  #     Ractor.current #=> #<Ractor:#1 running>
  #
  def self.current: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - main()
  # -->
  # returns main ractor
  #
  def self.main: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.make_shareable(obj, copy: false) -> shareable_obj
  # -->
  # Make `obj` shareable between ractors.
  #
  # `obj` and all the objects it refers to will be frozen, unless they are already
  # shareable.
  #
  # If `copy` keyword is `true`, the method will copy objects before freezing them
  # This is safer option but it can take be slower.
  #
  # Note that the specification and implementation of this method are not mature
  # and may be changed in the future.
  #
  #     obj = ['test']
  #     Ractor.shareable?(obj)     #=> false
  #     Ractor.make_shareable(obj) #=> ["test"]
  #     Ractor.shareable?(obj)     #=> true
  #     obj.frozen?                #=> true
  #     obj[0].frozen?             #=> true
  #
  #     # Copy vs non-copy versions:
  #     obj1 = ['test']
  #     obj1s = Ractor.make_shareable(obj1)
  #     obj1.frozen?                        #=> true
  #     obj1s.object_id == obj1.object_id   #=> true
  #     obj2 = ['test']
  #     obj2s = Ractor.make_shareable(obj2, copy: true)
  #     obj2.frozen?                        #=> false
  #     obj2s.frozen?                       #=> true
  #     obj2s.object_id == obj2.object_id   #=> false
  #     obj2s[0].object_id == obj2[0].object_id #=> false
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.make_shareable: [T] (T obj, ?copy: boolish) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.new(*args, name: nil) {|*args| block } -> ractor
  # -->
  # Create a new Ractor with args and a block.
  #
  # A block (Proc) will be isolated (can't access to outer variables). `self`
  # inside the block will refer to the current Ractor.
  #
  #     r = Ractor.new { puts "Hi, I am #{self.inspect}" }
  #     r.take
  #     # Prints "Hi, I am #<Ractor:#2 test.rb:1 running>"
  #
  # `args` passed to the method would be propagated to block args by the same
  # rules as objects passed through #send/Ractor.receive: if `args` are not
  # shareable, they will be copied (via deep cloning, which might be inefficient).
  #
  #     arg = [1, 2, 3]
  #     puts "Passing: #{arg} (##{arg.object_id})"
  #     r = Ractor.new(arg) {|received_arg|
  #       puts "Received: #{received_arg} (##{received_arg.object_id})"
  #     }
  #     r.take
  #     # Prints:
  #     #   Passing: [1, 2, 3] (#280)
  #     #   Received: [1, 2, 3] (#300)
  #
  # Ractor's `name` can be set for debugging purposes:
  #
  #     r = Ractor.new(name: 'my ractor') {}
  #     p r
  #     #=> #<Ractor:#3 my ractor test.rb:1 terminated>
  #
  def self.new: (*untyped args, ?name: string) { (*untyped) -> untyped } -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive -> msg
  # -->
  # Receive an incoming message from the current Ractor's incoming port's queue,
  # which was sent there by #send.
  #
  #     r = Ractor.new do
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # Here will be printed: "Received: message1"
  #
  # Alternatively, private instance method `receive` may be used:
  #
  #     r = Ractor.new do
  #       v1 = receive
  #       puts "Received: #{v1}"
  #     end
  #     r.send('message1')
  #     r.take
  #     # Here will be printed: "Received: message1"
  #
  # The method blocks if the queue is empty.
  #
  #     r = Ractor.new do
  #       puts "Before first receive"
  #       v1 = Ractor.receive
  #       puts "Received: #{v1}"
  #       v2 = Ractor.receive
  #       puts "Received: #{v2}"
  #     end
  #     wait
  #     puts "Still not received"
  #     r.send('message1')
  #     wait
  #     puts "Still received only one"
  #     r.send('message2')
  #     r.take
  #
  # Output:
  #
  #     Before first receive
  #     Still not received
  #     Received: message1
  #     Still received only one
  #     Received: message2
  #
  # If close_incoming was called on the ractor, the method raises
  # Ractor::ClosedError if there are no more messages in incoming queue:
  #
  #     Ractor.new do
  #       close_incoming
  #       receive
  #     end
  #     wait
  #     # in `receive': The incoming port is already closed => #<Ractor:#2 test.rb:1 running> (Ractor::ClosedError)
  #
  def self.receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.receive_if {|msg| block } -> msg
  # -->
  # Receive only a specific message.
  #
  # Instead of Ractor.receive, Ractor.receive_if can provide a pattern by a block
  # and you can choose the receiving message.
  #
  #     r = Ractor.new do
  #       p Ractor.receive_if{|msg| msg.match?(/foo/)} #=> "foo3"
  #       p Ractor.receive_if{|msg| msg.match?(/bar/)} #=> "bar1"
  #       p Ractor.receive_if{|msg| msg.match?(/baz/)} #=> "baz2"
  #     end
  #     r << "bar1"
  #     r << "baz2"
  #     r << "foo3"
  #     r.take
  #
  # This will output:
  #
  #     foo3
  #     bar1
  #     baz2
  #
  # If the block returns a truthy value, the message will be removed from the
  # incoming queue and returned. Otherwise, the message remains in the incoming
  # queue and the following received messages are checked by the given block.
  #
  # If there are no messages left in the incoming queue, the method will block
  # until new messages arrive.
  #
  # If the block is escaped by break/return/exception/throw, the message is
  # removed from the incoming queue as if a truthy value had been returned.
  #
  #     r = Ractor.new do
  #       val = Ractor.receive_if{|msg| msg.is_a?(Array)}
  #       puts "Received successfully: #{val}"
  #     end
  #
  #     r.send(1)
  #     r.send('test')
  #     wait
  #     puts "2 non-matching sent, nothing received"
  #     r.send([1, 2, 3])
  #     wait
  #
  # Prints:
  #
  #     2 non-matching sent, nothing received
  #     Received successfully: [1, 2, 3]
  #
  # Note that you can not call receive/receive_if in the given block recursively.
  # It means that you should not do any tasks in the block.
  #
  #     Ractor.current << true
  #     Ractor.receive_if{|msg| Ractor.receive}
  #     #=> `receive': can not call receive/receive_if recursively (Ractor::Error)
  #
  def self.receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias self.recv self.receive

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.select(*ractors, [yield_value:, move: false]) -> [ractor or symbol, obj]
  # -->
  # Waits for the first ractor to have something in its outgoing port, reads from
  # this ractor, and returns that ractor and the object received.
  #
  #     r1 = Ractor.new {Ractor.yield 'from 1'}
  #     r2 = Ractor.new {Ractor.yield 'from 2'}
  #
  #     r, obj = Ractor.select(r1, r2)
  #
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Prints: received "from 1" from #<Ractor:#2 test.rb:1 running>
  #
  # If one of the given ractors is the current ractor, and it would be selected,
  # `r` will contain `:receive` symbol instead of the ractor object.
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       main.send 'to main'
  #       Ractor.yield 'from 1'
  #     end
  #     r2 = Ractor.new do
  #       Ractor.yield 'from 2'
  #     end
  #
  #     r, obj = Ractor.select(r1, r2, Ractor.current)
  #     puts "received #{obj.inspect} from #{r.inspect}"
  #     # Prints: received "to main" from :receive
  #
  # If `yield_value` is provided, that value may be yielded if another Ractor is
  # calling #take. In this case, the pair `[:yield, nil]` would be returned:
  #
  #     r1 = Ractor.new(Ractor.current) do |main|
  #       puts "Received from main: #{main.take}"
  #     end
  #
  #     puts "Trying to select"
  #     r, obj = Ractor.select(r1, Ractor.current, yield_value: 123)
  #     wait
  #     puts "Received #{obj.inspect} from #{r.inspect}"
  #
  # This will print:
  #
  #     Trying to select
  #     Received from main: 123
  #     Received nil from :yield
  #
  # `move` boolean flag defines whether yielded value should be copied (default)
  # or moved.
  #
  def self.select: (*Ractor ractors, ?move: boolish, ?yield_value: untyped) -> [ Ractor | Symbol, untyped ]

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.shareable?(obj) -> true | false
  # -->
  # Checks if the object is shareable by ractors.
  #
  #     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are frozen
  #     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
  #     Ractor.shareable?('foo'.freeze) #=> true
  #
  # See also the "Shareable and unshareable objects" section in the Ractor class
  # docs.
  #
  def self.shareable?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - Ractor.yield(msg, move: false) -> nil
  # -->
  # Send a message to the current ractor's outgoing port to be consumed by #take.
  #
  #     r = Ractor.new {Ractor.yield 'Hello from ractor'}
  #     puts r.take
  #     # Prints: "Hello from ractor"
  #
  # The method is blocking, and will return only when somebody consumes the sent
  # message.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'Hello from ractor'
  #       puts "Ractor: after yield"
  #     end
  #     wait
  #     puts "Still not taken"
  #     puts r.take
  #
  # This will print:
  #
  #     Still not taken
  #     Hello from ractor
  #     Ractor: after yield
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise:
  #
  #     r = Ractor.new do
  #       close_outgoing
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     wait
  #     # `yield': The outgoing-port is already closed (Ractor::ClosedError)
  #
  # The meaning of `move` argument is the same as for #send.
  #
  def self.yield: (untyped obj, ?move: boolish) -> untyped

  public

  # <!--
  #   rdoc-file=ractor.rb
  #   - <<(obj, move: false)
  # -->
  #
  alias << send

  # <!--
  #   rdoc-file=ractor.rb
  #   - [](sym)
  # -->
  # get a value from ractor-local storage
  #
  def []: (Symbol | String sym) -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - []=(sym, val)
  # -->
  # set a value in ractor-local storage
  #
  def []=: [T] (Symbol | String sym, T val) -> T

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_incoming -> true | false
  # -->
  # Closes the incoming port and returns its previous state. All further attempts
  # to Ractor.receive in the ractor, and #send to the ractor will fail with
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_incoming  #=> false
  #     r.close_incoming  #=> true
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  def close_incoming: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.close_outgoing -> true | false
  # -->
  # Closes the outgoing port and returns its previous state. All further attempts
  # to Ractor.yield in the ractor, and #take from the ractor will fail with
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {sleep(500)}
  #     r.close_outgoing  #=> false
  #     r.close_outgoing  #=> true
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #
  def close_outgoing: () -> bool

  # <!--
  #   rdoc-file=ractor.rb
  #   - inspect()
  # -->
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ractor.rb
  #   - name()
  # -->
  # The name set in Ractor.new, or `nil`.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.send(msg, move: false) -> self
  # -->
  # Send a message to a Ractor's incoming queue to be consumed by Ractor.receive.
  #
  #     r = Ractor.new do
  #       value = Ractor.receive
  #       puts "Received #{value}"
  #     end
  #     r.send 'message'
  #     # Prints: "Received: message"
  #
  # The method is non-blocking (will return immediately even if the ractor is not
  # ready to receive anything):
  #
  #     r = Ractor.new {sleep(5)}
  #     r.send('test')
  #     puts "Sent successfully"
  #     # Prints: "Sent successfully" immediately
  #
  # Attempt to send to ractor which already finished its execution will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new {}
  #     r.take
  #     p r
  #     # "#<Ractor:#6 (irb):23 terminated>"
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #
  # If close_incoming was called on the ractor, the method also raises
  # Ractor::ClosedError.
  #
  #     r =  Ractor.new do
  #       sleep(500)
  #       receive
  #     end
  #     r.close_incoming
  #     r.send('test')
  #     # Ractor::ClosedError (The incoming-port is already closed)
  #     # The error would be raised immediately, not when ractor will try to receive
  #
  # If the `obj` is unshareable, by default it would be copied into ractor by deep
  # cloning. If the `move: true` is passed, object is *moved* into ractor and
  # becomes inaccessible to sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     msg = 'message'
  #     r.send(msg, move: true)
  #     r.take
  #     p msg
  #
  # This prints:
  #
  #     Received: message
  #     in `p': undefined method `inspect' for #<Ractor::MovedObject:0x000055c99b9b69b8>
  #
  # All references to the object and its parts will become invalid in sender.
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'
  #     ary = [s]
  #     copy = ary.dup
  #     r.send(ary, move: true)
  #
  #     s.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     ary.class
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     copy.class
  #     # => Array, it is different object
  #     copy[0].inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #     # ...but its item was still a reference to `s`, which was moved
  #
  # If the object was shareable, `move: true` has no effect on it:
  #
  #     r = Ractor.new {puts "Received: #{receive}"}
  #     s = 'message'.freeze
  #     r.send(s, move: true)
  #     s.inspect #=> "message", still available
  #
  def send: (untyped obj, ?move: boolish) -> Ractor

  # <!--
  #   rdoc-file=ractor.rb
  #   - ractor.take -> msg
  # -->
  # Take a message from ractor's outgoing port, which was put there by
  # Ractor.yield or at ractor's finalization.
  #
  #     r = Ractor.new do
  #       Ractor.yield 'explicit yield'
  #       'last value'
  #     end
  #     puts r.take #=> 'explicit yield'
  #     puts r.take #=> 'last value'
  #     puts r.take # Ractor::ClosedError (The outgoing-port is already closed)
  #
  # The fact that the last value is also put to outgoing port means that `take`
  # can be used as some analog of Thread#join ("just wait till ractor finishes"),
  # but don't forget it will raise if somebody had already consumed everything
  # ractor have produced.
  #
  # If the outgoing port was closed with #close_outgoing, the method will raise
  # Ractor::ClosedError.
  #
  #     r = Ractor.new do
  #       sleep(500)
  #       Ractor.yield 'Hello from ractor'
  #     end
  #     r.close_outgoing
  #     r.take
  #     # Ractor::ClosedError (The outgoing-port is already closed)
  #     # The error would be raised immediately, not when ractor will try to receive
  #
  # If an uncaught exception is raised in the Ractor, it is propagated on take as
  # a Ractor::RemoteError.
  #
  #     r = Ractor.new {raise "Something weird happened"}
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e              #  => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r  # => true
  #       p e.cause        # => #<RuntimeError: Something weird happened>
  #     end
  #
  # Ractor::ClosedError is a descendant of StopIteration, so the closing of the
  # ractor will break the loops without propagating the error:
  #
  #     r = Ractor.new do
  #       3.times {|i| Ractor.yield "message #{i}"}
  #       "finishing"
  #     end
  #
  #     loop {puts "Received: " + r.take}
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: message 0
  #     Received: message 1
  #     Received: message 2
  #     Received: finishing
  #     Continue successfully
  #
  def take: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - to_s()
  # -->
  #
  alias to_s inspect

  private

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive()
  # -->
  # same as Ractor.receive
  #
  def receive: () -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - receive_if(&b)
  # -->
  #
  def receive_if: () { (untyped) -> boolish } -> untyped

  # <!--
  #   rdoc-file=ractor.rb
  #   - recv()
  # -->
  #
  alias recv receive

  # <!-- rdoc-file=ractor.c -->
  # Raised when an attempt is made to send a message to a closed port, or to
  # retrieve a message from a closed and empty port. Ports may be closed
  # explicitly with Ractor#close_outgoing/close_incoming and are closed implicitly
  # when a Ractor terminates.
  #
  #     r = Ractor.new { sleep(500) }
  #     r.close_outgoing
  #     r.take # Ractor::ClosedError
  #
  # ClosedError is a descendant of StopIteration, so the closing of the ractor
  # will break the loops without propagating the error:
  #
  #     r = Ractor.new do
  #       loop do
  #         msg = receive # raises ClosedError and loop traps it
  #         puts "Received: #{msg}"
  #       end
  #       puts "loop exited"
  #     end
  #
  #     3.times{|i| r << i}
  #     r.close_incoming
  #     r.take
  #     puts "Continue successfully"
  #
  # This will print:
  #
  #     Received: 0
  #     Received: 1
  #     Received: 2
  #     loop exited
  #     Continue successfully
  #
  class ClosedError < StopIteration
  end

  class Error < RuntimeError
  end

  class IsolationError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on an attempt to access an object which was moved in Ractor#send or
  # Ractor.yield.
  #
  #     r = Ractor.new { sleep }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedError < Ractor::Error
  end

  # <!-- rdoc-file=ractor.c -->
  # A special object which replaces any value that was moved to another ractor in
  # Ractor#send or Ractor.yield. Any attempt to access the object results in
  # Ractor::MovedError.
  #
  #     r = Ractor.new { receive }
  #
  #     ary = [1, 2, 3]
  #     r.send(ary, move: true)
  #     p Ractor::MovedObject === ary
  #     # => true
  #     ary.inspect
  #     # Ractor::MovedError (can not send any methods to a moved object)
  #
  class MovedObject < BasicObject
    public

    # <!--
    #   rdoc-file=ractor.c
    #   - !(*args)
    # -->
    #
    def !: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - !=(*args)
    # -->
    #
    def !=: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - ==(*args)
    # -->
    #
    def ==: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __id__(*args)
    # -->
    #
    def __id__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - __send__(*args)
    # -->
    #
    def __send__: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - equal?(*args)
    # -->
    #
    def equal?: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_eval(*args)
    # -->
    #
    def instance_eval: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - instance_exec(*args)
    # -->
    #
    def instance_exec: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ractor.c
    #   - method_missing(*args)
    # -->
    #
    def method_missing: (*untyped) -> untyped
  end

  # <!-- rdoc-file=ractor.c -->
  # Raised on attempt to Ractor#take if there was an uncaught exception in the
  # Ractor. Its `cause` will contain the original exception, and `ractor` is the
  # original ractor it was raised in.
  #
  #     r = Ractor.new { raise "Something weird happened" }
  #
  #     begin
  #       r.take
  #     rescue => e
  #       p e             # => #<Ractor::RemoteError: thrown by remote Ractor.>
  #       p e.ractor == r # => true
  #       p e.cause       # => #<RuntimeError: Something weird happened>
  #     end
  #
  class RemoteError < Ractor::Error
    public

    def ractor: () -> Ractor
  end

  class UnsafeError < Ractor::Error
  end
end

# <!-- rdoc-file=array.c -->
# An Array is an ordered, integer-indexed collection of objects, called
# *elements*.  Any object may be an Array element.
#
# ## Array Indexes
#
# Array indexing starts at 0, as in C or Java.
#
# A positive index is an offset from the first element:
# *   Index 0 indicates the first element.
# *   Index 1 indicates the second element.
# *   ...
#
#
# A negative index is an offset, backwards, from the end of the array:
# *   Index -1 indicates the last element.
# *   Index -2 indicates the next-to-last element.
# *   ...
#
#
# A non-negative index is *in range* if it is smaller than the size of the
# array.  For a 3-element array:
# *   Indexes 0 through 2 are in range.
# *   Index 3 is out of range.
#
#
# A negative index is *in range* if its absolute value is not larger than the
# size of the array.  For a 3-element array:
# *   Indexes -1 through -3 are in range.
# *   Index -4 is out of range.
#
#
# ## Creating Arrays
#
# You can create an Array object explicitly with:
#
# *   An [array literal](doc/syntax/literals_rdoc.html#label-Array+Literals).
#
#
# You can convert certain objects to Arrays with:
#
# *   Method [Array](Kernel.html#method-i-Array).
#
#
# An Array can contain different types of objects.  For example, the array below
# contains an Integer, a String and a Float:
#
#     ary = [1, "two", 3.0] #=> [1, "two", 3.0]
#
# An array can also be created by calling Array.new with zero, one (the initial
# size of the Array) or two arguments (the initial size and a default object).
#
#     ary = Array.new    #=> []
#     Array.new(3)       #=> [nil, nil, nil]
#     Array.new(3, true) #=> [true, true, true]
#
# Note that the second argument populates the array with references to the same
# object.  Therefore, it is only recommended in cases when you need to
# instantiate arrays with natively immutable objects such as Symbols, numbers,
# true or false.
#
# To create an array with separate objects a block can be passed instead. This
# method is safe to use with mutable objects such as hashes, strings or other
# arrays:
#
#     Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
#     Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]
#
# This is also a quick way to build up multi-dimensional arrays:
#
#     empty_table = Array.new(3) {Array.new(3)}
#     #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
#
# An array can also be created by using the Array() method, provided by Kernel,
# which tries to call #to_ary, then #to_a on its argument.
#
#     Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]
#
# ## Example Usage
#
# In addition to the methods it mixes in through the Enumerable module, the
# Array class has proprietary methods for accessing, searching and otherwise
# manipulating arrays.
#
# Some of the more common ones are illustrated below.
#
# ## Accessing Elements
#
# Elements in an array can be retrieved using the Array#[] method.  It can take
# a single integer argument (a numeric index), a pair of arguments (start and
# length) or a range. Negative indices start counting from the end, with -1
# being the last element.
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr[2]    #=> 3
#     arr[100]  #=> nil
#     arr[-3]   #=> 4
#     arr[2, 3] #=> [3, 4, 5]
#     arr[1..4] #=> [2, 3, 4, 5]
#     arr[1..-3] #=> [2, 3, 4]
#
# Another way to access a particular array element is by using the #at method
#
#     arr.at(0) #=> 1
#
# The #slice method works in an identical manner to Array#[].
#
# To raise an error for indices outside of the array bounds or else to provide a
# default value when that happens, you can use #fetch.
#
#     arr = ['a', 'b', 'c', 'd', 'e', 'f']
#     arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
#     arr.fetch(100, "oops") #=> "oops"
#
# The special methods #first and #last will return the first and last elements
# of an array, respectively.
#
#     arr.first #=> 1
#     arr.last  #=> 6
#
# To return the first `n` elements of an array, use #take
#
#     arr.take(3) #=> [1, 2, 3]
#
# #drop does the opposite of #take, by returning the elements after `n` elements
# have been dropped:
#
#     arr.drop(3) #=> [4, 5, 6]
#
# ## Obtaining Information about an Array
#
# Arrays keep track of their own length at all times.  To query an array about
# the number of elements it contains, use #length, #count or #size.
#
#     browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
#     browsers.length #=> 5
#     browsers.count #=> 5
#
# To check whether an array contains any elements at all
#
#     browsers.empty? #=> false
#
# To check whether a particular item is included in the array
#
#     browsers.include?('Konqueror') #=> false
#
# ## Adding Items to Arrays
#
# Items can be added to the end of an array by using either #push or #<<
#
#     arr = [1, 2, 3, 4]
#     arr.push(5) #=> [1, 2, 3, 4, 5]
#     arr << 6    #=> [1, 2, 3, 4, 5, 6]
#
# #unshift will add a new item to the beginning of an array.
#
#     arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]
#
# With #insert you can add a new element to an array at any position.
#
#     arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]
#
# Using the #insert method, you can also insert multiple values at once:
#
#     arr.insert(3, 'orange', 'pear', 'grapefruit')
#     #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
#
# ## Removing Items from an Array
#
# The method #pop removes the last element in an array and returns it:
#
#     arr =  [1, 2, 3, 4, 5, 6]
#     arr.pop #=> 6
#     arr #=> [1, 2, 3, 4, 5]
#
# To retrieve and at the same time remove the first item, use #shift:
#
#     arr.shift #=> 1
#     arr #=> [2, 3, 4, 5]
#
# To delete an element at a particular index:
#
#     arr.delete_at(2) #=> 4
#     arr #=> [2, 3, 5]
#
# To delete a particular element anywhere in an array, use #delete:
#
#     arr = [1, 2, 2, 3]
#     arr.delete(2) #=> 2
#     arr #=> [1,3]
#
# A useful method if you need to remove `nil` values from an array is #compact:
#
#     arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
#     arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
#     arr          #=> ['foo', 0, 'bar', 7, 'baz']
#
# Another common need is to remove duplicate elements from an array.
#
# It has the non-destructive #uniq, and destructive method #uniq!
#
#     arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
#     arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]
#
# ## Iterating over Arrays
#
# Like all classes that include the Enumerable module, Array has an each method,
# which defines what elements should be iterated over and how.  In case of
# Array's #each, all elements in the Array instance are yielded to the supplied
# block in sequence.
#
# Note that this operation leaves the array unchanged.
#
#     arr = [1, 2, 3, 4, 5]
#     arr.each {|a| print a -= 10, " "}
#     # prints: -9 -8 -7 -6 -5
#     #=> [1, 2, 3, 4, 5]
#
# Another sometimes useful iterator is #reverse_each which will iterate over the
# elements in the array in reverse order.
#
#     words = %w[first second third fourth fifth sixth]
#     str = ""
#     words.reverse_each {|word| str += "#{word} "}
#     p str #=> "sixth fifth fourth third second first "
#
# The #map method can be used to create a new array based on the original array,
# but with the values modified by the supplied block:
#
#     arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
#     arr                   #=> [1, 2, 3, 4, 5]
#     arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
#     arr                   #=> [1, 4, 9, 16, 25]
#
# ## Selecting Items from an Array
#
# Elements can be selected from an array according to criteria defined in a
# block.  The selection can happen in a destructive or a non-destructive manner.
#  While the destructive operations will modify the array they were called on,
# the non-destructive methods usually return a new array with the selected
# elements, but leave the original array unchanged.
#
# ### Non-destructive Selection
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.select {|a| a > 3}       #=> [4, 5, 6]
#     arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
#     arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
#     arr                          #=> [1, 2, 3, 4, 5, 6]
#
# ### Destructive Selection
#
# #select! and #reject! are the corresponding destructive methods to #select and
# #reject
#
# Similar to #select vs. #reject, #delete_if and #keep_if have the exact
# opposite result when supplied with the same block:
#
#     arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
#     arr                         #=> [4, 5, 6]
#
#     arr = [1, 2, 3, 4, 5, 6]
#     arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
#     arr                       #=> [1, 2, 3]
#
# ## What's Here
#
# First, what's elsewhere. Class Array:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Array provides methods that are useful for:
#
# *   [Creating an Array](#class-Array-label-Methods+for+Creating+an+Array)
# *   [Querying](#class-Array-label-Methods+for+Querying)
# *   [Comparing](#class-Array-label-Methods+for+Comparing)
# *   [Fetching](#class-Array-label-Methods+for+Fetching)
# *   [Assigning](#class-Array-label-Methods+for+Assigning)
# *   [Deleting](#class-Array-label-Methods+for+Deleting)
# *   [Combining](#class-Array-label-Methods+for+Combining)
# *   [Iterating](#class-Array-label-Methods+for+Iterating)
# *   [Converting](#class-Array-label-Methods+for+Converting)
# *   [And more....](#class-Array-label-Other+Methods)
#
#
# ### Methods for Creating an Array
#
# ::[]
# :   Returns a new array populated with given objects.
# ::new
# :   Returns a new array.
# ::try_convert
# :   Returns a new array created from a given object.
#
#
# ### Methods for Querying
#
# #length, #size
# :   Returns the count of elements.
# #include?
# :   Returns whether any element `==` a given object.
# #empty?
# :   Returns whether there are no elements.
# #all?
# :   Returns whether all elements meet a given criterion.
# #any?
# :   Returns whether any element meets a given criterion.
# #none?
# :   Returns whether no element `==` a given object.
# #one?
# :   Returns whether exactly one element `==` a given object.
# #count
# :   Returns the count of elements that meet a given criterion.
# #find_index, #index
# :   Returns the index of the first element that meets a given criterion.
# #rindex
# :   Returns the index of the last element that meets a given criterion.
# #hash
# :   Returns the integer hash code.
#
#
# ### Methods for Comparing
# [#<=>](#method-i-3C-3D-3E)
# :   Returns -1, 0, or 1 as `self` is less than, equal to, or greater than a
#     given object.
# [#==](#method-i-3D-3D)
# :   Returns whether each element in `self` is `==` to the corresponding
#     element in a given object.
# #eql?
# :   Returns whether each element in `self` is `eql?` to the corresponding
#     element in a given object.
#
#
# ### Methods for Fetching
#
# These methods do not modify `self`.
#
# #[]
# :   Returns one or more elements.
# #fetch
# :   Returns the element at a given offset.
# #first
# :   Returns one or more leading elements.
# #last
# :   Returns one or more trailing elements.
# #max
# :   Returns one or more maximum-valued elements, as determined by `<=>` or a
#     given block.
# #max
# :   Returns one or more minimum-valued elements, as determined by `<=>` or a
#     given block.
# #minmax
# :   Returns the minimum-valued and maximum-valued elements, as determined by
#     `<=>` or a given block.
# #assoc
# :   Returns the first element that is an array whose first element `==` a
#     given object.
# #rassoc
# :   Returns the first element that is an array whose second element `==` a
#     given object.
# #at
# :   Returns the element at a given offset.
# #values_at
# :   Returns the elements at given offsets.
# #dig
# :   Returns the object in nested objects that is specified by a given index
#     and additional arguments.
# #drop
# :   Returns trailing elements as determined by a given index.
# #take
# :   Returns leading elements as determined by a given index.
# #drop_while
# :   Returns trailing elements as determined by a given block.
# #take_while
# :   Returns leading elements as determined by a given block.
# #slice
# :   Returns consecutive elements as determined by a given argument.
# #sort
# :   Returns all elements in an order determined by `<=>` or a given block.
# #reverse
# :   Returns all elements in reverse order.
# #compact
# :   Returns an array containing all non-`nil` elements.
# #select, #filter
# :   Returns an array containing elements selected by a given block.
# #uniq
# :   Returns an array containing non-duplicate elements.
# #rotate
# :   Returns all elements with some rotated from one end to the other.
# #bsearch
# :   Returns an element selected via a binary search as determined by a given
#     block.
# #bsearch_index
# :   Returns the index of an element selected via a binary search as determined
#     by a given block.
# #sample
# :   Returns one or more random elements.
# #shuffle
# :   Returns elements in a random order.
#
#
# ### Methods for Assigning
#
# These methods add, replace, or reorder elements in `self`.
#
# #[]=
# :   Assigns specified elements with a given object.
# #push, #append, #<<
# :   Appends trailing elements.
# #unshift, #prepend
# :   Prepends leading elements.
# #insert
# :   Inserts given objects at a given offset; does not replace elements.
# #concat
# :   Appends all elements from given arrays.
# #fill
# :   Replaces specified elements with specified objects.
# #replace
# :   Replaces the content of `self` with the content of a given array.
# #reverse!
# :   Replaces `self` with its elements reversed.
# #rotate!
# :   Replaces `self` with its elements rotated.
# #shuffle!
# :   Replaces `self` with its elements in random order.
# #sort!
# :   Replaces `self` with its elements sorted, as determined by `<=>` or a
#     given block.
# #sort_by!
# :   Replaces `self` with its elements sorted, as determined by a given block.
#
#
# ### Methods for Deleting
#
# Each of these methods removes elements from `self`:
#
# #pop
# :   Removes and returns the last element.
# #shift
# :   Removes and returns the first element.
# #compact!
# :   Removes all non-`nil` elements.
# #delete
# :   Removes elements equal to a given object.
# #delete_at
# :   Removes the element at a given offset.
# #delete_if
# :   Removes elements specified by a given block.
# #keep_if
# :   Removes elements not specified by a given block.
# #reject!
# :   Removes elements specified by a given block.
# #select!, #filter!
# :   Removes elements not specified by a given block.
# #slice!
# :   Removes and returns a sequence of elements.
# #uniq!
# :   Removes duplicates.
#
#
# ### Methods for Combining
#
# [#&](#method-i-26)
# :   Returns an array containing elements found both in `self` and a given
#     array.
# #intersection
# :   Returns an array containing elements found both in `self` and in each
#     given array.
# #+
# :   Returns an array containing all elements of `self` followed by all
#     elements of a given array.
# #-
# :   Returns an array containiing all elements of `self` that are not found in
#     a given array.
# [#|](#method-i-7C)
# :   Returns an array containing all elements of `self` and all elements of a
#     given array, duplicates removed.
# #union
# :   Returns an array containing all elements of `self` and all elements of
#     given arrays, duplicates removed.
# #difference
# :   Returns an array containing all elements of `self` that are not found in
#     any of the given arrays..
# #product
# :   Returns or yields all combinations of elements from `self` and given
#     arrays.
#
#
# ### Methods for Iterating
#
# #each
# :   Passes each element to a given block.
# #reverse_each
# :   Passes each element, in reverse order, to a given block.
# #each_index
# :   Passes each element index to a given block.
# #cycle
# :   Calls a given block with each element, then does so again, for a specified
#     number of times, or forever.
# #combination
# :   Calls a given block with combinations of elements of `self`; a combination
#     does not use the same element more than once.
# #permutation
# :   Calls a given block with permutations of elements of `self`; a permutation
#     does not use the same element more than once.
# #repeated_combination
# :   Calls a given block with combinations of elements of `self`; a combination
#     may use the same element more than once.
# #repeated_permutation
# :   Calls a given block with permutations of elements of `self`; a permutation
#     may use the same element more than once.
#
#
# ### Methods for Converting
#
# #map, #collect
# :   Returns an array containing the block return-value for each element.
# #map!, #collect!
# :   Replaces each element with a block return-value.
# #flatten
# :   Returns an array that is a recursive flattening of `self`.
# #flatten!
# :   Replaces each nested array in `self` with the elements from that array.
# #inspect, #to_s
# :   Returns a new String containing the elements.
# #join
# :   Returns a newsString containing the elements joined by the field
#     separator.
# #to_a
# :   Returns `self` or a new array containing all elements.
# #to_ary
# :   Returns `self`.
# #to_h
# :   Returns a new hash formed from the elements.
# #transpose
# :   Transposes `self`, which must be an array of arrays.
# #zip
# :   Returns a new array of arrays containing `self` and given arrays; follow
#     the link for details.
#
#
# ### Other Methods
#
# #*
# :   Returns one of the following:
#     *   With integer argument `n`, a new array that is the concatenation of
#         `n` copies of `self`.
#     *   With string argument `field_separator`, a new string that is
#         equivalent to `join(field_separator)`.
#
# #abbrev
# :   Returns a hash of unambiguous abbreviations for elements.
# #pack
# :   Packs the elements into a binary sequence.
# #sum
# :   Returns a sum of elements according to either `+` or a given block.
#
%a{annotate:rdoc:source:from=array.c}
class Array[unchecked out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - Array.new -> new_empty_array
  #   - Array.new(array) -> new_array
  #   - Array.new(size) -> new_array
  #   - Array.new(size, default_value) -> new_array
  #   - Array.new(size) {|index| ... } -> new_array
  # -->
  # Returns a new Array.
  #
  # With no block and no arguments, returns a new empty Array object.
  #
  # With no block and a single Array argument `array`, returns a new Array formed
  # from `array`:
  #     a = Array.new([:foo, 'bar', 2])
  #     a.class # => Array
  #     a # => [:foo, "bar", 2]
  #
  # With no block and a single Integer argument `size`, returns a new Array of the
  # given size whose elements are all `nil`:
  #     a = Array.new(3)
  #     a # => [nil, nil, nil]
  #
  # With no block and arguments `size` and `default_value`, returns an Array of
  # the given size; each element is that same `default_value`:
  #     a = Array.new(3, 'x')
  #     a # => ['x', 'x', 'x']
  #
  # With a block and argument `size`, returns an Array of the given size; the
  # block is called with each successive integer `index`; the element for that
  # `index` is the return value from the block:
  #     a = Array.new(3) {|index| "Element #{index}" }
  #     a # => ["Element 0", "Element 1", "Element 2"]
  #
  # Raises ArgumentError if `size` is negative.
  #
  # With a block and no argument, or a single argument `0`, ignores the block and
  # returns a new empty Array.
  #
  def initialize: () -> void
                | (::Array[Elem] ary) -> void
                | (int size, ?Elem val) -> void
                | (int size) { (::Integer index) -> Elem } -> void

  # <!--
  #   rdoc-file=array.c
  #   - [](*args)
  # -->
  # Returns a new array populated with the given objects.
  #
  #     Array.[]( 1, 'a', /^A/)  # => [1, "a", /^A/]
  #     Array[ 1, 'a', /^A/ ]    # => [1, "a", /^A/]
  #     [ 1, 'a', /^A/ ]         # => [1, "a", /^A/]
  #
  def self.[]: [U] (*U) -> ::Array[U]

  # <!--
  #   rdoc-file=array.c
  #   - Array.try_convert(object) -> object, new_array, or nil
  # -->
  # If `object` is an Array object, returns `object`.
  #
  # Otherwise if `object` responds to `:to_ary`, calls `object.to_ary` and returns
  # the result.
  #
  # Returns `nil` if `object` does not respond to `:to_ary`
  #
  # Raises an exception unless `object.to_ary` returns an Array object.
  #
  def self.try_convert: [U] (untyped) -> ::Array[U]?

  public

  # <!--
  #   rdoc-file=array.c
  #   - array & other_array -> new_array
  # -->
  # Returns a new Array containing each element found in both `array` and Array
  # `other_array`; duplicates are omitted; items are compared using `eql?`:
  #     [0, 1, 2, 3] & [1, 2] # => [1, 2]
  #     [0, 1, 0, 1] & [0, 1] # => [0, 1]
  #
  # Preserves order from `array`:
  #     [0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]
  #
  # Related: Array#intersection.
  #
  def &: (::Array[untyped] | _ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array * n -> new_array
  #   - array * string_separator -> new_string
  # -->
  # When non-negative argument Integer `n` is given, returns a new Array built by
  # concatenating the `n` copies of `self`:
  #     a = ['x', 'y']
  #     a * 3 # => ["x", "y", "x", "y", "x", "y"]
  #
  # When String argument `string_separator` is given, equivalent to
  # `array.join(string_separator)`:
  #     [0, [0, 1], {foo: 0}] * ', ' # => "0, 0, 1, {:foo=>0}"
  #
  def *: (string str) -> ::String
       | (int int) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array + other_array -> new_array
  # -->
  # Returns a new Array containing all elements of `array` followed by all
  # elements of `other_array`:
  #     a = [0, 1] + [2, 3]
  #     a # => [0, 1, 2, 3]
  #
  # Related: #concat.
  #
  def +: [U] (_ToAry[U]) -> ::Array[Elem | U]

  # <!--
  #   rdoc-file=array.c
  #   - array - other_array -> new_array
  # -->
  # Returns a new Array containing only those elements from `array` that are not
  # found in Array `other_array`; items are compared using `eql?`; the order from
  # `array` is preserved:
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1] - [1] # => [0, 2, 3]
  #     [0, 1, 2, 3] - [3, 0] # => [1, 2]
  #     [0, 1, 2] - [4] # => [0, 1, 2]
  #
  # Related: Array#difference.
  #
  def -: (_ToAry[untyped]) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array << object -> self
  # -->
  # Appends `object` to `self`; returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a << :baz # => [:foo, "bar", 2, :baz]
  #
  # Appends `object` as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a << [3, 4]
  #     a1 # => [:foo, "bar", 2, [3, 4]]
  #
  def <<: (Elem) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array <=> other_array -> -1, 0, or 1
  # -->
  # Returns -1, 0, or 1 as `self` is less than, equal to, or greater than
  # `other_array`. For each index `i` in `self`, evaluates `result = self[i] <=>
  # other_array[i]`.
  #
  # Returns -1 if any result is -1:
  #     [0, 1, 2] <=> [0, 1, 3] # => -1
  #
  # Returns 1 if any result is 1:
  #     [0, 1, 2] <=> [0, 1, 1] # => 1
  #
  # When all results are zero:
  # *   Returns -1 if `array` is smaller than `other_array`:
  #         [0, 1, 2] <=> [0, 1, 2, 3] # => -1
  #
  # *   Returns 1 if `array` is larger than `other_array`:
  #         [0, 1, 2] <=> [0, 1] # => 1
  #
  # *   Returns 0 if `array` and `other_array` are the same size:
  #         [0, 1, 2] <=> [0, 1, 2] # => 0
  #
  def <=>: (untyped) -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array == other_array -> true or false
  # -->
  # Returns `true` if both `array.size == other_array.size` and for each index `i`
  # in `array`, `array[i] == other_array[i]`:
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2.0]
  #     a1 == a0 # => true
  #     [] == [] # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method Array#eql?, which compares elements using
  # `Object#eql?`.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array[index] -> object or nil
  #   - array[start, length] -> object or nil
  #   - array[range] -> object or nil
  #   - array[aseq] -> object or nil
  #   - array.slice(index) -> object or nil
  #   - array.slice(start, length) -> object or nil
  #   - array.slice(range) -> object or nil
  #   - array.slice(aseq) -> object or nil
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When a single Integer argument `index` is given, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts relative to the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new Array
  # of size `length` containing successive elements beginning at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an Array of elements corresponding to the indexes produced by the sequence.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Array#slice is an alias for Array#[].
  #
  def []: (int index) -> Elem
        | (int start, int length) -> ::Array[Elem]?
        | (::Range[::Integer?] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array[index] = object -> object
  #   - array[start, length] = object -> object
  #   - array[range] = object -> object
  # -->
  # Assigns elements in `self`; returns the given `object`.
  #
  # When Integer argument `index` is given, assigns `object` to an element in
  # `self`.
  #
  # If `index` is non-negative, assigns `object` the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] = 'foo' # => "foo"
  #     a # => ["foo", "bar", 2]
  #
  # If `index` is greater than `self.length`, extends the array:
  #     a = [:foo, 'bar', 2]
  #     a[7] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
  #
  # If `index` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-1] = 'two' # => "two"
  #     a # => [:foo, "bar", "two"]
  #
  # When Integer arguments `start` and `length` are given and `object` is not an
  # Array, removes `length - 1` elements beginning at offset `start`, and assigns
  # `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # If `start` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-2, 2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If `start` is non-negative and outside the array (` >= self.size`), extends
  # the array with `nil`, assigns `object` at offset `start`, and ignores
  # `length`:
  #     a = [:foo, 'bar', 2]
  #     a[6, 50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `length` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[1, 0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `length` is too large for the existing array, does not extend the array:
  #     a = [:foo, 'bar', 2]
  #     a[1, 5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # When Range argument `range` is given and `object` is an Array, removes `length
  # - 1` elements beginning at offset `start`, and assigns `object` at offset
  # `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] = 'foo' # => "foo"
  #     a # => ["foo", 2]
  #
  # if `range.begin` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a[-2..2] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  # If the array length is less than `range.begin`, assigns `object` at offset
  # `range.begin`, and ignores `length`:
  #     a = [:foo, 'bar', 2]
  #     a[6..50] = 'foo' # => "foo"
  #     a # => [:foo, "bar", 2, nil, nil, nil, "foo"]
  #
  # If `range.end` is zero, shifts elements at and following offset `start` and
  # assigns `object` at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[1..0] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #
  # If `range.end` is negative, assigns `object` at offset `start`, retains
  # `range.end.abs -1` elements past that, and removes those beyond:
  #     a = [:foo, 'bar', 2]
  #     a[1..-1] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #     a = [:foo, 'bar', 2]
  #     a[1..-2] = 'foo' # => "foo"
  #     a # => [:foo, "foo", 2]
  #     a = [:foo, 'bar', 2]
  #     a[1..-3] = 'foo' # => "foo"
  #     a # => [:foo, "foo", "bar", 2]
  #     a = [:foo, 'bar', 2]
  #
  # If `range.end` is too large for the existing array, replaces array elements,
  # but does not extend the array with `nil` values:
  #     a = [:foo, 'bar', 2]
  #     a[1..5] = 'foo' # => "foo"
  #     a # => [:foo, "foo"]
  #
  def []=: (int index, Elem obj) -> Elem
         | (int start, int length, Elem obj) -> Elem
         | (int start, int length, ::Array[Elem]) -> ::Array[Elem]
         | (int start, int length, nil) -> nil
         | (::Range[::Integer?], Elem obj) -> Elem
         | (::Range[::Integer?], ::Array[Elem]) -> ::Array[Elem]
         | (::Range[::Integer?], nil) -> nil

  # <!--
  #   rdoc-file=array.c
  #   - array.all? -> true or false
  #   - array.all? {|element| ... } -> true or false
  #   - array.all?(obj) -> true or false
  # -->
  # Returns `true` if all elements of `self` meet a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` contains only
  # truthy elements, `false` otherwise:
  #     [0, 1, :foo].all? # => true
  #     [0, nil, 2].all? # => false
  #     [].all? # => true
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns only truthy values, `false`
  # otherwise:
  #     [0, 1, 2].all? { |element| element < 3 } # => true
  #     [0, 1, 2].all? { |element| element < 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` every element, `false`
  # otherwise:
  #     ['food', 'fool', 'foot'].all?(/foo/) # => true
  #     ['food', 'drink'].all?(/bar/) # => false
  #     [].all?(/foo/) # => true
  #     [0, 0, 0].all?(0) # => true
  #     [0, 1, 2].all?(1) # => false
  #
  # Related: Enumerable#all?
  #
  def all?: () -> bool
          | (_Pattern[Elem] pattern) -> bool
          | () { (Elem obj) -> boolish } -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.any? -> true or false
  #   - array.any? {|element| ... } -> true or false
  #   - array.any?(obj) -> true or false
  # -->
  # Returns `true` if any element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has any truthy
  # element, `false` otherwise:
  #     [nil, 0, false].any? # => true
  #     [nil, false].any? # => false
  #     [].any? # => false
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns any truthy value, `false`
  # otherwise:
  #     [0, 1, 2].any? {|element| element > 1 } # => true
  #     [0, 1, 2].any? {|element| element > 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj`.`===` any element, `false`
  # otherwise:
  #     ['food', 'drink'].any?(/foo/) # => true
  #     ['food', 'drink'].any?(/bar/) # => false
  #     [].any?(/foo/) # => false
  #     [0, 1, 2].any?(1) # => true
  #     [0, 1, 2].any?(3) # => false
  #
  # Related: Enumerable#any?
  #
  alias any? all?

  # <!-- rdoc-file=array.c -->
  # Appends trailing elements.
  #
  # Appends each argument in `objects` to `self`;  returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.push([:baz, :bat], [:bam, :bad])
  #     a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Array#append is an alias for Array#push.
  #
  # Related: #pop, #shift, #unshift.
  #
  alias append push

  # <!--
  #   rdoc-file=array.c
  #   - array.assoc(obj) -> found_array or nil
  # -->
  # Returns the first element in `self` that is an Array whose first element `==`
  # `obj`:
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.assoc(4) # => [4, 5, 6]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: #rassoc.
  #
  def assoc: (untyped) -> ::Array[untyped]?

  # <!--
  #   rdoc-file=array.c
  #   - array.at(index) -> object
  # -->
  # Returns the element at Integer offset `index`; does not modify `self`.
  #     a = [:foo, 'bar', 2]
  #     a.at(0) # => :foo
  #     a.at(2) # => 2
  #
  def at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.bsearch {|element| ... } -> object
  #   - array.bsearch -> new_enumerator
  # -->
  # Returns an element from `self` selected by a binary search.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.bsearch_index {|element| ... } -> integer or nil
  #   - array.bsearch_index -> new_enumerator
  # -->
  # Searches `self` as described at method #bsearch, but returns the *index* of
  # the found element instead of the element itself.
  #
  def bsearch_index: () { (Elem) -> (true | false) } -> ::Integer?
                   | () { (Elem) -> ::Integer } -> ::Integer?

  # <!--
  #   rdoc-file=array.c
  #   - array.clear -> self
  # -->
  # Removes all elements from `self`:
  #     a = [:foo, 'bar', 2]
  #     a.clear # => []
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.map {|element| ... } -> new_array
  #   - array.map -> new_enumerator
  # -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # whose elements are the return values from the block:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map>
  #
  # Array#collect is an alias for Array#map.
  #
  def collect: [U] () { (Elem item) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - array.map! {|element| ... } -> self
  #   - array.map! -> new_enumerator
  # -->
  # Calls the block, if given, with each element; replaces the element with the
  # block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map!
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map!>
  #
  # Array#collect! is an alias for Array#map!.
  #
  def collect!: () { (Elem item) -> Elem } -> self
              | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.combination(n) {|element| ... } -> self
  #   - array.combination(n) -> new_enumerator
  # -->
  # Calls the block, if given, with combinations of elements of `self`; returns
  # `self`. The order of combinations is indeterminate.
  #
  # When a block and an in-range positive Integer argument `n` (`0 < n <=
  # self.size`) are given, calls the block with all `n`-tuple combinations of
  # `self`.
  #
  # Example:
  #     a = [0, 1, 2]
  #     a.combination(2) {|combination| p combination }
  #
  # Output:
  #     [0, 1]
  #     [0, 2]
  #     [1, 2]
  #
  # Another example:
  #     a = [0, 1, 2]
  #     a.combination(3) {|combination| p combination }
  #
  # Output:
  #     [0, 1, 2]
  #
  # When `n` is zero, calls the block once with a new empty Array:
  #     a = [0, 1, 2]
  #     a1 = a.combination(0) {|combination| p combination }
  #
  # Output:
  #     []
  #
  # When `n` is out of range (negative or larger than `self.size`), does not call
  # the block:
  #     a = [0, 1, 2]
  #     a.combination(-1) {|combination| fail 'Cannot happen' }
  #     a.combination(4) {|combination| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>
  #
  def combination: (int n) { (::Array[Elem]) -> void } -> self
                 | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - array.compact -> new_array
  # -->
  # Returns a new Array containing all non-`nil` elements from `self`:
  #     a = [nil, 0, nil, 1, nil, 2, nil]
  #     a.compact # => [0, 1, 2]
  #
  def compact: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.compact! -> self or nil
  # -->
  # Removes all `nil` elements from `self`.
  #
  # Returns `self` if any elements removed, otherwise `nil`.
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.concat(*other_arrays) -> self
  # -->
  # Adds to `array` all elements from each Array in `other_arrays`; returns
  # `self`:
  #     a = [0, 1]
  #     a.concat([2, 3], [4, 5]) # => [0, 1, 2, 3, 4, 5]
  #
  def concat: (*::Array[Elem] arrays) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.count -> an_integer
  #   - array.count(obj) -> an_integer
  #   - array.count {|element| ... } -> an_integer
  # -->
  # Returns a count of specified elements.
  #
  # With no argument and no block, returns the count of all elements:
  #     [0, 1, 2].count # => 3
  #     [].count # => 0
  #
  # With argument `obj`, returns the count of elements `==` to `obj`:
  #     [0, 1, 2, 0.0].count(0) # => 2
  #     [0, 1, 2].count(3) # => 0
  #
  # With no argument and a block given, calls the block with each element; returns
  # the count of elements for which the block returns a truthy value:
  #     [0, 1, 2, 3].count {|element| element > 1} # => 2
  #
  # With argument `obj` and a block given, issues a warning, ignores the block,
  # and returns the count of elements `==` to `obj`:
  #
  def count: () -> ::Integer
           | (Elem obj) -> ::Integer
           | () { (Elem) -> boolish } -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.cycle {|element| ... } -> nil
  #   - array.cycle(count) {|element| ... } -> nil
  #   - array.cycle -> new_enumerator
  #   - array.cycle(count) -> new_enumerator
  # -->
  # When called with positive Integer argument `count` and a block, calls the
  # block with each element, then does so again, until it has done so `count`
  # times; returns `nil`:
  #     output = []
  #     [0, 1].cycle(2) {|element| output.push(element) } # => nil
  #     output # => [0, 1, 0, 1]
  #
  # If `count` is zero or negative, does not call the block:
  #     [0, 1].cycle(0) {|element| fail 'Cannot happen' } # => nil
  #     [0, 1].cycle(-1) {|element| fail 'Cannot happen' } # => nil
  #
  # When a block is given, and argument is omitted or `nil`, cycles forever:
  #     # Prints 0 and 1 forever.
  #     [0, 1].cycle {|element| puts element }
  #     [0, 1].cycle(nil) {|element| puts element }
  #
  # When no block is given, returns a new Enumerator:
  #
  #     [0, 1].cycle(2) # => #<Enumerator: [0, 1]:cycle(2)>
  #     [0, 1].cycle # => # => #<Enumerator: [0, 1]:cycle>
  #     [0, 1].cycle.first(5) # => [0, 1, 0, 1, 0]
  #
  def cycle: (?int? n) { (Elem) -> void } -> nil
           | (?int? n) -> ::Enumerator[Elem, nil]

  # <!--
  #   rdoc-file=array.c
  #   - deconstruct()
  # -->
  #
  def deconstruct: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.delete(obj) -> deleted_object
  #   - array.delete(obj) {|nosuch| ... } -> deleted_object or block_return
  # -->
  # Removes zero or more elements from `self`; returns `self`.
  #
  # When no block is given, removes from `self` each element `ele` such that `ele
  # == obj`; returns the last deleted element:
  #     s1 = 'bar'; s2 = 'bar'
  #     a = [:foo, s1, 2, s2]
  #     a.delete('bar') # => "bar"
  #     a # => [:foo, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # When a block is given, removes from `self` each element `ele` such that `ele
  # == obj`.
  #
  # If any such elements are found, ignores the block and returns the last deleted
  # element:
  #     s1 = 'bar'; s2 = 'bar'
  #     a = [:foo, s1, 2, s2]
  #     deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
  #     a # => [:foo, 2]
  #
  # If no such elements are found, returns the block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.delete(:nosuch) {|obj| "#{obj} not found" } # => "nosuch not found"
  #
  def delete: (Elem obj) -> Elem?
            | [S, T] (S obj) { (S) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_at(index) -> deleted_object or nil
  # -->
  # Deletes an element from `self`, per the given Integer `index`.
  #
  # When `index` is non-negative, deletes the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # If index is too large, returns `nil`.
  #
  # When `index` is negative, counts backward from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.delete_at(-2) # => "bar"
  #     a # => [:foo, 2]
  #
  # If `index` is too small (far from zero), returns nil.
  #
  def delete_at: (int index) -> Elem?

  # <!--
  #   rdoc-file=array.c
  #   - array.delete_if {|element| ... } -> self
  #   - array.delete_if -> Enumerator
  # -->
  # Removes each element in `self` for which the block returns a truthy value;
  # returns `self`:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.delete_if {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.delete_if # => #<Enumerator: [:foo, "bar", 2]:delete_if>
  #
  def delete_if: () { (Elem item) -> boolish } -> self
               | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.difference(*other_arrays) -> new_array
  # -->
  # Returns a new Array containing only those elements from `self` that are not
  # found in any of the Arrays `other_arrays`; items are compared using `eql?`;
  # order from `self` is preserved:
  #     [0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # => [0, 2, 3]
  #     [0, 1, 2, 3].difference([3, 0], [1, 3]) # => [2]
  #     [0, 1, 2].difference([4]) # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#-.
  #
  def difference: (*::Array[untyped] arrays) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.dig(index, *identifiers) -> object
  # -->
  # Finds and returns the object in nested objects that is specified by `index`
  # and `identifiers`. The nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Examples:
  #     a = [:foo, [:bar, :baz, [:bat, :bam]]]
  #     a.dig(1) # => [:bar, :baz, [:bat, :bam]]
  #     a.dig(1, 2) # => [:bat, :bam]
  #     a.dig(1, 2, 0) # => :bat
  #     a.dig(1, 2, 3) # => nil
  #
  def dig: (int idx) -> Elem?
         | (int idx, untyped, *untyped) -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - array.drop(n) -> new_array
  # -->
  # Returns a new Array containing all but the first `n` element of `self`, where
  # `n` is a non-negative Integer; does not modify `self`.
  #
  # Examples:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop(0) # => [0, 1, 2, 3, 4, 5]
  #     a.drop(1) # => [1, 2, 3, 4, 5]
  #     a.drop(2) # => [2, 3, 4, 5]
  #
  def drop: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.drop_while {|element| ... } -> new_array
  #   - array.drop_while -> new_enumerator
  # -->
  # Returns a new Array containing zero or more trailing elements of `self`; does
  # not modify `self`.
  #
  # With a block given, calls the block with each successive element of `self`;
  # stops if the block returns `false` or `nil`; returns a new Array *omitting*
  # those elements for which the block returned a truthy value:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.drop_while {|element| element < 3 } # => [3, 4, 5]
  #
  # With no block given, returns a new Enumerator:
  #     [0, 1].drop_while # => # => #<Enumerator: [0, 1]:drop_while>
  #
  def drop_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.each {|element| ... } -> self
  #   - array.each -> Enumerator
  # -->
  # Iterates over array elements.
  #
  # When a block given, passes each successive array element to the block; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #     foo
  #     bar
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.each
  #     e # => #<Enumerator: [:foo, "bar", 2]:each>
  #     a1 = e.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Symbol foo
  #     String bar
  #     Integer 2
  #
  # Related: #each_index, #reverse_each.
  #
  def each: () -> ::Enumerator[Elem, self]
          | () { (Elem item) -> void } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.each_index {|index| ... } -> self
  #   - array.each_index -> Enumerator
  # -->
  # Iterates over array indexes.
  #
  # When a block given, passes each successive array index to the block; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index|  puts "#{index} #{a[index]}" }
  #
  # Output:
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.each_index {|index| puts index; a.clear if index > 0 }
  #
  # Output:
  #     0
  #     1
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.each_index
  #     e # => #<Enumerator: [:foo, "bar", 2]:each_index>
  #     a1 = e.each {|index|  puts "#{index} #{a[index]}"}
  #
  # Output:
  #     0 foo
  #     1 bar
  #     2 2
  #
  # Related: #each, #reverse_each.
  #
  def each_index: () { (::Integer index) -> void } -> self
                | () -> ::Enumerator[::Integer, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.empty?  -> true or false
  # -->
  # Returns `true` if the count of elements in `self` is zero, `false` otherwise.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.eql? other_array -> true or false
  # -->
  # Returns `true` if `self` and `other_array` are the same size, and if, for each
  # index `i` in `self`, `self[i].eql? other_array[i]`:
  #     a0 = [:foo, 'bar', 2]
  #     a1 = [:foo, 'bar', 2]
  #     a1.eql?(a0) # => true
  #
  # Otherwise, returns `false`.
  #
  # This method is different from method [Array#==](#method-i-3D-3D), which
  # compares using method `Object#==`.
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.fetch(index) -> element
  #   - array.fetch(index, default_value) -> element
  #   - array.fetch(index) {|index| ... } -> element
  # -->
  # Returns the element at offset  `index`.
  #
  # With the single Integer argument `index`, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1) # => "bar"
  #
  # If `index` is negative, counts from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(-1) # => 2
  #     a.fetch(-2) # => "bar"
  #
  # With arguments `index` and `default_value`, returns the element at offset
  # `index` if index is in range, otherwise returns `default_value`:
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1, nil) # => "bar"
  #
  # With argument `index` and a block, returns the element at offset `index` if
  # index is in range (and the block is not called); otherwise calls the block
  # with index and returns its return value:
  #
  #     a = [:foo, 'bar', 2]
  #     a.fetch(1) {|index| raise 'Cannot happen' } # => "bar"
  #     a.fetch(50) {|index| "Value for #{index}" } # => "Value for 50"
  #
  def fetch: (int index) -> Elem
           | [T] (int index, T default) -> (Elem | T)
           | [T] (int index) { (int index) -> T } -> (Elem | T)

  # <!--
  #   rdoc-file=array.c
  #   - array.fill(obj) -> self
  #   - array.fill(obj, start) -> self
  #   - array.fill(obj, start, length) -> self
  #   - array.fill(obj, range) -> self
  #   - array.fill {|index| ... } -> self
  #   - array.fill(start) {|index| ... } -> self
  #   - array.fill(start, length) {|index| ... } -> self
  #   - array.fill(range) {|index| ... } -> self
  # -->
  # Replaces specified elements in `self` with specified objects; returns `self`.
  #
  # With argument `obj` and no block given, replaces all elements with that one
  # object:
  #     a = ['a', 'b', 'c', 'd']
  #     a # => ["a", "b", "c", "d"]
  #     a.fill(:X) # => [:X, :X, :X, :X]
  #
  # With arguments `obj` and Integer `start`, and no block given, replaces
  # elements based on the given start.
  #
  # If `start` is in range (`0 <= start < array.size`), replaces all elements from
  # offset `start` through the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 2) # => ["a", "b", :X, :X]
  #
  # If `start` is too large (`start >= array.size`), does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 4) # => ["a", "b", "c", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5) # => ["a", "b", "c", "d"]
  #
  # If `start` is negative, counts from the end (starting index is `start +
  # array.size`):
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -2) # => ["a", "b", :X, :X]
  #
  # If `start` is too small (less than and far from zero), replaces all elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -6) # => [:X, :X, :X, :X]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -50) # => [:X, :X, :X, :X]
  #
  # With arguments `obj`, Integer `start`, and Integer `length`, and no block
  # given, replaces elements based on the given `start` and `length`.
  #
  # If `start` is in range, replaces `length` elements beginning at offset
  # `start`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 1, 1) # => ["a", :X, "c", "d"]
  #
  # If `start` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, -2, 1) # => ["a", "b", :X, "d"]
  #
  # If `start` is large (`start >= array.size`), extends `self` with `nil`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5, 0) # => ["a", "b", "c", "d", nil]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 5, 2) # => ["a", "b", "c", "d", nil, :X, :X]
  #
  # If `length` is zero or negative, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, 1, 0) # => ["a", "b", "c", "d"]
  #     a.fill(:X, 1, -1) # => ["a", "b", "c", "d"]
  #
  # With arguments `obj` and Range `range`, and no block given, replaces elements
  # based on the given range.
  #
  # If the range is positive and ascending (`0 < range.begin <= range.end`),
  # replaces elements from `range.begin` to `range.end`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (1..1)) # => ["a", :X, "c", "d"]
  #
  # If `range.first` is negative, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-1..1)) # => ["a", "b", "c", "d"]
  #
  # If `range.last` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (0..-2)) # => [:X, :X, :X, "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (1..-2)) # => ["a", :X, :X, "d"]
  #
  # If `range.last` and `range.last` are both negative, both count from the end of
  # the array:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-1..-1)) # => ["a", "b", "c", :X]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(:X, (-2..-2)) # => ["a", "b", :X, "d"]
  #
  # With no arguments and a block given, calls the block with each index; replaces
  # the corresponding element with the block's return value:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #
  # With argument `start` and a block given, calls the block with each index from
  # offset `start` to the end; replaces the corresponding element with the block's
  # return value:
  #
  # If start is in range (`0 <= start < array.size`), replaces from offset `start`
  # to the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "new_3"]
  #
  # If `start` is too large(`start >= array.size`), does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # If `start` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "new_3"]
  #
  # If start is too small (`start <= -array.size`, replaces all elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-6) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-50) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
  #
  # With arguments `start` and `length`, and a block given, calls the block for
  # each index specified by start length; replaces the corresponding element with
  # the block's return value.
  #
  # If `start` is in range, replaces `length` elements beginning at offset
  # `start`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1, 1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]
  #
  # If start is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2, 1) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]
  #
  # If `start` is large (`start >= array.size`), extends `self` with `nil`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(5, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(5, 2) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil, "new_5", "new_6"]
  #
  # If `length` is zero or less, replaces no elements:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]
  #     a.fill(1, -1) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]
  #
  # With arguments `obj` and `range`, and a block given, calls the block with each
  # index in the given range; replaces the corresponding element with the block's
  # return value.
  #
  # If the range is positive and ascending (`range 0 < range.begin <= range.end`,
  # replaces elements from `range.begin` to `range.end`:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1..1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]
  #
  # If `range.first` is negative, does nothing:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-1..1) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
  #
  # If `range.last` is negative, counts from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(0..-2) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "d"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(1..-2) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "d"]
  #
  # If `range.first` and `range.last` are both negative, both count from the end:
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-1..-1) { |index| "new_#{index}" } # => ["a", "b", "c", "new_3"]
  #     a = ['a', 'b', 'c', 'd']
  #     a.fill(-2..-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]
  #
  def fill: (Elem obj) -> self
          | (Elem obj, int? start, ?int? length) -> self
          | (Elem obj, ::Range[::Integer] range) -> self
          | (?int? start, ?int? length) { (::Integer index) -> Elem } -> self
          | (::Range[::Integer] range) { (::Integer index) -> Elem } -> self

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # containing those elements of `self` for which the block returns a truthy
  # value:
  #     a = [:foo, 'bar', 2, :bam]
  #     a1 = a.select {|element| element.to_s.start_with?('b') }
  #     a1 # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>
  #
  # Array#filter is an alias for Array#select.
  #
  def filter: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given  with each element of `self`; removes from `self`
  # those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>
  #
  # Array#filter! is an alias for Array#select!.
  #
  def filter!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.index(object) -> integer or nil
  #   - array.index {|element| ... } -> integer or nil
  #   - array.index -> new_enumerator
  # -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  def find_index: (untyped obj) -> ::Integer?
                | () { (Elem item) -> boolish } -> ::Integer?
                | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.c
  #   - array.first -> object or nil
  #   - array.first(n) -> new_array
  # -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When no argument is given, returns the first element:
  #     a = [:foo, 'bar', 2]
  #     a.first # => :foo
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Integer argument `n` is given, returns the first `n`
  # elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.first(2) # => [:foo, "bar"]
  #
  # If `n >= array.size`, returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.first(50) # => [:foo, "bar", 2]
  #
  # If `n == 0` returns an new empty Array:
  #     a = [:foo, 'bar', 2]
  #     a.first(0) # []
  #
  # Related: #last.
  #
  def first: () -> Elem?
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.flatten -> new_array
  #   - array.flatten(level) -> new_array
  # -->
  # Returns a new Array that is a recursive flattening of `self`:
  # *   Each non-Array element is unchanged.
  # *   Each Array is replaced by its individual elements.
  #
  #
  # With non-negative Integer argument `level`, flattens recursively through
  # `level` levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(0) # => [0, [1, [2, 3], 4], 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(1) # => [0, 1, [2, 3], 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(2) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(3) # => [0, 1, 2, 3, 4, 5]
  #
  # With no argument, a `nil` argument, or with negative argument `level`,
  # flattens all levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten # => [0, 1, 2]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(-1) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten(-2) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten(-1) # => [0, 1, 2]
  #
  def flatten: (?int level) -> ::Array[untyped]

  # <!--
  #   rdoc-file=array.c
  #   - array.flatten! -> self or nil
  #   - array.flatten!(level) -> self or nil
  # -->
  # Replaces each nested Array in `self` with the elements from that Array;
  # returns `self` if any changes, `nil` otherwise.
  #
  # With non-negative Integer argument `level`, flattens recursively through
  # `level` levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(1) # => [0, 1, [2, 3], 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(2) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(3) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten!(1) # => nil
  #
  # With no argument, a `nil` argument, or with negative argument `level`,
  # flattens all levels:
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten! # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten! # => nil
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(-1) # => [0, 1, 2, 3, 4, 5]
  #     a = [ 0, [ 1, [2, 3], 4 ], 5 ]
  #     a.flatten!(-2) # => [0, 1, 2, 3, 4, 5]
  #     [0, 1, 2].flatten!(-1) # => nil
  #
  def flatten!: (?int level) -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two arrays with the same content will have the same hash code (and will
  # compare using eql?):
  #     [0, 1, 2].hash == [0, 1, 2].hash # => true
  #     [0, 1, 2].hash == [0, 1, 3].hash # => false
  #
  def hash: () -> ::Integer

  # <!--
  #   rdoc-file=array.c
  #   - array.include?(obj) -> true or false
  # -->
  # Returns `true` if for some index `i` in `self`, `obj == self[i]`; otherwise
  # `false`:
  #     [0, 1, 2].include?(2) # => true
  #     [0, 1, 2].include?(3) # => false
  #
  def include?: (Elem object) -> bool

  # <!-- rdoc-file=array.c -->
  # Returns the index of a specified element.
  #
  # When argument `object` is given but no block, returns the index of the first
  # element `element` for which `object == element`:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index('bar') # => 1
  #
  # Returns `nil` if no such element found.
  #
  # When both argument `object` and a block are given, calls the block with each
  # successive element; returns the index of the first element for which the block
  # returns a truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.index {|element| element == 'bar' } # => 1
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.index
  #     e # => #<Enumerator: [:foo, "bar", 2]:index>
  #     e.each {|element| element == 'bar' } # => 1
  #
  # Array#find_index is an alias for Array#index.
  #
  # Related: #rindex.
  #
  alias index find_index

  # <!--
  #   rdoc-file=array.c
  #   - array.insert(index, *objects) -> self
  # -->
  # Inserts given `objects` before or after the element at Integer index `offset`;
  # returns `self`.
  #
  # When `index` is non-negative, inserts all given `objects` before the element
  # at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.insert(1, :bat, :bam) # => [:foo, :bat, :bam, "bar", 2]
  #
  # Extends the array if `index` is beyond the array (`index >= self.size`):
  #     a = [:foo, 'bar', 2]
  #     a.insert(5, :bat, :bam)
  #     a # => [:foo, "bar", 2, nil, nil, :bat, :bam]
  #
  # Does nothing if no objects given:
  #     a = [:foo, 'bar', 2]
  #     a.insert(1)
  #     a.insert(50)
  #     a.insert(-50)
  #     a # => [:foo, "bar", 2]
  #
  # When `index` is negative, inserts all given `objects` *after* the element at
  # offset `index+self.size`:
  #     a = [:foo, 'bar', 2]
  #     a.insert(-2, :bat, :bam)
  #     a # => [:foo, "bar", :bat, :bam, 2]
  #
  def insert: (int index, *Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.inspect -> new_string
  # -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=array.c
  #   - ary.intersect?(other_ary)   -> true or false
  # -->
  # Returns `true` if the array and `other_ary` have at least one element in
  # common, otherwise returns `false`.
  #
  #     a = [ 1, 2, 3 ]
  #     b = [ 3, 4, 5 ]
  #     c = [ 5, 6, 7 ]
  #     a.intersect?(b)   #=> true
  #     a.intersect?(c)   #=> false
  #
  def intersect?: (_ToAry[untyped]) -> bool

  # <!--
  #   rdoc-file=array.c
  #   - array.intersection(*other_arrays) -> new_array
  # -->
  # Returns a new Array containing each element found both in `self` and in all of
  # the given Arrays `other_arrays`; duplicates are omitted; items are compared
  # using `eql?`:
  #     [0, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
  #     [0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
  #
  # Preserves order from `self`:
  #     [0, 1, 2].intersection([2, 1, 0]) # => [0, 1, 2]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#&.
  #
  def intersection: (*::Array[untyped] | _ToAry[untyped] other_ary) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.join ->new_string
  #   - array.join(separator = $,) -> new_string
  # -->
  # Returns the new String formed by joining the array elements after conversion.
  # For each element `element`
  # *   Uses `element.to_s` if `element` is not a `kind_of?(Array)`.
  # *   Uses recursive `element.join(separator)` if `element` is a
  #     `kind_of?(Array)`.
  #
  #
  # With no argument, joins using the output field separator, `$,`:
  #     a = [:foo, 'bar', 2]
  #     $, # => nil
  #     a.join # => "foobar2"
  #
  # With string argument `separator`, joins using that separator:
  #     a = [:foo, 'bar', 2]
  #     a.join("\n") # => "foo\nbar\n2"
  #
  # Joins recursively for nested Arrays:
  #     a = [:foo, [:bar, [:baz, :bat]]]
  #     a.join # => "foobarbazbat"
  #
  def join: (?string separator) -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.keep_if {|element| ... } -> self
  #   - array.keep_if -> new_enumeration
  # -->
  # Retains those elements for which the block returns a truthy value; deletes all
  # other elements; returns `self`:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.keep_if # => #<Enumerator: [:foo, "bar", 2, :bam]:keep_if>
  #
  def keep_if: () { (Elem item) -> boolish } -> self
             | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.last  -> object or nil
  #   - array.last(n) -> new_array
  # -->
  # Returns elements from `self`; `self` is not modified.
  #
  # When no argument is given, returns the last element:
  #     a = [:foo, 'bar', 2]
  #     a.last # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `self` is empty, returns `nil`.
  #
  # When non-negative Innteger argument `n` is given, returns the last `n`
  # elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.last(2) # => ["bar", 2]
  #
  # If `n >= array.size`, returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.last(50) # => [:foo, "bar", 2]
  #
  # If `n == 0`, returns an new empty Array:
  #     a = [:foo, 'bar', 2]
  #     a.last(0) # []
  #
  # Related: #first.
  #
  def last: () -> Elem?
          | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.length -> an_integer
  # -->
  # Returns the count of elements in `self`.
  #
  def length: () -> ::Integer

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # whose elements are the return values from the block:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map {|element| element.class }
  #     a1 # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map>
  #
  # Array#collect is an alias for Array#map.
  #
  alias map collect

  # <!-- rdoc-file=array.c -->
  # Calls the block, if given, with each element; replaces the element with the
  # block's return value:
  #     a = [:foo, 'bar', 2]
  #     a.map! { |element| element.class } # => [Symbol, String, Integer]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.map!
  #     a1 # => #<Enumerator: [:foo, "bar", 2]:map!>
  #
  # Array#collect! is an alias for Array#map!.
  #
  alias map! collect!

  # <!--
  #   rdoc-file=array.c
  #   - array.max -> element
  #   - array.max {|a, b| ... } -> element
  #   - array.max(n) -> new_array
  #   - array.max(n) {|a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  # *   The maximum-valued element from `self`.
  # *   A new Array of maximum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # maximum value per method `<=>`:
  #     [0, 1, 2].max # => 2
  #
  # With an argument Integer `n` and no block, returns a new Array with at most
  # `n` elements, in descending order per method `<=>`:
  #     [0, 1, 2, 3].max(3) # => [3, 2, 1]
  #     [0, 1, 2, 3].max(6) # => [3, 2, 1, 0]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the maximum value per the block:
  #     ['0', '00', '000'].max {|a, b| a.size <=> b.size } # => "000"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in descending order per the block:
  #     ['0', '00', '000'].max(2) {|a, b| a.size <=> b.size } # => ["000", "00"]
  #
  def max: () -> Elem?
         | () { (Elem a, Elem b) -> ::Integer? } -> Elem?
         | (int n) -> ::Array[Elem]
         | (int n) { (Elem a, Elem b) -> ::Integer? } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.min -> element
  #   - array.min { |a, b| ... } -> element
  #   - array.min(n) -> new_array
  #   - array.min(n) { |a, b| ... } -> new_array
  # -->
  # Returns one of the following:
  # *   The minimum-valued element from `self`.
  # *   A new Array of minimum-valued elements selected from `self`.
  #
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer.
  #
  # With no argument and no block, returns the element in `self` having the
  # minimum value per method `<=>`:
  #     [0, 1, 2].min # => 0
  #
  # With Integer argument `n` and no block, returns a new Array with at most `n`
  # elements, in ascending order per method `<=>`:
  #     [0, 1, 2, 3].min(3) # => [0, 1, 2]
  #     [0, 1, 2, 3].min(6) # => [0, 1, 2, 3]
  #
  # When a block is given, the block must return an Integer.
  #
  # With a block and no argument, calls the block `self.size-1` times to compare
  # elements; returns the element having the minimum value per the block:
  #     ['0', '00', '000'].min { |a, b| a.size <=> b.size } # => "0"
  #
  # With an argument `n` and a block, returns a new Array with at most `n`
  # elements, in ascending order per the block:
  #     ['0', '00', '000'].min(2) {|a, b| a.size <=> b.size } # => ["0", "00"]
  #
  alias min max

  # <!--
  #   rdoc-file=array.c
  #   - array.minmax -> [min_val, max_val]
  #   - array.minmax {|a, b| ... } -> [min_val, max_val]
  # -->
  # Returns a new 2-element Array containing the minimum and maximum values from
  # `self`, either per method `<=>` or per a given block:.
  #
  # When no block is given, each element in `self` must respond to method `<=>`
  # with an Integer; returns a new 2-element Array containing the minimum and
  # maximum values from `self`, per method `<=>`:
  #     [0, 1, 2].minmax # => [0, 2]
  #
  # When a block is given, the block must return an Integer; the block is called
  # `self.size-1` times to compare elements; returns a new 2-element Array
  # containing the minimum and maximum values from `self`, per the block:
  #     ['0', '00', '000'].minmax {|a, b| a.size <=> b.size } # => ["0", "000"]
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem a, Elem b) -> ::Integer? } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=array.c
  #   - array.none? -> true or false
  #   - array.none? {|element| ... } -> true or false
  #   - array.none?(obj) -> true or false
  # -->
  # Returns `true` if no element of `self` meet a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has no truthy
  # elements, `false` otherwise:
  #     [nil, false].none? # => true
  #     [nil, 0, false].none? # => false
  #     [].none? # => true
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block returns no truthy value, `false`
  # otherwise:
  #     [0, 1, 2].none? {|element| element > 3 } # => true
  #     [0, 1, 2].none? {|element| element > 1 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` no element, `false`
  # otherwise:
  #     ['food', 'drink'].none?(/bar/) # => true
  #     ['food', 'drink'].none?(/foo/) # => false
  #     [].none?(/foo/) # => true
  #     [0, 1, 2].none?(3) # => true
  #     [0, 1, 2].none?(1) # => false
  #
  # Related: Enumerable#none?
  #
  alias none? all?

  # <!--
  #   rdoc-file=array.c
  #   - array.one? -> true or false
  #   - array.one? {|element| ... } -> true or false
  #   - array.one?(obj) -> true or false
  # -->
  # Returns `true` if exactly one element of `self` meets a given criterion.
  #
  # With no block given and no argument, returns `true` if `self` has exactly one
  # truthy element, `false` otherwise:
  #     [nil, 0].one? # => true
  #     [0, 0].one? # => false
  #     [nil, nil].one? # => false
  #     [].one? # => false
  #
  # With a block given and no argument, calls the block with each element in
  # `self`; returns `true` if the block a truthy value for exactly one element,
  # `false` otherwise:
  #     [0, 1, 2].one? {|element| element > 0 } # => false
  #     [0, 1, 2].one? {|element| element > 1 } # => true
  #     [0, 1, 2].one? {|element| element > 2 } # => false
  #
  # If argument `obj` is given, returns `true` if `obj.===` exactly one element,
  # `false` otherwise:
  #     [0, 1, 2].one?(0) # => true
  #     [0, 0, 1].one?(0) # => false
  #     [1, 1, 2].one?(0) # => false
  #     ['food', 'drink'].one?(/bar/) # => false
  #     ['food', 'drink'].one?(/foo/) # => true
  #     [].one?(/foo/) # => false
  #
  # Related: Enumerable#one?
  #
  alias one? none?

  # <!--
  #   rdoc-file=pack.rb
  #   - arr.pack( aTemplateString ) -> aBinaryString
  #   - arr.pack( aTemplateString, buffer: aBufferString ) -> aBufferString
  # -->
  # Packs the contents of *arr* into a binary sequence according to the directives
  # in *aTemplateString* (see the table below) Directives ``A,'' ``a,'' and ``Z''
  # may be followed by a count, which gives the width of the resulting field. The
  # remaining directives also may take a count, indicating the number of array
  # elements to convert. If the count is an asterisk (```*`''), all remaining
  # array elements will be converted. Any of the directives ```sSiIlL`'' may be
  # followed by an underscore (```_`'') or exclamation mark (```!`'') to use the
  # underlying platform's native size for the specified type; otherwise, they use
  # a platform-independent size. Spaces are ignored in the template string. See
  # also String#unpack.
  #
  #     a = [ "a", "b", "c" ]
  #     n = [ 65, 66, 67 ]
  #     a.pack("A3A3A3")   #=> "a  b  c  "
  #     a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
  #     n.pack("ccc")      #=> "ABC"
  #
  # If *aBufferString* is specified and its capacity is enough, `pack` uses it as
  # the buffer and returns it. When the offset is specified by the beginning of
  # *aTemplateString*, the result is filled after the offset. If original contents
  # of *aBufferString* exists and it's longer than the offset, the rest of
  # *offsetOfBuffer* are overwritten by the result. If it's shorter, the gap is
  # filled with ```\0`''.
  #
  #     # packed data is appended by default
  #     [255].pack("C", buffer:"foo".b) #=> "foo\xFF"
  #
  #     # "@0" (offset 0) specifies that packed data is filled from beginning.
  #     # Also, original data after packed data is removed. ("oo" is removed.)
  #     [255].pack("@0C", buffer:"foo".b) #=> "\xFF"
  #
  #     # If the offset is bigger than the original length, \x00 is filled.
  #     [255].pack("@5C", buffer:"foo".b) #=> "foo\x00\x00\xFF"
  #
  # Note that ``buffer:'' option does not guarantee not to allocate memory in
  # `pack`.  If the capacity of *aBufferString* is not enough, `pack` allocates
  # memory.
  #
  # Directives for `pack`.
  #
  #     Integer       | Array   |
  #     Directive     | Element | Meaning
  #     ----------------------------------------------------------------------------
  #     C             | Integer | 8-bit unsigned (unsigned char)
  #     S             | Integer | 16-bit unsigned, native endian (uint16_t)
  #     L             | Integer | 32-bit unsigned, native endian (uint32_t)
  #     Q             | Integer | 64-bit unsigned, native endian (uint64_t)
  #     J             | Integer | pointer width unsigned, native endian (uintptr_t)
  #                   |         | (J is available since Ruby 2.3.)
  #                   |         |
  #     c             | Integer | 8-bit signed (signed char)
  #     s             | Integer | 16-bit signed, native endian (int16_t)
  #     l             | Integer | 32-bit signed, native endian (int32_t)
  #     q             | Integer | 64-bit signed, native endian (int64_t)
  #     j             | Integer | pointer width signed, native endian (intptr_t)
  #                   |         | (j is available since Ruby 2.3.)
  #                   |         |
  #     S_ S!         | Integer | unsigned short, native endian
  #     I I_ I!       | Integer | unsigned int, native endian
  #     L_ L!         | Integer | unsigned long, native endian
  #     Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #                   |         | (Q_ and Q! is available since Ruby 2.1.)
  #     J!            | Integer | uintptr_t, native endian (same with J)
  #                   |         | (J! is available since Ruby 2.3.)
  #                   |         |
  #     s_ s!         | Integer | signed short, native endian
  #     i i_ i!       | Integer | signed int, native endian
  #     l_ l!         | Integer | signed long, native endian
  #     q_ q!         | Integer | signed long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #                   |         | (q_ and q! is available since Ruby 2.1.)
  #     j!            | Integer | intptr_t, native endian (same with j)
  #                   |         | (j! is available since Ruby 2.3.)
  #                   |         |
  #     S> s> S!> s!> | Integer | same as the directives without ">" except
  #     L> l> L!> l!> |         | big endian
  #     I!> i!>       |         | (available since Ruby 1.9.3)
  #     Q> q> Q!> q!> |         | "S>" is the same as "n"
  #     J> j> J!> j!> |         | "L>" is the same as "N"
  #                   |         |
  #     S< s< S!< s!< | Integer | same as the directives without "<" except
  #     L< l< L!< l!< |         | little endian
  #     I!< i!<       |         | (available since Ruby 1.9.3)
  #     Q< q< Q!< q!< |         | "S<" is the same as "v"
  #     J< j< J!< j!< |         | "L<" is the same as "V"
  #                   |         |
  #     n             | Integer | 16-bit unsigned, network (big-endian) byte order
  #     N             | Integer | 32-bit unsigned, network (big-endian) byte order
  #     v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
  #     V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
  #                   |         |
  #     U             | Integer | UTF-8 character
  #     w             | Integer | BER-compressed integer
  #
  #     Float        | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     D d          | Float   | double-precision, native format
  #     F f          | Float   | single-precision, native format
  #     E            | Float   | double-precision, little-endian byte order
  #     e            | Float   | single-precision, little-endian byte order
  #     G            | Float   | double-precision, network (big-endian) byte order
  #     g            | Float   | single-precision, network (big-endian) byte order
  #
  #     String       | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     A            | String  | arbitrary binary string (space padded, count is width)
  #     a            | String  | arbitrary binary string (null padded, count is width)
  #     Z            | String  | same as ``a'', except that null is added with *
  #     B            | String  | bit string (MSB first)
  #     b            | String  | bit string (LSB first)
  #     H            | String  | hex string (high nibble first)
  #     h            | String  | hex string (low nibble first)
  #     u            | String  | UU-encoded string
  #     M            | String  | quoted printable, MIME encoding (see also RFC2045)
  #                  |         | (text mode but input must use LF and output LF)
  #     m            | String  | base64 encoded string (see RFC 2045)
  #                  |         | (if count is 0, no line feed are added, see RFC 4648)
  #                  |         | (count specifies input bytes between each LF,
  #                  |         | rounded down to nearest multiple of 3)
  #     P            | String  | pointer to a structure (fixed-length string)
  #     p            | String  | pointer to a null-terminated string
  #
  #     Misc.        | Array   |
  #     Directive    | Element | Meaning
  #     ---------------------------------------------------------------------------
  #     @            | ---     | moves to absolute position
  #     X            | ---     | back up a byte
  #     x            | ---     | null byte
  #
  def pack: (string fmt, ?buffer: String?) -> String

  # <!--
  #   rdoc-file=array.c
  #   - array.permutation {|element| ... } -> self
  #   - array.permutation(n) {|element| ... } -> self
  #   - array.permutation -> new_enumerator
  #   - array.permutation(n) -> new_enumerator
  # -->
  # When invoked with a block, yield all permutations of elements of `self`;
  # returns `self`. The order of permutations is indeterminate.
  #
  # When a block and an in-range positive Integer argument `n` (`0 < n <=
  # self.size`) are given, calls the block with all `n`-tuple permutations of
  # `self`.
  #
  # Example:
  #     a = [0, 1, 2]
  #     a.permutation(2) {|permutation| p permutation }
  #
  # Output:
  #     [0, 1]
  #     [0, 2]
  #     [1, 0]
  #     [1, 2]
  #     [2, 0]
  #     [2, 1]
  #
  # Another example:
  #     a = [0, 1, 2]
  #     a.permutation(3) {|permutation| p permutation }
  #
  # Output:
  #     [0, 1, 2]
  #     [0, 2, 1]
  #     [1, 0, 2]
  #     [1, 2, 0]
  #     [2, 0, 1]
  #     [2, 1, 0]
  #
  # When `n` is zero, calls the block once with a new empty Array:
  #     a = [0, 1, 2]
  #     a.permutation(0) {|permutation| p permutation }
  #
  # Output:
  #     []
  #
  # When `n` is out of range (negative or larger than `self.size`), does not call
  # the block:
  #     a = [0, 1, 2]
  #     a.permutation(-1) {|permutation| fail 'Cannot happen' }
  #     a.permutation(4) {|permutation| fail 'Cannot happen' }
  #
  # When a block given but no argument, behaves the same as
  # `a.permutation(a.size)`:
  #     a = [0, 1, 2]
  #     a.permutation {|permutation| p permutation }
  #
  # Output:
  #     [0, 1, 2]
  #     [0, 2, 1]
  #     [1, 0, 2]
  #     [1, 2, 0]
  #     [2, 0, 1]
  #     [2, 1, 0]
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.permutation # => #<Enumerator: [0, 1, 2]:permutation>
  #     a.permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>
  #
  def permutation: (?int n) -> ::Enumerator[::Array[Elem], ::Array[Elem]]
                 | (?int n) { (::Array[Elem] p) -> void } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.pop -> object or nil
  #   - array.pop(n) -> new_array
  # -->
  # Removes and returns trailing elements.
  #
  # When no argument is given and `self` is not empty, removes and returns the
  # last element:
  #     a = [:foo, 'bar', 2]
  #     a.pop # => 2
  #     a # => [:foo, "bar"]
  #
  # Returns `nil` if the array is empty.
  #
  # When a non-negative Integer argument `n` is given and is in range, removes and
  # returns the last `n` elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.pop(2) # => ["bar", 2]
  #
  # If `n` is positive and out of range, removes and returns all elements:
  #     a = [:foo, 'bar', 2]
  #     a.pop(50) # => [:foo, "bar", 2]
  #
  # Related: #push, #shift, #unshift.
  #
  def pop: () -> Elem?
         | (int n) -> ::Array[Elem]

  # <!-- rdoc-file=array.c -->
  # Prepends the given `objects` to `self`:
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Array#prepend is an alias for Array#unshift.
  #
  # Related: #push, #pop, #shift.
  #
  alias prepend unshift

  # <!--
  #   rdoc-file=array.c
  #   - array.product(*other_arrays) -> new_array
  #   - array.product(*other_arrays) {|combination| ... } -> self
  # -->
  # Computes and returns or yields all combinations of elements from all the
  # Arrays, including both `self` and `other_arrays`.
  # *   The number of combinations is the product of the sizes of all the arrays,
  #     including both `self` and `other_arrays`.
  # *   The order of the returned combinations is indeterminate.
  #
  #
  # When no block is given, returns the combinations as an Array of Arrays:
  #     a = [0, 1, 2]
  #     a1 = [3, 4]
  #     a2 = [5, 6]
  #     p = a.product(a1)
  #     p.size # => 6 # a.size * a1.size
  #     p # => [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]
  #     p = a.product(a1, a2)
  #     p.size # => 12 # a.size * a1.size * a2.size
  #     p # => [[0, 3, 5], [0, 3, 6], [0, 4, 5], [0, 4, 6], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]
  #
  # If any argument is an empty Array, returns an empty Array.
  #
  # If no argument is given, returns an Array of 1-element Arrays, each containing
  # an element of `self`:
  #     a.product # => [[0], [1], [2]]
  #
  # When a block is given, yields each combination as an Array; returns `self`:
  #     a.product(a1) {|combination| p combination }
  #
  # Output:
  #     [0, 3]
  #     [0, 4]
  #     [1, 3]
  #     [1, 4]
  #     [2, 3]
  #     [2, 4]
  #
  # If any argument is an empty Array, does not call the block:
  #     a.product(a1, a2, []) {|combination| fail 'Cannot happen' }
  #
  # If no argument is given, yields each element of `self` as a 1-element Array:
  #     a.product {|combination| p combination }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  def product: () -> ::Array[[ Elem ]]
             | [X] (::Array[X] other_ary) -> ::Array[[ Elem, X ]]
             | [X, Y] (::Array[X] other_ary1, ::Array[Y] other_ary2) -> ::Array[[ Elem, X, Y ]]
             | [U] (*::Array[U] other_arys) -> ::Array[::Array[Elem | U]]

  # <!--
  #   rdoc-file=array.c
  #   - array.push(*objects) -> self
  # -->
  # Appends trailing elements.
  #
  # Appends each argument in `objects` to `self`;  returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]
  #
  # Appends each argument as one element, even if it is another Array:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.push([:baz, :bat], [:bam, :bad])
  #     a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
  #
  # Array#append is an alias for Array#push.
  #
  # Related: #pop, #shift, #unshift.
  #
  def push: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.rassoc(obj) -> found_array or nil
  # -->
  # Returns the first element in `self` that is an Array whose second element `==`
  # `obj`:
  #     a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
  #     a.rassoc(4) # => [2, 4]
  #
  # Returns `nil` if no such element is found.
  #
  # Related: #assoc.
  #
  alias rassoc assoc

  # <!--
  #   rdoc-file=array.c
  #   - array.reject {|element| ... } -> new_array
  #   - array.reject -> new_enumerator
  # -->
  # Returns a new Array whose elements are all those from `self` for which the
  # block returns `false` or `nil`:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a1 = a.reject {|element| element.to_s.start_with?('b') }
  #     a1 # => [:foo, 2]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.reject # => #<Enumerator: [:foo, "bar", 2]:reject>
  #
  alias reject delete_if

  # <!--
  #   rdoc-file=array.c
  #   - array.reject! {|element| ... } -> self or nil
  #   - array.reject! -> new_enumerator
  # -->
  # Removes each element for which the block returns a truthy value.
  #
  # Returns `self` if any elements removed:
  #     a = [:foo, 'bar', 2, 'bat']
  #     a.reject! {|element| element.to_s.start_with?('b') } # => [:foo, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2]
  #     a.reject! # => #<Enumerator: [:foo, "bar", 2]:reject!>
  #
  def reject!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.repeated_combination(n) {|combination| ... } -> self
  #   - array.repeated_combination(n) -> new_enumerator
  # -->
  # Calls the block with each repeated combination of length `n` of the elements
  # of `self`; each combination is an Array; returns `self`. The order of the
  # combinations is indeterminate.
  #
  # When a block and a positive Integer argument `n` are given, calls the block
  # with each `n`-tuple repeated combination of the elements of `self`. The number
  # of combinations is `(n+1)(n+2)/2`.
  #
  # `n` = 1:
  #     a = [0, 1, 2]
  #     a.repeated_combination(1) {|combination| p combination }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  # `n` = 2:
  #     a.repeated_combination(2) {|combination| p combination }
  #
  # Output:
  #     [0, 0]
  #     [0, 1]
  #     [0, 2]
  #     [1, 1]
  #     [1, 2]
  #     [2, 2]
  #
  # If `n` is zero, calls the block once with an empty Array.
  #
  # If `n` is negative, does not call the block:
  #     a.repeated_combination(-1) {|combination| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.repeated_combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>
  #
  # Using Enumerators, it's convenient to show the combinations and counts for
  # some values of `n`:
  #     e = a.repeated_combination(0)
  #     e.size # => 1
  #     e.to_a # => [[]]
  #     e = a.repeated_combination(1)
  #     e.size # => 3
  #     e.to_a # => [[0], [1], [2]]
  #     e = a.repeated_combination(2)
  #     e.size # => 6
  #     e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]
  #
  def repeated_combination: (int n) { (::Array[Elem] c) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=array.c
  #   - array.repeated_permutation(n) {|permutation| ... } -> self
  #   - array.repeated_permutation(n) -> new_enumerator
  # -->
  # Calls the block with each repeated permutation of length `n` of the elements
  # of `self`; each permutation is an Array; returns `self`. The order of the
  # permutations is indeterminate.
  #
  # When a block and a positive Integer argument `n` are given, calls the block
  # with each `n`-tuple repeated permutation of the elements of `self`. The number
  # of permutations is `self.size**n`.
  #
  # `n` = 1:
  #     a = [0, 1, 2]
  #     a.repeated_permutation(1) {|permutation| p permutation }
  #
  # Output:
  #     [0]
  #     [1]
  #     [2]
  #
  # `n` = 2:
  #     a.repeated_permutation(2) {|permutation| p permutation }
  #
  # Output:
  #     [0, 0]
  #     [0, 1]
  #     [0, 2]
  #     [1, 0]
  #     [1, 1]
  #     [1, 2]
  #     [2, 0]
  #     [2, 1]
  #     [2, 2]
  #
  # If `n` is zero, calls the block once with an empty Array.
  #
  # If `n` is negative, does not call the block:
  #     a.repeated_permutation(-1) {|permutation| fail 'Cannot happen' }
  #
  # Returns a new Enumerator if no block given:
  #     a = [0, 1, 2]
  #     a.repeated_permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>
  #
  # Using Enumerators, it's convenient to show the permutations and counts for
  # some values of `n`:
  #     e = a.repeated_permutation(0)
  #     e.size # => 1
  #     e.to_a # => [[]]
  #     e = a.repeated_permutation(1)
  #     e.size # => 3
  #     e.to_a # => [[0], [1], [2]]
  #     e = a.repeated_permutation(2)
  #     e.size # => 9
  #     e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
  #
  def repeated_permutation: (int n) { (::Array[Elem] p) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  # <!-- rdoc-file=array.c -->
  # Replaces the content of `self` with the content of `other_array`; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
  #
  def replace: (::Array[Elem]) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse -> new_array
  # -->
  # Returns a new Array with the elements of `self` in reverse order.
  #     a = ['foo', 'bar', 'two']
  #     a1 = a.reverse
  #     a1 # => ["two", "bar", "foo"]
  #
  def reverse: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse! -> self
  # -->
  # Reverses `self` in place:
  #     a = ['foo', 'bar', 'two']
  #     a.reverse! # => ["two", "bar", "foo"]
  #
  def reverse!: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.reverse_each {|element| ... } -> self
  #   - array.reverse_each -> Enumerator
  # -->
  # Iterates backwards over array elements.
  #
  # When a block given, passes, in reverse order, each element to the block;
  # returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.reverse_each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Integer 2
  #     String bar
  #     Symbol foo
  #
  # Allows the array to be modified during iteration:
  #     a = [:foo, 'bar', 2]
  #     a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
  #
  # Output:
  #     2
  #     bar
  #
  # When no block given, returns a new Enumerator:
  #     a = [:foo, 'bar', 2]
  #     e = a.reverse_each
  #     e # => #<Enumerator: [:foo, "bar", 2]:reverse_each>
  #     a1 = e.each {|element|  puts "#{element.class} #{element}" }
  #
  # Output:
  #     Integer 2
  #     String bar
  #     Symbol foo
  #
  # Related: #each, #each_index.
  #
  def reverse_each: () { (Elem item) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=array.c
  #   - array.rindex(object) -> integer or nil
  #   - array.rindex {|element| ... } -> integer or nil
  #   - array.rindex -> new_enumerator
  # -->
  # Returns the index of the last element for which `object == element`.
  #
  # When argument `object` is given but no block, returns the index of the last
  # such element found:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex('bar') # => 3
  #
  # Returns `nil` if no such object found.
  #
  # When a block is given but no argument, calls the block with each successive
  # element; returns the index of the last element for which the block returns a
  # truthy value:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rindex {|element| element == 'bar' } # => 3
  #
  # Returns `nil` if the block never returns a truthy value.
  #
  # When neither an argument nor a block is given, returns a new Enumerator:
  #
  #     a = [:foo, 'bar', 2, 'bar']
  #     e = a.rindex
  #     e # => #<Enumerator: [:foo, "bar", 2, "bar"]:rindex>
  #     e.each {|element| element == 'bar' } # => 3
  #
  # Related: #index.
  #
  def rindex: (untyped obj) -> ::Integer?
            | () { (Elem item) -> boolish } -> ::Integer?
            | () -> ::Enumerator[Elem, ::Integer?]

  # <!--
  #   rdoc-file=array.c
  #   - array.rotate -> new_array
  #   - array.rotate(count) -> new_array
  # -->
  # Returns a new Array formed from `self` with elements rotated from one end to
  # the other.
  #
  # When no argument given, returns a new Array that is like `self`, except that
  # the first element has been rotated to the last position:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a1 = a.rotate
  #     a1 # => ["bar", 2, "bar", :foo]
  #
  # When given a non-negative Integer `count`, returns a new Array with `count`
  # elements rotated from the beginning to the end:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(2)
  #     a1 # => [2, :foo, "bar"]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(20)
  #     a1 # => [2, :foo, "bar"]
  #
  # If `count` is zero, returns a copy of `self`, unmodified:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(0)
  #     a1 # => [:foo, "bar", 2]
  #
  # When given a negative Integer `count`, rotates in the opposite direction, from
  # end to beginning:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(-2)
  #     a1 # => ["bar", 2, :foo]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a1 = a.rotate(-5)
  #     a1 # => ["bar", 2, :foo]
  #
  def rotate: (?int count) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.rotate! -> self
  #   - array.rotate!(count) -> self
  # -->
  # Rotates `self` in place by moving elements from one end to the other; returns
  # `self`.
  #
  # When no argument given, rotates the first element to the last position:
  #     a = [:foo, 'bar', 2, 'bar']
  #     a.rotate! # => ["bar", 2, "bar", :foo]
  #
  # When given a non-negative Integer `count`, rotates `count` elements from the
  # beginning to the end:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(2)
  #     a # => [2, :foo, "bar"]
  #
  # If `count` is large, uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(20)
  #     a # => [2, :foo, "bar"]
  #
  # If `count` is zero, returns `self` unmodified:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(0)
  #     a # => [:foo, "bar", 2]
  #
  # When given a negative Integer `count`, rotates in the opposite direction, from
  # end to beginning:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(-2)
  #     a # => ["bar", 2, :foo]
  #
  # If `count` is small (far from zero), uses `count % array.size` as the count:
  #     a = [:foo, 'bar', 2]
  #     a.rotate!(-5)
  #     a # => ["bar", 2, :foo]
  #
  def rotate!: (?int count) -> self

  # <!--
  #   rdoc-file=array.rb
  #   - array.sample(random: Random) -> object
  #   - array.sample(n, random: Random) -> new_ary
  # -->
  # Returns random elements from `self`.
  #
  # When no arguments are given, returns a random element from `self`:
  #     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a.sample # => 3
  #     a.sample # => 8
  #
  # If `self` is empty, returns `nil`.
  #
  # When argument `n` is given, returns a new Array containing `n` random elements
  # from `self`:
  #     a.sample(3) # => [8, 9, 2]
  #     a.sample(6) # => [9, 6, 10, 3, 1, 4]
  #
  # Returns no more than `a.size` elements (because no new duplicates are
  # introduced):
  #     a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]
  #
  # But `self` may contain duplicates:
  #     a = [1, 1, 1, 2, 2, 3]
  #     a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2]
  #
  # The argument `n` must be a non-negative numeric value. The order of the result
  # array is unrelated to the order of `self`. Returns a new empty Array if `self`
  # is empty.
  #
  # The optional `random` argument will be used as the random number generator:
  #     a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a.sample(random: Random.new(1))     #=> 6
  #     a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2]
  #
  def sample: (?random: _Rand rng) -> Elem?
            | (int n, ?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.select {|element| ... } -> new_array
  #   - array.select -> new_enumerator
  # -->
  # Calls the block, if given, with each element of `self`; returns a new Array
  # containing those elements of `self` for which the block returns a truthy
  # value:
  #     a = [:foo, 'bar', 2, :bam]
  #     a1 = a.select {|element| element.to_s.start_with?('b') }
  #     a1 # => ["bar", :bam]
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>
  #
  # Array#filter is an alias for Array#select.
  #
  def select: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.select! {|element| ... } -> self or nil
  #   - array.select! -> new_enumerator
  # -->
  # Calls the block, if given  with each element of `self`; removes from `self`
  # those elements for which the block returns `false` or `nil`.
  #
  # Returns `self` if any elements were removed:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]
  #
  # Returns `nil` if no elements were removed.
  #
  # Returns a new Enumerator if no block given:
  #     a = [:foo, 'bar', 2, :bam]
  #     a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>
  #
  # Array#filter! is an alias for Array#select!.
  #
  def select!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  # <!--
  #   rdoc-file=array.c
  #   - array.shift -> object or nil
  #   - array.shift(n) -> new_array
  # -->
  # Removes and returns leading elements.
  #
  # When no argument is given, removes and returns the first element:
  #     a = [:foo, 'bar', 2]
  #     a.shift # => :foo
  #     a # => ['bar', 2]
  #
  # Returns `nil` if `self` is empty.
  #
  # When positive Integer argument `n` is given, removes the first `n` elements;
  # returns those elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.shift(2) # => [:foo, 'bar']
  #     a # => [2]
  #
  # If `n` is as large as or larger than `self.length`, removes all elements;
  # returns those elements in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.shift(3) # => [:foo, 'bar', 2]
  #
  # If `n` is zero, returns a new empty Array; `self` is unmodified.
  #
  # Related: #push, #pop, #unshift.
  #
  def shift: () -> Elem?
           | (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - array.shuffle(random: Random) -> new_ary
  # -->
  # Returns a new array with elements of `self` shuffled.
  #     a = [1, 2, 3] #=> [1, 2, 3]
  #     a.shuffle     #=> [2, 3, 1]
  #     a             #=> [1, 2, 3]
  #
  # The optional `random` argument will be used as the random number generator:
  #     a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
  #
  def shuffle: (?random: _Rand rng) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.rb
  #   - array.shuffle!(random: Random) -> array
  # -->
  # Shuffles the elements of `self` in place.
  #     a = [1, 2, 3] #=> [1, 2, 3]
  #     a.shuffle!    #=> [2, 3, 1]
  #     a             #=> [2, 3, 1]
  #
  # The optional `random` argument will be used as the random number generator:
  #     a.shuffle!(random: Random.new(1))  #=> [1, 3, 2]
  #
  def shuffle!: (?random: _Rand rng) -> self

  # <!-- rdoc-file=array.c -->
  # Returns the count of elements in `self`.
  #
  alias size length

  # <!-- rdoc-file=array.c -->
  # Returns elements from `self`; does not modify `self`.
  #
  # When a single Integer argument `index` is given, returns the element at offset
  # `index`:
  #     a = [:foo, 'bar', 2]
  #     a[0] # => :foo
  #     a[2] # => 2
  #     a # => [:foo, "bar", 2]
  #
  # If `index` is negative, counts relative to the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a[-1] # => 2
  #     a[-2] # => "bar"
  #
  # If `index` is out of range, returns `nil`.
  #
  # When two Integer arguments `start` and `length` are given, returns a new Array
  # of size `length` containing successive elements beginning at offset `start`:
  #     a = [:foo, 'bar', 2]
  #     a[0, 2] # => [:foo, "bar"]
  #     a[1, 2] # => ["bar", 2]
  #
  # If `start + length` is greater than `self.length`, returns all elements from
  # offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a[0, 4] # => [:foo, "bar", 2]
  #     a[1, 3] # => ["bar", 2]
  #     a[2, 2] # => [2]
  #
  # If `start == self.size` and `length >= 0`, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When a single Range argument `range` is given, treats `range.min` as `start`
  # above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #     a[0..1] # => [:foo, "bar"]
  #     a[1..2] # => ["bar", 2]
  #
  # Special case: If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.end` is negative, calculates the end index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[0..-1] # => [:foo, "bar", 2]
  #     a[0..-2] # => [:foo, "bar"]
  #     a[0..-3] # => [:foo]
  #
  # If `range.start` is negative, calculates the start index from the end:
  #     a = [:foo, 'bar', 2]
  #     a[-1..2] # => [2]
  #     a[-2..2] # => ["bar", 2]
  #     a[-3..2] # => [:foo, "bar", 2]
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #     a = [:foo, 'bar', 2]
  #     a[4..1] # => nil
  #     a[4..0] # => nil
  #     a[4..-1] # => nil
  #
  # When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
  # an Array of elements corresponding to the indexes produced by the sequence.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..).step(2)] # => ["data1", "data2", "data3"]
  #
  # Unlike slicing with range, if the start or the end of the arithmetic sequence
  # is larger than array size, throws RangeError.
  #     a = ['--', 'data1', '--', 'data2', '--', 'data3']
  #     a[(1..11).step(2)]
  #     # RangeError (((1..11).step(2)) out of range)
  #     a[(7..).step(2)]
  #     # RangeError (((7..).step(2)) out of range)
  #
  # If given a single argument, and its type is not one of the listed, tries to
  # convert it to Integer, and raises if it is impossible:
  #     a = [:foo, 'bar', 2]
  #     # Raises TypeError (no implicit conversion of Symbol into Integer):
  #     a[:foo]
  #
  # Array#slice is an alias for Array#[].
  #
  def slice: (int index) -> Elem?
           | (int start, int length) -> ::Array[Elem]?
           | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array.slice!(n) -> object or nil
  #   - array.slice!(start, length) -> new_array or nil
  #   - array.slice!(range) -> new_array or nil
  # -->
  # Removes and returns elements from `self`.
  #
  # When the only argument is an Integer `n`, removes and returns the *nth*
  # element in `self`:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(1) # => "bar"
  #     a # => [:foo, 2]
  #
  # If `n` is negative, counts backwards from the end of `self`:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(-1) # => 2
  #     a # => [:foo, "bar"]
  #
  # If `n` is out of range, returns `nil`.
  #
  # When the only arguments are Integers `start` and `length`, removes `length`
  # elements from `self` beginning at offset  `start`; returns the deleted objects
  # in a new Array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(0, 2) # => [:foo, "bar"]
  #     a # => [2]
  #
  # If `start + length` exceeds the array size, removes and returns all elements
  # from offset `start` to the end:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(1, 50) # => ["bar", 2]
  #     a # => [:foo]
  #
  # If `start == a.size` and `length` is non-negative, returns a new empty Array.
  #
  # If `length` is negative, returns `nil`.
  #
  # When the only argument is a Range object `range`, treats `range.min` as
  # `start` above and `range.size` as `length` above:
  #     a = [:foo, 'bar', 2]
  #      a.slice!(1..2) # => ["bar", 2]
  #     a # => [:foo]
  #
  # If `range.start == a.size`, returns a new empty Array.
  #
  # If `range.start` is larger than the array size, returns `nil`.
  #
  # If `range.end` is negative, counts backwards from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(0..-2) # => [:foo, "bar"]
  #     a # => [2]
  #
  # If `range.start` is negative, calculates the start index backwards from the
  # end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.slice!(-2..2) # => ["bar", 2]
  #     a # => [:foo]
  #
  def slice!: (int index) -> Elem?
            | (int start, int length) -> ::Array[Elem]?
            | (::Range[::Integer] range) -> ::Array[Elem]?

  # <!--
  #   rdoc-file=array.c
  #   - array.sort -> new_array
  #   - array.sort {|a, b| ... } -> new_array
  # -->
  # Returns a new Array whose elements are those from `self`, sorted.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort
  #     a1 # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| a <=> b }
  #     a1 # => ["a", "b", "c", "d", "e"]
  #     a2 = a.sort {|a, b| b <=> a }
  #     a2 # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a1 = a.sort {|a, b| 0 }
  #     a1 # =>  ["c", "e", "b", "d", "a"]
  #
  # Related: Enumerable#sort_by.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem a, Elem b) -> ::Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.sort! -> self
  #   - array.sort! {|a, b| ... } -> self
  # -->
  # Returns `self` with its elements sorted in place.
  #
  # With no block, compares elements using operator `<=>` (see Comparable):
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort!
  #     a # => ["a", "b", "c", "d", "e"]
  #
  # With a block, calls the block with each element pair; for each element pair
  # `a` and `b`, the block should return an integer:
  # *   Negative when `b` is to follow `a`.
  # *   Zero when `a` and `b` are equivalent.
  # *   Positive when `a` is to follow `b`.
  #
  #
  # Example:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| a <=> b }
  #     a # => ["a", "b", "c", "d", "e"]
  #     a.sort! {|a, b| b <=> a }
  #     a # => ["e", "d", "c", "b", "a"]
  #
  # When the block returns zero, the order for `a` and `b` is indeterminate, and
  # may be unstable:
  #     a = 'abcde'.split('').shuffle
  #     a # => ["e", "b", "d", "a", "c"]
  #     a.sort! {|a, b| 0 }
  #     a # => ["d", "e", "c", "a", "b"]
  #
  def sort!: () -> self
           | () { (Elem a, Elem b) -> ::Integer } -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.sort_by! {|element| ... } -> self
  #   - array.sort_by! -> new_enumerator
  # -->
  # Sorts the elements of `self` in place, using an ordering determined by the
  # block; returns self.
  #
  # Calls the block with each successive element; sorts elements based on the
  # values returned from the block.
  #
  # For duplicates returned by the block, the ordering is indeterminate, and may
  # be unstable.
  #
  # This example sorts strings based on their sizes:
  #     a = ['aaaa', 'bbb', 'cc', 'd']
  #     a.sort_by! {|element| element.size }
  #     a # => ["d", "cc", "bbb", "aaaa"]
  #
  # Returns a new Enumerator if no block given:
  #
  #     a = ['aaaa', 'bbb', 'cc', 'd']
  #     a.sort_by! # => #<Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!>
  #
  def sort_by!: [U] () { (Elem obj) -> U } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - array.sum(init = 0) -> object
  #   - array.sum(init = 0) {|element| ... } -> object
  # -->
  # When no block is given, returns the object equivalent to:
  #     sum = init
  #     array.each {|element| sum += element }
  #     sum
  #
  # For example, `[e1, e2, e3].sum` returns `init + e1 + e2 + e3`.
  #
  # Examples:
  #     a = [0, 1, 2, 3]
  #     a.sum # => 6
  #     a.sum(100) # => 106
  #
  # The elements need not be numeric, but must be `+`-compatible with each other
  # and with `init`:
  #     a = ['abc', 'def', 'ghi']
  #     a.sum('jkl') # => "jklabcdefghi"
  #
  # When a block is given, it is called with each element and the block's return
  # value (instead of the element itself) is used as the addend:
  #     a = ['zero', 1, :two]
  #     s = a.sum('Coerced and concatenated: ') {|element| element.to_s }
  #     s # => "Coerced and concatenated: zero1two"
  #
  # Notes:
  # *   Array#join and Array#flatten may be faster than Array#sum for an Array of
  #     Strings or an Array of Arrays.
  # *   Array#sum method may not respect method redefinition of "+" methods such
  #     as Integer#+.
  #
  def sum: (?untyped init) -> untyped
         | (?untyped init) { (Elem e) -> untyped } -> untyped

  # <!--
  #   rdoc-file=array.c
  #   - array.take(n) -> new_array
  # -->
  # Returns a new Array containing the first `n` element of `self`, where `n` is a
  # non-negative Integer; does not modify `self`.
  #
  # Examples:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.take(1) # => [0]
  #     a.take(2) # => [0, 1]
  #     a.take(50) # => [0, 1, 2, 3, 4, 5]
  #     a # => [0, 1, 2, 3, 4, 5]
  #
  def take: (int n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.take_while {|element| ... } -> new_array
  #   - array.take_while -> new_enumerator
  # -->
  # Returns a new Array containing zero or more leading elements of `self`; does
  # not modify `self`.
  #
  # With a block given, calls the block with each successive element of `self`;
  # stops if the block returns `false` or `nil`; returns a new Array containing
  # those elements for which the block returned a truthy value:
  #     a = [0, 1, 2, 3, 4, 5]
  #     a.take_while {|element| element < 3 } # => [0, 1, 2]
  #     a.take_while {|element| true } # => [0, 1, 2, 3, 4, 5]
  #     a # => [0, 1, 2, 3, 4, 5]
  #
  # With no block given, returns a new Enumerator:
  #     [0, 1].take_while # => #<Enumerator: [0, 1]:take_while>
  #
  def take_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=array.c
  #   - to_a -> self or new_array
  # -->
  # When `self` is an instance of Array, returns `self`:
  #     a = [:foo, 'bar', 2]
  #     a.to_a # => [:foo, "bar", 2]
  #
  # Otherwise, returns a new Array containing the elements of `self`:
  #     class MyArray < Array; end
  #     a = MyArray.new(['foo', 'bar', 'two'])
  #     a.instance_of?(Array) # => false
  #     a.kind_of?(Array) # => true
  #     a1 = a.to_a
  #     a1 # => ["foo", "bar", "two"]
  #     a1.class # => Array # Not MyArray
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.to_ary -> self
  # -->
  # Returns `self`.
  #
  def to_ary: () -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.to_h -> new_hash
  #   - array.to_h {|item| ... } -> new_hash
  # -->
  # Returns a new Hash formed from `self`.
  #
  # When a block is given, calls the block with each array element; the block must
  # return a 2-element Array whose two elements form a key-value pair in the
  # returned Hash:
  #     a = ['foo', :bar, 1, [2, 3], {baz: 4}]
  #     h = a.to_h {|item| [item, item] }
  #     h # => {"foo"=>"foo", :bar=>:bar, 1=>1, [2, 3]=>[2, 3], {:baz=>4}=>{:baz=>4}}
  #
  # When no block is given, `self` must be an Array of 2-element sub-arrays, each
  # sub-array is formed into a key-value pair in the new Hash:
  #     [].to_h # => {}
  #     a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
  #     h = a.to_h
  #     h # => {"foo"=>"zero", "bar"=>"one", "baz"=>"two"}
  #
  def to_h: () -> Hash[untyped, untyped]
          | [T, S] () { (Elem) -> [ T, S ] } -> Hash[T, S]

  # <!-- rdoc-file=array.c -->
  # Returns the new String formed by calling method `#inspect` on each array
  # element:
  #     a = [:foo, 'bar', 2]
  #     a.inspect # => "[:foo, \"bar\", 2]"
  #
  # Array#to_s is an alias for Array#inspect.
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=array.c
  #   - array.transpose -> new_array
  # -->
  # Transposes the rows and columns in an Array of Arrays; the nested Arrays must
  # all be the same size:
  #     a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
  #     a.transpose # => [[:a0, :b0, :c0], [:a1, :b1, :c1]]
  #
  def transpose: () -> ::Array[::Array[untyped]]

  # <!--
  #   rdoc-file=array.c
  #   - array.union(*other_arrays) -> new_array
  # -->
  # Returns a new Array that is the union of `self` and all given Arrays
  # `other_arrays`; duplicates are removed;  order is preserved;  items are
  # compared using `eql?`:
  #     [0, 1, 2, 3].union([4, 5], [6, 7]) # => [0, 1, 2, 3, 4, 5, 6, 7]
  #     [0, 1, 1].union([2, 1], [3, 1]) # => [0, 1, 2, 3]
  #     [0, 1, 2, 3].union([3, 2], [1, 0]) # => [0, 1, 2, 3]
  #
  # Returns a copy of `self` if no arguments given.
  #
  # Related: Array#|.
  #
  def union: [T] (*::Array[T] other_arys) -> ::Array[T | Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.uniq -> new_array
  #   - array.uniq {|element| ... } -> new_array
  # -->
  # Returns a new Array containing those elements from `self` that are not
  # duplicates, the first occurrence always being retained.
  #
  # With no block given, identifies and omits duplicates using method `eql?` to
  # compare.
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq # => [0, 1, 2]
  #
  # With a block given, calls the block for each element; identifies (using method
  # `eql?`) and omits duplicate values, that is, those elements for which the
  # block returns the same value:
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq {|element| element.size } # => ["a", "aa", "aaa"]
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=array.c
  #   - array.uniq! -> self or nil
  #   - array.uniq! {|element| ... } -> self or nil
  # -->
  # Removes duplicate elements from `self`, the first occurrence always being
  # retained; returns `self` if any elements removed, `nil` otherwise.
  #
  # With no block given, identifies and removes elements using method `eql?` to
  # compare.
  #
  # Returns `self` if any elements removed:
  #     a = [0, 0, 1, 1, 2, 2]
  #     a.uniq! # => [0, 1, 2]
  #
  # Returns `nil` if no elements removed.
  #
  # With a block given, calls the block for each element; identifies (using method
  # `eql?`) and removes elements for which the block returns duplicate values.
  #
  # Returns `self` if any elements removed:
  #     a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
  #     a.uniq! {|element| element.size } # => ['a', 'aa', 'aaa']
  #
  # Returns `nil` if no elements removed.
  #
  def uniq!: () -> self?
           | () { (Elem) -> untyped } -> self?

  # <!--
  #   rdoc-file=array.c
  #   - array.unshift(*objects) -> self
  # -->
  # Prepends the given `objects` to `self`:
  #     a = [:foo, 'bar', 2]
  #     a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]
  #
  # Array#prepend is an alias for Array#unshift.
  #
  # Related: #push, #pop, #shift.
  #
  def unshift: (*Elem obj) -> self

  # <!--
  #   rdoc-file=array.c
  #   - array.values_at(*indexes) -> new_array
  # -->
  # Returns a new Array whose elements are the elements of `self` at the given
  # Integer or Range `indexes`.
  #
  # For each positive `index`, returns the element at offset `index`:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, 2) # => [:foo, 2]
  #     a.values_at(0..1) # => [:foo, "bar"]
  #
  # The given `indexes` may be in any order, and may repeat:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(2, 0, 1, 0, 2) # => [2, :foo, "bar", :foo, 2]
  #     a.values_at(1, 0..2) # => ["bar", :foo, "bar", 2]
  #
  # Assigns `nil` for an `index` that is too large:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, 3, 1, 3) # => [:foo, nil, "bar", nil]
  #
  # Returns a new empty Array if no arguments given.
  #
  # For each negative `index`, counts backward from the end of the array:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(-1, -3) # => [2, :foo]
  #
  # Assigns `nil` for an `index` that is too small:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, -5, 1, -6, 2) # => [:foo, nil, "bar", nil, 2]
  #
  # The given `indexes` may have a mixture of signs:
  #     a = [:foo, 'bar', 2]
  #     a.values_at(0, -2, 1, -1) # => [:foo, "bar", "bar", 2]
  #
  def values_at: (*int | ::Range[::Integer] selector) -> ::Array[Elem?]

  # <!--
  #   rdoc-file=array.c
  #   - array.zip(*other_arrays) -> new_array
  #   - array.zip(*other_arrays) {|other_array| ... } -> nil
  # -->
  # When no block given, returns a new Array `new_array` of size `self.size` whose
  # elements are Arrays.
  #
  # Each nested array `new_array[n]` is of size `other_arrays.size+1`, and
  # contains:
  # *   The *nth* element of `self`.
  # *   The *nth* element of each of the `other_arrays`.
  #
  #
  # If all `other_arrays` and `self` are the same size:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # If any array in `other_arrays` is smaller than `self`, fills to `self.size`
  # with `nil`:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
  #
  # If any array in `other_arrays` is larger than `self`, its trailing elements
  # are ignored:
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # When a block is given, calls the block with each of the sub-arrays (formed as
  # above); returns nil
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| p sub_array} # => nil
  #
  # Output:
  #     [:a0, :b0, :c0]
  #     [:a1, :b1, :c1]
  #     [:a2, :b2, :c2]
  #     [:a3, :b3, :c3]
  #
  def zip: [U] (::Array[U] arg) -> ::Array[[ Elem, U? ]]
         | (::Array[untyped] arg, *::Array[untyped] args) -> ::Array[::Array[untyped]]
         | [U] (::Array[U] arg) { ([ Elem, U? ]) -> void } -> void
         | (::Array[untyped] arg, *::Array[untyped] args) { (::Array[untyped]) -> void } -> void

  # <!--
  #   rdoc-file=array.c
  #   - array | other_array -> new_array
  # -->
  # Returns the union of `array` and Array `other_array`; duplicates are removed;
  # order is preserved; items are compared using `eql?`:
  #     [0, 1] | [2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 1] | [2, 2, 3] # => [0, 1, 2, 3]
  #     [0, 1, 2] | [3, 2, 1, 0] # => [0, 1, 2, 3]
  #
  # Related: Array#union.
  #
  def |: [T] (::Array[T] other_ary) -> ::Array[Elem | T]

  private

  # <!--
  #   rdoc-file=array.c
  #   - array.replace(other_array) -> self
  # -->
  # Replaces the content of `self` with the content of `other_array`; returns
  # `self`:
  #     a = [:foo, 'bar', 2]
  #     a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
  #
  def initialize_copy: (self other_ary) -> void
end

interface _ToA[T]
  def to_a: () -> Array[T]
end

interface _ToAry[T]
  def to_ary: () -> ::Array[T]
end

interface _Rand
  def rand: (::Integer max) -> ::Integer
end

interface Array::_Pattern[T]
  def ===: (T) -> bool
end

# <!-- rdoc-file=compar.c -->
# The Comparable mixin is used by classes whose objects may be ordered. The
# class must define the `<=>` operator, which compares the receiver against
# another object, returning a value less than 0, returning 0, or returning a
# value greater than 0, depending on whether the receiver is less than, equal
# to, or greater than the other object. If the other object is not comparable
# then the `<=>` operator should return `nil`. Comparable uses `<=>` to
# implement the conventional comparison operators (`<`, `<=`, `==`, `>=`, and
# `>`) and the method `between?`.
#
#     class SizeMatters
#       include Comparable
#       attr :str
#       def <=>(other)
#         str.size <=> other.str.size
#       end
#       def initialize(str)
#         @str = str
#       end
#       def inspect
#         @str
#       end
#     end
#
#     s1 = SizeMatters.new("Z")
#     s2 = SizeMatters.new("YY")
#     s3 = SizeMatters.new("XXX")
#     s4 = SizeMatters.new("WWWW")
#     s5 = SizeMatters.new("VVVVV")
#
#     s1 < s2                       #=> true
#     s4.between?(s1, s3)           #=> false
#     s4.between?(s3, s5)           #=> true
#     [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]
#
# ## What's Here
#
# Module Comparable provides these methods, all of which use method `<=>`:
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given object.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given object.
#
#     [==](#method-i-3D-3D)
# :       Returns whether `self` is equal to the given object.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than or equal to the given object.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than the given object.
#
# *   #between? Returns `true` if `self` is between two given objects.
#     #clamp
# :       For given objects `min` and `max`, or range `(min..max)`, returns:
#
#     *   `min` if `(self <=> min) < 0`.
#     *   `max` if `(self <=> max) > 0`.
#     *   `self` otherwise.
#
module Comparable : _WithSpaceshipOperator
  # <!--
  #   rdoc-file=compar.c
  #   - obj < other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than 0.
  #
  def <: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj <= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value less than or equal to 0.
  #
  def <=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj == other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns 0. Also returns true if *obj* and *other* are the same object.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj > other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than 0.
  #
  def >: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj >= other    -> true or false
  # -->
  # Compares two objects based on the receiver's `<=>` method, returning true if
  # it returns a value greater than or equal to 0.
  #
  def >=: (untyped other) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.between?(min, max)    -> true or false
  # -->
  # Returns `false` if *obj* `<=>` *min* is less than zero or if *obj* `<=>` *max*
  # is greater than zero, `true` otherwise.
  #
  #     3.between?(1, 5)               #=> true
  #     6.between?(1, 5)               #=> false
  #     'cat'.between?('ant', 'dog')   #=> true
  #     'gnu'.between?('ant', 'dog')   #=> false
  #
  def between?: (untyped min, untyped max) -> bool

  # <!--
  #   rdoc-file=compar.c
  #   - obj.clamp(min, max) ->  obj
  #   - obj.clamp(range)    ->  obj
  # -->
  # In `(min, max)` form, returns *min* if *obj* `<=>` *min* is less than zero,
  # *max* if *obj* `<=>` *max* is greater than zero, and *obj* otherwise.
  #
  #     12.clamp(0, 100)         #=> 12
  #     523.clamp(0, 100)        #=> 100
  #     -3.123.clamp(0, 100)     #=> 0
  #
  #     'd'.clamp('a', 'f')      #=> 'd'
  #     'z'.clamp('a', 'f')      #=> 'f'
  #
  # In `(range)` form, returns *range.begin* if *obj* `<=>` *range.begin* is less
  # than zero, *range.end* if *obj* `<=>` *range.end* is greater than zero, and
  # *obj* otherwise.
  #
  #     12.clamp(0..100)         #=> 12
  #     523.clamp(0..100)        #=> 100
  #     -3.123.clamp(0..100)     #=> 0
  #
  #     'd'.clamp('a'..'f')      #=> 'd'
  #     'z'.clamp('a'..'f')      #=> 'f'
  #
  # If *range.begin* is `nil`, it is considered smaller than *obj*, and if
  # *range.end* is `nil`, it is considered greater than *obj*.
  #
  #     -20.clamp(0..)           #=> 0
  #     523.clamp(..100)         #=> 100
  #
  # When *range.end* is excluded and not `nil`, an exception is raised.
  #
  #     100.clamp(0...100)       # ArgumentError
  #
  def clamp: [A, B] (A min, B max) -> (self | A | B)
           | [A] (Range[A]) -> (self | A)
end

# This interface defines the condition for Comparable mixin.
#
interface Comparable::_WithSpaceshipOperator
  # `<=>` operator must return Integer or `nil`.
  # If `other` is greater than `self`, it returns a positive Integer.
  # If `other` equals to `self`, it returns zero.
  # If `other` is less than `self`, it returns a positive Integer.
  # If no comparison is defined with `other` and `self`, it returns `nil`.
  #
  def <=>: (untyped other) -> Integer?
end

# <!-- rdoc-file=hash.c -->
# A Hash maps each of its unique keys to a specific value.
#
# A Hash has certain similarities to an Array, but:
# *   An Array index is always an Integer.
# *   A Hash key can be (almost) any object.
#
#
# ### Hash Data Syntax
#
# The older syntax for Hash data uses the "hash rocket," `=>`:
#
#     h = {:foo => 0, :bar => 1, :baz => 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Alternatively, but only for a Hash key that's a Symbol, you can use a newer
# JSON-style syntax, where each bareword becomes a Symbol:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can also use a String in place of a bareword:
#
#     h = {'foo': 0, 'bar': 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# And you can mix the styles:
#
#     h = {foo: 0, :bar => 1, 'baz': 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# But it's an error to try the JSON-style syntax for a key that's not a bareword
# or a String:
#
#     # Raises SyntaxError (syntax error, unexpected ':', expecting =>):
#     h = {0: 'zero'}
#
# Hash value can be omitted, meaning that value will be fetched from the context
# by the name of the key:
#
#     x = 0
#     y = 100
#     h = {x:, y:}
#     h # => {:x=>0, :y=>100}
#
# ### Common Uses
#
# You can use a Hash to give names to objects:
#
#     person = {name: 'Matz', language: 'Ruby'}
#     person # => {:name=>"Matz", :language=>"Ruby"}
#
# You can use a Hash to give names to method arguments:
#
#     def some_method(hash)
#       p hash
#     end
#     some_method({foo: 0, bar: 1, baz: 2}) # => {:foo=>0, :bar=>1, :baz=>2}
#
# Note: when the last argument in a method call is a Hash, the curly braces may
# be omitted:
#
#     some_method(foo: 0, bar: 1, baz: 2) # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can use a Hash to initialize an object:
#
#     class Dev
#       attr_accessor :name, :language
#       def initialize(hash)
#         self.name = hash[:name]
#         self.language = hash[:language]
#       end
#     end
#     matz = Dev.new(name: 'Matz', language: 'Ruby')
#     matz # => #<Dev: @name="Matz", @language="Ruby">
#
# ### Creating a Hash
#
# You can create a Hash object explicitly with:
#
# *   A [hash literal](doc/syntax/literals_rdoc.html#label-Hash+Literals).
#
#
# You can convert certain objects to Hashes with:
#
# *   Method [Hash](Kernel.html#method-i-Hash).
#
#
# You can create a Hash by calling method Hash.new.
#
# Create an empty Hash:
#
#     h = Hash.new
#     h # => {}
#     h.class # => Hash
#
# You can create a Hash by calling method Hash.[].
#
# Create an empty Hash:
#
#     h = Hash[]
#     h # => {}
#
# Create a Hash with initial entries:
#
#     h = Hash[foo: 0, bar: 1, baz: 2]
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# You can create a Hash by using its literal form (curly braces).
#
# Create an empty Hash:
#
#     h = {}
#     h # => {}
#
# Create a Hash with initial entries:
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# ### Hash Value Basics
#
# The simplest way to retrieve a Hash value (instance method #[]):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:foo] # => 0
#
# The simplest way to create or update a Hash value (instance method #[]=):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h[:bat] = 3 # => 3
#     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
#     h[:foo] = 4 # => 4
#     h # => {:foo=>4, :bar=>1, :baz=>2, :bat=>3}
#
# The simplest way to delete a Hash entry (instance method #delete):
#
#     h = {foo: 0, bar: 1, baz: 2}
#     h.delete(:bar) # => 1
#     h # => {:foo=>0, :baz=>2}
#
# ### Entry Order
#
# A Hash object presents its entries in the order of their creation. This is
# seen in:
#
# *   Iterative methods such as `each`, `each_key`, `each_pair`, `each_value`.
# *   Other order-sensitive methods such as `shift`, `keys`, `values`.
# *   The String returned by method `inspect`.
#
#
# A new Hash has its initial ordering per the given entries:
#
#     h = Hash[foo: 0, bar: 1]
#     h # => {:foo=>0, :bar=>1}
#
# New entries are added at the end:
#
#     h[:baz] = 2
#     h # => {:foo=>0, :bar=>1, :baz=>2}
#
# Updating a value does not affect the order:
#
#     h[:baz] = 3
#     h # => {:foo=>0, :bar=>1, :baz=>3}
#
# But re-creating a deleted entry can affect the order:
#
#     h.delete(:foo)
#     h[:foo] = 5
#     h # => {:bar=>1, :baz=>3, :foo=>5}
#
# ### Hash Keys
#
# #### Hash Key Equivalence
#
# Two objects are treated as the same hash key when their `hash` value is
# identical and the two objects are `eql?` to each other.
#
# #### Modifying an Active Hash Key
#
# Modifying a Hash key while it is in use damages the hash's index.
#
# This Hash has keys that are Arrays:
#
#     a0 = [ :foo, :bar ]
#     a1 = [ :baz, :bat ]
#     h = {a0 => 0, a1 => 1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#     a0.hash # => 110002110
#
# Modifying array element `a0[0]` changes its hash value:
#
#     a0[0] = :bam
#     a0.hash # => 1069447059
#
# And damages the Hash index:
#
#     h.include?(a0) # => false
#     h[a0] # => nil
#
# You can repair the hash index using method `rehash`:
#
#     h.rehash # => {[:bam, :bar]=>0, [:baz, :bat]=>1}
#     h.include?(a0) # => true
#     h[a0] # => 0
#
# A String key is always safe. That's because an unfrozen String passed as a key
# will be replaced by a duplicated and frozen String:
#
#     s = 'foo'
#     s.frozen? # => false
#     h = {s => 0}
#     first_key = h.keys.first
#     first_key.frozen? # => true
#
# #### User-Defined Hash Keys
#
# To be useable as a Hash key, objects must implement the methods `hash` and
# `eql?`. Note: this requirement does not apply if the Hash uses
# #compare_by_identity since comparison will then rely on the keys' object id
# instead of `hash` and `eql?`.
#
# Object defines basic implementation for `hash` and `eq?` that makes each
# object a distinct key. Typically, user-defined classes will want to override
# these methods to provide meaningful behavior, or for example inherit Struct
# that has useful definitions for these.
#
# A typical implementation of `hash` is based on the object's data while `eql?`
# is usually aliased to the overridden `==` method:
#
#     class Book
#       attr_reader :author, :title
#
#       def initialize(author, title)
#         @author = author
#         @title = title
#       end
#
#       def ==(other)
#         self.class === other &&
#           other.author == @author &&
#           other.title == @title
#       end
#
#       alias eql? ==
#
#       def hash
#         @author.hash ^ @title.hash # XOR
#       end
#     end
#
#     book1 = Book.new 'matz', 'Ruby in a Nutshell'
#     book2 = Book.new 'matz', 'Ruby in a Nutshell'
#
#     reviews = {}
#
#     reviews[book1] = 'Great reference!'
#     reviews[book2] = 'Nice and compact!'
#
#     reviews.length #=> 1
#
# ### Default Values
#
# The methods #[], #values_at and #dig need to return the value associated to a
# certain key. When that key is not found, that value will be determined by its
# default proc (if any) or else its default (initially `nil`).
#
# You can retrieve the default value with method #default:
#
#     h = Hash.new
#     h.default # => nil
#
# You can set the default value by passing an argument to method Hash.new or
# with method #default=
#
#     h = Hash.new(-1)
#     h.default # => -1
#     h.default = 0
#     h.default # => 0
#
# This default value is returned for #[], #values_at and #dig when a key is not
# found:
#
#     counts = {foo: 42}
#     counts.default # => nil (default)
#     counts[:foo] = 42
#     counts[:bar] # => nil
#     counts.default = 0
#     counts[:bar] # => 0
#     counts.values_at(:foo, :bar, :baz) # => [42, 0, 0]
#     counts.dig(:bar) # => 0
#
# Note that the default value is used without being duplicated. It is not
# advised to set the default value to a mutable object:
#
#     synonyms = Hash.new([])
#     synonyms[:hello] # => []
#     synonyms[:hello] << :hi # => [:hi], but this mutates the default!
#     synonyms.default # => [:hi]
#     synonyms[:world] << :universe
#     synonyms[:world] # => [:hi, :universe], oops
#     synonyms.keys # => [], oops
#
# To use a mutable object as default, it is recommended to use a default proc
#
# #### Default Proc
#
# When the default proc for a Hash is set (i.e., not `nil`), the default value
# returned by method #[] is determined by the default proc alone.
#
# You can retrieve the default proc with method #default_proc:
#
#     h = Hash.new
#     h.default_proc # => nil
#
# You can set the default proc by calling Hash.new with a block or calling the
# method #default_proc=
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h.default_proc.class # => Proc
#     h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
#     h.default_proc.class # => Proc
#
# When the default proc is set (i.e., not `nil`) and method #[] is called with
# with a non-existent key, #[] calls the default proc with both the Hash object
# itself and the missing key, then returns the proc's return value:
#
#     h = Hash.new { |hash, key| "Default value for #{key}" }
#     h[:nosuch] # => "Default value for nosuch"
#
# Note that in the example above no entry for key `:nosuch` is created:
#
#     h.include?(:nosuch) # => false
#
# However, the proc itself can add a new entry:
#
#     synonyms = Hash.new { |hash, key| hash[key] = [] }
#     synonyms.include?(:hello) # => false
#     synonyms[:hello] << :hi # => [:hi]
#     synonyms[:world] << :universe # => [:universe]
#     synonyms.keys # => [:hello, :world]
#
# Note that setting the default proc will clear the default value and vice
# versa.
#
# ### What's Here
#
# First, what's elsewhere. Class Hash:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Hash provides methods that are useful for:
#
# *   [Creating a Hash](#class-Hash-label-Methods+for+Creating+a+Hash)
# *   [Setting Hash State](#class-Hash-label-Methods+for+Setting+Hash+State)
# *   [Querying](#class-Hash-label-Methods+for+Querying)
# *   [Comparing](#class-Hash-label-Methods+for+Comparing)
# *   [Fetching](#class-Hash-label-Methods+for+Fetching)
# *   [Assigning](#class-Hash-label-Methods+for+Assigning)
# *   [Deleting](#class-Hash-label-Methods+for+Deleting)
# *   [Iterating](#class-Hash-label-Methods+for+Iterating)
# *   [Converting](#class-Hash-label-Methods+for+Converting)
# *   [Transforming Keys and
#     Values](#class-Hash-label-Methods+for+Transforming+Keys+and+Values)
# *   [And more....](#class-Hash-label-Other+Methods)
#
#
# Class Hash also includes methods from module Enumerable.
#
# #### Methods for Creating a Hash
#
# ::[]
# :   Returns a new hash populated with given objects.
# ::new
# :   Returns a new empty hash.
# ::try_convert
# :   Returns a new hash created from a given object.
#
#
# #### Methods for Setting Hash State
#
# #compare_by_identity
# :   Sets `self` to consider only identity in comparing keys.
# #default=
# :   Sets the default to a given value.
# #default_proc=
# :   Sets the default proc to a given proc.
# #rehash
# :   Rebuilds the hash table by recomputing the hash index for each key.
#
#
# #### Methods for Querying
#
# #any?
# :   Returns whether any element satisfies a given criterion.
# #compare_by_identity?
# :   Returns whether the hash considers only identity when comparing keys.
# #default
# :   Returns the default value, or the default value for a given key.
# #default_proc
# :   Returns the default proc.
# #empty?
# :   Returns whether there are no entries.
# #eql?
# :   Returns whether a given object is equal to `self`.
# #hash
# :   Returns the integer hash code.
# #has_value?
# :   Returns whether a given object is a value in `self`.
# #include?, #has_key?, #member?, #key?
# :   Returns whether a given object is a key in `self`.
# #length, #size
# :   Returns the count of entries.
# #value?
# :   Returns whether a given object is a value in `self`.
#
#
# #### Methods for Comparing
#
# [#<](#method-i-3C)
# :   Returns whether `self` is a proper subset of a given object.
# [#<=](#method-i-3C-3D)
# :   Returns whether `self` is a subset of a given object.
# [#==](#method-i-3D-3D)
# :   Returns whether a given object is equal to `self`.
# [#>](#method-i-3E)
# :   Returns whether `self` is a proper superset of a given object
# [#>=](#method-i-3E-3D)
# :   Returns whether `self` is a proper superset of a given object.
#
#
# #### Methods for Fetching
#
# #[]
# :   Returns the value associated with a given key.
# #assoc
# :   Returns a 2-element array containing a given key and its value.
# #dig
# :   Returns the object in nested objects that is specified by a given key and
#     additional arguments.
# #fetch
# :   Returns the value for a given key.
# #fetch_values
# :   Returns array containing the values associated with given keys.
# #key
# :   Returns the key for the first-found entry with a given value.
# #keys
# :   Returns an array containing all keys in `self`.
# #rassoc
# :   Returns a 2-element array consisting of the key and value of the
#     first-found entry having a given value.
# #values
# :   Returns an array containing all values in `self`/
# #values_at
# :   Returns an array containing values for given keys.
#
#
# #### Methods for Assigning
#
# #[]=, #store
# :   Associates a given key with a given value.
# #merge
# :   Returns the hash formed by merging each given hash into a copy of `self`.
# #merge!, #update
# :   Merges each given hash into `self`.
# #replace
# :   Replaces the entire contents of `self` with the contents of a givan hash.
#
#
# #### Methods for Deleting
#
# These methods remove entries from `self`:
#
# #clear
# :   Removes all entries from `self`.
# #compact!
# :   Removes all `nil`-valued entries from `self`.
# #delete
# :   Removes the entry for a given key.
# #delete_if
# :   Removes entries selected by a given block.
# #filter!, #select!
# :   Keep only those entries selected by a given block.
# #keep_if
# :   Keep only those entries selected by a given block.
# #reject!
# :   Removes entries selected by a given block.
# #shift
# :   Removes and returns the first entry.
#
#
# These methods return a copy of `self` with some entries removed:
#
# #compact
# :   Returns a copy of `self` with all `nil`-valued entries removed.
# #except
# :   Returns a copy of `self` with entries removed for specified keys.
# #filter, #select
# :   Returns a copy of `self` with only those entries selected by a given
#     block.
# #reject
# :   Returns a copy of `self` with entries removed as specified by a given
#     block.
# #slice
# :   Returns a hash containing the entries for given keys.
#
#
# #### Methods for Iterating
# #each, #each_pair
# :   Calls a given block with each key-value pair.
# #each_key
# :   Calls a given block with each key.
# #each_value
# :   Calls a given block with each value.
#
#
# #### Methods for Converting
#
# #inspect, #to_s
# :   Returns a new String containing the hash entries.
# #to_a
# :   Returns a new array of 2-element arrays; each nested array contains a
#     key-value pair from `self`.
# #to_h
# :   Returns `self` if a Hash; if a subclass of Hash, returns a Hash containing
#     the entries from `self`.
# #to_hash
# :   Returns `self`.
# #to_proc
# :   Returns a proc that maps a given key to its value.
#
#
# #### Methods for Transforming Keys and Values
#
# #transform_keys
# :   Returns a copy of `self` with modified keys.
# #transform_keys!
# :   Modifies keys in `self`
# #transform_values
# :   Returns a copy of `self` with modified values.
# #transform_values!
# :   Modifies values in `self`.
#
#
# #### Other Methods
# #flatten
# :   Returns an array that is a 1-dimensional flattening of `self`.
# #invert
# :   Returns a hash with the each key-value pair inverted.
#
class Hash[unchecked out K, unchecked out V] < Object
  include Enumerable[[ K, V ]]

  # <!--
  #   rdoc-file=hash.c
  #   - Hash[] -> new_empty_hash
  #   - Hash[hash] -> new_hash
  #   - Hash[ [*2_element_arrays] ] -> new_hash
  #   - Hash[*objects] -> new_hash
  # -->
  # Returns a new Hash object populated with the given objects, if any. See
  # Hash::new.
  #
  # With no argument, returns a new empty Hash.
  #
  # When the single given argument is a Hash, returns a new Hash populated with
  # the entries from the given Hash, excluding the default value or proc.
  #
  #     h = {foo: 0, bar: 1, baz: 2}
  #     Hash[h] # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When the single given argument is an Array of 2-element Arrays, returns a new
  # Hash object wherein each 2-element array forms a key-value entry:
  #
  #     Hash[ [ [:foo, 0], [:bar, 1] ] ] # => {:foo=>0, :bar=>1}
  #
  # When the argument count is an even number; returns a new Hash object wherein
  # each successive pair of arguments has become a key-value entry:
  #
  #     Hash[:foo, 0, :bar, 1] # => {:foo=>0, :bar=>1}
  #
  # Raises an exception if the argument list does not conform to any of the above.
  #
  def self.[]: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
             | [U, V] (Array[[ U, V ]]) -> ::Hash[U, V]
             | (*untyped) -> ::Hash[untyped, untyped]

  # <!--
  #   rdoc-file=hash.c
  #   - Hash.try_convert(obj) -> obj, new_hash, or nil
  # -->
  # If `obj` is a Hash object, returns `obj`.
  #
  # Otherwise if `obj` responds to `:to_hash`, calls `obj.to_hash` and returns the
  # result.
  #
  # Returns `nil` if `obj` does not respond to `:to_hash`
  #
  # Raises an exception unless `obj.to_hash` returns a Hash object.
  #
  def self.try_convert: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
                      | (untyped) -> (::Hash[untyped, untyped] | nil)

  public

  # <!--
  #   rdoc-file=hash.c
  #   - hash < other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper subset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 < h2 # => true
  #     h2 < h1 # => false
  #     h1 < h1 # => false
  #
  def <: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash <= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a subset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 <= h2 # => true
  #     h2 <= h1 # => false
  #     h1 <= h1 # => true
  #
  def <=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash == object -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a Hash object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `hash[key] == object[key]`.
  #
  #
  # Otherwise, returns `false`.
  #
  # Equal:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1 == h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1 == h3 # => true
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash > other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a proper superset of `other_hash`, `false`
  # otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 > h2 # => true
  #     h2 > h1 # => false
  #     h1 > h1 # => false
  #
  def >: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash >= other_hash -> true or false
  # -->
  # Returns `true` if `hash` is a superset of `other_hash`, `false` otherwise:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1}
  #     h1 >= h2 # => true
  #     h2 >= h1 # => false
  #     h1 >= h1 # => true
  #
  def >=: [A, B] (::Hash[A, B]) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] -> value
  # -->
  # Returns the value associated with the given `key`, if found:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:foo] # => 0
  #
  # If `key` is not found, returns a default value (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h[:nosuch] # => nil
  #
  def []: (K arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash[key] = value -> value
  #   - hash.store(key, value)
  # -->
  # Hash#store is an alias for Hash#[]=.
  #
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  def []=: (K arg0, V arg1) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.any? -> true or false
  #   - hash.any?(object) -> true or false
  #   - hash.any? {|key, value| ... } -> true or false
  # -->
  # Returns `true` if any element satisfies a given criterion; `false` otherwise.
  #
  # With no argument and no block, returns `true` if `self` is non-empty; `false`
  # if empty.
  #
  # With argument `object` and no block, returns `true` if for any key `key`
  # `h.assoc(key) == object`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any?([:bar, 1]) # => true
  #     h.any?([:bar, 0]) # => false
  #     h.any?([:baz, 1]) # => false
  #
  # With no argument and a block, calls the block with each key-value pair;
  # returns `true` if the block returns any truthy value, `false` otherwise:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.any? {|key, value| value < 3 } # => true
  #     h.any? {|key, value| value > 3 } # => false
  #
  def any?: () -> bool
          | (untyped pattern) -> bool
          | () { (K, V) -> boolish } -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.assoc(key) -> new_array or nil
  # -->
  # If the given `key` is found, returns a 2-element Array containing that key and
  # its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.assoc(:bar) # => [:bar, 1]
  #
  # Returns `nil` if key `key` is not found.
  #
  def assoc: (K arg0) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.clear -> self
  # -->
  # Removes all hash entries; returns `self`.
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact -> new_hash
  # -->
  # Returns a copy of `self` with all `nil`-valued entries removed:
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h1 = h.compact
  #     h1 # => {:foo=>0, :baz=>2}
  #
  def compact: () -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compact! -> self or nil
  # -->
  # Returns `self` with all its `nil`-valued entries removed (in place):
  #     h = {foo: 0, bar: nil, baz: 2, bat: nil}
  #     h.compact! # => {:foo=>0, :baz=>2}
  #
  # Returns `nil` if no entries were removed.
  #
  def compact!: () -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity -> self
  # -->
  # Sets `self` to consider only identity in comparing keys; two keys are
  # considered the same only if they are the same object; returns `self`.
  #
  # By default, these two object are considered to be the same key, so `s1` will
  # overwrite `s0`:
  #     s0 = 'x'
  #     s1 = 'x'
  #     h = {}
  #     h.compare_by_identity? # => false
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>1}
  #
  # After calling #compare_by_identity, the keys are considered to be different,
  # and therefore do not overwrite each other:
  #     h = {}
  #     h.compare_by_identity # => {}
  #     h.compare_by_identity? # => true
  #     h[s0] = 0
  #     h[s1] = 1
  #     h # => {"x"=>0, "x"=>1}
  #
  def compare_by_identity: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.compare_by_identity? -> true or false
  # -->
  # Returns `true` if #compare_by_identity has been called, `false` otherwise.
  #
  def compare_by_identity?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - deconstruct_keys(p1)
  # -->
  #
  def deconstruct_keys: (Array[K] | nil) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default -> object
  #   - hash.default(key) -> object
  # -->
  # Returns the default value for the given `key`. The returned value will be
  # determined either by the default proc or by the default value. See [Default
  # Values](#class-Hash-label-Default+Values).
  #
  # With no argument, returns the current default value:
  #     h = {}
  #     h.default # => nil
  #
  # If `key` is given, returns the default value for `key`, regardless of whether
  # that key exists:
  #     h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
  #     h[:foo] = "Hello"
  #     h.default(:foo) # => "No key foo"
  #
  def default: (?K arg0) -> V?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default = value -> object
  # -->
  # Sets the default value to `value`; returns `value`:
  #     h = {}
  #     h.default # => nil
  #     h.default = false # => false
  #     h.default # => false
  #
  # See [Default Values](#class-Hash-label-Default+Values).
  #
  def default=: (V arg0) -> V

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc -> proc or nil
  # -->
  # Returns the default proc for `self` (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc {|hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #
  def default_proc: () -> (Proc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.default_proc = proc -> proc
  # -->
  # Sets the default proc for `self` to `proc`: (see [Default
  # Values](#class-Hash-label-Default+Values)):
  #     h = {}
  #     h.default_proc # => nil
  #     h.default_proc = proc { |hash, key| "Default value for #{key}" }
  #     h.default_proc.class # => Proc
  #     h.default_proc = nil
  #     h.default_proc # => nil
  #
  def default_proc=: (Proc | _ToProc | nil) -> (Proc | _ToProc | nil)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete(key) -> value or nil
  #   - hash.delete(key) {|key| ... } -> object
  # -->
  # Deletes the entry for the given `key` and returns its associated value.
  #
  # If no block is given and `key` is found, deletes the entry and returns the
  # associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:bar) # => 1
  #     h # => {:foo=>0, :baz=>2}
  #
  # If no block given and `key` is not found, returns `nil`.
  #
  # If a block is given and `key` is found, ignores the block, deletes the entry,
  # and returns the associated value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:baz) { |key| raise 'Will never happen'} # => 2
  #     h # => {:foo=>0, :bar=>1}
  #
  # If a block is given and `key` is not found, calls the block and returns the
  # block's return value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete(:nosuch) { |key| "Key #{key} not found" } # => "Key nosuch not found"
  #     h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def delete: (K arg0) -> V?
            | [U] (K arg0) { (K arg0) -> U } -> (U | V)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.delete_if {|key, value| ... } -> self
  #   - hash.delete_if -> new_enumerator
  # -->
  # If a block given, calls the block with each key-value pair; deletes each entry
  # for which the block returns a truthy value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.delete_if {|key, value| value > 0 } # => {:foo=>0}
  #
  # If no block given, returns a new Enumerator:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.delete_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:delete_if>
  #     e.each { |key, value| value > 0 } # => {:foo=>0}
  #
  def delete_if: () { (K, V) -> boolish } -> self
               | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.dig(key, *identifiers) -> object
  # -->
  # Finds and returns the object in nested objects that is specified by `key` and
  # `identifiers`. The nested objects may be instances of various classes. See
  # [Dig Methods](rdoc-ref:dig_methods.rdoc).
  #
  # Nested Hashes:
  #     h = {foo: {bar: {baz: 2}}}
  #     h.dig(:foo) # => {:bar=>{:baz=>2}}
  #     h.dig(:foo, :bar) # => {:baz=>2}
  #     h.dig(:foo, :bar, :baz) # => 2
  #     h.dig(:foo, :bar, :BAZ) # => nil
  #
  # Nested Hashes and Arrays:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:foo, :bar, 2) # => :c
  #
  # This method will use the [default values](#class-Hash-label-Default+Values)
  # for keys that are not present:
  #     h = {foo: {bar: [:a, :b, :c]}}
  #     h.dig(:hello) # => nil
  #     h.default_proc = -> (hash, _key) { hash }
  #     h.dig(:hello, :world) # => h
  #     h.dig(:hello, :world, :foo, :bar, 2) # => :c
  #
  def dig: (*untyped) -> untyped

  # <!-- rdoc-file=hash.c -->
  # Hash#each is an alias for Hash#each_pair.
  #
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  def each: () { ([ K, V ] arg0) -> untyped } -> self
          | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_key {|key| ... } -> self
  #   - hash.each_key -> new_enumerator
  # -->
  # Calls the given block with each key; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_key {|key| puts key }  # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_key # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_key>
  #     h1 = e.each {|key| puts key }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo
  #     bar
  #     baz
  #
  def each_key: () { (K arg0) -> untyped } -> ::Hash[K, V]
              | () -> ::Enumerator[K, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each {|key, value| ... } -> self
  #   - hash.each_pair {|key, value| ... } -> self
  #   - hash.each -> new_enumerator
  #   - hash.each_pair -> new_enumerator
  # -->
  # Hash#each is an alias for Hash#each_pair.
  #
  # Calls the given block with each key-value pair; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
  #     h1 = e.each {|key, value| puts "#{key}: #{value}"}
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     foo: 0
  #     bar: 1
  #     baz: 2
  #
  alias each_pair each

  # <!--
  #   rdoc-file=hash.c
  #   - hash.each_value {|value| ... } -> self
  #   - hash.each_value -> new_enumerator
  # -->
  # Calls the given block with each value; returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_value {|value| puts value } # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.each_value # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_value>
  #     h1 = e.each {|value| puts value }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # Output:
  #     0
  #     1
  #     2
  #
  def each_value: () { (V arg0) -> untyped } -> self
                | () -> ::Enumerator[V, self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.empty? -> true or false
  # -->
  # Returns `true` if there are no hash entries, `false` otherwise:
  #     {}.empty? # => true
  #     {foo: 0, bar: 1, baz: 2}.empty? # => false
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.eql? object -> true or false
  # -->
  # Returns `true` if all of the following are true:
  # *   `object` is a Hash object.
  # *   `hash` and `object` have the same keys (regardless of order).
  # *   For each key `key`, `h[key] eql? object[key]`.
  #
  #
  # Otherwise, returns `false`.
  #
  # Equal:
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {foo: 0, bar: 1, baz: 2}
  #     h1.eql? h2 # => true
  #     h3 = {baz: 2, bar: 1, foo: 0}
  #     h1.eql? h3 # => true
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hsh.except(*keys) -> a_hash
  # -->
  # Returns a new Hash excluding entries for the given `keys`:
  #     h = { a: 100, b: 200, c: 300 }
  #     h.except(:a)          #=> {:b=>200, :c=>300}
  #
  # Any given `keys` that are not found are ignored.
  #
  def except: (*K) -> ::Hash[K, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch(key) -> object
  #   - hash.fetch(key, default_value) -> object
  #   - hash.fetch(key) {|key| ... } -> object
  # -->
  # Returns the value for the given `key`, if found.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch(:bar) # => 1
  #
  # If `key` is not found and no block was given, returns `default_value`:
  #     {}.fetch(:nosuch, :default) # => :default
  #
  # If `key` is not found and a block was given, yields `key` to the block and
  # returns the block's return value:
  #     {}.fetch(:nosuch) {|key| "No key #{key}"} # => "No key nosuch"
  #
  # Raises KeyError if neither `default_value` nor a block was given.
  #
  # Note that this method does not use the values of either #default or
  # #default_proc.
  #
  def fetch: (K arg0) -> V
           | [X] (K arg0, X arg1) -> (V | X)
           | [X] (K arg0) { (K arg0) -> X } -> (V | X)

  # <!--
  #   rdoc-file=hash.c
  #   - hash.fetch_values(*keys) -> new_array
  #   - hash.fetch_values(*keys) {|key| ... } -> new_array
  # -->
  # Returns a new Array containing the values associated with the given keys
  # *keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.fetch_values(:baz, :foo) # => [2, 0]
  #
  # Returns a new empty Array if no arguments given.
  #
  # When a block is given, calls the block with each missing key, treating the
  # block's return value as the value for that key:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
  #     values # => [1, 0, "bad", "bam"]
  #
  # When no block is given, raises an exception if any given key is not found.
  #
  def fetch_values: (*K) -> ::Array[V]
                  | [X] (*K) { (K) -> X } -> ::Array[V | X]

  # <!-- rdoc-file=hash.c -->
  # Hash#filter is an alias for Hash#select.
  #
  # Returns a new Hash object whose entries are those for which the block returns
  # a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter: () { (K, V) -> boolish } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], ::Hash[K, V]]

  # <!-- rdoc-file=hash.c -->
  # Hash#filter! is an alias for Hash#select!.
  #
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  def filter!: () { (K, V) -> boolish } -> self?
             | () -> ::Enumerator[[ K, V ], self?]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.flatten -> new_array
  #   - hash.flatten(level) -> new_array
  # -->
  # Returns a new Array object that is a 1-dimensional flattening of `self`.
  #
  # ---
  #
  # By default, nested Arrays are not flattened:
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten # => [:foo, 0, :bar, [:bat, 3], :baz, 2]
  #
  # Takes the depth of recursive flattening from Integer argument `level`:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(1) # => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
  #     h.flatten(2) # => [:foo, 0, :bar, :bat, [:baz, [:bat]]]
  #     h.flatten(3) # => [:foo, 0, :bar, :bat, :baz, [:bat]]
  #     h.flatten(4) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is negative, flattens all nested Arrays:
  #     h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
  #     h.flatten(-1) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #     h.flatten(-2) # => [:foo, 0, :bar, :bat, :baz, :bat]
  #
  # When `level` is zero, returns the equivalent of #to_a :
  #     h = {foo: 0, bar: [:bat, 3], baz: 2}
  #     h.flatten(0) # => [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
  #     h.flatten(0) == h.to_a # => true
  #
  def flatten: () -> ::Array[K | V]
             | (1 level) -> ::Array[K | V]
             | (Integer level) -> Array[untyped]

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  def has_key?: (K arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.has_value?(value) -> true or false
  #   - hash.value?(value) -> true or false
  # -->
  # Method #value? is an alias for #has_value?.
  #
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  def has_value?: (V arg0) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - hash.hash -> an_integer
  # -->
  # Returns the Integer hash-code for the hash.
  #
  # Two Hash objects have the same hash-code if their content is the same
  # (regardless or order):
  #     h1 = {foo: 0, bar: 1, baz: 2}
  #     h2 = {baz: 2, bar: 1, foo: 0}
  #     h2.hash == h1.hash # => true
  #     h2.eql? h1 # => true
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=hash.c
  #   - hash.include?(key) -> true or false
  #   - hash.has_key?(key) -> true or false
  #   - hash.key?(key) -> true or false
  #   - hash.member?(key) -> true or false
  # -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias include? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.inspect -> new_string
  # -->
  # Returns a new String containing the hash entries:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{:foo=>0, :bar=>1, :baz=>2}"
  #
  # Hash#to_s is an alias for Hash#inspect.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=hash.c
  #   - hash.invert -> new_hash
  # -->
  # Returns a new Hash object with the each key-value pair inverted:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.invert
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # Overwrites any repeated new keys: (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 0, baz: 0}
  #     h.invert # => {0=>:baz}
  #
  def invert: () -> ::Hash[V, K]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keep_if {|key, value| ... } -> self
  #   - hash.keep_if -> new_enumerator
  # -->
  # Calls the block for each key-value pair; retains the entry if the block
  # returns a truthy value; otherwise deletes the entry; returns `self`.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keep_if { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.keep_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:keep_if>
  #     e.each { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}
  #
  def keep_if: () { (K, V) -> boolish } -> self
             | () -> ::Enumerator[[ K, V ], self]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.key(value) -> key or nil
  # -->
  # Returns the key for the first-found entry with the given `value` (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 2, baz: 2}
  #     h.key(0) # => :foo
  #     h.key(2) # => :bar
  #
  # Returns `nil` if so such value is found.
  #
  def key: (V) -> K?

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias key? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.keys -> new_array
  # -->
  # Returns a new Array containing all keys in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.keys # => [:foo, :bar, :baz]
  #
  def keys: () -> ::Array[K]

  # <!-- rdoc-file=hash.c -->
  # Returns the count of entries in `self`:
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  # Hash#length is an alias for Hash#size.
  #
  def length: () -> Integer

  # <!-- rdoc-file=hash.c -->
  # Methods #has_key?, #key?, and #member? are aliases for #include?.
  #
  # Returns `true` if `key` is a key in `self`, otherwise `false`.
  #
  alias member? has_key?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge -> copy_of_self
  #   - hash.merge(*other_hashes) -> new_hash
  #   - hash.merge(*other_hashes) { |key, old_value, new_value| ... } -> new_hash
  # -->
  # Returns the new Hash formed by merging each of `other_hashes` into a copy of
  # `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # ---
  #
  # With arguments and no block:
  # *   Returns the new Hash object formed by merging each successive Hash in
  #     `other_hashes` into `self`.
  # *   Each new-key entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns a new Hash object that is the merge of `self` and each given hash.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns a copy of `self`.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge: [A, B] (*::Hash[A, B] other_hashes) -> ::Hash[A | K, B | V]
           | [A, B, C] (*::Hash[A, B] other_hashes) { (K key, V oldval, B newval) -> C } -> ::Hash[A | K, B | V | C]

  # <!-- rdoc-file=hash.c -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # Method #update is an alias for #merge!.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  def merge!: (*::Hash[K, V] other_hashes) -> self
            | (*::Hash[K, V] other_hashes) { (K key, V oldval, V newval) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rassoc(value) -> new_array or nil
  # -->
  # Returns a new 2-element Array consisting of the key and value of the
  # first-found entry whose value is `==` to value (see [Entry
  # Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1, baz: 1}
  #     h.rassoc(1) # => [:bar, 1]
  #
  # Returns `nil` if no such value found.
  #
  def rassoc: (V) -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.rehash -> self
  # -->
  # Rebuilds the hash table by recomputing the hash index for each key; returns
  # `self`.
  #
  # The hash table becomes invalid if the hash value of a key has changed after
  # the entry was created. See [Modifying an Active Hash
  # Key](#class-Hash-label-Modifying+an+Active+Hash+Key).
  #
  def rehash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject {|key, value| ... } -> new_hash
  #   - hash.reject -> new_enumerator
  # -->
  # Returns a new Hash object whose entries are all those from `self` for which
  # the block returns `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.reject {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject>
  #     h1 = e.each {|key, value| key.start_with?('b') }
  #     h1 # => {:foo=>0}
  #
  def reject: () -> ::Enumerator[[ K, V ], self]
            | () { (K, V) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.reject! {|key, value| ... } -> self or nil
  #   - hash.reject! -> new_enumerator
  # -->
  # Returns `self`, whose remaining entries are those for which the block returns
  # `false` or `nil`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.reject! {|key, value| value < 2 } # => {:baz=>2}
  #
  # Returns `nil` if no entries are removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.reject! # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject!>
  #     e.each {|key, value| key.start_with?('b') } # => {:foo=>0}
  #
  def reject!: () -> ::Enumerator[[ K, V ], self?]
             | () { (K, V) -> boolish } -> self?

  # <!-- rdoc-file=hash.c -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def replace: (Hash[K, V]) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select {|key, value| ... } -> new_hash
  #   - hash.select -> new_enumerator
  # -->
  # Hash#filter is an alias for Hash#select.
  #
  # Returns a new Hash object whose entries are those for which the block returns
  # a truthy value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
  #     e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select filter

  # <!--
  #   rdoc-file=hash.c
  #   - hash.select! {|key, value| ... } -> self or nil
  #   - hash.select! -> new_enumerator
  # -->
  # Hash#filter! is an alias for Hash#select!.
  #
  # Returns `self`, whose entries are those for which the block returns a truthy
  # value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}
  #
  # Returns `nil` if no entries were removed.
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
  #     e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}
  #
  alias select! filter!

  # <!--
  #   rdoc-file=hash.c
  #   - hash.shift -> [key, value] or default_value
  # -->
  # Removes the first hash entry (see [Entry
  # Order](#class-Hash-label-Entry+Order)); returns a 2-element Array containing
  # the removed key and value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.shift # => [:foo, 0]
  #     h # => {:bar=>1, :baz=>2}
  #
  # Returns the default value if the hash is empty (see [Default
  # Values](#class-Hash-label-Default+Values)).
  #
  def shift: () -> [ K, V ]?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.length -> integer
  #   - hash.size -> integer
  # -->
  # Returns the count of entries in `self`:
  #     {foo: 0, bar: 1, baz: 2}.length # => 3
  #
  # Hash#length is an alias for Hash#size.
  #
  alias size length

  # <!--
  #   rdoc-file=hash.c
  #   - hash.slice(*keys) -> new_hash
  # -->
  # Returns a new Hash object containing the entries for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.slice(:baz, :foo) # => {:baz=>2, :foo=>0}
  #
  # Any given `keys` that are not found are ignored.
  #
  def slice: (*K) -> ::Hash[K, V]

  # <!-- rdoc-file=hash.c -->
  # Hash#store is an alias for Hash#[]=.
  #
  # Associates the given `value` with the given `key`; returns `value`.
  #
  # If the given `key` exists, replaces its value with the given `value`; the
  # ordering is not affected (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:foo] = 2 # => 2
  #     h.store(:bar, 3) # => 3
  #     h # => {:foo=>2, :bar=>3}
  #
  # If `key` does not exist, adds the `key` and `value`; the new entry is last in
  # the order (see [Entry Order](#class-Hash-label-Entry+Order)):
  #     h = {foo: 0, bar: 1}
  #     h[:baz] = 2 # => 2
  #     h.store(:bat, 3) # => 3
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #
  alias store []=

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_a -> new_array
  # -->
  # Returns a new Array of 2-element Array objects; each nested Array contains a
  # key-value pair from `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.to_a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  def to_a: () -> ::Array[[ K, V ]]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_h -> self or new_hash
  #   - hash.to_h {|key, value| ... } -> new_hash
  # -->
  # For an instance of Hash, returns `self`.
  #
  # For a subclass of Hash, returns a new Hash containing the content of `self`.
  #
  # When a block is given, returns a new Hash object whose content is based on the
  # block; the block should return a 2-element Array object specifying the
  # key-value pair to be included in the returned Array:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.to_h {|key, value| [value, key] }
  #     h1 # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  def to_h: () -> Hash[K, V]
          | [A, B] () { (K, V) -> [ A, B ] } -> Hash[A, B]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_hash -> self
  # -->
  # Returns `self`.
  #
  def to_hash: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.to_proc -> proc
  # -->
  # Returns a Proc object that maps a key to its value:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     proc = h.to_proc
  #     proc.class # => Proc
  #     proc.call(:foo) # => 0
  #     proc.call(:bar) # => 1
  #     proc.call(:nosuch) # => nil
  #
  def to_proc: () -> ^(K) -> V?

  # <!-- rdoc-file=hash.c -->
  # Returns a new String containing the hash entries:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.inspect # => "{:foo=>0, :bar=>1, :baz=>2}"
  #
  # Hash#to_s is an alias for Hash#inspect.
  #
  alias to_s inspect

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys {|key| ... } -> new_hash
  #   - hash.transform_keys(hash2) -> new_hash
  #   - hash.transform_keys(hash2) {|other_key| ...} -> new_hash
  #   - hash.transform_keys -> new_enumerator
  # -->
  # Returns a new Hash object; each entry has:
  # *   A key provided by the block.
  # *   The value from `self`.
  #
  #
  # An optional hash argument can be provided to map keys to new keys. Any key not
  # given will be mapped using the provided block, or remain the same if no block
  # is given.
  #
  # Transform keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  #     h.transform_keys(foo: :bar, bar: :foo)
  #     #=> {bar: 0, foo: 1, baz: 2}
  #
  #     h.transform_keys(foo: :hello, &:to_s)
  #     #=> {:hello=>0, "bar"=>1, "baz"=>2}
  #
  # Overwrites values for duplicate keys:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_keys {|key| :bat }
  #     h1 # => {:bat=>2}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_keys # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_keys>
  #     h1 = e.each { |key| key.to_s }
  #     h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}
  #
  def transform_keys: () -> Enumerator[K, Hash[untyped, V]]
                    | [A] () { (K) -> A } -> Hash[A, V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_keys! {|key| ... } -> self
  #   - hash.transform_keys!(hash2) -> self
  #   - hash.transform_keys!(hash2) {|other_key| ...} -> self
  #   - hash.transform_keys! -> new_enumerator
  # -->
  # Same as Hash#transform_keys but modifies the receiver in place instead of
  # returning a new hash.
  #
  def transform_keys!: () -> Enumerator[K, self]
                     | () { (K) -> K } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values {|value| ... } -> new_hash
  #   - hash.transform_values -> new_enumerator
  # -->
  # Returns a new Hash object; each entry has:
  # *   A key from `self`.
  # *   A value provided by the block.
  #
  #
  # Transform values:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = h.transform_values {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_values>
  #     h1 = e.each { |value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values: () -> Enumerator[V, Hash[K, untyped]]
                      | [A] () { (V) -> A } -> Hash[K, A]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.transform_values! {|value| ... } -> self
  #   - hash.transform_values! -> new_enumerator
  # -->
  # Returns `self`, whose keys are unchanged, and whose values are determined by
  # the given block.
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.transform_values! {|value| value * 100} # => {:foo=>0, :bar=>100, :baz=>200}
  #
  # Returns a new Enumerator if no block given:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     e = h.transform_values! # => #<Enumerator: {:foo=>0, :bar=>100, :baz=>200}:transform_values!>
  #     h1 = e.each {|value| value * 100}
  #     h1 # => {:foo=>0, :bar=>100, :baz=>200}
  #
  def transform_values!: () -> Enumerator[V, self]
                       | () { (V) -> V } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - hash.merge! -> self
  #   - hash.merge!(*other_hashes) -> self
  #   - hash.merge!(*other_hashes) { |key, old_value, new_value| ... } -> self
  # -->
  # Merges each of `other_hashes` into `self`; returns `self`.
  #
  # Each argument in `other_hashes` must be a Hash.
  #
  # Method #update is an alias for #merge!.
  #
  # With arguments and no block:
  # *   Returns `self`, after the given hashes are merged into it.
  # *   The given hashes are merged left to right.
  # *   Each new entry is added at the end.
  # *   Each duplicate-key entry's value overwrites the previous value.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}
  #
  # With arguments and a block:
  # *   Returns `self`, after the given hashes are merged.
  # *   The given hashes are merged left to right.
  # *   Each new-key entry is added at the end.
  # *   For each duplicate key:
  #     *   Calls the block with the key and the old and new values.
  #     *   The block's return value becomes the new value for the entry.
  #
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h1 = {bat: 3, bar: 4}
  #     h2 = {bam: 5, bat:6}
  #     h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
  #     h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}
  #
  # With no arguments:
  # *   Returns `self`, unmodified.
  # *   The block, if given, is ignored.
  #
  #
  # Example:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.merge # => {:foo=>0, :bar=>1, :baz=>2}
  #     h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
  #     h1 # => {:foo=>0, :bar=>1, :baz=>2}
  #
  alias update merge!

  # <!-- rdoc-file=hash.c -->
  # Method #value? is an alias for #has_value?.
  #
  # Returns `true` if `value` is a value in `self`, otherwise `false`.
  #
  alias value? has_value?

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values -> new_array
  # -->
  # Returns a new Array containing all values in `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values # => [0, 1, 2]
  #
  def values: () -> ::Array[V]

  # <!--
  #   rdoc-file=hash.c
  #   - hash.values_at(*keys) -> new_array
  # -->
  # Returns a new Array containing values for the given `keys`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.values_at(:baz, :foo) # => [2, 0]
  #
  # The [default values](#class-Hash-label-Default+Values) are returned for any
  # keys that are not found:
  #     h.values_at(:hello, :foo) # => [nil, 0]
  #
  def values_at: (*K arg0) -> ::Array[V?]

  private

  # <!--
  #   rdoc-file=hash.c
  #   - Hash.new(default_value = nil) -> new_hash
  #   - Hash.new {|hash, key| ... } -> new_hash
  # -->
  # Returns a new empty Hash object.
  #
  # The initial default value and initial default proc for the new hash depend on
  # which form above was used. See [Default
  # Values](#class-Hash-label-Default+Values).
  #
  # If neither an argument nor a block given, initializes both the default value
  # and the default proc to `nil`:
  #     h = Hash.new
  #     h.default # => nil
  #     h.default_proc # => nil
  #
  # If argument `default_value` given but no block given, initializes the default
  # value to the given `default_value` and the default proc to `nil`:
  #     h = Hash.new(false)
  #     h.default # => false
  #     h.default_proc # => nil
  #
  # If a block given but no argument, stores the block as the default proc and
  # sets the default value to `nil`:
  #     h = Hash.new {|hash, key| "Default value for #{key}" }
  #     h.default # => nil
  #     h.default_proc.class # => Proc
  #     h[:nosuch] # => "Default value for nosuch"
  #
  def initialize: () -> void
                | (untyped default) -> void
                | [A, B] () { (Hash[A, B] hash, A key) -> B } -> void

  # <!--
  #   rdoc-file=hash.c
  #   - hash.replace(other_hash) -> self
  # -->
  # Replaces the entire contents of `self` with the contents of `other_hash`;
  # returns `self`:
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}
  #
  def initialize_copy: (self object) -> self
end

# <!-- rdoc-file=proc.c -->
# Ruby supports two forms of objectified methods. Class Method is used to
# represent methods that are associated with a particular object: these method
# objects are bound to that object. Bound method objects for an object can be
# created using Object#method.
#
# Ruby also supports unbound methods; methods objects that are not associated
# with a particular object. These can be created either by calling
# Module#instance_method or by calling #unbind on a bound method object. The
# result of both of these is an UnboundMethod object.
#
# Unbound methods can only be called after they are bound to an object. That
# object must be a kind_of? the method's original class.
#
#     class Square
#       def area
#         @side * @side
#       end
#       def initialize(side)
#         @side = side
#       end
#     end
#
#     area_un = Square.instance_method(:area)
#
#     s = Square.new(12)
#     area = area_un.bind(s)
#     area.call   #=> 144
#
# Unbound methods are a reference to the method at the time it was objectified:
# subsequent changes to the underlying class will not affect the unbound method.
#
#     class Test
#       def test
#         :original
#       end
#     end
#     um = Test.instance_method(:test)
#     class Test
#       def test
#         :modified
#       end
#     end
#     t = Test.new
#     t.test            #=> :modified
#     um.bind(t).call   #=> :original
#
class UnboundMethod
  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind(obj) -> method
  # -->
  # Bind *umeth* to *obj*. If Klass was the class from which *umeth* was obtained,
  # `obj.kind_of?(Klass)` must be true.
  #
  #     class A
  #       def test
  #         puts "In test, class = #{self.class}"
  #       end
  #     end
  #     class B < A
  #     end
  #     class C < B
  #     end
  #
  #     um = B.instance_method(:test)
  #     bm = um.bind(C.new)
  #     bm.call
  #     bm = um.bind(B.new)
  #     bm.call
  #     bm = um.bind(A.new)
  #     bm.call
  #
  # *produces:*
  #
  #     In test, class = C
  #     In test, class = B
  #     prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)
  #      from prog.rb:16
  #
  def bind: (untyped obj) -> Method

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module that defines the method. See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> Module

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> ::Array[[ Symbol, Symbol ]]
                | () -> ::Array[[ Symbol ]]

  # <!--
  #   rdoc-file=proc.c
  #   - meth.private? -> true or false
  # -->
  # Returns whether the method is private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.protected? -> true or false
  # -->
  # Returns whether the method is protected.
  #
  def protected?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.public? -> true or false
  # -->
  # Returns whether the method is public.
  #
  def public?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> UnboundMethod?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - umeth.bind_call(recv, args, ...) -> obj
  # -->
  # Bind *umeth* to *recv* and then invokes the method with the specified
  # arguments. This is semantically equivalent to `umeth.bind(recv).call(args,
  # ...)`.
  #
  def bind_call: (untyped recv, *untyped args) ?{ (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=numeric.c -->
# A Float object represents a sometimes-inexact real number using the native
# architecture's double-precision floating point representation.
#
# Floating point has a different arithmetic and is an inexact number. So you
# should know its esoteric system. See following:
#
# *   https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
# *   https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#floats_impre
#     cise
# *   https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
#
#
# You can create a Float object explicitly with:
#
# *   A [floating-point
#     literal](doc/syntax/literals_rdoc.html#label-Float+Literals).
#
#
# You can convert certain objects to Floats with:
#
# *   Method [Float](Kernel.html#method-i-Float).
#
#
# ## What's Here
#
# First, what's elsewhere. Class Float:
#
# *   Inherits from [class
#     Numeric](Numeric.html#class-Numeric-label-What-27s+Here).
#
#
# Here, class Float provides methods for:
#
# *   [Querying](#class-Float-label-Querying)
# *   [Comparing](#class-Float-label-Comparing)
# *   [Converting](#class-Float-label-Converting)
#
#
# ### Querying
#
#     #finite?
# :       Returns whether `self` is finite.
#
#     #hash
# :       Returns the integer hash code for `self`.
#
#     #infinite?
# :       Returns whether `self` is infinite.
#
#     #nan?
# :       Returns whether `self` is a NaN (not-a-number).
#
#
#
# ### Comparing
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given value.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given value.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns a number indicating whether `self` is less than, equal to, or
#         greater than the given value.
#
#     [==](#method-i-3D-3D) (aliased as #=== and #eql>)
# :       Returns whether `self` is equal to the given value.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than the given value.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than or equal to the given value.
#
#
#
# ### Converting
#
#     #% (aliased as #modulo)
# :       Returns `self` modulo the given value.
#
#     #*
# :       Returns the product of `self` and the given value.
#
#     [**](#method-i-2A-2A)
# :       Returns the value of `self` raised to the power of the given value.
#
#     #+
# :       Returns the sum of `self` and the given value.
#
#     #-
# :       Returns the difference of `self` and the given value.
#
#     [/](#method-i-2F)
# :       Returns the quotient of `self` and the given value.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`.
#
#     #coerce
# :       Returns a 2-element array containing the given value converted to a
#         Float and `self`
#
#     #divmod
# :       Returns a 2-element array containing the quotient and remainder
#         results of dividing `self` by the given value.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given value.
#
#     #floor
# :       Returns the greatest number smaller than or equal to `self`.
#
#     #next_float
# :       Returns the next-larger representable Float.
#
#     #prev_float
# :       Returns the next-smaller representable Float.
#
#     #quo
# :       Returns the quotient from dividing `self` by the given value.
#
#     #round
# :       Returns `self` rounded to the nearest value, to a given precision.
#
#     #to_i (aliased as #to_int)
# :       Returns `self` truncated to an Integer.
#
#     #to_s (aliased as #inspect)
# :       Returns a string containing the place-value representation of `self`
#         in the given radix.
#
#     #truncate
# :       Returns `self` truncated to a given precision.
#
class Float < Numeric
  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> float
  # -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  # Float#modulo is an alias for Float#%.
  #
  def %: (Integer) -> Float
       | (Float) -> Float
       | (Rational) -> Float
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self * other -> numeric
  # -->
  # Returns a new Float which is the product of `self` and `other`:
  #
  #     f = 3.14
  #     f * 2              # => 6.28
  #     f * 2.0            # => 6.28
  #     f * Rational(1, 2) # => 1.57
  #     f * Complex(2, 0)  # => (6.28+0.0i)
  #
  def *: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** other -> numeric
  # -->
  # Raises `self` to the power of `other`:
  #
  #     f = 3.14
  #     f ** 2              # => 9.8596
  #     f ** -2             # => 0.1014239928597509
  #     f ** 2.1            # => 11.054834900588839
  #     f ** Rational(2, 1) # => 9.8596
  #     f ** Complex(2, 0)  # => (9.8596+0i)
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self + other -> numeric
  # -->
  # Returns a new Float which is the sum of `self` and `other`:
  #
  #     f = 3.14
  #     f + 1                 # => 4.140000000000001
  #     f + 1.0               # => 4.140000000000001
  #     f + Rational(1, 1)    # => 4.140000000000001
  #     f + Complex(1, 0)     # => (4.140000000000001+0i)
  #
  def +: (Complex) -> Complex
       | (Numeric) -> Float

  def +@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self - other -> numeric
  # -->
  # Returns a new Float which is the difference of `self` and `other`:
  #
  #     f = 3.14
  #     f - 1                 # => 2.14
  #     f - 1.0               # => 2.14
  #     f - Rational(1, 1)    # => 2.14
  #     f - Complex(1, 0)     # => (2.14+0i)
  #
  def -: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - -float  ->  float
  # -->
  # Returns `float`, negated.
  #
  def -@: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self / other -> numeric
  # -->
  # Returns a new Float which is the result of dividing `self` by `other`:
  #
  #     f = 3.14
  #     f / 2              # => 1.57
  #     f / 2.0            # => 1.57
  #     f / Rational(2, 1) # => 1.57
  #     f / Complex(2, 0)  # => (1.57+0.0i)
  #
  def /: (Complex) -> Complex
       | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than `other`:
  #
  #     2.0 < 3              # => true
  #     2.0 < 3.0            # => true
  #     2.0 < Rational(3, 1) # => true
  #     2.0 < 2.0            # => false
  #
  # `Float::NAN < Float::NAN` returns an implementation-dependent value.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= other -> true or false
  # -->
  # Returns `true` if `self` is numerically less than or equal to `other`:
  #
  #     2.0 <= 3              # => true
  #     2.0 <= 3.0            # => true
  #     2.0 <= Rational(3, 1) # => true
  #     2.0 <= 2.0            # => true
  #     2.0 <= 1.0            # => false
  #
  # `Float::NAN <= Float::NAN` returns an implementation-dependent value.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other ->  -1, 0, +1, or nil
  # -->
  # Returns a value that depends on the numeric relation between `self` and
  # `other`:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater than `other`.
  # *   `nil`, if the two values are incommensurate.
  #
  #
  # Examples:
  #
  #     2.0 <=> 2              # => 0
  #     2.0 <=> 2.0            # => 0
  #     2.0 <=> Rational(2, 1) # => 0
  #     2.0 <=> Complex(2, 0)  # => 0
  #     2.0 <=> 1.9            # => 1
  #     2.0 <=> 2.1            # => -1
  #     2.0 <=> 'foo'          # => nil
  #
  # This is the basis for the tests in the Comparable module.
  #
  # `Float::NAN <=> Float::NAN` returns an implementation-dependent value.
  #
  def <=>: (Numeric) -> Integer?

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `other` has the same value as `self`, `false` otherwise:
  #
  #     2.0 == 2              # => true
  #     2.0 == 2.0            # => true
  #     2.0 == Rational(2, 1) # => true
  #     2.0 == Complex(2, 0)  # => true
  #
  # `Float::NAN == Float::NAN` returns an implementation-dependent value.
  #
  # Related: Float#eql? (requires `other` to be a Float).
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than `other`:
  #
  #     2.0 > 1              # => true
  #     2.0 > 1.0            # => true
  #     2.0 > Rational(1, 2) # => true
  #     2.0 > 2.0            # => false
  #
  # `Float::NAN > Float::NAN` returns an implementation-dependent value.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= other -> true or false
  # -->
  # Returns `true` if `self` is numerically greater than or equal to `other`:
  #
  #     2.0 >= 1              # => true
  #     2.0 >= 1.0            # => true
  #     2.0 >= Rational(1, 2) # => true
  #     2.0 >= 2.0            # => true
  #     2.0 >= 2.1            # => false
  #
  # `Float::NAN >= Float::NAN` returns an implementation-dependent value.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.abs        ->  float
  #   - float.magnitude  ->  float
  # -->
  # Returns the absolute value of `float`.
  #
  #     (-34.56).abs   #=> 34.56
  #     -34.56.abs     #=> 34.56
  #     34.56.abs      #=> 34.56
  #
  # Float#magnitude is an alias for Float#abs.
  #
  def abs: () -> Float

  def abs2: () -> Float

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=complex.c
  #   - flo.arg    ->  0 or float
  #   - flo.angle  ->  0 or float
  #   - flo.phase  ->  0 or float
  # -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> float or integer
  # -->
  # Returns the smallest number greater than or equal to `self` with a precision
  # of `ndigits` decimal digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.ceil(1) # => 12345.7
  #     f.ceil(3) # => 12345.679
  #     f = -12345.6789
  #     f.ceil(1) # => -12345.6
  #     f.ceil(3) # => -12345.678
  #
  # When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.ceil(0)  # => 12346
  #     f.ceil(-3) # => 13000
  #     f = -12345.6789
  #     f.ceil(0)  # => -12345
  #     f.ceil(-3) # => -12000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (2.1 / 0.7).ceil  #=> 4 (!)
  #
  # Related: Float#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing `other` converted to a Float and `self`:
  #
  #     f = 3.14                 # => 3.14
  #     f.coerce(2)              # => [2.0, 3.14]
  #     f.coerce(2.0)            # => [2.0, 3.14]
  #     f.coerce(Rational(1, 2)) # => [0.5, 3.14]
  #     f.coerce(Complex(1, 0))  # => [1.0, 3.14]
  #
  # Raises an exception if a type conversion fails.
  #
  def coerce: (Numeric) -> [ Float, Float ]

  def conj: () -> Float

  def conjugate: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flo.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).  The result is machine dependent.
  #
  # See also Float#numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor      # Quotient
  #     r = self % other            # Remainder
  #
  # Examples:
  #
  #     11.0.divmod(4)              # => [2, 3.0]
  #     11.0.divmod(-4)             # => [-3, -1.0]
  #     -11.0.divmod(4)             # => [-3, 1.0]
  #     -11.0.divmod(-4)            # => [2, -3.0]
  #
  #     12.0.divmod(4)              # => [3, 0.0]
  #     12.0.divmod(-4)             # => [-3, 0.0]
  #     -12.0.divmod(4)             # => [-3, -0.0]
  #     -12.0.divmod(-4)            # => [3, -0.0]
  #
  #     13.0.divmod(4.0)            # => [3, 1.0]
  #     13.0.divmod(Rational(4, 1)) # => [3, 1.0]
  #
  def divmod: (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `other` is a Float with the same value as `self`, `false`
  # otherwise:
  #
  #     2.0.eql?(2.0)            # => true
  #     2.0.eql?(1.0)            # => false
  #     2.0.eql?(1)              # => false
  #     2.0.eql?(Rational(2, 1)) # => false
  #     2.0.eql?(Complex(2, 0))  # => false
  #
  # `Float::NAN.eql?(Float::NAN)` returns an implementation-dependent value.
  #
  # Related: Float#== (performs type conversions).
  #
  def eql?: (untyped) -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  # Float#fdiv is an alias for Float#quo.
  #
  def fdiv: (Complex) -> Complex
          | (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - finite? -> true or false
  # -->
  # Returns `true` if `self` is not `Infinity`, `-Infinity`, or `Nan`, `false`
  # otherwise:
  #
  #     f = 2.0      # => 2.0
  #     f.finite?    # => true
  #     f = 1.0/0.0  # => Infinity
  #     f.finite?    # => false
  #     f = -1.0/0.0 # => -Infinity
  #     f.finite?    # => false
  #     f = 0.0/0.0  # => NaN
  #     f.finite?    # => false
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> float or integer
  # -->
  # Returns the largest number less than or equal to `self` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.floor(1) # => 12345.6
  #     f.floor(3) # => 12345.678
  #     f = -12345.6789
  #     f.floor(1) # => -12345.7
  #     f.floor(3) # => -12345.679
  #
  # When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.floor(0)  # => 12345
  #     f.floor(-3) # => 12000
  #     f = -12345.6789
  #     f.floor(0)  # => -12346
  #     f.floor(-3) # => -13000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).floor  #=> 2 (!)
  #
  # Related: Float#ceil.
  #
  def floor: () -> Integer
           | (int digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - infinite? -> -1, 1, or nil
  # -->
  # Returns:
  #
  # *   1, if `self` is `Infinity`.
  # *   -1 if `self` is `-Infinity`.
  # *   `nil`, otherwise.
  #
  #
  # Examples:
  #
  #     f = 1.0/0.0  # => Infinity
  #     f.infinite?  # => 1
  #     f = -1.0/0.0 # => -Infinity
  #     f.infinite?  # => -1
  #     f = 1.0      # => 1.0
  #     f.infinite?  # => nil
  #     f = 0.0/0.0  # => NaN
  #     f.infinite?  # => nil
  #
  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  # *   A number in "scientific notation" (containing an exponent).
  # *   'Infinity'.
  # *   '-Infinity'.
  # *   'NaN' (indicating not-a-number).
  #
  #     3.14.to_s         # => "3.14" (10.1**50).to_s   # =>
  #     "1.644631821843879e+50" (10.1**500).to_s  # => "Infinity"
  #     (-10.1**500).to_s # => "-Infinity" (0.0/0.0).to_s    # => "NaN"
  #
  alias inspect to_s

  def integer?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a float.
  #
  # For float `f` and real number `r`, these expressions are equivalent:
  #
  #     f % r
  #     f-r*(f/r).floor
  #     f.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10.0 % 2              # => 0.0
  #     10.0 % 3              # => 1.0
  #     10.0 % 4              # => 2.0
  #
  #     10.0 % -2             # => 0.0
  #     10.0 % -3             # => -2.0
  #     10.0 % -4             # => -2.0
  #
  #     10.0 % 4.0            # => 2.0
  #     10.0 % Rational(4, 1) # => 2.0
  #
  # Float#modulo is an alias for Float#%.
  #
  def modulo: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - nan? -> true or false
  # -->
  # Returns `true` if `self` is a NaN, `false` otherwise.
  #
  #     f = -1.0     #=> -1.0
  #     f.nan?       #=> false
  #     f = 0.0/0.0  #=> NaN
  #     f.nan?       #=> true
  #
  def nan?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.negative?  ->  true or false
  # -->
  # Returns `true` if `float` is less than 0.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - next_float -> float
  # -->
  # Returns the next-larger representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.next_float`:
  #
  #     f = 0.0      # 0x0000000000000000
  #     f.next_float # 0x0000000000000001
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.next_float # 0x3f847ae147ae147c
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.next_float    # => 0.010000000000000002
  #     1.0.next_float     # => 1.0000000000000002
  #     100.0.next_float   # => 100.00000000000001
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.next_float }
  #
  # Output:
  #
  #      0 0x1.47ae147ae147bp-7 0.01
  #      1 0x1.47ae147ae147cp-7 0.010000000000000002
  #      2 0x1.47ae147ae147dp-7 0.010000000000000004
  #      3 0x1.47ae147ae147ep-7 0.010000000000000005
  #
  #     f = 0.0; 100.times { f += 0.1 }
  #     f                           # => 9.99999999999998       # should be 10.0 in the ideal world.
  #     10-f                        # => 1.9539925233402755e-14 # the floating point error.
  #     10.0.next_float-10          # => 1.7763568394002505e-15 # 1 ulp (unit in the last place).
  #     (10-f)/(10.0.next_float-10) # => 11.0                   # the error is 11 ulp.
  #     (10-f)/(10*Float::EPSILON)  # => 8.8                    # approximation of the above.
  #     "%a" % 10                   # => "0x1.4p+3"
  #     "%a" % f                    # => "0x1.3fffffffffff5p+3" # the last hex digit is 5.  16 - 5 = 11 ulp.
  #
  # Related: Float#prev_float
  #
  def next_float: () -> Float

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - flo.numerator  ->  integer
  # -->
  # Returns the numerator.  The result is machine dependent.
  #
  #     n = 0.3.numerator    #=> 5404319552844595
  #     d = 0.3.denominator  #=> 18014398509481984
  #     n.fdiv(d)            #=> 0.3
  #
  # See also Float#denominator.
  #
  def numerator: () -> Integer

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias phase angle

  def polar: () -> [ Float, Integer | Float ]

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.positive?  ->  true or false
  # -->
  # Returns `true` if `float` is greater than 0.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - float.prev_float  ->  float
  # -->
  # Returns the next-smaller representable Float.
  #
  # These examples show the internally stored values (64-bit hexadecimal) for each
  # Float `f` and for the corresponding `f.pev_float`:
  #
  #     f = 5e-324   # 0x0000000000000001
  #     f.prev_float # 0x0000000000000000
  #
  #     f = 0.01     # 0x3f847ae147ae147b
  #     f.prev_float # 0x3f847ae147ae147a
  #
  # In the remaining examples here, the output is shown in the usual way (result
  # `to_s`):
  #
  #     0.01.prev_float   # => 0.009999999999999998
  #     1.0.prev_float    # => 0.9999999999999999
  #     100.0.prev_float  # => 99.99999999999999
  #
  #     f = 0.01
  #     (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.prev_float }
  #
  # Output:
  #
  #     0 0x1.47ae147ae147bp-7 0.01
  #     1 0x1.47ae147ae147ap-7 0.009999999999999998
  #     2 0x1.47ae147ae1479p-7 0.009999999999999997
  #     3 0x1.47ae147ae1478p-7 0.009999999999999995
  #
  # Related: Float#next_float.
  #
  def prev_float: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - quo(other) -> numeric
  # -->
  # Returns the quotient from dividing `self` by `other`:
  #
  #     f = 3.14
  #     f.quo(2)              # => 1.57
  #     f.quo(-2)             # => -1.57
  #     f.quo(Rational(2, 1)) # => 1.57
  #     f.quo(Complex(2, 0))  # => (1.57+0.0i)
  #
  # Float#fdiv is an alias for Float#quo.
  #
  def quo: (Complex) -> Complex
         | (Numeric) -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - flt.rationalize([eps])  ->  rational
  # -->
  # Returns a simpler approximation of the value (flt-|eps| <= result <=
  # flt+|eps|).  If the optional argument `eps` is not given, it will be chosen
  # automatically.
  #
  #     0.3.rationalize          #=> (3/10)
  #     1.333.rationalize        #=> (1333/1000)
  #     1.333.rationalize(0.01)  #=> (4/3)
  #
  # See also Float#to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Float

  def real?: () -> true

  def rect: () -> [ Float, Numeric ]

  alias rectangular rect

  def remainder: (Numeric) -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits = 0, half: :up]) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is non-negative, returns a float with `ndigits` after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.round(1) # => 12345.7
  #     f.round(3) # => 12345.679
  #     f = -12345.6789
  #     f.round(1) # => -12345.7
  #     f.round(3) # => -12345.679
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.round(0)  # => 12346
  #     f.round(-3) # => 12000
  #     f = -12345.6789
  #     f.round(0)  # => -12346
  #     f.round(-3) # => -12000
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         2.5.round(half: :up)      # => 3
  #         3.5.round(half: :up)      # => 4
  #         (-2.5).round(half: :up)   # => -3
  #
  # *   `:down`: round toward zero:
  #
  #         2.5.round(half: :down)    # => 2
  #         3.5.round(half: :down)    # => 3
  #         (-2.5).round(half: :down) # => -2
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         2.5.round(half: :even)    # => 2
  #         3.5.round(half: :even)    # => 4
  #         (-2.5).round(half: :even) # => -2
  #
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Float#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  def step: (?Numeric limit, ?Numeric step) { (Float) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Float, self]
          | (?by: Numeric, ?to: Numeric) { (Float) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Float, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.to_f  ->  self
  # -->
  # Since `float` is already a Float, returns `self`.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.c
  #   - to_i -> integer
  # -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  # Float#to_int is an alias for Float#to_i.
  #
  def to_i: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` truncated to an Integer.
  #
  #     1.2.to_i    # => 1
  #     (-1.2).to_i # => -1
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).to_i  # => 2 (!)
  #
  # Float#to_int is an alias for Float#to_i.
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - flt.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     2.0.to_r    #=> (2/1)
  #     2.5.to_r    #=> (5/2)
  #     -0.75.to_r  #=> (-3/4)
  #     0.0.to_r    #=> (0/1)
  #     0.3.to_r    #=> (5404319552844595/18014398509481984)
  #
  # NOTE: 0.3.to_r isn't the same as "0.3".to_r.  The latter is equivalent to
  # "3/10".to_r, but the former isn't so.
  #
  #     0.3.to_r   == 3/10r  #=> false
  #     "0.3".to_r == 3/10r  #=> true
  #
  # See also Float#rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s -> string
  # -->
  # Returns a string containing a representation of `self`; depending of the value
  # of `self`, the string representation may contain:
  #
  # *   A fixed-point number.
  # *   A number in "scientific notation" (containing an exponent).
  # *   'Infinity'.
  # *   '-Infinity'.
  # *   'NaN' (indicating not-a-number).
  #
  #     3.14.to_s         # => "3.14" (10.1**50).to_s   # =>
  #     "1.644631821843879e+50" (10.1**500).to_s  # => "Infinity"
  #     (-10.1**500).to_s # => "-Infinity" (0.0/0.0).to_s    # => "NaN"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> float or integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is positive, returns a float with `ndigits` digits after the
  # decimal point (as available):
  #
  #     f = 12345.6789
  #     f.truncate(1) # => 12345.6
  #     f.truncate(3) # => 12345.678
  #     f = -12345.6789
  #     f.truncate(1) # => -12345.6
  #     f.truncate(3) # => -12345.678
  #
  # When `ndigits` is negative, returns an integer with at least `ndigits.abs`
  # trailing zeros:
  #
  #     f = 12345.6789
  #     f.truncate(0)  # => 12345
  #     f.truncate(-3) # => 12000
  #     f = -12345.6789
  #     f.truncate(0)  # => -12345
  #     f.truncate(-3) # => -12000
  #
  # Note that the limited precision of floating-point arithmetic may lead to
  # surprising results:
  #
  #     (0.3 / 0.1).truncate  #=> 2 (!)
  #
  # Related: Float#round.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - float.zero?  ->  true or false
  # -->
  # Returns `true` if `float` is 0.0.
  #
  def zero?: () -> bool
end

# <!-- rdoc-file=numeric.c -->
# The minimum number of significant decimal digits in a double-precision
# floating point.
#
# Usually defaults to 15.
#
Float::DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The difference between 1 and the smallest double-precision floating point
# number greater than 1.
#
# Usually defaults to 2.2204460492503131e-16.
#
Float::EPSILON: Float

# <!-- rdoc-file=numeric.c -->
# An expression representing positive infinity.
#
Float::INFINITY: Float

# <!-- rdoc-file=numeric.c -->
# The number of base digits for the `double` data type.
#
# Usually defaults to 53.
#
Float::MANT_DIG: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible integer in a double-precision floating point number.
#
# Usually defaults to 1.7976931348623157e+308.
#
Float::MAX: Float

# <!-- rdoc-file=numeric.c -->
# The largest positive exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to 308.
#
Float::MAX_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The largest possible exponent value in a double-precision floating point.
#
# Usually defaults to 1024.
#
Float::MAX_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest positive normalized number in a double-precision floating point.
#
# Usually defaults to 2.2250738585072014e-308.
#
# If the platform supports denormalized numbers, there are numbers between zero
# and Float::MIN. 0.0.next_float returns the smallest positive floating point
# number including denormalized numbers.
#
Float::MIN: Float

# <!-- rdoc-file=numeric.c -->
# The smallest negative exponent in a double-precision floating point where 10
# raised to this power minus 1.
#
# Usually defaults to -307.
#
Float::MIN_10_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# The smallest possible exponent value in a double-precision floating point.
#
# Usually defaults to -1021.
#
Float::MIN_EXP: Integer

# <!-- rdoc-file=numeric.c -->
# An expression representing a value which is "not a number".
#
Float::NAN: Float

# <!-- rdoc-file=numeric.c -->
# The base of the floating point, or number of unique digits used to represent
# the number.
#
# Usually defaults to 2 on most systems, which would represent a base-10
# decimal.
#
Float::RADIX: Integer

# Deprecated, do not use.
#
# Represents the rounding mode for floating point addition at the start time.
#
# Usually defaults to 1, rounding to the nearest number.
#
# Other modes include:
#
# -1
# :   Indeterminable
# 0
# :   Rounding towards zero
# 1
# :   Rounding to the nearest number
# 2
# :   Rounding towards positive infinity
# 3
# :   Rounding towards negative infinity
#
#
Float::ROUNDS: Integer

# <!-- rdoc-file=hash.c -->
# ENV is a hash-like accessor for environment variables.
#
# ### Interaction with the Operating System
#
# The ENV object interacts with the operating system's environment variables:
#
# *   When you get the value for a name in ENV, the value is retrieved from
#     among the current environment variables.
# *   When you create or set a name-value pair in ENV, the name and value are
#     immediately set in the environment variables.
# *   When you delete a name-value pair in ENV, it is immediately deleted from
#     the environment variables.
#
#
# ### Names and Values
#
# Generally, a name or value is a String.
#
# #### Valid Names and Values
#
# Each name or value must be one of the following:
#
# *   A String.
# *   An object that responds to #to_str by returning a String, in which case
#     that String will be used as the name or value.
#
#
# #### Invalid Names and Values
#
# A new name:
#
# *   May not be the empty string:
#         ENV[''] = '0'
#         # Raises Errno::EINVAL (Invalid argument - ruby_setenv())
#
# *   May not contain character `"="`:
#         ENV['='] = '0'
#         # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))
#
#
# A new name or value:
#
# *   May not be a non-String that does not respond to #to_str:
#
#         ENV['foo'] = Object.new
#         # Raises TypeError (no implicit conversion of Object into String)
#         ENV[Object.new] = '0'
#         # Raises TypeError (no implicit conversion of Object into String)
#
# *   May not contain the NUL character `"\0"`:
#
#         ENV['foo'] = "\0"
#         # Raises ArgumentError (bad environment variable value: contains null byte)
#         ENV["\0"] == '0'
#         # Raises ArgumentError (bad environment variable name: contains null byte)
#
# *   May not have an ASCII-incompatible encoding such as UTF-16LE or
#     ISO-2022-JP:
#
#         ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
#         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
#         ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
#         # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
#
#
# ### About Ordering
#
# ENV enumerates its name/value pairs in the order found in the operating
# system's environment variables. Therefore the ordering of ENV content is
# OS-dependent, and may be indeterminate.
#
# This will be seen in:
# *   A Hash returned by an ENV method.
# *   An Enumerator returned by an ENV method.
# *   An Array returned by ENV.keys, ENV.values, or ENV.to_a.
# *   The String returned by ENV.inspect.
# *   The Array returned by ENV.shift.
# *   The name returned by ENV.key.
#
#
# ### About the Examples
# Some methods in ENV return ENV itself. Typically, there are many environment
# variables. It's not useful to display a large ENV in the examples here, so
# most example snippets begin by resetting the contents of ENV:
# *   ENV.replace replaces ENV with a new collection of entries.
# *   ENV.clear empties ENV.
#
#
# ## What's Here
#
# First, what's elsewhere. Class ENV:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Extends [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here),
#
#
# Here, class ENV provides methods that are useful for:
#
# *   [Querying](#class-ENV-label-Methods+for+Querying)
# *   [Assigning](#class-ENV-label-Methods+for+Assigning)
# *   [Deleting](#class-ENV-label-Methods+for+Deleting)
# *   [Iterating](#class-ENV-label-Methods+for+Iterating)
# *   [Converting](#class-ENV-label-Methods+for+Converting)
# *   [And more ....](#class-ENV-label-More+Methods)
#
#
# ### Methods for Querying
#
#     ::[]
# :       Returns the value for the given environment variable name if it
#         exists:
#
#     ::empty?
# :       Returns whether ENV is empty.
#
#     ::has_value?, ::value?
# :       Returns whether the given value is in ENV.
#
#     ::include?, ::has_key?, ::key?, ::member?
# :       Returns whether the given name is in ENV.
#
#     ::key
# :       Returns the name of the first entry with the given value.
#
#     ::size, ::length
# :       Returns the number of entries.
#
#     ::value?
# :       Returns whether any entry has the given value.
#
#
#
# ### Methods for Assigning
#
#     ::[]=, ::store
# :       Creates, updates, or deletes the named environment variable.
#
#     ::clear
# :       Removes every environment variable; returns ENV:
#
#     ::update, ::merge!
# :       Adds to ENV each key/value pair in the given hash.
#
#     ::replace
# :       Replaces the entire content of the ENV with the name/value pairs in
#         the given hash.
#
#
#
# ### Methods for Deleting
#
#     ::delete
# :       Deletes the named environment variable name if it exists.
#
#     ::delete_if
# :       Deletes entries selected by the block.
#
#     ::keep_if
# :       Deletes entries not selected by the block.
#
#     ::reject!
# :       Similar to #delete_if, but returns `nil` if no change was made.
#
#     ::select!, ::filter!
# :       Deletes entries selected by the block.
#
#     ::shift
# :       Removes and returns the first entry.
#
#
#
# ### Methods for Iterating
#
#     ::each, ::each_pair
# :       Calls the block with each name/value pair.
#
#     ::each_key
# :       Calls the block with each name.
#
#     ::each_value
# :       Calls the block with each value.
#
#
#
# ### Methods for Converting
#
#     ::assoc
# :       Returns a 2-element array containing the name and value of the named
#         environment variable if it exists:
#
#     ::clone
# :       Returns ENV (and issues a warning).
#
#     ::except
# :       Returns a hash of all name/value pairs except those given.
#
#     ::fetch
# :       Returns the value for the given name.
#
#     ::inspect
# :       Returns the contents of ENV as a string.
#
#     ::invert
# :       Returns a hash whose keys are the ENV values, and whose values are the
#         corresponding ENV names.
#
#     ::keys
# :       Returns an array of all names.
#
#     ::rassoc
# :       Returns the name and value of the first found entry that has the given
#         value.
#
#     ::reject
# :       Returns a hash of those entries not rejected by the block.
#
#     ::select, ::filter
# :       Returns a hash of name/value pairs selected by the block.
#
#     ::slice
# :       Returns a hash of the given names and their corresponding values.
#
#     ::to_a
# :       Returns the entries as an array of 2-element Arrays.
#
#     ::to_h
# :       Returns a hash of entries selected by the block.
#
#     ::to_hash
# :       Returns a hash of all entries.
#
#     ::to_s
# :       Returns the string `'ENV'`.
#
#     ::values
# :       Returns all values as an array.
#
#     ::values_at
# :       Returns an array of the values for the given name.
#
#
#
# ### More Methods
#
#     ::dup
# :       Raises an exception.
#
#     ::freeze
# :       Raises an exception.
#
#     ::rehash
# :       Returns `nil`, without modifying ENV.
#
%a{annotate:rdoc:copy:ENV}
class ENVClass
  include Enumerable[[ String, String ]]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] -> value
  # -->
  # Returns the value for the environment variable `name` if it exists:
  #     ENV['foo'] = '0'
  #     ENV['foo'] # => "0"
  #
  # Returns `nil` if the named variable does not exist.
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.[]}
  def []: (String name) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.fetch(name)                  -> value
  #   - ENV.fetch(name, default)         -> value
  #   - ENV.fetch(name) { |name| block } -> value
  # -->
  # If `name` is the name of an environment variable, returns its value:
  #     ENV['foo'] = '0'
  #     ENV.fetch('foo') # => '0'
  #
  # Otherwise if a block is given (but not a default value), yields `name` to the
  # block and returns the block's return value:
  #     ENV.fetch('foo') { |name| :need_not_return_a_string } # => :need_not_return_a_string
  #
  # Otherwise if a default value is given (but not a block), returns the default
  # value:
  #     ENV.delete('foo')
  #     ENV.fetch('foo', :default_need_not_be_a_string) # => :default_need_not_be_a_string
  #
  # If the environment variable does not exist and both default and block are
  # given, issues a warning ("warning: block supersedes default value argument"),
  # yields `name` to the block, and returns the block's return value:
  #     ENV.fetch('foo', :default) { |name| :block_return } # => :block_return
  #
  # Raises KeyError if `name` is valid, but not found, and neither default value
  # nor block is given:
  #     ENV.fetch('foo') # Raises KeyError (key not found: "foo")
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.fetch}
  def fetch: (String name) -> String
           | [X] (String name, X default) -> (String | X)
           | [X] (String name) { (String) -> X } -> (String | X)

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] = value      -> value
  #   - ENV.store(name, value) -> value
  # -->
  # ENV.store is an alias for ENV.[]=.
  #
  # Creates, updates, or deletes the named environment variable, returning the
  # value. Both `name` and `value` may be instances of String. See [Valid Names
  # and Values](#class-ENV-label-Valid+Names+and+Values).
  #
  # *   If the named environment variable does not exist:
  #     *   If `value` is `nil`, does nothing.
  #             ENV.clear
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #     *   If `value` is not `nil`, creates the environment variable with `name`
  #         and `value`:
  #             # Create 'foo' using ENV.[]=.
  #             ENV['foo'] = '0' # => '0'
  #             ENV['foo'] # => '0'
  #             # Create 'bar' using ENV.store.
  #             ENV.store('bar', '1') # => '1'
  #             ENV['bar'] # => '1'
  #
  #
  # *   If the named environment variable exists:
  #     *   If `value` is not `nil`, updates the environment variable with value
  #         `value`:
  #             # Update 'foo' using ENV.[]=.
  #             ENV['foo'] = '2' # => '2'
  #             ENV['foo'] # => '2'
  #             # Update 'bar' using ENV.store.
  #             ENV.store('bar', '3') # => '3'
  #             ENV['bar'] # => '3'
  #
  #     *   If `value` is `nil`, deletes the environment variable:
  #             # Delete 'foo' using ENV.[]=.
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             # Delete 'bar' using ENV.store.
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #
  #
  # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.[]=}
  def []=: (String name, String? value) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV[name] = value      -> value
  #   - ENV.store(name, value) -> value
  # -->
  # ENV.store is an alias for ENV.[]=.
  #
  # Creates, updates, or deletes the named environment variable, returning the
  # value. Both `name` and `value` may be instances of String. See [Valid Names
  # and Values](#class-ENV-label-Valid+Names+and+Values).
  #
  # *   If the named environment variable does not exist:
  #     *   If `value` is `nil`, does nothing.
  #             ENV.clear
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #     *   If `value` is not `nil`, creates the environment variable with `name`
  #         and `value`:
  #             # Create 'foo' using ENV.[]=.
  #             ENV['foo'] = '0' # => '0'
  #             ENV['foo'] # => '0'
  #             # Create 'bar' using ENV.store.
  #             ENV.store('bar', '1') # => '1'
  #             ENV['bar'] # => '1'
  #
  #
  # *   If the named environment variable exists:
  #     *   If `value` is not `nil`, updates the environment variable with value
  #         `value`:
  #             # Update 'foo' using ENV.[]=.
  #             ENV['foo'] = '2' # => '2'
  #             ENV['foo'] # => '2'
  #             # Update 'bar' using ENV.store.
  #             ENV.store('bar', '3') # => '3'
  #             ENV['bar'] # => '3'
  #
  #     *   If `value` is `nil`, deletes the environment variable:
  #             # Delete 'foo' using ENV.[]=.
  #             ENV['foo'] = nil # => nil
  #             ENV.include?('foo') # => false
  #             # Delete 'bar' using ENV.store.
  #             ENV.store('bar', nil) # => nil
  #             ENV.include?('bar') # => false
  #
  #
  #
  # Raises an exception if `name` or `value` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.store}
  alias store []=

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each      { |name, value| block } -> ENV
  #   - ENV.each                              -> an_enumerator
  #   - ENV.each_pair { |name, value| block } -> ENV
  #   - ENV.each_pair                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array:
  #     h = {}
  #     ENV.each_pair { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     h = {}
  #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
  #     e.each { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.each}
  def each: () -> ::Enumerator[[ String, String ], self]
          | () { ([ String, String ]) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each      { |name, value| block } -> ENV
  #   - ENV.each                              -> an_enumerator
  #   - ENV.each_pair { |name, value| block } -> ENV
  #   - ENV.each_pair                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array:
  #     h = {}
  #     ENV.each_pair { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     h = {}
  #     e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
  #     e.each { |name, value| h[name] = value } # => ENV
  #     h # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.each_pair}
  def each_pair: () -> ::Enumerator[[ String, String ], self]
               | () { ([ String, String ]) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each_key { |name| block } -> ENV
  #   - ENV.each_key                  -> an_enumerator
  # -->
  # Yields each environment variable name:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     names = []
  #     ENV.each_key { |name| names.push(name) } # => ENV
  #     names # => ["bar", "foo"]
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.each_key # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_key>
  #     names = []
  #     e.each { |name| names.push(name) } # => ENV
  #     names # => ["bar", "foo"]
  #
  %a{annotate:rdoc:copy:ENV.each_key}
  def each_key: () -> ::Enumerator[[ String ], self]
              | () { (String name) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.each_value { |value| block } -> ENV
  #   - ENV.each_value                   -> an_enumerator
  # -->
  # Yields each environment variable value:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     values = []
  #     ENV.each_value { |value| values.push(value) } # => ENV
  #     values # => ["1", "0"]
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.each_value # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_value>
  #     values = []
  #     e.each { |value| values.push(value) } # => ENV
  #     values # => ["1", "0"]
  #
  %a{annotate:rdoc:copy:ENV.each_value}
  def each_value: () -> ::Enumerator[[ String ], self]
                | () { (String value) -> void } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.delete(name)                           -> value
  #   - ENV.delete(name) { |name| block }          -> value
  #   - ENV.delete(missing_name)                   -> nil
  #   - ENV.delete(missing_name) { |name| block }  -> block_value
  # -->
  # Deletes the environment variable with `name` if it exists and returns its
  # value:
  #     ENV['foo'] = '0'
  #     ENV.delete('foo') # => '0'
  #
  # If a block is not given and the named environment variable does not exist,
  # returns `nil`.
  #
  # If a block given and the environment variable does not exist, yields `name` to
  # the block and returns the value of the block:
  #     ENV.delete('foo') { |name| name * 2 } # => "foofoo"
  #
  # If a block given and the environment variable exists, deletes the environment
  # variable and returns its value (ignoring the block):
  #     ENV['foo'] = '0'
  #     ENV.delete('foo') { |name| raise 'ignored' } # => "0"
  #
  # Raises an exception if `name` is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.delete}
  def delete: (String name) -> String?
            | (String name) { (String) -> String } -> String

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.delete_if { |name, value| block } -> ENV
  #   - ENV.delete_if                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns a truthy value,
  # and returning ENV (regardless of whether any deletions):
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.delete_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:delete_if!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #
  %a{annotate:rdoc:copy:ENV.delete_if}
  def delete_if: () -> ::Enumerator[[ String, String ], self]
               | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.keep_if { |name, value| block } -> ENV
  #   - ENV.keep_if                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns `false` or
  # `nil`, and returning ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.keep_if { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.keep_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:keep_if>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.keep_if}
  def keep_if: () -> ::Enumerator[[ String, String ], self]
             | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.slice(*names) -> hash of name/value pairs
  # -->
  # Returns a Hash of the given ENV names and their corresponding values:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2', 'bat' => '3')
  #     ENV.slice('foo', 'baz') # => {"foo"=>"0", "baz"=>"2"}
  #     ENV.slice('baz', 'foo') # => {"baz"=>"2", "foo"=>"0"}
  #
  # Raises an exception if any of the `names` is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.slice('foo', 'bar', :bat) # Raises TypeError (no implicit conversion of Symbol into String)
  #
  %a{annotate:rdoc:copy:ENV.slice}
  def slice: (*String names) -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.except(*keys) -> a_hash
  # -->
  # Returns a hash except the given keys from ENV and their values.
  #
  #     ENV                       #=> {"LANG"=>"en_US.UTF-8", "TERM"=>"xterm-256color", "HOME"=>"/Users/rhc"}
  #     ENV.except("TERM","HOME") #=> {"LANG"=>"en_US.UTF-8"}
  #
  %a{annotate:rdoc:copy:ENV.except}
  def except: (*String names) -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.clear -> ENV
  # -->
  # Removes every environment variable; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.size # => 2
  #     ENV.clear # => ENV
  #     ENV.size # => 0
  #
  %a{annotate:rdoc:copy:ENV.clear}
  def clear: () -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.reject { |name, value| block } -> hash of name/value pairs
  #   - ENV.reject                         -> an_enumerator
  # -->
  # Yields each environment variable name and its value as a 2-element Array.
  # Returns a Hash whose items are determined by the block. When the block returns
  # a truthy value, the name/value pair is added to the return Hash; otherwise the
  # pair is ignored:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.reject { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.reject
  #     e.each { |name, value| name.start_with?('b') } # => {"foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.reject}
  def reject: () -> ::Enumerator[[ String, String ], self]
            | () { (String name, String value) -> boolish } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.reject! { |name, value| block } -> ENV or nil
  #   - ENV.reject!                         -> an_enumerator
  # -->
  # Similar to ENV.delete_if, but returns `nil` if no changes were made.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each environment variable for which the block returns a truthy value,
  # and returning ENV (if any deletions) or `nil` (if not):
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.reject! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     ENV.reject! { |name, value| name.start_with?('b') } # => nil
  #
  # Returns an Enumerator if no block given:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.reject! # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:reject!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"foo"=>"0"}
  #     e.each { |name, value| name.start_with?('b') } # => nil
  #
  %a{annotate:rdoc:copy:ENV.reject!}
  def reject!: () -> ::Enumerator[[ String, String ], self?]
             | () { (String name, String value) -> boolish } -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select { |name, value| block } -> hash of name/value pairs
  #   - ENV.select                         -> an_enumerator
  #   - ENV.filter { |name, value| block } -> hash of name/value pairs
  #   - ENV.filter                         -> an_enumerator
  # -->
  # ENV.filter is an alias for ENV.select.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # returning a Hash of the names and values for which the block returns a truthy
  # value:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.select}
  def select: () -> ::Enumerator[[ String, String ], ::Hash[String, String]]
            | () { (String name, String value) -> boolish } -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select { |name, value| block } -> hash of name/value pairs
  #   - ENV.select                         -> an_enumerator
  #   - ENV.filter { |name, value| block } -> hash of name/value pairs
  #   - ENV.filter                         -> an_enumerator
  # -->
  # ENV.filter is an alias for ENV.select.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # returning a Hash of the names and values for which the block returns a truthy
  # value:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  # Returns an Enumerator if no block given:
  #     e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #     e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
  #     e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
  #
  %a{annotate:rdoc:copy:ENV.filter}
  alias filter select

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select! { |name, value| block } -> ENV or nil
  #   - ENV.select!                         -> an_enumerator
  #   - ENV.filter! { |name, value| block } -> ENV or nil
  #   - ENV.filter!                         -> an_enumerator
  # -->
  # ENV.filter! is an alias for ENV.select!.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each entry for which the block returns `false` or `nil`, and
  # returning ENV if any deletions made, or `nil` otherwise:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.select! { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter! { |name, value| true } # => nil
  #
  # Returns an Enumerator if no block given:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  %a{annotate:rdoc:copy:ENV.select!}
  def select!: () -> ::Enumerator[[ String, String ], self?]
             | () { (String name, String value) -> boolish } -> self?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.select! { |name, value| block } -> ENV or nil
  #   - ENV.select!                         -> an_enumerator
  #   - ENV.filter! { |name, value| block } -> ENV or nil
  #   - ENV.filter!                         -> an_enumerator
  # -->
  # ENV.filter! is an alias for ENV.select!.
  #
  # Yields each environment variable name and its value as a 2-element Array,
  # deleting each entry for which the block returns `false` or `nil`, and
  # returning ENV if any deletions made, or `nil` otherwise:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.select! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.select! { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.filter! { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     ENV.filter! { |name, value| true } # => nil
  #
  # Returns an Enumerator if no block given:
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
  #     e.each { |name, value| name.start_with?('b') } # => ENV
  #     ENV # => {"bar"=>"1", "baz"=>"2"}
  #     e.each { |name, value| true } # => nil
  #
  %a{annotate:rdoc:copy:ENV.filter!}
  alias filter! select!

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.shift -> [name, value] or nil
  # -->
  # Removes the first environment variable from ENV and returns a 2-element Array
  # containing its name and value:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_hash # => {'bar' => '1', 'foo' => '0'}
  #     ENV.shift # => ['bar', '1']
  #     ENV.to_hash # => {'foo' => '0'}
  #
  # Exactly which environment variable is "first" is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if the environment is empty.
  #
  %a{annotate:rdoc:copy:ENV.shift}
  def shift: () -> [ String, String ]?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.invert -> hash of value/name pairs
  # -->
  # Returns a Hash whose keys are the ENV values, and whose values are the
  # corresponding ENV names:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.invert # => {"1"=>"bar", "0"=>"foo"}
  #
  # For a duplicate ENV value, overwrites the hash entry:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.invert # => {"0"=>"foo"}
  #
  # Note that the order of the ENV processing is OS-dependent, which means that
  # the order of overwriting is also OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  %a{annotate:rdoc:copy:ENV.invert}
  def invert: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.replace(hash) -> ENV
  # -->
  # Replaces the entire content of the environment variables with the name/value
  # pairs in the given `hash`; returns ENV.
  #
  # Replaces the content of ENV with the given pairs:
  #     ENV.replace('foo' => '0', 'bar' => '1') # => ENV
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.replace('foo' => '0', :bar => '1') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV.replace('foo' => '0', 'bar' => 1) # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.replace}
  def replace: (Hash[String, String]) -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.update(hash)                                     -> ENV
  #   - ENV.update(hash) { |name, env_val, hash_val| block } -> ENV
  #   - ENV.merge!(hash)                                     -> ENV
  #   - ENV.merge!(hash) { |name, env_val, hash_val| block } -> ENV
  # -->
  # ENV.update is an alias for ENV.merge!.
  #
  # Adds to ENV each key/value pair in the given `hash`; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
  #
  # Deletes the ENV entry for a hash value that is `nil`:
  #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
  #
  # For an already-existing name, if no block given, overwrites the ENV value:
  #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
  #
  # For an already-existing name, if block given, yields the name, its ENV value,
  # and its hash value; the block's return value becomes the new name:
  #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values));
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV # => {"bar"=>"1", "foo"=>"6"}
  #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "foo"=>"7"}
  #
  # Raises an exception if the block returns an invalid name: (see [Invalid Names
  # and Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
  #
  # Note that for the exceptions above, hash pairs preceding an invalid name or
  # value are processed normally; those following are ignored.
  #
  %a{annotate:rdoc:copy:ENV.update}
  def update: (Hash[String, String?]) -> self
            | (Hash[String, String?]) { (String name, String env_val, String? hash_val) -> String } -> self

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.update(hash)                                     -> ENV
  #   - ENV.update(hash) { |name, env_val, hash_val| block } -> ENV
  #   - ENV.merge!(hash)                                     -> ENV
  #   - ENV.merge!(hash) { |name, env_val, hash_val| block } -> ENV
  # -->
  # ENV.update is an alias for ENV.merge!.
  #
  # Adds to ENV each key/value pair in the given `hash`; returns ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}
  #
  # Deletes the ENV entry for a hash value that is `nil`:
  #     ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}
  #
  # For an already-existing name, if no block given, overwrites the ENV value:
  #     ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}
  #
  # For an already-existing name, if block given, yields the name, its ENV value,
  # and its hash value; the block's return value becomes the new name:
  #     ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}
  #
  # Raises an exception if a name or value is invalid (see [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values));
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
  #     ENV # => {"bar"=>"1", "foo"=>"6"}
  #     ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "foo"=>"7"}
  #
  # Raises an exception if the block returns an invalid name: (see [Invalid Names
  # and Values](#class-ENV-label-Invalid+Names+and+Values)):
  #     ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
  #     ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}
  #
  # Note that for the exceptions above, hash pairs preceding an invalid name or
  # value are processed normally; those following are ignored.
  #
  %a{annotate:rdoc:copy:ENV.merge!}
  alias merge! update

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.rehash -> nil
  # -->
  # (Provided for compatibility with Hash.)
  #
  # Does not modify ENV; returns `nil`.
  #
  %a{annotate:rdoc:copy:ENV.rehash}
  def rehash: () -> nil

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_a -> array of 2-element arrays
  # -->
  # Returns the contents of ENV as an Array of 2-element Arrays, each of which is
  # a name/value pair:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_a # => [["bar", "1"], ["foo", "0"]]
  #
  %a{annotate:rdoc:copy:ENV.to_a}
  def to_a: () -> ::Array[[ String, String ]]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_s -> "ENV"
  # -->
  # Returns String 'ENV':
  #     ENV.to_s # => "ENV"
  #
  %a{annotate:rdoc:copy:ENV.to_s}
  def to_s: () -> "ENV"

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.key(value) -> name or nil
  # -->
  # Returns the name of the first environment variable with `value`, if it exists:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.key('0') # => "foo"
  #
  # The order in which environment variables are examined is OS-dependent. See
  # [About Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if there is no such value.
  #
  # Raises an exception if `value` is invalid:
  #     ENV.key(Object.new) # raises TypeError (no implicit conversion of Object into String)
  #
  # See [Invalid Names and Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.key}
  def key: (String value) -> String?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.length -> an_integer
  #   - ENV.size   -> an_integer
  # -->
  # Returns the count of environment variables:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.length # => 2
  #     ENV.size # => 2
  #
  %a{annotate:rdoc:copy:ENV.size}
  def size: () -> Integer

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.length -> an_integer
  #   - ENV.size   -> an_integer
  # -->
  # Returns the count of environment variables:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.length # => 2
  #     ENV.size # => 2
  #
  %a{annotate:rdoc:copy:ENV.length}
  alias length size

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.empty? -> true or false
  # -->
  # Returns `true` when there are no environment variables, `false` otherwise:
  #     ENV.clear
  #     ENV.empty? # => true
  #     ENV['foo'] = '0'
  #     ENV.empty? # => false
  #
  %a{annotate:rdoc:copy:ENV.empty?}
  def empty?: () -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.keys -> array of names
  # -->
  # Returns all variable names in an Array:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.keys # => ['bar', 'foo']
  #
  # The order of the names is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns the empty Array if ENV is empty.
  #
  %a{annotate:rdoc:copy:ENV.keys}
  def keys: () -> ::Array[String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.values -> array of values
  # -->
  # Returns all environment variable values in an Array:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.values # => ['1', '0']
  #
  # The order of the values is OS-dependent. See [About
  # Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns the empty Array if ENV is empty.
  #
  %a{annotate:rdoc:copy:ENV.values}
  def values: () -> ::Array[String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.values_at(*names) -> array of values
  # -->
  # Returns an Array containing the environment variable values associated with
  # the given names:
  #     ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
  #     ENV.values_at('foo', 'baz') # => ["0", "2"]
  #
  # Returns `nil` in the Array for each name that is not an ENV name:
  #     ENV.values_at('foo', 'bat', 'bar', 'bam') # => ["0", nil, "1", nil]
  #
  # Returns an empty Array if no names given.
  #
  # Raises an exception if any name is invalid. See [Invalid Names and
  # Values](#class-ENV-label-Invalid+Names+and+Values).
  #
  %a{annotate:rdoc:copy:ENV.values_at}
  def values_at: (*String names) -> ::Array[String?]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.include?}
  def include?: (String name) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.member?}
  alias member? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.has_key?}
  alias has_key? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.value?(value)     -> true or false
  #   - ENV.has_value?(value) -> true or false
  # -->
  # Returns `true` if `value` is the value for some environment variable name,
  # `false` otherwise:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.value?('0') # => true
  #     ENV.has_value?('0') # => true
  #     ENV.value?('2') # => false
  #     ENV.has_value?('2') # => false
  #
  %a{annotate:rdoc:copy:ENV.has_value?}
  def has_value?: (String value) -> bool

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.value?(value)     -> true or false
  #   - ENV.has_value?(value) -> true or false
  # -->
  # Returns `true` if `value` is the value for some environment variable name,
  # `false` otherwise:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.value?('0') # => true
  #     ENV.has_value?('0') # => true
  #     ENV.value?('2') # => false
  #     ENV.has_value?('2') # => false
  #
  %a{annotate:rdoc:copy:ENV.value?}
  alias value? has_value?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.include?(name) -> true or false
  #   - ENV.has_key?(name) -> true or false
  #   - ENV.member?(name)  -> true or false
  #   - ENV.key?(name)     -> true or false
  # -->
  # ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.
  #
  # Returns `true` if there is an environment variable with the given `name`:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.include?('foo') # => true
  #
  # Returns `false` if `name` is a valid String and there is no such environment
  # variable:
  #     ENV.include?('baz') # => false
  #
  # Returns `false` if `name` is the empty String or is a String containing
  # character `'='`:
  #     ENV.include?('') # => false
  #     ENV.include?('=') # => false
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.key?}
  alias key? include?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.to_hash -> hash of name/value pairs
  # -->
  # Returns a Hash containing all name/value pairs from ENV:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}
  #
  %a{annotate:rdoc:copy:ENV.to_hash}
  def to_hash: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.assoc(name) -> [name, value] or nil
  # -->
  # Returns a 2-element Array containing the name and value of the environment
  # variable for `name` if it exists:
  #     ENV.replace('foo' => '0', 'bar' => '1')
  #     ENV.assoc('foo') # => ['foo', '0']
  #
  # Returns `nil` if `name` is a valid String and there is no such environment
  # variable.
  #
  # Returns `nil` if `name` is the empty String or is a String containing
  # character `'='`.
  #
  # Raises an exception if `name` is a String containing the NUL character `"\0"`:
  #     ENV.assoc("\0") # Raises ArgumentError (bad environment variable name: contains null byte)
  #
  # Raises an exception if `name` has an encoding that is not ASCII-compatible:
  #     ENV.assoc("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
  #     # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)
  #
  # Raises an exception if `name` is not a String:
  #     ENV.assoc(Object.new) # TypeError (no implicit conversion of Object into String)
  #
  %a{annotate:rdoc:copy:ENV.assoc}
  def assoc: (String name) -> [ String, String ]?

  # <!--
  #   rdoc-file=hash.c
  #   - ENV.rassoc(value) -> [name, value] or nil
  # -->
  # Returns a 2-element Array containing the name and value of the **first**
  # **found** environment variable that has value `value`, if one exists:
  #     ENV.replace('foo' => '0', 'bar' => '0')
  #     ENV.rassoc('0') # => ["bar", "0"]
  #
  # The order in which environment variables are examined is OS-dependent. See
  # [About Ordering](#class-ENV-label-About+Ordering).
  #
  # Returns `nil` if there is no such environment variable.
  #
  %a{annotate:rdoc:copy:ENV.rassoc}
  def rassoc: (String value) -> [ String, String ]?
end

# <!-- rdoc-file=hash.c -->
# ENV is a Hash-like accessor for environment variables.
#
# See ENV (the class) for more details.
#
ENV: ENVClass

interface _ToI
  def to_i: () -> Integer
end

interface _ToInt
  def to_int: () -> Integer
end

interface _ToR
  def to_r: () -> Rational
end

interface _ToS
  def to_s: () -> String
end

interface _ToStr
  def to_str: () -> String
end

interface _ToHash[K, V]
  def to_hash: () -> Hash[K, V]
end

interface _ToProc
  def to_proc: () -> untyped
end

interface _ToPath
  def to_path: () -> String
end

interface _Each[out A]
  def each: () { (A) -> void } -> void
end

interface _Reader
  def read: (?int? length, ?string outbuf) -> String?
end

interface _ReaderPartial
  def readpartial: (int maxlen, ?string outbuf) -> String
end

interface _Writer
  # Writes the +data+ string. Returns the number of bytes written
  def write: (*_ToS data) -> Integer
end

interface _Rewindable
  # Positions the stream to the beginning of input, resetting `lineno` to zero.
  #
  def rewind: () -> Integer
end

interface _ToIO
  def to_io: () -> IO
end

interface _Exception
  def exception: () -> Exception
               | (String arg0) -> Exception
end

type int = Integer | _ToInt
type real = Integer | Float | Rational

type string = String | _ToStr
type encoding = Encoding | string

type io = IO | _ToIO

# `boolish` is a type for documentation.
# It means the value of this type is only for testing a condition.
# Unlike `bool` type, it doesn't require the value is one of `true` or `false`.
# Any Ruby object can have `boolish` type.
#
type boolish = top

# <!-- rdoc-file=string.c -->
# Symbol objects represent named identifiers inside the Ruby interpreter.
#
# You can create a Symbol object explicitly with:
#
# *   A [symbol literal](doc/syntax/literals_rdoc.html#label-Symbol+Literals).
#
#
# The same Symbol object will be created for a given name or string for the
# duration of a program's execution, regardless of the context or meaning of
# that name. Thus if `Fred` is a constant in one context, a method in another,
# and a class in a third, the Symbol `:Fred` will be the same object in all
# three contexts.
#
#     module One
#       class Fred
#       end
#       $f1 = :Fred
#     end
#     module Two
#       Fred = 1
#       $f2 = :Fred
#     end
#     def Fred()
#     end
#     $f3 = :Fred
#     $f1.object_id   #=> 2514190
#     $f2.object_id   #=> 2514190
#     $f3.object_id   #=> 2514190
#
# Constant, method, and variable names are returned as symbols:
#
#     module One
#       Two = 2
#       def three; 3 end
#       @four = 4
#       @@five = 5
#       $six = 6
#     end
#     seven = 7
#
#     One.constants
#     # => [:Two]
#     One.instance_methods(true)
#     # => [:three]
#     One.instance_variables
#     # => [:@four]
#     One.class_variables
#     # => [:@@five]
#     global_variables.grep(/six/)
#     # => [:$six]
#     local_variables
#     # => [:seven]
#
# Symbol objects are different from String objects in that Symbol objects
# represent identifiers, while String objects represent text or data.
#
# ## What's Here
#
# First, what's elsewhere. Class Symbol:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Symbol provides methods that are useful for:
#
# *   [Querying](#class-Symbol-label-Methods+for+Querying)
# *   [Comparing](#class-Symbol-label-Methods+for+Comparing)
# *   [Converting](#class-Symbol-label-Methods+for+Converting)
#
#
# ### Methods for Querying
#
#     ::all_symbols
# :       Returns an array of the symbols currently in Ruby's symbol table.
#
#     [#=~](#method-i-3D~)
# :       Returns the index of the first substring in symbol that matches a
#         given Regexp or other object; returns `nil` if no match is found.
#
#     #[], #slice
# :       Returns a substring of symbol determined by a given index,
#         start/length, or range, or string.
#
#     #empty?
# :       Returns `true` if `self.length` is zero; `false` otherwise.
#
#     #encoding
# :       Returns the Encoding object that represents the encoding of symbol.
#
#     #end_with?
# :       Returns `true` if symbol ends with any of the given strings.
#
#     #match
# :       Returns a MatchData object if symbol matches a given Regexp; `nil`
#         otherwise.
#
#     #match?
# :       Returns `true` if symbol matches a given Regexp; `false` otherwise.
#
#     #length, #size
# :       Returns the number of characters in symbol.
#
#     #start_with?
# :       Returns `true` if symbol starts with any of the given strings.
#
#
#
# ### Methods for Comparing
#
#     [#<=>](#method-i-3C-3D-3E)
# :       Returns -1, 0, or 1 as a given symbol is smaller than, equal to, or
#         larger than symbol.
#
#     [#==, #===](#method-i-3D-3D)
# :       Returns `true` if a given symbol has the same content and encoding.
#
#     #casecmp
# :       Ignoring case, returns -1, 0, or 1 as a given symbol is smaller than,
#         equal to, or larger than symbol.
#
#     #casecmp?
# :       Returns `true` if symbol is equal to a given symbol after Unicode case
#         folding; `false` otherwise.
#
#
#
# ### Methods for Converting
#
#     #capitalize
# :       Returns symbol with the first character upcased and all other
#         characters downcased.
#
#     #downcase
# :       Returns symbol with all characters downcased.
#
#     #inspect
# :       Returns the string representation of `self` as a symbol literal.
#
#     #name
# :       Returns the frozen string corresponding to symbol.
#
#     #succ, #next
# :       Returns the symbol that is the successor to symbol.
#
#     #swapcase
# :       Returns symbol with all upcase characters downcased and all downcase
#         characters upcased.
#
#     #to_proc
# :       Returns a Proc object which responds to the method named by symbol.
#
#     #to_s, #id2name
# :       Returns the string corresponding to `self`.
#
#     #to_sym, #intern
# :       Returns `self`.
#
#     #upcase
# :       Returns symbol with all characters upcased.
#
class Symbol
  include Comparable

  # <!--
  #   rdoc-file=string.c
  #   - Symbol.all_symbols    => array
  # -->
  # Returns an array of all the symbols currently in Ruby's symbol table.
  #
  #     Symbol.all_symbols.size    #=> 903
  #     Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink,
  #                                     :chown, :EOFError, :$;, :String,
  #                                     :LOCK_SH, :"setuid?", :$<,
  #                                     :default_proc, :compact, :extend,
  #                                     :Tms, :getwd, :$=, :ThreadGroup,
  #                                     :wait2, :$>]
  #
  def self.all_symbols: () -> ::Array[Symbol]

  public

  # <!--
  #   rdoc-file=string.c
  #   - symbol <=> other_symbol       -> -1, 0, +1, or nil
  # -->
  # Compares `symbol` with `other_symbol` after calling #to_s on each of the
  # symbols. Returns -1, 0, +1, or `nil` depending on whether `symbol` is less
  # than, equal to, or greater than `other_symbol`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  # See String#<=> for more information.
  #
  def <=>: (Symbol other) -> Integer
         | (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - sym == obj   -> true or false
  # -->
  # Equality---If *sym* and *obj* are exactly the same symbol, returns `true`.
  #
  def ==: (untyped obj) -> bool

  # <!-- rdoc-file=string.c -->
  # Equality---If *sym* and *obj* are exactly the same symbol, returns `true`.
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym =~ obj   -> integer or nil
  # -->
  # Returns `sym.to_s =~ obj`.
  #
  def =~: (untyped obj) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - sym[idx]      -> char
  #   - sym[b, n]     -> string
  #   - sym.slice(idx)      -> char
  #   - sym.slice(b, n)     -> string
  # -->
  # Returns `sym.to_s[]`.
  #
  def []: (int index) -> String?
        | (int start, int length) -> String?
        | (Range[Integer?] range) -> String?
        | (Regexp regexp) -> String?
        | (Regexp regexp, int | String capture) -> String?
        | (String match_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.capitalize.to_sym`.
  #
  # See String#capitalize.
  #
  def capitalize: () -> Symbol
                | (:ascii | :lithuanian | :turkic) -> Symbol
                | (:lithuanian, :turkic) -> Symbol
                | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(other_symbol) -> -1, 0, 1, or nil
  # -->
  # Case-insensitive version of [Symbol#<=>](#method-i-3C-3D-3E):
  #
  #     :aBcDeF.casecmp(:abcde)   # => 1
  #     :aBcDeF.casecmp(:abcdef)  # => 0
  #     :aBcDeF.casecmp(:abcdefg) # => -1
  #     :abcdef.casecmp(:ABCDEF)  # => 0
  #
  # Returns `nil` if the two symbols have incompatible encodings, or if
  # `other_symbol` is not a symbol:
  #
  #     sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
  #     other_sym = :"\u{c4 d6 dc}"
  #     sym.casecmp(other_sym) # => nil
  #     :foo.casecmp(2)        # => nil
  #
  # Currently, case-insensitivity only works on characters A-Z/a-z, not all of
  # Unicode. This is different from Symbol#casecmp?.
  #
  # Related: Symbol#casecmp?.
  #
  def casecmp: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(other_symbol) -> true, false, or nil
  # -->
  # Returns `true` if `sym` and `other_symbol` are equal after Unicode case
  # folding, `false` if they are not equal:
  #
  #     :aBcDeF.casecmp?(:abcde)                  # => false
  #     :aBcDeF.casecmp?(:abcdef)                 # => true
  #     :aBcDeF.casecmp?(:abcdefg)                # => false
  #     :abcdef.casecmp?(:ABCDEF)                 # => true
  #     :"\u{e4 f6 fc}".casecmp?(:"\u{c4 d6 dc}") #=> true
  #
  # Returns `nil` if the two symbols have incompatible encodings, or if
  # `other_symbol` is not a symbol:
  #
  #     sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
  #     other_sym = :"\u{c4 d6 dc}"
  #     sym.casecmp?(other_sym) # => nil
  #     :foo.casecmp?(2)        # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: Symbol#casecmp.
  #
  def casecmp?: (untyped other) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.downcase.to_sym`.
  #
  # See String#downcase.
  #
  # Related: Symbol#upcase.
  #
  def downcase: () -> Symbol
              | (:ascii | :fold | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.empty?   -> true or false
  # -->
  # Returns whether *sym* is :"" or not.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of *sym*.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - sym.end_with?([suffixes]+)   -> true or false
  # -->
  # Returns true if `sym` ends with one of the `suffixes` given.
  #
  #     :hello.end_with?("ello")               #=> true
  #
  #     # returns true if one of the +suffixes+ matches.
  #     :hello.end_with?("heaven", "ello")     #=> true
  #     :hello.end_with?("heaven", "paradise") #=> false
  #
  def end_with?: (*string suffixes) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns the name or string corresponding to *sym*.
  #
  #     :fred.id2name   #=> "fred"
  #     :ginger.to_s    #=> "ginger"
  #
  # Note that this string is not frozen (unlike the symbol itself). To get a
  # frozen string, use #name.
  #
  def id2name: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - sym.inspect    -> string
  # -->
  # Returns the representation of *sym* as a symbol literal.
  #
  #     :fred.inspect   #=> ":fred"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - sym.to_sym   -> sym
  #   - sym.intern   -> sym
  # -->
  # In general, `to_sym` returns the Symbol corresponding to an object. As *sym*
  # is already a symbol, `self` is returned in this case.
  #
  def intern: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.length   -> integer
  #   - sym.size     -> integer
  # -->
  # Same as `sym.to_s.length`.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - sym.match(pattern)        -> matchdata or nil
  #   - sym.match(pattern, pos)   -> matchdata or nil
  # -->
  # Returns `sym.to_s.match`.
  #
  def match: (Regexp | string pattern, ?int pos) -> MatchData?
           | (Regexp | string pattern, ?int pos) { (MatchData) -> void } -> untyped

  # <!--
  #   rdoc-file=string.c
  #   - sym.match?(pattern)        -> true or false
  #   - sym.match?(pattern, pos)   -> true or false
  # -->
  # Returns `sym.to_s.match?`.
  #
  def match?: (Regexp | string pattern, ?int pos) -> bool

  # <!-- rdoc-file=string.c -->
  # Same as `sym.to_s.succ.intern`.
  #
  def next: () -> Symbol

  # <!-- rdoc-file=string.c -->
  # Same as `sym.to_s.length`.
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Returns `sym.to_s[]`.
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - sym.start_with?([prefixes]+)   -> true or false
  # -->
  # Returns true if `sym` starts with one of the `prefixes` given. Each of the
  # `prefixes` should be a String or a Regexp.
  #
  #     :hello.start_with?("hell")               #=> true
  #     :hello.start_with?(/H/i)                 #=> true
  #
  #     # returns true if one of the prefixes matches.
  #     :hello.start_with?("heaven", "hell")     #=> true
  #     :hello.start_with?("heaven", "paradise") #=> false
  #
  def start_with?: (*string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - sym.succ
  # -->
  # Same as `sym.to_s.succ.intern`.
  #
  alias succ next

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.swapcase.to_sym`.
  #
  # See String#swapcase.
  #
  def swapcase: () -> Symbol
              | (:ascii | :lithuanian | :turkic) -> Symbol
              | (:lithuanian, :turkic) -> Symbol
              | (:turkic, :lithuanian) -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - sym.to_proc
  # -->
  # Returns a *Proc* object which responds to the given method by *sym*.
  #
  #     (1..3).collect(&:to_s)  #=> ["1", "2", "3"]
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=string.c
  #   - sym.id2name   -> string
  #   - sym.to_s      -> string
  # -->
  # Returns the name or string corresponding to *sym*.
  #
  #     :fred.id2name   #=> "fred"
  #     :ginger.to_s    #=> "ginger"
  #
  # Note that this string is not frozen (unlike the symbol itself). To get a
  # frozen string, use #name.
  #
  alias to_s id2name

  # <!-- rdoc-file=string.c -->
  # In general, `to_sym` returns the Symbol corresponding to an object. As *sym*
  # is already a symbol, `self` is returned in this case.
  #
  alias to_sym intern

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> symbol
  # -->
  # Equivalent to `sym.to_s.upcase.to_sym`.
  #
  # See String#upcase.
  #
  def upcase: () -> Symbol
            | (:ascii | :lithuanian | :turkic) -> Symbol
            | (:lithuanian, :turkic) -> Symbol
            | (:turkic, :lithuanian) -> Symbol

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=file.c -->
# FileTest implements file test operations similar to those used in File::Stat.
# It exists as a standalone module, and its methods are also insinuated into the
# File class. (Note that this is not done by inclusion: the interpreter cheats).
#
module FileTest
  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a block device.
  #
  # *file_name* can be an IO object.
  #
  def self?.blockdev?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a character device.
  #
  # *file_name* can be an IO object.
  #
  def self?.chardev?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def self?.directory?: (String | IO file_name) -> bool

  # <!-- rdoc-file=file.c -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self?.empty?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self?.executable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self?.executable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self?.exist?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self?.file?: (String | IO file) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self?.grpowned?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self?.identical?: (String | IO file_1, String | IO file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self?.owned?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a pipe.
  #
  # *file_name* can be an IO object.
  #
  def self?.pipe?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self?.readable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self?.readable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setgid?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.setuid?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self?.size: (String | IO file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self?.size?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a socket.
  #
  # *file_name* can be an IO object.
  #
  def self?.socket?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self?.sticky?: (String | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a symbolic link.
  #
  def self?.symlink?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self?.world_readable?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self?.world_writable?: (String | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self?.writable?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self?.writable_real?: (String file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self?.zero?: (String | IO file_name) -> bool
end

# The Exception object set by Kernel#raise.
$!: Exception | nil

# The array contains the module names loaded by require.
$": Array[String]

# The process number of the Ruby running this script. Same as Process.pid.
$$: Integer

# The string matched by the last successful match.
$&: String | nil

# The string to the right of the last successful match.
$': String | nil

# The same as ARGV.
$*: Array[String]

# The highest group matched by the last successful match.
$+: String | nil

# The output field separator for Kernel#print and Array#join. Non-nil $, will be deprecated.
$,: String | nil

# The input record separator, newline by default.
$-0: String | nil

# The default separator for String#split. Non-nil $; will be deprecated.
$-F: Regexp | String | nil

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$-I: Array[String]

$-W: 0 | 1 | 2

# True if option <tt>-a</tt> is set. Read-only variable.
$-a: bool

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output.
$-d: bool

# In in-place-edit mode, this variable holds the extension, otherwise +nil+.
$-i: String?

# True if option <tt>-l</tt> is set. Read-only variable.
$-l: bool

# True if option <tt>-p</tt> is set. Read-only variable.
$-p: bool

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-v: bool | nil

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn.
$-w: bool | nil

# The current input line number of the last file that was read.
$.: Integer

# The input record separator, newline by default. Aliased to $-0.
$/: String | nil

# Contains the name of the script being executed. May be assignable.
$0: String

# The Nth group of the last successful match. May be > 1.
$1: String | nil

# The Nth group of the last successful match. May be > 1.
$2: String | nil

# The Nth group of the last successful match. May be > 1.
$3: String | nil

# The Nth group of the last successful match. May be > 1.
$4: String | nil

# The Nth group of the last successful match. May be > 1.
$5: String | nil

# The Nth group of the last successful match. May be > 1.
$6: String | nil

# The Nth group of the last successful match. May be > 1.
$7: String | nil

# The Nth group of the last successful match. May be > 1.
$8: String | nil

# The Nth group of the last successful match. May be > 1.
$9: String | nil

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$:: Array[String]

# The default separator for String#split. Non-nil $; will be deprecated. Aliased to $-F.
$;: Regexp | String | nil

# The same as ARGF.
$<: IO

# This variable is no longer effective. Deprecated.
$=: bool

# The default output stream for Kernel#print and Kernel#printf. $stdout by default.
$>: IO

# The status of the last executed child process (thread-local).
$?: Process::Status | nil

# The same as <code>$!.backtrace</code>.
$@: Array[String] | nil

# The debug flag, which is set by the <tt>-d</tt> switch.  Enabling debug
# output prints each exception raised to $stderr (but not its
# backtrace).  Setting this to a true value enables debug output as
# if <tt>-d</tt> were given on the command line.  Setting this to a false
# value disables debug output. Aliased to $-d.
$DEBUG: bool

# Current input filename from ARGF. Same as ARGF.filename.
$FILENAME: String

# The array contains the module names loaded by require.
$LOADED_FEATURES: Array[String]

# Load path for searching Ruby scripts and extension libraries used
# by Kernel#load and Kernel#require. Aliased to $: and $-I.
# Has a singleton method <code>$LOAD_PATH.resolve_feature_path(feature)</code>
# that returns [+:rb+ or +:so+, path], which resolves the feature to
# the path the original Kernel#require method would load.
$LOAD_PATH: Array[String] & _LoadPathAPI

interface _LoadPathAPI
  def resolve_feature_path: (String) -> [:rb | :so, String]?
end

# Contains the name of the script being executed. May be assignable.
$PROGRAM_NAME: String

# The verbose flag, which is set by the <tt>-w</tt> or <tt>-v</tt> switch.
# Setting this to a true value enables warnings as if <tt>-w</tt> or <tt>-v</tt> were given
# on the command line.  Setting this to +nil+ disables warnings,
# including from Kernel#warn. Aliased to $-v and $-w.
$VERBOSE: bool | nil

# The output record separator for Kernel#print and IO#write. Default is +nil+.
$\: String | nil

# The last input line of string by gets or readline.
$_: String | nil

# The string to the left of the last successful match.
$`: String | nil

# The current standard error output.
$stderr: IO

# The current standard input.
$stdin: IO

# The current standard output.
$stdout: IO

# The information about the last match in the current scope (thread-local and frame-local).
$~: MatchData | nil

# <!-- rdoc-file=range.c -->
# A Range object represents a collection of values that are between given begin
# and end values.
#
# You can create an Range object explicitly with:
#
# *   A [range literal](doc/syntax/literals_rdoc.html#label-Range+Literals):
#
#         # Ranges that use '..' to include the given end value.
#         (1..4).to_a      # => [1, 2, 3, 4]
#         ('a'..'d').to_a  # => ["a", "b", "c", "d"]
#         # Ranges that use '...' to exclude the given end value.
#         (1...4).to_a     # => [1, 2, 3]
#         ('a'...'d').to_a # => ["a", "b", "c"]
#
#
# A range may be created using method Range.new:
#
#     # Ranges that by default include the given end value.
#     Range.new(1, 4).to_a     # => [1, 2, 3, 4]
#     Range.new('a', 'd').to_a # => ["a", "b", "c", "d"]
#     # Ranges that use third argument +exclude_end+ to exclude the given end value.
#     Range.new(1, 4, true).to_a     # => [1, 2, 3]
#     Range.new('a', 'd', true).to_a # => ["a", "b", "c"]
#
# ## Beginless Ranges
#
# A *beginless* *range* has a definite end value, but a `nil` begin value. Such
# a range includes all values up to the end value.
#
#     r = (..4)               # => nil..4
#     r.begin                 # => nil
#     r.include?(-50)         # => true
#     r.include?(4)           # => true
#
#     r = (...4)              # => nil...4
#     r.include?(4)           # => false
#
#     Range.new(nil, 4)       # => nil..4
#     Range.new(nil, 4, true) # => nil...4
#
# A beginless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     r = (..2) # => nil...2
#     a[r]      # => [1, 2]
#
# Method `each` for a beginless range raises an exception.
#
# ## Endless Ranges
#
# An *endless* *range* has a definite begin value, but a `nil` end value. Such a
# range includes all values from the begin value.
#
#     r = (1..)         # => 1..
#     r.end             # => nil
#     r.include?(50)    # => true
#
#     Range.new(1, nil) # => 1..
#
# The literal for  an endless range may be written with either two dots or
# three. The range has the same elements, either way. But note that the two are
# not equal:
#
#     r0 = (1..)           # => 1..
#     r1 = (1...)          # => 1...
#     r0.begin == r1.begin # => true
#     r0.end == r1.end     # => true
#     r0 == r1             # => false
#
# An endless range may be used to slice an array:
#
#     a = [1, 2, 3, 4]
#     r = (2..) # => 2..
#     a[r]      # => [3, 4]
#
# Method `each` for an endless range calls the given block indefinitely:
#
#     a = []
#     r = (1..)
#     r.each do |i|
#       a.push(i) if i.even?
#       break if i > 10
#     end
#     a # => [2, 4, 6, 8, 10]
#
# ## Ranges and Other Classes
#
# An object may be put into a range if its class implements instance method
# `<=>`. Ruby core classes that do so include Array, Complex, File::Stat, Float,
# Integer, Kernel, Module, Numeric, Rational, String, Symbol, and Time.
#
# Example:
#
#     t0 = Time.now         # => 2021-09-19 09:22:48.4854986 -0500
#     t1 = Time.now         # => 2021-09-19 09:22:56.0365079 -0500
#     t2 = Time.now         # => 2021-09-19 09:23:08.5263283 -0500
#     (t0..t2).include?(t1) # => true
#     (t0..t1).include?(t2) # => false
#
# A range can be iterated over only if its elements implement instance method
# `succ`. Ruby core classes that do so include Integer, String, and Symbol (but
# not the other classes mentioned above).
#
# Iterator methods include:
#
# *   In Range itself: #each, #step, and #%
# *   Included from module Enumerable: #each_entry, #each_with_index,
#     #each_with_object, #each_slice, #each_cons, and #reverse_each.
#
#
# Example:
#
#     a = []
#     (1..4).each {|i| a.push(i) }
#     a # => [1, 2, 3, 4]
#
# ## Ranges and User-Defined Classes
#
# A user-defined class that is to be used in a range must implement instance
# `<=>`; see [Integer#<=>](Integer.html#label-method-i-3C-3D-3E). To make
# iteration available, it must also implement instance method `succ`; see
# Integer#succ.
#
# The class below implements both `<=>` and `succ`, and so can be used both to
# construct ranges and to iterate over them. Note that the Comparable module is
# included so the `==` method is defined in terms of `<=>`.
#
#     # Represent a string of 'X' characters.
#     class Xs
#       include Comparable
#       attr_accessor :length
#       def initialize(n)
#         @length = n
#       end
#       def succ
#         Xs.new(@length + 1)
#       end
#       def <=>(other)
#         @length <=> other.length
#       end
#       def to_s
#         sprintf "%2d #{inspect}", @length
#       end
#       def inspect
#         'X' * @length
#       end
#     end
#
#     r = Xs.new(3)..Xs.new(6) #=> XXX..XXXXXX
#     r.to_a                   #=> [XXX, XXXX, XXXXX, XXXXXX]
#     r.include?(Xs.new(5))    #=> true
#     r.include?(Xs.new(7))    #=> false
#
# ## What's Here
#
# First, what's elsewhere. Class Range:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Range provides methods that are useful for:
#
# *   [Creating a Range](#class-Range-label-Methods+for+Creating+a+Range)
# *   [Querying](#class-Range-label-Methods+for+Querying)
# *   [Comparing](#class-Range-label-Methods+for+Comparing)
# *   [Iterating](#class-Range-label-Methods+for+Iterating)
# *   [Converting](#class-Range-label-Methods+for+Converting)
#
#
# ### Methods for Creating a Range
#
#     ::new
# :       Returns a new range.
#
#
#
# ### Methods for Querying
#
#     #begin
# :       Returns the begin value given for `self`.
#
#     #bsearch
# :       Returns an element from `self` selected by a binary search.
#
#     #count
# :       Returns a count of elements in `self`.
#
#     #end
# :       Returns the end value given for `self`.
#
#     #exclude_end?
# :       Returns whether the end object is excluded.
#
#     #first
# :       Returns the first elements of `self`.
#
#     #hash
# :       Returns the integer hash code.
#
#     #last
# :       Returns the last elements of `self`.
#
#     #max
# :       Returns the maximum values in `self`.
#
#     #min
# :       Returns the minimum values in `self`.
#
#     #minmax
# :       Returns the minimum and maximum values in `self`.
#
#     #size
# :       Returns the count of elements in `self`.
#
#
#
# ### Methods for Comparing
#
#     [#==](#method-i-3D-3D)
# :       Returns whether a given object is equal to `self` (uses #==).
#
#     #===
# :       Returns whether the given object is between the begin and end values.
#
#     #cover?
# :       Returns whether a given object is within `self`.
#
#     #eql?
# :       Returns whether a given object is equal to `self` (uses #eql?).
#
#     #include? (aliased as #member?)
# :       Returns whether a given object is an element of `self`.
#
#
#
# ### Methods for Iterating
#
#     #%
# :       Requires argument `n`; calls the block with each `n`-th element of
#         `self`.
#
#     #each
# :       Calls the block with each element of `self`.
#
#     #step
# :       Takes optional argument `n` (defaults to 1); calls the block with each
#         `n`-th element of `self`.
#
#
#
# ### Methods for Converting
#
#     #inspect
# :       Returns a string representation of `self` (uses #inspect).
#
#     #to_a (aliased as #entries)
# :       Returns elements of `self` in an array.
#
#     #to_s
# :       Returns a string representation of `self` (uses #to_s).
#
class Range[out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin == self.begin`.
  # *   `other.end == self.end`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r == (1..5)                # => true
  #     r = Range.new(1, 5)
  #     r == 'foo'                 # => false
  #     r == (2..5)                # => false
  #     r == (1..4)                # => false
  #     r == (1...5)               # => false
  #     r == Range.new(1, 5, true) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#eql?.
  #
  def ==: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self === object ->  true or false
  # -->
  # Returns `true` if `object` is between `self.begin` and `self.end`. `false`
  # otherwise:
  #
  #     (1..4) === 2       # => true
  #     (1..4) === 5       # => false
  #     (1..4) === 'a'     # => false
  #     (1..4) === 4       # => true
  #     (1...4) === 4      # => false
  #     ('a'..'d') === 'c' # => true
  #     ('a'..'d') === 'e' # => false
  #
  # A case statement uses method `===`, and so:
  #
  #     case 79
  #     when (1..50)
  #       "low"
  #     when (51..75)
  #       "medium"
  #     when (76..100)
  #       "high"
  #     end # => "high"
  #
  #     case "2.6.5"
  #     when ..."2.4"
  #       "EOL"
  #     when "2.4"..."2.5"
  #       "maintenance"
  #     when "2.5"..."3.0"
  #       "stable"
  #     when "3.1"..
  #       "upcoming"
  #     end # => "stable"
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - self.begin -> object
  # -->
  # Returns the object that defines the beginning of `self`.
  #
  #     (1..4).begin # => 1
  #     (..2).begin  # => nil
  #
  # Related: Range#first, Range#end.
  #
  def begin: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - bsearch {|obj| block }  -> value
  # -->
  # Returns an element from `self` selected by a binary search.
  #
  # See [Binary Searching](rdoc-ref:bsearch.rdoc).
  #
  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  # <!--
  #   rdoc-file=range.c
  #   - cover?(object) -> true or false
  #   - cover?(range) -> true or false
  # -->
  # Returns `true` if the given argument is within `self`, `false` otherwise.
  #
  # With non-range argument `object`, evaluates with `<=` and `<`.
  #
  # For range `self` with included end value (`#exclude_end? == false`), evaluates
  # thus:
  #
  #     self.begin <= object <= self.end
  #
  # Examples:
  #
  #     r = (1..4)
  #     r.cover?(1)     # => true
  #     r.cover?(4)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(5)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'..'d')
  #     r.cover?('a')     # => true
  #     r.cover?('d')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('e')     # => false
  #     r.cover?(0)       # => false
  #
  # For range `r` with excluded end value (`#exclude_end? == true`), evaluates
  # thus:
  #
  #     r.begin <= object < r.end
  #
  # Examples:
  #
  #     r = (1...4)
  #     r.cover?(1)     # => true
  #     r.cover?(3)     # => true
  #     r.cover?(0)     # => false
  #     r.cover?(4)     # => false
  #     r.cover?('foo') # => false
  #
  #     r = ('a'...'d')
  #     r.cover?('a')     # => true
  #     r.cover?('c')     # => true
  #     r.cover?(' ')     # => false
  #     r.cover?('d')     # => false
  #     r.cover?(0)       # => false
  #
  # With range argument `range`, compares the first and last elements of `self`
  # and `range`:
  #
  #     r = (1..4)
  #     r.cover?(1..4)     # => true
  #     r.cover?(0..4)     # => false
  #     r.cover?(1..5)     # => false
  #     r.cover?('a'..'d') # => false
  #
  #     r = (1...4)
  #     r.cover?(1..3)     # => true
  #     r.cover?(1..4)     # => false
  #
  # If begin and end are numeric, #cover? behaves like #include?
  #
  #     (1..3).cover?(1.5) # => true
  #     (1..3).include?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').cover?('cc')   # => true
  #     ('a'..'d').include?('cc') # => false
  #
  # Returns `false` if either:
  #
  # *   The begin value of `self` is larger than its end value.
  # *   An internal call to `<=>` returns `nil`; that is, the operands are not
  #     comparable.
  #
  #
  # Related: Range#include?.
  #
  def cover?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - each {|element| ... } -> self
  #   - each                  -> an_enumerator
  # -->
  # With a block given, passes each element of `self` to the block:
  #
  #     a = []
  #     (1..4).each {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  # Raises an exception unless `self.first.respond_to?(:succ)`.
  #
  # With no block given, returns an enumerator.
  #
  def each: () { (Elem arg0) -> untyped } -> self
          | () -> ::Enumerator[Elem, self]

  # <!--
  #   rdoc-file=range.c
  #   - self.end -> object
  # -->
  # Returns the object that defines the end of `self`.
  #
  #     (1..4).end  # => 4
  #     (1...4).end # => 4
  #     (1..).end   # => nil
  #
  # Related: Range#begin, Range#last.
  #
  def end: () -> Elem

  # <!--
  #   rdoc-file=range.c
  #   - exclude_end? -> true or false
  # -->
  # Returns `true` if `self` excludes its end value; `false` otherwise:
  #
  #     Range.new(2, 5).exclude_end?       # => false
  #     Range.new(2, 5, true).exclude_end? # => true
  #     (2..5).exclude_end?                # => false
  #     (2...5).exclude_end?               # => true
  #
  def exclude_end?: () -> bool

  # <!--
  #   rdoc-file=range.c
  #   - first -> object
  #   - first(n) -> array
  # -->
  # With no argument, returns the first element of `self`, if it exists:
  #
  #     (1..4).first     # => 1
  #     ('a'..'d').first # => "a"
  #
  # With non-negative integer argument `n` given, returns the first `n` elements
  # in an array:
  #
  #     (1..10).first(3) # => [1, 2, 3]
  #     (1..10).first(0) # => []
  #     (1..4).first(50) # => [1, 2, 3, 4]
  #
  # Raises an exception if there is no first element:
  #
  #     (..4).first # Raises RangeError
  #
  def first: () -> Elem
           | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. Two range objects `r0` and `r1`
  # have the same hash value if and only if `r0.eql?(r1)`.
  #
  # Related: Range#eql?, Object#hash.
  #
  def hash: () -> Integer

  # <!-- rdoc-file=range.c -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  # Range#member? is an alias for Range#include?.
  #
  def include?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - Range.new(begin, end, exclude_end = false) -> new_range
  # -->
  # Returns a new range based on the given objects `begin` and `end`. Optional
  # argument `exclude_end` determines whether object `end` is included as the last
  # object in the range:
  #
  #     Range.new(2, 5).to_a            # => [2, 3, 4, 5]
  #     Range.new(2, 5, true).to_a      # => [2, 3, 4]
  #     Range.new('a', 'd').to_a        # => ["a", "b", "c", "d"]
  #     Range.new('a', 'd', true).to_a  # => ["a", "b", "c"]
  #
  def initialize: (Elem from, Elem to, ?boolish exclude_end) -> void

  # <!--
  #   rdoc-file=range.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`, including `begin.inspect` and
  # `end.inspect`:
  #
  #     (1..4).inspect  # => "1..4"
  #     (1...4).inspect # => "1...4"
  #     (1..).inspect   # => "1.."
  #     (..4).inspect   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#to_s.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - last -> object
  #   - last(n) -> array
  # -->
  # With no argument, returns the last element of `self`, if it exists:
  #
  #     (1..4).last     # => 4
  #     ('a'..'d').last # => "d"
  #
  # Note that `last` with no argument returns the end element of `self` even if
  # #exclude_end? is `true`:
  #
  #     (1...4).last     # => 4
  #     ('a'...'d').last # => "d"
  #
  # With non-negative integer argument `n` given, returns the last `n` elements in
  # an array:
  #
  #     (1..10).last(3) # => [8, 9, 10]
  #     (1..10).last(0) # => []
  #     (1..4).last(50) # => [1, 2, 3, 4]
  #
  # Note that `last` with argument does not return the end element of `self` if
  # #exclude_end? it `true`:
  #
  #     (1...4).last(3)     # => [1, 2, 3]
  #     ('a'...'d').last(3) # => ["a", "b", "c"]
  #
  # Raises an exception if there is no last element:
  #
  #     (1..).last # Raises RangeError
  #
  def last: () -> Elem
          | (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - max -> object
  #   - max(n) -> array
  #   - max {|a, b| ... } -> object
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the maximum value in `self`, using method `<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the maximum-valued element of
  # `self`.
  #
  #     (1..4).max     # => 4
  #     ('a'..'d').max # => "d"
  #     (-4..-1).max   # => -1
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` maximum-valued elements of `self` in an array:
  #
  #     (1..4).max(2)     # => [4, 3]
  #     ('a'..'d').max(2) # => ["d", "c"]
  #     (-4..-1).max(2)   # => [-1, -2]
  #     (1..4).max(50)    # => [4, 3, 2, 1]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far maximum value and the next element of
  #     `self`.
  #
  #
  # To illustrate:
  #
  #     (1..4).max {|a, b| p [a, b]; a <=> b } # => 4
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 2]
  #     [4, 3]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).max {|a, b| -(a <=> b) } # => 1
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).max(2) {|a, b| -(a <=> b) }  # => [1, 2]
  #     (1..4).max(50) {|a, b| -(a <=> b) } # => [1, 2, 3, 4]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).max(0)                      # => []
  #     (1..4).max(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).max                         # => nil
  #         (4..1).max(2)                      # => []
  #         (4..1).max {|a, b| -(a <=> b) }    # => nil
  #         (4..1).max(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).max                          # => nil
  #         (1...1).max(2)                       # => []
  #         (1...1).max  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).max(2)  {|a, b| -(a <=> b) } # => []
  #
  #
  # Raises an exception if either:
  #
  # *   `self` is a endless range: `(1..)`.
  # *   A block is given and `self` is a beginless range.
  #
  #
  # Related: Range#min, Range#minmax.
  #
  def max: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - min -> object
  #   - min(n) -> array
  #   - min {|a, b| ... } -> object
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the minimum value in `self`, using method `<=>` or a given block for
  # comparison.
  #
  # With no argument and no block given, returns the minimum-valued element of
  # `self`.
  #
  #     (1..4).min     # => 1
  #     ('a'..'d').min # => "a"
  #     (-4..-1).min   # => -4
  #
  # With non-negative integer argument `n` given, and no block given, returns the
  # `n` minimum-valued elements of `self` in an array:
  #
  #     (1..4).min(2)     # => [1, 2]
  #     ('a'..'d').min(2) # => ["a", "b"]
  #     (-4..-1).min(2)   # => [-4, -3]
  #     (1..4).min(50)    # => [1, 2, 3, 4]
  #
  # If a block is given, it is called:
  #
  # *   First, with the first two element of `self`.
  # *   Then, sequentially, with the so-far minimum value and the next element of
  #     `self`.
  #
  #
  # To illustrate:
  #
  #     (1..4).min {|a, b| p [a, b]; a <=> b } # => 1
  #
  # Output:
  #
  #     [2, 1]
  #     [3, 1]
  #     [4, 1]
  #
  # With no argument and a block given, returns the return value of the last call
  # to the block:
  #
  #     (1..4).min {|a, b| -(a <=> b) } # => 4
  #
  # With non-negative integer argument `n` given, and a block given, returns the
  # return values of the last `n` calls to the block in an array:
  #
  #     (1..4).min(2) {|a, b| -(a <=> b) }  # => [4, 3]
  #     (1..4).min(50) {|a, b| -(a <=> b) } # => [4, 3, 2, 1]
  #
  # Returns an empty array if `n` is zero:
  #
  #     (1..4).min(0)                      # => []
  #     (1..4).min(0) {|a, b| -(a <=> b) } # => []
  #
  # Returns `nil` or an empty array if:
  #
  # *   The begin value of the range is larger than the end value:
  #
  #         (4..1).min                         # => nil
  #         (4..1).min(2)                      # => []
  #         (4..1).min {|a, b| -(a <=> b) }    # => nil
  #         (4..1).min(2) {|a, b| -(a <=> b) } # => []
  #
  # *   The begin value of an exclusive range is equal to the end value:
  #
  #         (1...1).min                          # => nil
  #         (1...1).min(2)                       # => []
  #         (1...1).min  {|a, b| -(a <=> b) }    # => nil
  #         (1...1).min(2)  {|a, b| -(a <=> b) } # => []
  #
  #
  # Raises an exception if either:
  #
  # *   `self` is a beginless range: `(..4)`.
  # *   A block is given and `self` is an endless range.
  #
  #
  # Related: Range#max, Range#minmax.
  #
  def min: () -> Elem
         | () { (Elem a, Elem b) -> Integer } -> Elem
         | (Integer n) -> ::Array[Elem]
         | (Integer n) { (Elem a, Elem b) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=range.c
  #   - size -> non_negative_integer or Infinity or nil
  # -->
  # Returns the count of elements in `self` if both begin and end values are
  # numeric; otherwise, returns `nil`:
  #
  #     (1..4).size      # => 4
  #     (1...4).size     # => 3
  #     (1..).size       # => Infinity
  #     ('a'..'z').size  #=> nil
  #
  # Related: Range#count.
  #
  def size: () -> Integer?
          | () -> Float?

  # <!--
  #   rdoc-file=range.c
  #   - step(n = 1) {|element| ... } -> self
  #   - step(n = 1)                  -> enumerator
  # -->
  # Iterates over the elements of `self`.
  #
  # With a block given and no argument, calls the block each element of the range;
  # returns `self`:
  #
  #     a = []
  #     (1..5).step {|element| a.push(element) } # => 1..5
  #     a # => [1, 2, 3, 4, 5]
  #     a = []
  #     ('a'..'e').step {|element| a.push(element) } # => "a".."e"
  #     a # => ["a", "b", "c", "d", "e"]
  #
  # With a block given and a positive integer argument `n` given, calls the block
  # with element `0`, element `n`, element `2n`, and so on:
  #
  #     a = []
  #     (1..5).step(2) {|element| a.push(element) } # => 1..5
  #     a # => [1, 3, 5]
  #     a = []
  #     ('a'..'e').step(2) {|element| a.push(element) } # => "a".."e"
  #     a # => ["a", "c", "e"]
  #
  # With no block given, returns an enumerator, which will be of class
  # Enumerator::ArithmeticSequence if `self` is numeric; otherwise of class
  # Enumerator:
  #
  #     e = (1..5).step(2) # => ((1..5).step(2))
  #     e.class            # => Enumerator::ArithmeticSequence
  #     ('a'..'e').step # => #<Enumerator: ...>
  #
  # Related: Range#%.
  #
  def step: (?Integer n) { (Elem arg0) -> untyped } -> self
          | (?Integer n) -> ::Enumerator[Elem, void]

  # <!--
  #   rdoc-file=range.c
  #   - to_s -> string
  # -->
  # Returns a string representation of `self`, including `begin.to_s` and
  # `end.to_s`:
  #
  #     (1..4).to_s  # => "1..4"
  #     (1...4).to_s # => "1...4"
  #     (1..).to_s   # => "1.."
  #     (..4).to_s   # => "..4"
  #
  # Note that returns from #to_s and #inspect may differ:
  #
  #     ('a'..'d').to_s    # => "a..d"
  #     ('a'..'d').inspect # => "\"a\"..\"d\""
  #
  # Related: Range#inspect.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=range.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if and only if:
  #
  # *   `other` is a range.
  # *   `other.begin eql? self.begin`.
  # *   `other.end eql? self.end`.
  # *   `other.exclude_end? == self.exclude_end?`.
  #
  #
  # Otherwise returns `false`.
  #
  #     r = (1..5)
  #     r.eql?(1..5)                  # => true
  #     r = Range.new(1, 5)
  #     r.eql?('foo')                 # => false
  #     r.eql?(2..5)                  # => false
  #     r.eql?(1..4)                  # => false
  #     r.eql?(1...5)                 # => false
  #     r.eql?(Range.new(1, 5, true)) # => false
  #
  # Note that even with the same argument, the return values of #== and #eql? can
  # differ:
  #
  #     (1..2) == (1..2.0)   # => true
  #     (1..2).eql? (1..2.0) # => false
  #
  # Related: Range#==.
  #
  def eql?: (untyped obj) -> bool

  # <!--
  #   rdoc-file=range.c
  #   - include?(object) -> true or false
  # -->
  # Returns `true` if `object` is an element of `self`, `false` otherwise:
  #
  #     (1..4).include?(2)        # => true
  #     (1..4).include?(5)        # => false
  #     (1..4).include?(4)        # => true
  #     (1...4).include?(4)       # => false
  #     ('a'..'d').include?('b')  # => true
  #     ('a'..'d').include?('e')  # => false
  #     ('a'..'d').include?('B')  # => false
  #     ('a'..'d').include?('d')  # => true
  #     ('a'...'d').include?('d') # => false
  #
  # If begin and end are numeric, #include? behaves like #cover?
  #
  #     (1..3).include?(1.5) # => true
  #     (1..3).cover?(1.5) # => true
  #
  # But when not numeric, the two methods may differ:
  #
  #     ('a'..'d').include?('cc') # => false
  #     ('a'..'d').cover?('cc')   # => true
  #
  # Related: Range#cover?.
  #
  # Range#member? is an alias for Range#include?.
  #
  def member?: (untyped obj) -> bool
end

# <!-- rdoc-file=proc.c -->
# Objects of class Binding encapsulate the execution context at some particular
# place in the code and retain this context for future use. The variables,
# methods, value of `self`, and possibly an iterator block that can be accessed
# in this context are all retained. Binding objects can be created using
# Kernel#binding, and are made available to the callback of
# Kernel#set_trace_func and instances of TracePoint.
#
# These binding objects can be passed as the second argument of the Kernel#eval
# method, establishing an environment for the evaluation.
#
#     class Demo
#       def initialize(n)
#         @secret = n
#       end
#       def get_binding
#         binding
#       end
#     end
#
#     k1 = Demo.new(99)
#     b1 = k1.get_binding
#     k2 = Demo.new(-3)
#     b2 = k2.get_binding
#
#     eval("@secret", b1)   #=> 99
#     eval("@secret", b2)   #=> -3
#     eval("@secret")       #=> nil
#
# Binding objects have no class-specific methods.
#
class Binding
  public

  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - binding.eval(string [, filename [,lineno]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*, in the *binding*'s context.  If
  # the optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     b.eval("param")   #=> "hello"
  #
  def eval: (String arg0, ?String filename, ?Integer lineno) -> untyped

  # <!--
  #   rdoc-file=lib/irb.rb
  #   - irb()
  # -->
  # Opens an IRB session where `binding.irb` is called which allows for
  # interactive debugging. You can call any methods or variables available in the
  # current scope, and mutate state if you need to.
  #
  # Given a Ruby file called `potato.rb` containing the following code:
  #
  #     class Potato
  #       def initialize
  #         @cooked = false
  #         binding.irb
  #         puts "Cooked potato: #{@cooked}"
  #       end
  #     end
  #
  #     Potato.new
  #
  # Running `ruby potato.rb` will open an IRB session where `binding.irb` is
  # called, and you will see the following:
  #
  #     $ ruby potato.rb
  #
  #     From: potato.rb @ line 4 :
  #
  #         1: class Potato
  #         2:   def initialize
  #         3:     @cooked = false
  #      => 4:     binding.irb
  #         5:     puts "Cooked potato: #{@cooked}"
  #         6:   end
  #         7: end
  #         8:
  #         9: Potato.new
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0>
  #
  # You can type any valid Ruby code and it will be evaluated in the current
  # context. This allows you to debug without having to run your code repeatedly:
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0> @cooked
  #     => false
  #     irb(#<Potato:0x00007feea1916670>):002:0> self.class
  #     => Potato
  #     irb(#<Potato:0x00007feea1916670>):003:0> caller.first
  #     => ".../2.5.1/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'"
  #     irb(#<Potato:0x00007feea1916670>):004:0> @cooked = true
  #     => true
  #
  # You can exit the IRB session with the `exit` command. Note that exiting will
  # resume execution where `binding.irb` had paused it, as you can see from the
  # output printed to standard output in this example:
  #
  #     irb(#<Potato:0x00007feea1916670>):005:0> exit
  #     Cooked potato: true
  #
  # See IRB@IRB+Usage for more information.
  #
  def irb: () -> void

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_defined?(symbol) -> obj
  # -->
  # Returns `true` if a local variable `symbol` exists.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_defined?(:a) #=> true
  #       binding.local_variable_defined?(:b) #=> false
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("defined?(#{symbol}) == 'local-variable'")
  #
  def local_variable_defined?: (String | Symbol symbol) -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_get(symbol) -> obj
  # -->
  # Returns the value of the local variable `symbol`.
  #
  #     def foo
  #       a = 1
  #       binding.local_variable_get(:a) #=> 1
  #       binding.local_variable_get(:b) #=> NameError
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("#{symbol}")
  #
  def local_variable_get: (String | Symbol symbol) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variable_set(symbol, obj) -> obj
  # -->
  # Set local variable named `symbol` as `obj`.
  #
  #     def foo
  #       a = 1
  #       bind = binding
  #       bind.local_variable_set(:a, 2) # set existing local variable `a'
  #       bind.local_variable_set(:b, 3) # create new local variable `b'
  #                                      # `b' exists only in binding
  #
  #       p bind.local_variable_get(:a)  #=> 2
  #       p bind.local_variable_get(:b)  #=> 3
  #       p a                            #=> 2
  #       p b                            #=> NameError
  #     end
  #
  # This method behaves similarly to the following code:
  #
  #     binding.eval("#{symbol} = #{obj}")
  #
  # if `obj` can be dumped in Ruby code.
  #
  def local_variable_set: [U] (String | Symbol symbol, U obj) -> U

  # <!--
  #   rdoc-file=proc.c
  #   - binding.local_variables -> Array
  # -->
  # Returns the names of the binding's local variables as symbols.
  #
  #     def foo
  #       a = 1
  #       2.times do |n|
  #         binding.local_variables #=> [:a, :n]
  #       end
  #     end
  #
  # This method is the short version of the following code:
  #
  #     binding.eval("local_variables")
  #
  def local_variables: () -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - binding.receiver    -> object
  # -->
  # Returns the bound receiver of the binding object.
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - binding.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number of the binding object.
  #
  def source_location: () -> [ String, Integer ]
end

# <!-- rdoc-file=enum.c -->
# ## What's Here
#
# Module Enumerable provides methods that are useful to a collection class for:
# *   [Querying](#module-Enumerable-label-Methods+for+Querying)
# *   [Fetching](#module-Enumerable-label-Methods+for+Fetching)
# *   [Searching](#module-Enumerable-label-Methods+for+Searching)
# *   [Sorting](#module-Enumerable-label-Methods+for+Sorting)
# *   [Iterating](#module-Enumerable-label-Methods+for+Iterating)
# *   [And more....](#module-Enumerable-label-Other+Methods)
#
#
# ### Methods for Querying
#
# These methods return information about the Enumerable other than the elements
# themselves:
#
# #include?, #member?
# :   Returns `true` if self == object, `false` otherwise.
# #all?
# :   Returns `true` if all elements meet a specified criterion; `false`
#     otherwise.
# #any?
# :   Returns `true` if any element meets a specified criterion; `false`
#     otherwise.
# #none?
# :   Returns `true` if no element meets a specified criterion; `false`
#     otherwise.
# #one?
# :   Returns `true` if exactly one element meets a specified criterion; `false`
#     otherwise.
# #count
# :   Returns the count of elements, based on an argument or block criterion, if
#     given.
# #tally
# :   Returns a new Hash containing the counts of occurrences of each element.
#
#
# ### Methods for Fetching
#
# These methods return entries from the Enumerable, without modifying it:
#
# *Leading, trailing, or all elements*:
# #entries, #to_a
# :   Returns all elements.
# #first
# :   Returns the first element or leading elements.
# #take
# :   Returns a specified number of leading elements.
# #drop
# :   Returns a specified number of trailing elements.
# #take_while
# :   Returns leading elements as specified by the given block.
# #drop_while
# :   Returns trailing elements as specified by the given block.
#
#
# *Minimum and maximum value elements*:
# #min
# :   Returns the elements whose values are smallest among the elements, as
#     determined by `<=>` or a given block.
# #max
# :   Returns the elements whose values are largest among the elements, as
#     determined by `<=>` or a given block.
# #minmax
# :   Returns a 2-element Array containing the smallest and largest elements.
# #min_by
# :   Returns the smallest element, as determined by the given block.
# #max_by
# :   Returns the largest element, as determined by the given block.
# #minmax_by
# :   Returns the smallest and largest elements, as determined by the given
#     block.
#
#
# *Groups, slices, and partitions*:
# #group_by
# :   Returns a Hash that partitions the elements into groups.
# #partition
# :   Returns elements partitioned into two new Arrays, as determined by the
#     given block.
# #slice_after
# :   Returns a new Enumerator whose entries are a partition of `self`, based
#     either on a given `object` or a given block.
# #slice_before
# :   Returns a new Enumerator whose entries are a partition of `self`, based
#     either on a given `object` or a given block.
# #slice_when
# :   Returns a new Enumerator whose entries are a partition of `self` based on
#     the given block.
# #chunk
# :   Returns elements organized into chunks as specified by the given block.
# #chunk_while
# :   Returns elements organized into chunks as specified by the given block.
#
#
# ### Methods for Searching and Filtering
#
# These methods return elements that meet a specified criterion.
#
# #find, #detect
# :   Returns an element selected by the block.
# #find_all, #filter, #select
# :   Returns elements selected by the block.
# #find_index
# :   Returns the index of an element selected by a given object or block.
# #reject
# :   Returns elements not rejected by the block.
# #uniq
# :   Returns elements that are not duplicates.
#
#
# ### Methods for Sorting
#
# These methods return elements in sorted order.
#
# #sort
# :   Returns the elements, sorted by `<=>` or the given block.
# #sort_by
# :   Returns the elements, sorted by the given block.
#
#
# ### Methods for Iterating
#
# #each_entry
# :   Calls the block with each successive element (slightly different from
#     #each).
# #each_with_index
# :   Calls the block with each successive element and its index.
# #each_with_object
# :   Calls the block with each successive element and a given object.
# #each_slice
# :   Calls the block with successive non-overlapping slices.
# #each_cons
# :   Calls the block with successive overlapping slices. (different from
#     #each_slice).
# #reverse_each
# :   Calls the block with each successive element, in reverse order.
#
#
# ### Other Methods
#
# #map, #collect
# :   Returns objects returned by the block.
# #filter_map
# :   Returns truthy objects returned by the block.
# #flat_map, #collect_concat
# :   Returns flattened objects returned by the block.
# #grep
# :   Returns elements selected by a given object or objects returned by a given
#     block.
# #grep_v
# :   Returns elements selected by a given object or objects returned by a given
#     block.
# #reduce, #inject
# :   Returns the object formed by combining all elements.
# #sum
# :   Returns the sum of the elements, using method +++.
# #zip
# :   Combines each element with elements from other enumerables; returns the
#     n-tuples or calls the block with each.
# #cycle
# :   Calls the block with each element, cycling repeatedly.
#
#
# ## Usage
#
# To use module Enumerable in a collection class:
#
# *   Include it:
#
#         include Enumerable
#
# *   Implement method `#each` which must yield successive elements of the
#     collection. The method will be called by almost any Enumerable method.
#
#
# Example:
#
#     class Foo
#       include Enumerable
#       def each
#         yield 1
#         yield 1, 2
#         yield
#       end
#     end
#     Foo.new.each_entry{ |element| p element }
#
# Output:
#
#     1
#     [1, 2]
#     nil
#
# ## Enumerable in Ruby Core Classes
# Some Ruby classes include Enumerable:
# *   Array
# *   Dir
# *   Hash
# *   IO
# *   Range
# *   Set
# *   Struct
#
# Virtually all methods in Enumerable call method `#each` in the including
# class:
# *   `Hash#each` yields the next key-value pair as a 2-element Array.
# *   `Struct#each` yields the next name-value pair as a 2-element Array.
# *   For the other classes above, `#each` yields the next object from the
#     collection.
#
#
# ## About the Examples
# The example code snippets for the Enumerable methods:
# *   Always show the use of one or more Array-like classes (often Array
#     itself).
# *   Sometimes show the use of a Hash-like class. For some methods, though, the
#     usage would not make sense, and so it is not shown.  Example: #tally would
#     find exactly one of each Hash entry.
#
module Enumerable[unchecked out Elem] : _Each[Elem]
  # <!--
  #   rdoc-file=enum.c
  #   - all?                  -> true or false
  #   - all?(pattern)         -> true or false
  #   - all? {|element| ... } -> true or false
  # -->
  # Returns whether every element meets a given criterion.
  #
  # With no argument and no block, returns whether every element is truthy:
  #
  #     (1..4).all?           # => true
  #     %w[a b c d].all?      # => true
  #     [1, 2, nil].all?      # => false
  #     ['a','b', false].all? # => false
  #     [].all?               # => true
  #
  # With argument `pattern` and no block, returns whether for each element
  # `element`, `pattern === element`:
  #
  #     (1..4).all?(Integer)                 # => true
  #     (1..4).all?(Numeric)                 # => true
  #     (1..4).all?(Float)                   # => false
  #     %w[bar baz bat bam].all?(/ba/)       # => true
  #     %w[bar baz bat bam].all?(/bar/)      # => false
  #     %w[bar baz bat bam].all?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.all?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.all?(Hash)  # => false
  #     [].all?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for every
  # element:
  #
  #     (1..4).all? {|element| element < 5 }                    # => true
  #     (1..4).all? {|element| element < 4 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 3 } # => true
  #     {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 2 } # => false
  #
  # Related: #any?, #none? #one?.
  #
  def all?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - any?                  -> true or false
  #   - any?(pattern)         -> true or false
  #   - any? {|element| ... } -> true or false
  # -->
  # Returns whether any element meets a given criterion.
  #
  # With no argument and no block, returns whether any element is truthy:
  #
  #     (1..4).any?          # => true
  #     %w[a b c d].any?     # => true
  #     [1, false, nil].any? # => true
  #     [].any?              # => false
  #
  # With argument `pattern` and no block, returns whether for any element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].any?(Integer)        # => true
  #     [nil, false, 0].any?(Numeric)        # => true
  #     [nil, false, 0].any?(Float)          # => false
  #     %w[bar baz bat bam].any?(/m/)        # => true
  #     %w[bar baz bat bam].any?(/foo/)      # => false
  #     %w[bar baz bat bam].any?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.any?(Array) # => true
  #     {foo: 0, bar: 1, baz: 2}.any?(Hash)  # => false
  #     [].any?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for any
  # element:
  #
  #     (1..4).any? {|element| element < 2 }                    # => true
  #     (1..4).any? {|element| element < 1 }                    # => false
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 1 } # => true
  #     {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 0 } # => false
  #
  # Related: #all?, #none?, #one?.
  #
  def any?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - map {|element| ... } -> array
  #   - map -> enumerator
  # -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def collect: [U] () { (Elem arg0) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def collect_concat: [U] () { (Elem) -> (::Array[U] | U) } -> ::Array[U]
                    | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - compact -> array
  # -->
  # Returns an array of all non-`nil` elements:
  #
  #     a = [nil, 0, nil, 'a', false, nil, false, nil, 'a', nil, 0, nil]
  #     a.compact # => [0, "a", false, false, "a", 0]
  #
  def compact: () -> Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - count -> integer
  #   - count(object) -> integer
  #   - count {|element| ... } -> integer
  # -->
  # Returns the count of elements, based on an argument or block criterion, if
  # given.
  #
  # With no argument and no block given, returns the number of elements:
  #
  #     [0, 1, 2].count                # => 3
  #     {foo: 0, bar: 1, baz: 2}.count # => 3
  #
  # With argument `object` given, returns the number of elements that are `==` to
  # `object`:
  #
  #     [0, 1, 2, 1].count(1)           # => 2
  #
  # With a block given, calls the block with each element and returns the number
  # of elements for which the block returns a truthy value:
  #
  #     [0, 1, 2, 3].count {|element| element < 2}              # => 2
  #     {foo: 0, bar: 1, baz: 2}.count {|key, value| value < 2} # => 2
  #
  def count: () -> Integer
           | (Elem) -> Integer
           | () { (Elem) -> boolish } -> Integer

  # <!--
  #   rdoc-file=enum.c
  #   - cycle(n = nil) {|element| ...} ->  nil
  #   - cycle(n = nil)                 ->  enumerator
  # -->
  # When called with positive integer argument `n` and a block, calls the block
  # with each element, then does so again, until it has done so `n` times; returns
  # `nil`:
  #
  #     a = []
  #     (1..4).cycle(3) {|element| a.push(element) } # => nil
  #     a # => [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
  #     a = []
  #     ('a'..'d').cycle(2) {|element| a.push(element) }
  #     a # => ["a", "b", "c", "d", "a", "b", "c", "d"]
  #     a = []
  #     {foo: 0, bar: 1, baz: 2}.cycle(2) {|element| a.push(element) }
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2], [:foo, 0], [:bar, 1], [:baz, 2]]
  #
  # If count is zero or negative, does not call the block.
  #
  # When called with a block and `n` is `nil`, cycles forever.
  #
  # When no block is given, returns an Enumerator.
  #
  def cycle: (?Integer n) { (Elem arg0) -> untyped } -> NilClass
           | (?Integer n) -> ::Enumerator[Elem, NilClass]

  # <!-- rdoc-file=enum.c -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def detect: (?Proc ifnone) { (Elem) -> boolish } -> Elem?
            | (?Proc ifnone) -> ::Enumerator[Elem, Elem?]

  # <!--
  #   rdoc-file=enum.c
  #   - drop(n) -> array
  # -->
  # For positive integer `n`, returns an array containing all but the first `n`
  # elements:
  #
  #     r = (1..4)
  #     r.drop(3)  # => [4]
  #     r.drop(2)  # => [3, 4]
  #     r.drop(1)  # => [2, 3, 4]
  #     r.drop(0)  # => [1, 2, 3, 4]
  #     r.drop(50) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.drop(2) # => [[:baz, 2], [:bat, 3]]
  #
  def drop: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - drop_while {|element| ... } -> array
  #   - drop_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements after that point:
  #
  #     (1..4).drop_while{|i| i < 3 } # => [3, 4]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     a = h.drop_while{|element| key, value = *element; value < 2 }
  #     a # => [[:baz, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  def drop_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - each_cons(n) { ... } ->  self
  #   - each_cons(n)         ->  enumerator
  # -->
  # Calls the block with each successive overlapped `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..5).each_cons(3) {|element| a.push(element) }
  #     a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
  #
  #     a = []
  #     h = {foo: 0,  bar: 1, baz: 2, bam: 3}
  #     h.each_cons(2) {|element| a.push(element) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:bar, 1], [:baz, 2]], [[:baz, 2], [:bam, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_cons: (Integer n) { (::Array[Elem]) -> void } -> self
               | (Integer n) -> ::Enumerator[::Array[Elem], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_index(*args) {|element, i| ..... } -> self
  #   - each_with_index(*args)                       -> enumerator
  # -->
  # With a block given, calls the block with each element and its index; returns
  # `self`:
  #
  #     h = {}
  #     (1..4).each_with_index {|element, i| h[element] = i } # => 1..4
  #     h # => {1=>0, 2=>1, 3=>2, 4=>3}
  #
  #     h = {}
  #     %w[a b c d].each_with_index {|element, i| h[element] = i }
  #     # => ["a", "b", "c", "d"]
  #     h # => {"a"=>0, "b"=>1, "c"=>2, "d"=>3}
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.each_with_index {|element, i| a.push([i, element]) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[0, [:foo, 0]], [1, [:bar, 1]], [2, [:baz, 2]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_index: () { (Elem, Integer index) -> untyped } -> self
                     | () -> ::Enumerator[[ Elem, Integer ], self]

  # <!--
  #   rdoc-file=enum.c
  #   - each_with_object(object) { |(*args), memo_object| ... }  ->  object
  #   - each_with_object(object)                                 ->  enumerator
  # -->
  # Calls the block once for each element, passing both the element and the given
  # object:
  #
  #     (1..4).each_with_object([]) {|i, a| a.push(i**2) } # => [1, 4, 9, 16]
  #     h.each_with_object({}) {|element, h| k, v = *element; h[v] = k }
  #     # => {0=>:foo, 1=>:bar, 2=>:baz}
  #
  # With no block given, returns an Enumerator.
  #
  def each_with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                      | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  # Enumerable#entries is an alias for Enumerable#to_a.
  #
  def entries: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - select {|element| ... } -> array
  #   - select -> enumerator
  # -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  def find_all: () { (Elem) -> boolish } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias select find_all

  # <!-- rdoc-file=enum.c -->
  # Returns an array containing elements selected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns a truthy value:
  #
  #     (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
  #     a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
  #     a # => {:bar=>1, :baz=>2}
  #
  # With no block given, returns an Enumerator.
  #
  # Related: #reject.
  #
  alias filter find_all

  # <!--
  #   rdoc-file=enum.c
  #   - find_index(object) -> integer or nil
  #   - find_index {|element| ... } -> integer or nil
  #   - find_index -> enumerator
  # -->
  # Returns the index of the first element that meets a specified criterion, or
  # `nil` if no such element is found.
  #
  # With argument `object` given, returns the index of the first element that is
  # `==` `object`:
  #
  #     ['a', 'b', 'c', 'b'].find_index('b') # => 1
  #
  # With a block given, calls the block with successive elements; returns the
  # first element for which the block returns a truthy value:
  #
  #     ['a', 'b', 'c', 'b'].find_index {|element| element.start_with?('b') } # => 1
  #     {foo: 0, bar: 1, baz: 2}.find_index {|key, value| value > 1 }         # => 2
  #
  # With no argument and no block given, returns an Enumerator.
  #
  def find_index: (untyped value) -> Integer?
                | () { (Elem) -> boolish } -> Integer?
                | () -> ::Enumerator[Elem, Integer?]

  # <!--
  #   rdoc-file=enum.c
  #   - first    -> element or nil
  #   - first(n) -> array
  # -->
  # Returns the first element or elements.
  #
  # With no argument, returns the first element, or `nil` if there is none:
  #
  #     (1..4).first                   # => 1
  #     %w[a b c].first                # => "a"
  #     {foo: 1, bar: 1, baz: 2}.first # => [:foo, 1]
  #     [].first                       # => nil
  #
  # With integer argument `n`, returns an array containing the first `n` elements
  # that exist:
  #
  #     (1..4).first(2)                   # => [1, 2]
  #     %w[a b c d].first(3)              # => ["a", "b", "c"]
  #     %w[a b c d].first(50)             # => ["a", "b", "c", "d"]
  #     {foo: 1, bar: 1, baz: 2}.first(2) # => [[:foo, 1], [:bar, 1]]
  #     [].first(2)                       # => []
  #
  def first: () -> Elem?
           | (_ToInt n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - grep(pattern) -> array
  #   - grep(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based elements of `self` that match the given
  # pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `true`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/)                   # => ["bar", "car"]
  #     (1..10).grep(3..8)             # => [3, 4, 5, 6, 7, 8]
  #     ['a', 'b', 0, 1].grep(Integer) # => [0, 1]
  #
  # With a block given, calls the block with each matching element and returns an
  # array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep(/ar/) {|element| element.upcase } # => ["BAR", "CAR"]
  #
  # Related: #grep_v.
  #
  def grep: (untyped arg0) -> ::Array[Elem]
          | [U] (untyped arg0) { (Elem arg0) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - grep_v(pattern) -> array
  #   - grep_v(pattern) {|element| ... } -> array
  # -->
  # Returns an array of objects based on elements of `self` that *don't* match the
  # given pattern.
  #
  # With no block given, returns an array containing each element for which
  # `pattern === element` is `false`:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/)                   # => ["foo", "moo"]
  #     (1..10).grep_v(3..8)             # => [1, 2, 9, 10]
  #     ['a', 'b', 0, 1].grep_v(Integer) # => ["a", "b"]
  #
  # With a block given, calls the block with each non-matching element and returns
  # an array containing each object returned by the block:
  #
  #     a = ['foo', 'bar', 'car', 'moo']
  #     a.grep_v(/ar/) {|element| element.upcase } # => ["FOO", "MOO"]
  #
  # Related: #grep.
  #
  def grep_v: (untyped) -> ::Array[Elem]
            | [U] (untyped) { (Elem) -> U } -> ::Array[U]

  # <!--
  #   rdoc-file=enum.c
  #   - group_by {|element| ... } -> hash
  #   - group_by                  -> enumerator
  # -->
  # With a block given returns a hash:
  #
  # *   Each key is a return value from the block.
  # *   Each value is an array of those elements for which the block returned that
  #     key.
  #
  #
  # Examples:
  #
  #     g = (1..6).group_by {|i| i%3 }
  #     g # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]}
  #     h = {foo: 0, bar: 1, baz: 0, bat: 1}
  #     g = h.group_by {|key, value| value }
  #     g # => {0=>[[:foo, 0], [:baz, 0]], 1=>[[:bar, 1], [:bat, 1]]}
  #
  # With no block given, returns an Enumerator.
  #
  def group_by: [U] () { (Elem arg0) -> U } -> ::Hash[U, ::Array[Elem]]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!-- rdoc-file=enum.c -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  # Enumerable#member? is an alias for Enumerable#include?.
  #
  def include?: (Elem arg0) -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - inject(symbol) -> object
  #   - inject(initial_operand, symbol) -> object
  #   - inject {|memo, operand| ... } -> object
  #   - inject(initial_operand) {|memo, operand| ... } -> object
  # -->
  # Returns an object formed from operands via either:
  #
  # *   A method named by `symbol`.
  # *   A block to which each operand is passed.
  #
  #
  # With method-name argument `symbol`, combines operands using the method:
  #
  #     # Sum, without initial_operand.
  #     (1..4).inject(:+)     # => 10
  #     # Sum, with initial_operand.
  #     (1..4).inject(10, :+) # => 20
  #
  # With a block, passes each operand to the block:
  #
  #     # Sum of squares, without initial_operand.
  #     (1..4).inject {|sum, n| sum + n*n }    # => 30
  #     # Sum of squares, with initial_operand.
  #     (1..4).inject(2) {|sum, n| sum + n*n } # => 32
  #
  # **Operands**
  #
  # If argument `initial_operand` is not given, the operands for `inject` are
  # simply the elements of `self`. Example calls and their operands:
  #
  #     `(1..4).inject(:+)`
  # :       `[1, 2, 3, 4]`.
  #
  #     `(1...4).inject(:+)`
  # :       `[1, 2, 3]`.
  #
  #     `('a'..'d').inject(:+)`
  # :       `['a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject(:+)`
  # :       `['a', 'b', 'c']`.
  #
  #
  #
  # Examples with first operand (which is `self.first`) of various types:
  #
  #     # Integer.
  #     (1..4).inject(:+)                # => 10
  #     # Float.
  #     [1.0, 2, 3, 4].inject(:+)        # => 10.0
  #     # Character.
  #     ('a'..'d').inject(:+)            # => "abcd"
  #     # Complex.
  #     [Complex(1, 2), 3, 4].inject(:+) # => (8+2i)
  #
  # If argument `initial_operand` is given, the operands for `inject` are that
  # value plus the elements of `self`. Example calls their operands:
  #
  #     `(1..4).inject(10, :+)`
  # :       `[10, 1, 2, 3, 4]`.
  #
  #     `(1...4).inject(10, :+)`
  # :       `[10, 1, 2, 3]`.
  #
  #     `('a'..'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c']`.
  #
  #
  #
  # Examples with `initial_operand` of various types:
  #
  #     # Integer.
  #     (1..4).inject(2, :+)               # => 12
  #     # Float.
  #     (1..4).inject(2.0, :+)             # => 12.0
  #     # String.
  #     ('a'..'d').inject('foo', :+)       # => "fooabcd"
  #     # Array.
  #     %w[a b c].inject(['x'], :push)     # => ["x", "a", "b", "c"]
  #     # Complex.
  #     (1..4).inject(Complex(2, 2), :+)   # => (12+2i)
  #
  # **Combination by Given \Method**
  #
  # If the method-name argument `symbol` is given, the operands are combined by
  # that method:
  #
  # *   The first and second operands are combined.
  # *   That result is combined with the third operand.
  # *   That result is combined with the fourth operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the result of the last combination.
  #
  # This call to `inject` computes the sum of the operands:
  #
  #     (1..4).inject(:+) # => 10
  #
  # Examples with various methods:
  #
  #     # Integer addition.
  #     (1..4).inject(:+)                # => 10
  #     # Integer multiplication.
  #     (1..4).inject(:*)                # => 24
  #     # Character range concatenation.
  #     ('a'..'d').inject('', :+)        # => "abcd"
  #     # String array concatenation.
  #     %w[foo bar baz].inject('', :+)   # => "foobarbaz"
  #     # Hash update.
  #     h = [{foo: 0, bar: 1}, {baz: 2}, {bat: 3}].inject(:update)
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #     # Hash conversion to nested arrays.
  #     h = {foo: 0, bar: 1}.inject([], :push)
  #     h # => [[:foo, 0], [:bar, 1]]
  #
  # **Combination by Given Block**
  #
  # If a block is given, the operands are passed to the block:
  #
  # *   The first call passes the first and second operands.
  # *   The second call passes the result of the first call, along with the third
  #     operand.
  # *   The third call passes the result of the second call, along with the fourth
  #     operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the return value from the last block call.
  #
  # This call to `inject` gives a block that writes the memo and element, and also
  # sums the elements:
  #
  #     (1..4).inject do |memo, element|
  #       p "Memo: #{memo}; element: #{element}"
  #       memo + element
  #     end # => 10
  #
  # Output:
  #
  #     "Memo: 1; element: 2"
  #     "Memo: 3; element: 3"
  #     "Memo: 6; element: 4"
  #
  # Enumerable#reduce is an alias for Enumerable#inject.
  #
  def inject: (untyped init, Symbol method) -> untyped
            | (Symbol method) -> untyped
            | [A] (A initial) { (A, Elem) -> A } -> A
            | () { (Elem, Elem) -> Elem } -> Elem

  # <!--
  #   rdoc-file=enum.c
  #   - max                  -> element
  #   - max(n)               -> array
  #   - max {|a, b| ... }    -> element
  #   - max(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the maximum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the maximum element, using the
  # elements' own method `<=>` for comparison:
  #
  #     (1..4).max                   # => 4
  #     (-4..-1).max                 # => -1
  #     %w[d c b a].max              # => "d"
  #     {foo: 0, bar: 1, baz: 2}.max # => [:foo, 0]
  #     [].max                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` maximum elements that exist:
  #
  #     (1..4).max(2)                   # => [4, 3]
  #     (-4..-1).max(2)                # => [-1, -2]
  #     %w[d c b a].max(2)              # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.max(2) # => [[:foo, 0], [:baz, 2]]
  #     [].max(2)                       # => []
  #
  # With a block given, the block determines the maximum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # With a block given and no argument, returns the maximum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].max {|a, b| a.size <=> b.size } # => "xxxx"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max {|pair1, pair2| pair1[1] <=> pair2[1] }     # => [:baz, 2]
  #     [].max {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` maximum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].max(2) {|a, b| a.size <=> b.size } # => ["xxxx", "xxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.max(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].max(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min, #minmax, #max_by.
  #
  def max: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - max_by {|element| ... }    -> element
  #   - max_by(n) {|element| ... } -> array
  #   - max_by                     -> enumerator
  #   - max_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the maximum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the maximum value:
  #
  #     (1..4).max_by {|element| -element }                    # => 1
  #     %w[a b c d].max_by {|element| -element.ord }           # => "a"
  #     {foo: 0, bar: 1, baz: 2}.max_by {|key, value| -value } # => [:foo, 0]
  #     [].max_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns maximum values:
  #
  #     (1..4).max_by(2) {|element| -element }
  #     # => [1, 2]
  #     %w[a b c d].max_by(2) {|element| -element.ord }
  #     # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.max_by(2) {|key, value| -value }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].max_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max, #minmax, #min_by.
  #
  def max_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min                  -> element
  #   - min(n)               -> array
  #   - min {|a, b| ... }    -> element
  #   - min(n) {|a, b| ... } -> array
  # -->
  # Returns the element with the minimum element according to a given criterion.
  # The ordering of equal elements is indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum element, using the
  # elements' own method `<=>` for comparison:
  #
  #     (1..4).min                   # => 1
  #     (-4..-1).min                 # => -4
  #     %w[d c b a].min              # => "a"
  #     {foo: 0, bar: 1, baz: 2}.min # => [:bar, 1]
  #     [].min                       # => nil
  #
  # With positive integer argument `n` given, and no block, returns an array
  # containing the first `n` minimum elements that exist:
  #
  #     (1..4).min(2)                   # => [1, 2]
  #     (-4..-1).min(2)                 # => [-4, -3]
  #     %w[d c b a].min(2)              # => ["a", "b"]
  #     {foo: 0, bar: 1, baz: 2}.min(2) # => [[:bar, 1], [:baz, 2]]
  #     [].min(2)                       # => []
  #
  # With a block given, the block determines the minimum elements. The block is
  # called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # With a block given and no argument, returns the minimum element as determined
  # by the block:
  #
  #     %w[xxx x xxxx xx].min {|a, b| a.size <=> b.size } # => "x"
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min {|pair1, pair2| pair1[1] <=> pair2[1] } # => [:foo, 0]
  #     [].min {|a, b| a <=> b }                          # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the first `n` minimum elements that exist, as determined by the
  # block.
  #
  #     %w[xxx x xxxx xx].min(2) {|a, b| a.size <=> b.size } # => ["x", "xx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.min(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:bar, 1]]
  #     [].min(2) {|a, b| a <=> b }                          # => []
  #
  # Related: #min_by, #minmax, #max.
  #
  def min: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - min_by {|element| ... }    -> element
  #   - min_by(n) {|element| ... } -> array
  #   - min_by                     -> enumerator
  #   - min_by(n)                  -> enumerator
  # -->
  # Returns the elements for which the block returns the minimum values.
  #
  # With a block given and no argument, returns the element for which the block
  # returns the minimum value:
  #
  #     (1..4).min_by {|element| -element }                    # => 4
  #     %w[a b c d].min_by {|element| -element.ord }           # => "d"
  #     {foo: 0, bar: 1, baz: 2}.min_by {|key, value| -value } # => [:baz, 2]
  #     [].min_by {|element| -element }                        # => nil
  #
  # With a block given and positive integer argument `n` given, returns an array
  # containing the `n` elements for which the block returns minimum values:
  #
  #     (1..4).min_by(2) {|element| -element }
  #     # => [4, 3]
  #     %w[a b c d].min_by(2) {|element| -element.ord }
  #     # => ["d", "c"]
  #     {foo: 0, bar: 1, baz: 2}.min_by(2) {|key, value| -value }
  #     # => [[:baz, 2], [:bar, 1]]
  #     [].min_by(2) {|element| -element }
  #     # => []
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #min, #minmax, #max_by.
  #
  def min_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax               -> [minimum, maximum]
  #   - minmax {|a, b| ... } -> [minimum, maximum]
  # -->
  # Returns a 2-element array containing the minimum and maximum elements
  # according to a given criterion. The ordering of equal elements is
  # indeterminate and may be unstable.
  #
  # With no argument and no block, returns the minimum and maximum elements, using
  # the elements' own method `<=>` for comparison:
  #
  #     (1..4).minmax                   # => [1, 4]
  #     (-4..-1).minmax                 # => [-4, -1]
  #     %w[d c b a].minmax              # => ["a", "d"]
  #     {foo: 0, bar: 1, baz: 2}.minmax # => [[:bar, 1], [:foo, 0]]
  #     [].minmax                       # => [nil, nil]
  #
  # With a block given, returns the minimum and maximum elements as determined by
  # the block:
  #
  #     %w[xxx x xxxx xx].minmax {|a, b| a.size <=> b.size } # => ["x", "xxxx"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.minmax {|pair1, pair2| pair1[1] <=> pair2[1] }
  #     # => [[:foo, 0], [:baz, 2]]
  #     [].minmax {|a, b| a <=> b }                          # => [nil, nil]
  #
  # Related: #min, #max, #minmax_by.
  #
  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem arg0, Elem arg1) -> Integer } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - minmax_by {|element| ... } -> [minimum, maximum]
  #   - minmax_by                  -> enumerator
  # -->
  # Returns a 2-element array containing the elements for which the block returns
  # minimum and maximum values:
  #
  #     (1..4).minmax_by {|element| -element }
  #     # => [4, 1]
  #     %w[a b c d].minmax_by {|element| -element.ord }
  #     # => ["d", "a"]
  #     {foo: 0, bar: 1, baz: 2}.minmax_by {|key, value| -value }
  #     # => [[:baz, 2], [:foo, 0]]
  #     [].minmax_by {|element| -element }
  #     # => [nil, nil]
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #max_by, #minmax, #min_by.
  #
  def minmax_by: () -> [ Elem?, Elem? ]
               | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> [ Elem?, Elem? ]

  # <!--
  #   rdoc-file=enum.c
  #   - none?                  -> true or false
  #   - none?(pattern)         -> true or false
  #   - none? {|element| ... } -> true or false
  # -->
  # Returns whether no element meets a given criterion.
  #
  # With no argument and no block, returns whether no element is truthy:
  #
  #     (1..4).none?           # => false
  #     [nil, false].none?     # => true
  #     {foo: 0}.none?         # => false
  #     {foo: 0, bar: 1}.none? # => false
  #     [].none?               # => true
  #
  # With argument `pattern` and no block, returns whether for no element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 1.1].none?(Integer)      # => true
  #     %w[bar baz bat bam].none?(/m/)        # => false
  #     %w[bar baz bat bam].none?(/foo/)      # => true
  #     %w[bar baz bat bam].none?('ba')       # => true
  #     {foo: 0, bar: 1, baz: 2}.none?(Hash)  # => true
  #     {foo: 0}.none?(Array)                 # => false
  #     [].none?(Integer)                     # => true
  #
  # With a block given, returns whether the block returns a truthy value for no
  # element:
  #
  #     (1..4).none? {|element| element < 1 }                     # => true
  #     (1..4).none? {|element| element < 2 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 0 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 1 } # => false
  #
  # Related: #one?, #all?, #any?.
  #
  def none?: () -> bool
           | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - one?                  -> true or false
  #   - one?(pattern)         -> true or false
  #   - one? {|element| ... } -> true or false
  # -->
  # Returns whether exactly one element meets a given criterion.
  #
  # With no argument and no block, returns whether exactly one element is truthy:
  #
  #     (1..1).one?           # => true
  #     [1, nil, false].one?  # => true
  #     (1..4).one?           # => false
  #     {foo: 0}.one?         # => true
  #     {foo: 0, bar: 1}.one? # => false
  #     [].one?               # => false
  #
  # With argument `pattern` and no block, returns whether for exactly one element
  # `element`, `pattern === element`:
  #
  #     [nil, false, 0].one?(Integer)        # => true
  #     [nil, false, 0].one?(Numeric)        # => true
  #     [nil, false, 0].one?(Float)          # => false
  #     %w[bar baz bat bam].one?(/m/)        # => true
  #     %w[bar baz bat bam].one?(/foo/)      # => false
  #     %w[bar baz bat bam].one?('ba')       # => false
  #     {foo: 0, bar: 1, baz: 2}.one?(Array) # => false
  #     {foo: 0}.one?(Array)                 # => true
  #     [].one?(Integer)                     # => false
  #
  # With a block given, returns whether the block returns a truthy value for
  # exactly one element:
  #
  #     (1..4).one? {|element| element < 2 }                     # => true
  #     (1..4).one? {|element| element < 1 }                     # => false
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 1 }  # => true
  #     {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 2 } # => false
  #
  # Related: #none?, #all?, #any?.
  #
  def one?: () -> bool
          | () { (Elem) -> boolish } -> bool

  # <!--
  #   rdoc-file=enum.c
  #   - partition {|element| ... } -> [true_array, false_array]
  #   - partition -> enumerator
  # -->
  # With a block given, returns an array of two arrays:
  #
  # *   The first having those elements for which the block returns a truthy
  #     value.
  # *   The other having all other elements.
  #
  #
  # Examples:
  #
  #     p = (1..4).partition {|i| i.even? }
  #     p # => [[2, 4], [1, 3]]
  #     p = ('a'..'d').partition {|c| c < 'c' }
  #     p # => [["a", "b"], ["c", "d"]]
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     p = h.partition {|key, value| key.start_with?('b') }
  #     p # => [[[:bar, 1], [:baz, 2], [:bat, 3]], [[:foo, 0]]]
  #     p = h.partition {|key, value| value < 2 }
  #     p # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]]]
  #
  # With no block given, returns an Enumerator.
  #
  # Related: Enumerable#group_by.
  #
  def partition: () { (Elem) -> boolish } -> [ ::Array[Elem], ::Array[Elem] ]
               | () -> ::Enumerator[Elem, [ ::Array[Elem], ::Array[Elem] ]]

  # <!--
  #   rdoc-file=enum.c
  #   - reject {|element| ... } -> array
  #   - reject -> enumerator
  # -->
  # Returns an array of objects rejected by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of those elements for which the block returns `nil` or `false`:
  #
  #     (0..9).reject {|i| i * 2 if i.even? }                             # => [1, 3, 5, 7, 9]
  #     {foo: 0, bar: 1, baz: 2}.reject {|key, value| key if value.odd? } # => {:foo=>0, :baz=>2}
  #
  # When no block given, returns an Enumerator.
  #
  # Related: #select.
  #
  def reject: () { (Elem) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - reverse_each(*args) {|element| ... } ->  self
  #   - reverse_each(*args)                  ->  enumerator
  # -->
  # With a block given, calls the block with each element, but in reverse order;
  # returns `self`:
  #
  #     a = []
  #     (1..4).reverse_each {|element| a.push(-element) } # => 1..4
  #     a # => [-4, -3, -2, -1]
  #
  #     a = []
  #     %w[a b c d].reverse_each {|element| a.push(element) }
  #     # => ["a", "b", "c", "d"]
  #     a # => ["d", "c", "b", "a"]
  #
  #     a = []
  #     h.reverse_each {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:baz, 2], [:bar, 1], [:foo, 0]]
  #
  # With no block given, returns an Enumerator.
  #
  def reverse_each: () { (Elem arg0) -> untyped } -> void
                  | () -> ::Enumerator[Elem, void]

  # <!--
  #   rdoc-file=enum.c
  #   - sort               -> array
  #   - sort {|a, b| ... } -> array
  # -->
  # Returns an array containing the sorted elements of `self`. The ordering of
  # equal elements is indeterminate and may be unstable.
  #
  # With no block given, the sort compares using the elements' own method `<=>`:
  #
  #     %w[b c a d].sort              # => ["a", "b", "c", "d"]
  #     {foo: 0, bar: 1, baz: 2}.sort # => [[:bar, 1], [:baz, 2], [:foo, 0]]
  #
  # With a block given, comparisons in the block determine the ordering. The block
  # is called with two elements `a` and `b`, and must return:
  #
  # *   A negative integer if `a < b`.
  # *   Zero if `a == b`.
  # *   A positive integer if `a > b`.
  #
  #
  # Examples:
  #
  #     a = %w[b c a d]
  #     a.sort {|a, b| b <=> a } # => ["d", "c", "b", "a"]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.sort {|a, b| b <=> a } # => [[:foo, 0], [:baz, 2], [:bar, 1]]
  #
  # See also #sort_by. It implements a Schwartzian transform which is useful when
  # key computation or comparison is expensive.
  #
  def sort: () -> ::Array[Elem]
          | () { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sort_by {|element| ... } -> array
  #   - sort_by                  -> enumerator
  # -->
  # With a block given, returns an array of elements of `self`, sorted according
  # to the value returned by the block for each element. The ordering of equal
  # elements is indeterminate and may be unstable.
  #
  # Examples:
  #
  #     a = %w[xx xxx x xxxx]
  #     a.sort_by {|s| s.size }        # => ["x", "xx", "xxx", "xxxx"]
  #     a.sort_by {|s| -s.size }       # => ["xxxx", "xxx", "xx", "x"]
  #     h = {foo: 2, bar: 1, baz: 0}
  #     h.sort_by{|key, value| value } # => [[:baz, 0], [:bar, 1], [:foo, 2]]
  #     h.sort_by{|key, value| key }   # => [[:bar, 1], [:baz, 0], [:foo, 2]]
  #
  # With no block given, returns an Enumerator.
  #
  # The current implementation of #sort_by generates an array of tuples containing
  # the original collection element and the mapped value. This makes #sort_by
  # fairly expensive when the keysets are simple.
  #
  #     require 'benchmark'
  #
  #     a = (1..100000).map { rand(100000) }
  #
  #     Benchmark.bm(10) do |b|
  #       b.report("Sort")    { a.sort }
  #       b.report("Sort by") { a.sort_by { |a| a } }
  #     end
  #
  # *produces:*
  #
  #     user     system      total        real
  #     Sort        0.180000   0.000000   0.180000 (  0.175469)
  #     Sort by     1.980000   0.040000   2.020000 (  2.013586)
  #
  # However, consider the case where comparing the keys is a non-trivial
  # operation. The following code sorts some files on modification time using the
  # basic #sort method.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This sort is inefficient: it generates two new File objects during every
  # comparison. A slightly better technique is to use the Kernel#test method to
  # generate the modification times directly.
  #
  #     files = Dir["*"]
  #     sorted = files.sort { |a, b|
  #       test(?M, a) <=> test(?M, b)
  #     }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This still generates many unnecessary Time objects. A more efficient technique
  # is to cache the sort keys (modification times in this case) before the sort.
  # Perl users often call this approach a Schwartzian transform, after Randal
  # Schwartz. We construct a temporary array, where each element is an array
  # containing our sort key along with the filename. We sort this array, and then
  # extract the filename from the result.
  #
  #     sorted = Dir["*"].collect { |f|
  #        [test(?M, f), f]
  #     }.sort.collect { |f| f[1] }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # This is exactly what #sort_by does internally.
  #
  #     sorted = Dir["*"].sort_by { |f| test(?M, f) }
  #     sorted   #=> ["mon", "tues", "wed", "thurs"]
  #
  # To produce the reverse of a specific order, the following can be used:
  #
  #     ary.sort_by { ... }.reverse!
  #
  def sort_by: () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]
             | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - take(n) -> array
  # -->
  # For non-negative integer `n`, returns the first `n` elements:
  #
  #     r = (1..4)
  #     r.take(2) # => [1, 2]
  #     r.take(0) # => []
  #
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3}
  #     h.take(2) # => [[:foo, 0], [:bar, 1]]
  #
  def take: (Integer n) -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - take_while {|element| ... } -> array
  #   - take_while                  -> enumerator
  # -->
  # Calls the block with successive elements as long as the block returns a truthy
  # value; returns an array of all elements up to that point:
  #
  #     (1..4).take_while{|i| i < 3 } # => [1, 2]
  #     h = {foo: 0, bar: 1, baz: 2}
  #     h.take_while{|element| key, value = *element; value < 2 }
  #     # => [[:foo, 0], [:bar, 1]]
  #
  # With no block given, returns an Enumerator.
  #
  def take_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  # <!--
  #   rdoc-file=enum.c
  #   - to_h -> hash
  #   - to_h {|element| ... }  -> hash
  # -->
  # When `self` consists of 2-element arrays, returns a hash each of whose entries
  # is the key-value pair formed from one of those arrays:
  #
  #     [[:foo, 0], [:bar, 1], [:baz, 2]].to_h # => {:foo=>0, :bar=>1, :baz=>2}
  #
  # When a block is given, the block is called with each element of `self`; the
  # block should return a 2-element array which becomes a key-value pair in the
  # returned hash:
  #
  #     (0..3).to_h {|i| [i, i ** 2]} # => {0=>0, 1=>1, 2=>4, 3=>9}
  #
  # Raises an exception if an element of `self` is not a 2-element array, and a
  # block is not passed.
  #
  def to_h: () -> ::Hash[untyped, untyped]
          | [T, U] () { (Elem) -> [ T, U ] } -> ::Hash[T, U]

  # <!--
  #   rdoc-file=enum.c
  #   - each_slice(n) { ... }  ->  self
  #   - each_slice(n)          ->  enumerator
  # -->
  # Calls the block with each successive disjoint `n`-tuple of elements; returns
  # `self`:
  #
  #     a = []
  #     (1..10).each_slice(3) {|tuple| a.push(tuple) }
  #     a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz: 2, bat: 3, bam: 4}
  #     h.each_slice(2) {|tuple| a.push(tuple) }
  #     a # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]], [[:bam, 4]]]
  #
  # With no block given, returns an Enumerator.
  #
  def each_slice: (Integer n) { (::Array[Elem]) -> void } -> self
                | (Integer n) -> ::Enumerator[::Array[Elem], self]

  interface _NotFound[T]
    def call: () -> T
  end

  # <!--
  #   rdoc-file=enum.c
  #   - find(if_none_proc = nil) {|element| ... } -> object or nil
  #   - find(if_none_proc = nil) -> enumerator
  # -->
  # Returns the first element for which the block returns a truthy value.
  #
  # With a block given, calls the block with successive elements of the
  # collection; returns the first element for which the block returns a truthy
  # value:
  #
  #     (0..9).find {|element| element > 2}                # => 3
  #
  # If no such element is found, calls `if_none_proc` and returns its return
  # value.
  #
  #     (0..9).find(proc {false}) {|element| element > 12} # => false
  #     {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
  #     {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []
  #
  # With no block given, returns an Enumerator.
  #
  def find: () { (Elem) -> boolish } -> Elem?
          | () -> ::Enumerator[Elem, Elem?]
          | [T] (_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
          | [T] (_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  # <!--
  #   rdoc-file=enum.c
  #   - flat_map {|element| ... } -> array
  #   - flat_map -> enumerator
  # -->
  # Returns an array of flattened objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns a
  # flattened array of objects returned by the block:
  #
  #     [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
  #     [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
  #     [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
  #     {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]
  #
  # With no block given, returns an Enumerator.
  #
  # Alias: #collect_concat.
  #
  def flat_map: [U] () { (Elem) -> (Array[U] | U) } -> Array[U]
              | () -> ::Enumerator[Elem, Array[untyped]]

  # <!-- rdoc-file=enum.c -->
  # Returns an array of objects returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # of the objects returned by the block:
  #
  #     (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
  #     {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def map: [U] () { (Elem arg0) -> U } -> ::Array[U]
         | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enum.c
  #   - include?(object) -> true or false
  # -->
  # Returns whether for any element `object == element`:
  #
  #     (1..4).include?(2)                       # => true
  #     (1..4).include?(5)                       # => false
  #     (1..4).include?('2')                     # => false
  #     %w[a b c d].include?('b')                # => true
  #     %w[a b c d].include?('2')                # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
  #     {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
  #     {foo: 0, bar: 1, baz: 2}.include?(0)     # => false
  #
  # Enumerable#member? is an alias for Enumerable#include?.
  #
  def member?: (Elem arg0) -> bool

  # <!-- rdoc-file=enum.c -->
  # Returns an object formed from operands via either:
  #
  # *   A method named by `symbol`.
  # *   A block to which each operand is passed.
  #
  #
  # With method-name argument `symbol`, combines operands using the method:
  #
  #     # Sum, without initial_operand.
  #     (1..4).inject(:+)     # => 10
  #     # Sum, with initial_operand.
  #     (1..4).inject(10, :+) # => 20
  #
  # With a block, passes each operand to the block:
  #
  #     # Sum of squares, without initial_operand.
  #     (1..4).inject {|sum, n| sum + n*n }    # => 30
  #     # Sum of squares, with initial_operand.
  #     (1..4).inject(2) {|sum, n| sum + n*n } # => 32
  #
  # **Operands**
  #
  # If argument `initial_operand` is not given, the operands for `inject` are
  # simply the elements of `self`. Example calls and their operands:
  #
  #     `(1..4).inject(:+)`
  # :       `[1, 2, 3, 4]`.
  #
  #     `(1...4).inject(:+)`
  # :       `[1, 2, 3]`.
  #
  #     `('a'..'d').inject(:+)`
  # :       `['a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject(:+)`
  # :       `['a', 'b', 'c']`.
  #
  #
  #
  # Examples with first operand (which is `self.first`) of various types:
  #
  #     # Integer.
  #     (1..4).inject(:+)                # => 10
  #     # Float.
  #     [1.0, 2, 3, 4].inject(:+)        # => 10.0
  #     # Character.
  #     ('a'..'d').inject(:+)            # => "abcd"
  #     # Complex.
  #     [Complex(1, 2), 3, 4].inject(:+) # => (8+2i)
  #
  # If argument `initial_operand` is given, the operands for `inject` are that
  # value plus the elements of `self`. Example calls their operands:
  #
  #     `(1..4).inject(10, :+)`
  # :       `[10, 1, 2, 3, 4]`.
  #
  #     `(1...4).inject(10, :+)`
  # :       `[10, 1, 2, 3]`.
  #
  #     `('a'..'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c', 'd']`.
  #
  #     `('a'...'d').inject('e', :+)`
  # :       `['e', 'a', 'b', 'c']`.
  #
  #
  #
  # Examples with `initial_operand` of various types:
  #
  #     # Integer.
  #     (1..4).inject(2, :+)               # => 12
  #     # Float.
  #     (1..4).inject(2.0, :+)             # => 12.0
  #     # String.
  #     ('a'..'d').inject('foo', :+)       # => "fooabcd"
  #     # Array.
  #     %w[a b c].inject(['x'], :push)     # => ["x", "a", "b", "c"]
  #     # Complex.
  #     (1..4).inject(Complex(2, 2), :+)   # => (12+2i)
  #
  # **Combination by Given \Method**
  #
  # If the method-name argument `symbol` is given, the operands are combined by
  # that method:
  #
  # *   The first and second operands are combined.
  # *   That result is combined with the third operand.
  # *   That result is combined with the fourth operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the result of the last combination.
  #
  # This call to `inject` computes the sum of the operands:
  #
  #     (1..4).inject(:+) # => 10
  #
  # Examples with various methods:
  #
  #     # Integer addition.
  #     (1..4).inject(:+)                # => 10
  #     # Integer multiplication.
  #     (1..4).inject(:*)                # => 24
  #     # Character range concatenation.
  #     ('a'..'d').inject('', :+)        # => "abcd"
  #     # String array concatenation.
  #     %w[foo bar baz].inject('', :+)   # => "foobarbaz"
  #     # Hash update.
  #     h = [{foo: 0, bar: 1}, {baz: 2}, {bat: 3}].inject(:update)
  #     h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
  #     # Hash conversion to nested arrays.
  #     h = {foo: 0, bar: 1}.inject([], :push)
  #     h # => [[:foo, 0], [:bar, 1]]
  #
  # **Combination by Given Block**
  #
  # If a block is given, the operands are passed to the block:
  #
  # *   The first call passes the first and second operands.
  # *   The second call passes the result of the first call, along with the third
  #     operand.
  # *   The third call passes the result of the second call, along with the fourth
  #     operand.
  # *   And so on.
  #
  #
  # The return value from `inject` is the return value from the last block call.
  #
  # This call to `inject` gives a block that writes the memo and element, and also
  # sums the elements:
  #
  #     (1..4).inject do |memo, element|
  #       p "Memo: #{memo}; element: #{element}"
  #       memo + element
  #     end # => 10
  #
  # Output:
  #
  #     "Memo: 1; element: 2"
  #     "Memo: 3; element: 3"
  #     "Memo: 6; element: 4"
  #
  # Enumerable#reduce is an alias for Enumerable#inject.
  #
  alias reduce inject

  # <!--
  #   rdoc-file=enum.c
  #   - to_a -> array
  # -->
  # Returns an array containing the items in `self`:
  #
  #     (0..4).to_a # => [0, 1, 2, 3, 4]
  #
  # Enumerable#entries is an alias for Enumerable#to_a.
  #
  def to_a: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.lazy -> lazy_enumerator
  # -->
  # Returns an Enumerator::Lazy, which redefines most Enumerable methods to
  # postpone enumeration and enumerate values only on an as-needed basis.
  #
  # ### Example
  #
  # The following program finds pythagorean triples:
  #
  #     def pythagorean_triples
  #       (1..Float::INFINITY).lazy.flat_map {|z|
  #         (1..z).flat_map {|x|
  #           (x..z).select {|y|
  #             x**2 + y**2 == z**2
  #           }.map {|y|
  #             [x, y, z]
  #           }
  #         }
  #       }
  #     end
  #     # show first ten pythagorean triples
  #     p pythagorean_triples.take(10).force # take is lazy, so force is needed
  #     p pythagorean_triples.first(10)      # first is eager
  #     # show pythagorean triples less than 100
  #     p pythagorean_triples.take_while { |*, z| z < 100 }.force
  #
  def lazy: () -> Enumerator::Lazy[Elem, void]

  # <!--
  #   rdoc-file=enum.c
  #   - uniq                  -> array
  #   - uniq {|element| ... } -> array
  # -->
  # With no block, returns a new array containing only unique elements; the array
  # has no two elements `e0` and `e1` such that `e0.eql?(e1)`:
  #
  #     %w[a b c c b a a b c].uniq       # => ["a", "b", "c"]
  #     [0, 1, 2, 2, 1, 0, 0, 1, 2].uniq # => [0, 1, 2]
  #
  # With a block, returns a new array containing only for which the block returns
  # a unique value:
  #
  #     a = [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
  #     a.uniq {|i| i.even? ? i : 0 } # => [0, 2, 4]
  #     a = %w[a b c d e e d c b a a b c d e]
  #     a.uniq {|c| c < 'c' }         # => ["a", "c"]
  #
  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - sum(initial_value = 0)                  -> number
  #   - sum(initial_value = 0) {|element| ... } -> object
  # -->
  # With no block given, returns the sum of `initial_value` and the elements:
  #
  #     (1..100).sum          # => 5050
  #     (1..100).sum(1)       # => 5051
  #     ('a'..'d').sum('foo') # => "fooabcd"
  #
  # Generally, the sum is computed using methods `+` and `each`; for performance
  # optimizations, those methods may not be used, and so any redefinition of those
  # methods may not have effect here.
  #
  # One such optimization: When possible, computes using Gauss's summation formula
  # *n(n+1)/2*:
  #
  #     100 * (100 + 1) / 2 # => 5050
  #
  # With a block given, calls the block with each element; returns the sum of
  # `initial_value` and the block return values:
  #
  #     (1..4).sum {|i| i*i }                        # => 30
  #     (1..4).sum(100) {|i| i*i }                   # => 130
  #     h = {a: 0, b: 1, c: 2, d: 3, e: 4, f: 5}
  #     h.sum {|key, value| value.odd? ? value : 0 } # => 9
  #     ('a'..'f').sum('x') {|c| c < 'd' ? c : '' }  # => "xabc"
  #
  def sum: () -> (Elem | Integer)
         | [T] () { (Elem arg0) -> T } -> (Integer | T)
         | [T] (?T arg0) -> (Elem | T)
         | [U] (?U arg0) { (Elem arg0) -> U } -> U

  # <!--
  #   rdoc-file=enum.c
  #   - filter_map {|element| ... } -> array
  #   - filter_map -> enumerator
  # -->
  # Returns an array containing truthy elements returned by the block.
  #
  # With a block given, calls the block with successive elements; returns an array
  # containing each truthy value returned by the block:
  #
  #     (0..9).filter_map {|i| i * 2 if i.even? }                              # => [0, 4, 8, 12, 16]
  #     {foo: 0, bar: 1, baz: 2}.filter_map {|key, value| key if value.even? } # => [:foo, :baz]
  #
  # When no block given, returns an Enumerator.
  #
  def filter_map: [U] () { (Elem elem) -> (nil | false | U) } -> ::Array[U]
                | () -> ::Enumerator[Elem, ::Array[untyped]]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.chain(*enums) -> enumerator
  # -->
  # Returns an enumerator object generated from this enumerator and given
  # enumerables.
  #
  #     e = (1..3).chain([4, 5])
  #     e.to_a #=> [1, 2, 3, 4, 5]
  #
  def chain: (*self enumerables) -> ::Enumerator::Chain[Elem]

  # <!--
  #   rdoc-file=enum.c
  #   - tally -> new_hash
  #   - tally(hash) -> hash
  # -->
  # Returns a hash containing the counts of equal elements:
  #
  # *   Each key is an element of `self`.
  # *   Each value is the number elements equal to that key.
  #
  #
  # With no argument:
  #
  #     %w[a b c b c a c b].tally # => {"a"=>2, "b"=>3, "c"=>3}
  #
  # With a hash argument, that hash is used for the tally (instead of a new hash),
  # and is returned; this may be useful for accumulating tallies across multiple
  # enumerables:
  #
  #     hash = {}
  #     hash = %w[a c d b c a].tally(hash)
  #     hash # => {"a"=>2, "c"=>2, "d"=>1, "b"=>1}
  #     hash = %w[b a z].tally(hash)
  #     hash # => {"a"=>3, "c"=>2, "d"=>1, "b"=>2, "z"=>1}
  #     hash = %w[b a m].tally(hash)
  #     hash # => {"a"=>4, "c"=>2, "d"=>1, "b"=>3, "z"=>1, "m"=> 1}
  #
  def tally: (?Hash[Elem, Integer] hash) -> ::Hash[Elem, Integer]

  # <!--
  #   rdoc-file=enum.c
  #   - each_entry(*args) {|element| ... } -> self
  #   - each_entry(*args)                  -> enumerator
  # -->
  # Calls the given block with each element, converting multiple values from yield
  # to an array; returns `self`:
  #
  #     a = []
  #     (1..4).each_entry {|element| a.push(element) } # => 1..4
  #     a # => [1, 2, 3, 4]
  #
  #     a = []
  #     h = {foo: 0, bar: 1, baz:2}
  #     h.each_entry {|element| a.push(element) }
  #     # => {:foo=>0, :bar=>1, :baz=>2}
  #     a # => [[:foo, 0], [:bar, 1], [:baz, 2]]
  #
  #     class Foo
  #       include Enumerable
  #       def each
  #         yield 1
  #         yield 1, 2
  #         yield
  #       end
  #     end
  #     Foo.new.each_entry {|yielded| p yielded }
  #
  # Output:
  #
  #     1
  #     [1, 2]
  #     nil
  #
  # With no block given, returns an Enumerator.
  #
  def each_entry: () -> ::Enumerator[Elem, self]
                | () { (Elem arg0) -> untyped } -> self

  # <!--
  #   rdoc-file=enum.c
  #   - zip(*other_enums) -> array
  #   - zip(*other_enums) {|array| ... } -> nil
  # -->
  # With no block given, returns a new array `new_array` of size self.size whose
  # elements are arrays. Each nested array `new_array[n]` is of size
  # `other_enums.size+1`, and contains:
  #
  # *   The `n`-th element of self.
  # *   The `n`-th element of each of the `other_enums`.
  #
  #
  # If all `other_enums` and self are the same size, all elements are included in
  # the result, and there is no `nil`-filling:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  #     f = {foo: 0, bar: 1, baz: 2}
  #     g = {goo: 3, gar: 4, gaz: 5}
  #     h = {hoo: 6, har: 7, haz: 8}
  #     d = f.zip(g, h)
  #     d # => [
  #       #      [[:foo, 0], [:goo, 3], [:hoo, 6]],
  #       #      [[:bar, 1], [:gar, 4], [:har, 7]],
  #       #      [[:baz, 2], [:gaz, 5], [:haz, 8]]
  #       #    ]
  #
  # If any enumerable in other_enums is smaller than self, fills to `self.size`
  # with `nil`:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2]
  #     c = [:c0, :c1]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
  #
  # If any enumerable in other_enums is larger than self, its trailing elements
  # are ignored:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3, :b4]
  #     c = [:c0, :c1, :c2, :c3, :c4, :c5]
  #     d = a.zip(b, c)
  #     d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
  #
  # When a block is given, calls the block with each of the sub-arrays (formed as
  # above); returns nil:
  #
  #     a = [:a0, :a1, :a2, :a3]
  #     b = [:b0, :b1, :b2, :b3]
  #     c = [:c0, :c1, :c2, :c3]
  #     a.zip(b, c) {|sub_array| p sub_array} # => nil
  #
  # Output:
  #
  #     [:a0, :b0, :c0]
  #     [:a1, :b1, :c1]
  #     [:a2, :b2, :c2]
  #     [:a3, :b3, :c3]
  #
  def zip: [Elem2] (::Enumerable[Elem2] enum) -> ::Array[[ Elem, Elem2 | nil ]]
         | [U, Elem2] (::Enumerable[Elem2]) { ([ Elem, Elem2 | nil ]) -> U } -> nil

  # <!--
  #   rdoc-file=enum.c
  #   - chunk {|array| ... } -> enumerator
  # -->
  # Each element in the returned enumerator is a 2-element array consisting of:
  #
  # *   A value returned by the block.
  # *   An array ("chunk") containing the element for which that value was
  #     returned, and all following elements for which the block returned the same
  #     value:
  #
  #
  # So that:
  #
  # *   Each block return value that is different from its predecessor begins a
  #     new chunk.
  # *   Each block return value that is the same as its predecessor continues the
  #     same chunk.
  #
  #
  # Example:
  #
  #     e = (0..10).chunk {|i| (i / 3).floor } # => #<Enumerator: ...>
  #     # The enumerator elements.
  #     e.next # => [0, [0, 1, 2]]
  #     e.next # => [1, [3, 4, 5]]
  #     e.next # => [2, [6, 7, 8]]
  #     e.next # => [3, [9, 10]]
  #
  # Method `chunk` is especially useful for an enumerable that is already sorted.
  # This example counts words for each initial letter in a large array of words:
  #
  #     # Get sorted words from a web page.
  #     url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
  #     words = URI::open(url).readlines
  #     # Make chunks, one for each letter.
  #     e = words.chunk {|word| word.upcase[0] } # => #<Enumerator: ...>
  #     # Display 'A' through 'F'.
  #     e.each {|c, words| p [c, words.length]; break if c == 'F' }
  #
  # Output:
  #
  #     ["A", 17096]
  #     ["B", 11070]
  #     ["C", 19901]
  #     ["D", 10896]
  #     ["E", 8736]
  #     ["F", 6860]
  #
  # You can use the special symbol `:_alone` to force an element into its own
  # separate chuck:
  #
  #     a = [0, 0, 1, 1]
  #     e = a.chunk{|i| i.even? ? :_alone : true }
  #     e.to_a # => [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]
  #
  # For example, you can put each line that contains a URL into its own chunk:
  #
  #     pattern = /http/
  #     open(filename) { |f|
  #       f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
  #         pp lines
  #       }
  #     }
  #
  # You can use the special symbol `:_separator` or `nil` to force an element to
  # be ignored (not included in any chunk):
  #
  #     a = [0, 0, -1, 1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1, 1]]]
  #
  # Note that the separator does end the chunk:
  #
  #     a = [0, 0, -1, 1, -1, 1]
  #     e = a.chunk{|i| i < 0 ? :_separator : true }
  #     e.to_a # => [[true, [0, 0]], [true, [1]], [true, [1]]]
  #
  # For example, the sequence of hyphens in svn log can be eliminated as follows:
  #
  #     sep = "-"*72 + "\n"
  #     IO.popen("svn log README") { |f|
  #       f.chunk { |line|
  #         line != sep || nil
  #       }.each { |_, lines|
  #         pp lines
  #       }
  #     }
  #     #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Update the portability section.\n",
  #     #    "\n"]
  #     #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
  #     #    "\n",
  #     #    "* README, README.ja: Add a note about default C flags.\n",
  #     #    "\n"]
  #     #   ...
  #
  # Paragraphs separated by empty lines can be parsed as follows:
  #
  #     File.foreach("README").chunk { |line|
  #       /\A\s*\z/ !~ line || nil
  #     }.each { |_, lines|
  #       pp lines
  #     }
  #
  def chunk: [U] () { (Elem elt) -> U } -> ::Enumerator[[ U, ::Array[Elem] ], void]
           | () -> ::Enumerator[Elem, ::Enumerator[[ untyped, ::Array[Elem] ], void]]

  # <!--
  #   rdoc-file=enum.c
  #   - chunk_while {|element, next_element| ... } -> enumerator
  # -->
  # The returned Enumerator uses the block to partition elements into arrays
  # ("chunks"); it calls the block with each element and its successor; begins a
  # new chunk if and only if the block returns a truthy value:
  #
  # Example:
  #
  #     a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
  #     e = a.chunk_while {|i, j| j == i + 1 }
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1, 2]
  #     [4]
  #     [9, 10, 11, 12]
  #     [15, 16]
  #     [19, 20, 21]
  #
  def chunk_while: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_when {|element, next_element| ... } -> enumerator
  # -->
  # The returned enumerator uses the block to partition elements into arrays
  # ("slices"); it calls the block with each element and its successor; begins a
  # new slice if and only if the block returns a truthy value:
  #
  #     a = [0, 1, 2, 4, 5, 6, 8, 9]
  #     e = a.slice_when {|i, j| j != i + 1 }
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [0, 1, 2]
  #     [4, 5, 6]
  #     [8, 9]
  #
  def slice_when: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_after(pattern)       -> enumerator
  #   - slice_after {|array| ... } -> enumerator
  # -->
  # With argument `pattern`, returns an enumerator that uses the pattern to
  # partition elements into arrays ("slices"). An element ends the current slice
  # if `element === pattern`:
  #
  #     a = %w[foo bar fop for baz fob fog bam foy]
  #     e = a.slice_after(/ba/) # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     ["foo", "bar"]
  #     ["fop", "for", "baz"]
  #     ["fob", "fog", "bam"]
  #     ["foy"]
  #
  # With a block, returns an enumerator that uses the block to partition elements
  # into arrays. An element ends the current slice if its block return is a truthy
  # value:
  #
  #     e = (1..20).slice_after {|i| i % 4 == 2 } # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1, 2]
  #     [3, 4, 5, 6]
  #     [7, 8, 9, 10]
  #     [11, 12, 13, 14]
  #     [15, 16, 17, 18]
  #     [19, 20]
  #
  # Other methods of the Enumerator class and Enumerable module, such as `map`,
  # etc., are also usable.
  #
  # For example, continuation lines (lines end with backslash) can be concatenated
  # as follows:
  #
  #     lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
  #     e = lines.slice_after(/(?<!\\)\n\z/)
  #     p e.to_a
  #     #=> [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
  #     p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
  #     #=>["foo\n", "barbaz\n", "\n", "qux\n"]
  #
  def slice_after: (untyped pattern) -> ::Enumerator[::Array[Elem], void]
                 | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem], void]

  # <!--
  #   rdoc-file=enum.c
  #   - slice_before(pattern)       -> enumerator
  #   - slice_before {|array| ... } -> enumerator
  # -->
  # With argument `pattern`, returns an enumerator that uses the pattern to
  # partition elements into arrays ("slices"). An element begins a new slice if
  # `element === pattern` (or if it is the first element).
  #
  #     a = %w[foo bar fop for baz fob fog bam foy]
  #     e = a.slice_before(/ba/) # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     ["foo"]
  #     ["bar", "fop", "for"]
  #     ["baz", "fob", "fog"]
  #     ["bam", "foy"]
  #
  # With a block, returns an enumerator that uses the block to partition elements
  # into arrays. An element begins a new slice if its block return is a truthy
  # value (or if it is the first element):
  #
  #     e = (1..20).slice_before {|i| i % 4 == 2 } # => #<Enumerator: ...>
  #     e.each {|array| p array }
  #
  # Output:
  #
  #     [1]
  #     [2, 3, 4, 5]
  #     [6, 7, 8, 9]
  #     [10, 11, 12, 13]
  #     [14, 15, 16, 17]
  #     [18, 19, 20]
  #
  # Other methods of the Enumerator class and Enumerable module, such as `to_a`,
  # `map`, etc., are also usable.
  #
  # For example, iteration over ChangeLog entries can be implemented as follows:
  #
  #     # iterate over ChangeLog entries.
  #     open("ChangeLog") { |f|
  #       f.slice_before(/\A\S/).each { |e| pp e }
  #     }
  #
  #     # same as above.  block is used instead of pattern argument.
  #     open("ChangeLog") { |f|
  #       f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
  #     }
  #
  # "svn proplist -R" produces multiline output for each file. They can be chunked
  # as follows:
  #
  #     IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
  #       f.lines.slice_before(/\AProp/).each { |lines| p lines }
  #     }
  #     #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
  #     #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
  #     #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
  #     #   ...
  #
  # If the block needs to maintain state over multiple elements, local variables
  # can be used. For example, three or more consecutive increasing numbers can be
  # squashed as follows (see `chunk_while` for a better way):
  #
  #     a = [0, 2, 3, 4, 6, 7, 9]
  #     prev = a[0]
  #     p a.slice_before { |e|
  #       prev, prev2 = e, prev
  #       prev2 + 1 != e
  #     }.map { |es|
  #       es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
  #     }.join(",")
  #     #=> "0,2-4,6,7,9"
  #
  # However local variables should be used carefully if the result enumerator is
  # enumerated twice or more. The local variables should be initialized for each
  # enumeration. Enumerator.new can be used to do it.
  #
  #     # Word wrapping.  This assumes all characters have same width.
  #     def wordwrap(words, maxwidth)
  #       Enumerator.new {|y|
  #         # cols is initialized in Enumerator.new.
  #         cols = 0
  #         words.slice_before { |w|
  #           cols += 1 if cols != 0
  #           cols += w.length
  #           if maxwidth < cols
  #             cols = w.length
  #             true
  #           else
  #             false
  #           end
  #         }.each {|ws| y.yield ws }
  #       }
  #     end
  #     text = (1..20).to_a.join(" ")
  #     enum = wordwrap(text.split(/\s+/), 10)
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # first enumeration.
  #     puts "-"*10
  #     enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
  #     puts "-"*10
  #     #=> ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #     #   1 2 3 4 5
  #     #   6 7 8 9 10
  #     #   11 12 13
  #     #   14 15 16
  #     #   17 18 19
  #     #   20
  #     #   ----------
  #
  # mbox contains series of mails which start with Unix From line. So each mail
  # can be extracted by slice before Unix From line.
  #
  #     # parse mbox
  #     open("mbox") { |f|
  #       f.slice_before { |line|
  #         line.start_with? "From "
  #       }.each { |mail|
  #         unix_from = mail.shift
  #         i = mail.index("\n")
  #         header = mail[0...i]
  #         body = mail[(i+1)..-1]
  #         body.pop if body.last == "\n"
  #         fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
  #         p unix_from
  #         pp fields
  #         pp body
  #       }
  #     }
  #
  #     # split mails in mbox (slice before Unix From line after an empty line)
  #     open("mbox") { |f|
  #       emp = true
  #       f.slice_before { |line|
  #         prevemp = emp
  #         emp = line == "\n"
  #         prevemp && line.start_with?("From ")
  #       }.each { |mail|
  #         mail.pop if mail.last == "\n"
  #         pp mail
  #       }
  #     }
  #
  def slice_before: (untyped pattern) -> ::Enumerator[::Array[Elem], void]
                  | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem], void]
end

# <!-- rdoc-file=error.c -->
# Ruby exception objects are subclasses of Exception.  However, operating
# systems typically report errors using plain integers. Module Errno is created
# dynamically to map these operating system errors to Ruby classes, with each
# error number generating its own subclass of SystemCallError.  As the subclass
# is created in module Errno, its name will start `Errno::`.
#
# The names of the `Errno::` classes depend on the environment in which Ruby
# runs. On a typical Unix or Windows platform, there are Errno classes such as
# Errno::EACCES, Errno::EAGAIN, Errno::EINTR, and so on.
#
# The integer operating system error number corresponding to a particular error
# is available as the class constant `Errno::`*error*`::Errno`.
#
#     Errno::EACCES::Errno   #=> 13
#     Errno::EAGAIN::Errno   #=> 11
#     Errno::EINTR::Errno    #=> 4
#
# The full list of operating system errors on your particular platform are
# available as the constants of Errno.
#
#     Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...
#
module Errno
end

class Errno::E2BIG < SystemCallError
end

Errno::E2BIG::Errno: Integer

class Errno::EACCES < SystemCallError
end

Errno::EACCES::Errno: Integer

class Errno::EADDRINUSE < SystemCallError
end

Errno::EADDRINUSE::Errno: Integer

class Errno::EADDRNOTAVAIL < SystemCallError
end

Errno::EADDRNOTAVAIL::Errno: Integer

class Errno::EADV < SystemCallError
end

Errno::EADV::Errno: Integer

class Errno::EAFNOSUPPORT < SystemCallError
end

Errno::EAFNOSUPPORT::Errno: Integer

class Errno::EAGAIN < SystemCallError
end

Errno::EAGAIN::Errno: Integer

class Errno::EALREADY < SystemCallError
end

Errno::EALREADY::Errno: Integer

class Errno::EAUTH < SystemCallError
end

Errno::EAUTH::Errno: Integer

class Errno::EBADE < SystemCallError
end

Errno::EBADE::Errno: Integer

class Errno::EBADF < SystemCallError
end

Errno::EBADF::Errno: Integer

class Errno::EBADFD < SystemCallError
end

Errno::EBADFD::Errno: Integer

class Errno::EBADMSG < SystemCallError
end

Errno::EBADMSG::Errno: Integer

class Errno::EBADR < SystemCallError
end

Errno::EBADR::Errno: Integer

class Errno::EBADRPC < SystemCallError
end

Errno::EBADRPC::Errno: Integer

class Errno::EBADRQC < SystemCallError
end

Errno::EBADRQC::Errno: Integer

class Errno::EBADSLT < SystemCallError
end

Errno::EBADSLT::Errno: Integer

class Errno::EBFONT < SystemCallError
end

Errno::EBFONT::Errno: Integer

class Errno::EBUSY < SystemCallError
end

Errno::EBUSY::Errno: Integer

class Errno::ECANCELED < SystemCallError
end

Errno::ECANCELED::Errno: Integer

class Errno::ECAPMODE < SystemCallError
end

Errno::ECAPMODE::Errno: Integer

class Errno::ECHILD < SystemCallError
end

Errno::ECHILD::Errno: Integer

class Errno::ECHRNG < SystemCallError
end

Errno::ECHRNG::Errno: Integer

class Errno::ECOMM < SystemCallError
end

Errno::ECOMM::Errno: Integer

# Client sent TCP reset (RST) before server has accepted the connection
# requested by client.
#
class Errno::ECONNABORTED < SystemCallError
end

Errno::ECONNABORTED::Errno: Integer

class Errno::ECONNREFUSED < SystemCallError
end

Errno::ECONNREFUSED::Errno: Integer

# Remote host reset the connection request.
#
class Errno::ECONNRESET < SystemCallError
end

Errno::ECONNRESET::Errno: Integer

class Errno::EDEADLK < SystemCallError
end

Errno::EDEADLK::Errno: Integer

class Errno::EDEADLOCK < SystemCallError
end

Errno::EDEADLOCK::Errno: Integer

class Errno::EDESTADDRREQ < SystemCallError
end

Errno::EDESTADDRREQ::Errno: Integer

class Errno::EDOM < SystemCallError
end

Errno::EDOM::Errno: Integer

class Errno::EDOOFUS < SystemCallError
end

Errno::EDOOFUS::Errno: Integer

class Errno::EDOTDOT < SystemCallError
end

Errno::EDOTDOT::Errno: Integer

class Errno::EDQUOT < SystemCallError
end

Errno::EDQUOT::Errno: Integer

class Errno::EEXIST < SystemCallError
end

Errno::EEXIST::Errno: Integer

class Errno::EFAULT < SystemCallError
end

Errno::EFAULT::Errno: Integer

class Errno::EFBIG < SystemCallError
end

Errno::EFBIG::Errno: Integer

class Errno::EFTYPE < SystemCallError
end

Errno::EFTYPE::Errno: Integer

class Errno::EHOSTDOWN < SystemCallError
end

Errno::EHOSTDOWN::Errno: Integer

class Errno::EHOSTUNREACH < SystemCallError
end

Errno::EHOSTUNREACH::Errno: Integer

class Errno::EHWPOISON < SystemCallError
end

Errno::EHWPOISON::Errno: Integer

class Errno::EIDRM < SystemCallError
end

Errno::EIDRM::Errno: Integer

class Errno::EILSEQ < SystemCallError
end

Errno::EILSEQ::Errno: Integer

class Errno::EINPROGRESS < SystemCallError
end

Errno::EINPROGRESS::Errno: Integer

class Errno::EINTR < SystemCallError
end

Errno::EINTR::Errno: Integer

class Errno::EINVAL < SystemCallError
end

Errno::EINVAL::Errno: Integer

class Errno::EIO < SystemCallError
end

Errno::EIO::Errno: Integer

class Errno::EIPSEC < SystemCallError
end

Errno::EIPSEC::Errno: Integer

class Errno::EISCONN < SystemCallError
end

Errno::EISCONN::Errno: Integer

class Errno::EISDIR < SystemCallError
end

Errno::EISDIR::Errno: Integer

class Errno::EISNAM < SystemCallError
end

Errno::EISNAM::Errno: Integer

class Errno::EKEYEXPIRED < SystemCallError
end

Errno::EKEYEXPIRED::Errno: Integer

class Errno::EKEYREJECTED < SystemCallError
end

Errno::EKEYREJECTED::Errno: Integer

class Errno::EKEYREVOKED < SystemCallError
end

Errno::EKEYREVOKED::Errno: Integer

class Errno::EL2HLT < SystemCallError
end

Errno::EL2HLT::Errno: Integer

class Errno::EL2NSYNC < SystemCallError
end

Errno::EL2NSYNC::Errno: Integer

class Errno::EL3HLT < SystemCallError
end

Errno::EL3HLT::Errno: Integer

class Errno::EL3RST < SystemCallError
end

Errno::EL3RST::Errno: Integer

class Errno::ELIBACC < SystemCallError
end

Errno::ELIBACC::Errno: Integer

class Errno::ELIBBAD < SystemCallError
end

Errno::ELIBBAD::Errno: Integer

class Errno::ELIBEXEC < SystemCallError
end

Errno::ELIBEXEC::Errno: Integer

class Errno::ELIBMAX < SystemCallError
end

Errno::ELIBMAX::Errno: Integer

class Errno::ELIBSCN < SystemCallError
end

Errno::ELIBSCN::Errno: Integer

class Errno::ELNRNG < SystemCallError
end

Errno::ELNRNG::Errno: Integer

class Errno::ELOOP < SystemCallError
end

Errno::ELOOP::Errno: Integer

class Errno::EMEDIUMTYPE < SystemCallError
end

Errno::EMEDIUMTYPE::Errno: Integer

class Errno::EMFILE < SystemCallError
end

Errno::EMFILE::Errno: Integer

class Errno::EMLINK < SystemCallError
end

Errno::EMLINK::Errno: Integer

class Errno::EMSGSIZE < SystemCallError
end

Errno::EMSGSIZE::Errno: Integer

class Errno::EMULTIHOP < SystemCallError
end

Errno::EMULTIHOP::Errno: Integer

class Errno::ENAMETOOLONG < SystemCallError
end

Errno::ENAMETOOLONG::Errno: Integer

class Errno::ENAVAIL < SystemCallError
end

Errno::ENAVAIL::Errno: Integer

class Errno::ENEEDAUTH < SystemCallError
end

Errno::ENEEDAUTH::Errno: Integer

class Errno::ENETDOWN < SystemCallError
end

Errno::ENETDOWN::Errno: Integer

class Errno::ENETRESET < SystemCallError
end

Errno::ENETRESET::Errno: Integer

class Errno::ENETUNREACH < SystemCallError
end

Errno::ENETUNREACH::Errno: Integer

class Errno::ENFILE < SystemCallError
end

Errno::ENFILE::Errno: Integer

class Errno::ENOANO < SystemCallError
end

Errno::ENOANO::Errno: Integer

class Errno::ENOATTR < SystemCallError
end

Errno::ENOATTR::Errno: Integer

class Errno::ENOBUFS < SystemCallError
end

Errno::ENOBUFS::Errno: Integer

class Errno::ENOCSI < SystemCallError
end

Errno::ENOCSI::Errno: Integer

class Errno::ENODATA < SystemCallError
end

Errno::ENODATA::Errno: Integer

class Errno::ENODEV < SystemCallError
end

Errno::ENODEV::Errno: Integer

class Errno::ENOENT < SystemCallError
end

Errno::ENOENT::Errno: Integer

class Errno::ENOEXEC < SystemCallError
end

Errno::ENOEXEC::Errno: Integer

class Errno::ENOKEY < SystemCallError
end

Errno::ENOKEY::Errno: Integer

class Errno::ENOLCK < SystemCallError
end

Errno::ENOLCK::Errno: Integer

class Errno::ENOLINK < SystemCallError
end

Errno::ENOLINK::Errno: Integer

class Errno::ENOMEDIUM < SystemCallError
end

Errno::ENOMEDIUM::Errno: Integer

class Errno::ENOMEM < SystemCallError
end

Errno::ENOMEM::Errno: Integer

class Errno::ENOMSG < SystemCallError
end

Errno::ENOMSG::Errno: Integer

class Errno::ENONET < SystemCallError
end

Errno::ENONET::Errno: Integer

class Errno::ENOPKG < SystemCallError
end

Errno::ENOPKG::Errno: Integer

class Errno::ENOPROTOOPT < SystemCallError
end

Errno::ENOPROTOOPT::Errno: Integer

class Errno::ENOSPC < SystemCallError
end

Errno::ENOSPC::Errno: Integer

class Errno::ENOSR < SystemCallError
end

Errno::ENOSR::Errno: Integer

class Errno::ENOSTR < SystemCallError
end

Errno::ENOSTR::Errno: Integer

class Errno::ENOSYS < SystemCallError
end

Errno::ENOSYS::Errno: Integer

class Errno::ENOTBLK < SystemCallError
end

Errno::ENOTBLK::Errno: Integer

class Errno::ENOTCAPABLE < SystemCallError
end

Errno::ENOTCAPABLE::Errno: Integer

class Errno::ENOTCONN < SystemCallError
end

Errno::ENOTCONN::Errno: Integer

class Errno::ENOTDIR < SystemCallError
end

Errno::ENOTDIR::Errno: Integer

class Errno::ENOTEMPTY < SystemCallError
end

Errno::ENOTEMPTY::Errno: Integer

class Errno::ENOTNAM < SystemCallError
end

Errno::ENOTNAM::Errno: Integer

class Errno::ENOTRECOVERABLE < SystemCallError
end

Errno::ENOTRECOVERABLE::Errno: Integer

class Errno::ENOTSOCK < SystemCallError
end

Errno::ENOTSOCK::Errno: Integer

class Errno::ENOTSUP < SystemCallError
end

Errno::ENOTSUP::Errno: Integer

class Errno::ENOTTY < SystemCallError
end

Errno::ENOTTY::Errno: Integer

class Errno::ENOTUNIQ < SystemCallError
end

Errno::ENOTUNIQ::Errno: Integer

class Errno::ENXIO < SystemCallError
end

Errno::ENXIO::Errno: Integer

class Errno::EOPNOTSUPP < SystemCallError
end

Errno::EOPNOTSUPP::Errno: Integer

class Errno::EOVERFLOW < SystemCallError
end

Errno::EOVERFLOW::Errno: Integer

class Errno::EOWNERDEAD < SystemCallError
end

Errno::EOWNERDEAD::Errno: Integer

class Errno::EPERM < SystemCallError
end

Errno::EPERM::Errno: Integer

class Errno::EPFNOSUPPORT < SystemCallError
end

Errno::EPFNOSUPPORT::Errno: Integer

class Errno::EPIPE < SystemCallError
end

Errno::EPIPE::Errno: Integer

class Errno::EPROCLIM < SystemCallError
end

Errno::EPROCLIM::Errno: Integer

class Errno::EPROCUNAVAIL < SystemCallError
end

Errno::EPROCUNAVAIL::Errno: Integer

class Errno::EPROGMISMATCH < SystemCallError
end

Errno::EPROGMISMATCH::Errno: Integer

class Errno::EPROGUNAVAIL < SystemCallError
end

Errno::EPROGUNAVAIL::Errno: Integer

# Protocol error.
#
class Errno::EPROTO < SystemCallError
end

Errno::EPROTO::Errno: Integer

class Errno::EPROTONOSUPPORT < SystemCallError
end

Errno::EPROTONOSUPPORT::Errno: Integer

class Errno::EPROTOTYPE < SystemCallError
end

Errno::EPROTOTYPE::Errno: Integer

class Errno::ERANGE < SystemCallError
end

Errno::ERANGE::Errno: Integer

class Errno::EREMCHG < SystemCallError
end

Errno::EREMCHG::Errno: Integer

class Errno::EREMOTE < SystemCallError
end

Errno::EREMOTE::Errno: Integer

class Errno::EREMOTEIO < SystemCallError
end

Errno::EREMOTEIO::Errno: Integer

class Errno::ERESTART < SystemCallError
end

Errno::ERESTART::Errno: Integer

class Errno::ERFKILL < SystemCallError
end

Errno::ERFKILL::Errno: Integer

class Errno::EROFS < SystemCallError
end

Errno::EROFS::Errno: Integer

class Errno::ERPCMISMATCH < SystemCallError
end

Errno::ERPCMISMATCH::Errno: Integer

class Errno::ESHUTDOWN < SystemCallError
end

Errno::ESHUTDOWN::Errno: Integer

class Errno::ESOCKTNOSUPPORT < SystemCallError
end

Errno::ESOCKTNOSUPPORT::Errno: Integer

class Errno::ESPIPE < SystemCallError
end

Errno::ESPIPE::Errno: Integer

class Errno::ESRCH < SystemCallError
end

Errno::ESRCH::Errno: Integer

class Errno::ESRMNT < SystemCallError
end

Errno::ESRMNT::Errno: Integer

class Errno::ESTALE < SystemCallError
end

Errno::ESTALE::Errno: Integer

class Errno::ESTRPIPE < SystemCallError
end

Errno::ESTRPIPE::Errno: Integer

class Errno::ETIME < SystemCallError
end

Errno::ETIME::Errno: Integer

class Errno::ETIMEDOUT < SystemCallError
end

Errno::ETIMEDOUT::Errno: Integer

class Errno::ETOOMANYREFS < SystemCallError
end

Errno::ETOOMANYREFS::Errno: Integer

class Errno::ETXTBSY < SystemCallError
end

Errno::ETXTBSY::Errno: Integer

class Errno::EUCLEAN < SystemCallError
end

Errno::EUCLEAN::Errno: Integer

class Errno::EUNATCH < SystemCallError
end

Errno::EUNATCH::Errno: Integer

class Errno::EUSERS < SystemCallError
end

Errno::EUSERS::Errno: Integer

class Errno::EWOULDBLOCK < SystemCallError
end

Errno::EWOULDBLOCK::Errno: Integer

class Errno::EXDEV < SystemCallError
end

Errno::EXDEV::Errno: Integer

class Errno::EXFULL < SystemCallError
end

Errno::EXFULL::Errno: Integer

# <!-- rdoc-file=dir.rb -->
# Objects of class Dir are directory streams representing directories in the
# underlying file system. They provide a variety of ways to list directories and
# their contents. See also File.
#
# The directory used in these examples contains the two regular files
# (`config.h` and `main.rb`), the parent directory (`..`), and the directory
# itself (`.`).
#
# ## What's Here
#
# First, what's elsewhere. Class Dir:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Dir provides methods that are useful for:
#
# *   [Reading](#class-Dir-label-Reading)
# *   [Setting](#class-Dir-label-Setting)
# *   [Querying](#class-Dir-label-Querying)
# *   [Iterating](#class-Dir-label-Iterating)
# *   [Other](#class-Dir-label-Other)
#
#
# ### Reading
#
#     #close
# :       Closes the directory stream for `self`.
#
#     #pos=
# :       Sets the position in the directory stream for `self`.
#
#     #read
# :       Reads and returns the next entry in the directory stream for `self`.
#
#     #rewind
# :       Sets the position in the directory stream for `self` to the first
#         entry.
#
#     #seek
# :       Sets the position in the directory stream for `self` the entry at the
#         given offset.
#
#
#
# ### Setting
#
#     ::chdir
# :       Changes the working directory of the current process to the given
#         directory.
#
#     ::chroot
# :       Changes the file-system root for the current process to the given
#         directory.
#
#
#
# ### Querying
#
#     ::[]
# :       Same as ::glob without the ability to pass flags.
#
#     ::children
# :       Returns an array of names of the children (both files and directories)
#         of the given directory, but not including `.` or `..`.
#
#     ::empty?
# :       Returns whether the given path is an empty directory.
#
#     ::entries
# :       Returns an array of names of the children (both files and directories)
#         of the given directory, including `.` and `..`.
#
#     ::exist?
# :       Returns whether the given path is a directory.
#
#     ::getwd (aliased as #pwd)
# :       Returns the path to the current working directory.
#
#     ::glob
# :       Returns an array of file paths matching the given pattern and flags.
#
#     ::home
# :       Returns the home directory path for a given user or the current user.
#
#     #children
# :       Returns an array of names of the children (both files and directories)
#         of `self`, but not including `.` or `..`.
#
#     #fileno
# :       Returns the integer file descriptor for `self`.
#
#     #path (aliased as #to_path)
# :       Returns the path used to create `self`.
#
#     #tell (aliased as #pos)
# :       Returns the integer position in the directory stream for `self`.
#
#
#
# ### Iterating
#
#     ::each_child
# :       Calls the given block with each entry in the given directory, but not
#         including `.` or `..`.
#
#     ::foreach
# :       Calls the given block with each entryin the given directory, including
#         `.` and `..`.
#
#     #each
# :       Calls the given block with each entry in `self`, including `.` and
#         `..`.
#
#     #each_child
# :       Calls the given block with each entry in `self`, but not including `.`
#         or `..`.
#
#
#
# ### Other
#
#     ::mkdir
# :       Creates a directory at the given path, with optional permissions.
#
#     ::new
# :       Returns a new Dir for the given path, with optional encoding.
#
#     ::open
# :       Same as ::new, but if a block is given, yields the Dir to the block,
#         closing it upon block exit.
#
#     ::unlink (aliased as ::delete and ::rmdir)
# :       Removes the given directory.
#
#     #inspect
# :       Returns a string description of `self`.
#
class Dir
  include Enumerable[String]

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.new( string ) -> aDir
  #   - Dir.new( string, encoding: enc ) -> aDir
  # -->
  # Returns a new directory object for the named directory.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  def initialize: (string, ?encoding: encoding | nil) -> void

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir[ string [, string ...] [, base: path] [, sort: true] ] -> array
  # -->
  # Equivalent to calling `Dir.glob([`*string,...*`], 0)`.
  #
  def self.[]: (*string patterns, ?base: string) ?{ (String path) -> void } -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chdir( [ string] ) -> 0
  #   - Dir.chdir( [ string] ) {| path | block }  -> anObject
  # -->
  # Changes the current working directory of the process to the given string. When
  # called without an argument, changes the directory to the value of the
  # environment variable `HOME`, or `LOGDIR`. SystemCallError (probably
  # Errno::ENOENT) if the target directory does not exist.
  #
  # If a block is given, it is passed the name of the new current directory, and
  # the block is executed with that as the current directory. The original working
  # directory is restored when the block exits. The return value of `chdir` is the
  # value of the block. `chdir` blocks can be nested, but in a multi-threaded
  # program an error will be raised if a thread attempts to open a `chdir` block
  # while another thread has one open or a call to `chdir` without a block occurs
  # inside a block passed to `chdir` (even in the same thread).
  #
  #     Dir.chdir("/var/spool/mail")
  #     puts Dir.pwd
  #     Dir.chdir("/tmp") do
  #       puts Dir.pwd
  #       Dir.chdir("/usr") do
  #         puts Dir.pwd
  #       end
  #       puts Dir.pwd
  #     end
  #     puts Dir.pwd
  #
  # *produces:*
  #
  #     /var/spool/mail
  #     /tmp
  #     /usr
  #     /tmp
  #     /var/spool/mail
  #
  def self.chdir: (?string) -> void
                | [U] (?string) { (String) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.children( dirname )                -> array
  #   - Dir.children( dirname, encoding: enc ) -> array
  # -->
  # Returns an array containing all of the filenames except for "." and ".." in
  # the given directory. Will raise a SystemCallError if the named directory
  # doesn't exist.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  #     Dir.children("testdir")   #=> ["config.h", "main.rb"]
  #
  def self.children: (string dirname, ?encoding: string | Encoding | nil enc) -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.chroot( string ) -> 0
  # -->
  # Changes this process's idea of the file system root. Only a privileged process
  # may make this call. Not available on all platforms. On Unix systems, see
  # `chroot(2)` for more information.
  #
  def self.chroot: (string) -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  def self.delete: (string) -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.each_child( dirname ) {| filename | block }                 -> nil
  #   - Dir.each_child( dirname, encoding: enc ) {| filename | block }  -> nil
  #   - Dir.each_child( dirname )                                       -> an_enumerator
  #   - Dir.each_child( dirname, encoding: enc )                        -> an_enumerator
  # -->
  # Calls the block once for each entry except for "." and ".." in the named
  # directory, passing the filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     Dir.each_child("testdir") {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got config.h
  #     Got main.rb
  #
  def self.each_child: (string dirname, ?encoding: string | Encoding | nil enc) -> Enumerator[String, void]
                     | (string dirname, ?encoding: string | Encoding | nil enc) { (String filename) -> void } -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.empty?(path_name)  ->  true or false
  # -->
  # Returns `true` if the named file is an empty directory, `false` if it is not a
  # directory or non-empty.
  #
  def self.empty?: (string path_name) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.entries( dirname )                -> array
  #   - Dir.entries( dirname, encoding: enc ) -> array
  # -->
  # Returns an array containing all of the filenames in the given directory. Will
  # raise a SystemCallError if the named directory doesn't exist.
  #
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  #     Dir.entries("testdir")   #=> [".", "..", "config.h", "main.rb"]
  #
  def self.entries: (string dirname, ?encoding: encoding | nil enc) -> ::Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.exist?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, `false` otherwise.
  #
  def self.exist?: (string file) -> bool

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.foreach( dirname ) {| filename | block }                 -> nil
  #   - Dir.foreach( dirname, encoding: enc ) {| filename | block }  -> nil
  #   - Dir.foreach( dirname )                                       -> an_enumerator
  #   - Dir.foreach( dirname, encoding: enc )                        -> an_enumerator
  # -->
  # Calls the block once for each entry in the named directory, passing the
  # filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     Dir.foreach("testdir") {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got .
  #     Got ..
  #     Got config.h
  #     Got main.rb
  #
  alias self.foreach self.each_child

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.getwd -> string
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory of this process as a string.
  #
  #     Dir.chdir("/tmp")   #=> 0
  #     Dir.getwd           #=> "/tmp"
  #     Dir.pwd             #=> "/tmp"
  #
  def self.getwd: () -> String

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.glob( pattern, [flags], [base: path] [, sort: true] )                       -> array
  #   - Dir.glob( pattern, [flags], [base: path] [, sort: true] ) { |filename| block }  -> nil
  # -->
  # Expands `pattern`, which is a pattern string or an Array of pattern strings,
  # and returns an array containing the matching filenames. If a block is given,
  # calls the block once for each matching filename, passing the filename as a
  # parameter to the block.
  #
  # The optional `base` keyword argument specifies the base directory for
  # interpreting relative pathnames instead of the current working directory. As
  # the results are not prefixed with the base directory name in this case, you
  # will need to prepend the base directory name if you want real paths.
  #
  # The results which matched single wildcard or character set are sorted in
  # binary ascending order, unless `false` is given as the optional `sort` keyword
  # argument.  The order of an Array of pattern strings and braces are preserved.
  #
  # Note that the pattern is not a regexp, it's closer to a shell glob. See
  # File::fnmatch for the meaning of the `flags` parameter. Case sensitivity
  # depends on your system (`File::FNM_CASEFOLD` is ignored).
  #
  # `*`
  # :   Matches any file. Can be restricted by other values in the glob.
  #     Equivalent to `/.*/mx` in regexp.
  #
  #     `*`
  # :       Matches all files
  #     `c*`
  # :       Matches all files beginning with `c`
  #     `*c`
  # :       Matches all files ending with `c`
  #     `*c*`
  # :       Match all files that have `c` in them (including at the beginning or
  #         end).
  #
  #
  #     Note, this will not match Unix-like hidden files (dotfiles).  In order to
  #     include those in the match results, you must use the File::FNM_DOTMATCH
  #     flag or something like `"{*,.*}"`.
  #
  # `**`
  # :   Matches directories recursively if followed by `/`.  If this path segment
  #     contains any other characters, it is the same as the usual `*`.
  #
  # `?`
  # :   Matches any one character. Equivalent to `/.{1}/` in regexp.
  #
  # `[set]`
  # :   Matches any one character in `set`.  Behaves exactly like character sets
  #     in Regexp, including set negation (`[^a-z]`).
  #
  # `{p,q}`
  # :   Matches either literal `p` or literal `q`. Equivalent to pattern
  #     alternation in regexp.
  #
  #     Matching literals may be more than one character in length.  More than two
  #     literals may be specified.
  #
  # `\`
  # :   Escapes the next metacharacter.
  #
  #     Note that this means you cannot use backslash on windows as part of a
  #     glob, i.e.  `Dir["c:\\foo*"]` will not work, use `Dir["c:/foo*"]` instead.
  #
  #
  # Examples:
  #
  #     Dir["config.?"]                     #=> ["config.h"]
  #     Dir.glob("config.?")                #=> ["config.h"]
  #     Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]
  #     Dir.glob("*.[^r]*")                 #=> ["config.h"]
  #     Dir.glob("*.{rb,h}")                #=> ["main.rb", "config.h"]
  #     Dir.glob("*")                       #=> ["config.h", "main.rb"]
  #     Dir.glob("*", File::FNM_DOTMATCH)   #=> [".", "..", "config.h", "main.rb"]
  #     Dir.glob(["*.rb", "*.h"])           #=> ["main.rb", "config.h"]
  #
  #     Dir.glob("**/*.rb")                 #=> ["main.rb",
  #                                         #    "lib/song.rb",
  #                                         #    "lib/song/karaoke.rb"]
  #
  #     Dir.glob("**/*.rb", base: "lib")    #=> ["song.rb",
  #                                         #    "song/karaoke.rb"]
  #
  #     Dir.glob("**/lib")                  #=> ["lib"]
  #
  #     Dir.glob("**/lib/**/*.rb")          #=> ["lib/song.rb",
  #                                         #    "lib/song/karaoke.rb"]
  #
  #     Dir.glob("**/lib/*.rb")             #=> ["lib/song.rb"]
  #
  def self.glob: (string | ::Array[string] pattern, ?Integer flags, ?base: string) -> ::Array[String]
               | (string | ::Array[string] pattern, ?Integer flags, ?base: string) { (String) -> void } -> void

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.home()       -> "/home/me"
  #   - Dir.home("root") -> "/root"
  # -->
  # Returns the home directory of the current user or the named user if given.
  #
  def self.home: (?string user) -> String

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.mkdir( string [, integer] ) -> 0
  # -->
  # Makes a new directory named by *string*, with permissions specified by the
  # optional parameter *anInteger*. The permissions may be modified by the value
  # of File::umask, and are ignored on NT. Raises a SystemCallError if the
  # directory cannot be created. See also the discussion of permissions in the
  # class documentation for File.
  #
  #     Dir.mkdir(File.join(Dir.home, ".foo"), 0700) #=> 0
  #
  def self.mkdir: (string, ?Integer permissions) -> void

  # <!--
  #   rdoc-file=dir.rb
  #   - Dir.open( string ) -> aDir
  #   - Dir.open( string, encoding: enc ) -> aDir
  #   - Dir.open( string ) {| aDir | block } -> anObject
  #   - Dir.open( string, encoding: enc ) {| aDir | block } -> anObject
  # -->
  # The optional *encoding* keyword argument specifies the encoding of the
  # directory. If not specified, the filesystem encoding is used.
  #
  # With no block, `open` is a synonym for Dir::new. If a block is present, it is
  # passed *aDir* as a parameter. The directory is closed at the end of the block,
  # and Dir::open returns the value of the block.
  #
  def self.open: (string, ?encoding: encoding | nil) -> Dir
               | [U] (string, ?encoding: encoding | nil) { (Dir) -> U } -> U

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.getwd -> string
  #   - Dir.pwd -> string
  # -->
  # Returns the path to the current working directory of this process as a string.
  #
  #     Dir.chdir("/tmp")   #=> 0
  #     Dir.getwd           #=> "/tmp"
  #     Dir.pwd             #=> "/tmp"
  #
  def self.pwd: () -> String

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  alias self.rmdir self.delete

  # <!--
  #   rdoc-file=dir.c
  #   - Dir.delete( string ) -> 0
  #   - Dir.rmdir( string ) -> 0
  #   - Dir.unlink( string ) -> 0
  # -->
  # Deletes the named directory. Raises a subclass of SystemCallError if the
  # directory isn't empty.
  #
  alias self.unlink self.delete

  public

  # <!--
  #   rdoc-file=dir.c
  #   - dir.children  -> array
  # -->
  # Returns an array containing all of the filenames except for "." and ".." in
  # this directory.
  #
  #     d = Dir.new("testdir")
  #     d.children   #=> ["config.h", "main.rb"]
  #
  def children: () -> Array[String]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.close -> nil
  # -->
  # Closes the directory stream. Calling this method on closed Dir object is
  # ignored since Ruby 2.3.
  #
  #     d = Dir.new("testdir")
  #     d.close   #=> nil
  #
  def close: () -> void

  # <!--
  #   rdoc-file=dir.c
  #   - dir.each { |filename| block }  -> dir
  #   - dir.each                       -> an_enumerator
  # -->
  # Calls the block once for each entry in this directory, passing the filename of
  # each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     d = Dir.new("testdir")
  #     d.each  {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got .
  #     Got ..
  #     Got config.h
  #     Got main.rb
  #
  def each: () { (String) -> void } -> self
          | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.each_child {| filename | block }  -> dir
  #   - dir.each_child                        -> an_enumerator
  # -->
  # Calls the block once for each entry except for "." and ".." in this directory,
  # passing the filename of each entry as a parameter to the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     d = Dir.new("testdir")
  #     d.each_child  {|x| puts "Got #{x}" }
  #
  # *produces:*
  #
  #     Got config.h
  #     Got main.rb
  #
  def each_child: () { (String) -> void } -> self
                | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=dir.c
  #   - dir.fileno -> integer
  # -->
  # Returns the file descriptor used in *dir*.
  #
  #     d = Dir.new("..")
  #     d.fileno   #=> 8
  #
  # This method uses dirfd() function defined by POSIX 2008. NotImplementedError
  # is raised on other platforms, such as Windows, which doesn't provide the
  # function.
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.inspect -> string
  # -->
  # Return a string describing this Dir object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=dir.c
  #   - dir.path -> string or nil
  #   - dir.to_path -> string or nil
  # -->
  # Returns the path parameter passed to *dir*'s constructor.
  #
  #     d = Dir.new("..")
  #     d.path   #=> ".."
  #
  def path: () -> String?

  # <!-- rdoc-file=dir.c -->
  # Returns the current position in *dir*. See also Dir#seek.
  #
  #     d = Dir.new("testdir")
  #     d.tell   #=> 0
  #     d.read   #=> "."
  #     d.tell   #=> 12
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.pos = integer  -> integer
  # -->
  # Synonym for Dir#seek, but returns the position parameter.
  #
  #     d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
  #     d.read                   #=> "."
  #     i = d.pos                #=> 12
  #     d.read                   #=> ".."
  #     d.pos = i                #=> 12
  #     d.read                   #=> ".."
  #
  def pos=: (Integer pos) -> Integer

  # <!--
  #   rdoc-file=dir.c
  #   - dir.read -> string or nil
  # -->
  # Reads the next entry from *dir* and returns it as a string. Returns `nil` at
  # the end of the stream.
  #
  #     d = Dir.new("testdir")
  #     d.read   #=> "."
  #     d.read   #=> ".."
  #     d.read   #=> "config.h"
  #
  def read: () -> String?

  # <!--
  #   rdoc-file=dir.c
  #   - dir.rewind -> dir
  # -->
  # Repositions *dir* to the first entry.
  #
  #     d = Dir.new("testdir")
  #     d.read     #=> "."
  #     d.rewind   #=> #<Dir:0x401b3fb0>
  #     d.read     #=> "."
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=dir.c
  #   - dir.seek( integer ) -> dir
  # -->
  # Seeks to a particular location in *dir*. *integer* must be a value returned by
  # Dir#tell.
  #
  #     d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
  #     d.read                   #=> "."
  #     i = d.tell               #=> 12
  #     d.read                   #=> ".."
  #     d.seek(i)                #=> #<Dir:0x401b3c40>
  #     d.read                   #=> ".."
  #
  def seek: (Integer) -> self

  # <!--
  #   rdoc-file=dir.c
  #   - dir.pos -> integer
  #   - dir.tell -> integer
  # -->
  # Returns the current position in *dir*. See also Dir#seek.
  #
  #     d = Dir.new("testdir")
  #     d.tell   #=> 0
  #     d.read   #=> "."
  #     d.tell   #=> 12
  #
  def tell: () -> Integer

  # <!-- rdoc-file=dir.c -->
  # Returns the path parameter passed to *dir*'s constructor.
  #
  #     d = Dir.new("..")
  #     d.path   #=> ".."
  #
  alias to_path path
end

# <!-- rdoc-file=object.c -->
# A Module is a collection of methods and constants. The methods in a module may
# be instance methods or module methods. Instance methods appear as methods in a
# class when the module is included, module methods do not. Conversely, module
# methods may be called without creating an encapsulating object, while instance
# methods may not. (See Module#module_function.)
#
# In the descriptions that follow, the parameter *sym* refers to a symbol, which
# is either a quoted string or a Symbol (such as `:name`).
#
#     module Mod
#       include Math
#       CONST = 1
#       def meth
#         #  ...
#       end
#     end
#     Mod.class              #=> Module
#     Mod.constants          #=> [:CONST, :PI, :E]
#     Mod.instance_methods   #=> [:meth]
#
class Module < Object
  # <!--
  #   rdoc-file=eval.c
  #   - Module.constants   -> array
  #   - Module.constants(inherited)   -> array
  # -->
  # In the first form, returns an array of the names of all constants accessible
  # from the point of call. This list includes the names of all modules and
  # classes defined in the global scope.
  #
  #     Module.constants.first(4)
  #        # => [:ARGF, :ARGV, :ArgumentError, :Array]
  #
  #     Module.constants.include?(:SEEK_SET)   # => false
  #
  #     class IO
  #       Module.constants.include?(:SEEK_SET) # => true
  #     end
  #
  # The second form calls the instance method `constants`.
  #
  def self.constants: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=eval.c
  #   - Module.nesting    -> array
  # -->
  # Returns the list of `Modules` nested at the point of call.
  #
  #     module M1
  #       module M2
  #         $a = Module.nesting
  #       end
  #     end
  #     $a           #=> [M1::M2, M1]
  #     $a[0].name   #=> "M1::M2"
  #
  def self.nesting: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - used_modules -> array
  # -->
  # Returns an array of all modules used in the current scope. The ordering of
  # modules in the resulting array is not defined.
  #
  #     module A
  #       refine Object do
  #       end
  #     end
  #
  #     module B
  #       refine Object do
  #       end
  #     end
  #
  #     using A
  #     using B
  #     p Module.used_modules
  #
  # *produces:*
  #
  #     [B, A]
  #
  def self.used_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=object.c
  #   - mod < other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other*. Returns `nil` if there's no
  # relationship between the two. (Think of the relationship in terms of the class
  # definition: "class A < B" implies "A < B".)
  #
  def <: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod <= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is a subclass of *other* or is the same as *other*.
  # Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "A < B".)
  #
  def <=: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - module <=> other_module   -> -1, 0, +1, or nil
  # -->
  # Comparison---Returns -1, 0, +1 or nil depending on whether `module` includes
  # `other_module`, they are the same, or if `module` is included by
  # `other_module`.
  #
  # Returns `nil` if `module` has no relationship with `other_module`, if
  # `other_module` is not a module, or if the two values are incomparable.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod === obj    -> true or false
  # -->
  # Case Equality---Returns `true` if *obj* is an instance of *mod* or an instance
  # of one of *mod*'s descendants. Of limited use for modules, but can be used in
  # `case` statements to classify objects by class.
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod > other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*. Returns `nil` if there's no
  # relationship between the two. (Think of the relationship in terms of the class
  # definition: "class A < B" implies "B > A".)
  #
  def >: (Module other) -> bool?

  # <!--
  #   rdoc-file=object.c
  #   - mod >= other   ->  true, false, or nil
  # -->
  # Returns true if *mod* is an ancestor of *other*, or the two modules are the
  # same. Returns `nil` if there's no relationship between the two. (Think of the
  # relationship in terms of the class definition: "class A < B" implies "B > A".)
  #
  def >=: (Module other) -> bool?

  # <!--
  #   rdoc-file=vm_method.c
  #   - alias_method(new_name, old_name)   -> symbol
  # -->
  # Makes *new_name* a new copy of the method *old_name*. This can be used to
  # retain access to methods that are overridden.
  #
  #     module Mod
  #       alias_method :orig_exit, :exit #=> :orig_exit
  #       def exit(code=0)
  #         puts "Exiting with code #{code}"
  #         orig_exit(code)
  #       end
  #     end
  #     include Mod
  #     exit(99)
  #
  # *produces:*
  #
  #     Exiting with code 99
  #
  def alias_method: (::Symbol | ::String new_name, ::Symbol | ::String old_name) -> ::Symbol

  # <!--
  #   rdoc-file=object.c
  #   - mod.ancestors -> array
  # -->
  # Returns a list of modules included/prepended in *mod* (including *mod*
  # itself).
  #
  #     module Mod
  #       include Math
  #       include Comparable
  #       prepend Enumerable
  #     end
  #
  #     Mod.ancestors        #=> [Enumerable, Mod, Comparable, Math]
  #     Math.ancestors       #=> [Math]
  #     Enumerable.ancestors #=> [Enumerable]
  #
  def ancestors: () -> ::Array[Module]

  # <!--
  #   rdoc-file=eval.c
  #   - append_features(mod)   -> mod
  # -->
  # When this module is included in another, Ruby calls #append_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to add the constants, methods, and module variables of this
  # module to *mod* if this module has not already been added to *mod* or one of
  # its ancestors. See also Module#include.
  #
  def append_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - attr_accessor(symbol, ...)    -> array
  #   - attr_accessor(string, ...)    -> array
  # -->
  # Defines a named attribute for this module, where the name is
  # *symbol.*`id2name`, creating an instance variable (`@name`) and a
  # corresponding access method to read it. Also creates a method called `name=`
  # to set the attribute. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  #     module Mod
  #       attr_accessor(:one, :two) #=> [:one, :one=, :two, :two=]
  #     end
  #     Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]
  #
  def attr_accessor: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=object.c
  #   - attr_reader(symbol, ...)  -> array
  #   - attr(symbol, ...)         -> array
  #   - attr_reader(string, ...)  -> array
  #   - attr(string, ...)         -> array
  # -->
  # Creates instance variables and corresponding methods that return the value of
  # each instance variable. Equivalent to calling ```attr`*:name*'' on each name
  # in turn. String arguments are converted to symbols. Returns an array of
  # defined method names as symbols.
  #
  def attr_reader: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=object.c
  #   - attr_writer(symbol, ...)    -> array
  #   - attr_writer(string, ...)    -> array
  # -->
  # Creates an accessor method to allow assignment to the attribute
  # *symbol*`.id2name`. String arguments are converted to symbols. Returns an
  # array of defined method names as symbols.
  #
  def attr_writer: (*Symbol | String arg0) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload(module, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *module* (which may be a String or a symbol) is accessed in the namespace of
  # *mod*.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A::B.doit            # autoloads "b"
  #
  def autoload: (Symbol _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - mod.autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload` in the
  # namespace of *mod* or one of its ancestors.
  #
  #     module A
  #     end
  #     A.autoload(:B, "b")
  #     A.autoload?(:B)            #=> "b"
  #
  # If `inherit` is false, the lookup only checks the autoloads in the receiver:
  #
  #     class A
  #       autoload :CONST, "const.rb"
  #     end
  #
  #     class B < A
  #     end
  #
  #     B.autoload?(:CONST)          #=> "const.rb", found in A (ancestor)
  #     B.autoload?(:CONST, false)   #=> nil, not found in B itself
  #
  def autoload?: (Symbol name, ?boolish inherit) -> String?

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def class_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                | [U] () { (self m) -> U } -> U

  # <!-- rdoc-file=vm_eval.c -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def class_exec: (*untyped args) { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_defined?(symbol)    -> true or false
  #   - obj.class_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given class variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_defined?(:@@foo)    #=> true
  #     Fred.class_variable_defined?(:@@bar)    #=> false
  #
  def class_variable_defined?: (Symbol | String arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variable_get(symbol)    -> obj
  #   - mod.class_variable_get(string)    -> obj
  # -->
  # Returns the value of the given class variable (or throws a NameError
  # exception). The `@@` part of the variable name should be included for regular
  # class variables. String arguments are converted to symbols.
  #
  #     class Fred
  #       @@foo = 99
  #     end
  #     Fred.class_variable_get(:@@foo)     #=> 99
  #
  def class_variable_get: (Symbol | String arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.class_variable_set(symbol, obj)    -> obj
  #   - obj.class_variable_set(string, obj)    -> obj
  # -->
  # Sets the class variable named by *symbol* to the given object. If the class
  # variable name is passed as a string, that string is converted to a symbol.
  #
  #     class Fred
  #       @@foo = 99
  #       def foo
  #         @@foo
  #       end
  #     end
  #     Fred.class_variable_set(:@@foo, 101)     #=> 101
  #     Fred.new.foo                             #=> 101
  #
  def class_variable_set: (Symbol | String arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.class_variables(inherit=true)    -> array
  # -->
  # Returns an array of the names of class variables in *mod*. This includes the
  # names of class variables in any included modules, unless the *inherit*
  # parameter is set to `false`.
  #
  #     class One
  #       @@var1 = 1
  #     end
  #     class Two < One
  #       @@var2 = 2
  #     end
  #     One.class_variables          #=> [:@@var1]
  #     Two.class_variables          #=> [:@@var2, :@@var1]
  #     Two.class_variables(false)   #=> [:@@var2]
  #
  def class_variables: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_defined?(sym, inherit=true)   -> true or false
  #   - mod.const_defined?(str, inherit=true)   -> true or false
  # -->
  # Says whether *mod* or its ancestors have a constant with the given name:
  #
  #     Float.const_defined?(:EPSILON)      #=> true, found in Float itself
  #     Float.const_defined?("String")      #=> true, found in Object (ancestor)
  #     BasicObject.const_defined?(:Hash)   #=> false
  #
  # If *mod* is a `Module`, additionally `Object` and its ancestors are checked:
  #
  #     Math.const_defined?(:String)   #=> true, found in Object
  #
  # In each of the checked classes or modules, if the constant is not present but
  # there is an autoload for it, `true` is returned directly without autoloading:
  #
  #     module Admin
  #       autoload :User, 'admin/user'
  #     end
  #     Admin.const_defined?(:User)   #=> true
  #
  # If the constant is not found the callback `const_missing` is **not** called
  # and the method returns `false`.
  #
  # If `inherit` is false, the lookup only checks the constants in the receiver:
  #
  #     IO.const_defined?(:SYNC)          #=> true, found in File::Constants (ancestor)
  #     IO.const_defined?(:SYNC, false)   #=> false, not found in IO itself
  #
  # In this case, the same logic for autoloading applies.
  #
  # If the argument is not a valid constant name a `NameError` is raised with the
  # message "wrong constant name *name*":
  #
  #     Hash.const_defined? 'foobar'   #=> NameError: wrong constant name foobar
  #
  def const_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_get(sym, inherit=true)    -> obj
  #   - mod.const_get(str, inherit=true)    -> obj
  # -->
  # Checks for a constant with the given name in *mod*. If `inherit` is set, the
  # lookup will also search the ancestors (and `Object` if *mod* is a `Module`).
  #
  # The value of the constant is returned if a definition is found, otherwise a
  # `NameError` is raised.
  #
  #     Math.const_get(:PI)   #=> 3.14159265358979
  #
  # This method will recursively look up constant names if a namespaced class name
  # is provided.  For example:
  #
  #     module Foo; class Bar; end end
  #     Object.const_get 'Foo::Bar'
  #
  # The `inherit` flag is respected on each lookup.  For example:
  #
  #     module Foo
  #       class Bar
  #         VAL = 10
  #       end
  #
  #       class Baz < Bar; end
  #     end
  #
  #     Object.const_get 'Foo::Baz::VAL'         # => 10
  #     Object.const_get 'Foo::Baz::VAL', false  # => NameError
  #
  # If the argument is not a valid constant name a `NameError` will be raised with
  # a warning "wrong constant name".
  #
  #     Object.const_get 'foobar' #=> NameError: wrong constant name foobar
  #
  def const_get: (Symbol | String name, ?boolish inherit) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_missing(sym)    -> obj
  # -->
  # Invoked when a reference is made to an undefined constant in *mod*. It is
  # passed a symbol for the undefined constant, and returns a value to be used for
  # that constant. The following code is an example of the same:
  #
  #     def Foo.const_missing(name)
  #       name # return the constant name as Symbol
  #     end
  #
  #     Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned
  #
  # In the next example when a reference is made to an undefined constant, it
  # attempts to load a file whose name is the lowercase version of the constant
  # (thus class `Fred` is assumed to be in file `fred.rb`).  If found, it returns
  # the loaded class. It therefore implements an autoload feature similar to
  # Kernel#autoload and Module#autoload.
  #
  #     def Object.const_missing(name)
  #       @looked_for ||= {}
  #       str_name = name.to_s
  #       raise "Class not found: #{name}" if @looked_for[str_name]
  #       @looked_for[str_name] = 1
  #       file = str_name.downcase
  #       require file
  #       klass = const_get(name)
  #       return klass if klass
  #       raise "Class not found: #{name}"
  #     end
  #
  def const_missing: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_set(sym, obj)    -> obj
  #   - mod.const_set(str, obj)    -> obj
  # -->
  # Sets the named constant to the given object, returning that object. Creates a
  # new constant if no constant with the given name previously existed.
  #
  #     Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714
  #     Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968
  #
  # If `sym` or `str` is not a valid constant name a `NameError` will be raised
  # with a warning "wrong constant name".
  #
  #     Object.const_set('foobar', 42) #=> NameError: wrong constant name foobar
  #
  def const_set: (Symbol | String arg0, untyped arg1) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.const_source_location(sym, inherit=true)   -> [String, Integer]
  #   - mod.const_source_location(str, inherit=true)   -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing the definition of
  # the constant specified. If the named constant is not found, `nil` is returned.
  # If the constant is found, but its source location can not be extracted
  # (constant is defined in C code), empty array is returned.
  #
  # *inherit* specifies whether to lookup in `mod.ancestors` (`true` by default).
  #
  #     # test.rb:
  #     class A         # line 1
  #       C1 = 1
  #       C2 = 2
  #     end
  #
  #     module M        # line 6
  #       C3 = 3
  #     end
  #
  #     class B < A     # line 10
  #       include M
  #       C4 = 4
  #     end
  #
  #     class A # continuation of A definition
  #       C2 = 8 # constant redefinition; warned yet allowed
  #     end
  #
  #     p B.const_source_location('C4')           # => ["test.rb", 12]
  #     p B.const_source_location('C3')           # => ["test.rb", 7]
  #     p B.const_source_location('C1')           # => ["test.rb", 2]
  #
  #     p B.const_source_location('C3', false)    # => nil  -- don't lookup in ancestors
  #
  #     p A.const_source_location('C2')           # => ["test.rb", 16] -- actual (last) definition place
  #
  #     p Object.const_source_location('B')       # => ["test.rb", 10] -- top-level constant could be looked through Object
  #     p Object.const_source_location('A')       # => ["test.rb", 1] -- class reopening is NOT considered new definition
  #
  #     p B.const_source_location('A')            # => ["test.rb", 1]  -- because Object is in ancestors
  #     p M.const_source_location('A')            # => ["test.rb", 1]  -- Object is not ancestor, but additionally checked for modules
  #
  #     p Object.const_source_location('A::C1')   # => ["test.rb", 2]  -- nesting is supported
  #     p Object.const_source_location('String')  # => []  -- constant is defined in C code
  #
  def const_source_location: (Symbol | String name, ?boolish inherit) -> ([ String, Integer ] | [ ] | nil)

  # <!--
  #   rdoc-file=object.c
  #   - mod.constants(inherit=true)    -> array
  # -->
  # Returns an array of the names of the constants accessible in *mod*. This
  # includes the names of constants in any included modules (example at start of
  # section), unless the *inherit* parameter is set to `false`.
  #
  # The implementation makes no guarantees about the order in which the constants
  # are yielded.
  #
  #     IO.constants.include?(:SYNC)        #=> true
  #     IO.constants(false).include?(:SYNC) #=> false
  #
  # Also see Module#const_defined?.
  #
  def constants: (?boolish inherit) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - define_method(symbol, method)     -> symbol
  #   - define_method(symbol) { block }   -> symbol
  # -->
  # Defines an instance method in the receiver. The *method* parameter can be a
  # `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
  # is used as the method body. If a block or the *method* parameter has
  # parameters, they're used as method parameters. This block is evaluated using
  # #instance_eval.
  #
  #     class A
  #       def fred
  #         puts "In Fred"
  #       end
  #       def create_method(name, &block)
  #         self.class.define_method(name, &block)
  #       end
  #       define_method(:wilma) { puts "Charge it!" }
  #       define_method(:flint) {|name| puts "I'm #{name}!"}
  #     end
  #     class B < A
  #       define_method(:barney, instance_method(:fred))
  #     end
  #     a = B.new
  #     a.barney
  #     a.wilma
  #     a.flint('Dino')
  #     a.create_method(:betty) { p self }
  #     a.betty
  #
  # *produces:*
  #
  #     In Fred
  #     Charge it!
  #     I'm Dino!
  #     #<B:0x401b39e8>
  #
  def define_method: (Symbol | String arg0, ?Proc | Method | UnboundMethod arg1) -> Symbol
                   | (Symbol | String arg0) { () -> untyped } -> Symbol

  def eql?: (untyped other) -> bool

  def equal?: (untyped other) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - extend_object(obj)    -> obj
  # -->
  # Extends the specified object by adding this module's constants and methods
  # (which are added as singleton methods). This is the callback method used by
  # Object#extend.
  #
  #     module Picky
  #       def Picky.extend_object(o)
  #         if String === o
  #           puts "Can't add Picky to a String"
  #         else
  #           puts "Picky added to #{o.class}"
  #           super
  #         end
  #       end
  #     end
  #     (s = Array.new).extend Picky  # Call Object.extend
  #     (s = "quick brown fox").extend Picky
  #
  # *produces:*
  #
  #     Picky added to Array
  #     Can't add Picky to a String
  #
  def extend_object: (untyped arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - extended(othermod)
  # -->
  # The equivalent of `included`, but for extended modules.
  #
  #     module A
  #       def self.extended(mod)
  #         puts "#{self} extended in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       extend A
  #     end
  #      # => prints "A extended in Enumerable"
  #
  def extended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.freeze       -> mod
  # -->
  # Prevents further modifications to *mod*.
  #
  # This method returns self.
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=eval.c
  #   - include(module, ...)    -> self
  # -->
  # Invokes Module.append_features on each parameter in reverse order.
  #
  def include: (*Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.include?(module)    -> true or false
  # -->
  # Returns `true` if *module* is included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module A
  #     end
  #     class B
  #       include A
  #     end
  #     class C < B
  #     end
  #     B.include?(A)   #=> true
  #     C.include?(A)   #=> true
  #     A.include?(A)   #=> false
  #
  def include?: (Module arg0) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - included(othermod)
  # -->
  # Callback invoked whenever the receiver is included in another module or class.
  # This should be used in preference to `Module.append_features` if your code
  # wants to perform some action when a module is included in another.
  #
  #     module A
  #       def A.included(mod)
  #         puts "#{self} included in #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       include A
  #     end
  #      # => prints "A included in Enumerable"
  #
  def included: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - mod.included_modules -> array
  # -->
  # Returns the list of modules included or prepended in *mod* or one of *mod*'s
  # ancestors.
  #
  #     module Sub
  #     end
  #
  #     module Mixin
  #       prepend Sub
  #     end
  #
  #     module Outer
  #       include Mixin
  #     end
  #
  #     Mixin.included_modules   #=> [Sub]
  #     Outer.included_modules   #=> [Sub, Mixin]
  #
  def included_modules: () -> ::Array[Module]

  # <!--
  #   rdoc-file=object.c
  #   - Module.new                  -> mod
  #   - Module.new {|mod| block }   -> mod
  # -->
  # Creates a new anonymous module. If a block is given, it is passed the module
  # object, and the block is evaluated in the context of this module like
  # #module_eval.
  #
  #     fred = Module.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #     a = "my string"
  #     a.extend(fred)   #=> "my string"
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the module to a constant (name starting uppercase) if you want to treat
  # it like a regular module.
  #
  def initialize: () -> Object
                | () { (Module arg0) -> untyped } -> void

  # <!--
  #   rdoc-file=proc.c
  #   - mod.instance_method(symbol)   -> unbound_method
  # -->
  # Returns an `UnboundMethod` representing the given instance method in *mod*.
  #
  #     class Interpreter
  #       def do_a() print "there, "; end
  #       def do_d() print "Hello ";  end
  #       def do_e() print "!\n";     end
  #       def do_v() print "Dave";    end
  #       Dispatcher = {
  #         "a" => instance_method(:do_a),
  #         "d" => instance_method(:do_d),
  #         "e" => instance_method(:do_e),
  #         "v" => instance_method(:do_v)
  #       }
  #       def interpret(string)
  #         string.each_char {|b| Dispatcher[b].bind(self).call }
  #       end
  #     end
  #
  #     interpreter = Interpreter.new
  #     interpreter.interpret('dave')
  #
  # *produces:*
  #
  #     Hello there, Dave!
  #
  def instance_method: (Symbol arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.instance_methods(include_super=true)   -> array
  # -->
  # Returns an array containing the names of the public and protected instance
  # methods in the receiver. For a module, these are the public and protected
  # methods; for a class, they are the instance (not singleton) methods. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       include A
  #       def method2()  end
  #     end
  #     class C < B
  #       def method3()  end
  #     end
  #
  #     A.instance_methods(false)                   #=> [:method1]
  #     B.instance_methods(false)                   #=> [:method2]
  #     B.instance_methods(true).include?(:method1) #=> true
  #     C.instance_methods(false)                   #=> [:method3]
  #     C.instance_methods.include?(:method2)       #=> true
  #
  def instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - method_added(method_name)
  # -->
  # Invoked as a callback whenever an instance method is added to the receiver.
  #
  #     module Chatty
  #       def self.method_added(method_name)
  #         puts "Adding #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #     end
  #
  # *produces:*
  #
  #     Adding :some_instance_method
  #
  def method_added: (Symbol meth) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named method is defined by *mod*.  If *inherit* is set,
  # the lookup will also search *mod*'s ancestors. Public and protected methods
  # are matched. String arguments are converted to symbols.
  #
  #     module A
  #       def method1()  end
  #       def protected_method1()  end
  #       protected :protected_method1
  #     end
  #     class B
  #       def method2()  end
  #       def private_method2()  end
  #       private :private_method2
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1              #=> true
  #     C.method_defined? "method1"             #=> true
  #     C.method_defined? "method2"             #=> true
  #     C.method_defined? "method2", true       #=> true
  #     C.method_defined? "method2", false      #=> false
  #     C.method_defined? "method3"             #=> true
  #     C.method_defined? "protected_method1"   #=> true
  #     C.method_defined? "method4"             #=> false
  #     C.method_defined? "private_method2"     #=> false
  #
  def method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - method_removed(method_name)
  # -->
  # Invoked as a callback whenever an instance method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def self.method_removed(method_name)
  #         puts "Removing #{method_name.inspect}"
  #       end
  #       def self.some_class_method() end
  #       def some_instance_method() end
  #       class << self
  #         remove_method :some_class_method
  #       end
  #       remove_method :some_instance_method
  #     end
  #
  # *produces:*
  #
  #     Removing :some_instance_method
  #
  def method_removed: (Symbol method_name) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.class_eval(string [, filename [, lineno]])  -> obj
  #   - mod.class_eval {|mod| block }                   -> obj
  #   - mod.module_eval(string [, filename [, lineno]]) -> obj
  #   - mod.module_eval {|mod| block }                  -> obj
  # -->
  # Evaluates the string or block in the context of *mod*, except that when a
  # block is given, constant/class variable lookup is not affected. This can be
  # used to add methods to a class. `module_eval` returns the result of evaluating
  # its argument. The optional *filename* and *lineno* parameters set the text for
  # error messages.
  #
  #     class Thing
  #     end
  #     a = %q{def hello() "Hello there!" end}
  #     Thing.module_eval(a)
  #     puts Thing.new.hello()
  #     Thing.module_eval("invalid code", "dummy", 123)
  #
  # *produces:*
  #
  #     Hello there!
  #     dummy:123:in `module_eval': undefined local variable
  #         or method `code' for Thing:Class
  #
  def module_eval: (String arg0, ?String filename, ?Integer lineno) -> untyped
                 | [U] () { (self m) -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - mod.module_exec(arg...) {|var...| block }       -> obj
  #   - mod.class_exec(arg...) {|var...| block }        -> obj
  # -->
  # Evaluates the given block in the context of the class/module. The method
  # defined in the block will belong to the receiver. Any arguments passed to the
  # method will be passed to the block. This can be used if the block needs to
  # access instance variables.
  #
  #     class Thing
  #     end
  #     Thing.class_exec{
  #       def hello() "Hello there!" end
  #     }
  #     puts Thing.new.hello()
  #
  # *produces:*
  #
  #     Hello there!
  #
  def module_exec: (*untyped args) { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - module_function                                -> nil
  #   - module_function(method_name)                   -> method_name
  #   - module_function(method_name, method_name, ...) -> array
  # -->
  # Creates module functions for the named methods. These functions may be called
  # with the module as a receiver, and also become available as instance methods
  # to classes that mix in the module. Module functions are copies of the
  # original, and so may be changed independently. The instance-method versions
  # are made private. If used with no arguments, subsequently defined methods
  # become module functions. String arguments are converted to symbols. If a
  # single argument is passed, it is returned. If no argument is passed, nil is
  # returned. If multiple arguments are passed, the arguments are returned as an
  # array.
  #
  #     module Mod
  #       def one
  #         "This is one"
  #       end
  #       module_function :one
  #     end
  #     class Cls
  #       include Mod
  #       def call_one
  #         one
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c = Cls.new
  #     c.call_one  #=> "This is one"
  #     module Mod
  #       def one
  #         "This is the new one"
  #       end
  #     end
  #     Mod.one     #=> "This is one"
  #     c.call_one  #=> "This is the new one"
  #
  def module_function: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.name    -> string
  # -->
  # Returns the name of the module *mod*.  Returns nil for anonymous modules.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - prepend(module, ...)    -> self
  # -->
  # Invokes Module.prepend_features on each parameter in reverse order.
  #
  def prepend: (*Module arg0) -> self

  # <!--
  #   rdoc-file=eval.c
  #   - prepend_features(mod)   -> mod
  # -->
  # When this module is prepended in another, Ruby calls #prepend_features in this
  # module, passing it the receiving module in *mod*. Ruby's default
  # implementation is to overlay the constants, methods, and module variables of
  # this module to *mod* if this module has not already been added to *mod* or one
  # of its ancestors. See also Module#prepend.
  #
  def prepend_features: (Module arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - prepended(othermod)
  # -->
  # The equivalent of `included`, but for prepended modules.
  #
  #     module A
  #       def self.prepended(mod)
  #         puts "#{self} prepended to #{mod}"
  #       end
  #     end
  #     module Enumerable
  #       prepend A
  #     end
  #      # => prints "A prepended to Enumerable"
  #
  def prepended: (Module othermod) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - private                                -> nil
  #   - private(method_name)                   -> method_name
  #   - private(method_name, method_name, ...) -> array
  #   - private(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to private. With arguments, sets the named methods to have private
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  #     module Mod
  #       def a()  end
  #       def b()  end
  #       private
  #       def c()  end
  #       private :a
  #     end
  #     Mod.private_instance_methods   #=> [:a, :c]
  #
  # Note that to show a private method on RDoc, use `:doc:`.
  #
  def private: () -> nil
             | (Symbol method_name) -> Symbol
             | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
             | (string method_name) -> string
             | (string | Symbol, string | Symbol, *string | Symbol method_name) -> Array[string | Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_class_method(symbol, ...)   -> mod
  #   - mod.private_class_method(string, ...)   -> mod
  #   - mod.private_class_method(array)         -> mod
  # -->
  # Makes existing class methods private. Often used to hide the default
  # constructor `new`.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  #     class SimpleSingleton  # Not thread safe
  #       private_class_method :new
  #       def SimpleSingleton.create(*args, &block)
  #         @me = new(*args, &block) if ! @me
  #         @me
  #       end
  #     end
  #
  def private_class_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants private.
  #
  def private_constant: (*Symbol arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.private_instance_methods(include_super=true)    -> array
  # -->
  # Returns a list of the private instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  #     module Mod
  #       def method1()  end
  #       private :method1
  #       def method2()  end
  #     end
  #     Mod.instance_methods           #=> [:method2]
  #     Mod.private_instance_methods   #=> [:method1]
  #
  def private_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.private_method_defined?(symbol, inherit=true)    -> true or false
  #   - mod.private_method_defined?(string, inherit=true)    -> true or false
  # -->
  # Returns `true` if the named private method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       private
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                   #=> true
  #     C.private_method_defined? "method1"          #=> false
  #     C.private_method_defined? "method2"          #=> true
  #     C.private_method_defined? "method2", true    #=> true
  #     C.private_method_defined? "method2", false   #=> false
  #     C.method_defined? "method2"                  #=> false
  #
  def private_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - protected                                -> nil
  #   - protected(method_name)                   -> method_name
  #   - protected(method_name, method_name, ...) -> array
  #   - protected(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to protected. With arguments, sets the named methods to have protected
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  # If a method has protected visibility, it is callable only where `self` of the
  # context is the same as the method. (method definition or instance_eval). This
  # behavior is different from Java's protected method. Usually `private` should
  # be used.
  #
  # Note that a protected method is slow because it can't use inline cache.
  #
  # To show a private method on RDoc, use `:doc:` instead of this.
  #
  def protected: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.protected_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the protected instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def protected_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.protected_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.protected_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named protected method is defined *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                    #=> true
  #     C.protected_method_defined? "method1"         #=> false
  #     C.protected_method_defined? "method2"         #=> true
  #     C.protected_method_defined? "method2", true   #=> true
  #     C.protected_method_defined? "method2", false  #=> false
  #     C.method_defined? "method2"                   #=> true
  #
  def protected_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=vm_method.c
  #   - public                                -> nil
  #   - public(method_name)                   -> method_name
  #   - public(method_name, method_name, ...) -> array
  #   - public(array)                         -> array
  # -->
  # With no arguments, sets the default visibility for subsequently defined
  # methods to public. With arguments, sets the named methods to have public
  # visibility. String arguments are converted to symbols. An Array of Symbols
  # and/or Strings is also accepted. If a single argument is passed, it is
  # returned. If no argument is passed, nil is returned. If multiple arguments are
  # passed, the arguments are returned as an array.
  #
  def public: () -> nil
            | (Symbol method_name) -> Symbol
            | (Symbol, Symbol, *Symbol method_name) -> Array[Symbol]
            | (string method_name) -> string
            | (string | Symbol, string | Symbol, *string | Symbol method_name) -> Array[string | Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_class_method(symbol, ...)    -> mod
  #   - mod.public_class_method(string, ...)    -> mod
  #   - mod.public_class_method(array)          -> mod
  # -->
  # Makes a list of existing class methods public.
  #
  # String arguments are converted to symbols. An Array of Symbols and/or Strings
  # is also accepted.
  #
  def public_class_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_constant(symbol, ...)    => mod
  # -->
  # Makes a list of existing constants public.
  #
  def public_constant: (*Symbol arg0) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - mod.public_instance_method(symbol)   -> unbound_method
  # -->
  # Similar to *instance_method*, searches public method only.
  #
  def public_instance_method: (Symbol arg0) -> UnboundMethod

  # <!--
  #   rdoc-file=object.c
  #   - mod.public_instance_methods(include_super=true)   -> array
  # -->
  # Returns a list of the public instance methods defined in *mod*. If the
  # optional parameter is `false`, the methods of any ancestors are not included.
  #
  def public_instance_methods: (?boolish include_super) -> ::Array[Symbol]

  # <!--
  #   rdoc-file=vm_method.c
  #   - mod.public_method_defined?(symbol, inherit=true)   -> true or false
  #   - mod.public_method_defined?(string, inherit=true)   -> true or false
  # -->
  # Returns `true` if the named public method is defined by *mod*.  If *inherit*
  # is set, the lookup will also search *mod*'s ancestors. String arguments are
  # converted to symbols.
  #
  #     module A
  #       def method1()  end
  #     end
  #     class B
  #       protected
  #       def method2()  end
  #     end
  #     class C < B
  #       include A
  #       def method3()  end
  #     end
  #
  #     A.method_defined? :method1                 #=> true
  #     C.public_method_defined? "method1"         #=> true
  #     C.public_method_defined? "method1", true   #=> true
  #     C.public_method_defined? "method1", false  #=> true
  #     C.public_method_defined? "method2"         #=> false
  #     C.method_defined? "method2"                #=> true
  #
  def public_method_defined?: (Symbol | String name, ?boolish inherit) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - refine(mod) { block }   -> module
  # -->
  # Refine *mod* in the receiver.
  #
  # Returns a module, where refined methods are defined.
  #
  def refine: (Class arg0) { (untyped arg0) -> untyped } -> self

  # <!--
  #   rdoc-file=object.c
  #   - remove_class_variable(sym)    -> obj
  # -->
  # Removes the named class variable from the receiver, returning that variable's
  # value.
  #
  #     class Example
  #       @@var = 99
  #       puts remove_class_variable(:@@var)
  #       p(defined? @@var)
  #     end
  #
  # *produces:*
  #
  #     99
  #     nil
  #
  def remove_class_variable: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - remove_const(sym)   -> obj
  # -->
  # Removes the definition of the given constant, returning that constant's
  # previous value.  If that constant referred to a module, this will not change
  # that module's name and can lead to confusion.
  #
  def remove_const: (Symbol arg0) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - remove_method(symbol)   -> self
  #   - remove_method(string)   -> self
  # -->
  # Removes the method identified by *symbol* from the current class. For an
  # example, see Module#undef_method. String arguments are converted to symbols.
  #
  def remove_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=object.c
  #   - mod.singleton_class?    -> true or false
  # -->
  # Returns `true` if *mod* is a singleton class or `false` if it is an ordinary
  # class or module.
  #
  #     class C
  #     end
  #     C.singleton_class?                  #=> false
  #     C.singleton_class.singleton_class?  #=> true
  #
  def singleton_class?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - mod.to_s   -> string
  # -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_method.c
  #   - undef_method(symbol)    -> self
  #   - undef_method(string)    -> self
  # -->
  # Prevents the current class from responding to calls to the named method.
  # Contrast this with `remove_method`, which deletes the method from the
  # particular class; Ruby will still search superclasses and mixed-in modules for
  # a possible receiver. String arguments are converted to symbols.
  #
  #     class Parent
  #       def hello
  #         puts "In parent"
  #       end
  #     end
  #     class Child < Parent
  #       def hello
  #         puts "In child"
  #       end
  #     end
  #
  #     c = Child.new
  #     c.hello
  #
  #     class Child
  #       remove_method :hello  # remove from child, still in parent
  #     end
  #     c.hello
  #
  #     class Child
  #       undef_method :hello   # prevent any calls to 'hello'
  #     end
  #     c.hello
  #
  # *produces:*
  #
  #     In child
  #     In parent
  #     prog.rb:23: undefined method `hello' for #<Child:0x401b3bb4> (NoMethodError)
  #
  def undef_method: (*Symbol | String arg0) -> self

  # <!--
  #   rdoc-file=eval.c
  #   - using(module)    -> self
  # -->
  # Import class refinements from *module* into the current class or module
  # definition.
  #
  def using: (Module arg0) -> self

  # <!-- rdoc-file=object.c -->
  # Returns a string representing this module or class. For basic classes and
  # modules, this is the name. For singletons, we show information on the thing
  # we're attached to as well.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - attr(name, ...) -> array
  #   - attr(name, true) -> array
  #   - attr(name, false) -> array
  # -->
  # The first form is equivalent to #attr_reader. The second form is equivalent to
  # `attr_accessor(name)` but deprecated. The last form is equivalent to
  # `attr_reader(name)` but deprecated. Returns an array of defined method names
  # as symbols.
  #
  def attr: (*Symbol | String arg0) -> NilClass
end

# <!-- rdoc-file=encoding.c -->
# An Encoding instance represents a character encoding usable in Ruby. It is
# defined as a constant under the Encoding namespace. It has a name and
# optionally, aliases:
#
#     Encoding::ISO_8859_1.name
#     #=> "ISO-8859-1"
#
#     Encoding::ISO_8859_1.names
#     #=> ["ISO-8859-1", "ISO8859-1"]
#
# Ruby methods dealing with encodings return or accept Encoding instances as
# arguments (when a method accepts an Encoding instance as an argument, it can
# be passed an Encoding name or alias instead).
#
#     "some string".encoding
#     #=> #<Encoding:UTF-8>
#
#     string = "some string".encode(Encoding::ISO_8859_1)
#     #=> "some string"
#     string.encoding
#     #=> #<Encoding:ISO-8859-1>
#
#     "some string".encode "ISO-8859-1"
#     #=> "some string"
#
# Encoding::ASCII_8BIT is a special encoding that is usually used for a byte
# string, not a character string. But as the name insists, its characters in the
# range of ASCII are considered as ASCII characters.  This is useful when you
# use ASCII-8BIT characters with other ASCII compatible characters.
#
# ## Changing an encoding
#
# The associated Encoding of a String can be changed in two different ways.
#
# First, it is possible to set the Encoding of a string to a new Encoding
# without changing the internal byte representation of the string, with
# String#force_encoding. This is how you can tell Ruby the correct encoding of a
# string.
#
#     string
#     #=> "R\xC3\xA9sum\xC3\xA9"
#     string.encoding
#     #=> #<Encoding:ISO-8859-1>
#     string.force_encoding(Encoding::UTF_8)
#     #=> "R\u00E9sum\u00E9"
#
# Second, it is possible to transcode a string, i.e. translate its internal byte
# representation to another encoding. Its associated encoding is also set to the
# other encoding. See String#encode for the various forms of transcoding, and
# the Encoding::Converter class for additional control over the transcoding
# process.
#
#     string
#     #=> "R\u00E9sum\u00E9"
#     string.encoding
#     #=> #<Encoding:UTF-8>
#     string = string.encode!(Encoding::ISO_8859_1)
#     #=> "R\xE9sum\xE9"
#     string.encoding
#     #=> #<Encoding::ISO-8859-1>
#
# ## Script encoding
#
# All Ruby script code has an associated Encoding which any String literal
# created in the source code will be associated to.
#
# The default script encoding is Encoding::UTF_8 after v2.0, but it can be
# changed by a magic comment on the first line of the source code file (or
# second line, if there is a shebang line on the first). The comment must
# contain the word `coding` or `encoding`, followed by a colon, space and the
# Encoding name or alias:
#
#     # encoding: UTF-8
#
#     "some string".encoding
#     #=> #<Encoding:UTF-8>
#
# The `__ENCODING__` keyword returns the script encoding of the file which the
# keyword is written:
#
#     # encoding: ISO-8859-1
#
#     __ENCODING__
#     #=> #<Encoding:ISO-8859-1>
#
# `ruby -K` will change the default locale encoding, but this is not
# recommended. Ruby source files should declare its script encoding by a magic
# comment even when they only depend on US-ASCII strings or regular expressions.
#
# ## Locale encoding
#
# The default encoding of the environment. Usually derived from locale.
#
# see Encoding.locale_charmap, Encoding.find('locale')
#
# ## Filesystem encoding
#
# The default encoding of strings from the filesystem of the environment. This
# is used for strings of file names or paths.
#
# see Encoding.find('filesystem')
#
# ## External encoding
#
# Each IO object has an external encoding which indicates the encoding that Ruby
# will use to read its data. By default Ruby sets the external encoding of an IO
# object to the default external encoding. The default external encoding is set
# by locale encoding or the interpreter `-E` option. Encoding.default_external
# returns the current value of the external encoding.
#
#     ENV["LANG"]
#     #=> "UTF-8"
#     Encoding.default_external
#     #=> #<Encoding:UTF-8>
#
#     $ ruby -E ISO-8859-1 -e "p Encoding.default_external"
#     #<Encoding:ISO-8859-1>
#
#     $ LANG=C ruby -e 'p Encoding.default_external'
#     #<Encoding:US-ASCII>
#
# The default external encoding may also be set through
# Encoding.default_external=, but you should not do this as strings created
# before and after the change will have inconsistent encodings.  Instead use
# `ruby -E` to invoke ruby with the correct external encoding.
#
# When you know that the actual encoding of the data of an IO object is not the
# default external encoding, you can reset its external encoding with
# IO#set_encoding or set it at IO object creation (see IO.new options).
#
# ## Internal encoding
#
# To process the data of an IO object which has an encoding different from its
# external encoding, you can set its internal encoding. Ruby will use this
# internal encoding to transcode the data when it is read from the IO object.
#
# Conversely, when data is written to the IO object it is transcoded from the
# internal encoding to the external encoding of the IO object.
#
# The internal encoding of an IO object can be set with IO#set_encoding or at IO
# object creation (see IO.new options).
#
# The internal encoding is optional and when not set, the Ruby default internal
# encoding is used. If not explicitly set this default internal encoding is
# `nil` meaning that by default, no transcoding occurs.
#
# The default internal encoding can be set with the interpreter option `-E`.
# Encoding.default_internal returns the current internal encoding.
#
#     $ ruby -e 'p Encoding.default_internal'
#     nil
#
#     $ ruby -E ISO-8859-1:UTF-8 -e "p [Encoding.default_external, \
#       Encoding.default_internal]"
#     [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]
#
# The default internal encoding may also be set through
# Encoding.default_internal=, but you should not do this as strings created
# before and after the change will have inconsistent encodings.  Instead use
# `ruby -E` to invoke ruby with the correct internal encoding.
#
# ## IO encoding example
#
# In the following example a UTF-8 encoded string "Ru00E9sumu00E9" is transcoded
# for output to ISO-8859-1 encoding, then read back in and transcoded to UTF-8:
#
#     string = "R\u00E9sum\u00E9"
#
#     open("transcoded.txt", "w:ISO-8859-1") do |io|
#       io.write(string)
#     end
#
#     puts "raw text:"
#     p File.binread("transcoded.txt")
#     puts
#
#     open("transcoded.txt", "r:ISO-8859-1:UTF-8") do |io|
#       puts "transcoded text:"
#       p io.read
#     end
#
# While writing the file, the internal encoding is not specified as it is only
# necessary for reading.  While reading the file both the internal and external
# encoding must be specified to obtain the correct result.
#
#     $ ruby t.rb
#     raw text:
#     "R\xE9sum\xE9"
#
#     transcoded text:
#     "R\u00E9sum\u00E9"
#
class Encoding < Object
  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.aliases -> {"alias1" => "orig1", "alias2" => "orig2", ...}
  # -->
  # Returns the hash of available encoding alias and original encoding name.
  #
  #     Encoding.aliases
  #     #=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII",
  #           "SJIS"=>"Windows-31J", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}
  #
  def self.aliases: () -> ::Hash[String, String]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.compatible?(obj1, obj2) -> enc or nil
  # -->
  # Checks the compatibility of two objects.
  #
  # If the objects are both strings they are compatible when they are
  # concatenatable.  The encoding of the concatenated string will be returned if
  # they are compatible, nil if they are not.
  #
  #     Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")
  #     #=> #<Encoding:ISO-8859-1>
  #
  #     Encoding.compatible?(
  #       "\xa1".force_encoding("iso-8859-1"),
  #       "\xa1\xa1".force_encoding("euc-jp"))
  #     #=> nil
  #
  # If the objects are non-strings their encodings are compatible when they have
  # an encoding and:
  # *   Either encoding is US-ASCII compatible
  # *   One of the encodings is a 7-bit encoding
  #
  def self.compatible?: (untyped obj1, untyped obj2) -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external -> enc
  # -->
  # Returns default external encoding.
  #
  # The default external encoding is used by default for strings created from the
  # following locations:
  #
  # *   CSV
  # *   File data read from disk
  # *   SDBM
  # *   StringIO
  # *   Zlib::GzipReader
  # *   Zlib::GzipWriter
  # *   String#inspect
  # *   Regexp#inspect
  #
  #
  # While strings created from these locations will have this encoding, the
  # encoding may not be valid.  Be sure to check String#valid_encoding?.
  #
  # File data written to disk will be transcoded to the default external encoding
  # when written, if default_internal is not nil.
  #
  # The default external encoding is initialized by the -E option. If -E isn't
  # set, it is initialized to UTF-8 on Windows and the locale on other operating
  # systems.
  #
  def self.default_external: () -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_external = enc
  # -->
  # Sets default external encoding.  You should not set Encoding::default_external
  # in ruby code as strings created before changing the value may have a different
  # encoding from strings created after the value was changed., instead you should
  # use `ruby -E` to invoke ruby with the correct default_external.
  #
  # See Encoding::default_external for information on how the default external
  # encoding is used.
  #
  def self.default_external=: (String arg0) -> String
                            | (Encoding arg0) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal -> enc
  # -->
  # Returns default internal encoding.  Strings will be transcoded to the default
  # internal encoding in the following places if the default internal encoding is
  # not nil:
  #
  # *   CSV
  # *   Etc.sysconfdir and Etc.systmpdir
  # *   File data read from disk
  # *   File names from Dir
  # *   Integer#chr
  # *   String#inspect and Regexp#inspect
  # *   Strings returned from Readline
  # *   Strings returned from SDBM
  # *   Time#zone
  # *   Values from ENV
  # *   Values in ARGV including $PROGRAM_NAME
  #
  #
  # Additionally String#encode and String#encode! use the default internal
  # encoding if no encoding is given.
  #
  # The script encoding (__ENCODING__), not default_internal, is used as the
  # encoding of created strings.
  #
  # Encoding::default_internal is initialized with -E option or nil otherwise.
  #
  def self.default_internal: () -> Encoding?

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.default_internal = enc or nil
  # -->
  # Sets default internal encoding or removes default internal encoding when
  # passed nil.  You should not set Encoding::default_internal in ruby code as
  # strings created before changing the value may have a different encoding from
  # strings created after the change.  Instead you should use `ruby -E` to invoke
  # ruby with the correct default_internal.
  #
  # See Encoding::default_internal for information on how the default internal
  # encoding is used.
  #
  def self.default_internal=: (String arg0) -> String?
                            | (Encoding arg0) -> Encoding?
                            | (nil arg0) -> nil

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.find(string) -> enc
  # -->
  # Search the encoding with specified *name*. *name* should be a string.
  #
  #     Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>
  #
  # Names which this method accept are encoding names and aliases including
  # following special aliases
  #
  # "external"
  # :   default external encoding
  # "internal"
  # :   default internal encoding
  # "locale"
  # :   locale encoding
  # "filesystem"
  # :   filesystem encoding
  #
  #
  # An ArgumentError is raised when no encoding with *name*. Only
  # `Encoding.find("internal")` however returns nil when no encoding named
  # "internal", in other words, when Ruby has no default internal encoding.
  #
  def self.find: (String | Encoding arg0) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.list -> [enc1, enc2, ...]
  # -->
  # Returns the list of loaded encodings.
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:ISO-2022-JP (dummy)>]
  #
  #     Encoding.find("US-ASCII")
  #     #=> #<Encoding:US-ASCII>
  #
  #     Encoding.list
  #     #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
  #           #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]
  #
  def self.list: () -> ::Array[Encoding]

  # <!--
  #   rdoc-file=encoding.c
  #   - Encoding.name_list -> ["enc1", "enc2", ...]
  # -->
  # Returns the list of available encoding names.
  #
  #     Encoding.name_list
  #     #=> ["US-ASCII", "ASCII-8BIT", "UTF-8",
  #           "ISO-8859-1", "Shift_JIS", "EUC-JP",
  #           "Windows-31J",
  #           "BINARY", "CP932", "eucJP"]
  #
  def self.name_list: () -> ::Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.ascii_compatible? -> true or false
  # -->
  # Returns whether ASCII-compatible or not.
  #
  #     Encoding::UTF_8.ascii_compatible?     #=> true
  #     Encoding::UTF_16BE.ascii_compatible?  #=> false
  #
  def ascii_compatible?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.dummy? -> true or false
  # -->
  # Returns true for dummy encodings. A dummy encoding is an encoding for which
  # character handling is not properly implemented. It is used for stateful
  # encodings.
  #
  #     Encoding::ISO_2022_JP.dummy?       #=> true
  #     Encoding::UTF_8.dummy?             #=> false
  #
  def dummy?: () -> bool

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.inspect -> string
  # -->
  # Returns a string which represents the encoding for programmers.
  #
  #     Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"
  #     Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"
  #
  def inspect: () -> String

  # <!-- rdoc-file=encoding.c -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  def name: () -> String

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.names -> array
  # -->
  # Returns the list of name and aliases of the encoding.
  #
  #     Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J", "SJIS", "PCK"]
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.replicate(name) -> encoding
  # -->
  # Returns a replicated encoding of *enc* whose name is *name*. The new encoding
  # should have the same byte structure of *enc*. If *name* is used by another
  # encoding, raise ArgumentError.
  #
  def replicate: (String name) -> Encoding

  # <!--
  #   rdoc-file=encoding.c
  #   - enc.name -> string
  #   - enc.to_s -> string
  # -->
  # Returns the name of the encoding.
  #
  #     Encoding::UTF_8.name      #=> "UTF-8"
  #
  def to_s: () -> String
end

Encoding::ANSI_X3_4_1968: Encoding

Encoding::ASCII: Encoding

Encoding::ASCII_8BIT: Encoding

Encoding::BIG5: Encoding

Encoding::BIG5_HKSCS: Encoding

Encoding::BIG5_HKSCS_2008: Encoding

Encoding::BIG5_UAO: Encoding

Encoding::BINARY: Encoding

Encoding::Big5: Encoding

Encoding::Big5_HKSCS: Encoding

Encoding::Big5_HKSCS_2008: Encoding

Encoding::Big5_UAO: Encoding

Encoding::CESU_8: Encoding

Encoding::CP1250: Encoding

Encoding::CP1251: Encoding

Encoding::CP1252: Encoding

Encoding::CP1253: Encoding

Encoding::CP1254: Encoding

Encoding::CP1255: Encoding

Encoding::CP1256: Encoding

Encoding::CP1257: Encoding

Encoding::CP1258: Encoding

Encoding::CP437: Encoding

Encoding::CP50220: Encoding

Encoding::CP50221: Encoding

Encoding::CP51932: Encoding

Encoding::CP65000: Encoding

Encoding::CP65001: Encoding

Encoding::CP737: Encoding

Encoding::CP775: Encoding

Encoding::CP850: Encoding

Encoding::CP852: Encoding

Encoding::CP855: Encoding

Encoding::CP857: Encoding

Encoding::CP860: Encoding

Encoding::CP861: Encoding

Encoding::CP862: Encoding

Encoding::CP863: Encoding

Encoding::CP864: Encoding

Encoding::CP865: Encoding

Encoding::CP866: Encoding

Encoding::CP869: Encoding

Encoding::CP874: Encoding

Encoding::CP878: Encoding

Encoding::CP932: Encoding

Encoding::CP936: Encoding

Encoding::CP949: Encoding

Encoding::CP950: Encoding

Encoding::CP951: Encoding

Encoding::CSWINDOWS31J: Encoding

Encoding::CsWindows31J: Encoding

Encoding::EBCDIC_CP_US: Encoding

Encoding::EMACS_MULE: Encoding

Encoding::EUCCN: Encoding

Encoding::EUCJP: Encoding

Encoding::EUCJP_MS: Encoding

Encoding::EUCKR: Encoding

Encoding::EUCTW: Encoding

Encoding::EUC_CN: Encoding

Encoding::EUC_JISX0213: Encoding

Encoding::EUC_JIS_2004: Encoding

Encoding::EUC_JP: Encoding

Encoding::EUC_JP_MS: Encoding

Encoding::EUC_KR: Encoding

Encoding::EUC_TW: Encoding

Encoding::Emacs_Mule: Encoding

Encoding::EucCN: Encoding

Encoding::EucJP: Encoding

Encoding::EucJP_ms: Encoding

Encoding::EucKR: Encoding

Encoding::EucTW: Encoding

Encoding::GB12345: Encoding

Encoding::GB18030: Encoding

Encoding::GB1988: Encoding

Encoding::GB2312: Encoding

Encoding::GBK: Encoding

Encoding::IBM037: Encoding

Encoding::IBM437: Encoding

Encoding::IBM737: Encoding

Encoding::IBM775: Encoding

Encoding::IBM850: Encoding

Encoding::IBM852: Encoding

Encoding::IBM855: Encoding

Encoding::IBM857: Encoding

Encoding::IBM860: Encoding

Encoding::IBM861: Encoding

Encoding::IBM862: Encoding

Encoding::IBM863: Encoding

Encoding::IBM864: Encoding

Encoding::IBM865: Encoding

Encoding::IBM866: Encoding

Encoding::IBM869: Encoding

Encoding::ISO2022_JP: Encoding

Encoding::ISO2022_JP2: Encoding

Encoding::ISO8859_1: Encoding

Encoding::ISO8859_10: Encoding

Encoding::ISO8859_11: Encoding

Encoding::ISO8859_13: Encoding

Encoding::ISO8859_14: Encoding

Encoding::ISO8859_15: Encoding

Encoding::ISO8859_16: Encoding

Encoding::ISO8859_2: Encoding

Encoding::ISO8859_3: Encoding

Encoding::ISO8859_4: Encoding

Encoding::ISO8859_5: Encoding

Encoding::ISO8859_6: Encoding

Encoding::ISO8859_7: Encoding

Encoding::ISO8859_8: Encoding

Encoding::ISO8859_9: Encoding

Encoding::ISO_2022_JP: Encoding

Encoding::ISO_2022_JP_2: Encoding

Encoding::ISO_2022_JP_KDDI: Encoding

Encoding::ISO_8859_1: Encoding

Encoding::ISO_8859_10: Encoding

Encoding::ISO_8859_11: Encoding

Encoding::ISO_8859_13: Encoding

Encoding::ISO_8859_14: Encoding

Encoding::ISO_8859_15: Encoding

Encoding::ISO_8859_16: Encoding

Encoding::ISO_8859_2: Encoding

Encoding::ISO_8859_3: Encoding

Encoding::ISO_8859_4: Encoding

Encoding::ISO_8859_5: Encoding

Encoding::ISO_8859_6: Encoding

Encoding::ISO_8859_7: Encoding

Encoding::ISO_8859_8: Encoding

Encoding::ISO_8859_9: Encoding

Encoding::KOI8_R: Encoding

Encoding::KOI8_U: Encoding

Encoding::MACCENTEURO: Encoding

Encoding::MACCROATIAN: Encoding

Encoding::MACCYRILLIC: Encoding

Encoding::MACGREEK: Encoding

Encoding::MACICELAND: Encoding

Encoding::MACJAPAN: Encoding

Encoding::MACJAPANESE: Encoding

Encoding::MACROMAN: Encoding

Encoding::MACROMANIA: Encoding

Encoding::MACTHAI: Encoding

Encoding::MACTURKISH: Encoding

Encoding::MACUKRAINE: Encoding

Encoding::MacCentEuro: Encoding

Encoding::MacCroatian: Encoding

Encoding::MacCyrillic: Encoding

Encoding::MacGreek: Encoding

Encoding::MacIceland: Encoding

Encoding::MacJapan: Encoding

Encoding::MacJapanese: Encoding

Encoding::MacRoman: Encoding

Encoding::MacRomania: Encoding

Encoding::MacThai: Encoding

Encoding::MacTurkish: Encoding

Encoding::MacUkraine: Encoding

Encoding::PCK: Encoding

Encoding::SHIFT_JIS: Encoding

Encoding::SJIS: Encoding

Encoding::SJIS_DOCOMO: Encoding

Encoding::SJIS_DoCoMo: Encoding

Encoding::SJIS_KDDI: Encoding

Encoding::SJIS_SOFTBANK: Encoding

Encoding::SJIS_SoftBank: Encoding

Encoding::STATELESS_ISO_2022_JP: Encoding

Encoding::STATELESS_ISO_2022_JP_KDDI: Encoding

Encoding::Shift_JIS: Encoding

Encoding::Stateless_ISO_2022_JP: Encoding

Encoding::Stateless_ISO_2022_JP_KDDI: Encoding

Encoding::TIS_620: Encoding

Encoding::UCS_2BE: Encoding

Encoding::UCS_4BE: Encoding

Encoding::UCS_4LE: Encoding

Encoding::US_ASCII: Encoding

Encoding::UTF8_DOCOMO: Encoding

Encoding::UTF8_DoCoMo: Encoding

Encoding::UTF8_KDDI: Encoding

Encoding::UTF8_MAC: Encoding

Encoding::UTF8_SOFTBANK: Encoding

Encoding::UTF8_SoftBank: Encoding

Encoding::UTF_16: Encoding

Encoding::UTF_16BE: Encoding

Encoding::UTF_16LE: Encoding

Encoding::UTF_32: Encoding

Encoding::UTF_32BE: Encoding

Encoding::UTF_32LE: Encoding

Encoding::UTF_7: Encoding

Encoding::UTF_8: Encoding

Encoding::UTF_8_HFS: Encoding

Encoding::UTF_8_MAC: Encoding

Encoding::WINDOWS_1250: Encoding

Encoding::WINDOWS_1251: Encoding

Encoding::WINDOWS_1252: Encoding

Encoding::WINDOWS_1253: Encoding

Encoding::WINDOWS_1254: Encoding

Encoding::WINDOWS_1255: Encoding

Encoding::WINDOWS_1256: Encoding

Encoding::WINDOWS_1257: Encoding

Encoding::WINDOWS_1258: Encoding

Encoding::WINDOWS_31J: Encoding

Encoding::WINDOWS_874: Encoding

Encoding::Windows_1250: Encoding

Encoding::Windows_1251: Encoding

Encoding::Windows_1252: Encoding

Encoding::Windows_1253: Encoding

Encoding::Windows_1254: Encoding

Encoding::Windows_1255: Encoding

Encoding::Windows_1256: Encoding

Encoding::Windows_1257: Encoding

Encoding::Windows_1258: Encoding

Encoding::Windows_31J: Encoding

Encoding::Windows_874: Encoding

# <!-- rdoc-file=transcode.c -->
# Encoding conversion class.
#
class Encoding::Converter < Object
end

# <!-- rdoc-file=transcode.c -->
# AFTER_OUTPUT
#
# Stop converting after some output is complete but before all of the input was
# consumed.  See primitive_convert for an example.
#
Encoding::Converter::AFTER_OUTPUT: Integer

# <!-- rdoc-file=transcode.c -->
# CRLF_NEWLINE_DECORATOR
#
# Decorator for converting LF to CRLF
#
Encoding::Converter::CRLF_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# CR_NEWLINE_DECORATOR
#
# Decorator for converting LF to CR
#
Encoding::Converter::CR_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# INVALID_MASK
#
# Mask for invalid byte sequences
#
Encoding::Converter::INVALID_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# INVALID_REPLACE
#
# Replace invalid byte sequences
#
Encoding::Converter::INVALID_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# PARTIAL_INPUT
#
# Indicates the source may be part of a larger string.  See primitive_convert
# for an example.
#
Encoding::Converter::PARTIAL_INPUT: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_HEX_CHARREF
#
# Replace byte sequences that are undefined in the destination encoding with an
# XML hexadecimal character reference.  This is valid for XML conversion.
#
Encoding::Converter::UNDEF_HEX_CHARREF: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_MASK
#
# Mask for a valid character in the source encoding but no related character(s)
# in destination encoding.
#
Encoding::Converter::UNDEF_MASK: Integer

# <!-- rdoc-file=transcode.c -->
# UNDEF_REPLACE
#
# Replace byte sequences that are undefined in the destination encoding.
#
Encoding::Converter::UNDEF_REPLACE: Integer

# <!-- rdoc-file=transcode.c -->
# UNIVERSAL_NEWLINE_DECORATOR
#
# Decorator for converting CRLF and CR to LF
#
Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_ATTR_CONTENT_DECORATOR
#
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_CONTENT_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_ATTR_QUOTE_DECORATOR
#
# Escape as XML AttValue
#
Encoding::Converter::XML_ATTR_QUOTE_DECORATOR: Integer

# <!-- rdoc-file=transcode.c -->
# XML_TEXT_DECORATOR
#
# Escape as XML CharData
#
Encoding::Converter::XML_TEXT_DECORATOR: Integer

# <!-- rdoc-file=error.c -->
# Raised by Encoding and String methods when the source encoding is incompatible
# with the target encoding.
#
class Encoding::CompatibilityError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by transcoding methods when a named encoding does not correspond with a
# known converter.
#
class Encoding::ConverterNotFoundError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by Encoding and String methods when the string being transcoded
# contains a byte invalid for the either the source or target encoding.
#
class Encoding::InvalidByteSequenceError < EncodingError
end

# <!-- rdoc-file=transcode.c -->
# Raised by Encoding and String methods when a transcoding operation fails.
#
class Encoding::UndefinedConversionError < EncodingError
end

# <!-- rdoc-file=math.c -->
# The Math module contains module functions for basic trigonometric and
# transcendental functions. See class Float for a list of constants that define
# Ruby's floating point accuracy.
#
# Domains and codomains are given only for real (not complex) numbers.
#
module Math
  # <!--
  #   rdoc-file=math.c
  #   - Math.acos(x)    -> Float
  # -->
  # Computes the arc cosine of `x`. Returns 0..PI.
  #
  # Domain: [-1, 1]
  #
  # Codomain: [0, PI]
  #
  #     Math.acos(0) == Math::PI/2  #=> true
  #
  def self.acos: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.acosh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic cosine of `x`.
  #
  # Domain: [1, INFINITY)
  #
  # Codomain: [0, INFINITY)
  #
  #     Math.acosh(1) #=> 0.0
  #
  def self.acosh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asin(x)    -> Float
  # -->
  # Computes the arc sine of `x`. Returns -PI/2..PI/2.
  #
  # Domain: [-1, -1]
  #
  # Codomain: [-PI/2, PI/2]
  #
  #     Math.asin(1) == Math::PI/2  #=> true
  #
  def self.asin: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.asinh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic sine of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.asinh(1) #=> 0.881373587019543
  #
  def self.asinh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan(x)    -> Float
  # -->
  # Computes the arc tangent of `x`. Returns -PI/2..PI/2.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-PI/2, PI/2)
  #
  #     Math.atan(0) #=> 0.0
  #
  def self.atan: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atan2(y, x)  -> Float
  # -->
  # Computes the arc tangent given `y` and `x`. Returns a Float in the range
  # -PI..PI. Return value is a angle in radians between the positive x-axis of
  # cartesian plane and the point given by the coordinates (`x`, `y`) on it.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-PI, PI]
  #
  #     Math.atan2(-0.0, -1.0) #=> -3.141592653589793
  #     Math.atan2(-1.0, -1.0) #=> -2.356194490192345
  #     Math.atan2(-1.0, 0.0)  #=> -1.5707963267948966
  #     Math.atan2(-1.0, 1.0)  #=> -0.7853981633974483
  #     Math.atan2(-0.0, 1.0)  #=> -0.0
  #     Math.atan2(0.0, 1.0)   #=> 0.0
  #     Math.atan2(1.0, 1.0)   #=> 0.7853981633974483
  #     Math.atan2(1.0, 0.0)   #=> 1.5707963267948966
  #     Math.atan2(1.0, -1.0)  #=> 2.356194490192345
  #     Math.atan2(0.0, -1.0)  #=> 3.141592653589793
  #     Math.atan2(INFINITY, INFINITY)   #=> 0.7853981633974483
  #     Math.atan2(INFINITY, -INFINITY)  #=> 2.356194490192345
  #     Math.atan2(-INFINITY, INFINITY)  #=> -0.7853981633974483
  #     Math.atan2(-INFINITY, -INFINITY) #=> -2.356194490192345
  #
  def self.atan2: (Numeric y, Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.atanh(x)    -> Float
  # -->
  # Computes the inverse hyperbolic tangent of `x`.
  #
  # Domain: (-1, 1)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.atanh(1) #=> Infinity
  #
  def self.atanh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cbrt(x)    -> Float
  # -->
  # Returns the cube root of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     -9.upto(9) {|x|
  #       p [x, Math.cbrt(x), Math.cbrt(x)**3]
  #     }
  #     #=> [-9, -2.0800838230519, -9.0]
  #     #   [-8, -2.0, -8.0]
  #     #   [-7, -1.91293118277239, -7.0]
  #     #   [-6, -1.81712059283214, -6.0]
  #     #   [-5, -1.7099759466767, -5.0]
  #     #   [-4, -1.5874010519682, -4.0]
  #     #   [-3, -1.44224957030741, -3.0]
  #     #   [-2, -1.25992104989487, -2.0]
  #     #   [-1, -1.0, -1.0]
  #     #   [0, 0.0, 0.0]
  #     #   [1, 1.0, 1.0]
  #     #   [2, 1.25992104989487, 2.0]
  #     #   [3, 1.44224957030741, 3.0]
  #     #   [4, 1.5874010519682, 4.0]
  #     #   [5, 1.7099759466767, 5.0]
  #     #   [6, 1.81712059283214, 6.0]
  #     #   [7, 1.91293118277239, 7.0]
  #     #   [8, 2.0, 8.0]
  #     #   [9, 2.0800838230519, 9.0]
  #
  def self.cbrt: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cos(x)    -> Float
  # -->
  # Computes the cosine of `x` (expressed in radians). Returns a Float in the
  # range -1.0..1.0.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-1, 1]
  #
  #     Math.cos(Math::PI) #=> -1.0
  #
  def self.cos: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.cosh(x)    -> Float
  # -->
  # Computes the hyperbolic cosine of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [1, INFINITY)
  #
  #     Math.cosh(0) #=> 1.0
  #
  def self.cosh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erf(x)  -> Float
  # -->
  # Calculates the error function of `x`.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-1, 1)
  #
  #     Math.erf(0) #=> 0.0
  #
  def self.erf: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.erfc(x)  -> Float
  # -->
  # Calculates the complementary error function of x.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (0, 2)
  #
  #     Math.erfc(0) #=> 1.0
  #
  def self.erfc: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.exp(x)    -> Float
  # -->
  # Returns e**x.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (0, INFINITY)
  #
  #     Math.exp(0)       #=> 1.0
  #     Math.exp(1)       #=> 2.718281828459045
  #     Math.exp(1.5)     #=> 4.4816890703380645
  #
  def self.exp: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.frexp(x)    -> [fraction, exponent]
  # -->
  # Returns a two-element array containing the normalized fraction (a Float) and
  # exponent (an Integer) of `x`.
  #
  #     fraction, exponent = Math.frexp(1234)   #=> [0.6025390625, 11]
  #     fraction * 2**exponent                  #=> 1234.0
  #
  def self.frexp: (Numeric x) -> [ Float, Integer ]

  # <!--
  #   rdoc-file=math.c
  #   - Math.gamma(x)  -> Float
  # -->
  # Calculates the gamma function of x.
  #
  # Note that gamma(n) is the same as fact(n-1) for integer n > 0. However
  # gamma(n) returns float and can be an approximation.
  #
  #     def fact(n) (1..n).inject(1) {|r,i| r*i } end
  #     1.upto(26) {|i| p [i, Math.gamma(i), fact(i-1)] }
  #     #=> [1, 1.0, 1]
  #     #   [2, 1.0, 1]
  #     #   [3, 2.0, 2]
  #     #   [4, 6.0, 6]
  #     #   [5, 24.0, 24]
  #     #   [6, 120.0, 120]
  #     #   [7, 720.0, 720]
  #     #   [8, 5040.0, 5040]
  #     #   [9, 40320.0, 40320]
  #     #   [10, 362880.0, 362880]
  #     #   [11, 3628800.0, 3628800]
  #     #   [12, 39916800.0, 39916800]
  #     #   [13, 479001600.0, 479001600]
  #     #   [14, 6227020800.0, 6227020800]
  #     #   [15, 87178291200.0, 87178291200]
  #     #   [16, 1307674368000.0, 1307674368000]
  #     #   [17, 20922789888000.0, 20922789888000]
  #     #   [18, 355687428096000.0, 355687428096000]
  #     #   [19, 6.402373705728e+15, 6402373705728000]
  #     #   [20, 1.21645100408832e+17, 121645100408832000]
  #     #   [21, 2.43290200817664e+18, 2432902008176640000]
  #     #   [22, 5.109094217170944e+19, 51090942171709440000]
  #     #   [23, 1.1240007277776077e+21, 1124000727777607680000]
  #     #   [24, 2.5852016738885062e+22, 25852016738884976640000]
  #     #   [25, 6.204484017332391e+23, 620448401733239439360000]
  #     #   [26, 1.5511210043330954e+25, 15511210043330985984000000]
  #
  def self.gamma: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.hypot(x, y)    -> Float
  # -->
  # Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle with
  # sides `x` and `y`.
  #
  #     Math.hypot(3, 4)   #=> 5.0
  #
  def self.hypot: (Numeric x, Numeric y) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.ldexp(fraction, exponent) -> float
  # -->
  # Returns the value of `fraction`*(2**`exponent`).
  #
  #     fraction, exponent = Math.frexp(1234)
  #     Math.ldexp(fraction, exponent)   #=> 1234.0
  #
  def self.ldexp: (Numeric fraction, Numeric exponent) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.lgamma(x)  -> [float, -1 or 1]
  # -->
  # Calculates the logarithmic gamma of `x` and the sign of gamma of `x`.
  #
  # Math.lgamma(x) is the same as
  #     [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]
  #
  # but avoids overflow by Math.gamma(x) for large x.
  #
  #     Math.lgamma(0) #=> [Infinity, 1]
  #
  def self.lgamma: (Numeric x) -> [ Float, Integer ]

  # <!--
  #   rdoc-file=math.c
  #   - Math.log(x)          -> Float
  #   - Math.log(x, base)    -> Float
  # -->
  # Returns the logarithm of `x`. If additional second argument is given, it will
  # be the base of logarithm. Otherwise it is `e` (for the natural logarithm).
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log(0)          #=> -Infinity
  #     Math.log(1)          #=> 0.0
  #     Math.log(Math::E)    #=> 1.0
  #     Math.log(Math::E**3) #=> 3.0
  #     Math.log(12, 3)      #=> 2.2618595071429146
  #
  def self.log: (Numeric x, ?Numeric base) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log10(x)    -> Float
  # -->
  # Returns the base 10 logarithm of `x`.
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log10(1)       #=> 0.0
  #     Math.log10(10)      #=> 1.0
  #     Math.log10(10**100) #=> 100.0
  #
  def self.log10: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.log2(x)    -> Float
  # -->
  # Returns the base 2 logarithm of `x`.
  #
  # Domain: (0, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.log2(1)      #=> 0.0
  #     Math.log2(2)      #=> 1.0
  #     Math.log2(32768)  #=> 15.0
  #     Math.log2(65536)  #=> 16.0
  #
  def self.log2: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sin(x)    -> Float
  # -->
  # Computes the sine of `x` (expressed in radians). Returns a Float in the range
  # -1.0..1.0.
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: [-1, 1]
  #
  #     Math.sin(Math::PI/2) #=> 1.0
  #
  def self.sin: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sinh(x)    -> Float
  # -->
  # Computes the hyperbolic sine of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.sinh(0) #=> 0.0
  #
  def self.sinh: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.sqrt(x)    -> Float
  # -->
  # Returns the non-negative square root of `x`.
  #
  # Domain: [0, INFINITY)
  #
  # Codomain:[0, INFINITY)
  #
  #     0.upto(10) {|x|
  #       p [x, Math.sqrt(x), Math.sqrt(x)**2]
  #     }
  #     #=> [0, 0.0, 0.0]
  #     #   [1, 1.0, 1.0]
  #     #   [2, 1.4142135623731, 2.0]
  #     #   [3, 1.73205080756888, 3.0]
  #     #   [4, 2.0, 4.0]
  #     #   [5, 2.23606797749979, 5.0]
  #     #   [6, 2.44948974278318, 6.0]
  #     #   [7, 2.64575131106459, 7.0]
  #     #   [8, 2.82842712474619, 8.0]
  #     #   [9, 3.0, 9.0]
  #     #   [10, 3.16227766016838, 10.0]
  #
  # Note that the limited precision of floating point arithmetic might lead to
  # surprising results:
  #
  #     Math.sqrt(10**46).to_i  #=> 99999999999999991611392 (!)
  #
  # See also BigDecimal#sqrt and Integer.sqrt.
  #
  def self.sqrt: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tan(x)    -> Float
  # -->
  # Computes the tangent of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-INFINITY, INFINITY)
  #
  #     Math.tan(0) #=> 0.0
  #
  def self.tan: (Numeric x) -> Float

  # <!--
  #   rdoc-file=math.c
  #   - Math.tanh(x)    -> Float
  # -->
  # Computes the hyperbolic tangent of `x` (expressed in radians).
  #
  # Domain: (-INFINITY, INFINITY)
  #
  # Codomain: (-1, 1)
  #
  #     Math.tanh(0) #=> 0.0
  #
  def self.tanh: (Numeric x) -> Float
end

# <!-- rdoc-file=math.c -->
# Definition of the mathematical constant E for Euler's number (e) as a Float
# number.
#
Math::E: Float

# <!-- rdoc-file=math.c -->
# Definition of the mathematical constant PI as a Float number.
#
Math::PI: Float

# <!-- rdoc-file=math.c -->
# Raised when a mathematical function is evaluated outside of its domain of
# definition.
#
# For example, since `cos` returns values in the range -1..1, its inverse
# function `acos` is only defined on that interval:
#
#     Math.acos(42)
#
# *produces:*
#
#     Math::DomainError: Numerical argument is out of domain - "acos"
#
class Math::DomainError < StandardError
end

# <!-- rdoc-file=cont.c -->
# Fibers are primitives for implementing light weight cooperative concurrency in
# Ruby. Basically they are a means of creating code blocks that can be paused
# and resumed, much like threads. The main difference is that they are never
# preempted and that the scheduling must be done by the programmer and not the
# VM.
#
# As opposed to other stackless light weight concurrency models, each fiber
# comes with a stack.  This enables the fiber to be paused from deeply nested
# function calls within the fiber block.  See the ruby(1) manpage to configure
# the size of the fiber stack(s).
#
# When a fiber is created it will not run automatically. Rather it must be
# explicitly asked to run using the Fiber#resume method. The code running inside
# the fiber can give up control by calling Fiber.yield in which case it yields
# control back to caller (the caller of the Fiber#resume).
#
# Upon yielding or termination the Fiber returns the value of the last executed
# expression
#
# For instance:
#
#     fiber = Fiber.new do
#       Fiber.yield 1
#       2
#     end
#
#     puts fiber.resume
#     puts fiber.resume
#     puts fiber.resume
#
# *produces*
#
#     1
#     2
#     FiberError: dead fiber called
#
# The Fiber#resume method accepts an arbitrary number of parameters, if it is
# the first call to #resume then they will be passed as block arguments.
# Otherwise they will be the return value of the call to Fiber.yield
#
# Example:
#
#     fiber = Fiber.new do |first|
#       second = Fiber.yield first + 2
#     end
#
#     puts fiber.resume 10
#     puts fiber.resume 1_000_000
#     puts fiber.resume "The fiber will be dead before I can cause trouble"
#
# *produces*
#
#     12
#     1000000
#     FiberError: dead fiber called
#
# ## Non-blocking Fibers
#
# The concept of *non-blocking fiber* was introduced in Ruby 3.0. A non-blocking
# fiber, when reaching a operation that would normally block the fiber (like
# `sleep`, or wait for another process or I/O) will yield control to other
# fibers and allow the *scheduler* to handle blocking and waking up (resuming)
# this fiber when it can proceed.
#
# For a Fiber to behave as non-blocking, it need to be created in Fiber.new with
# `blocking: false` (which is the default), and Fiber.scheduler should be set
# with Fiber.set_scheduler. If Fiber.scheduler is not set in the current thread,
# blocking and non-blocking fibers' behavior is identical.
#
# Ruby doesn't provide a scheduler class: it is expected to be implemented by
# the user and correspond to Fiber::SchedulerInterface.
#
# There is also Fiber.schedule method, which is expected to immediately perform
# the given block in a non-blocking manner. Its actual implementation is up to
# the scheduler.
#
class Fiber < Object
  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.yield(args, ...) -> obj
  # -->
  # Yields control back to the context that resumed the fiber, passing along any
  # arguments that were passed to it. The fiber will resume processing at this
  # point when #resume is called next. Any arguments passed to the next #resume
  # will be the value that this Fiber.yield expression evaluates to.
  #
  def self.yield: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.new(blocking: false) { |*args| ... } -> fiber
  # -->
  # Creates new Fiber. Initially, the fiber is not running and can be resumed with
  # #resume. Arguments to the first #resume call will be passed to the block:
  #
  #     f = Fiber.new do |initial|
  #        current = initial
  #        loop do
  #          puts "current: #{current.inspect}"
  #          current = Fiber.yield
  #        end
  #     end
  #     f.resume(100)     # prints: current: 100
  #     f.resume(1, 2, 3) # prints: current: [1, 2, 3]
  #     f.resume          # prints: current: nil
  #     # ... and so on ...
  #
  # If `blocking: false` is passed to `Fiber.new`, *and* current thread has a
  # Fiber.scheduler defined, the Fiber becomes non-blocking (see "Non-blocking
  # Fibers" section in class docs).
  #
  def initialize: () { () -> untyped } -> void

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.resume(args, ...) -> obj
  # -->
  # Resumes the fiber from the point at which the last Fiber.yield was called, or
  # starts running it if it is the first call to #resume. Arguments passed to
  # resume will be the value of the Fiber.yield expression or will be passed as
  # block parameters to the fiber's block if this is the first #resume.
  #
  # Alternatively, when resume is called it evaluates to the arguments passed to
  # the next Fiber.yield statement inside the fiber's block or to the block value
  # if it runs to completion without any Fiber.yield
  #
  def resume: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.raise                                 -> obj
  #   - fiber.raise(string)                         -> obj
  #   - fiber.raise(exception [, string [, array]]) -> obj
  # -->
  # Raises an exception in the fiber at the point at which the last `Fiber.yield`
  # was called. If the fiber has not been started or has already run to
  # completion, raises `FiberError`. If the fiber is yielding, it is resumed. If
  # it is transferring, it is transferred into. But if it is resuming, raises
  # `FiberError`.
  #
  # With no arguments, raises a `RuntimeError`. With a single `String` argument,
  # raises a `RuntimeError` with the string as a message.  Otherwise, the first
  # parameter should be the name of an `Exception` class (or an object that
  # returns an `Exception` object when sent an `exception` message). The optional
  # second parameter sets the message associated with the exception, and the third
  # parameter is an array of callback information. Exceptions are caught by the
  # `rescue` clause of `begin...end` blocks.
  #
  def raise: () -> untyped
           | (string message) -> untyped
           | (_Exception exception, ?string message, ?Array[String] backtrace) -> untyped
end

# <!-- rdoc-file=gc.c -->
# The ObjectSpace module contains a number of routines that interact with the
# garbage collection facility and allow you to traverse all living objects with
# an iterator.
#
# ObjectSpace also provides support for object finalizers, procs that will be
# called when a specific object is about to be destroyed by garbage collection.
# See the documentation for `ObjectSpace.define_finalizer` for important
# information on how to use this method correctly.
#
#     a = "A"
#     b = "B"
#
#     ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
#     ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })
#
#     a = nil
#     b = nil
#
# *produces:*
#
#     Finalizer two on 537763470
#     Finalizer one on 537763480
#
%a{annotate:rdoc:source:from=gc.c}
module ObjectSpace
  # <!--
  #   rdoc-file=gc.c
  #   - _id2ref(p1)
  # -->
  #
  def self._id2ref: (Integer id) -> untyped

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.count_objects([result_hash]) -> hash
  # -->
  # Counts all objects grouped by type.
  #
  # It returns a hash, such as:
  #     {
  #       :TOTAL=>10000,
  #       :FREE=>3011,
  #       :T_OBJECT=>6,
  #       :T_CLASS=>404,
  #       # ...
  #     }
  #
  # The contents of the returned hash are implementation specific. It may be
  # changed in future.
  #
  # The keys starting with `:T_` means live objects. For example, `:T_ARRAY` is
  # the number of arrays. `:FREE` means object slots which is not used now.
  # `:TOTAL` means sum of above.
  #
  # If the optional argument `result_hash` is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  #     h = {}
  #     ObjectSpace.count_objects(h)
  #     puts h
  #     # => { :TOTAL=>10000, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249 }
  #
  # This method is only expected to work on C Ruby.
  #
  def self.count_objects: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.define_finalizer(obj, aProc=proc())
  # -->
  # Adds *aProc* as a finalizer, to be called after *obj* was destroyed. The
  # object ID of the *obj* will be passed as an argument to *aProc*. If *aProc* is
  # a lambda or method, make sure it can be called with a single argument.
  #
  # The return value is an array `[0, aProc]`.
  #
  # The two recommended patterns are to either create the finaliser proc in a
  # non-instance method where it can safely capture the needed state, or to use a
  # custom callable object that stores the needed state explicitly as instance
  # variables.
  #
  #     class Foo
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, self.class.create_finalizer(data_needed_for_finalization))
  #       end
  #
  #       def self.create_finalizer(data_needed_for_finalization)
  #         proc {
  #           puts "finalizing #{data_needed_for_finalization}"
  #         }
  #       end
  #     end
  #
  #     class Bar
  #      class Remover
  #         def initialize(data_needed_for_finalization)
  #           @data_needed_for_finalization = data_needed_for_finalization
  #         end
  #
  #         def call(id)
  #           puts "finalizing #{@data_needed_for_finalization}"
  #         end
  #       end
  #
  #       def initialize(data_needed_for_finalization)
  #         ObjectSpace.define_finalizer(self, Remover.new(data_needed_for_finalization))
  #       end
  #     end
  #
  # Note that if your finalizer references the object to be finalized it will
  # never be run on GC, although it will still be run at exit. You will get a
  # warning if you capture the object to be finalized as the receiver of the
  # finalizer.
  #
  #     class CapturesSelf
  #       def initialize(name)
  #         ObjectSpace.define_finalizer(self, proc {
  #           # this finalizer will only be run on exit
  #           puts "finalizing #{name}"
  #         })
  #       end
  #     end
  #
  # Also note that finalization can be unpredictable and is never guaranteed to be
  # run except on exit.
  #
  def self.define_finalizer: (untyped obj, ^(Integer id) -> void aProc) -> [ Integer, Proc ]
                           | (untyped obj) { (Integer id) -> void } -> [ Integer, Proc ]

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.each_object([module]) {|obj| ... } -> integer
  #   - ObjectSpace.each_object([module])              -> an_enumerator
  # -->
  # Calls the block once for each living, nonimmediate object in this Ruby
  # process. If *module* is specified, calls the block for only those classes or
  # modules that match (or are a subclass of) *module*. Returns the number of
  # objects found. Immediate objects (`Fixnum`s, `Symbol`s `true`, `false`, and
  # `nil`) are never returned. In the example below, #each_object returns both the
  # numbers we defined and several constants defined in the Math module.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     a = 102.7
  #     b = 95       # Won't be returned
  #     c = 12345678987654321
  #     count = ObjectSpace.each_object(Numeric) {|x| p x }
  #     puts "Total count: #{count}"
  #
  # *produces:*
  #
  #     12345678987654321
  #     102.7
  #     2.71828182845905
  #     3.14159265358979
  #     2.22044604925031e-16
  #     1.7976931348623157e+308
  #     2.2250738585072e-308
  #     Total count: 7
  #
  def self.each_object: (?Module `module`) -> Enumerator[untyped, Integer]
                      | (?Module `module`) { (untyped obj) -> void } -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def self.garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void

  # <!--
  #   rdoc-file=gc.c
  #   - ObjectSpace.undefine_finalizer(obj)
  # -->
  # Removes all finalizers for *obj*.
  #
  def self.undefine_finalizer: [X] (X obj) -> X

  private

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def garbage_collect: (?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool) -> void
end

# <!-- rdoc-file=object.c -->
# Classes in Ruby are first-class objects---each is an instance of class Class.
#
# Typically, you create a new class by using:
#
#     class Name
#      # some code describing the class behavior
#     end
#
# When a new class is created, an object of type Class is initialized and
# assigned to a global constant (Name in this case).
#
# When `Name.new` is called to create a new object, the #new method in Class is
# run by default. This can be demonstrated by overriding #new in Class:
#
#     class Class
#       alias old_new new
#       def new(*args)
#         print "Creating a new ", self.name, "\n"
#         old_new(*args)
#       end
#     end
#
#     class Name
#     end
#
#     n = Name.new
#
# *produces:*
#
#     Creating a new Name
#
# Classes, modules, and objects are interrelated. In the diagram that follows,
# the vertical arrows represent inheritance, and the parentheses metaclasses.
# All metaclasses are instances of the class `Class'.
#                              +---------+             +-...
#                              |         |             |
#              BasicObject-----|-->(BasicObject)-------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#               Object---------|----->(Object)---------|-...
#                  ^           |         ^             |
#                  |           |         |             |
#                  +-------+   |         +--------+    |
#                  |       |   |         |        |    |
#                  |    Module-|---------|--->(Module)-|-...
#                  |       ^   |         |        ^    |
#                  |       |   |         |        |    |
#                  |     Class-|---------|---->(Class)-|-...
#                  |       ^   |         |        ^    |
#                  |       +---+         |        +----+
#                  |                     |
#     obj--->OtherClass---------->(OtherClass)-----------...
#
%a{annotate:rdoc:source:from=object.c}
class Class < Module
  # <!--
  #   rdoc-file=object.c
  #   - Class.new(super_class=Object)               -> a_class
  #   - Class.new(super_class=Object) { |mod| ... } -> a_class
  # -->
  # Creates a new anonymous (unnamed) class with the given superclass (or Object
  # if no parameter is given). You can give a class a name by assigning the class
  # object to a constant.
  #
  # If a block is given, it is passed the class object, and the block is evaluated
  # in the context of this class like #class_eval.
  #
  #     fred = Class.new do
  #       def meth1
  #         "hello"
  #       end
  #       def meth2
  #         "bye"
  #       end
  #     end
  #
  #     a = fred.new     #=> #<#<Class:0x100381890>:0x100376b98>
  #     a.meth1          #=> "hello"
  #     a.meth2          #=> "bye"
  #
  # Assign the class to a constant (name starting uppercase) if you want to treat
  # it like a regular class.
  #
  def initialize: (?Class superclass) ?{ (Class newclass) -> void } -> void

  # <!--
  #   rdoc-file=object.c
  #   - class.allocate()   ->   obj
  # -->
  # Allocates space for a new object of *class*'s class and does not call
  # initialize on the new instance. The returned object must be an instance of
  # *class*.
  #
  #     klass = Class.new do
  #       def initialize(*args)
  #         @initialized = true
  #       end
  #
  #       def initialized?
  #         @initialized || false
  #       end
  #     end
  #
  #     klass.allocate.initialized? #=> false
  #
  def allocate: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - inherited(subclass)
  # -->
  # Callback invoked whenever a subclass of the current class is created.
  #
  # Example:
  #
  #     class Foo
  #       def self.inherited(subclass)
  #         puts "New subclass: #{subclass}"
  #       end
  #     end
  #
  #     class Bar < Foo
  #     end
  #
  #     class Baz < Bar
  #     end
  #
  # *produces:*
  #
  #     New subclass: Bar
  #     New subclass: Baz
  #
  def inherited: (Class arg0) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - class.new(args, ...)    ->  obj
  # -->
  # Calls #allocate to create a new object of *class*'s class, then invokes that
  # object's #initialize method, passing it *args*.  This is the method that ends
  # up getting called whenever an object is constructed using `.new`.
  #
  def new: () -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - subclasses -> array
  # -->
  # Returns an array of classes where the receiver is the direct superclass of the
  # class, excluding singleton classes. The order of the returned array is not
  # defined.
  #
  #     class A; end
  #     class B < A; end
  #     class C < B; end
  #     class D < A; end
  #
  #     A.subclasses        #=> [D, B]
  #     B.subclasses        #=> [C]
  #     C.subclasses        #=> []
  #
  def subclasses: () -> Array[Class]

  # <!--
  #   rdoc-file=object.c
  #   - class.superclass -> a_super_class or nil
  # -->
  # Returns the superclass of *class*, or `nil`.
  #
  #     File.superclass          #=> IO
  #     IO.superclass            #=> Object
  #     Object.superclass        #=> BasicObject
  #     class Foo; end
  #     class Bar < Foo; end
  #     Bar.superclass           #=> Foo
  #
  # Returns nil when the given class does not have a parent class:
  #
  #     BasicObject.superclass   #=> nil
  #
  def superclass: () -> Class?
end

# <!-- rdoc-file=io.c -->
# The IO class is the basis for all input and output in Ruby. An I/O stream may
# be *duplexed* (that is, bidirectional), and so may use more than one native
# operating system stream.
#
# Many of the examples in this section use the File class, the only standard
# subclass of IO. The two classes are closely associated.  Like the File class,
# the Socket library subclasses from IO (such as TCPSocket or UDPSocket).
#
# The Kernel#open method can create an IO (or File) object for these types of
# arguments:
#
# *   A plain string represents a filename suitable for the underlying operating
#     system.
#
# *   A string starting with `"|"` indicates a subprocess. The remainder of the
#     string following the `"|"` is invoked as a process with appropriate
#     input/output channels connected to it.
#
# *   A string equal to `"|-"` will create another Ruby instance as a
#     subprocess.
#
#
# The IO may be opened with different file modes (read-only, write-only) and
# encodings for proper conversion.  See IO.new for these options.  See
# Kernel#open for details of the various command formats described above.
#
# IO.popen, the Open3 library, or  Process#spawn may also be used to communicate
# with subprocesses through an IO.
#
# Ruby will convert pathnames between different operating system conventions if
# possible.  For instance, on a Windows system the filename
# `"/gumby/ruby/test.rb"` will be opened as `"\gumby\ruby\test.rb"`.  When
# specifying a Windows-style filename in a Ruby string, remember to escape the
# backslashes:
#
#     "C:\\gumby\\ruby\\test.rb"
#
# Our examples here will use the Unix-style forward slashes; File::ALT_SEPARATOR
# can be used to get the platform-specific separator character.
#
# The global constant ARGF (also accessible as `$<`) provides an IO-like stream
# which allows access to all files mentioned on the command line (or STDIN if no
# files are mentioned). ARGF#path and its alias ARGF#filename are provided to
# access the name of the file currently being read.
#
# ## io/console
#
# The io/console extension provides methods for interacting with the console.
# The console can be accessed from IO.console or the standard input/output/error
# IO objects.
#
# Requiring io/console adds the following methods:
#
# *   IO::console
# *   IO#raw
# *   IO#raw!
# *   IO#cooked
# *   IO#cooked!
# *   IO#getch
# *   IO#echo=
# *   IO#echo?
# *   IO#noecho
# *   IO#winsize
# *   IO#winsize=
# *   IO#iflush
# *   IO#ioflush
# *   IO#oflush
#
#
# Example:
#
#     require 'io/console'
#     rows, columns = $stdout.winsize
#     puts "Your screen is #{columns} wide and #{rows} tall"
#
# ## Example Files
#
# Many examples here use these filenames and their corresponding files:
#
# *   `t.txt`: A text-only file that is assumed to exist via:
#
#         text = <<~EOT
#           This is line one.
#           This is the second line.
#           This is the third line.
#         EOT
#         File.write('t.txt', text)
#
# *   `t.dat`: A data file that is assumed to exist via:
#
#         data = "\u9990\u9991\u9992\u9993\u9994"
#         f = File.open('t.dat', 'wb:UTF-16')
#         f.write(data)
#         f.close
#
# *   `t.rus`: A Russian-language text file that is assumed to exist via:
#
#         File.write('t.rus', "\u{442 435 441 442}")
#
# *   `t.tmp`: A file that is assumed *not* to exist.
#
#
# ## Modes
#
# A number of IO method calls must or may specify a *mode* for the stream; the
# mode determines how stream is to be accessible, including:
#
# *   Whether the stream is to be read-only, write-only, or read-write.
# *   Whether the stream is positioned at its beginning or its end.
# *   Whether the stream treats data as text-only or binary.
# *   The external and internal encodings.
#
#
# ### Mode Specified as an Integer
#
# When `mode` is an integer it must be one or more (combined by bitwise OR (`|`)
# of the modes defined in File::Constants:
#
# *   `File::RDONLY`: Open for reading only.
# *   `File::WRONLY`: Open for writing only.
# *   `File::RDWR`: Open for reading and writing.
# *   `File::APPEND`: Open for appending only.
# *   `File::CREAT`: Create file if it does not exist.
# *   `File::EXCL`: Raise an exception if `File::CREAT` is given and the file
#     exists.
#
#
# Examples:
#
#     File.new('t.txt', File::RDONLY)
#     File.new('t.tmp', File::RDWR | File::CREAT | File::EXCL)
#
# Note: Method IO#set_encoding does not allow the mode to be specified as an
# integer.
#
# ### Mode Specified As a String
#
# When `mode` is a string it must begin with one of the following:
#
# *   `'r'`: Read-only stream, positioned at the beginning; the stream cannot be
#     changed to writable.
# *   `'w'`: Write-only stream, positioned at the beginning; the stream cannot
#     be changed to readable.
# *   `'a'`: Write-only stream, positioned at the end; every write appends to
#     the end; the stream cannot be changed to readable.
# *   `'r+'`: Read-write stream, positioned at the beginning.
# *   `'w+'`: Read-write stream, positioned at the end.
# *   `'a+'`: Read-write stream, positioned at the end.
#
#
# For a writable file stream (that is, any except read-only), the file is
# truncated to zero if it exists, and is created if it does not exist.
#
# Examples:
#
#     File.open('t.txt', 'r')
#     File.open('t.tmp', 'w')
#
# Either of the following may be suffixed to any of the above:
#
# *   `'t'`: Text data; sets the default external encoding to `Encoding::UTF_8`;
#     on Windows, enables conversion between EOL and CRLF.
# *   `'b'`: Binary data; sets the default external encoding to
#     `Encoding::ASCII_8BIT`; on Windows, suppresses conversion between EOL and
#     CRLF.
#
#
# If neither is given, the stream defaults to text data.
#
# Examples:
#
#     File.open('t.txt', 'rt')
#     File.open('t.dat', 'rb')
#
# The following may be suffixed to any writable mode above:
#
# *   `'x'`: Creates the file if it does not exist; raises an exception if the
#     file exists.
#
#
# Example:
#
#     File.open('t.tmp', 'wx')
#
# Finally, the mode string may specify encodings -- either external encoding
# only or both external and internal encodings -- by appending one or both
# encoding names, separated by colons:
#
#     f = File.new('t.dat', 'rb')
#     f.external_encoding # => #<Encoding:ASCII-8BIT>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => nil
#     f = File.new('t.dat', 'rb:UTF-16:UTF-16')
#     f.external_encoding # => #<Encoding:UTF-16 (dummy)>
#     f.internal_encoding # => #<Encoding:UTF-16>
#
# The numerous encoding names are available in array Encoding.name_list:
#
#     Encoding.name_list.size    # => 175
#     Encoding.name_list.take(3) # => ["ASCII-8BIT", "UTF-8", "US-ASCII"]
#
# ## Encodings
#
# When the external encoding is set, strings read are tagged by that encoding
# when reading, and strings written are converted to that encoding when writing.
#
# When both external and internal encodings are set, strings read are converted
# from external to internal encoding, and strings written are converted from
# internal to external encoding. For further details about transcoding input and
# output, see Encoding.
#
# If the external encoding is `'BOM|UTF-8'`, `'BOM|UTF-16LE'` or
# `'BOM|UTF16-BE'`, Ruby checks for a Unicode BOM in the input document to help
# determine the encoding.  For UTF-16 encodings the file open mode must be
# binary. If the BOM is found, it is stripped and the external encoding from the
# BOM is used.
#
# Note that the BOM-style encoding option is case insensitive, so 'bom|utf-8' is
# also valid.)
#
# ## Open Options
#
# A number of IO methods accept an optional parameter `opts`, which determines
# how a new stream is to be opened:
#
# *   `:mode`: Stream mode.
# *   `:flags`: Integer file open flags; If `mode` is also given, the two are
#     bitwise-ORed.
# *   `:external_encoding`: External encoding for the stream.
# *   `:internal_encoding`: Internal encoding for the stream. `'-'` is a synonym
#     for the default internal encoding. If the value is `nil` no conversion
#     occurs.
# *   `:encoding`: Specifies external and internal encodings as
#     `'extern:intern'`.
# *   `:textmode`: If a truthy value, specifies the mode as text-only, binary
#     otherwise.
# *   `:binmode`: If a truthy value, specifies the mode as binary, text-only
#     otherwise.
# *   `:autoclose`: If a truthy value, specifies that the `fd` will close when
#     the stream closes; otherwise it remains open.
#
#
# Also available are the options offered in String#encode, which may control
# conversion between external internal encoding.
#
# ## Getline Options
#
# A number of IO methods accept optional keyword arguments that determine how a
# stream is to be treated:
#
# *   `:chomp`: If `true`, line separators are omitted; default is  `false`.
#
#
# ## Position
#
# An IO stream has a *position*, which is the non-negative integer offset (in
# bytes) in the stream where the next read or write will occur.
#
# Note that a text stream may have multi-byte characters, so a text stream whose
# position is `n` (*bytes*) may not have `n` *characters* preceding the current
# position -- there may be fewer.
#
# A new stream is initially positioned:
#
# *   At the beginning (position `0`) if its mode is `'r'`, `'w'`, or `'r+'`.
# *   At the end (position `self.size`) if its mode is `'a'`, `'w+'`, or `'a+'`.
#
#
# Methods to query the position:
#
# *   IO#tell and its alias IO#pos return the position for an open stream.
# *   IO#eof? and its alias IO#eof return whether the position is at the end of
#     a readable stream.
#
#
# Reading from a stream usually changes its position:
#
#     f = File.open('t.txt')
#     f.tell     # => 0
#     f.readline # => "This is line one.\n"
#     f.tell     # => 19
#     f.readline # => "This is the second line.\n"
#     f.tell     # => 45
#     f.eof?     # => false
#     f.readline # => "Here's the third line.\n"
#     f.eof?     # => true
#
# Writing to a stream usually changes its position:
#
#     f = File.open('t.tmp', 'w')
#     f.tell         # => 0
#     f.write('foo') # => 3
#     f.tell         # => 3
#     f.write('bar') # => 3
#     f.tell         # => 6
#
# Iterating over a stream usually changes its position:
#
#     f = File.open('t.txt')
#     f.each do |line|
#       p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
#     end
#
# Output:
#
#     "position=19 eof?=false line=This is line one.\n"
#     "position=45 eof?=false line=This is the second line.\n"
#     "position=70 eof?=true line=This is the third line.\n"
#
# The position may also be changed by certain other methods:
#
# *   IO#pos= and IO#seek change the position to a specified offset.
# *   IO#rewind changes the position to the beginning.
#
#
# ## Line Number
#
# A readable IO stream has a *line* *number*, which is the non-negative integer
# line number in the stream where the next read will occur.
#
# A new stream is initially has line number `0`.
#
# Method IO#lineno returns the line number.
#
# Reading lines from a stream usually changes its line number:
#
#     f = File.open('t.txt', 'r')
#     f.lineno   # => 0
#     f.readline # => "This is line one.\n"
#     f.lineno   # => 1
#     f.readline # => "This is the second line.\n"
#     f.lineno   # => 2
#     f.readline # => "Here's the third line.\n"
#     f.lineno   # => 3
#     f.eof?     # => true
#
# Iterating over lines in a stream usually changes its line number:
#
#     f = File.open('t.txt')
#     f.each_line do |line|
#       p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
#     end
#
# Output:
#
#     "position=19 eof?=false line=This is line one.\n"
#     "position=45 eof?=false line=This is the second line.\n"
#     "position=70 eof?=true line=This is the third line.\n"
#
# ## What's Here
#
# First, what's elsewhere. Class IO:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class IO provides methods that are useful for:
#
# *   [Creating](#class-IO-label-Creating)
# *   [Reading](#class-IO-label-Reading)
# *   [Writing](#class-IO-label-Writing)
# *   [Positioning](#class-IO-label-Positioning)
# *   [Iterating](#class-IO-label-Iterating)
# *   [Settings](#class-IO-label-Settings)
# *   [Querying](#class-IO-label-Querying)
# *   [Buffering](#class-IO-label-Buffering)
# *   [Low-Level Access](#class-IO-label-Low-Level+Access)
# *   [Other](#class-IO-label-Other)
#
#
# ### Creating
#
#     ::new (aliased as ::for_fd)
# :       Creates and returns a new IO object for the given integer file
#         descriptor.
#
#     ::open
# :       Creates a new IO object.
#
#     ::pipe
# :       Creates a connected pair of reader and writer IO objects.
#
#     ::popen
# :       Creates an IO object to interact with a subprocess.
#
#     ::select
# :       Selects which given IO instances are ready for reading,
#
#     writing, or have pending exceptions.
#
#
# ### Reading
#
#     ::binread
# :       Returns a binary string with all or a subset of bytes from the given
#         file.
#
#     ::read
# :       Returns a string with all or a subset of bytes from the given file.
#
#     ::readlines
# :       Returns an array of strings, which are the lines from the given file.
#
#     #getbyte
# :       Returns the next 8-bit byte read from `self` as an integer.
#
#     #getc
# :       Returns the next character read from `self` as a string.
#
#     #gets
# :       Returns the line read from `self`.
#
#     #pread
# :       Returns all or the next *n* bytes read from `self`, not updating the
#         receiver's offset.
#
#     #read
# :       Returns all remaining or the next *n* bytes read from `self` for a
#         given *n*.
#
#     #read_nonblock
# :       the next *n* bytes read from `self` for a given *n*, in non-block
#         mode.
#
#     #readbyte
# :       Returns the next byte read from `self`; same as #getbyte, but raises
#         an exception on end-of-file.
#
#     #readchar
# :       Returns the next character read from `self`; same as #getc, but raises
#         an exception on end-of-file.
#
#     #readline
# :       Returns the next line read from `self`; same as #getline, but raises
#         an exception of end-of-file.
#
#     #readlines
# :       Returns an array of all lines read read from `self`.
#
#     #readpartial
# :       Returns up to the given number of bytes from `self`.
#
#
#
# ### Writing
#
#     ::binwrite
# :       Writes the given string to the file at the given filepath, in binary
#         mode.
#
#     ::write
# :       Writes the given string to `self`.
#
#     [:<<](#method-i-3C-3C)
# :       Appends the given string to `self`.
#
#     #print
# :       Prints last read line or given objects to `self`.
#
#     #printf
# :       Writes to `self` based on the given format string and objects.
#
#     #putc
# :       Writes a character to `self`.
#
#     #puts
# :       Writes lines to `self`, making sure line ends with a newline.
#
#     #pwrite
# :       Writes the given string at the given offset, not updating the
#         receiver's offset.
#
#     #write
# :       Writes one or more given strings to `self`.
#
#     #write_nonblock
# :       Writes one or more given strings to `self` in non-blocking mode.
#
#
#
# ### Positioning
#
#     #lineno
# :       Returns the current line number in `self`.
#
#     #lineno=
# :       Sets the line number is `self`.
#
#     #pos (aliased as #tell)
# :       Returns the current byte offset in `self`.
#
#     #pos=
# :       Sets the byte offset in `self`.
#
#     #reopen
# :       Reassociates `self` with a new or existing IO stream.
#
#     #rewind
# :       Positions `self` to the beginning of input.
#
#     #seek
# :       Sets the offset for `self` relative to given position.
#
#
#
# ### Iterating
#
#     ::foreach
# :       Yields each line of given file to the block.
#
#     #each (aliased as #each_line)
# :       Calls the given block with each successive line in `self`.
#
#     #each_byte
# :       Calls the given block with each successive byte in `self` as an
#         integer.
#
#     #each_char
# :       Calls the given block with each successive character in `self` as a
#         string.
#
#     #each_codepoint
# :       Calls the given block with each successive codepoint in `self` as an
#         integer.
#
#
#
# ### Settings
#
#     #autoclose=
# :       Sets whether `self` auto-closes.
#
#     #binmode
# :       Sets `self` to binary mode.
#
#     #close
# :       Closes `self`.
#
#     #close_on_exec=
# :       Sets the close-on-exec flag.
#
#     #close_read
# :       Closes `self` for reading.
#
#     #close_write
# :       Closes `self` for writing.
#
#     #set_encoding
# :       Sets the encoding for `self`.
#
#     #set_encoding_by_bom
# :       Sets the encoding for `self`, based on its Unicode byte-order-mark.
#
#     #sync=
# :       Sets the sync-mode to the given value.
#
#
#
# ### Querying
#
#     #autoclose?
# :       Returns whether `self` auto-closes.
#
#     #binmode?
# :       Returns whether `self` is in binary mode.
#
#     #close_on_exec?
# :       Returns the close-on-exec flag for `self`.
#
#     #closed?
# :       Returns whether `self` is closed.
#
#     #eof? (aliased as #eof)
# :       Returns whether `self` is at end-of-file.
#
#     #external_encoding
# :       Returns the external encoding object for `self`.
#
#     #fileno (aliased as #to_i)
# :       Returns the integer file descriptor for `self`
#
#     #internal_encoding
# :       Returns the internal encoding object for `self`.
#
#     #pid
# :       Returns the process ID of a child process associated with `self`, if
#         `self` was created by ::popen.
#
#     #stat
# :       Returns the File::Stat object containing status information for
#         `self`.
#
#     #sync
# :       Returns whether `self` is in sync-mode.
#
#     #tty (aliased as #isatty)
# :       Returns whether `self` is a terminal.
#
#
#
# ### Buffering
#
#     #fdatasync
# :       Immediately writes all buffered data in `self` to disk.
#
#     #flush
# :       Flushes any buffered data within `self` to the underlying operating
#         system.
#
#     #fsync
# :       Immediately writes all buffered data and attributes in `self` to disk.
#
#     #ungetbyte
# :       Prepends buffer for `self` with given integer byte or string.
#
#     #ungetc
# :       Prepends buffer for `self` with given string.
#
#
#
# ### Low-Level Access
#
#     ::sysopen
# :       Opens the file given by its path, returning the integer file
#         descriptor.
#
#     #advise
# :       Announces the intention to access data from `self` in a specific way.
#
#     #fcntl
# :       Passes a low-level command to the file specified by the given file
#         descriptor.
#
#     #ioctl
# :       Passes a low-level command to the device specified by the given file
#         descriptor.
#
#     #sysread
# :       Returns up to the next *n* bytes read from self using a low-level
#         read.
#
#     #sysseek
# :       Sets the offset for `self`.
#
#     #syswrite
# :       Writes the given string to `self` using a low-level write.
#
#
#
# ### Other
#
#     ::copy_stream
# :       Copies data from a source to a destination, each of which is a
#         filepath or an IO-like object.
#
#     ::try_convert
# :       Returns a new IO object resulting from converting the given object.
#
#     #inspect
# :       Returns the string representation of `self`.
#
%a{annotate:rdoc:source:from=io.c}
class IO < Object
  include File::Constants

  include Enumerable[String]

  # <!--
  #   rdoc-file=io.c
  #   - self << object -> self
  # -->
  # Writes the given `object` to `self`, which must be opened for writing (see
  # [Modes](#class-IO-label-Modes)); returns `self`; if `object` is not a string,
  # it is converted via method `to_s`:
  #
  #     $stdout << 'Hello' << ', ' << 'World!' << "\n"
  #     $stdout << 'foo' << :bar << 2 << "\n"
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  def <<: (_ToS obj) -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.advise(advice, offset=0, len=0) -> nil
  # -->
  # Announce an intention to access data from the current file in a specific
  # pattern. On platforms that do not support the *posix_fadvise(2)* system call,
  # this method is a no-op.
  #
  # *advice* is one of the following symbols:
  #
  # :normal
  # :   No advice to give; the default assumption for an open file.
  # :sequential
  # :   The data will be accessed sequentially with lower offsets read before
  #     higher ones.
  # :random
  # :   The data will be accessed in random order.
  # :willneed
  # :   The data will be accessed in the near future.
  # :dontneed
  # :   The data will not be accessed in the near future.
  # :noreuse
  # :   The data will only be accessed once.
  #
  #
  # The semantics of a piece of advice are platform-dependent. See *man 2
  # posix_fadvise* for details.
  #
  # "data" means the region of the current file that begins at *offset* and
  # extends for *len* bytes. If *len* is 0, the region ends at the last byte of
  # the file. By default, both *offset* and *len* are 0, meaning that the advice
  # applies to the entire file.
  #
  # If an error occurs, one of the following exceptions will be raised:
  #
  # IOError
  # :   The IO stream is closed.
  # Errno::EBADF
  # :   The file descriptor of the current file is invalid.
  # Errno::EINVAL
  # :   An invalid value for *advice* was given.
  # Errno::ESPIPE
  # :   The file descriptor of the current file refers to a FIFO or pipe. (Linux
  #     raises Errno::EINVAL in this case).
  # TypeError
  # :   Either *advice* was not a Symbol, or one of the other arguments was not an
  #     Integer.
  # RangeError
  # :   One of the arguments given was too big/small.
  #
  # This list is not exhaustive; other Errno
  # :   exceptions are also possible.
  #
  def advise: (:normal | :sequential | :random | :willneed | :dontneed | :noreuse advise, ?Integer offset, ?Integer len) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - io.autoclose = bool    -> true or false
  # -->
  # Sets auto-close flag.
  #
  #     f = open("/dev/null")
  #     IO.for_fd(f.fileno)
  #     # ...
  #     f.gets # may cause Errno::EBADF
  #
  #     f = open("/dev/null")
  #     IO.for_fd(f.fileno).autoclose = false
  #     # ...
  #     f.gets # won't cause Errno::EBADF
  #
  def autoclose=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.autoclose?   -> true or false
  # -->
  # Returns `true` if the underlying file descriptor of *ios* will be closed
  # automatically at its finalization, otherwise `false`.
  #
  def autoclose?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.binmode    -> ios
  # -->
  # Puts *ios* into binary mode. Once a stream is in binary mode, it cannot be
  # reset to nonbinary mode.
  #
  # *   newline conversion disabled
  # *   encoding conversion disabled
  # *   content is treated as ASCII-8BIT
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.binmode?    -> true or false
  # -->
  # Returns `true` if *ios* is binmode.
  #
  def binmode?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.close   -> nil
  # -->
  # Closes *ios* and flushes any pending writes to the operating system. The
  # stream is unavailable for any further data operations; an IOError is raised if
  # such an attempt is made. I/O streams are automatically closed when they are
  # claimed by the garbage collector.
  #
  # If *ios* is opened by IO.popen, #close sets `$?`.
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_on_exec = bool    -> true or false
  # -->
  # Sets a close-on-exec flag.
  #
  #     f = open("/dev/null")
  #     f.close_on_exec = true
  #     system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No such file or directory
  #     f.closed?                #=> false
  #
  # Ruby sets close-on-exec flags of all file descriptors by default since Ruby
  # 2.0.0. So you don't need to set by yourself. Also, unsetting a close-on-exec
  # flag can cause file descriptor leak if another thread use fork() and exec()
  # (via system() method for example). If you really needs file descriptor
  # inheritance to child process, use spawn()'s argument such as fd=>fd.
  #
  def close_on_exec=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_on_exec?   -> true or false
  # -->
  # Returns `true` if *ios* will be closed on exec.
  #
  #     f = open("/dev/null")
  #     f.close_on_exec?                 #=> false
  #     f.close_on_exec = true
  #     f.close_on_exec?                 #=> true
  #     f.close_on_exec = false
  #     f.close_on_exec?                 #=> false
  #
  def close_on_exec?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_read    -> nil
  # -->
  # Closes the read end of a duplex I/O stream (i.e., one that contains both a
  # read and a write stream, such as a pipe). Will raise an IOError if the stream
  # is not duplexed.
  #
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_read
  #     f.readlines
  #
  # *produces:*
  #
  #     prog.rb:3:in `readlines': not opened for reading (IOError)
  #      from prog.rb:3
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close_read: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.close_write   -> nil
  # -->
  # Closes the write end of a duplex I/O stream (i.e., one that contains both a
  # read and a write stream, such as a pipe). Will raise an IOError if the stream
  # is not duplexed.
  #
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_write
  #     f.print "nowhere"
  #
  # *produces:*
  #
  #     prog.rb:3:in `write': not opened for writing (IOError)
  #      from prog.rb:3:in `print'
  #      from prog.rb:3
  #
  # Calling this method on closed IO object is just ignored since Ruby 2.3.
  #
  def close_write: () -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.closed?    -> true or false
  # -->
  # Returns `true` if *ios* is completely closed (for duplex streams, both reader
  # and writer), `false` otherwise.
  #
  #     f = File.new("testfile")
  #     f.close         #=> nil
  #     f.closed?       #=> true
  #     f = IO.popen("/bin/sh","r+")
  #     f.close_write   #=> nil
  #     f.closed?       #=> false
  #     f.close_read    #=> nil
  #     f.closed?       #=> true
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.each(sep=$/ [, getline_args])          {|line| block } -> ios
  #   - ios.each(limit [, getline_args])           {|line| block } -> ios
  #   - ios.each(sep, limit [, getline_args])      {|line| block } -> ios
  #   - ios.each(...)                             -> an_enumerator
  #   - ios.each_line(sep=$/ [, getline_args])     {|line| block } -> ios
  #   - ios.each_line(limit [, getline_args])      {|line| block } -> ios
  #   - ios.each_line(sep, limit [, getline_args]) {|line| block } -> ios
  #   - ios.each_line(...)                        -> an_enumerator
  # -->
  # Executes the block for every line in *ios*, where lines are separated by
  # *sep*. *ios* must be opened for reading or an IOError will be raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each {|line| puts "#{f.lineno}: #{line}" }
  #
  # *produces:*
  #
  #     1: This is line one
  #     2: This is line two
  #     3: This is line three
  #     4: And so on...
  #
  # See IO.readlines for details about getline_args.
  #
  def each: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
          | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_byte {|byte| block }  -> ios
  #   - ios.each_byte                  -> an_enumerator
  # -->
  # Calls the given block once for each byte (0..255) in *ios*, passing the byte
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     checksum = 0
  #     f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>
  #     checksum                           #=> 12
  #
  def each_byte: () { (Integer arg0) -> untyped } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_char {|c| block }  -> ios
  #   - ios.each_char               -> an_enumerator
  # -->
  # Calls the given block once for each character in *ios*, passing the character
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each_char {|c| print c, ' ' }   #=> #<File:testfile>
  #
  def each_char: () { (String arg0) -> untyped } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=io.c
  #   - ios.each_codepoint {|c| block }  -> ios
  #   - ios.each_codepoint               -> an_enumerator
  # -->
  # Passes the Integer ordinal of each character in *ios*, passing the codepoint
  # as an argument. The stream must be opened for reading or an IOError will be
  # raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  def each_codepoint: () { (Integer arg0) -> untyped } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=io.c
  #   - eof -> true or false
  # -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](#class-IO-label-Mode).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  # I#eof? is an alias for IO#eof.
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.fcntl(integer_cmd, arg)    -> integer
  # -->
  # Provides a mechanism for issuing low-level commands to control or query
  # file-oriented I/O streams. Arguments and results are platform dependent. If
  # *arg* is a number, its value is passed directly. If it is a string, it is
  # interpreted as a binary sequence of bytes (Array#pack might be a useful way to
  # build this string). On Unix platforms, see `fcntl(2)` for details.  Not
  # implemented on all platforms.
  #
  def fcntl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - fdatasync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's: `fdatasync(2)`, if supported, otherwise via `fsync(2)`, if
  # supported; otherwise raises an exception.
  #
  def fdatasync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - fileno -> integer
  # -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #
  # IO#to_i is an alias for IO#fileno.
  #
  def fileno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - flush -> self
  # -->
  # Flushes data buffered in `self` to the operating system (but does not
  # necessarily flush data buffered in the operating system):
  #
  #     $stdout.print 'no newline' # Not necessarily flushed.
  #     $stdout.flush              # Flushed.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=io.c
  #   - fsync -> 0
  # -->
  # Immediately writes to disk all data buffered in the stream, via the operating
  # system's `fsync(2)`.
  #
  # Note this difference:
  #
  # *   IO#sync=: Ensures that data is flushed from the stream's internal buffers,
  #     but does not guarantee that the operating system actually writes the data
  #     to disk.
  # *   IO#fsync: Ensures both that data is flushed from internal buffers, and
  #     that data is written to disk.
  #
  #
  # Raises an exception if the operating system does not support `fsync(2)`.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - ios.getbyte   -> integer or nil
  # -->
  # Gets the next 8-bit byte (0..255) from *ios*. Returns `nil` if called at end
  # of file.
  #
  #     f = File.new("testfile")
  #     f.getbyte   #=> 84
  #     f.getbyte   #=> 104
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=io.c
  #   - ios.getc   -> string or nil
  # -->
  # Reads a one-character string from *ios*. Returns `nil` if called at end of
  # file.
  #
  #     f = File.new("testfile")
  #     f.getc   #=> "h"
  #     f.getc   #=> "e"
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep = $/, **getline_opts)   -> string or nil
  #   - gets(limit, **getline_opts)      -> string or nil
  #   - gets(sep, limit, **getline_opts) -> string or nil
  # -->
  # Reads and returns data from the stream; assigns the return value to `$_`.
  #
  # With no arguments given, returns the next line as determined by line separator
  # `$/`, or `nil` if none:
  #
  #     f = File.open('t.txt')
  #     f.gets # => "This is line one.\n"
  #     $_     # => "This is line one.\n"
  #     f.gets # => "This is the second line.\n"
  #     f.gets # => "This is the third line.\n"
  #     f.gets # => nil
  #
  # With string argument `sep` given, but not argument `limit`, returns the next
  # line as determined by line separator `sep`, or `nil` if none:
  #
  #     f = File.open('t.txt')
  #     f.gets(' is') # => "This is"
  #     f.gets(' is') # => " line one.\nThis is"
  #     f.gets(' is') # => " the second line.\nThis is"
  #     f.gets(' is') # => " the third line.\n"
  #     f.gets(' is') # => nil
  #
  # Note two special values for `sep`:
  #
  # *   `nil`: The entire stream is read and returned.
  # *   `''` (empty string): The next "paragraph" is read and returned, the
  #     paragraph separator being two successive line separators.
  #
  #
  # With integer argument `limit` given, returns up to `limit+1` bytes:
  #
  #     # Text with 1-byte characters.
  #     File.open('t.txt') {|f| f.gets(1) } # => "T"
  #     File.open('t.txt') {|f| f.gets(2) } # => "Th"
  #     File.open('t.txt') {|f| f.gets(3) } # => "Thi"
  #     File.open('t.txt') {|f| f.gets(4) } # => "This"
  #     # No more than one line.
  #     File.open('t.txt') {|f| f.gets(17) } # => "This is line one."
  #     File.open('t.txt') {|f| f.gets(18) } # => "This is line one.\n"
  #     File.open('t.txt') {|f| f.gets(19) } # => "This is line one.\n"
  #
  #     # Text with 2-byte characters, which will not be split.
  #     File.open('t.rus') {|f| f.gets(1).size } # => 1
  #     File.open('t.rus') {|f| f.gets(2).size } # => 1
  #     File.open('t.rus') {|f| f.gets(3).size } # => 2
  #     File.open('t.rus') {|f| f.gets(4).size } # => 2
  #
  # With arguments `sep` and `limit`, combines the two behaviors above:
  #
  # *   Returns the next line as determined by line separator `sep`, or `nil` if
  #     none.
  # *   But returns no more than `limit+1` bytes.
  #
  #
  # For all forms above, trailing optional keyword arguments may be given; see
  # [Getline Options](#class-IO-label-Getline+Options):
  #
  #     f = File.open('t.txt')
  #     # Chomp the lines.
  #     f.gets(chomp: true) # => "This is line one."
  #     f.gets(chomp: true) # => "This is the second line."
  #     f.gets(chomp: true) # => "This is the third line."
  #     f.gets(chomp: true) # => nil
  #
  def gets: (?String sep, ?Integer limit) -> String?

  # <!--
  #   rdoc-file=io.c
  #   - IO.new(fd [, mode] [, opt])   -> io
  # -->
  # Returns a new IO object (a stream) for the given integer file descriptor `fd`
  # and `mode` string.  `opt` may be used to specify parts of `mode` in a more
  # readable fashion.  See also IO.sysopen and IO.for_fd.
  #
  # IO.new is called by various File and IO opening methods such as IO::open,
  # Kernel#open, and File::open.
  #
  # ### Open Mode
  #
  # When `mode` is an integer it must be combination of the modes defined in
  # File::Constants (`File::RDONLY`, `File::WRONLY|File::CREAT`). See the open(2)
  # man page for more information.
  #
  # When `mode` is a string it must be in one of the following forms:
  #
  #     fmode
  #     fmode ":" ext_enc
  #     fmode ":" ext_enc ":" int_enc
  #     fmode ":" "BOM|UTF-*"
  #
  # `fmode` is an IO open mode string, `ext_enc` is the external encoding for the
  # IO and `int_enc` is the internal encoding.
  #
  # #### IO Open Mode
  #
  # Ruby allows the following open modes:
  #
  #     "r"  Read-only, starts at beginning of file  (default mode).
  #
  #     "r+" Read-write, starts at beginning of file.
  #
  #     "w"  Write-only, truncates existing file
  #          to zero length or creates a new file for writing.
  #
  #     "w+" Read-write, truncates existing file to zero length
  #          or creates a new file for reading and writing.
  #
  #     "a"  Write-only, each write call appends data at end of file.
  #          Creates a new file for writing if file does not exist.
  #
  #     "a+" Read-write, each write call appends data at end of file.
  #          Creates a new file for reading and writing if file does
  #          not exist.
  #
  # The following modes must be used separately, and along with one or more of the
  # modes seen above.
  #
  #     "b"  Binary file mode
  #          Suppresses EOL <-> CRLF conversion on Windows. And
  #          sets external encoding to ASCII-8BIT unless explicitly
  #          specified.
  #
  #     "t"  Text file mode
  #
  # The exclusive access mode ("x") can be used together with "w" to ensure the
  # file is created. Errno::EEXIST is raised when it already exists. It may not be
  # supported with all kinds of streams (e.g. pipes).
  #
  # When the open mode of original IO is read only, the mode cannot be changed to
  # be writable.  Similarly, the open mode cannot be changed from write only to
  # readable.
  #
  # When such a change is attempted the error is raised in different locations
  # according to the platform.
  #
  # ### IO Encoding
  #
  # When `ext_enc` is specified, strings read will be tagged by the encoding when
  # reading, and strings output will be converted to the specified encoding when
  # writing.
  #
  # When `ext_enc` and `int_enc` are specified read strings will be converted from
  # `ext_enc` to `int_enc` upon input, and written strings will be converted from
  # `int_enc` to `ext_enc` upon output.  See Encoding for further details of
  # transcoding on input and output.
  #
  # If "BOM|UTF-8", "BOM|UTF-16LE" or "BOM|UTF16-BE" are used, Ruby checks for a
  # Unicode BOM in the input document to help determine the encoding.  For UTF-16
  # encodings the file open mode must be binary.  When present, the BOM is
  # stripped and the external encoding from the BOM is used.  When the BOM is
  # missing the given Unicode encoding is used as `ext_enc`.  (The BOM-set
  # encoding option is case insensitive, so "bom|utf-8" is also valid.)
  #
  # ### Options
  #
  # `opt` can be used instead of `mode` for improved readability.  The following
  # keys are supported:
  #
  # :mode
  # :   Same as `mode` parameter
  #
  # :flags
  # :   Specifies file open flags as integer. If `mode` parameter is given, this
  #     parameter will be bitwise-ORed.
  #
  # :external_encoding
  # :   External encoding for the IO.
  #
  # :internal_encoding
  # :   Internal encoding for the IO.  "-" is a synonym for the default internal
  #     encoding.
  #
  #     If the value is `nil` no conversion occurs.
  #
  # :encoding
  # :   Specifies external and internal encodings as "extern:intern".
  #
  # :textmode
  # :   If the value is truth value, same as "t" in argument `mode`.
  #
  # :binmode
  # :   If the value is truth value, same as "b" in argument `mode`.
  #
  # :autoclose
  # :   If the value is `false`, the `fd` will be kept open after this IO instance
  #     gets finalized.
  #
  #
  # Also, `opt` can have same keys in String#encode for controlling conversion
  # between the external encoding and the internal encoding.
  #
  # ### Example 1
  #
  #     fd = IO.sysopen("/dev/tty", "w")
  #     a = IO.new(fd,"w")
  #     $stderr.puts "Hello"
  #     a.puts "World"
  #
  # Produces:
  #
  #     Hello
  #     World
  #
  # ### Example 2
  #
  #     require 'fcntl'
  #
  #     fd = STDERR.fcntl(Fcntl::F_DUPFD)
  #     io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
  #     io.puts "Hello, World!"
  #
  #     fd = STDERR.fcntl(Fcntl::F_DUPFD)
  #     io = IO.new(fd, mode: 'w', cr_newline: true,
  #                 external_encoding: Encoding::UTF_16LE)
  #     io.puts "Hello, World!"
  #
  # Both of above print "Hello, World!" in UTF-16LE to standard error output with
  # converting EOL generated by #puts to CR.
  #
  def initialize: (Integer fd, ?Integer mode, ?Integer opt) -> void

  # <!--
  #   rdoc-file=io.c
  #   - inspect -> string
  # -->
  # Returns a string representation of `self`:
  #
  #     f = File.open('t.txt')
  #     f.inspect # => "#<File:t.txt>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=io.c
  #   - io.internal_encoding   -> encoding
  # -->
  # Returns the Encoding of the internal string if conversion is specified.
  # Otherwise returns `nil`.
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=io.c
  #   - ios.ioctl(integer_cmd, arg)    -> integer
  # -->
  # Provides a mechanism for issuing low-level commands to control or query I/O
  # devices. Arguments and results are platform dependent. If *arg* is a number,
  # its value is passed directly. If it is a string, it is interpreted as a binary
  # sequence of bytes. On Unix platforms, see `ioctl(2)` for details. Not
  # implemented on all platforms.
  #
  def ioctl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.isatty   -> true or false
  #   - ios.tty?     -> true or false
  # -->
  # Returns `true` if *ios* is associated with a terminal device (tty), `false`
  # otherwise.
  #
  #     File.new("testfile").isatty   #=> false
  #     File.new("/dev/tty").isatty   #=> true
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.lineno    -> integer
  # -->
  # Returns the current line number in *ios*.  The stream must be opened for
  # reading. #lineno counts the number of times #gets is called rather than the
  # number of newlines encountered.  The two values will differ if #gets is called
  # with a separator other than newline.
  #
  # Methods that use `$/` like #each, #lines and #readline will also increment
  # #lineno.
  #
  # See also the `$.` variable.
  #
  #     f = File.new("testfile")
  #     f.lineno   #=> 0
  #     f.gets     #=> "This is line one\n"
  #     f.lineno   #=> 1
  #     f.gets     #=> "This is line two\n"
  #     f.lineno   #=> 2
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.lineno = integer    -> integer
  # -->
  # Manually sets the current line number to the given value. `$.` is updated only
  # on the next read.
  #
  #     f = File.new("testfile")
  #     f.gets                     #=> "This is line one\n"
  #     $.                         #=> 1
  #     f.lineno = 1000
  #     f.lineno                   #=> 1000
  #     $.                         #=> 1         # lineno of last read
  #     f.gets                     #=> "This is line two\n"
  #     $.                         #=> 1001      # lineno of last read
  #
  def lineno=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - pid -> integer or nil
  # -->
  # Returns the process ID of a child process associated with the stream, which
  # will have been set by IO#popen, or `nil` if the stream was not created by
  # IO#popen:
  #
  #     pipe = IO.popen("-")
  #     if pipe
  #       $stderr.puts "In parent, child pid is #{pipe.pid}"
  #     else
  #       $stderr.puts "In child, pid is #{$$}"
  #     end
  #
  # Output:
  #
  #     In child, pid is 26209
  #     In parent, child pid is 26209
  #
  def pid: () -> Integer

  # <!-- rdoc-file=io.c -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](#class-IO-label-Position)):
  #
  #     f = File.new('t.txt')
  #     f.tell     # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #
  # Related: IO#pos=, IO#seek.
  #
  # IO#pos is an alias for IO#tell.
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - pos = new_position -> new_position
  # -->
  # Seeks to the given `new_position` (in bytes); see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.pos = 20 # => 20
  #     f.tell     # => 20
  #
  # Related: IO#seek, IO#tell.
  #
  def pos=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.print               -> nil
  #   - ios.print(obj, ...)     -> nil
  # -->
  # Writes the given object(s) to *ios*. Returns `nil`.
  #
  # The stream must be opened for writing. Each given object that isn't a string
  # will be converted by calling its `to_s` method. When called without arguments,
  # prints the contents of `$_`.
  #
  # If the output field separator (`$,`) is not `nil`, it is inserted between
  # objects. If the output record separator (`$\`) is not `nil`, it is appended to
  # the output.
  #
  #     $stdout.print("This is ", 100, " percent.\n")
  #
  # *produces:*
  #
  #     This is 100 percent.
  #
  def print: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.printf(format_string [, obj, ...])   -> nil
  # -->
  # Formats and writes to *ios*, converting parameters under control of the format
  # string. See Kernel#sprintf for details.
  #
  def printf: (String format_string, *untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.putc(obj)    -> obj
  # -->
  # If *obj* is Numeric, write the character whose code is the least-significant
  # byte of *obj*.  If *obj* is String, write the first character of *obj* to
  # *ios*.  Otherwise, raise TypeError.
  #
  #     $stdout.putc "A"
  #     $stdout.putc 65
  #
  # *produces:*
  #
  #     AA
  #
  def putc: (Numeric | String arg0) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.puts(obj, ...)    -> nil
  # -->
  # Writes the given object(s) to *ios*. Writes a newline after any that do not
  # already end with a newline sequence. Returns `nil`.
  #
  # The stream must be opened for writing. If called with an array argument,
  # writes each element on a new line. Each given object that isn't a string or
  # array will be converted by calling its `to_s` method. If called without
  # arguments, outputs a single newline.
  #
  #     $stdout.puts("this", "is", ["a", "test"])
  #
  # *produces:*
  #
  #     this
  #     is
  #     a
  #     test
  #
  # Note that `puts` always uses newlines and is not affected by the output record
  # separator (`$\`).
  #
  def puts: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - read(maxlen = nil)             -> string or nil
  #   - read(maxlen = nil, out_string) -> out_string or nil
  # -->
  # Reads bytes from the stream (in binary mode):
  #
  # *   If `maxlen` is `nil`, reads all bytes.
  # *   Otherwise reads `maxlen` bytes, if available.
  # *   Otherwise reads all bytes.
  #
  #
  # Returns a string (either a new string or the given `out_string`) containing
  # the bytes read. The encoding of the string depends on both `maxLen` and
  # `out_string`:
  #
  # *   `maxlen` is `nil`: uses internal encoding of `self` (regardless of whether
  #     `out_string` was given).
  # *   `maxlen` not `nil`:
  #
  #     *   `out_string` given: encoding of `out_string` not modified.
  #     *   `out_string` not given: ASCII-8BIT is used.
  #
  #
  #
  # **Without Argument `out_string`**
  #
  # When argument `out_string` is omitted, the returned value is a new string:
  #
  #     f = File.new('t.txt')
  #     f.read
  #     # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     f.rewind
  #     f.read(40)      # => "This is line one.\r\nThis is the second li"
  #     f.read(40)      # => "ne.\r\nThis is the third line.\r\n"
  #     f.read(40)      # => nil
  #
  # If `maxlen` is zero, returns an empty string.
  #
  # ** With Argument `out_string`**
  #
  # When argument `out_string` is given, the returned value is `out_string`, whose
  # content is replaced:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'      # => "foo"
  #     f.read(nil, s) # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     s              # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
  #     f.rewind
  #     s = 'bar'
  #     f.read(40, s)  # => "This is line one.\r\nThis is the second li"
  #     s              # => "This is line one.\r\nThis is the second li"
  #     s = 'baz'
  #     f.read(40, s)  # => "ne.\r\nThis is the third line.\r\n"
  #     s              # => "ne.\r\nThis is the third line.\r\n"
  #     s = 'bat'
  #     f.read(40, s)  # => nil
  #     s              # => ""
  #
  # Note that this method behaves like the fread() function in C. This means it
  # retries to invoke read(2) system calls to read data with the specified maxlen
  # (or until EOF).
  #
  # This behavior is preserved even if the stream is in non-blocking mode. (This
  # method is non-blocking-flag insensitive as other methods.)
  #
  # If you need the behavior like a single read(2) system call, consider
  # #readpartial, #read_nonblock, and #sysread.
  #
  def read: (?int? length, ?string outbuf) -> String?

  # <!--
  #   rdoc-file=io.rb
  #   - ios.read_nonblock(maxlen [, options])              -> string
  #   - ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf
  # -->
  # Reads at most *maxlen* bytes from *ios* using the read(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # If the optional *outbuf* argument is present, it must reference a String,
  # which will receive the data. The *outbuf* will contain only the received data
  # after the method call even if it is not empty at the beginning.
  #
  # read_nonblock just calls the read(2) system call. It causes all errors the
  # read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller
  # should care such errors.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying read_nonblock.
  #
  # read_nonblock causes EOFError on EOF.
  #
  # On some platforms, such as Windows, non-blocking mode is not supported on IO
  # objects other than sockets. In such cases, Errno::EBADF will be raised.
  #
  # If the read byte buffer is not empty, read_nonblock reads from the buffer like
  # readpartial. In this case, the read(2) system call is not called.
  #
  # When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock
  # should not be called until io is readable for avoiding busy loop. This can be
  # done as follows.
  #
  #     # emulates blocking read (readpartial).
  #     begin
  #       result = io.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io])
  #       retry
  #     end
  #
  # Although IO#read_nonblock doesn't raise IO::WaitWritable.
  # OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. If IO and SSL
  # should be used polymorphically, IO::WaitWritable should be rescued too. See
  # the document of OpenSSL::Buffering#read_nonblock for sample code.
  #
  # Note that this method is identical to readpartial except the non-blocking flag
  # is set.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # read_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead. At EOF, it will return nil instead of raising
  # EOFError.
  #
  def read_nonblock: (int len, ?string buf, ?exception: true) -> String
                   | (int len, ?string buf, exception: false) -> (String | :wait_readable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - ios.readbyte   -> integer
  # -->
  # Reads a byte as with IO#getbyte, but raises an EOFError on end of file.
  #
  def readbyte: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.readchar   -> string
  # -->
  # Reads a one-character string from *ios*. Raises an EOFError on end of file.
  #
  #     f = File.new("testfile")
  #     f.readchar   #=> "h"
  #     f.readchar   #=> "e"
  #
  def readchar: () -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.readline(sep=$/ [, getline_args])     -> string
  #   - ios.readline(limit [, getline_args])      -> string
  #   - ios.readline(sep, limit [, getline_args]) -> string
  # -->
  # Reads a line as with IO#gets, but raises an EOFError on end of file.
  #
  def readline: (?String sep, ?Integer limit) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.readlines(sep=$/ [, getline_args])     -> array
  #   - ios.readlines(limit [, getline_args])      -> array
  #   - ios.readlines(sep, limit [, getline_args]) -> array
  # -->
  # Reads all of the lines in *ios*, and returns them in an array. Lines are
  # separated by the optional *sep*. If *sep* is `nil`, the rest of the stream is
  # returned as a single record. If the first argument is an integer, or an
  # optional second argument is given, the returning string would not be longer
  # than the given value in bytes. The stream must be opened for reading or an
  # IOError will be raised.
  #
  #     f = File.new("testfile")
  #     f.readlines[0]   #=> "This is line one\n"
  #
  #     f = File.new("testfile", chomp: true)
  #     f.readlines[0]   #=> "This is line one"
  #
  # See IO.readlines for details about getline_args.
  #
  def readlines: (?String sep, ?Integer limit) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - readpartial(maxlen)             -> string
  #   - readpartial(maxlen, out_string) -> out_string
  # -->
  # Reads up to `maxlen` bytes from the stream; returns a string (either a new
  # string or the given `out_string`). Its encoding is:
  #
  # *   The unchanged encoding of `out_string`, if `out_string` is given.
  # *   ASCII-8BIT, otherwise.
  #
  # *   Contains `maxlen` bytes from the stream, if available.
  # *   Otherwise contains all available bytes, if any available.
  # *   Otherwise is an empty string.
  #
  #
  # With the single non-negative integer argument `maxlen` given, returns a new
  # string:
  #
  #     f = File.new('t.txt')
  #     f.readpartial(30) # => "This is line one.\nThis is the"
  #     f.readpartial(30) # => " second line.\nThis is the thi"
  #     f.readpartial(30) # => "rd line.\n"
  #     f.eof             # => true
  #     f.readpartial(30) # Raises EOFError.
  #
  # With both argument `maxlen` and string argument `out_string` given, returns
  # modified `out_string`:
  #
  #     f = File.new('t.txt')
  #     s = 'foo'
  #     f.readpartial(30, s) # => "This is line one.\nThis is the"
  #     s = 'bar'
  #     f.readpartial(0, s)  # => ""
  #
  # This method is useful for a stream such as a pipe, a socket, or a tty. It
  # blocks only when no data is immediately available. This means that it blocks
  # only when *all* of the following are true:
  #
  # *   The byte buffer in the stream is empty.
  # *   The content of the stream is empty.
  # *   The stream is not at EOF.
  #
  #
  # When blocked, the method waits for either more data or EOF on the stream:
  #
  # *   If more data is read, the method returns the data.
  # *   If EOF is reached, the method raises EOFError.
  #
  #
  # When not blocked, the method responds immediately:
  #
  # *   Returns data from the buffer if there is any.
  # *   Otherwise returns data from the stream if there is any.
  # *   Otherwise raises EOFError if the stream has reached EOF.
  #
  #
  # Note that this method is similar to sysread. The differences are:
  #
  # *   If the byte buffer is not empty, read from the byte buffer instead of
  #     "sysread for buffered IO (IOError)".
  # *   It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial
  #     meets EWOULDBLOCK and EINTR by read system call, readpartial retries the
  #     system call.
  #
  #
  # The latter means that readpartial is non-blocking-flag insensitive. It blocks
  # on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking
  # mode.
  #
  # Examples:
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc".
  #     r.readpartial(4096)      # => "abc"      ""                ""
  #     r.readpartial(4096)      # (Blocks because buffer and pipe are empty.)
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << 'abc'               #               ""                "abc"
  #     w.close                  #               ""                "abc" EOF
  #     r.readpartial(4096)      # => "abc"      ""                 EOF
  #     r.readpartial(4096)      # raises EOFError
  #
  #     #                        # Returned      Buffer Content    Pipe Content
  #     r, w = IO.pipe           #
  #     w << "abc\ndef\n"        #               ""                "abc\ndef\n"
  #     r.gets                   # => "abc\n"    "def\n"           ""
  #     w << "ghi\n"             #               "def\n"           "ghi\n"
  #     r.readpartial(4096)      # => "def\n"    ""                "ghi\n"
  #     r.readpartial(4096)      # => "ghi\n"    ""                ""
  #
  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.reopen(other_IO)             -> ios
  #   - ios.reopen(path, mode [, opt])   -> ios
  # -->
  # Reassociates *ios* with the I/O stream given in *other_IO* or to a new stream
  # opened on *path*. This may dynamically change the actual class of this stream.
  # The `mode` and `opt` parameters accept the same values as IO.open.
  #
  #     f1 = File.new("testfile")
  #     f2 = File.new("testfile")
  #     f2.readlines[0]   #=> "This is line one\n"
  #     f2.reopen(f1)     #=> #<File:testfile>
  #     f2.readlines[0]   #=> "This is line one\n"
  #
  def reopen: (IO other_IO_or_path) -> IO
            | (String other_IO_or_path, ?String mode_str) -> IO

  # <!--
  #   rdoc-file=io.c
  #   - rewind -> 0
  # -->
  # Repositions the stream to its beginning, setting both the position and the
  # line number to zero; see [Position](#class-IO-label-Position) and [Line
  # Number](#class-IO-label-Line+Number):
  #
  #     f = File.open('t.txt')
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #     f.lineno   # => 1
  #     f.rewind   # => 0
  #     f.tell     # => 0
  #     f.lineno   # => 0
  #
  # Note that this method cannot be used with streams such as pipes, ttys, and
  # sockets.
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - seek(offset, whence = IO::SEEK_SET) -> 0
  # -->
  # Seeks to the position given by integer `offset` (see
  # [Position](#class-IO-label-Position)) and constant `whence`, which is one of:
  #
  # *   `:CUR` or `IO::SEEK_CUR`: Repositions the stream to its current position
  #     plus the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :CUR)  # => 0
  #         f.tell            # => 20
  #         f.seek(-10, :CUR) # => 0
  #         f.tell            # => 10
  #
  # *   `:END` or `IO::SEEK_END`: Repositions the stream to its end plus the given
  #     `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(0, :END)   # => 0  # Repositions to stream end.
  #         f.tell            # => 70
  #         f.seek(-20, :END) # => 0
  #         f.tell            # => 50
  #         f.seek(-40, :END) # => 0
  #         f.tell            # => 30
  #
  # *   `:SET` or `IO:SEEK_SET`: Repositions the stream to the given `offset`:
  #
  #         f = File.open('t.txt')
  #         f.tell            # => 0
  #         f.seek(20, :SET) # => 0
  #         f.tell           # => 20
  #         f.seek(40, :SET) # => 0
  #         f.tell           # => 40
  #
  #
  # Related: IO#pos=, IO#tell.
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - io.set_encoding(ext_enc)                -> io
  #   - io.set_encoding("ext_enc:int_enc")      -> io
  #   - io.set_encoding(ext_enc, int_enc)       -> io
  #   - io.set_encoding("ext_enc:int_enc", opt) -> io
  #   - io.set_encoding(ext_enc, int_enc, opt)  -> io
  # -->
  # If single argument is specified, read string from io is tagged with the
  # encoding specified.  If encoding is a colon separated two encoding names
  # "A:B", the read string is converted from encoding A (external encoding) to
  # encoding B (internal encoding), then tagged with B.  If two arguments are
  # specified, those must be encoding objects or encoding names, and the first one
  # is the external encoding, and the second one is the internal encoding. If the
  # external encoding and the internal encoding is specified, optional hash
  # argument specify the conversion option.
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=io.c
  #   - ios.set_encoding_by_bom   -> encoding or nil
  # -->
  # Checks if `ios` starts with a BOM, and then consumes it and sets the external
  # encoding.  Returns the result encoding if found, or nil.  If `ios` is not
  # binmode or its encoding has been set already, an exception will be raised.
  #
  #     File.write("bom.txt", "\u{FEFF}abc")
  #     ios = File.open("bom.txt", "rb")
  #     ios.set_encoding_by_bom    #=>  #<Encoding:UTF-8>
  #
  #     File.write("nobom.txt", "abc")
  #     ios = File.open("nobom.txt", "rb")
  #     ios.set_encoding_by_bom    #=>  nil
  #
  def set_encoding_by_bom: () -> Encoding?

  # <!--
  #   rdoc-file=file.c
  #   - ios.stat    -> stat
  # -->
  # Returns status information for *ios* as an object of type File::Stat.
  #
  #     f = File.new("testfile")
  #     s = f.stat
  #     "%o" % s.mode   #=> "100644"
  #     s.blksize       #=> 4096
  #     s.atime         #=> Wed Apr 09 08:53:54 CDT 2003
  #
  def stat: () -> File::Stat

  # <!--
  #   rdoc-file=io.c
  #   - sync -> true or false
  # -->
  # Returns the current sync mode of the stream. When sync mode is true, all
  # output is immediately flushed to the underlying operating system and is not
  # buffered by Ruby internally. See also #fsync.
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - sync = boolean -> boolean
  # -->
  # Sets the *sync* *mode* for the stream to the given value; returns the given
  # value.
  #
  # Values for the sync mode:
  #
  # *   `true`: All output is immediately flushed to the underlying operating
  #     system and is not buffered internally.
  # *   `false`: Output may be buffered internally.
  #
  #
  # Example;
  #
  #     f = File.open('t.tmp', 'w')
  #     f.sync # => false
  #     f.sync = true
  #     f.sync # => true
  #
  # Related: IO#fsync.
  #
  def sync=: (boolish) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - ios.sysread(maxlen[, outbuf])    -> string
  # -->
  # Reads *maxlen* bytes from *ios* using a low-level read and returns them as a
  # string.  Do not mix with other methods that read from *ios* or you may get
  # unpredictable results.
  #
  # If the optional *outbuf* argument is present, it must reference a String,
  # which will receive the data. The *outbuf* will contain only the received data
  # after the method call even if it is not empty at the beginning.
  #
  # Raises SystemCallError on error and EOFError at end of file.
  #
  #     f = File.new("testfile")
  #     f.sysread(16)   #=> "This is line one"
  #
  def sysread: (Integer maxlen, String outbuf) -> String

  # <!--
  #   rdoc-file=io.c
  #   - ios.sysseek(offset, whence=IO::SEEK_SET)   -> integer
  # -->
  # Seeks to a given *offset* in the stream according to the value of *whence*
  # (see IO#seek for values of *whence*). Returns the new offset into the file.
  #
  #     f = File.new("testfile")
  #     f.sysseek(-13, IO::SEEK_END)   #=> 53
  #     f.sysread(10)                  #=> "And so on."
  #
  def sysseek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - ios.syswrite(string)   -> integer
  # -->
  # Writes the given string to *ios* using a low-level write. Returns the number
  # of bytes written. Do not mix with other methods that write to *ios* or you may
  # get unpredictable results. Raises SystemCallError on error.
  #
  #     f = File.new("out", "w")
  #     f.syswrite("ABCDEF")   #=> 6
  #
  def syswrite: (_ToS arg0) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - tell -> integer
  # -->
  # Returns the current position (in bytes) in `self` (see
  # [Position](#class-IO-label-Position)):
  #
  #     f = File.new('t.txt')
  #     f.tell     # => 0
  #     f.readline # => "This is line one.\n"
  #     f.tell     # => 19
  #
  # Related: IO#pos=, IO#seek.
  #
  # IO#pos is an alias for IO#tell.
  #
  def tell: () -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - to_io -> self
  # -->
  # Returns `self`.
  #
  def to_io: () -> self

  # <!-- rdoc-file=io.c -->
  # Returns `true` if *ios* is associated with a terminal device (tty), `false`
  # otherwise.
  #
  #     File.new("testfile").isatty   #=> false
  #     File.new("/dev/tty").isatty   #=> true
  #
  def tty?: () -> bool

  # <!--
  #   rdoc-file=io.c
  #   - ios.ungetbyte(string)   -> nil
  #   - ios.ungetbyte(integer)  -> nil
  # -->
  # Pushes back bytes (passed as a parameter) onto *ios*, such that a subsequent
  # buffered read will return it. It is only guaranteed to support a single byte,
  # and only if ungetbyte or ungetc has not already been called on *ios* since the
  # previous read of at least a single byte from *ios*. However, it can support
  # additional bytes if there is space in the internal buffer to allow for it.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     b = f.getbyte              #=> 0x38
  #     f.ungetbyte(b)             #=> nil
  #     f.getbyte                  #=> 0x38
  #
  # If given an integer, only uses the lower 8 bits of the integer as the byte to
  # push.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetbyte(0x102)         #=> nil
  #     f.getbyte                  #=> 0x2
  #
  # Calling this method prepends to the existing buffer, even if the method has
  # already been called previously:
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetbyte("ab")          #=> nil
  #     f.ungetbyte("cd")          #=> nil
  #     f.read(5)                  #=> "cdab8"
  #
  # Has no effect with unbuffered reads (such as IO#sysread).
  #
  def ungetbyte: (String | Integer arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - ios.ungetc(integer)  -> nil
  #   - ios.ungetc(string)   -> nil
  # -->
  # Pushes back characters (passed as a parameter) onto *ios*, such that a
  # subsequent buffered read will return it. It is only guaranteed to support a
  # single byte, and only if ungetbyte or ungetc has not already been called on
  # *ios* since the previous read of at least a single byte from *ios*. However,
  # it can support additional bytes if there is space in the internal buffer to
  # allow for it.
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     c = f.getc                 #=> "8"
  #     f.ungetc(c)                #=> nil
  #     f.getc                     #=> "8"
  #
  # If given an integer, the integer must represent a valid codepoint in the
  # external encoding of *ios*.
  #
  # Calling this method prepends to the existing buffer, even if the method has
  # already been called previously:
  #
  #     f = File.new("testfile")   #=> #<File:testfile>
  #     f.ungetc("ab")             #=> nil
  #     f.ungetc("cd")             #=> nil
  #     f.read(5)                  #=> "cdab8"
  #
  # Has no effect with unbuffered reads (such as IO#sysread).
  #
  def ungetc: (String arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - write(*objects) -> integer
  # -->
  # Writes each of the given `objects` to `self`, which must be opened for writing
  # (see [Modes](#class-IO-label-Modes)); returns the total number bytes written;
  # each of `objects` that is not a string is converted via method `to_s`:
  #
  #     $stdout.write('Hello', ', ', 'World!', "\n") # => 14
  #     $stdout.write('foo', :bar, 2, "\n")          # => 8
  #
  # Output:
  #
  #     Hello, World!
  #     foobar2
  #
  def write: (*_ToS string) -> Integer

  # <!--
  #   rdoc-file=io.rb
  #   - ios.write_nonblock(string)   -> integer
  #   - ios.write_nonblock(string [, options])   -> integer
  # -->
  # Writes the given string to *ios* using the write(2) system call after
  # O_NONBLOCK is set for the underlying file descriptor.
  #
  # It returns the number of bytes written.
  #
  # write_nonblock just calls the write(2) system call. It causes all errors the
  # write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result
  # may also be smaller than string.length (partial write). The caller should care
  # such errors and partial write.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for
  # retrying write_nonblock.
  #
  #     # Creates a pipe.
  #     r, w = IO.pipe
  #
  #     # write_nonblock writes only 65536 bytes and return 65536.
  #     # (The pipe size is 65536 bytes on this environment.)
  #     s = "a" * 100000
  #     p w.write_nonblock(s)     #=> 65536
  #
  #     # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
  #     p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)
  #
  # If the write buffer is not empty, it is flushed at first.
  #
  # When write_nonblock raises an exception kind of IO::WaitWritable,
  # write_nonblock should not be called until io is writable for avoiding busy
  # loop. This can be done as follows.
  #
  #     begin
  #       result = io.write_nonblock(string)
  #     rescue IO::WaitWritable, Errno::EINTR
  #       IO.select(nil, [io])
  #       retry
  #     end
  #
  # Note that this doesn't guarantee to write all data in string. The length
  # written is reported as result and it should be checked later.
  #
  # On some platforms such as Windows, write_nonblock is not supported according
  # to the kind of the IO object. In such cases, write_nonblock raises
  # `Errno::EBADF`.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # write_nonblock should not raise an IO::WaitWritable exception, but return the
  # symbol `:wait_writable` instead.
  #
  def write_nonblock: (_ToS s, ?exception: true) -> Integer
                    | (_ToS s, exception: false) -> (Integer | :wait_writable | nil)

  # <!--
  #   rdoc-file=io.c
  #   - IO.binread(name, [length [, offset]])   -> string
  #   - File.binread(name, [length [, offset]]) -> string
  # -->
  # Opens the file, optionally seeks to the given *offset*, then returns *length*
  # bytes (defaulting to the rest of the file). #binread ensures the file is
  # closed before returning.  The open mode would be `"rb:ASCII-8BIT"`.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.binread to disable the behavior of
  # subprocess invocation.
  #
  #     File.binread("testfile")           #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #     File.binread("testfile", 20)       #=> "This is line one\nThi"
  #     File.binread("testfile", 20, 10)   #=> "ne one\nThis is line "
  #     IO.binread("| cat testfile")       #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.binread: (String name, ?Integer length, ?Integer offset) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.binwrite(name, string, [offset])               -> integer
  #   - IO.binwrite(name, string, [offset], open_args)    -> integer
  #   - File.binwrite(name, string, [offset])             -> integer
  #   - File.binwrite(name, string, [offset], open_args)  -> integer
  # -->
  # Same as IO.write except opening the file in binary mode and ASCII-8BIT
  # encoding (`"wb:ASCII-8BIT"`).
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.binwrite to disable the behavior of
  # subprocess invocation.
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.binwrite: (String name, _ToS string, ?Integer offset, ?mode: String mode) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.copy_stream(src, dst)
  #   - IO.copy_stream(src, dst, copy_length)
  #   - IO.copy_stream(src, dst, copy_length, src_offset)
  # -->
  # IO.copy_stream copies *src* to *dst*. *src* and *dst* is either a filename or
  # an IO-like object. IO-like object for *src* should have #readpartial or #read
  # method.  IO-like object for *dst* should have #write method. (Specialized
  # mechanisms, such as sendfile system call, may be used on appropriate
  # situation.)
  #
  # This method returns the number of bytes copied.
  #
  # If optional arguments are not given, the start position of the copy is the
  # beginning of the filename or the current file offset of the IO. The end
  # position of the copy is the end of file.
  #
  # If *copy_length* is given, No more than *copy_length* bytes are copied.
  #
  # If *src_offset* is given, it specifies the start position of the copy.
  #
  # When *src_offset* is specified and *src* is an IO, IO.copy_stream doesn't move
  # the current file offset.
  #
  def self.copy_stream: (String | _Reader | _ReaderPartial src, String | _Writer dst, ?Integer copy_length, ?Integer src_offset) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.popen([env,] cmd, mode="r" [, opt])               -> io
  #   - IO.popen([env,] cmd, mode="r" [, opt]) {|io| block } -> obj
  # -->
  # Runs the specified command as a subprocess; the subprocess's standard input
  # and output will be connected to the returned IO object.
  #
  # The PID of the started process can be obtained by IO#pid method.
  #
  # *cmd* is a string or an array as follows.
  #
  #     cmd:
  #       "-"                                      : fork
  #       commandline                              : command line string which is passed to a shell
  #       [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
  #       [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
  #     (env and opts are optional.)
  #
  # If *cmd* is a `String` ```-`'', then a new instance of Ruby is started as the
  # subprocess.
  #
  # If *cmd* is an `Array` of `String`, then it will be used as the subprocess's
  # `argv` bypassing a shell. The array can contain a hash at first for
  # environments and a hash at last for options similar to #spawn.
  #
  # The default mode for the new file object is ``r'', but *mode* may be set to
  # any of the modes listed in the description for class IO. The last argument
  # *opt* qualifies *mode*.
  #
  #     # set IO encoding
  #     IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|
  #       euc_jp_string = nkf_io.read
  #     }
  #
  #     # merge standard output and standard error using
  #     # spawn option.  See the document of Kernel.spawn.
  #     IO.popen(["ls", "/", :err=>[:child, :out]]) {|ls_io|
  #       ls_result_with_error = ls_io.read
  #     }
  #
  #     # spawn options can be mixed with IO options
  #     IO.popen(["ls", "/"], :err=>[:child, :out]) {|ls_io|
  #       ls_result_with_error = ls_io.read
  #     }
  #
  # Raises exceptions which IO.pipe and Kernel.spawn raise.
  #
  # If a block is given, Ruby will run the command as a child connected to Ruby
  # with a pipe. Ruby's end of the pipe will be passed as a parameter to the
  # block. At the end of block, Ruby closes the pipe and sets `$?`. In this case
  # IO.popen returns the value of the block.
  #
  # If a block is given with a *cmd* of ```-`'', the block will be run in two
  # separate processes: once in the parent, and once in a child. The parent
  # process will be passed the pipe object as a parameter to the block, the child
  # version of the block will be passed `nil`, and the child's standard in and
  # standard out will be connected to the parent through the pipe. Not available
  # on all platforms.
  #
  #     f = IO.popen("uname")
  #     p f.readlines
  #     f.close
  #     puts "Parent is #{Process.pid}"
  #     IO.popen("date") {|f| puts f.gets }
  #     IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}
  #     p $?
  #     IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|
  #       f.puts "bar"; f.close_write; puts f.gets
  #     }
  #
  # *produces:*
  #
  #     ["Linux\n"]
  #     Parent is 21346
  #     Thu Jan 15 22:41:19 JST 2009
  #     21346 is here, f is #<IO:fd 3>
  #     21352 is here, f is nil
  #     #<Process::Status: pid 21352 exit 0>
  #     <foo>bar;zot;
  #
  def self.popen: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=io.c
  #   - IO.read(name, [length [, offset]] [, opt])   -> string
  #   - File.read(name, [length [, offset]] [, opt]) -> string
  # -->
  # Opens the file, optionally seeks to the given `offset`, then returns `length`
  # bytes (defaulting to the rest of the file).  #read ensures the file is closed
  # before returning.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.read to disable the behavior of subprocess
  # invocation.
  #
  # ### Options
  #
  # The options hash accepts the following keys:
  #
  # :encoding
  # :   string or encoding
  #
  #     Specifies the encoding of the read string.  `:encoding` will be ignored if
  #     `length` is specified.  See Encoding.aliases for possible encodings.
  #
  # :mode
  # :   string or integer
  #
  #     Specifies the *mode* argument for open().  It must start with an "r",
  #     otherwise it will cause an error. See IO.new for the list of possible
  #     modes.
  #
  # :open_args
  # :   array
  #
  #     Specifies arguments for open() as an array.  This key can not be used in
  #     combination with either `:encoding` or `:mode`.
  #
  #
  # Examples:
  #
  #     File.read("testfile")            #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
  #     File.read("testfile", 20)        #=> "This is line one\nThi"
  #     File.read("testfile", 20, 10)    #=> "ne one\nThis is line "
  #     File.read("binfile", mode: "rb") #=> "\xF7\x00\x00\x0E\x12"
  #     IO.read("|ls -a")                #=> ".\n..\n"...
  #
  def self.read: (String name, ?Integer length, ?Integer offset, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode) -> String

  # <!--
  #   rdoc-file=io.c
  #   - IO.readlines(name, sep=$/ [, getline_args, open_args])     -> array
  #   - IO.readlines(name, limit [, getline_args, open_args])      -> array
  #   - IO.readlines(name, sep, limit [, getline_args, open_args]) -> array
  #   - File.readlines(name, sep=$/ [, getline_args, open_args])     -> array
  #   - File.readlines(name, limit [, getline_args, open_args])      -> array
  #   - File.readlines(name, sep, limit [, getline_args, open_args]) -> array
  # -->
  # Reads the entire file specified by *name* as individual lines, and returns
  # those lines in an array. Lines are separated by *sep*.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.readlines to disable the behavior of
  # subprocess invocation.
  #
  #     a = File.readlines("testfile")
  #     a[0]   #=> "This is line one\n"
  #
  #     b = File.readlines("testfile", chomp: true)
  #     b[0]   #=> "This is line one"
  #
  #     IO.readlines("|ls -a")     #=> [".\n", "..\n", ...]
  #
  # If the last argument is a hash, it's the keyword argument to open.
  #
  # ### Options for getline
  #
  # The options hash accepts the following keys:
  #
  # :chomp
  # :   When the optional `chomp` keyword argument has a true value, `\n`, `\r`,
  #     and `\r\n` will be removed from the end of each line.
  #
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.readlines: (String name, ?String sep, ?Integer limit, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode, ?chomp: boolish) -> ::Array[String]

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil
  # -->
  # Calls select(2) system call. It monitors given arrays of IO objects, waits
  # until one or more of IO objects are ready for reading, are ready for writing,
  # and have pending exceptions respectively, and returns an array that contains
  # arrays of those IO objects.  It will return `nil` if optional *timeout* value
  # is given and no IO object is ready in *timeout* seconds.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after nonblocking methods such as
  # #read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
  # extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
  # caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
  # should wait for reading.  If IO::WaitWritable is raised, the caller should
  # wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of nonblocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of nonblocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process. See
  # select(2) manual on GNU/Linux system.
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # ### Parameters
  # read_array
  # :   an array of IO objects that wait until ready for read
  # write_array
  # :   an array of IO objects that wait until ready for write
  # error_array
  # :   an array of IO objects that wait for exceptions
  # timeout
  # :   a numeric value in second
  #
  #
  # ### Example
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # *produces:*
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self.select: [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array) -> [ Array[X], Array[Y], Array[Z] ]
                 | [X, Y, Z] (::Array[X & io]? read_array, ?::Array[Y & io]? write_array, ?::Array[Z & io]? error_array, Numeric? timeout) -> [ Array[X], Array[Y], Array[Z] ]?

  # <!--
  #   rdoc-file=io.c
  #   - IO.sysopen(path, [mode, [perm]])  -> integer
  # -->
  # Opens the given path, returning the underlying file descriptor as a Integer.
  #
  #     IO.sysopen("testfile")   #=> 3
  #
  def self.sysopen: (String path, ?String mode, ?String perm) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.try_convert(object) -> new_io or nil
  # -->
  # Attempts to convert `object` into an IO object via method `to_io`; returns the
  # new IO object if successful, or `nil` otherwise:
  #
  #     IO.try_convert(STDOUT)   # => #<IO:<STDOUT>>
  #     IO.try_convert(ARGF)     # => #<IO:<STDIN>>
  #     IO.try_convert('STDOUT') # => nil
  #
  def self.try_convert: (untyped arg0) -> IO?

  # <!--
  #   rdoc-file=io.c
  #   - IO.write(name, string [, offset])           -> integer
  #   - IO.write(name, string [, offset] [, opt])   -> integer
  #   - File.write(name, string [, offset])         -> integer
  #   - File.write(name, string [, offset] [, opt]) -> integer
  # -->
  # Opens the file, optionally seeks to the given *offset*, writes *string*, then
  # returns the length written.  #write ensures the file is closed before
  # returning.  If *offset* is not given in write mode, the file is truncated.
  # Otherwise, it is not truncated.
  #
  # If `name` starts with a pipe character (`"|"`) and the receiver is the IO
  # class, a subprocess is created in the same way as Kernel#open, and its output
  # is returned. Consider to use File.write to disable the behavior of subprocess
  # invocation.
  #
  #     File.write("testfile", "0123456789", 20)  #=> 10
  #     # File could contain:  "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"
  #     File.write("testfile", "0123456789")      #=> 10
  #     # File would now read: "0123456789"
  #     IO.write("|tr a-z A-Z", "abc")            #=> 3
  #     # Prints "ABC" to the standard output
  #
  # If the last argument is a hash, it specifies options for the internal open().
  # It accepts the following keys:
  #
  # :encoding
  # :   string or encoding
  #
  #     Specifies the encoding of the read string. See Encoding.aliases for
  #     possible encodings.
  #
  # :mode
  # :   string or integer
  #
  #     Specifies the *mode* argument for open().  It must start with "w", "a", or
  #     "r+", otherwise it will cause an error. See IO.new for the list of
  #     possible modes.
  #
  # :perm
  # :   integer
  #
  #     Specifies the *perm* argument for open().
  #
  # :open_args
  # :   array
  #
  #     Specifies arguments for open() as an array. This key can not be used in
  #     combination with other keys.
  #
  #
  # See also IO.read for details about `name` and open_args.
  #
  def self.write: (String name, _ToS arg0, ?Integer offset, ?external_encoding: String external_encoding, ?internal_encoding: String internal_encoding, ?encoding: String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: String mode) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - IO.for_fd(fd, mode [, opt])    -> io
  # -->
  # Synonym for IO.new.
  #
  def self.for_fd: (int fd, ?string | int mode, **untyped opt) -> instance

  # <!--
  #   rdoc-file=io.c
  #   - IO.open(fd, mode="r" [, opt])                -> io
  #   - IO.open(fd, mode="r" [, opt]) {|io| block }  -> obj
  # -->
  # With no associated block, IO.open is a synonym for IO.new.  If the optional
  # code block is given, it will be passed `io` as an argument, and the IO object
  # will automatically be closed when the block terminates. In this instance,
  # IO.open returns the value of the block.
  #
  # See IO.new for a description of the `fd`, `mode` and `opt` parameters.
  #
  alias self.open self.for_fd

  # <!--
  #   rdoc-file=io.c
  #   - IO.open(fd, mode="r" [, opt])                -> io
  #   - IO.open(fd, mode="r" [, opt]) {|io| block }  -> obj
  # -->
  # With no associated block, IO.open is a synonym for IO.new.  If the optional
  # code block is given, it will be passed `io` as an argument, and the IO object
  # will automatically be closed when the block terminates. In this instance,
  # IO.open returns the value of the block.
  #
  # See IO.new for a description of the `fd`, `mode` and `opt` parameters.
  #
  def self.open: [A] (int fd, ?string | int mode, **untyped opt) { (instance) -> A } -> A
               | ...

  def bytes: () { (Integer arg0) -> untyped } -> self
           | () -> ::Enumerator[Integer, self]

  def chars: () { (String arg0) -> untyped } -> self
           | () -> ::Enumerator[String, self]

  def codepoints: () { (Integer arg0) -> untyped } -> self
                | () -> ::Enumerator[Integer, self]

  # <!-- rdoc-file=io.c -->
  # Executes the block for every line in *ios*, where lines are separated by
  # *sep*. *ios* must be opened for reading or an IOError will be raised.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     f = File.new("testfile")
  #     f.each {|line| puts "#{f.lineno}: #{line}" }
  #
  # *produces:*
  #
  #     1: This is line one
  #     2: This is line two
  #     3: This is line three
  #     4: And so on...
  #
  # See IO.readlines for details about getline_args.
  #
  def each_line: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
               | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!-- rdoc-file=io.c -->
  # Returns `true` if the stream is positioned at its end, `false` otherwise; see
  # [Position](#class-IO-label-Position):
  #
  #     f = File.open('t.txt')
  #     f.eof           # => false
  #     f.seek(0, :END) # => 0
  #     f.eof           # => true
  #
  # Raises an exception unless the stream is opened for reading; see
  # [Mode](#class-IO-label-Mode).
  #
  # If `self` is a stream such as pipe or socket, this method blocks until the
  # other end sends some data or closes it:
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.close }
  #     r.eof? # => true # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     Thread.new { sleep 1; w.puts "a" }
  #     r.eof?  # => false # After 1-second wait.
  #
  #     r, w = IO.pipe
  #     r.eof?  # blocks forever
  #
  # Note that this method reads data to the input byte buffer.  So IO#sysread may
  # not behave as you intend with IO#eof?, unless you call IO#rewind first (which
  # is not available for some streams).
  #
  # I#eof? is an alias for IO#eof.
  #
  def eof?: () -> bool

  def lines: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
           | (?String sep, ?Integer limit) -> ::Enumerator[String, self]

  # <!-- rdoc-file=io.c -->
  # Returns the integer file descriptor for the stream:
  #
  #     $stdin.fileno             # => 0
  #     $stdout.fileno            # => 1
  #     $stderr.fileno            # => 2
  #     File.open('t.txt').fileno # => 10
  #
  # IO#to_i is an alias for IO#fileno.
  #
  def to_i: () -> Integer
end

IO::APPEND: Integer

IO::BINARY: Integer

IO::CREAT: Integer

IO::DIRECT: Integer

IO::DSYNC: Integer

IO::EXCL: Integer

IO::FNM_CASEFOLD: Integer

IO::FNM_DOTMATCH: Integer

IO::FNM_EXTGLOB: Integer

IO::FNM_NOESCAPE: Integer

IO::FNM_PATHNAME: Integer

IO::FNM_SHORTNAME: Integer

IO::FNM_SYSCASE: Integer

IO::LOCK_EX: Integer

IO::LOCK_NB: Integer

IO::LOCK_SH: Integer

IO::LOCK_UN: Integer

IO::NOATIME: Integer

IO::NOCTTY: Integer

IO::NOFOLLOW: Integer

IO::NONBLOCK: Integer

IO::NULL: String

IO::RDONLY: Integer

IO::RDWR: Integer

IO::RSYNC: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the current position
#
IO::SEEK_CUR: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next location containing data
#
IO::SEEK_DATA: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the end
#
IO::SEEK_END: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position to the next hole
#
IO::SEEK_HOLE: Integer

# <!-- rdoc-file=io.c -->
# Set I/O position from the beginning
#
IO::SEEK_SET: Integer

IO::SHARE_DELETE: Integer

IO::SYNC: Integer

IO::TMPFILE: Integer

IO::TRUNC: Integer

IO::WRONLY: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EAGAIN. see IO.select.
#
class IO::EAGAINWaitReadable < Errno::EAGAIN
  include IO::WaitReadable
end

IO::EAGAINWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EAGAIN. see IO.select.
#
class IO::EAGAINWaitWritable < Errno::EAGAIN
  include IO::WaitWritable
end

IO::EAGAINWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitReadable < Errno::EINPROGRESS
  include IO::WaitReadable
end

IO::EINPROGRESSWaitReadable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for writing by EINPROGRESS. see IO.select.
#
class IO::EINPROGRESSWaitWritable < Errno::EINPROGRESS
  include IO::WaitWritable
end

IO::EINPROGRESSWaitWritable::Errno: Integer

# <!-- rdoc-file=io.c -->
# exception to wait for reading. see IO.select.
#
module IO::WaitReadable
end

# <!-- rdoc-file=io.c -->
# exception to wait for writing. see IO.select.
#
module IO::WaitWritable
end

# <!-- rdoc-file=numeric.c -->
# Numeric is the class from which all higher-level numeric classes should
# inherit.
#
# Numeric allows instantiation of heap-allocated objects. Other core numeric
# classes such as Integer are implemented as immediates, which means that each
# Integer is a single immutable object which is always passed by value.
#
#     a = 1
#     1.object_id == a.object_id   #=> true
#
# There can only ever be one instance of the integer `1`, for example. Ruby
# ensures this by preventing instantiation. If duplication is attempted, the
# same instance is returned.
#
#     Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
#     1.dup                            #=> 1
#     1.object_id == 1.dup.object_id   #=> true
#
# For this reason, Numeric should be used when defining other numeric classes.
#
# Classes which inherit from Numeric must implement `coerce`, which returns a
# two-member Array containing an object that has been coerced into an instance
# of the new class and `self` (see #coerce).
#
# Inheriting classes should also implement arithmetic operator methods (`+`,
# `-`, `*` and `/`) and the `<=>` operator (see Comparable). These methods may
# rely on `coerce` to ensure interoperability with instances of other numeric
# classes.
#
#     class Tally < Numeric
#       def initialize(string)
#         @string = string
#       end
#
#       def to_s
#         @string
#       end
#
#       def to_i
#         @string.size
#       end
#
#       def coerce(other)
#         [self.class.new('|' * other.to_i), self]
#       end
#
#       def <=>(other)
#         to_i <=> other.to_i
#       end
#
#       def +(other)
#         self.class.new('|' * (to_i + other.to_i))
#       end
#
#       def -(other)
#         self.class.new('|' * (to_i - other.to_i))
#       end
#
#       def *(other)
#         self.class.new('|' * (to_i * other.to_i))
#       end
#
#       def /(other)
#         self.class.new('|' * (to_i / other.to_i))
#       end
#     end
#
#     tally = Tally.new('||')
#     puts tally * 2            #=> "||||"
#     puts tally > 1            #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class Numeric:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Numeric provides methods for:
#
# *   [Querying](#class-Numeric-label-Querying)
# *   [Comparing](#class-Numeric-label-Comparing)
# *   [Converting](#class-Numeric-label-Converting)
# *   [Other](#class-Numeric-label-Other)
#
#
# ### Querying
#
#     #finite?
# :       Returns true unless `self` is infinite or not a number.
#
#     #infinite?
# :       Returns -1, `nil` or +1, depending on whether `self` is
#         `-Infinity<tt>, finite, or <tt>+Infinity`.
#
#     #integer?
# :       Returns whether `self` is an integer.
#
#     #negative?
# :       Returns whether `self` is negative.
#
#     #nonzero?
# :       Returns whether `self` is not zero.
#
#     #positive?
# :       Returns whether `self` is positive.
#
#     #real?
# :       Returns whether `self` is a real value.
#
#     #zero?
# :       Returns whether `self` is zero.
#
#
#
# ### Comparing
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns:
#
#     *   -1 if  `self` is less than the given value.
#     *   0 if `self` is equal to the given value.
#     *   1 if `self` is greater than the given value.
#     *   `nil` if `self` and the given value are not comparable.
#
#     #eql?
# :       Returns whether `self` and the given value have the same value and
#         type.
#
#
#
# ### Converting
#
#     #% (aliased as #modulo)
# :       Returns the remainder of `self` divided by the given value.
#
#     #-@
# :       Returns the value of `self`, negated.
#
#     #abs (aliased as #magnitude)
# :       Returns the absolute value of `self`.
#
#     #abs2
# :       Returns the square of `self`.
#
#     #angle (aliased as #arg and #phase)
# :       Returns 0 if `self` is positive, Math::PI otherwise.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`, to a
#         given precision.
#
#     #coerce
# :       Returns array `[coerced_self, coerced_other]` for the given other
#         value.
#
#     #conj (aliased as #conjugate)
# :       Returns the complex conjugate of `self`.
#
#     #denominator
# :       Returns the denominator (always positive) of the Rational
#         representation of `self`.
#
#     #div
# :       Returns the value of `self` divided by the given value and converted
#         to an integer.
#
#     #divmod
# :       Returns array `[quotient, modulus]` resulting from dividing `self` the
#         given divisor.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given divisor.
#
#     #floor
# :       Returns the largest number less than or equal to `self`, to a given
#         precision.
#
#     #i
# :       Returns the Complex object `Complex(0, self)`. the given value.
#
#     #imaginary (aliased as #imag)
# :       Returns the imaginary part of the `self`.
#
#     #numerator
# :       Returns the numerator of the Rational representation of `self`; has
#         the same sign as `self`.
#
#     #polar
# :       Returns the array `[self.abs, self.arg]`.
#
#     #quo
# :       Returns the value of `self` divided by the given value.
#
#     #real
# :       Returns the real part of `self`.
#
#     #rect (aliased as #rectangular)
# :       Returns the array `[self, 0]`.
#
#     #remainder
# :       Returns `self-arg*(self/arg).truncate` for the given `arg`.
#
#     #round
# :       Returns the value of `self` rounded to the nearest value for the given
#         a precision.
#
#     #to_c
# :       Returns the Complex representation of `self`.
#
#     #to_int
# :       Returns the Integer representation of `self`, truncating if necessary.
#
#     #truncate
# :       Returns `self` truncated (toward zero) to a given precision.
#
#
#
# ### Other
#
#     #clone
# :       Returns `self`; does not allow freezing.
#
#     #dup (aliased as #+@)
# :       Returns `self`.
#
#     #step
# :       Invokes the given block with the sequence of specified numbers.
#
class Numeric
  include Comparable

  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_numeric
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     c % n
  #     c-n*(c/n).floor
  #     c.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  # Numeric#modulo is an alias for Numeric#%.
  #
  def %: (Numeric) -> Numeric

  # Performs addition: the class of the resulting object depends on the class of
  # `numeric`.
  #
  def +: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - +self -> self
  # -->
  # Returns `self`.
  #
  def +@: () -> Numeric

  # Performs subtraction: the class of the resulting object depends on the class
  # of `numeric`.
  #
  def -: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - -self -> numeric
  # -->
  # Unary Minus---Returns the receiver, negated.
  #
  def -@: () -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other -> zero or nil
  # -->
  # Returns zero if `self` is the same as `other`, `nil` otherwise.
  #
  # No subclass in the Ruby Core or Standard Library uses this implementation.
  #
  def <=>: (Numeric other) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - abs -> numeric
  # -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  # Numeric#magnitude is an alias for Numeric#abs.
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.abs2  ->  real
  # -->
  # Returns square of self.
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  def angle: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.arg    ->  0 or float
  #   - num.angle  ->  0 or float
  #   - num.phase  ->  0 or float
  # -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias arg angle

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(digits = 0) -> integer or float
  # -->
  # Returns the smallest number that is greater than or equal to `self` with a
  # precision of `digits` decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#ceil.
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - coerce(other) -> array
  # -->
  # Returns a 2-element array containing two numeric elements, formed from the two
  # operands `self` and `other`, of a common compatible type.
  #
  # Of the Core and Standard Library classes, Integer, Rational, and Complex use
  # this implementation.
  #
  # Examples:
  #
  #     i = 2                    # => 2
  #     i.coerce(3)              # => [3, 2]
  #     i.coerce(3.0)            # => [3.0, 2.0]
  #     i.coerce(Rational(1, 2)) # => [0.5, 2.0]
  #     i.coerce(Complex(3, 4))  # Raises RangeError.
  #
  #     r = Rational(5, 2)       # => (5/2)
  #     r.coerce(2)              # => [(2/1), (5/2)]
  #     r.coerce(2.0)            # => [2.0, 2.5]
  #     r.coerce(Rational(2, 3)) # => [(2/3), (5/2)]
  #     r.coerce(Complex(3, 4))  # => [(3+4i), ((5/2)+0i)]
  #
  #     c = Complex(2, 3)        # => (2+3i)
  #     c.coerce(2)              # => [(2+0i), (2+3i)]
  #     c.coerce(2.0)            # => [(2.0+0i), (2+3i)]
  #     c.coerce(Rational(1, 2)) # => [((1/2)+0i), (2+3i)]
  #     c.coerce(Complex(3, 4))  # => [(3+4i), (2+3i)]
  #
  # Raises an exception if any type conversion fails.
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  # <!-- rdoc-file=complex.c -->
  # Returns self.
  #
  def conj: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.conj       ->  self
  #   - num.conjugate  ->  self
  # -->
  # Returns self.
  #
  def conjugate: () -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - num.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - div(other) -> integer
  # -->
  # Returns the quotient `self/other` as an integer (via `floor`), using method
  # `/` in the derived class of `self`. (Numeric itself does not define method
  # `/`.)
  #
  # Of the Core and Standard Library classes, Float, Rational, and Complex use
  # this implementation.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor                  # Quotient
  #     r = self % other                        # Remainder
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # Examples:
  #
  #     Rational(11, 1).divmod(4)               # => [2, (3/1)]
  #     Rational(11, 1).divmod(-4)              # => [-3, (-1/1)]
  #     Rational(-11, 1).divmod(4)              # => [-3, (1/1)]
  #     Rational(-11, 1).divmod(-4)             # => [2, (-3/1)]
  #
  #     Rational(12, 1).divmod(4)               # => [3, (0/1)]
  #     Rational(12, 1).divmod(-4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(4)              # => [-3, (0/1)]
  #     Rational(-12, 1).divmod(-4)             # => [3, (0/1)]
  #
  #     Rational(13, 1).divmod(4.0)             # => [3, 1.0]
  #     Rational(13, 1).divmod(Rational(4, 11)) # => [35, (3/11)]
  #
  def divmod: (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - eql?(other) -> true or false
  # -->
  # Returns `true` if `self` and `other` are the same type and have equal values.
  #
  # Of the Core and Standard Library classes, only Integer, Rational, and Complex
  # use this implementation.
  #
  # Examples:
  #
  #     1.eql?(1)              # => true
  #     1.eql?(1.0)            # => false
  #     1.eql?(Rational(1, 1)) # => false
  #     1.eql?(Complex(1, 0))  # => false
  #
  # Method `eql?` is different from +==+ in that `eql?` requires matching types,
  # while +==+ does not.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(other) -> float
  # -->
  # Returns the quotient `self/other` as a float, using method `/` in the derived
  # class of `self`. (Numeric itself does not define method `/`.)
  #
  # Of the Core and Standard Library classes, only BigDecimal uses this
  # implementation.
  #
  def fdiv: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.finite?  ->  true or false
  # -->
  # Returns `true` if `num` is a finite number, otherwise returns `false`.
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(digits = 0) -> integer or float
  # -->
  # Returns the largest number that is less than or equal to `self` with a
  # precision of `digits` decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#floor.
  #
  def floor: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - i -> complex
  # -->
  # Returns `Complex(0, self)`:
  #
  #     2.i              # => (0+2i)
  #     -2.i             # => (0-2i)
  #     2.0.i            # => (0+2.0i)
  #     Rational(1, 2).i # => (0+(1/2)*i)
  #     Complex(3, 4).i  # Raises NoMethodError.
  #
  def i: () -> Complex

  # <!-- rdoc-file=complex.c -->
  # Returns zero.
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.imag       ->  0
  #   - num.imaginary  ->  0
  # -->
  # Returns zero.
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.infinite?  ->  -1, 1, or nil
  # -->
  # Returns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
  # or `+Infinity`.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.integer?  ->  true or false
  # -->
  # Returns `true` if `num` is an Integer.
  #
  #     1.0.integer?   #=> false
  #     1.integer?     #=> true
  #
  def integer?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the absolute value of `self`.
  #
  #     12.abs        #=> 12
  #     (-34.56).abs  #=> 34.56
  #     -34.56.abs    #=> 34.56
  #
  # Numeric#magnitude is an alias for Numeric#abs.
  #
  alias magnitude abs

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # Of the Core and Standard Library classes, only Rational uses this
  # implementation.
  #
  # For Rational `r` and real number `n`, these expressions are equivalent:
  #
  #     c % n
  #     c-n*(c/n).floor
  #     c.divmod(n)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     r = Rational(1, 2)    # => (1/2)
  #     r2 = Rational(2, 3)   # => (2/3)
  #     r % r2                # => (1/2)
  #     r % 2                 # => (1/2)
  #     r % 2.0               # => 0.5
  #
  #     r = Rational(301,100) # => (301/100)
  #     r2 = Rational(7,5)    # => (7/5)
  #     r % r2                # => (21/100)
  #     r % -r2               # => (-119/100)
  #     (-r) % r2             # => (119/100)
  #     (-r) %-r2             # => (-21/100)
  #
  # Numeric#modulo is an alias for Numeric#%.
  #
  def modulo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - negative? -> true or false
  # -->
  # Returns `true` if `self` is less than 0, `false` otherwise.
  #
  def negative?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - nonzero?  ->  self or nil
  # -->
  # Returns `self` if `self` is not a zero value, `nil` otherwise; uses method
  # `zero?` for the evaluation.
  #
  # The returned `self` allows the method to be chained:
  #
  #     a = %w[z Bb bB bb BB a aA Aa AA A]
  #     a.sort {|a, b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #     # => ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  # Of the Core and Standard Library classes, Integer, Float, Rational, and
  # Complex use this implementation.
  #
  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - num.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  def numerator: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns 0 if the value is positive, pi otherwise.
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - num.polar  ->  array
  # -->
  # Returns an array; [num.abs, num.arg].
  #
  def polar: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - positive? -> true or false
  # -->
  # Returns `true` if `self` is greater than 0, `false` otherwise.
  #
  def positive?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - num.quo(int_or_rat)   ->  rat
  #   - num.quo(flo)          ->  flo
  # -->
  # Returns the most exact division (rational for integers, float for floats).
  #
  def quo: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - num.real  ->  self
  # -->
  # Returns self.
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=numeric.rb
  #   - num.real?  ->  true or false
  # -->
  # Returns `true` if `num` is a real number (i.e. not Complex).
  #
  def real?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns an array; [num, 0].
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - num.rect  ->  array
  #   - num.rectangular  ->  array
  # -->
  # Returns an array; [num, 0].
  #
  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Of the Core and Standard Library classes, only Float and Rational use this
  # implementation.
  #
  # Examples:
  #
  #     11.0.remainder(4)              # => 3.0
  #     11.0.remainder(-4)             # => 3.0
  #     -11.0.remainder(4)             # => -3.0
  #     -11.0.remainder(-4)            # => -3.0
  #
  #     12.0.remainder(4)              # => 0.0
  #     12.0.remainder(-4)             # => 0.0
  #     -12.0.remainder(4)             # => -0.0
  #     -12.0.remainder(-4)            # => -0.0
  #
  #     13.0.remainder(4.0)            # => 1.0
  #     13.0.remainder(Rational(4, 1)) # => 1.0
  #
  #     Rational(13, 1).remainder(4)   # => (1/1)
  #     Rational(13, 1).remainder(-4)  # => (1/1)
  #     Rational(-13, 1).remainder(4)  # => (-1/1)
  #     Rational(-13, 1).remainder(-4) # => (-1/1)
  #
  def remainder: (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(digits = 0) -> integer or float
  # -->
  # Returns `self` rounded to the nearest value with a precision of `digits`
  # decimal digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#round.
  #
  def round: () -> Integer
           | (Integer digits) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - step(to = nil, by = 1) {|n| ... } ->  self
  #   - step(to = nil, by = 1)            ->  enumerator
  #   - step(to = nil, by: 1) {|n| ... }  ->  self
  #   - step(to = nil, by: 1)             ->  enumerator
  #   - step(by: 1, to: ) {|n| ... }      ->  self
  #   - step(by: 1, to: )                 ->  enumerator
  #   - step(by: , to: nil) {|n| ... }    ->  self
  #   - step(by: , to: nil)               ->  enumerator
  # -->
  # Generates a sequence of numbers; with a block given, traverses the sequence.
  #
  #     Of the Core and Standard Library classes,
  #     Integer, Float, and Rational use this implementation.
  #
  #     A quick example:
  #
  #       squares = []
  #       1.step(by: 2, to: 10) {|i| squares.push(i*i) }
  #       squares # => [1, 9, 25, 49, 81]
  #
  #     The generated sequence:
  #
  #     - Begins with +self+.
  #     - Continues at intervals of +step+ (which may not be zero).
  #     - Ends with the last number that is within or equal to +limit+;
  #       that is, less than or equal to +limit+ if +step+ is positive,
  #       greater than or equal to +limit+ if +step+ is negative.
  #       If +limit+ is not given, the sequence is of infinite length.
  #
  #     If a block is given, calls the block with each number in the sequence;
  #     returns +self+.  If no block is given, returns an Enumerator::ArithmeticSequence.
  #
  #     <b>Keyword Arguments</b>
  #
  #     With keyword arguments +by+ and +to+,
  #     their values (or defaults) determine the step and limit:
  #
  #       # Both keywords given.
  #       squares = []
  #       4.step(by: 2, to: 10) {|i| squares.push(i*i) }    # => 4
  #       squares # => [16, 36, 64, 100]
  #       cubes = []
  #       3.step(by: -1.5, to: -3) {|i| cubes.push(i*i*i) } # => 3
  #       cubes   # => [27.0, 3.375, 0.0, -3.375, -27.0]
  #       squares = []
  #       1.2.step(by: 0.2, to: 2.0) {|f| squares.push(f*f) }
  #       squares # => [1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #       squares = []
  #       Rational(6/5).step(by: 0.2, to: 2.0) {|r| squares.push(r*r) }
  #       squares # => [1.0, 1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]
  #
  #       # Only keyword to given.
  #       squares = []
  #       4.step(to: 10) {|i| squares.push(i*i) }           # => 4
  #       squares # => [16, 25, 36, 49, 64, 81, 100]
  #       # Only by given.
  #
  #       # Only keyword by given
  #       squares = []
  #       4.step(by:2) {|i| squares.push(i*i); break if i > 10 }
  #       squares # => [16, 36, 64, 100, 144]
  #
  #       # No block given.
  #       e = 3.step(by: -1.5, to: -3) # => (3.step(by: -1.5, to: -3))
  #       e.class                      # => Enumerator::ArithmeticSequence
  #
  #     <b>Positional Arguments</b>
  #
  #     With optional positional arguments +limit+ and +step+,
  #     their values (or defaults) determine the step and limit:
  #
  #       squares = []
  #       4.step(10, 2) {|i| squares.push(i*i) }    # => 4
  #       squares # => [16, 36, 64, 100]
  #       squares = []
  #       4.step(10) {|i| squares.push(i*i) }
  #       squares # => [16, 25, 36, 49, 64, 81, 100]
  #       squares = []
  #       4.step {|i| squares.push(i*i); break if i > 10 }  # => nil
  #       squares # => [16, 25, 36, 49, 64, 81, 100, 121]
  #
  # **Implementation Notes**
  #
  #     If all the arguments are integers, the loop operates using an integer
  #     counter.
  #
  #     If any of the arguments are floating point numbers, all are converted
  #     to floats, and the loop is executed
  #     <i>floor(n + n*Float::EPSILON) + 1</i> times,
  #     where <i>n = (limit - self)/step</i>.
  #
  def step: (?Numeric limit, ?Numeric step) { (Numeric) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Numeric, self]
          | (?by: Numeric, ?to: Numeric) { (Numeric) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Numeric, self]

  # <!--
  #   rdoc-file=complex.c
  #   - num.to_c  ->  complex
  # -->
  # Returns the value as a complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_int -> integer
  # -->
  # Returns `self` as an integer; converts using method `to_i` in the derived
  # class.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  # Examples:
  #
  #     Rational(1, 2).to_int # => 0
  #     Rational(2, 1).to_int # => 2
  #     Complex(2, 0).to_int  # => 2
  #     Complex(2, 1)         # Raises RangeError (non-zero imaginary part)
  #
  def to_int: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(digits = 0) -> integer or float
  # -->
  # Returns `self` truncated (toward zero) to a precision of `digits` decimal
  # digits.
  #
  # Numeric implements this by converting `self` to a Float and invoking
  # Float#truncate.
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Numeric)

  # <!--
  #   rdoc-file=numeric.c
  #   - zero? -> true or false
  # -->
  # Returns `true` if `zero` has a zero value, `false` otherwise.
  #
  # Of the Core and Standard Library classes, only Rational and Complex use this
  # implementation.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - clone(freeze: true) -> self
  # -->
  # Returns `self`.
  #
  # Raises an exception if the value for `freeze` is neither `true` nor `nil`.
  #
  # Related: Numeric#dup.
  #
  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=re.c -->
# A Regexp holds a regular expression, used to match a pattern against strings.
# Regexps are created using the `/.../` and `%r{...}` literals, and by the
# Regexp::new constructor.
#
# You can create a Regexp object explicitly with:
#
# *   A [regexp literal](doc/syntax/literals_rdoc.html#label-Regexp+Literals).
#
#
# Regular expressions (*regexp*s) are patterns which describe the contents of a
# string. They're used for testing whether a string contains a given pattern, or
# extracting the portions that match. They are created with the `/`*pat*`/` and
# `%r{`*pat*`}` literals or the `Regexp.new` constructor.
#
# A regexp is usually delimited with forward slashes (`/`). For example:
#
#     /hay/ =~ 'haystack'   #=> 0
#     /y/.match('haystack') #=> #<MatchData "y">
#
# If a string contains the pattern it is said to *match*. A literal string
# matches itself.
#
# Here 'haystack' does not contain the pattern 'needle', so it doesn't match:
#
#     /needle/.match('haystack') #=> nil
#
# Here 'haystack' contains the pattern 'hay', so it matches:
#
#     /hay/.match('haystack')    #=> #<MatchData "hay">
#
# Specifically, `/st/` requires that the string contains the letter *s* followed
# by the letter *t*, so it matches *haystack*, also.
#
# ## `=~` and Regexp#match
#
# Pattern matching may be achieved by using `=~` operator or Regexp#match
# method.
#
# ### `=~` operator
#
# `=~` is Ruby's basic pattern-matching operator.  When one operand is a regular
# expression and the other is a string then the regular expression is used as a
# pattern to match against the string.  (This operator is equivalently defined
# by Regexp and String so the order of String and Regexp do not matter. Other
# classes may have different implementations of `=~`.)  If a match is found, the
# operator returns index of first match in string, otherwise it returns `nil`.
#
#     /hay/ =~ 'haystack'   #=> 0
#     'haystack' =~ /hay/   #=> 0
#     /a/   =~ 'haystack'   #=> 1
#     /u/   =~ 'haystack'   #=> nil
#
# Using `=~` operator with a String and Regexp the `$~` global variable is set
# after a successful match.  `$~` holds a MatchData object. Regexp.last_match is
# equivalent to `$~`.
#
# ### Regexp#match method
#
# The #match method returns a MatchData object:
#
#     /st/.match('haystack')   #=> #<MatchData "st">
#
# ## Metacharacters and Escapes
#
# The following are *metacharacters* `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`,
# `+`, `*`. They have a specific meaning when appearing in a pattern. To match
# them literally they must be backslash-escaped. To match a backslash literally,
# backslash-escape it: `\\\`.
#
#     /1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=> #<MatchData "1 + 2 = 3?">
#     /a\\\\b/.match('a\\\\b')                    #=> #<MatchData "a\\b">
#
# Patterns behave like double-quoted strings and can contain the same backslash
# escapes (the meaning of `\s` is different, however, see
# [below](#label-Character+Classes)).
#
#     /\s\u{6771 4eac 90fd}/.match("Go to ")
#         #=> #<MatchData " ">
#
# Arbitrary Ruby expressions can be embedded into patterns with the `#{...}`
# construct.
#
#     place = ""
#     /#{place}/.match("Go to ")
#         #=> #<MatchData "">
#
# ## Character Classes
#
# A *character class* is delimited with square brackets (`[`, `]`) and lists
# characters that may appear at that point in the match. `/[ab]/` means *a* or
# *b*, as opposed to `/ab/` which means *a* followed by *b*.
#
#     /W[aeiou]rd/.match("Word") #=> #<MatchData "Word">
#
# Within a character class the hyphen (`-`) is a metacharacter denoting an
# inclusive range of characters. `[abcd]` is equivalent to `[a-d]`. A range can
# be followed by another range, so `[abcdwxyz]` is equivalent to `[a-dw-z]`. The
# order in which ranges or individual characters appear inside a character class
# is irrelevant.
#
#     /[0-9a-f]/.match('9f') #=> #<MatchData "9">
#     /[9f]/.match('9f')     #=> #<MatchData "9">
#
# If the first character of a character class is a caret (`^`) the class is
# inverted: it matches any character *except* those named.
#
#     /[^a-eg-z]/.match('f') #=> #<MatchData "f">
#
# A character class may contain another character class. By itself this isn't
# useful because `[a-z[0-9]]` describes the same set as `[a-z0-9]`. However,
# character classes also support the `&&` operator which performs set
# intersection on its arguments. The two can be combined as follows:
#
#     /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))
#
# This is equivalent to:
#
#     /[abh-w]/
#
# The following metacharacters also behave like character classes:
#
# *   `/./` - Any character except a newline.
# *   `/./m` - Any character (the `m` modifier enables multiline mode)
# *   `/\w/` - A word character (`[a-zA-Z0-9_]`)
# *   `/\W/` - A non-word character (`[^a-zA-Z0-9_]`). Please take a look at
#     [Bug #4044](https://bugs.ruby-lang.org/issues/4044) if using `/\W/` with
#     the `/i` modifier.
# *   `/\d/` - A digit character (`[0-9]`)
# *   `/\D/` - A non-digit character (`[^0-9]`)
# *   `/\h/` - A hexdigit character (`[0-9a-fA-F]`)
# *   `/\H/` - A non-hexdigit character (`[^0-9a-fA-F]`)
# *   `/\s/` - A whitespace character: `/[ \t\r\n\f\v]/`
# *   `/\S/` - A non-whitespace character: `/[^ \t\r\n\f\v]/`
# *   `/\R/` - A linebreak: `\n`, `\v`, `\f`, `\r` `\u0085` (NEXT LINE),
#     `\u2028` (LINE SEPARATOR), `\u2029` (PARAGRAPH SEPARATOR) or `\r\n`.
#
#
# POSIX *bracket expressions* are also similar to character classes. They
# provide a portable alternative to the above, with the added benefit that they
# encompass non-ASCII characters. For instance, `/\d/` matches only the ASCII
# decimal digits (0-9); whereas `/[[:digit:]]/` matches any character in the
# Unicode *Nd* category.
#
# *   `/[[:alnum:]]/` - Alphabetic and numeric character
# *   `/[[:alpha:]]/` - Alphabetic character
# *   `/[[:blank:]]/` - Space or tab
# *   `/[[:cntrl:]]/` - Control character
# *   `/[[:digit:]]/` - Digit
# *   `/[[:graph:]]/` - Non-blank character (excludes spaces, control
#     characters, and similar)
# *   `/[[:lower:]]/` - Lowercase alphabetical character
# *   `/[[:print:]]/` - Like [:graph:], but includes the space character
# *   `/[[:punct:]]/` - Punctuation character
# *   `/[[:space:]]/` - Whitespace character (`[:blank:]`, newline, carriage
#     return, etc.)
# *   `/[[:upper:]]/` - Uppercase alphabetical
# *   `/[[:xdigit:]]/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
#
#
# Ruby also supports the following non-POSIX character classes:
#
# *   `/[[:word:]]/` - A character in one of the following Unicode general
#     categories *Letter*, *Mark*, *Number*, *Connector_Punctuation*
# *   `/[[:ascii:]]/` - A character in the ASCII character set
#
#         # U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"
#         /[[:digit:]]/.match("\u06F2")    #=> #<MatchData "\u{06F2}">
#         /[[:upper:]][[:lower:]]/.match("Hello") #=> #<MatchData "He">
#         /[[:xdigit:]][[:xdigit:]]/.match("A6")  #=> #<MatchData "A6">
#
#
# ## Repetition
#
# The constructs described so far match a single character. They can be followed
# by a repetition metacharacter to specify how many times they need to occur.
# Such metacharacters are called *quantifiers*.
#
# *   `*` - Zero or more times
# *   `+` - One or more times
# *   `?` - Zero or one times (optional)
# *   `{`*n*`}` - Exactly *n* times
# *   `{`*n*`,}` - *n* or more times
# *   `{,`*m*`}` - *m* or less times
# *   `{`*n*`,`*m*`}` - At least *n* and at most *m* times
#
#
# At least one uppercase character ('H'), at least one lowercase character
# ('e'), two 'l' characters, then one 'o':
#
#     "Hello".match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=> #<MatchData "Hello">
#
# ### Greedy match
#
# Repetition is *greedy* by default: as many occurrences as possible are matched
# while still allowing the overall match to succeed. By contrast, *lazy*
# matching makes the minimal amount of matches necessary for overall success.
# Most greedy metacharacters can be made lazy by following them with `?`. For
# the `{n}` pattern, because it specifies an exact number of characters to match
# and not a variable number of characters, the `?` metacharacter instead makes
# the repeated pattern optional.
#
# Both patterns below match the string. The first uses a greedy quantifier so
# '.+' matches '<a><b>'; the second uses a lazy quantifier so '.+?' matches
# '<a>':
#
#     /<.+>/.match("<a><b>")  #=> #<MatchData "<a><b>">
#     /<.+?>/.match("<a><b>") #=> #<MatchData "<a>">
#
# ### Possessive match
#
# A quantifier followed by `+` matches *possessively*: once it has matched it
# does not backtrack. They behave like greedy quantifiers, but having matched
# they refuse to "give up" their match even if this jeopardises the overall
# match.
#
#     /<.*><.+>/.match("<a><b>") #=> #<MatchData "<a><b>">
#     /<.*+><.+>/.match("<a><b>") #=> nil
#     /<.*><.++>/.match("<a><b>") #=> nil
#
# ## Capturing
#
# Parentheses can be used for *capturing*. The text enclosed by the *n*th group
# of parentheses can be subsequently referred to with *n*. Within a pattern use
# the *backreference* `\n` (e.g. `\1`); outside of the pattern use
# `MatchData[n]` (e.g. `MatchData[1]`).
#
# In this example, `'at'` is captured by the first group of parentheses, then
# referred to later with `\1`:
#
#     /[csh](..) [csh]\1 in/.match("The cat sat in the hat")
#         #=> #<MatchData "cat sat in" 1:"at">
#
# Regexp#match returns a MatchData object which makes the captured text
# available with its #[] method:
#
#     /[csh](..) [csh]\1 in/.match("The cat sat in the hat")[1] #=> 'at'
#
# While Ruby supports an arbitrary number of numbered captured groups, only
# groups 1-9 are supported using the `\n` backreference syntax.
#
# Ruby also supports `\0` as a special backreference, which references the
# entire matched string.  This is also available at `MatchData[0]`.  Note that
# the `\0` backreference cannot be used inside the regexp, as backreferences can
# only be used after the end of the capture group, and the `\0` backreference
# uses the implicit capture group of the entire match.  However, you can use
# this backreference when doing substitution:
#
#     "The cat sat in the hat".gsub(/[csh]at/, '\0s')
#       # => "The cats sats in the hats"
#
# ### Named captures
#
# Capture groups can be referred to by name when defined with the
# `(?<`*name*`>)` or `(?'`*name*`')` constructs.
#
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")
#         #=> #<MatchData "$3.67" dollars:"3" cents:"67">
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")[:dollars] #=> "3"
#
# Named groups can be backreferenced with `\k<`*name*`>`, where *name* is the
# group name.
#
#     /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
#         #=> #<MatchData "ototo" vowel:"o">
#
# **Note**: A regexp can't use named backreferences and numbered backreferences
# simultaneously. Also, if a named capture is used in a regexp, then parentheses
# used for grouping which would otherwise result in a unnamed capture are
# treated as non-capturing.
#
#     /(\w)(\w)/.match("ab").captures # => ["a", "b"]
#     /(\w)(\w)/.match("ab").named_captures # => {}
#
#     /(?<c>\w)(\w)/.match("ab").captures # => ["a"]
#     /(?<c>\w)(\w)/.match("ab").named_captures # => {"c"=>"a"}
#
# When named capture groups are used with a literal regexp on the left-hand side
# of an expression and the `=~` operator, the captured text is also assigned to
# local variables with corresponding names.
#
#     /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" #=> 0
#     dollars #=> "3"
#
# ## Grouping
#
# Parentheses also *group* the terms they enclose, allowing them to be
# quantified as one *atomic* whole.
#
# The pattern below matches a vowel followed by 2 word characters:
#
#     /[aeiou]\w{2}/.match("Caenorhabditis elegans") #=> #<MatchData "aen">
#
# Whereas the following pattern matches a vowel followed by a word character,
# twice, i.e. `[aeiou]\w[aeiou]\w`: 'enor'.
#
#     /([aeiou]\w){2}/.match("Caenorhabditis elegans")
#         #=> #<MatchData "enor" 1:"or">
#
# The `(?:`...`)` construct provides grouping without capturing. That is, it
# combines the terms it contains into an atomic whole without creating a
# backreference. This benefits performance at the slight expense of readability.
#
# The first group of parentheses captures 'n' and the second 'ti'. The second
# group is referred to later with the backreference `\2`:
#
#     /I(n)ves(ti)ga\2ons/.match("Investigations")
#         #=> #<MatchData "Investigations" 1:"n" 2:"ti">
#
# The first group of parentheses is now made non-capturing with '?:', so it
# still matches 'n', but doesn't create the backreference. Thus, the
# backreference `\1` now refers to 'ti'.
#
#     /I(?:n)ves(ti)ga\1ons/.match("Investigations")
#         #=> #<MatchData "Investigations" 1:"ti">
#
# ### Atomic Grouping
#
# Grouping can be made *atomic* with `(?>`*pat*`)`. This causes the
# subexpression *pat* to be matched independently of the rest of the expression
# such that what it matches becomes fixed for the remainder of the match, unless
# the entire subexpression must be abandoned and subsequently revisited. In this
# way *pat* is treated as a non-divisible whole. Atomic grouping is typically
# used to optimise patterns so as to prevent the regular expression engine from
# backtracking needlessly.
#
# The `"` in the pattern below matches the first character of the string, then
# `.*` matches *Quote"*. This causes the overall match to fail, so the text
# matched by `.*` is backtracked by one position, which leaves the final
# character of the string available to match `"`
#
#     /".*"/.match('"Quote"')     #=> #<MatchData "\"Quote\"">
#
# If `.*` is grouped atomically, it refuses to backtrack *Quote"*, even though
# this means that the overall match fails
#
#     /"(?>.*)"/.match('"Quote"') #=> nil
#
# ## Subexpression Calls
#
# The `\g<`*name*`>` syntax matches the previous subexpression named *name*,
# which can be a group name or number, again. This differs from backreferences
# in that it re-executes the group rather than simply trying to re-match the
# same text.
#
# This pattern matches a *(* character and assigns it to the `paren` group,
# tries to call that the `paren` sub-expression again but fails, then matches a
# literal *)*:
#
#     /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'
#
#     /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' #=> 0
#     # ^1
#     #      ^2
#     #           ^3
#     #                 ^4
#     #      ^5
#     #           ^6
#     #                      ^7
#     #                       ^8
#     #                       ^9
#     #                           ^10
#
# 1.  Matches at the beginning of the string, i.e. before the first character.
# 2.  Enters a named capture group called `paren`
# 3.  Matches a literal *(*, the first character in the string
# 4.  Calls the `paren` group again, i.e. recurses back to the second step
# 5.  Re-enters the `paren` group
# 6.  Matches a literal *(*, the second character in the string
# 7.  Try to call `paren` a third time, but fail because doing so would prevent
#     an overall successful match
# 8.  Match a literal *)*, the third character in the string. Marks the end of
#     the second recursive call
# 9.  Match a literal *)*, the fourth character in the string
# 10. Match the end of the string
#
#
# ## Alternation
#
# The vertical bar metacharacter (`|`) combines several expressions into a
# single one that matches any of the expressions. Each expression is an
# *alternative*.
#
#     /\w(and|or)\w/.match("Feliformia") #=> #<MatchData "form" 1:"or">
#     /\w(and|or)\w/.match("furandi")    #=> #<MatchData "randi" 1:"and">
#     /\w(and|or)\w/.match("dissemblance") #=> nil
#
# ## Character Properties
#
# The `\p{}` construct matches characters with the named property, much like
# POSIX bracket classes.
#
# *   `/\p{Alnum}/` - Alphabetic and numeric character
# *   `/\p{Alpha}/` - Alphabetic character
# *   `/\p{Blank}/` - Space or tab
# *   `/\p{Cntrl}/` - Control character
# *   `/\p{Digit}/` - Digit
# *   `/\p{Graph}/` - Non-blank character (excludes spaces, control characters,
#     and similar)
# *   `/\p{Lower}/` - Lowercase alphabetical character
# *   `/\p{Print}/` - Like `\p{Graph}`, but includes the space character
# *   `/\p{Punct}/` - Punctuation character
# *   `/\p{Space}/` - Whitespace character (`[:blank:]`, newline, carriage
#     return, etc.)
# *   `/\p{Upper}/` - Uppercase alphabetical
# *   `/\p{XDigit}/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
# *   `/\p{Word}/` - A member of one of the following Unicode general category
#     *Letter*, *Mark*, *Number*, *Connector_Punctuation*
# *   `/\p{ASCII}/` - A character in the ASCII character set
# *   `/\p{Any}/` - Any Unicode character (including unassigned characters)
# *   `/\p{Assigned}/` - An assigned character
#
#
# A Unicode character's *General Category* value can also be matched with
# `\p{`*Ab*`}` where *Ab* is the category's abbreviation as described below:
#
# *   `/\p{L}/` - 'Letter'
# *   `/\p{Ll}/` - 'Letter: Lowercase'
# *   `/\p{Lm}/` - 'Letter: Mark'
# *   `/\p{Lo}/` - 'Letter: Other'
# *   `/\p{Lt}/` - 'Letter: Titlecase'
# *   `/\p{Lu}/` - 'Letter: Uppercase
# *   `/\p{Lo}/` - 'Letter: Other'
# *   `/\p{M}/` - 'Mark'
# *   `/\p{Mn}/` - 'Mark: Nonspacing'
# *   `/\p{Mc}/` - 'Mark: Spacing Combining'
# *   `/\p{Me}/` - 'Mark: Enclosing'
# *   `/\p{N}/` - 'Number'
# *   `/\p{Nd}/` - 'Number: Decimal Digit'
# *   `/\p{Nl}/` - 'Number: Letter'
# *   `/\p{No}/` - 'Number: Other'
# *   `/\p{P}/` - 'Punctuation'
# *   `/\p{Pc}/` - 'Punctuation: Connector'
# *   `/\p{Pd}/` - 'Punctuation: Dash'
# *   `/\p{Ps}/` - 'Punctuation: Open'
# *   `/\p{Pe}/` - 'Punctuation: Close'
# *   `/\p{Pi}/` - 'Punctuation: Initial Quote'
# *   `/\p{Pf}/` - 'Punctuation: Final Quote'
# *   `/\p{Po}/` - 'Punctuation: Other'
# *   `/\p{S}/` - 'Symbol'
# *   `/\p{Sm}/` - 'Symbol: Math'
# *   `/\p{Sc}/` - 'Symbol: Currency'
# *   `/\p{Sc}/` - 'Symbol: Currency'
# *   `/\p{Sk}/` - 'Symbol: Modifier'
# *   `/\p{So}/` - 'Symbol: Other'
# *   `/\p{Z}/` - 'Separator'
# *   `/\p{Zs}/` - 'Separator: Space'
# *   `/\p{Zl}/` - 'Separator: Line'
# *   `/\p{Zp}/` - 'Separator: Paragraph'
# *   `/\p{C}/` - 'Other'
# *   `/\p{Cc}/` - 'Other: Control'
# *   `/\p{Cf}/` - 'Other: Format'
# *   `/\p{Cn}/` - 'Other: Not Assigned'
# *   `/\p{Co}/` - 'Other: Private Use'
# *   `/\p{Cs}/` - 'Other: Surrogate'
#
#
# Lastly, `\p{}` matches a character's Unicode *script*. The following scripts
# are supported: *Arabic*, *Armenian*, *Balinese*, *Bengali*, *Bopomofo*,
# *Braille*, *Buginese*, *Buhid*, *Canadian_Aboriginal*, *Carian*, *Cham*,
# *Cherokee*, *Common*, *Coptic*, *Cuneiform*, *Cypriot*, *Cyrillic*, *Deseret*,
# *Devanagari*, *Ethiopic*, *Georgian*, *Glagolitic*, *Gothic*, *Greek*,
# *Gujarati*, *Gurmukhi*, *Han*, *Hangul*, *Hanunoo*, *Hebrew*, *Hiragana*,
# *Inherited*, *Kannada*, *Katakana*, *Kayah_Li*, *Kharoshthi*, *Khmer*, *Lao*,
# *Latin*, *Lepcha*, *Limbu*, *Linear_B*, *Lycian*, *Lydian*, *Malayalam*,
# *Mongolian*, *Myanmar*, *New_Tai_Lue*, *Nko*, *Ogham*, *Ol_Chiki*,
# *Old_Italic*, *Old_Persian*, *Oriya*, *Osmanya*, *Phags_Pa*, *Phoenician*,
# *Rejang*, *Runic*, *Saurashtra*, *Shavian*, *Sinhala*, *Sundanese*,
# *Syloti_Nagri*, *Syriac*, *Tagalog*, *Tagbanwa*, *Tai_Le*, *Tamil*, *Telugu*,
# *Thaana*, *Thai*, *Tibetan*, *Tifinagh*, *Ugaritic*, *Vai*, and *Yi*.
#
# Unicode codepoint U+06E9 is named "ARABIC PLACE OF SAJDAH" and belongs to the
# Arabic script:
#
#     /\p{Arabic}/.match("\u06E9") #=> #<MatchData "\u06E9">
#
# All character properties can be inverted by prefixing their name with a caret
# (`^`).
#
# Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so this
# match succeeds:
#
#     /\p{^Ll}/.match("A") #=> #<MatchData "A">
#
# ## Anchors
#
# Anchors are metacharacter that match the zero-width positions between
# characters, *anchoring* the match to a specific position.
#
# *   `^` - Matches beginning of line
# *   `$` - Matches end of line
# *   `\A` - Matches beginning of string.
# *   `\Z` - Matches end of string. If string ends with a newline, it matches
#     just before newline
# *   `\z` - Matches end of string
# *   `\G` - Matches first matching position:
#
#     In methods like `String#gsub` and `String#scan`, it changes on each
#     iteration. It initially matches the beginning of subject, and in each
#     following iteration it matches where the last match finished.
#
#         "    a b c".gsub(/ /, '_')    #=> "____a_b_c"
#         "    a b c".gsub(/\G /, '_')  #=> "____a b c"
#
#     In methods like `Regexp#match` and `String#match` that take an (optional)
#     offset, it matches where the search begins.
#
#         "hello, world".match(/,/, 3)    #=> #<MatchData ",">
#         "hello, world".match(/\G,/, 3)  #=> nil
#
# *   `\b` - Matches word boundaries when outside brackets; backspace (0x08)
#     when inside brackets
# *   `\B` - Matches non-word boundaries
# *   `(?=`*pat*`)` - *Positive lookahead* assertion: ensures that the following
#     characters match *pat*, but doesn't include those characters in the
#     matched text
# *   `(?!`*pat*`)` - *Negative lookahead* assertion: ensures that the following
#     characters do not match *pat*, but doesn't include those characters in the
#     matched text
# *   `(?<=`*pat*`)` - *Positive lookbehind* assertion: ensures that the
#     preceding characters match *pat*, but doesn't include those characters in
#     the matched text
# *   `(?<!`*pat*`)` - *Negative lookbehind* assertion: ensures that the
#     preceding characters do not match *pat*, but doesn't include those
#     characters in the matched text
# *   `\K` - Uses an positive lookbehind of the content preceding `\K` in the
#     regexp.  For example, the following two regexps are almost equivalent:
#
#         /ab\Kc/
#         /(?<=ab)c/
#
#     As are the following two regexps:
#
#         /(a)\K(b)\Kc/
#         /(?<=(?<=(a))(b))c/
#
#
# If a pattern isn't anchored it can begin at any point in the string:
#
#     /real/.match("surrealist") #=> #<MatchData "real">
#
# Anchoring the pattern to the beginning of the string forces the match to start
# there. 'real' doesn't occur at the beginning of the string, so now the match
# fails:
#
#     /\Areal/.match("surrealist") #=> nil
#
# The match below fails because although 'Demand' contains 'and', the pattern
# does not occur at a word boundary.
#
#     /\band/.match("Demand")
#
# Whereas in the following example 'and' has been anchored to a non-word
# boundary so instead of matching the first 'and' it matches from the fourth
# letter of 'demand' instead:
#
#     /\Band.+/.match("Supply and demand curve") #=> #<MatchData "and curve">
#
# The pattern below uses positive lookahead and positive lookbehind to match
# text appearing in  tags without including the tags in the match:
#
#     /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>")
#         #=> #<MatchData "bold">
#
# ## Options
#
# The end delimiter for a regexp can be followed by one or more single-letter
# options which control how the pattern can match.
#
# *   `/pat/i` - Ignore case
# *   `/pat/m` - Treat a newline as a character matched by `.`
# *   `/pat/x` - Ignore whitespace and comments in the pattern
# *   `/pat/o` - Perform `#{}` interpolation only once
#
#
# `i`, `m`, and `x` can also be applied on the subexpression level with the
# `(?`*on*`-`*off*`)` construct, which enables options *on*, and disables
# options *off* for the expression enclosed by the parentheses:
#
#     /a(?i:b)c/.match('aBc')   #=> #<MatchData "aBc">
#     /a(?-i:b)c/i.match('ABC') #=> nil
#
# Additionally, these options can also be toggled for the remainder of the
# pattern:
#
#     /a(?i)bc/.match('abC') #=> #<MatchData "abC">
#
# Options may also be used with `Regexp.new`:
#
#     Regexp.new("abc", Regexp::IGNORECASE)                     #=> /abc/i
#     Regexp.new("abc", Regexp::MULTILINE)                      #=> /abc/m
#     Regexp.new("abc # Comment", Regexp::EXTENDED)             #=> /abc # Comment/x
#     Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) #=> /abc/mi
#
# ## Free-Spacing Mode and Comments
#
# As mentioned above, the `x` option enables *free-spacing* mode. Literal white
# space inside the pattern is ignored, and the octothorpe (`#`) character
# introduces a comment until the end of the line. This allows the components of
# the pattern to be organized in a potentially more readable fashion.
#
# A contrived pattern to match a number with optional decimal places:
#
#     float_pat = /\A
#         [[:digit:]]+ # 1 or more digits before the decimal point
#         (\.          # Decimal point
#             [[:digit:]]+ # 1 or more digits after the decimal point
#         )? # The decimal point and following digits are optional
#     \Z/x
#     float_pat.match('3.14') #=> #<MatchData "3.14" 1:".14">
#
# There are a number of strategies for matching whitespace:
#
# *   Use a pattern such as `\s` or `\p{Space}`.
# *   Use escaped whitespace such as `\ `, i.e. a space preceded by a backslash.
# *   Use a character class such as `[ ]`.
#
#
# Comments can be included in a non-`x` pattern with the `(?#`*comment*`)`
# construct, where *comment* is arbitrary text ignored by the regexp engine.
#
# Comments in regexp literals cannot include unescaped terminator characters.
#
# ## Encoding
#
# Regular expressions are assumed to use the source encoding. This can be
# overridden with one of the following modifiers.
#
# *   `/`*pat*`/u` - UTF-8
# *   `/`*pat*`/e` - EUC-JP
# *   `/`*pat*`/s` - Windows-31J
# *   `/`*pat*`/n` - ASCII-8BIT
#
#
# A regexp can be matched against a string when they either share an encoding,
# or the regexp's encoding is *US-ASCII* and the string's encoding is
# ASCII-compatible.
#
# If a match between incompatible encodings is attempted an
# `Encoding::CompatibilityError` exception is raised.
#
# The `Regexp#fixed_encoding?` predicate indicates whether the regexp has a
# *fixed* encoding, that is one incompatible with ASCII. A regexp's encoding can
# be explicitly fixed by supplying `Regexp::FIXEDENCODING` as the second
# argument of `Regexp.new`:
#
#     r = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
#     r =~ "a\u3042"
#        # raises Encoding::CompatibilityError: incompatible encoding regexp match
#        #         (ISO-8859-1 regexp with UTF-8 string)
#
# ## Special global variables
#
# Pattern matching sets some global variables :
# *   `$~` is equivalent to Regexp.last_match;
# *   `$&` contains the complete matched text;
# *   `$`` contains string before match;
# *   `$'` contains string after match;
# *   `$1`, `$2` and so on contain text matching first, second, etc capture
#     group;
# *   `$+` contains last capture group.
#
#
# Example:
#
#     m = /s(\w{2}).*(c)/.match('haystack') #=> #<MatchData "stac" 1:"ta" 2:"c">
#     $~                                    #=> #<MatchData "stac" 1:"ta" 2:"c">
#     Regexp.last_match                     #=> #<MatchData "stac" 1:"ta" 2:"c">
#
#     $&      #=> "stac"
#             # same as m[0]
#     $`      #=> "hay"
#             # same as m.pre_match
#     $'      #=> "k"
#             # same as m.post_match
#     $1      #=> "ta"
#             # same as m[1]
#     $2      #=> "c"
#             # same as m[2]
#     $3      #=> nil
#             # no third group in pattern
#     $+      #=> "c"
#             # same as m[-1]
#
# These global variables are thread-local and method-local variables.
#
# ## Performance
#
# Certain pathological combinations of constructs can lead to abysmally bad
# performance.
#
# Consider a string of 25 *a*s, a *d*, 4 *a*s, and a *c*.
#
#     s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
#     #=> "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"
#
# The following patterns match instantly as you would expect:
#
#     /(b|a)/ =~ s #=> 0
#     /(b|a+)/ =~ s #=> 0
#     /(b|a+)*/ =~ s #=> 0
#
# However, the following pattern takes appreciably longer:
#
#     /(b|a+)*c/ =~ s #=> 26
#
# This happens because an atom in the regexp is quantified by both an immediate
# `+` and an enclosing `*` with nothing to differentiate which is in control of
# any particular character. The nondeterminism that results produces
# super-linear performance. (Consult *Mastering Regular Expressions* (3rd ed.),
# pp 222, by *Jeffery Friedl*, for an in-depth analysis). This particular case
# can be fixed by use of atomic grouping, which prevents the unnecessary
# backtracking:
#
#     (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)
#        #=> 24.702736882
#     (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start)
#        #=> 0.000166571
#
# A similar case is typified by the following example, which takes approximately
# 60 seconds to execute for me:
#
# Match a string of 29 *a*s against a pattern of 29 optional *a*s followed by 29
# mandatory *a*s:
#
#     Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29
#
# The 29 optional *a*s match the string, but this prevents the 29 mandatory *a*s
# that follow from matching. Ruby must then backtrack repeatedly so as to
# satisfy as many of the optional matches as it can while still matching the
# mandatory 29. It is plain to us that none of the optional matches can succeed,
# but this fact unfortunately eludes Ruby.
#
# The best way to improve performance is to significantly reduce the amount of
# backtracking needed.  For this case, instead of individually matching 29
# optional *a*s, a range of optional *a*s can be matched all at once with
# *a{0,29}*:
#
#     Regexp.new('a{0,29}' + 'a' * 29) =~ 'a' * 29
#
class Regexp
  # <!--
  #   rdoc-file=re.c
  #   - Regexp.new(string, [options])       -> regexp
  #   - Regexp.new(regexp)                  -> regexp
  #   - Regexp.compile(string, [options])   -> regexp
  #   - Regexp.compile(regexp)              -> regexp
  # -->
  # Constructs a new regular expression from `pattern`, which can be either a
  # String or a Regexp (in which case that regexp's options are propagated), and
  # new options may not be specified (a change as of Ruby 1.8).
  #
  # If `options` is an Integer, it should be one or more of the constants
  # Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, *or*-ed together.
  #  Otherwise, if `options` is not `nil` or `false`, the regexp will be case
  # insensitive.
  #
  #     r1 = Regexp.new('^a-z+:\\s+\w+') #=> /^a-z+:\s+\w+/
  #     r2 = Regexp.new('cat', true)     #=> /cat/i
  #     r3 = Regexp.new(r2)              #=> /cat/i
  #     r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=> /dog/ix
  #
  def initialize: (String string, ?untyped options, ?String kcode) -> Object
                | (Regexp regexp) -> void

  # <!--
  #   rdoc-file=re.c
  #   - compile(*args)
  # -->
  # Alias for Regexp.new
  #
  def self.compile: (String string, ?untyped options, ?String kcode) -> Regexp
                  | (Regexp regexp) -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(str)   -> string
  #   - Regexp.quote(str)    -> string
  # -->
  # Escapes any characters that would have special meaning in a regular
  # expression. Returns a new escaped string with the same or compatible encoding.
  # For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.
  #
  #     Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.
  #
  def self.escape: (String | Symbol str) -> String

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.last_match           -> matchdata
  #   - Regexp.last_match(n)        -> str
  # -->
  # The first form returns the MatchData object generated by the last successful
  # pattern match.  Equivalent to reading the special global variable `$~` (see
  # Special global variables in Regexp for details).
  #
  # The second form returns the *n*th field in this MatchData object. *n* can be a
  # string or symbol to reference a named capture.
  #
  # Note that the last_match is local to the thread and method scope of the method
  # that did the pattern match.
  #
  #     /c(.)t/ =~ 'cat'        #=> 0
  #     Regexp.last_match       #=> #<MatchData "cat" 1:"a">
  #     Regexp.last_match(0)    #=> "cat"
  #     Regexp.last_match(1)    #=> "a"
  #     Regexp.last_match(2)    #=> nil
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "var = val"
  #     Regexp.last_match       #=> #<MatchData "var = val" lhs:"var" rhs:"val">
  #     Regexp.last_match(:lhs) #=> "var"
  #     Regexp.last_match(:rhs) #=> "val"
  #
  def self.last_match: () -> MatchData?
                     | (Integer n) -> String?
                     | (Symbol | String n) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.escape(str)   -> string
  #   - Regexp.quote(str)    -> string
  # -->
  # Escapes any characters that would have special meaning in a regular
  # expression. Returns a new escaped string with the same or compatible encoding.
  # For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.
  #
  #     Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.
  #
  def self.quote: (String | Symbol str) -> String

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.try_convert(obj) -> re or nil
  # -->
  # Try to convert *obj* into a Regexp, using to_regexp method. Returns converted
  # regexp or nil if *obj* cannot be converted for any reason.
  #
  #     Regexp.try_convert(/re/)         #=> /re/
  #     Regexp.try_convert("re")         #=> nil
  #
  #     o = Object.new
  #     Regexp.try_convert(o)            #=> nil
  #     def o.to_regexp() /foo/ end
  #     Regexp.try_convert(o)            #=> /foo/
  #
  def self.try_convert: (untyped obj) -> Regexp?

  # <!--
  #   rdoc-file=re.c
  #   - Regexp.union(pat1, pat2, ...)            -> new_regexp
  #   - Regexp.union(pats_ary)                   -> new_regexp
  # -->
  # Return a Regexp object that is the union of the given *pattern*s, i.e., will
  # match any of its parts. The *pattern*s can be Regexp objects, in which case
  # their options will be preserved, or Strings. If no patterns are given, returns
  # `/(?!)/`.  The behavior is unspecified if any given *pattern* contains
  # capture.
  #
  #     Regexp.union                         #=> /(?!)/
  #     Regexp.union("penzance")             #=> /penzance/
  #     Regexp.union("a+b*c")                #=> /a\+b\*c/
  #     Regexp.union("skiing", "sledding")   #=> /skiing|sledding/
  #     Regexp.union(["skiing", "sledding"]) #=> /skiing|sledding/
  #     Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/
  #
  # Note: the arguments for ::union will try to be converted into a regular
  # expression literal via #to_regexp.
  #
  def self.union: () -> Regexp
                | (String | Regexp pat1, *String | Regexp pat2) -> Regexp
                | (::Array[String | Regexp]) -> Regexp

  public

  # <!-- rdoc-file=re.c -->
  # Equality---Two regexps are equal if their patterns are identical, they have
  # the same character set code, and their `casefold?` values are the same.
  #
  #     /abc/  == /abc/x   #=> false
  #     /abc/  == /abc/i   #=> false
  #     /abc/  == /abc/u   #=> false
  #     /abc/u == /abc/n   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp === str   -> true or false
  # -->
  # Case Equality---Used in case statements.
  #
  #     a = "HELLO"
  #     case a
  #     when /\A[a-z]*\z/; print "Lower case\n"
  #     when /\A[A-Z]*\z/; print "Upper case\n"
  #     else;              print "Mixed case\n"
  #     end
  #     #=> "Upper case"
  #
  # Following a regular expression literal with the #=== operator allows you to
  # compare against a String.
  #
  #     /^[a-z]*$/ === "HELLO" #=> false
  #     /^[A-Z]*$/ === "HELLO" #=> true
  #
  def ===: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp =~ str    -> integer or nil
  # -->
  # Match---Matches *rxp* against *str*.
  #
  #     /at/ =~ "input data"   #=> 7
  #     /ax/ =~ "input data"   #=> nil
  #
  # If `=~` is used with a regexp literal with named captures, captured strings
  # (or nil) is assigned to local variables named by the capture names.
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = y  "
  #     p lhs    #=> "x"
  #     p rhs    #=> "y"
  #
  # If it is not matched, nil is assigned for the variables.
  #
  #     /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = "
  #     p lhs    #=> nil
  #     p rhs    #=> nil
  #
  # This assignment is implemented in the Ruby parser. The parser detects
  # 'regexp-literal =~ expression' for the assignment. The regexp must be a
  # literal without interpolation and placed at left hand side.
  #
  # The assignment does not occur if the regexp is not a literal.
  #
  #     re = /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
  #     re =~ "  x = y  "
  #     p lhs    # undefined local variable
  #     p rhs    # undefined local variable
  #
  # A regexp interpolation, `#{}`, also disables the assignment.
  #
  #     rhs_pat = /(?<rhs>\w+)/
  #     /(?<lhs>\w+)\s*=\s*#{rhs_pat}/ =~ "x = y"
  #     p lhs    # undefined local variable
  #
  # The assignment does not occur if the regexp is placed at the right hand side.
  #
  #     "  x = y  " =~ /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
  #     p lhs, rhs # undefined local variable
  #
  def =~: (String? str) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - rxp.casefold?   -> true or false
  # -->
  # Returns the value of the case-insensitive flag.
  #
  #     /a/.casefold?           #=> false
  #     /a/i.casefold?          #=> true
  #     /(?i:a)/.casefold?      #=> false
  #
  def casefold?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=re.c
  #   - rxp == other_rxp      -> true or false
  #   - rxp.eql?(other_rxp)   -> true or false
  # -->
  # Equality---Two regexps are equal if their patterns are identical, they have
  # the same character set code, and their `casefold?` values are the same.
  #
  #     /abc/  == /abc/x   #=> false
  #     /abc/  == /abc/i   #=> false
  #     /abc/  == /abc/u   #=> false
  #     /abc/u == /abc/n   #=> false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.fixed_encoding?   -> true or false
  # -->
  # Returns false if rxp is applicable to a string with any ASCII compatible
  # encoding. Returns true otherwise.
  #
  #     r = /a/
  #     r.fixed_encoding?                               #=> false
  #     r =~ "\u{6666} a"                               #=> 2
  #     r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2
  #     r =~ "abc".force_encoding("euc-jp")             #=> 0
  #
  #     r = /a/u
  #     r.fixed_encoding?                               #=> true
  #     r.encoding                                      #=> #<Encoding:UTF-8>
  #     r =~ "\u{6666} a"                               #=> 2
  #     r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
  #     r =~ "abc".force_encoding("euc-jp")             #=> 0
  #
  #     r = /\u{6666}/
  #     r.fixed_encoding?                               #=> true
  #     r.encoding                                      #=> #<Encoding:UTF-8>
  #     r =~ "\u{6666} a"                               #=> 0
  #     r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
  #     r =~ "abc".force_encoding("euc-jp")             #=> nil
  #
  def fixed_encoding?: () -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.hash   -> integer
  # -->
  # Produce a hash based on the text and options of this regular expression.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - rxp.inspect   -> string
  # -->
  # Produce a nicely formatted string-version of *rxp*. Perhaps surprisingly,
  # `#inspect` actually produces the more natural version of the string than
  # `#to_s`.
  #
  #     /ab+c/ix.inspect        #=> "/ab+c/ix"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - rxp.match(str, pos=0)                   -> matchdata or nil
  #   - rxp.match(str, pos=0) {|match| block }  -> obj
  # -->
  # Returns a MatchData object describing the match, or `nil` if there was no
  # match. This is equivalent to retrieving the value of the special variable `$~`
  # following a normal match.  If the second parameter is present, it specifies
  # the position in the string to begin the search.
  #
  #     /(.)(.)(.)/.match("abc")[2]   #=> "b"
  #     /(.)(.)/.match("abc", 1)[2]   #=> "c"
  #
  # If a block is given, invoke the block with MatchData if match succeed, so that
  # you can write
  #
  #     /M(.*)/.match("Matz") do |m|
  #       puts m[0]
  #       puts m[1]
  #     end
  #
  # instead of
  #
  #     if m = /M(.*)/.match("Matz")
  #       puts m[0]
  #       puts m[1]
  #     end
  #
  # The return value is a value from block execution in this case.
  #
  def match: (String? | Symbol | _ToStr str, ?Integer pos) -> MatchData?
           | [T] (String? | Symbol | _ToStr str, ?Integer pos) { (MatchData) -> T } -> T?

  # <!--
  #   rdoc-file=re.c
  #   - rxp.match?(str)          -> true or false
  #   - rxp.match?(str, pos=0)   -> true or false
  # -->
  # Returns `true` or `false` to indicate whether the regexp is matched or not
  # without updating $~ and other related variables. If the second parameter is
  # present, it specifies the position in the string to begin the search.
  #
  #     /R.../.match?("Ruby")    #=> true
  #     /R.../.match?("Ruby", 1) #=> false
  #     /P.../.match?("Ruby")    #=> false
  #     $&                       #=> nil
  #
  def match?: (String? | Symbol | _ToStr str, ?Integer pos) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - rxp.named_captures  -> hash
  # -->
  # Returns a hash representing information about named captures of *rxp*.
  #
  # A key of the hash is a name of the named captures. A value of the hash is an
  # array which is list of indexes of corresponding named captures.
  #
  #     /(?<foo>.)(?<bar>.)/.named_captures
  #     #=> {"foo"=>[1], "bar"=>[2]}
  #
  #     /(?<foo>.)(?<foo>.)/.named_captures
  #     #=> {"foo"=>[1, 2]}
  #
  # If there are no named captures, an empty hash is returned.
  #
  #     /(.)(.)/.named_captures
  #     #=> {}
  #
  def named_captures: () -> ::Hash[String, ::Array[Integer]]

  # <!--
  #   rdoc-file=re.c
  #   - rxp.names   -> [name1, name2, ...]
  # -->
  # Returns a list of names of captures as an array of strings.
  #
  #     /(?<foo>.)(?<bar>.)(?<baz>.)/.names
  #     #=> ["foo", "bar", "baz"]
  #
  #     /(?<foo>.)(?<foo>.)/.names
  #     #=> ["foo"]
  #
  #     /(.)(.)/.names
  #     #=> []
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - rxp.options   -> integer
  # -->
  # Returns the set of bits corresponding to the options used when creating this
  # Regexp (see Regexp::new for details. Note that additional bits may be set in
  # the returned options: these are used internally by the regular expression
  # code. These extra bits are ignored if the options are passed to Regexp::new.
  #
  #     Regexp::IGNORECASE                  #=> 1
  #     Regexp::EXTENDED                    #=> 2
  #     Regexp::MULTILINE                   #=> 4
  #
  #     /cat/.options                       #=> 0
  #     /cat/ix.options                     #=> 3
  #     Regexp.new('cat', true).options     #=> 1
  #     /\xa1\xa2/e.options                 #=> 16
  #
  #     r = /cat/ix
  #     Regexp.new(r.source, r.options)     #=> /cat/ix
  #
  def options: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - rxp.source   -> str
  # -->
  # Returns the original string of the pattern.
  #
  #     /ab+c/ix.source #=> "ab+c"
  #
  # Note that escape sequences are retained as is.
  #
  #     /\x20\+/.source  #=> "\\x20\\+"
  #
  def source: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - rxp.to_s   -> str
  # -->
  # Returns a string containing the regular expression and its options (using the
  # `(?opts:source)` notation. This string can be fed back in to Regexp::new to a
  # regular expression with the same semantics as the original. (However,
  # `Regexp#==` may not return true when comparing the two, as the source of the
  # regular expression itself may differ, as the example shows).  Regexp#inspect
  # produces a generally more readable version of *rxp*.
  #
  #     r1 = /ab+c/ix           #=> /ab+c/ix
  #     s1 = r1.to_s            #=> "(?ix-m:ab+c)"
  #     r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/
  #     r1 == r2                #=> false
  #     r1.source               #=> "ab+c"
  #     r2.source               #=> "(?ix-m:ab+c)"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - ~ rxp   -> integer or nil
  # -->
  # Match---Matches *rxp* against the contents of `$_`. Equivalent to *`rxp* =~
  # $_`.
  #
  #     $_ = "input data"
  #     ~ /at/   #=> 7
  #
  def ~: () -> Integer?

  private

  def initialize_copy: (self object) -> self
end

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::EXTENDED: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::FIXEDENCODING: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::IGNORECASE: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::MULTILINE: Integer

# <!-- rdoc-file=re.c -->
# see Regexp.options and Regexp.new
#
Regexp::NOENCODING: Integer

# <!-- rdoc-file=object.c -->
# Object is the default root of all Ruby objects.  Object inherits from
# BasicObject which allows creating alternate object hierarchies.  Methods on
# Object are available to all classes unless explicitly overridden.
#
# Object mixes in the Kernel module, making the built-in kernel functions
# globally accessible.  Although the instance methods of Object are defined by
# the Kernel module, we have chosen to document them here for clarity.
#
# When referencing constants in classes inheriting from Object you do not need
# to use the full namespace.  For example, referencing `File` inside `YourClass`
# will find the top-level File class.
#
# In the descriptions of Object's methods, the parameter *symbol* refers to a
# symbol, which is either a quoted string or a Symbol (such as `:name`).
#
# ## What's Here
#
# First, what's elsewhere. Class Object:
#
# *   Inherits from [class
#     BasicObject](BasicObject.html#class-BasicObject-label-What-27s+Here).
# *   Includes [module Kernel](Kernel.html#module-Kernel-label-What-27s+Here).
#
#
# Here, class Object provides methods for:
#
# *   [Querying](#class-Object-label-Querying)
# *   [Instance Variables](#class-Object-label-Instance+Variables)
# *   [Other](#class-Object-label-Other)
#
#
# ### Querying
#
#     [!~](#method-i-21~)
# :       Returns `true` if `self` does not match the given object, otherwise
#         `false`.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns 0 if `self` and the given object `object` are the same object,
#         or if `self == object`; otherwise returns `nil`.
#
#     #===
# :       Implements case equality, effectively the same as calling #==.
#
#     #eql?
# :       Implements hash equality, effectively the same as calling #==.
#
#     #kind_of? (aliased as #is_a?)
# :       Returns whether given argument is an ancestor of the singleton class
#         of `self`.
#
#     #instance_of?
# :       Returns whether `self` is an instance of the given class.
#
#     #instance_variable_defined?
# :       Returns whether the given instance variable is defined in `self`.
#
#     #method
# :       Returns the Method object for the given method in `self`.
#
#     #methods
# :       Returns an array of symbol names of public and protected methods in
#         `self`.
#
#     #nil?
# :       Returns `false`. (Only `nil` responds `true` to method `nil?`.)
#
#     #object_id
# :       Returns an integer corresponding to `self` that is unique for the
#         current process
#
#     #private_methods
# :       Returns an array of the symbol names of the private methods in `self`.
#
#     #protected_methods
# :       Returns an array of the symbol names of the protected methods in
#         `self`.
#
#     #public_method
# :       Returns the Method object for the given public method in `self`.
#
#     #public_methods
# :       Returns an array of the symbol names of the public methods in `self`.
#
#     #respond_to?
# :       Returns whether `self` responds to the given method.
#
#     #singleton_class
# :       Returns the singleton class of `self`.
#
#     #singleton_method
# :       Returns the Method object for the given singleton method in `self`.
#
#     #singleton_methods
# :       Returns an array of the symbol names of the singleton methods in
#         `self`.
#
#
#     #define_singleton_method
# :       Defines a singleton method in `self` for the given symbol method-name
#         and block or proc.
#
#     #extend
# :       Includes the given modules in the singleton class of `self`.
#
#     #public_send
# :       Calls the given public method in `self` with the given argument.
#
#     #send
# :       Calls the given method in `self` with the given argument.
#
#
#
# ### Instance Variables
#
#     #instance_variable_get
# :       Returns the value of the given instance variable in `self`, or `nil`
#         if the instance variable is not set.
#
#     #instance_variable_set
# :       Sets the value of the given instance variable in `self` to the given
#         object.
#
#     #instance_variables
# :       Returns an array of the symbol names of the instance variables in
#         `self`.
#
#     #remove_instance_variable
# :       Removes the named instance variable from `self`.
#
#
#
# ### Other
#
#     #clone
# :       Returns a shallow copy of `self`, including singleton class and frozen
#         state.
#
#     #define_singleton_method
# :       Defines a singleton method in `self` for the given symbol method-name
#         and block or proc.
#
#     #display
# :       Prints `self` to the given IO stream or `$stdout`.
#
#     #dup
# :       Returns a shallow unfrozen copy of `self`.
#
#     #enum_for (aliased as #to_enum)
# :       Returns an Enumerator for `self` using the using the given method,
#         arguments, and block.
#
#     #extend
# :       Includes the given modules in the singleton class of `self`.
#
#     #freeze
# :       Prevents further modifications to `self`.
#
#     #hash
# :       Returns the integer hash value for `self`.
#
#     #inspect
# :       Returns a human-readable  string representation of `self`.
#
#     #itself
# :       Returns `self`.
#
#     #public_send
# :       Calls the given public method in `self` with the given argument.
#
#     #send
# :       Calls the given method in `self` with the given argument.
#
#     #to_s
# :       Returns a string representation of `self`.
#
class Object < BasicObject
  include Kernel

  # <!--
  #   rdoc-file=object.c
  #   - obj !~ other  -> true or false
  # -->
  # Returns true if two objects do not match (using the *=~* method), otherwise
  # false.
  #
  def !~: (untyped) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj <=> other -> 0 or nil
  # -->
  # Returns 0 if `obj` and `other` are the same object or `obj == other`,
  # otherwise nil.
  #
  # The #<=> is used by various methods to compare objects, for example
  # Enumerable#sort, Enumerable#max etc.
  #
  # Your implementation of #<=> should return one of the following values: -1, 0,
  # 1 or nil. -1 means self is smaller than other. 0 means self is equal to other.
  # 1 means self is bigger than other. Nil means the two values could not be
  # compared.
  #
  # When you define #<=>, you can include Comparable to gain the methods #<=, #<,
  # #==, #>=, #> and #between?.
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj =~ other  -> nil
  # -->
  # This method is deprecated.
  #
  # This is not only useless but also troublesome because it may hide a type
  # error.
  #
  def =~: (untyped) -> bool

  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as `class` is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> untyped

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `clone` copies the frozen (unless :freeze
  # keyword argument is given with a false value) and tainted state of *obj*. See
  # also the discussion under `Object#dup`.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool?) -> self

  # <!--
  #   rdoc-file=proc.c
  #   - define_singleton_method(symbol, method) -> symbol
  #   - define_singleton_method(symbol) { block } -> symbol
  # -->
  # Defines a singleton method in the receiver. The *method* parameter can be a
  # `Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
  # is used as the method body. If a block or a method has parameters, they're
  # used as method parameters.
  #
  #     class A
  #       class << self
  #         def class_name
  #           to_s
  #         end
  #       end
  #     end
  #     A.define_singleton_method(:who_am_i) do
  #       "I am: #{class_name}"
  #     end
  #     A.who_am_i   # ==> "I am: A"
  #
  #     guy = "Bob"
  #     guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
  #     guy.hello    #=>  "Bob: Hello there!"
  #
  #     chris = "Chris"
  #     chris.define_singleton_method(:greet) {|greeting| "#{greeting}, I'm Chris!" }
  #     chris.greet("Hi") #=> "Hi, I'm Chris!"
  #
  def define_singleton_method: (Symbol, Method | UnboundMethod) -> Symbol
                             | (Symbol) { (*untyped) -> untyped } -> Symbol

  # <!--
  #   rdoc-file=io.c
  #   - obj.display(port=$>)    -> nil
  # -->
  # Prints *obj* on the given port (default `$>`). Equivalent to:
  #
  #     def display(port=$>)
  #       port.write self
  #       nil
  #     end
  #
  # For example:
  #
  #     1.display
  #     "cat".display
  #     [ 4, 5, 6 ].display
  #     puts
  #
  # *produces:*
  #
  #     1cat[4, 5, 6]
  #
  def display: (?_Writeable port) -> void

  # <!--
  #   rdoc-file=object.c
  #   - obj.dup -> an_object
  # -->
  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, #clone and #dup may have different semantics in descendant
  # classes. While #clone is used to duplicate an object, including its internal
  # state, #dup typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401be280>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401c1084>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401c1084>
  #
  def dup: () -> self

  # <!-- rdoc-file=enumerator.c -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  def enum_for: (Symbol method, *untyped args) ?{ (*untyped args) -> Integer } -> Enumerator[untyped, untyped]
              | () ?{ () -> Integer } -> Enumerator[untyped, self]

  # <!--
  #   rdoc-file=enumerator.c
  #   - obj.to_enum(method = :each, *args)                 -> enum
  #   - obj.enum_for(method = :each, *args)                -> enum
  #   - obj.to_enum(method = :each, *args) {|*args| block} -> enum
  #   - obj.enum_for(method = :each, *args){|*args| block} -> enum
  # -->
  # Creates a new Enumerator which will enumerate by calling `method` on `obj`,
  # passing `args` if any. What was *yielded* by method becomes values of
  # enumerator.
  #
  # If a block is given, it will be used to calculate the size of the enumerator
  # without the need to iterate it (see Enumerator#size).
  #
  # ### Examples
  #
  #     str = "xyz"
  #
  #     enum = str.enum_for(:each_byte)
  #     enum.each { |b| puts b }
  #     # => 120
  #     # => 121
  #     # => 122
  #
  #     # protect an array from being modified by some_method
  #     a = [1, 2, 3]
  #     some_method(a.to_enum)
  #
  #     # String#split in block form is more memory-effective:
  #     very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
  #     # This could be rewritten more idiomatically with to_enum:
  #     very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first
  #
  # It is typical to call to_enum when defining methods for a generic Enumerable,
  # in case no block is passed.
  #
  # Here is such an example, with parameter passing and a sizing block:
  #
  #     module Enumerable
  #       # a generic method to repeat the values of any enumerable
  #       def repeat(n)
  #         raise ArgumentError, "#{n} is negative!" if n < 0
  #         unless block_given?
  #           return to_enum(__method__, n) do # __method__ is :repeat here
  #             sz = size     # Call size and multiply by n...
  #             sz * n if sz  # but return nil if size itself is nil
  #           end
  #         end
  #         each do |*val|
  #           n.times { yield *val }
  #         end
  #       end
  #     end
  #
  #     %i[hello world].repeat(2) { |w| puts w }
  #       # => Prints 'hello', 'hello', 'world', 'world'
  #     enum = (1..14).repeat(3)
  #       # => returns an Enumerator when called without a block
  #     enum.first(4) # => [1, 1, 1, 2]
  #     enum.size # => 42
  #
  alias to_enum enum_for

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=eval.c
  #   - obj.extend(module, ...)    -> obj
  # -->
  # Adds to *obj* the instance methods from each module given as a parameter.
  #
  #     module Mod
  #       def hello
  #         "Hello from Mod.\n"
  #       end
  #     end
  #
  #     class Klass
  #       def hello
  #         "Hello from Klass.\n"
  #       end
  #     end
  #
  #     k = Klass.new
  #     k.hello         #=> "Hello from Klass.\n"
  #     k.extend(Mod)   #=> #<Klass:0x401b3bc8>
  #     k.hello         #=> "Hello from Mod.\n"
  #
  def extend: (*Module) -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.freeze    -> obj
  # -->
  # Prevents further modifications to *obj*. A FrozenError will be raised if
  # modification is attempted. There is no way to unfreeze a frozen object. See
  # also Object#frozen?.
  #
  # This method returns self.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze
  #     a << "z"
  #
  # *produces:*
  #
  #     prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
  #      from prog.rb:3
  #
  # Objects of the following classes are always frozen: Integer, Float, Symbol.
  #
  def freeze: () -> self

  # Returns the freeze status of *obj*.
  #
  #     a = [ "a", "b", "c" ]
  #     a.freeze    #=> ["a", "b", "c"]
  #     a.frozen?   #=> true
  #
  def frozen?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.hash    -> integer
  # -->
  # Generates an Integer hash value for this object.  This function must have the
  # property that `a.eql?(b)` implies `a.hash == b.hash`.
  #
  # The hash value is used along with #eql? by the Hash class to determine if two
  # objects reference the same hash key.  Any hash value that exceeds the capacity
  # of an Integer will be truncated before being used.
  #
  # The hash value for an object may not be identical across invocations or
  # implementations of Ruby.  If you need a stable identifier across Ruby
  # invocations and implementations you will need to generate one with a custom
  # method.
  #
  # Certain core classes such as Integer use built-in hash calculations and do not
  # call the #hash method when used as a hash key.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.inspect   -> string
  # -->
  # Returns a string containing a human-readable representation of *obj*. The
  # default #inspect shows the object's class name, an encoding of its memory
  # address, and a list of the instance variables and their values (by calling
  # #inspect on each of them).  User defined classes should override this method
  # to provide a better representation of *obj*.  When overriding this method, it
  # should return a string whose encoding is compatible with the default external
  # encoding.
  #
  #     [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
  #     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
  #
  #     class Foo
  #     end
  #     Foo.new.inspect                  #=> "#<Foo:0x0300c868>"
  #
  #     class Bar
  #       def initialize
  #         @bar = 1
  #       end
  #     end
  #     Bar.new.inspect                  #=> "#<Bar:0x0300c868 @bar=1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_of?(class)    -> true or false
  # -->
  # Returns `true` if *obj* is an instance of the given class. See also
  # Object#kind_of?.
  #
  #     class A;     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.instance_of? A   #=> false
  #     b.instance_of? B   #=> true
  #     b.instance_of? C   #=> false
  #
  def instance_of?: (Module) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_defined?(symbol)    -> true or false
  #   - obj.instance_variable_defined?(string)    -> true or false
  # -->
  # Returns `true` if the given instance variable is defined in *obj*. String
  # arguments are converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_defined?(:@a)    #=> true
  #     fred.instance_variable_defined?("@b")   #=> true
  #     fred.instance_variable_defined?("@c")   #=> false
  #
  def instance_variable_defined?: (String | Symbol var) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_get(symbol)    -> obj
  #   - obj.instance_variable_get(string)    -> obj
  # -->
  # Returns the value of the given instance variable, or nil if the instance
  # variable is not set. The `@` part of the variable name should be included for
  # regular instance variables. Throws a NameError exception if the supplied
  # symbol is not valid as an instance variable name. String arguments are
  # converted to symbols.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_get(:@a)    #=> "cat"
  #     fred.instance_variable_get("@b")   #=> 99
  #
  def instance_variable_get: (String | Symbol var) -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variable_set(symbol, obj)    -> obj
  #   - obj.instance_variable_set(string, obj)    -> obj
  # -->
  # Sets the instance variable named by *symbol* to the given object. This may
  # circumvent the encapsulation intended by the author of the class, so it should
  # be used with care. The variable does not have to exist prior to this call. If
  # the instance variable name is passed as a string, that string is converted to
  # a symbol.
  #
  #     class Fred
  #       def initialize(p1, p2)
  #         @a, @b = p1, p2
  #       end
  #     end
  #     fred = Fred.new('cat', 99)
  #     fred.instance_variable_set(:@a, 'dog')   #=> "dog"
  #     fred.instance_variable_set(:@c, 'cat')   #=> "cat"
  #     fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"
  #
  def instance_variable_set: [X] (String | Symbol var, X value) -> X

  # <!--
  #   rdoc-file=object.c
  #   - obj.instance_variables    -> array
  # -->
  # Returns an array of instance variable names for the receiver. Note that simply
  # defining an accessor does not create the corresponding instance variable.
  #
  #     class Fred
  #       attr_accessor :a1
  #       def initialize
  #         @iv = 3
  #       end
  #     end
  #     Fred.new.instance_variables   #=> [:@iv]
  #
  def instance_variables: () -> Array[Symbol]

  # <!-- rdoc-file=object.c -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  def is_a?: (Module) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.is_a?(class)       -> true or false
  #   - obj.kind_of?(class)    -> true or false
  # -->
  # Returns `true` if *class* is the class of *obj*, or if *class* is one of the
  # superclasses of *obj* or modules included in *obj*.
  #
  #     module M;    end
  #     class A
  #       include M
  #     end
  #     class B < A; end
  #     class C < B; end
  #
  #     b = B.new
  #     b.is_a? A          #=> true
  #     b.is_a? B          #=> true
  #     b.is_a? C          #=> false
  #     b.is_a? M          #=> true
  #
  #     b.kind_of? A       #=> true
  #     b.kind_of? B       #=> true
  #     b.kind_of? C       #=> false
  #     b.kind_of? M       #=> true
  #
  alias kind_of? is_a?

  # <!--
  #   rdoc-file=object.c
  #   - obj.itself    -> obj
  # -->
  # Returns the receiver.
  #
  #     string = "my string"
  #     string.itself.object_id == string.object_id   #=> true
  #
  def itself: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - obj.method(sym)    -> method
  # -->
  # Looks up the named method as a receiver in *obj*, returning a Method object
  # (or raising NameError). The Method object acts as a closure in *obj*'s object
  # instance, so instance variables and the value of `self` remain available.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     m = k.method(:hello)
  #     m.call   #=> "Hello, @iv = 99"
  #
  #     l = Demo.new('Fred')
  #     m = l.method("hello")
  #     m.call   #=> "Hello, @iv = Fred"
  #
  # Note that Method implements `to_proc` method, which means it can be used with
  # iterators.
  #
  #     [ 1, 2, 3 ].each(&method(:puts)) # => prints 3 lines to stdout
  #
  #     out = File.open('test.txt', 'w')
  #     [ 1, 2, 3 ].each(&out.method(:puts)) # => prints 3 lines to file
  #
  #     require 'date'
  #     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
  #     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
  #
  def method: (String | Symbol name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.methods(regular=true)    -> array
  # -->
  # Returns a list of the names of public and protected methods of *obj*. This
  # will include all the methods accessible in *obj*'s ancestors. If the optional
  # parameter is `false`, it returns an array of *obj*'s public and protected
  # singleton methods, the array will not include methods in modules included in
  # *obj*.
  #
  #     class Klass
  #       def klass_method()
  #       end
  #     end
  #     k = Klass.new
  #     k.methods[0..9]    #=> [:klass_method, :nil?, :===,
  #                        #    :==~, :!, :eql?
  #                        #    :hash, :<=>, :class, :singleton_class]
  #     k.methods.length   #=> 56
  #
  #     k.methods(false)   #=> []
  #     def k.singleton_method; end
  #     k.methods(false)   #=> [:singleton_method]
  #
  #     module M123; def m123; end end
  #     k.extend M123
  #     k.methods(false)   #=> [:singleton_method]
  #
  def methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.nil?               -> true or false
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  #     Object.new.nil?   #=> false
  #     nil.nil?          #=> true
  #
  def nil?: () -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  def object_id: () -> Integer

  # <!--
  #   rdoc-file=object.c
  #   - obj.private_methods(all=true)   -> array
  # -->
  # Returns the list of private methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def private_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.protected_methods(all=true)   -> array
  # -->
  # Returns the list of protected methods accessible to *obj*. If the *all*
  # parameter is set to `false`, only those methods in the receiver will be
  # listed.
  #
  def protected_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=proc.c
  #   - obj.public_method(sym)    -> method
  # -->
  # Similar to *method*, searches public method only.
  #
  def public_method: (name name) -> Method

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.public_send(symbol [, args...])  -> obj
  #   - obj.public_send(string [, args...])  -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # Unlike send, public_send calls public methods only. When the method is
  # identified by a string, the string is converted to a symbol.
  #
  #     1.public_send(:puts, "hello")  # causes NoMethodError
  #
  def public_send: (name name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.remove_instance_variable(symbol)    -> obj
  #   - obj.remove_instance_variable(string)    -> obj
  # -->
  # Removes the named instance variable from *obj*, returning that variable's
  # value. String arguments are converted to symbols.
  #
  #     class Dummy
  #       attr_reader :var
  #       def initialize
  #         @var = 99
  #       end
  #       def remove
  #         remove_instance_variable(:@var)
  #       end
  #     end
  #     d = Dummy.new
  #     d.var      #=> 99
  #     d.remove   #=> 99
  #     d.var      #=> nil
  #
  def remove_instance_variable: (name name) -> untyped

  # <!--
  #   rdoc-file=vm_method.c
  #   - obj.respond_to?(symbol, include_all=false) -> true or false
  #   - obj.respond_to?(string, include_all=false) -> true or false
  # -->
  # Returns `true` if *obj* responds to the given method.  Private and protected
  # methods are included in the search only if the optional second parameter
  # evaluates to `true`.
  #
  # If the method is not implemented, as Process.fork on Windows, File.lchmod on
  # GNU/Linux, etc., false is returned.
  #
  # If the method is not defined, `respond_to_missing?` method is called and the
  # result is returned.
  #
  # When the method name parameter is given as a string, the string is converted
  # to a symbol.
  #
  def respond_to?: (name name, ?boolish include_all) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  def send: (name name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_class    -> class
  # -->
  # Returns the singleton class of *obj*.  This method creates a new singleton
  # class if *obj* does not have one.
  #
  # If *obj* is `nil`, `true`, or `false`, it returns NilClass, TrueClass, or
  # FalseClass, respectively. If *obj* is an Integer, a Float or a Symbol, it
  # raises a TypeError.
  #
  #     Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
  #     String.singleton_class      #=> #<Class:String>
  #     nil.singleton_class         #=> NilClass
  #
  def singleton_class: () -> Class

  # <!--
  #   rdoc-file=proc.c
  #   - obj.singleton_method(sym)    -> method
  # -->
  # Similar to *method*, searches singleton method only.
  #
  #     class Demo
  #       def initialize(n)
  #         @iv = n
  #       end
  #       def hello()
  #         "Hello, @iv = #{@iv}"
  #       end
  #     end
  #
  #     k = Demo.new(99)
  #     def k.hi
  #       "Hi, @iv = #{@iv}"
  #     end
  #     m = k.singleton_method(:hi)
  #     m.call   #=> "Hi, @iv = 99"
  #     m = k.singleton_method(:hello) #=> NameError
  #
  def singleton_method: (name name) -> Method

  # <!--
  #   rdoc-file=object.c
  #   - obj.singleton_methods(all=true)    -> array
  # -->
  # Returns an array of the names of singleton methods for *obj*. If the optional
  # *all* parameter is true, the list will include methods in modules included in
  # *obj*. Only public and protected singleton methods are returned.
  #
  #     module Other
  #       def three() end
  #     end
  #
  #     class Single
  #       def Single.four() end
  #     end
  #
  #     a = Single.new
  #
  #     def a.one()
  #     end
  #
  #     class << a
  #       include Other
  #       def two()
  #       end
  #     end
  #
  #     Single.singleton_methods    #=> [:four]
  #     a.singleton_methods(false)  #=> [:two, :one]
  #     a.singleton_methods         #=> [:two, :one, :three]
  #
  def singleton_methods: () -> Array[Symbol]

  # <!--
  #   rdoc-file=object.c
  #   - obj.taint -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  def taint: () -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.untrust -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  alias untrust taint

  # <!--
  #   rdoc-file=object.c
  #   - obj.tainted?    -> false
  # -->
  # Returns false.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def tainted?: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj.untrusted?    -> false
  # -->
  # Returns false.  This method is deprecated and will be removed in Ruby 3.2.
  #
  alias untrusted? tainted?

  # Yields self to the block, and then returns self. The primary purpose of this
  # method is to "tap into" a method chain, in order to perform operations on
  # intermediate results within the chain.
  #
  #     (1..10)                  .tap {|x| puts "original: #{x}" }
  #       .to_a                  .tap {|x| puts "array:    #{x}" }
  #       .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
  #       .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }
  #
  def tap: () { (self) -> void } -> self

  # Yields self to the block and returns the result of the block.
  #
  #     3.next.then {|x| x**x }.to_s             #=> "256"
  #     "my string".yield_self {|s| s.upcase }   #=> "MY STRING"
  #
  # Good usage for `yield_self` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments).
  #       yield_self {|url| open(url).read }.
  #       yield_self {|response| JSON.parse(response) }
  #
  # When called without block, the method returns `Enumerator`, which can be used,
  # for example, for conditional circuit-breaking:
  #
  #     # meets condition, no-op
  #     1.yield_self.detect(&:odd?)            # => 1
  #     # does not meet condition, drop value
  #     2.yield_self.detect(&:odd?)            # => nil
  #
  def yield_self: [X] () { (self) -> X } -> X
                | () -> Enumerator[self, untyped]

  # <!--
  #   rdoc-file=object.c
  #   - obj.to_s    -> string
  # -->
  # Returns a string representing *obj*. The default #to_s prints the object's
  # class and an encoding of the object id. As a special case, the top-level
  # object that is the initial execution context of Ruby programs returns
  # ``main''.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=object.c
  #   - obj.untaint    -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  def untaint: () -> self

  # <!--
  #   rdoc-file=object.c
  #   - obj.trust    -> obj
  # -->
  # Returns object. This method is deprecated and will be removed in Ruby 3.2.
  #
  alias trust untaint

  # Yields self to the block and returns the result of the block.
  #
  #     3.next.then {|x| x**x }.to_s             #=> "256"
  #     "my string".yield_self {|s| s.upcase }   #=> "MY STRING"
  #
  # Good usage for `yield_self` is value piping in method chains:
  #
  #     require 'open-uri'
  #     require 'json'
  #
  #     construct_url(arguments).
  #       yield_self {|url| open(url).read }.
  #       yield_self {|response| JSON.parse(response) }
  #
  # When called without block, the method returns `Enumerator`, which can be used,
  # for example, for conditional circuit-breaking:
  #
  #     # meets condition, no-op
  #     1.yield_self.detect(&:odd?)            # => 1
  #     # does not meet condition, drop value
  #     2.yield_self.detect(&:odd?)            # => nil
  #
  alias then yield_self
end

interface _Writeable
  def write: (untyped) -> void
end

type Object::name = Symbol | String

# <!-- rdoc-file=re.c -->
# MatchData encapsulates the result of matching a Regexp against string. It is
# returned by Regexp#match and String#match, and also stored in a global
# variable returned by Regexp.last_match.
#
# Usage:
#
#     url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
#     m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
#     m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
#     m.regexp                    # => /(\d\.?)+/
#     # entire matched substring:
#     m[0]                        # => "2.5.0"
#
#     # Working with unnamed captures
#     m = url.match(%r{([^/]+)/([^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
#     # Working with named captures
#     m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
#     m.captures                  # => ["2.5.0", "MatchData"]
#     m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
#     m[:version]                 # => "2.5.0"
#     m.values_at(:version, :module)
#                                 # => ["2.5.0", "MatchData"]
#     # Numerical indexes are working, too
#     m[1]                        # => "2.5.0"
#     m.values_at(1, 2)           # => ["2.5.0", "MatchData"]
#
# ## Global variables equivalence
#
# Parts of last MatchData (returned by Regexp.last_match) are also aliased as
# global variables:
#
# *   `$~` is Regexp.last_match;
# *   `$&` is Regexp.last_match`[ 0 ]`;
# *   `$1`, `$2`, and so on are Regexp.last_match`[ i ]` (captures by number);
# *   `$`` is Regexp.last_match`.pre_match`;
# *   `$'` is Regexp.last_match`.post_match`;
# *   `$+` is Regexp.last_match`[ -1 ]` (the last capture).
#
#
# See also "Special global variables" section in Regexp documentation.
#
class MatchData
  public

  # <!-- rdoc-file=re.c -->
  # Equality---Two matchdata are equal if their target strings, patterns, and
  # matched positions are identical.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - mtch[i]               -> str or nil
  #   - mtch[start, length]   -> array
  #   - mtch[range]           -> array
  #   - mtch[name]            -> str or nil
  # -->
  # Match Reference -- MatchData acts as an array, and may be accessed using the
  # normal array indexing techniques.  `mtch[0]` is equivalent to the special
  # variable `$&`, and returns the entire matched string.  `mtch[1]`, `mtch[2]`,
  # and so on return the values of the matched backreferences (portions of the
  # pattern between parentheses).
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m          #=> #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
  #     m[0]       #=> "HX1138"
  #     m[1, 2]    #=> ["H", "X"]
  #     m[1..3]    #=> ["H", "X", "113"]
  #     m[-3, 2]   #=> ["X", "113"]
  #
  #     m = /(?<foo>a+)b/.match("ccaaab")
  #     m          #=> #<MatchData "aaab" foo:"aaa">
  #     m["foo"]   #=> "aaa"
  #     m[:foo]    #=> "aaa"
  #
  def []: (Integer idx) -> String?
        | (Integer start, Integer length) -> ::Array[String?]
        | (::Range[Integer] range) -> ::Array[String?]
        | (String | Symbol name) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.begin(n)   -> integer
  # -->
  # Returns the offset of the start of the *n*th element of the match array in the
  # string. *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.begin(0)       #=> 1
  #     m.begin(2)       #=> 2
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.begin(:foo)  #=> 0
  #     p m.begin(:bar)  #=> 2
  #
  def begin: (Integer | String | Symbol n_or_name) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.captures   -> array
  # -->
  # Returns the array of captures; equivalent to `mtch.to_a[1..-1]`.
  #
  #     f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures
  #     f1    #=> "H"
  #     f2    #=> "X"
  #     f3    #=> "113"
  #     f4    #=> "8"
  #
  def captures: () -> ::Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.end(n)   -> integer
  # -->
  # Returns the offset of the character immediately following the end of the *n*th
  # element of the match array in the string. *n* can be a string or symbol to
  # reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.end(0)         #=> 7
  #     m.end(2)         #=> 3
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.end(:foo)    #=> 1
  #     p m.end(:bar)    #=> 3
  #
  def end: (Integer | String | Symbol n_or_name) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch == mtch2   -> true or false
  #   - mtch.eql?(mtch2)   -> true or false
  # -->
  # Equality---Two matchdata are equal if their target strings, patterns, and
  # matched positions are identical.
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=re.c
  #   - mtch.hash   -> integer
  # -->
  # Produce a hash based on the target string, regexp and matched positions of
  # this matchdata.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.inspect   -> str
  # -->
  # Returns a printable version of *mtch*.
  #
  #     puts /.$/.match("foo").inspect
  #     #=> #<MatchData "o">
  #
  #     puts /(.)(.)(.)/.match("foo").inspect
  #     #=> #<MatchData "foo" 1:"f" 2:"o" 3:"o">
  #
  #     puts /(.)(.)?(.)/.match("fo").inspect
  #     #=> #<MatchData "fo" 1:"f" 2:nil 3:"o">
  #
  #     puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").inspect
  #     #=> #<MatchData "hog" foo:"h" bar:"o" baz:"g">
  #
  def inspect: () -> String

  # <!-- rdoc-file=re.c -->
  # Returns the number of elements in the match array.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.length   #=> 5
  #     m.size     #=> 5
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.named_captures -> hash
  # -->
  # Returns a Hash using named capture.
  #
  # A key of the hash is a name of the named captures. A value of the hash is a
  # string of last successful capture of corresponding group.
  #
  #     m = /(?<a>.)(?<b>.)/.match("01")
  #     m.named_captures #=> {"a" => "0", "b" => "1"}
  #
  #     m = /(?<a>.)(?<b>.)?/.match("0")
  #     m.named_captures #=> {"a" => "0", "b" => nil}
  #
  #     m = /(?<a>.)(?<a>.)/.match("01")
  #     m.named_captures #=> {"a" => "1"}
  #
  #     m = /(?<a>x)|(?<a>y)/.match("x")
  #     m.named_captures #=> {"a" => "x"}
  #
  def named_captures: () -> ::Hash[String, String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.names   -> [name1, name2, ...]
  # -->
  # Returns a list of names of captures as an array of strings. This is the same
  # as mtch.regexp.names.
  #
  #     /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").names
  #     #=> ["foo", "bar", "baz"]
  #
  #     m = /(?<x>.)(?<y>.)?/.match("a") #=> #<MatchData "a" x:"a" y:nil>
  #     m.names                          #=> ["x", "y"]
  #
  def names: () -> ::Array[String]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.match(n)   -> string or nil
  # -->
  # Returns the captured substring corresponding to the argument. *n* can be a
  # string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     m.match(0)       #=> "HX1138"
  #     m.match(4)       #=> "8"
  #     m.match(5)       #=> nil
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     m.match(:foo)    #=> "h"
  #     m.match(:bar)    #=> "ge"
  #
  def match: (int | String | Symbol) -> String?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.match_length(n)   -> array
  # -->
  # Returns the length of the captured substring corresponding to the argument.
  # *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
  #     m.match_length(0)       #=> 6
  #     m.match_length(4)       #=> 1
  #     m.match_length(5)       #=> nil
  #
  #     m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
  #     m.match_length(:foo)    #=> 1
  #     m.match_length(:bar)    #=> 2
  #
  def match_length: (int | String | Symbol) -> Integer?

  # <!--
  #   rdoc-file=re.c
  #   - mtch.offset(n)   -> array
  # -->
  # Returns a two-element array containing the beginning and ending offsets of the
  # *n*th match. *n* can be a string or symbol to reference a named capture.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.offset(0)      #=> [1, 7]
  #     m.offset(4)      #=> [6, 7]
  #
  #     m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
  #     p m.offset(:foo) #=> [0, 1]
  #     p m.offset(:bar) #=> [2, 3]
  #
  def offset: (Integer | Symbol | String n_or_name) -> ([ Integer, Integer ] | [ nil, nil ])

  # <!--
  #   rdoc-file=re.c
  #   - mtch.post_match   -> str
  # -->
  # Returns the portion of the original string after the current match. Equivalent
  # to the special variable `$'`.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     m.post_match   #=> ": The Movie"
  #
  def post_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.pre_match   -> str
  # -->
  # Returns the portion of the original string before the current match.
  # Equivalent to the special variable `$``.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.pre_match   #=> "T"
  #
  def pre_match: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.regexp   -> regexp
  # -->
  # Returns the regexp.
  #
  #     m = /a.*b/.match("abc")
  #     m.regexp #=> /a.*b/
  #
  def regexp: () -> Regexp

  # <!--
  #   rdoc-file=re.c
  #   - mtch.length   -> integer
  #   - mtch.size     -> integer
  # -->
  # Returns the number of elements in the match array.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.length   #=> 5
  #     m.size     #=> 5
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=re.c
  #   - mtch.string   -> str
  # -->
  # Returns a frozen copy of the string passed in to `match`.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.string   #=> "THX1138."
  #
  def string: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.to_a   -> anArray
  # -->
  # Returns the array of matches.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.to_a   #=> ["HX1138", "H", "X", "113", "8"]
  #
  # Because `to_a` is called when expanding `*`*variable*, there's a useful
  # assignment shortcut for extracting matched fields. This is slightly slower
  # than accessing the fields directly (as an intermediate array is generated).
  #
  #     all,f1,f2,f3 = * /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     all   #=> "HX1138"
  #     f1    #=> "H"
  #     f2    #=> "X"
  #     f3    #=> "113"
  #
  def to_a: () -> ::Array[String?]

  # <!--
  #   rdoc-file=re.c
  #   - mtch.to_s   -> str
  # -->
  # Returns the entire matched string.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138.")
  #     m.to_s   #=> "HX1138"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=re.c
  #   - mtch.values_at(index, ...)   -> array
  # -->
  # Uses each *index* to access the matching values, returning an array of the
  # corresponding matches.
  #
  #     m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
  #     m.to_a               #=> ["HX1138", "H", "X", "113", "8"]
  #     m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]
  #     m.values_at(1..2, -1)   #=> ["H", "X", "8"]
  #
  #     m = /(?<a>\d+) *(?<op>[+\-*\/]) *(?<b>\d+)/.match("1 + 2")
  #     m.to_a               #=> ["1 + 2", "1", "+", "2"]
  #     m.values_at(:a, :b, :op) #=> ["1", "2", "+"]
  #
  def values_at: (*Integer | Symbol | String n_or_name) -> ::Array[String?]

  private

  def initialize_copy: (self object) -> void
end

# <!-- rdoc-file=io.c -->
# ARGF is a stream designed for use in scripts that process files given as
# command-line arguments or passed in via STDIN.
#
# See ARGF (the class) for more details.
#
::ARGF: Object

# <!-- rdoc-file=ruby.c -->
# ARGV contains the command line arguments used to run ruby.
#
# A library like OptionParser can be used to process command-line arguments.
#
::ARGV: Array[String]

::CROSS_COMPILING: NilClass

::FALSE: FalseClass

::NIL: NilClass

# <!-- rdoc-file=version.c -->
# The copyright string for ruby
#
::RUBY_COPYRIGHT: String

# <!-- rdoc-file=version.c -->
# The full ruby version string, like `ruby -v` prints
#
::RUBY_DESCRIPTION: String

# <!-- rdoc-file=version.c -->
# The engine or interpreter this ruby uses.
#
::RUBY_ENGINE: String

# <!-- rdoc-file=version.c -->
# The version of the engine or interpreter this ruby uses.
#
::RUBY_ENGINE_VERSION: String

# <!-- rdoc-file=version.c -->
# The patchlevel for this ruby.  If this is a development build of ruby the
# patchlevel will be -1
#
::RUBY_PATCHLEVEL: Integer

# <!-- rdoc-file=version.c -->
# The platform for this ruby
#
::RUBY_PLATFORM: String

# <!-- rdoc-file=version.c -->
# The date this ruby was released
#
::RUBY_RELEASE_DATE: String

# <!-- rdoc-file=version.c -->
# The GIT commit hash for this ruby.
#
::RUBY_REVISION: Integer

# <!-- rdoc-file=version.c -->
# The running version of ruby
#
::RUBY_VERSION: String

# <!-- rdoc-file=io.c -->
# Holds the original stderr
#
::STDERR: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdin
#
::STDIN: IO

# <!-- rdoc-file=io.c -->
# Holds the original stdout
#
::STDOUT: IO

# <!-- rdoc-file=vm.c -->
# The Binding of the top level scope
#
::TOPLEVEL_BINDING: Binding

::TRUE: TrueClass

# <!-- rdoc-file=trace_point.rb -->
# Document-class: TracePoint
#
# A class that provides the functionality of Kernel#set_trace_func in a nice
# Object-Oriented API.
#
# ## Example
#
# We can use TracePoint to gather information specifically for exceptions:
#
#     trace = TracePoint.new(:raise) do |tp|
#         p [tp.lineno, tp.event, tp.raised_exception]
#     end
#     #=> #<TracePoint:disabled>
#
#     trace.enable
#     #=> false
#
#     0 / 0
#     #=> [5, :raise, #<ZeroDivisionError: divided by 0>]
#
# ## Events
#
# If you don't specify the type of events you want to listen for, TracePoint
# will include all available events.
#
# **Note** do not depend on current event set, as this list is subject to
# change. Instead, it is recommended you specify the type of events you want to
# use.
#
# To filter what is traced, you can pass any of the following as `events`:
#
# `:line`
# :   execute an expression or statement on a new line
# `:class`
# :   start a class or module definition
# `:end`
# :   finish a class or module definition
# `:call`
# :   call a Ruby method
# `:return`
# :   return from a Ruby method
# `:c_call`
# :   call a C-language routine
# `:c_return`
# :   return from a C-language routine
# `:raise`
# :   raise an exception
# `:b_call`
# :   event hook at block entry
# `:b_return`
# :   event hook at block ending
# `:a_call`
# :   event hook at all calls (`call`, `b_call`, and `c_call`)
# `:a_return`
# :   event hook at all returns (`return`, `b_return`, and `c_return`)
# `:thread_begin`
# :   event hook at thread beginning
# `:thread_end`
# :   event hook at thread ending
# `:fiber_switch`
# :   event hook at fiber switch
# `:script_compiled`
# :   new Ruby code compiled (with `eval`, `load` or `require`)
#
class TracePoint < Object
  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.new(*events) { |obj| block }         -> obj
  # -->
  # Returns a new TracePoint object, not enabled by default.
  #
  # Next, in order to activate the trace, you must use TracePoint#enable
  #
  #     trace = TracePoint.new(:call) do |tp|
  #         p [tp.lineno, tp.defined_class, tp.method_id, tp.event]
  #     end
  #     #=> #<TracePoint:disabled>
  #
  #     trace.enable
  #     #=> false
  #
  #     puts "Hello, TracePoint!"
  #     # ...
  #     # [48, IRB::Notifier::AbstractNotifier, :printf, :call]
  #     # ...
  #
  # When you want to deactivate the trace, you must use TracePoint#disable
  #
  #     trace.disable
  #
  # See TracePoint@Events for possible events and more information.
  #
  # A block must be given, otherwise an ArgumentError is raised.
  #
  # If the trace method isn't included in the given events filter, a RuntimeError
  # is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #         p tp.raised_exception
  #     end
  #     #=> RuntimeError: 'raised_exception' not supported by this event
  #
  # If the trace method is called outside block, a RuntimeError is raised.
  #
  #     TracePoint.trace(:line) do |tp|
  #       $tp = tp
  #     end
  #     $tp.lineno #=> access from outside (RuntimeError)
  #
  # Access from other threads is also forbidden.
  #
  def initialize: (*Symbol events) { (TracePoint tp) -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.allow_reentry
  # -->
  # In general, while a TracePoint callback is running, other registered callbacks
  # are not called to avoid confusion by reentrance. This method allows the
  # reentrance in a given block. This method should be used carefully, otherwise
  # the callback can be easily called infinitely.
  #
  # If this method is called when the reentrance is already allowed, it raises a
  # RuntimeError.
  #
  def self.allow_reentry: () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.stat -> obj
  # -->
  # Returns internal information of TracePoint.
  #
  # The contents of the returned value are implementation specific. It may be
  # changed in future.
  #
  # This method is only for debugging TracePoint itself.
  #
  def self.stat: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - TracePoint.trace(*events) { |obj| block }        -> obj
  # -->
  # A convenience method for TracePoint.new, that activates the trace
  # automatically.
  #
  #     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] }
  #     #=> #<TracePoint:enabled>
  #
  #     trace.enabled? #=> true
  #
  def self.trace: (*Symbol events) { (TracePoint tp) -> void } -> TracePoint

  # <!--
  #   rdoc-file=trace_point.rb
  #   - binding()
  # -->
  # Return the generated binding object from event.
  #
  # Note that for `c_call` and `c_return` events, the binding returned is the
  # binding of the nearest Ruby method calling the C method, since C methods
  # themselves do not have bindings.
  #
  def binding: () -> Binding

  # <!--
  #   rdoc-file=trace_point.rb
  #   - callee_id()
  # -->
  # Return the called name of the method being called
  #
  def callee_id: () -> Symbol

  # <!--
  #   rdoc-file=trace_point.rb
  #   - defined_class()
  # -->
  # Return class or module of the method being called.
  #
  #     class C; def foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> C
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # If method is defined by a module, then that module is returned.
  #
  #     module M; def foo; end; end
  #     class C; include M; end;
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> M
  #     end.enable do
  #       C.new.foo
  #     end
  #
  # **Note:** #defined_class returns singleton class.
  #
  # 6th block parameter of Kernel#set_trace_func passes original class of attached
  # by singleton class.
  #
  # **This is a difference between Kernel#set_trace_func and TracePoint.**
  #
  #     class C; def self.foo; end; end
  #     trace = TracePoint.new(:call) do |tp|
  #       p tp.defined_class #=> #<Class:C>
  #     end.enable do
  #       C.foo
  #     end
  #
  def defined_class: () -> Module

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.disable               -> true or false
  #   - trace.disable { block } -> obj
  # -->
  # Deactivates the trace
  #
  # Return true if trace was enabled. Return false if trace was disabled.
  #
  #     trace.enabled?      #=> true
  #     trace.disable       #=> true (previous status)
  #     trace.enabled?      #=> false
  #     trace.disable       #=> false
  #
  # If a block is given, the trace will only be disable within the scope of the
  # block.
  #
  #     trace.enabled?
  #     #=> true
  #
  #     trace.disable do
  #         trace.enabled?
  #         # only disabled for this block
  #     end
  #
  #     trace.enabled?
  #     #=> true
  #
  # Note: You cannot access event hooks within the block.
  #
  #     trace.disable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def disable: () -> bool
             | () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enable(target: nil, target_line: nil, target_thread: nil)    -> true or false
  #   - trace.enable(target: nil, target_line: nil, target_thread: nil) { block }  -> obj
  # -->
  # Activates the trace.
  #
  # Returns `true` if trace was enabled. Returns `false` if trace was disabled.
  #
  #     trace.enabled?  #=> false
  #     trace.enable    #=> false (previous state)
  #                     #   trace is enabled
  #     trace.enabled?  #=> true
  #     trace.enable    #=> true (previous state)
  #                     #   trace is still enabled
  #
  # If a block is given, the trace will only be enabled within the scope of the
  # block.
  #
  #     trace.enabled?
  #     #=> false
  #
  #     trace.enable do
  #       trace.enabled?
  #       # only enabled for this block
  #     end
  #
  #     trace.enabled?
  #     #=> false
  #
  # `target`, `target_line` and `target_thread` parameters are used to limit
  # tracing only to specified code objects. `target` should be a code object for
  # which RubyVM::InstructionSequence.of will return an instruction sequence.
  #
  #     t = TracePoint.new(:line) { |tp| p tp }
  #
  #     def m1
  #       p 1
  #     end
  #
  #     def m2
  #       p 2
  #     end
  #
  #     t.enable(target: method(:m1))
  #
  #     m1
  #     # prints #<TracePoint:line test.rb:4 in `m1'>
  #     m2
  #     # prints nothing
  #
  # Note: You cannot access event hooks within the `enable` block.
  #
  #     trace.enable { p tp.lineno }
  #     #=> RuntimeError: access from outside
  #
  def enable: () -> bool
            | () { () -> void } -> void

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.enabled?          -> true or false
  # -->
  # The current status of the trace
  #
  def enabled?: () -> bool

  # <!--
  #   rdoc-file=trace_point.rb
  #   - trace.inspect  -> string
  # -->
  # Return a string containing a human-readable TracePoint status.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - lineno()
  # -->
  # Line number of the event
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=trace_point.rb
  #   - method_id()
  # -->
  # Return the name at the definition of the method being called
  #
  def method_id: () -> Symbol

  # <!--
  #   rdoc-file=trace_point.rb
  #   - path()
  # -->
  # Path of the file being run
  #
  def path: () -> String

  # <!--
  #   rdoc-file=trace_point.rb
  #   - raised_exception()
  # -->
  # Value from exception raised on the `:raise` event
  #
  def raised_exception: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - return_value()
  # -->
  # Return value from `:return`, `c_return`, and `b_return` event
  #
  def return_value: () -> untyped

  # <!--
  #   rdoc-file=trace_point.rb
  #   - self()
  # -->
  # Return the trace object during event
  #
  # Same as the following, except it returns the correct object (the method
  # receiver) for `c_call` and `c_return` events:
  #
  #     trace.binding.eval('self')
  #
  def self: () -> Binding
end

# <!-- rdoc-file=object.c -->
# The global value `true` is the only instance of class TrueClass and represents
# a logically true value in boolean expressions. The class provides operators
# allowing `true` to be used in logical expressions.
#
class TrueClass
  public

  def !: () -> false

  # <!--
  #   rdoc-file=object.c
  #   - true & obj    -> true or false
  # -->
  # And---Returns `false` if *obj* is `nil` or `false`, `true` otherwise.
  #
  def &: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (true) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - true ^ obj   -> !obj
  # -->
  # Exclusive Or---Returns `true` if *obj* is `nil` or `false`, `false` otherwise.
  #
  def ^: (nil) -> true
       | (false) -> true
       | (untyped obj) -> false

  # <!-- rdoc-file=object.c -->
  # The string representation of `true` is "true".
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - true.to_s   ->  "true"
  # -->
  # The string representation of `true` is "true".
  #
  def to_s: () -> "true"

  # <!--
  #   rdoc-file=object.c
  #   - true | obj   -> true
  # -->
  # Or---Returns `true`. As *obj* is an argument to a method call, it is always
  # evaluated; there is no short-circuit evaluation in this case.
  #
  #     true |  puts("or")
  #     true || puts("logical or")
  #
  # *produces:*
  #
  #     or
  #
  def |: (untyped obj) -> true

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=process.c -->
# The module contains several groups of functionality for handling OS processes:
#
# *   Low-level property introspection and management of the current process,
#     like Process.argv0, Process.pid;
# *   Low-level introspection of other processes, like Process.getpgid,
#     Process.getpriority;
# *   Management of the current process: Process.abort, Process.exit,
#     Process.daemon, etc. (for convenience, most of those are also available as
#     global functions and module functions of Kernel);
# *   Creation and management of child processes: Process.fork, Process.spawn,
#     and related methods;
# *   Management of low-level system clock: Process.times and
#     Process.clock_gettime, which could be important for proper benchmarking
#     and other elapsed time measurement tasks.
#
module Process
  # <!--
  #   rdoc-file=process.c
  #   - Process._fork   -> integer
  # -->
  # An internal API for fork. Do not call this method directly. Currently, this is
  # called via Kernel#fork, Process.fork, and IO.popen with `"-"`.
  #
  # This method is not for casual code but for application monitoring libraries.
  # You can add custom code before and after fork events by overriding this
  # method.
  #
  def self._fork: () -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.argv0  -> frozen_string
  # -->
  # Returns the name of the script being executed.  The value is not affected by
  # assigning a new value to $0.
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to get the script name.
  #
  def self.argv0: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_getres(clock_id [, unit])   -> number
  # -->
  # Returns an estimate of the resolution of a `clock_id` using the POSIX
  # `clock_getres()` function.
  #
  # Note the reported resolution is often inaccurate on most platforms due to
  # underlying bugs for this function and therefore the reported resolution often
  # differs from the actual resolution of the clock in practice. Inaccurate
  # reported resolutions have been observed for various clocks including
  # CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW when using Linux, macOS, BSD or AIX
  # platforms, when using ARM processors, or when using virtualization.
  #
  # `clock_id` specifies a kind of clock. See the document of
  # `Process.clock_gettime` for details. `clock_id` can be a symbol as for
  # `Process.clock_gettime`.
  #
  # If the given `clock_id` is not supported, Errno::EINVAL is raised.
  #
  # `unit` specifies the type of the return value. `Process.clock_getres` accepts
  # `unit` as `Process.clock_gettime`. The default value, `:float_second`, is also
  # the same as `Process.clock_gettime`.
  #
  # `Process.clock_getres` also accepts `:hertz` as `unit`. `:hertz` means the
  # reciprocal of `:float_second`.
  #
  # `:hertz` can be used to obtain the exact value of the clock ticks per second
  # for the times() function and CLOCKS_PER_SEC for the clock() function.
  #
  # `Process.clock_getres(:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
  # the clock ticks per second.
  #
  # `Process.clock_getres(:CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
  # CLOCKS_PER_SEC.
  #
  #     p Process.clock_getres(Process::CLOCK_MONOTONIC)
  #     #=> 1.0e-09
  #
  def self.clock_getres: (Symbol | Integer clock_id, ?Symbol unit) -> (Float | Integer)

  # <!--
  #   rdoc-file=process.c
  #   - Process.clock_gettime(clock_id [, unit])   -> number
  # -->
  # Returns a time returned by POSIX clock_gettime() function.
  #
  #     p Process.clock_gettime(Process::CLOCK_MONOTONIC)
  #     #=> 896053.968060096
  #
  # `clock_id` specifies a kind of clock. It is specified as a constant which
  # begins with `Process::CLOCK_` such as Process::CLOCK_REALTIME and
  # Process::CLOCK_MONOTONIC.
  #
  # The supported constants depends on OS and version. Ruby provides following
  # types of `clock_id` if available.
  #
  # CLOCK_REALTIME
  # :   SUSv2 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 2.1, macOS
  #     10.12, Windows-8/Server-2012
  # CLOCK_MONOTONIC
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 3.4, macOS
  #     10.12, Windows-2000
  # CLOCK_PROCESS_CPUTIME_ID
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 9.3, OpenBSD 5.4, macOS 10.12
  # CLOCK_THREAD_CPUTIME_ID
  # :   SUSv3 to 4, Linux 2.5.63, FreeBSD 7.1, OpenBSD 5.4, macOS 10.12
  # CLOCK_VIRTUAL
  # :   FreeBSD 3.0, OpenBSD 2.1
  # CLOCK_PROF
  # :   FreeBSD 3.0, OpenBSD 2.1
  # CLOCK_REALTIME_FAST
  # :   FreeBSD 8.1
  # CLOCK_REALTIME_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_REALTIME_COARSE
  # :   Linux 2.6.32
  # CLOCK_REALTIME_ALARM
  # :   Linux 3.0
  # CLOCK_MONOTONIC_FAST
  # :   FreeBSD 8.1
  # CLOCK_MONOTONIC_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_MONOTONIC_COARSE
  # :   Linux 2.6.32
  # CLOCK_MONOTONIC_RAW
  # :   Linux 2.6.28, macOS 10.12
  # CLOCK_MONOTONIC_RAW_APPROX
  # :   macOS 10.12
  # CLOCK_BOOTTIME
  # :   Linux 2.6.39
  # CLOCK_BOOTTIME_ALARM
  # :   Linux 3.0
  # CLOCK_UPTIME
  # :   FreeBSD 7.0, OpenBSD 5.5
  # CLOCK_UPTIME_FAST
  # :   FreeBSD 8.1
  # CLOCK_UPTIME_RAW
  # :   macOS 10.12
  # CLOCK_UPTIME_RAW_APPROX
  # :   macOS 10.12
  # CLOCK_UPTIME_PRECISE
  # :   FreeBSD 8.1
  # CLOCK_SECOND
  # :   FreeBSD 8.1
  # CLOCK_TAI
  # :   Linux 3.10
  #
  #
  # Note that SUS stands for Single Unix Specification. SUS contains POSIX and
  # clock_gettime is defined in the POSIX part. SUS defines CLOCK_REALTIME
  # mandatory but CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID and
  # CLOCK_THREAD_CPUTIME_ID are optional.
  #
  # Also, several symbols are accepted as `clock_id`. There are emulations for
  # clock_gettime().
  #
  # For example, Process::CLOCK_REALTIME is defined as
  # `:GETTIMEOFDAY_BASED_CLOCK_REALTIME` when clock_gettime() is not available.
  #
  # Emulations for `CLOCK_REALTIME`:
  # :GETTIMEOFDAY_BASED_CLOCK_REALTIME
  # :   Use gettimeofday() defined by SUS. (SUSv4 obsoleted it, though.) The
  #     resolution is 1 microsecond.
  # :TIME_BASED_CLOCK_REALTIME
  # :   Use time() defined by ISO C. The resolution is 1 second.
  #
  #
  # Emulations for `CLOCK_MONOTONIC`:
  # :MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC
  # :   Use mach_absolute_time(), available on Darwin. The resolution is CPU
  #     dependent.
  # :TIMES_BASED_CLOCK_MONOTONIC
  # :   Use the result value of times() defined by POSIX. POSIX defines it as
  #     "times() shall return the elapsed real time, in clock ticks, since an
  #     arbitrary point in the past (for example, system start-up time)". For
  #     example, GNU/Linux returns a value based on jiffies and it is monotonic.
  #     However, 4.4BSD uses gettimeofday() and it is not monotonic. (FreeBSD uses
  #     clock_gettime(CLOCK_MONOTONIC) instead, though.) The resolution is the
  #     clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
  #     (The clock ticks per second is defined by HZ macro in older systems.) If
  #     it is 100 and clock_t is 32 bits integer type, the resolution is 10
  #     millisecond and cannot represent over 497 days.
  #
  #
  # Emulations for `CLOCK_PROCESS_CPUTIME_ID`:
  # :GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use getrusage() defined by SUS. getrusage() is used with RUSAGE_SELF to
  #     obtain the time only for the calling process (excluding the time for child
  #     processes). The result is addition of user time (ru_utime) and system time
  #     (ru_stime). The resolution is 1 microsecond.
  # :TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use times() defined by POSIX. The result is addition of user time
  #     (tms_utime) and system time (tms_stime). tms_cutime and tms_cstime are
  #     ignored to exclude the time for child processes. The resolution is the
  #     clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
  #     (The clock ticks per second is defined by HZ macro in older systems.) If
  #     it is 100, the resolution is 10 millisecond.
  # :CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID
  # :   Use clock() defined by ISO C. The resolution is 1/CLOCKS_PER_SEC.
  #     CLOCKS_PER_SEC is the C-level macro defined by time.h. SUS defines
  #     CLOCKS_PER_SEC is 1000000. Non-Unix systems may define it a different
  #     value, though. If CLOCKS_PER_SEC is 1000000 as SUS, the resolution is 1
  #     microsecond. If CLOCKS_PER_SEC is 1000000 and clock_t is 32 bits integer
  #     type, it cannot represent over 72 minutes.
  #
  #
  # If the given `clock_id` is not supported, Errno::EINVAL is raised.
  #
  # `unit` specifies a type of the return value.
  #
  # :float_second
  # :   number of seconds as a float (default)
  # :float_millisecond
  # :   number of milliseconds as a float
  # :float_microsecond
  # :   number of microseconds as a float
  # :second
  # :   number of seconds as an integer
  # :millisecond
  # :   number of milliseconds as an integer
  # :microsecond
  # :   number of microseconds as an integer
  # :nanosecond
  # :   number of nanoseconds as an integer
  #
  #
  # The underlying function, clock_gettime(), returns a number of nanoseconds.
  # Float object (IEEE 754 double) is not enough to represent the return value for
  # CLOCK_REALTIME. If the exact nanoseconds value is required, use `:nanoseconds`
  # as the `unit`.
  #
  # The origin (zero) of the returned value varies. For example, system start up
  # time, process start up time, the Epoch, etc.
  #
  # The origin in CLOCK_REALTIME is defined as the Epoch (1970-01-01 00:00:00
  # UTC). But some systems count leap seconds and others doesn't. So the result
  # can be interpreted differently across systems. Time.now is recommended over
  # CLOCK_REALTIME.
  #
  def self.clock_gettime: (Symbol | Integer clock_id) -> Float
                        | (Symbol | Integer clock_id, :float_second | :float_millisecond | :float_microsecond unit) -> Float
                        | (Symbol | Integer clock_id, :second | :millisecond | :microsecond | :nanosecond unit) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.daemon()                        -> 0
  #   - Process.daemon(nochdir=nil,noclose=nil) -> 0
  # -->
  # Detach the process from controlling terminal and run in the background as
  # system daemon.  Unless the argument nochdir is true (i.e. non false), it
  # changes the current working directory to the root ("/"). Unless the argument
  # noclose is true, daemon() will redirect standard input, standard output and
  # standard error to /dev/null. Return zero on success, or raise one of Errno::*.
  #
  def self.daemon: (?untyped nochdir, ?untyped noclose) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.detach(pid)   -> thread
  # -->
  # Some operating systems retain the status of terminated child processes until
  # the parent collects that status (normally using some variant of `wait()`). If
  # the parent never collects this status, the child stays around as a *zombie*
  # process. Process::detach prevents this by setting up a separate Ruby thread
  # whose sole job is to reap the status of the process *pid* when it terminates.
  # Use #detach only when you do not intend to explicitly wait for the child to
  # terminate.
  #
  # The waiting thread returns the exit status of the detached process when it
  # terminates, so you can use Thread#join to know the result.  If specified *pid*
  # is not a valid child process ID, the thread returns `nil` immediately.
  #
  # The waiting thread has #pid method which returns the pid.
  #
  # In this first example, we don't reap the first child process, so it appears as
  # a zombie in the process status display.
  #
  #     p1 = fork { sleep 0.1 }
  #     p2 = fork { sleep 0.2 }
  #     Process.waitpid(p2)
  #     sleep 2
  #     system("ps -ho pid,state -p #{p1}")
  #
  # *produces:*
  #
  #     27389 Z
  #
  # In the next example, Process::detach is used to reap the child automatically.
  #
  #     p1 = fork { sleep 0.1 }
  #     p2 = fork { sleep 0.2 }
  #     Process.detach(p1)
  #     Process.waitpid(p2)
  #     sleep 2
  #     system("ps -ho pid,state -p #{p1}")
  #
  # *(produces no output)*
  #
  def self.detach: (Integer pid) -> Thread

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid          -> integer
  #   - Process::GID.eid      -> integer
  #   - Process::Sys.geteid   -> integer
  # -->
  # Returns the effective group ID for this process. Not available on all
  # platforms.
  #
  #     Process.egid   #=> 500
  #
  def self.egid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid = integer   -> integer
  # -->
  # Sets the effective group ID for this process. Not available on all platforms.
  #
  def self.egid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.euid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid= user
  # -->
  # Sets the effective user ID for this process. Not available on all platforms.
  #
  def self.euid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgid(pid)   -> integer
  # -->
  # Returns the process group ID for the given process id. Not available on all
  # platforms.
  #
  #     Process.getpgid(Process.ppid())   #=> 25527
  #
  def self.getpgid: (Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpgrp   -> integer
  # -->
  # Returns the process group ID for this process. Not available on all platforms.
  #
  #     Process.getpgid(0)   #=> 25527
  #     Process.getpgrp      #=> 25527
  #
  def self.getpgrp: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getpriority(kind, integer)   -> integer
  # -->
  # Gets the scheduling priority for specified process, process group, or user.
  # *kind* indicates the kind of entity to find: one of Process::PRIO_PGRP,
  # Process::PRIO_USER, or Process::PRIO_PROCESS. *integer* is an id indicating
  # the particular process, process group, or user (an id of 0 means *current*).
  # Lower priorities are more favorable for scheduling. Not available on all
  # platforms.
  #
  #     Process.getpriority(Process::PRIO_USER, 0)      #=> 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19
  #
  def self.getpriority: (Integer kind, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.getrlimit(resource)   -> [cur_limit, max_limit]
  # -->
  # Gets the resource limit of the process. *cur_limit* means current (soft) limit
  # and *max_limit* means maximum (hard) limit.
  #
  # *resource* indicates the kind of resource to limit. It is specified as a
  # symbol such as `:CORE`, a string such as `"CORE"` or a constant such as
  # Process::RLIMIT_CORE. See Process.setrlimit for details.
  #
  # *cur_limit* and *max_limit* may be Process::RLIM_INFINITY,
  # Process::RLIM_SAVED_MAX or Process::RLIM_SAVED_CUR. See Process.setrlimit and
  # the system getrlimit(2) manual for details.
  #
  def self.getrlimit: (Symbol | String | Integer resource) -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.getsid()      -> integer
  #   - Process.getsid(pid)   -> integer
  # -->
  # Returns the session ID for the given process id. If not given, return current
  # process sid. Not available on all platforms.
  #
  #     Process.getsid()                #=> 27422
  #     Process.getsid(0)               #=> 27422
  #     Process.getsid(Process.pid())   #=> 27422
  #
  def self.getsid: (?Integer pid) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.gid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid= integer   -> integer
  # -->
  # Sets the group ID for this process.
  #
  def self.gid=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups   -> array
  # -->
  # Get an Array of the group IDs in the supplemental group access list for this
  # process.
  #
  #     Process.groups   #=> [27, 6, 10, 11]
  #
  # Note that this method is just a wrapper of getgroups(2). This means that the
  # following characteristics of the result completely depend on your system:
  #
  # *   the result is sorted
  # *   the result includes effective GIDs
  # *   the result does not include duplicated GIDs
  #
  #
  # You can make sure to get a sorted unique GID list of the current process by
  # this expression:
  #
  #     Process.groups.uniq.sort
  #
  def self.groups: () -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.groups= array   -> array
  # -->
  # Set the supplemental group access list to the given Array of group IDs.
  #
  #     Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]
  #     Process.groups   #=> [27, 6, 10, 11]
  #
  def self.groups=: (::Array[Integer] arg0) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.initgroups(username, gid)   -> array
  # -->
  # Initializes the supplemental group access list by reading the system group
  # database and using all groups of which the given user is a member. The group
  # with the specified *gid* is also added to the list. Returns the resulting
  # Array of the gids of all the groups in the supplementary group access list.
  # Not available on all platforms.
  #
  #     Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
  #     Process.initgroups( "mgranger", 30 )   #=> [30, 6, 10, 11]
  #     Process.groups   #=> [30, 6, 10, 11]
  #
  def self.initgroups: (String username, Integer gid) -> ::Array[Integer]

  # <!--
  #   rdoc-file=process.c
  #   - Process.kill(signal, pid, ...)    -> integer
  # -->
  # Sends the given signal to the specified process id(s) if *pid* is positive. If
  # *pid* is zero, *signal* is sent to all processes whose group ID is equal to
  # the group ID of the process. If *pid* is negative, results are dependent on
  # the operating system. *signal* may be an integer signal number or a POSIX
  # signal name (either with or without a `SIG` prefix). If *signal* is negative
  # (or starts with a minus sign), kills process groups instead of processes. Not
  # all signals are available on all platforms. The keys and values of Signal.list
  # are known signal names and numbers, respectively.
  #
  #     pid = fork do
  #        Signal.trap("HUP") { puts "Ouch!"; exit }
  #        # ... do some work ...
  #     end
  #     # ...
  #     Process.kill("HUP", pid)
  #     Process.wait
  #
  # *produces:*
  #
  #     Ouch!
  #
  # If *signal* is an integer but wrong for signal, Errno::EINVAL or RangeError
  # will be raised.  Otherwise unless *signal* is a String or a Symbol, and a
  # known signal name, ArgumentError will be raised.
  #
  # Also, Errno::ESRCH or RangeError for invalid *pid*, Errno::EPERM when failed
  # because of no privilege, will be raised.  In these cases, signals may have
  # been sent to preceding processes.
  #
  def self.kill: (Integer | Symbol | String signal, *Integer pids) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups   -> integer
  # -->
  # Returns the maximum number of gids allowed in the supplemental group access
  # list.
  #
  #     Process.maxgroups   #=> 32
  #
  def self.maxgroups: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.maxgroups= integer   -> integer
  # -->
  # Sets the maximum number of gids allowed in the supplemental group access list.
  #
  def self.maxgroups=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.pid   -> integer
  # -->
  # Returns the process id of this process. Not available on all platforms.
  #
  #     Process.pid   #=> 27415
  #
  def self.pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.ppid   -> integer
  # -->
  # Returns the process id of the parent of this process. Returns untrustworthy
  # value on Win32/64. Not available on all platforms.
  #
  #     puts "I am #{Process.pid}"
  #     Process.fork { puts "Dad is #{Process.ppid}" }
  #
  # *produces:*
  #
  #     I am 27417
  #     Dad is 27417
  #
  def self.ppid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpgid(pid, integer)   -> 0
  # -->
  # Sets the process group ID of *pid* (0 indicates this process) to *integer*.
  # Not available on all platforms.
  #
  def self.setpgid: (Integer pid, Integer arg0) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.setpriority(kind, integer, priority)   -> 0
  # -->
  # See Process.getpriority.
  #
  #     Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0
  #     Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0
  #     Process.getpriority(Process::PRIO_USER, 0)          #=> 19
  #     Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19
  #
  def self.setpriority: (Integer kind, Integer arg0, Integer priority) -> Integer

  # <!--
  #   rdoc-file=ruby.c
  #   - Process.setproctitle(string)  -> string
  # -->
  # Sets the process title that appears on the ps(1) command.  Not necessarily
  # effective on all platforms.  No exception will be raised regardless of the
  # result, nor will NotImplementedError be raised even if the platform does not
  # support the feature.
  #
  # Calling this method does not affect the value of $0.
  #
  #     Process.setproctitle('myapp: worker #%d' % worker_id)
  #
  # This method first appeared in Ruby 2.1 to serve as a global variable free
  # means to change the process title.
  #
  def self.setproctitle: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - Process.setrlimit(resource, cur_limit, max_limit)        -> nil
  #   - Process.setrlimit(resource, cur_limit)                   -> nil
  # -->
  # Sets the resource limit of the process. *cur_limit* means current (soft) limit
  # and *max_limit* means maximum (hard) limit.
  #
  # If *max_limit* is not given, *cur_limit* is used.
  #
  # *resource* indicates the kind of resource to limit. It should be a symbol such
  # as `:CORE`, a string such as `"CORE"` or a constant such as
  # Process::RLIMIT_CORE. The available resources are OS dependent. Ruby may
  # support following resources.
  #
  # AS
  # :   total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but
  #     4.4BSD-Lite)
  # CORE
  # :   core size (bytes) (SUSv3)
  # CPU
  # :   CPU time (seconds) (SUSv3)
  # DATA
  # :   data segment (bytes) (SUSv3)
  # FSIZE
  # :   file size (bytes) (SUSv3)
  # MEMLOCK
  # :   total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)
  # MSGQUEUE
  # :   allocation for POSIX message queues (bytes) (GNU/Linux)
  # NICE
  # :   ceiling on process's nice(2) value (number) (GNU/Linux)
  # NOFILE
  # :   file descriptors (number) (SUSv3)
  # NPROC
  # :   number of processes for the user (number) (4.4BSD, GNU/Linux)
  # RSS
  # :   resident memory size (bytes) (4.2BSD, GNU/Linux)
  # RTPRIO
  # :   ceiling on the process's real-time priority (number) (GNU/Linux)
  # RTTIME
  # :   CPU time for real-time process (us) (GNU/Linux)
  # SBSIZE
  # :   all socket buffers (bytes) (NetBSD, FreeBSD)
  # SIGPENDING
  # :   number of queued signals allowed (signals) (GNU/Linux)
  # STACK
  # :   stack size (bytes) (SUSv3)
  #
  #
  # *cur_limit* and *max_limit* may be `:INFINITY`, `"INFINITY"` or
  # Process::RLIM_INFINITY, which means that the resource is not limited. They may
  # be Process::RLIM_SAVED_MAX, Process::RLIM_SAVED_CUR and corresponding symbols
  # and strings too. See system setrlimit(2) manual for details.
  #
  # The following example raises the soft limit of core size to the hard limit to
  # try to make core dump possible.
  #
  #     Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])
  #
  def self.setrlimit: (Symbol | String | Integer resource, Integer cur_limit, ?Integer max_limit) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process.setsid   -> integer
  # -->
  # Establishes this process as a new session and process group leader, with no
  # controlling tty. Returns the session id. Not available on all platforms.
  #
  #     Process.setsid   #=> 27422
  #
  def self.setsid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.times   -> aProcessTms
  # -->
  # Returns a `Tms` structure (see Process::Tms) that contains user and system CPU
  # times for this process, and also for children processes.
  #
  #     t = Process.times
  #     [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]
  #
  def self.times: () -> Process::Tms

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.uid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid= user   -> numeric
  # -->
  # Sets the (user) user ID for this process. Not available on all platforms.
  #
  def self.uid=: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait()                     -> integer
  #   - Process.wait(pid=-1, flags=0)      -> integer
  #   - Process.waitpid(pid=-1, flags=0)   -> integer
  # -->
  # Waits for a child process to exit, returns its process id, and sets `$?` to a
  # Process::Status object containing information on that process. Which child it
  # waits on depends on the value of *pid*:
  #
  # > 0
  # :   Waits for the child whose process ID equals *pid*.
  #
  # 0
  # :   Waits for any child whose process group ID equals that of the calling
  #     process.
  #
  # -1
  # :   Waits for any child process (the default if no *pid* is given).
  #
  # < -1
  # :   Waits for any child whose process group ID equals the absolute value of
  #     *pid*.
  #
  #
  # The *flags* argument may be a logical or of the flag values Process::WNOHANG
  # (do not block if no child available) or Process::WUNTRACED (return stopped
  # children that haven't been reported). Not all flags are available on all
  # platforms, but a flag value of zero will work on all platforms.
  #
  # Calling this method raises a SystemCallError if there are no child processes.
  # Not available on all platforms.
  #
  #     include Process
  #     fork { exit 99 }                 #=> 27429
  #     wait                             #=> 27429
  #     $?.exitstatus                    #=> 99
  #
  #     pid = fork { sleep 3 }           #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, Process::WNOHANG)   #=> nil
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, 0)                  #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:19 +0900
  #
  def self.wait: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid=-1, flags=0)      -> [pid, status]
  #   - Process.waitpid2(pid=-1, flags=0)   -> [pid, status]
  # -->
  # Waits for a child process to exit (see Process::waitpid for exact semantics)
  # and returns an array containing the process id and the exit status (a
  # Process::Status object) of that child. Raises a SystemCallError if there are
  # no child processes.
  #
  #     Process.fork { exit 99 }   #=> 27437
  #     pid, status = Process.wait2
  #     pid                        #=> 27437
  #     status.exitstatus          #=> 99
  #
  def self.wait2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]

  # <!--
  #   rdoc-file=process.c
  #   - Process.waitall   -> [ [pid1,status1], ...]
  # -->
  # Waits for all children, returning an array of *pid*/*status* pairs (where
  # *status* is a Process::Status object).
  #
  #     fork { sleep 0.2; exit 2 }   #=> 27432
  #     fork { sleep 0.1; exit 1 }   #=> 27433
  #     fork {            exit 0 }   #=> 27434
  #     p Process.waitall
  #
  # *produces*:
  #
  #     [[30982, #<Process::Status: pid 30982 exit 0>],
  #      [30979, #<Process::Status: pid 30979 exit 1>],
  #      [30976, #<Process::Status: pid 30976 exit 2>]]
  #
  def self.waitall: () -> ::Array[[ Integer, Process::Status ]]

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait()                     -> integer
  #   - Process.wait(pid=-1, flags=0)      -> integer
  #   - Process.waitpid(pid=-1, flags=0)   -> integer
  # -->
  # Waits for a child process to exit, returns its process id, and sets `$?` to a
  # Process::Status object containing information on that process. Which child it
  # waits on depends on the value of *pid*:
  #
  # > 0
  # :   Waits for the child whose process ID equals *pid*.
  #
  # 0
  # :   Waits for any child whose process group ID equals that of the calling
  #     process.
  #
  # -1
  # :   Waits for any child process (the default if no *pid* is given).
  #
  # < -1
  # :   Waits for any child whose process group ID equals the absolute value of
  #     *pid*.
  #
  #
  # The *flags* argument may be a logical or of the flag values Process::WNOHANG
  # (do not block if no child available) or Process::WUNTRACED (return stopped
  # children that haven't been reported). Not all flags are available on all
  # platforms, but a flag value of zero will work on all platforms.
  #
  # Calling this method raises a SystemCallError if there are no child processes.
  # Not available on all platforms.
  #
  #     include Process
  #     fork { exit 99 }                 #=> 27429
  #     wait                             #=> 27429
  #     $?.exitstatus                    #=> 99
  #
  #     pid = fork { sleep 3 }           #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, Process::WNOHANG)   #=> nil
  #     Time.now                         #=> 2008-03-08 19:56:16 +0900
  #     waitpid(pid, 0)                  #=> 27440
  #     Time.now                         #=> 2008-03-08 19:56:19 +0900
  #
  def self.waitpid: (?Integer pid, ?Integer flags) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.wait2(pid=-1, flags=0)      -> [pid, status]
  #   - Process.waitpid2(pid=-1, flags=0)   -> [pid, status]
  # -->
  # Waits for a child process to exit (see Process::waitpid for exact semantics)
  # and returns an array containing the process id and the exit status (a
  # Process::Status object) of that child. Raises a SystemCallError if there are
  # no child processes.
  #
  #     Process.fork { exit 99 }   #=> 27437
  #     pid, status = Process.wait2
  #     pid                        #=> 27437
  #     status.exitstatus          #=> 99
  #
  def self.waitpid2: (?Integer pid, ?Integer flags) -> [ Integer, Process::Status ]
end

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_BOOTTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_MONOTONIC_RAW: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_PROCESS_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_ALARM: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_REALTIME_COARSE: Integer

# <!-- rdoc-file=process.c -->
# see Process.clock_gettime
#
Process::CLOCK_THREAD_CPUTIME_ID: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PGRP: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_PROCESS: Integer

# <!-- rdoc-file=process.c -->
# see Process.setpriority
#
Process::PRIO_USER: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's virtual memory (address space) in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_AS: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the core file.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CORE: Integer

# <!-- rdoc-file=process.c -->
# CPU time limit in seconds.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_CPU: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the process's data segment.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_DATA: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of files that the process may create.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_FSIZE: Integer

# <!-- rdoc-file=process.c -->
# Maximum number of bytes of memory that may be locked into RAM.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MEMLOCK: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit on the number of bytes that can be allocated for POSIX
# message queues for the real user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_MSGQUEUE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling to which the process's nice value can be raised.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NICE: Integer

# <!-- rdoc-file=process.c -->
# Specifies a value one greater than the maximum file descriptor number that can
# be opened by this process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NOFILE: Integer

# <!-- rdoc-file=process.c -->
# The maximum number of processes that can be created for the real user ID of
# the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_NPROC: Integer

# <!-- rdoc-file=process.c -->
# Specifies the limit (in pages) of the process's resident set.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RSS: Integer

# <!-- rdoc-file=process.c -->
# Specifies a ceiling on the real-time priority that may be set for this
# process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTPRIO: Integer

# <!-- rdoc-file=process.c -->
# Specifies limit on CPU time this process scheduled under a real-time
# scheduling policy can consume.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_RTTIME: Integer

# <!-- rdoc-file=process.c -->
# Specifies a limit on the number of signals that may be queued for the real
# user ID of the calling process.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_SIGPENDING: Integer

# <!-- rdoc-file=process.c -->
# Maximum size of the stack, in bytes.
#
# see the system getrlimit(2) manual for details.
#
Process::RLIMIT_STACK: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_INFINITY: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_CUR: Integer

# <!-- rdoc-file=process.c -->
# see Process.setrlimit
#
Process::RLIM_SAVED_MAX: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WNOHANG: Integer

# <!-- rdoc-file=process.c -->
# see Process.wait
#
Process::WUNTRACED: Integer

# <!-- rdoc-file=process.c -->
# The Process::GID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved group IDs.
#
module Process::GID
  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.change_privilege(group)   -> integer
  # -->
  # Change the current process's real and effective group ID to that specified by
  # *group*. Returns the new group ID. Not available on all platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.change_privilege(33)    #=> 33
  #     [Process.gid, Process.egid]          #=> [33, 33]
  #
  def self.change_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.egid          -> integer
  #   - Process::GID.eid      -> integer
  #   - Process::Sys.geteid   -> integer
  # -->
  # Returns the effective group ID for this process. Not available on all
  # platforms.
  #
  #     Process.egid   #=> 500
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.from_name(name)   -> gid
  # -->
  # Get the group ID by the *name*. If the group is not found, `ArgumentError`
  # will be raised.
  #
  #     Process::GID.from_name("wheel") #=> 0
  #     Process::GID.from_name("nosuchgroup") #=> can't find group for nosuchgroup (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.grant_privilege(group)    -> integer
  #   - Process::GID.eid = group               -> integer
  # -->
  # Set the effective group ID, and if possible, the saved group ID of the process
  # to the given *group*. Returns the new effective group ID. Not available on all
  # platforms.
  #
  #     [Process.gid, Process.egid]          #=> [0, 0]
  #     Process::GID.grant_privilege(31)     #=> 33
  #     [Process.gid, Process.egid]          #=> [0, 33]
  #
  def self.grant_privilege: (Integer group) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchange   -> integer
  # -->
  # Exchange real and effective group IDs and return the new effective group ID.
  # Not available on all platforms.
  #
  #     [Process.gid, Process.egid]   #=> [0, 33]
  #     Process::GID.re_exchange      #=> 0
  #     [Process.gid, Process.egid]   #=> [33, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective group IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved group ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::GID.switch              -> integer
  #   - Process::GID.switch {|| block}   -> object
  # -->
  # Switch the effective and real group IDs of the current process. If a *block*
  # is given, the group IDs will be switched back after the block is executed.
  # Returns the new effective group ID if called without a block, and the return
  # value of the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer group) -> Integer
end

# <!-- rdoc-file=process.c -->
# Process::Status encapsulates the information on the status of a running or
# terminated system process. The built-in variable `$?` is either `nil` or a
# Process::Status object.
#
#     fork { exit 99 }   #=> 26557
#     Process.wait       #=> 26557
#     $?.class           #=> Process::Status
#     $?.to_i            #=> 25344
#     $? >> 8            #=> 99
#     $?.stopped?        #=> false
#     $?.exited?         #=> true
#     $?.exitstatus      #=> 99
#
# Posix systems record information on processes using a 16-bit integer.  The
# lower bits record the process status (stopped, exited, signaled) and the upper
# bits possibly contain additional information (for example the program's return
# code in the case of exited processes). Pre Ruby 1.8, these bits were exposed
# directly to the Ruby program. Ruby now encapsulates these in a Process::Status
# object. To maximize compatibility, however, these objects retain a
# bit-oriented interface. In the descriptions that follow, when we talk about
# the integer value of *stat*, we're referring to this 16 bit value.
#
class Process::Status < Object
  # <!--
  #   rdoc-file=process.c
  #   - stat & num   -> integer
  # -->
  # Logical AND of the bits in *stat* with *num*.
  #
  #     fork { exit 0x37 }
  #     Process.wait
  #     sprintf('%04x', $?.to_i)       #=> "3700"
  #     sprintf('%04x', $? & 0x1e00)   #=> "1600"
  #
  def &: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat == other   -> true or false
  # -->
  # Returns `true` if the integer value of *stat* equals *other*.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat >> num   -> integer
  # -->
  # Shift the bits in *stat* right *num* places.
  #
  #     fork { exit 99 }   #=> 26563
  #     Process.wait       #=> 26563
  #     $?.to_i            #=> 25344
  #     $? >> 8            #=> 99
  #
  def >>: (Integer num) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.coredump?   -> true or false
  # -->
  # Returns `true` if *stat* generated a coredump when it terminated. Not
  # available on all platforms.
  #
  def coredump?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.exited?   -> true or false
  # -->
  # Returns `true` if *stat* exited normally (for example using an `exit()` call
  # or finishing the program).
  #
  def exited?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.exitstatus   -> integer or nil
  # -->
  # Returns the least significant eight bits of the return code of *stat*. Only
  # available if #exited? is `true`.
  #
  #     fork { }           #=> 26572
  #     Process.wait       #=> 26572
  #     $?.exited?         #=> true
  #     $?.exitstatus      #=> 0
  #
  #     fork { exit 99 }   #=> 26573
  #     Process.wait       #=> 26573
  #     $?.exited?         #=> true
  #     $?.exitstatus      #=> 99
  #
  def exitstatus: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.inspect   -> string
  # -->
  # Override the inspection method.
  #
  #     system("false")
  #     p $?.inspect #=> "#<Process::Status: pid 12861 exit 1>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=process.c
  #   - stat.pid   -> integer
  # -->
  # Returns the process ID that this status object represents.
  #
  #     fork { exit }   #=> 26569
  #     Process.wait    #=> 26569
  #     $?.pid          #=> 26569
  #
  def pid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.signaled?   -> true or false
  # -->
  # Returns `true` if *stat* terminated because of an uncaught signal.
  #
  def signaled?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.stopped?   -> true or false
  # -->
  # Returns `true` if this process is stopped. This is only returned if the
  # corresponding #wait call had the Process::WUNTRACED flag set.
  #
  def stopped?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.stopsig   -> integer or nil
  # -->
  # Returns the number of the signal that caused *stat* to stop (or `nil` if self
  # is not stopped).
  #
  def stopsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.success?   -> true, false or nil
  # -->
  # Returns `true` if *stat* is successful, `false` if not. Returns `nil` if
  # #exited? is not `true`.
  #
  def success?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - stat.termsig   -> integer or nil
  # -->
  # Returns the number of the signal that caused *stat* to terminate (or `nil` if
  # self was not terminated by an uncaught signal).
  #
  def termsig: () -> Integer?

  # <!--
  #   rdoc-file=process.c
  #   - stat.to_i     -> integer
  # -->
  # Returns the bits in *stat* as an Integer. Poking around in these bits is
  # platform dependent.
  #
  #     fork { exit 0xab }         #=> 26566
  #     Process.wait               #=> 26566
  #     sprintf('%04x', $?.to_i)   #=> "ab00"
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - stat.to_s   -> string
  # -->
  # Show pid and exit status as a string.
  #
  #     system("false")
  #     p $?.to_s         #=> "pid 12766 exit 1"
  #
  def to_s: () -> String
end

# <!-- rdoc-file=process.c -->
# The Process::Sys module contains UID and GID functions which provide direct
# bindings to the system calls of the same names instead of the more-portable
# versions of the same functionality found in the Process, Process::UID, and
# Process::GID modules.
#
module Process::Sys
  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.geteuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.gid           -> integer
  #   - Process::GID.rid      -> integer
  #   - Process::Sys.getgid   -> integer
  # -->
  # Returns the (real) group ID for this process.
  #
  #     Process.gid   #=> 500
  #
  def self.getgid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.getuid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.issetugid   -> true or false
  # -->
  # Returns `true` if the process was created as a result of an execve(2) system
  # call which had either of the setuid or setgid bits set (and extra privileges
  # were given as a result) or if it has changed any of its real, effective or
  # saved user or group IDs since it began execution.
  #
  def self.issetugid: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setegid(group)   -> nil
  # -->
  # Set the effective group ID of the calling process to *group*.  Not available
  # on all platforms.
  #
  def self.setegid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.seteuid(user)   -> nil
  # -->
  # Set the effective user ID of the calling process to *user*.  Not available on
  # all platforms.
  #
  def self.seteuid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setgid(group)   -> nil
  # -->
  # Set the group ID of the current process to *group*. Not available on all
  # platforms.
  #
  def self.setgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setregid(rid, eid)   -> nil
  # -->
  # Sets the (group) real and/or effective group IDs of the current process to
  # *rid* and *eid*, respectively. A value of `-1` for either means to leave that
  # ID unchanged. Not available on all platforms.
  #
  def self.setregid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresgid(rid, eid, sid)   -> nil
  # -->
  # Sets the (group) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresgid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setresuid(rid, eid, sid)   -> nil
  # -->
  # Sets the (user) real, effective, and saved user IDs of the current process to
  # *rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
  # leave that ID unchanged. Not available on all platforms.
  #
  def self.setresuid: (Integer rid, Integer eid, Integer sid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setreuid(rid, eid)   -> nil
  # -->
  # Sets the (user) real and/or effective user IDs of the current process to *rid*
  # and *eid*, respectively. A value of `-1` for either means to leave that ID
  # unchanged. Not available on all platforms.
  #
  def self.setreuid: (Integer rid, Integer eid) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setrgid(group)   -> nil
  # -->
  # Set the real group ID of the calling process to *group*. Not available on all
  # platforms.
  #
  def self.setrgid: (Integer group) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setruid(user)   -> nil
  # -->
  # Set the real user ID of the calling process to *user*. Not available on all
  # platforms.
  #
  def self.setruid: (Integer user) -> nil

  # <!--
  #   rdoc-file=process.c
  #   - Process::Sys.setuid(user)   -> nil
  # -->
  # Set the user ID of the current process to *user*. Not available on all
  # platforms.
  #
  def self.setuid: (Integer user) -> nil
end

# <!-- rdoc-file=process.c -->
# The Process::UID module contains a collection of module functions which can be
# used to portably get, set, and switch the current process's real, effective,
# and saved user IDs.
#
module Process::UID
  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.change_privilege(user)   -> integer
  # -->
  # Change the current process's real and effective user ID to that specified by
  # *user*. Returns the new user ID. Not available on all platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.change_privilege(31)    #=> 31
  #     [Process.uid, Process.euid]          #=> [31, 31]
  #
  def self.change_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process.euid           -> integer
  #   - Process::UID.eid       -> integer
  #   - Process::Sys.geteuid   -> integer
  # -->
  # Returns the effective user ID for this process.
  #
  #     Process.euid   #=> 501
  #
  def self.eid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.from_name(name)   -> uid
  # -->
  # Get the user ID by the *name*. If the user is not found, `ArgumentError` will
  # be raised.
  #
  #     Process::UID.from_name("root") #=> 0
  #     Process::UID.from_name("nosuchuser") #=> can't find user for nosuchuser (ArgumentError)
  #
  def self.from_name: (String name) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.grant_privilege(user)   -> integer
  #   - Process::UID.eid= user               -> integer
  # -->
  # Set the effective user ID, and if possible, the saved user ID of the process
  # to the given *user*. Returns the new effective user ID. Not available on all
  # platforms.
  #
  #     [Process.uid, Process.euid]          #=> [0, 0]
  #     Process::UID.grant_privilege(31)     #=> 31
  #     [Process.uid, Process.euid]          #=> [0, 31]
  #
  def self.grant_privilege: (Integer user) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchange   -> integer
  # -->
  # Exchange real and effective user IDs and return the new effective user ID. Not
  # available on all platforms.
  #
  #     [Process.uid, Process.euid]   #=> [0, 31]
  #     Process::UID.re_exchange      #=> 0
  #     [Process.uid, Process.euid]   #=> [31, 0]
  #
  def self.re_exchange: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.re_exchangeable?   -> true or false
  # -->
  # Returns `true` if the real and effective user IDs of a process may be
  # exchanged on the current platform.
  #
  def self.re_exchangeable?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process.uid           -> integer
  #   - Process::UID.rid      -> integer
  #   - Process::Sys.getuid   -> integer
  # -->
  # Returns the (real) user ID of this process.
  #
  #     Process.uid   #=> 501
  #
  def self.rid: () -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.sid_available?   -> true or false
  # -->
  # Returns `true` if the current platform has saved user ID functionality.
  #
  def self.sid_available?: () -> bool

  # <!--
  #   rdoc-file=process.c
  #   - Process::UID.switch              -> integer
  #   - Process::UID.switch {|| block}   -> object
  # -->
  # Switch the effective and real user IDs of the current process. If a *block* is
  # given, the user IDs will be switched back after the block is executed. Returns
  # the new effective user ID if called without a block, and the return value of
  # the block if one is given.
  #
  def self.switch: () -> Integer
                 | [T] () { () -> T } -> T

  def self.eid=: (Integer user) -> Integer
end

class Process::Tms < Struct[Float]
end

class Process::Waiter < Thread
  def pid: () -> Integer
end

# <!-- rdoc-file=struct.c -->
# Class Struct provides a convenient way to create a simple class that can store
# and fetch values.
#
# This example creates a subclass of `Struct`, `Struct::Customer`; the first
# argument, a string, is the name of the subclass; the other arguments, symbols,
# determine the *members* of the new subclass.
#
#     Customer = Struct.new('Customer', :name, :address, :zip)
#     Customer.name       # => "Struct::Customer"
#     Customer.class      # => Class
#     Customer.superclass # => Struct
#
# Corresponding to each member are two methods, a writer and a reader, that
# store and fetch values:
#
#     methods = Customer.instance_methods false
#     methods # => [:zip, :address=, :zip=, :address, :name, :name=]
#
# An instance of the subclass may be created, and its members assigned values,
# via method `::new`:
#
#     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
#     joe # => #<struct Struct::Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=12345>
#
# The member values may be managed thus:
#
#     joe.name    # => "Joe Smith"
#     joe.name = 'Joseph Smith'
#     joe.name    # => "Joseph Smith"
#
# And thus; note that member name may be expressed as either a string or a
# symbol:
#
#     joe[:name]  # => "Joseph Smith"
#     joe[:name] = 'Joseph Smith, Jr.'
#     joe['name'] # => "Joseph Smith, Jr."
#
# See Struct::new.
#
# ## What's Here
#
# First, what's elsewhere. Class Struct:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
#     provides dozens of additional methods.
#
#
# Here, class Struct provides methods that are useful for:
#
# *   [Creating a Struct
#     Subclass](#class-Struct-label-Methods+for+Creating+a+Struct+Subclass)
# *   [Querying](#class-Struct-label-Methods+for+Querying)
# *   [Comparing](#class-Struct-label-Methods+for+Comparing)
# *   [Fetching](#class-Struct-label-Methods+for+Fetching)
# *   [Assigning](#class-Struct-label-Methods+for+Assigning)
# *   [Iterating](#class-Struct-label-Methods+for+Iterating)
# *   [Converting](#class-Struct-label-Methods+for+Converting)
#
#
# ### Methods for Creating a Struct Subclass
#
# ::new
# :   Returns a new subclass of Struct.
#
#
# ### Methods for Querying
#
# #hash
# :   Returns the integer hash code.
# #length, #size
# :   Returns the number of members.
#
#
# ### Methods for Comparing
#
# [#==](#method-i-3D-3D)
# :   Returns whether a given object is equal to `self`, using `==` to compare
#     member values.
# #eql?
# :   Returns whether a given object is equal to `self`, using `eql?` to compare
#     member values.
#
#
# ### Methods for Fetching
#
# #[]
# :   Returns the value associated with a given member name.
# #to_a, #values, #deconstruct
# :   Returns the member values in `self` as an array.
# #deconstruct_keys
# :   Returns a hash of the name/value pairs for given member names.
# #dig
# :   Returns the object in nested objects that is specified by a given member
#     name and additional arguments.
# #members
# :   Returns an array of the member names.
# #select, #filter
# :   Returns an array of member values from `self`, as selected by the given
#     block.
# #values_at
# :   Returns an array containing values for given member names.
#
#
# ### Methods for Assigning
#
# #[]=
# :   Assigns a given value to a given member name.
#
#
# ### Methods for Iterating
#
# #each
# :   Calls a given block with each member name.
# #each_pair
# :   Calls a given block with each member name/value pair.
#
#
# ### Methods for Converting
#
# #inspect, #to_s
# :   Returns a string representation of `self`.
# #to_h
# :   Returns a hash of the member name/value pairs in `self`.
#
class Struct[Elem] < Object
  include Enumerable[Elem?]

  type attribute_name = Symbol | String

  # <!--
  #   rdoc-file=struct.c
  #   - Struct.new(*member_names, keyword_init: false){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct.new(class_name, *member_names, keyword_init: false){|Struct_subclass| ... } -> Struct_subclass
  #   - Struct_subclass.new(*member_names) -> Struct_subclass_instance
  #   - Struct_subclass.new(**member_names) -> Struct_subclass_instance
  # -->
  # `Struct.new` returns a new subclass of `Struct`.  The new subclass:
  #
  # *   May be anonymous, or may have the name given by `class_name`.
  # *   May have members as given by `member_names`.
  # *   May have initialization via ordinary arguments (the default) or via
  #     keyword arguments (if `keyword_init: true` is given).
  #
  #
  # The new subclass has its own method `::new`; thus:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     f = Foo.new(0, 1)                   # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **\Class Name**
  #
  # With string argument `class_name`, returns a new subclass of `Struct` named
  # `Struct::*class_name`*:
  #
  #     Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
  #     Foo.name                            # => "Struct::Foo"
  #     Foo.superclass                      # => Struct
  #
  # Without string argument `class_name`, returns a new anonymous subclass of
  # `Struct`:
  #
  #     Struct.new(:foo, :bar).name # => nil
  #
  # **Block**
  #
  # With a block given, the created subclass is yielded to the block:
  #
  #     Customer = Struct.new('Customer', :name, :address) do |new_class|
  #       p "The new subclass is #{new_class}"
  #       def greeting
  #         "Hello #{name} at #{address}"
  #       end
  #     end           # => Struct::Customer
  #     dave = Customer.new('Dave', '123 Main')
  #     dave # =>     #<struct Struct::Customer name="Dave", address="123 Main">
  #     dave.greeting # => "Hello Dave at 123 Main"
  #
  # Output, from `Struct.new`:
  #
  #     "The new subclass is Struct::Customer"
  #
  # **Member Names**
  #
  # Symbol arguments `member_names` determines the members of the new subclass:
  #
  #     Struct.new(:foo, :bar).members        # => [:foo, :bar]
  #     Struct.new('Foo', :foo, :bar).members # => [:foo, :bar]
  #
  # The new subclass has instance methods corresponding to `member_names`:
  #
  #     Foo = Struct.new('Foo', :foo, :bar)
  #     Foo.instance_methods(false) # => [:foo, :bar, :foo=, :bar=]
  #     f = Foo.new                 # => #<struct Struct::Foo foo=nil, bar=nil>
  #     f.foo                       # => nil
  #     f.foo = 0                   # => 0
  #     f.bar                       # => nil
  #     f.bar = 1                   # => 1
  #     f                           # => #<struct Struct::Foo foo=0, bar=1>
  #
  # **Singleton Methods**
  #
  # A subclass returned by Struct.new has these singleton methods:
  #
  # *   Method `::new ` creates an instance of the subclass:
  #
  #         Foo.new          # => #<struct Struct::Foo foo=nil, bar=nil>
  #         Foo.new(0)       # => #<struct Struct::Foo foo=0, bar=nil>
  #         Foo.new(0, 1)    # => #<struct Struct::Foo foo=0, bar=1>
  #         Foo.new(0, 1, 2) # Raises ArgumentError: struct size differs
  #
  #     Method `::[]` is an alias for method `::new`.
  #
  # *   Method `:inspect` returns a string representation of the subclass:
  #
  #         Foo.inspect
  #         # => "Struct::Foo"
  #
  # *   Method `::members` returns an array of the member names:
  #
  #         Foo.members # => [:foo, :bar]
  #
  #
  # **Keyword Argument**
  #
  # By default, the arguments for initializing an instance of the new subclass are
  # ordinary arguments (not keyword arguments). With optional keyword argument
  # `keyword_init: true`, the new subclass is initialized with keyword arguments:
  #
  #     # Without keyword_init: true.
  #     Foo = Struct.new('Foo', :foo, :bar)
  #     Foo                     # => Struct::Foo
  #     Foo.new(0, 1)           # => #<struct Struct::Foo foo=0, bar=1>
  #     # With keyword_init: true.
  #     Bar = Struct.new(:foo, :bar, keyword_init: true)
  #     Bar # =>                # => Bar(keyword_init: true)
  #     Bar.new(bar: 1, foo: 0) # => #<struct Bar foo=0, bar=1>
  #
  def initialize: (attribute_name, *attribute_name, ?keyword_init: boolish) ?{ () -> void } -> void

  # <!--
  #   rdoc-file=struct.c
  #   - each {|value| ... } -> self
  #   - each -> enumerator
  # -->
  # Calls the given block with the value of each member; returns `self`:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
  #     joe.each {|value| p value }
  #
  # Output:
  #
  #     "Joe Smith"
  #     "123 Maple, Anytown NC"
  #     12345
  #
  # Returns an Enumerator if no block is given.
  #
  # Related: #each_pair.
  #
  def each: () -> ::Enumerator[Elem?, self]
          | () { (Elem? item) -> void } -> self

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::members -> array_of_symbols
  # -->
  # Returns the member names of the Struct descendant as an array:
  #
  #     Customer = Struct.new(:name, :address, :zip)
  #     Customer.members # => [:name, :address, :zip]
  #
  def self.members: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=struct.c
  #   - StructClass::keyword_init? -> true or falsy value
  # -->
  # Returns `true` if the class was initialized with `keyword_init: true`.
  # Otherwise returns `nil` or `false`.
  #
  # Examples:
  #     Foo = Struct.new(:a)
  #     Foo.keyword_init? # => nil
  #     Bar = Struct.new(:a, keyword_init: true)
  #     Bar.keyword_init? # => true
  #     Baz = Struct.new(:a, keyword_init: false)
  #     Baz.keyword_init? # => false
  #
  def self.keyword_init?: () -> (true | false | nil)
end

# <!-- rdoc-file=timev.rb -->
# Time is an abstraction of dates and times. Time is stored internally as the
# number of seconds with subsecond since the *Epoch*, 1970-01-01 00:00:00 UTC.
#
# The Time class treats GMT (Greenwich Mean Time) and UTC (Coordinated Universal
# Time) as equivalent. GMT is the older way of referring to these baseline times
# but persists in the names of calls on POSIX systems.
#
# Note: A Time object uses the resolution available on your system clock.
#
# All times may have subsecond. Be aware of this fact when comparing times with
# each other -- times that are apparently equal when displayed may be different
# when compared. (Since Ruby 2.7.0, Time#inspect shows subsecond but Time#to_s
# still doesn't show subsecond.)
#
# ## Examples
#
# All of these examples were done using the EST timezone which is GMT-5.
#
# ### Creating a New Time Instance
#
# You can create a new instance of Time with Time.new. This will use the current
# system time. Time.now is an alias for this. You can also pass parts of the
# time to Time.new such as year, month, minute, etc. When you want to construct
# a time this way you must pass at least a year. If you pass the year with
# nothing else time will default to January 1 of that year at 00:00:00 with the
# current system timezone. Here are some examples:
#
#     Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
#     Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
#     Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500
#
# You can pass a UTC offset:
#
#     Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200
#
# Or a timezone object:
#
#     zone = timezone("Europe/Athens")      # Eastern European Time, UTC+2
#     Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200
#
# You can also use Time.local and Time.utc to infer local and UTC timezones
# instead of using the current system setting.
#
# You can also create a new time using Time.at which takes the number of seconds
# (with subsecond) since the [Unix
# Epoch](https://en.wikipedia.org/wiki/Unix_time).
#
#     Time.at(628232400) #=> 1989-11-28 00:00:00 -0500
#
# ### Working with an Instance of Time
#
# Once you have an instance of Time there is a multitude of things you can do
# with it. Below are some examples. For all of the following examples, we will
# work on the assumption that you have done the following:
#
#     t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")
#
# Was that a monday?
#
#     t.monday? #=> false
#
# What year was that again?
#
#     t.year #=> 1993
#
# Was it daylight savings at the time?
#
#     t.dst? #=> false
#
# What's the day a year later?
#
#     t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900
#
# How many seconds was that since the Unix Epoch?
#
#     t.to_i #=> 730522800
#
# You can also do standard functions like compare two times.
#
#     t1 = Time.new(2010)
#     t2 = Time.new(2011)
#
#     t1 == t2 #=> false
#     t1 == t1 #=> true
#     t1 <  t2 #=> true
#     t1 >  t2 #=> false
#
#     Time.new(2010,10,31).between?(t1, t2) #=> true
#
# ## What's Here
#
# First, what's elsewhere. Class Time:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class Time provides methods that are useful for:
#
# *   [Creating \Time objects](#class-Time-label-Methods+for+Creating).
# *   [Fetching \Time values](#class-Time-label-Methods+for+Fetching).
# *   [Querying a \Time object](#class-Time-label-Methods+for+Querying).
# *   [Comparing \Time objects](#class-Time-label-Methods+for+Comparing).
# *   [Converting a \Time object](#class-Time-label-Methods+for+Converting).
# *   [Rounding a \Time](#class-Time-label-Methods+for+Rounding).
#
#
# ### Methods for Creating
#
# *   ::new: Returns a new time from specified arguments (year, month, etc.),
#     including an optional timezone value.
# *   ::local (aliased as ::mktime): Same as ::new, except the timezone is the
#     local timezone.
# *   ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC.
# *   ::at: Returns a new time based on seconds since epoch.
# *   ::now: Returns a new time based on the current system time.
# *   #+ (plus): Returns a new time increased by the given number of seconds.
# *   [-](#method-i-2D) (minus): Returns a new time
#         decreased by the given number of seconds.
#
#
# ### Methods for Fetching
#
# *   #year: Returns the year of the time.
# *   #month (aliased as #mon): Returns the month of the time.
# *   #mday (aliased as #day): Returns the day of the month.
# *   #hour: Returns the hours value for the time.
# *   #min: Returns the minutes value for the time.
# *   #sec: Returns the seconds value for the time.
# *   #usec (aliased as #tv_usec): Returns the number of microseconds in the
#     subseconds value of the time.
# *   #nsec (aliased as #tv_nsec: Returns the number of nanoseconds in the
#     subsecond part of the time.
# *   #subsec: Returns the subseconds value for the time.
# *   #wday: Returns the integer weekday value of the time (0 == Sunday).
# *   #yday: Returns the integer yearday value of the time (1 == January 1).
# *   #hash: Returns the integer hash value for the time.
# *   #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset in
#     seconds between time and UTC.
# *   #to_f: Returns the float number of seconds since epoch for the time.
# *   #to_i (aliased as #tv_sec): Returns the integer number of seconds since
#     epoch for the time.
# *   #to_r: Returns the Rational number of seconds since epoch for the time.
# *   #zone: Returns a string representation of the timezone of the time.
#
#
# ### Methods for Querying
#
# *   #utc? (aliased as #gmt?): Returns whether the time is UTC.
# *   #dst? (aliased as #isdst): Returns whether the time is DST (daylight
#     saving time).
# *   #sunday?: Returns whether the time is a Sunday.
# *   #monday?: Returns whether the time is a Monday.
# *   #tuesday?: Returns whether the time is a Tuesday.
# *   #wednesday?: Returns whether the time is a Wednesday.
# *   #thursday?: Returns whether the time is a Thursday.
# *   #friday?: Returns whether time is a Friday.
# *   #saturday?: Returns whether the time is a Saturday.
#
#
# ### Methods for Comparing
#
# *   [#<=>](#method-i-3C-3D-3E): Compares `self` to another time.
# *   #eql?: Returns whether the time is equal to another time.
#
#
# ### Methods for Converting
#
# *   #asctime (aliased as #ctime): Returns the time as a string.
# *   #inspect: Returns the time in detail as a string.
# *   #strftime: Returns the time as a string, according to a given format.
# *   #to_a: Returns a 10-element array of values from the time.
# *   #to_s: Returns a string representation of the time.
# *   #getutc (aliased as #getgm): Returns a new time converted to UTC.
# *   #getlocal: Returns a new time converted to local time.
# *   #utc (aliased as #gmtime): Converts time to UTC in place.
# *   #localtime: Converts time to local time in place.
#
#
# ### Methods for Rounding
#
# *   #round:Returns a new time with subseconds rounded.
# *   #ceil: Returns a new time with subseconds raised to a ceiling.
# *   #floor: Returns a new time with subseconds lowered to a floor.
#
#
# ## Timezone Argument
#
# A timezone argument must have `local_to_utc` and `utc_to_local` methods, and
# may have `name`, `abbr`, and `dst?` methods.
#
# The `local_to_utc` method should convert a Time-like object from the timezone
# to UTC, and `utc_to_local` is the opposite.  The result also should be a Time
# or Time-like object (not necessary to be the same class).  The #zone of the
# result is just ignored. Time-like argument to these methods is similar to a
# Time object in UTC without subsecond; it has attribute readers for the parts,
# e.g. #year, #month, and so on, and epoch time readers, #to_i.  The subsecond
# attributes are fixed as 0, and #utc_offset, #zone, #isdst, and their aliases
# are same as a Time object in UTC. Also #to_time, #+, and #- methods are
# defined.
#
# The `name` method is used for marshaling. If this method is not defined on a
# timezone object, Time objects using that timezone object can not be dumped by
# Marshal.
#
# The `abbr` method is used by '%Z' in #strftime.
#
# The `dst?` method is called with a `Time` value and should return whether the
# `Time` value is in daylight savings time in the zone.
#
# ### Auto Conversion to Timezone
#
# At loading marshaled data, a timezone name will be converted to a timezone
# object by `find_timezone` class method, if the method is defined.
#
# Similarly, that class method will be called when a timezone argument does not
# have the necessary methods mentioned above.
#
class Time < Object
  include Comparable

  # <!--
  #   rdoc-file=timev.rb
  #   - at(time, subsec = false, unit = :microsecond, in: nil)
  # -->
  # *Time*
  #
  # This form accepts a Time object `time` and optional keyword argument `in`:
  #
  #     Time.at(Time.new)               # => 2021-04-26 08:52:31.6023486 -0500
  #     Time.at(Time.new, in: '+09:00') # => 2021-04-26 22:52:31.6023486 +0900
  #
  # *Seconds*
  #
  # This form accepts a numeric number of seconds `sec` and optional keyword
  # argument `in`:
  #
  #     Time.at(946702800)               # => 1999-12-31 23:00:00 -0600
  #     Time.at(946702800, in: '+09:00') # => 2000-01-01 14:00:00 +0900
  #
  # *Seconds with Subseconds and Units*
  #
  # This form accepts an integer number of seconds `sec_i`, a numeric number of
  # milliseconds `msec`, a symbol argument for the subsecond unit type (defaulting
  # to :usec), and an optional keyword argument `in`:
  #
  #     Time.at(946702800, 500, :millisecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500, :millisecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000)                             # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, :usec)                      # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, :microsecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000, in: '+09:00')               # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000, :usec, in: '+09:00')        # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000, :microsecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000000, :nsec)                     # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000000, :nanosecond)               # => 1999-12-31 23:00:00.5 -0600
  #     Time.at(946702800, 500000000, :nsec, in: '+09:00')       # => 2000-01-01 14:00:00.5 +0900
  #     Time.at(946702800, 500000000, :nanosecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
  #
  # Parameters:
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `msec` is the number of milliseconds (Integer, Float, or Rational) in the
  #     range `0..1000`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  # *   `nsec` is the number of nanoseconds (Integer, Float, or Rational) in the
  #     range `0..1000000000`.
  # *   `in: zone`: a timezone *zone*, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  def self.at: (Time, ?in: String | Integer | nil) -> Time
             | (Numeric, ?in: String | Integer | nil) -> Time
             | (Integer sec_i, Numeric msec, subsec_unit msec, ?in: String | Integer | nil) -> Time

  type subsec_unit = :msec | :millisecond | :usec | :microsecond | :nsec | :nanosecond

  # Creates a Time object based on given values, interpreted as UTC (GMT). The
  # year must be specified. Other values default to the minimum value for that
  # field (and may be `nil` or omitted). Months may be specified by numbers from 1
  # to 12, or by the three-letter English month names. Hours are specified on a
  # 24-hour clock (0..23). Raises an ArgumentError if any values are out of range.
  # Will also accept ten arguments in the order output by Time#to_a.
  #
  # `sec_with_frac` and `usec_with_frac` can have a fractional part.
  #
  #     Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
  #     Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #
  def self.gm: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.local(year, month=1, day=1, hour=0, min=0, sec_i=0, usec=0) -> new_time
  #   - Time.local(sec, min, hour, day, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Returns a new Time object based the on given arguments; its timezone is the
  # local timezone.
  #
  # In the first form (up to seven arguments), argument `year` is required.
  #
  #     Time.local(2000)                   # => 2000-01-01 00:00:00 -0600
  #     Time.local(0, 1, 2, 3, 4, 5, 6.5)  # => 0000-01-02 03:04:05.0000065 -0600
  #
  # In the second form, all ten arguments are required, though the last four are
  # ignored. This form is useful for creating a time from a 10-element array such
  # as those returned by #to_a.
  #
  #     array = Time.now.to_a
  #     p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
  #     array[5] = 2000
  #     Time.local(*array)  # => 2000-04-24 13:26:57 -0500
  #
  # Parameters:
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  #
  #
  # Alias: Time.mktime.
  #
  # Related: Time.utc.
  #
  def self.local: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=timev.rb
  #   - now(in: nil)
  # -->
  # Creates a new Time object from the current system time. This is the same as
  # Time.new without arguments.
  #
  #     Time.now               # => 2009-06-24 12:39:54 +0900
  #     Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400
  #
  # Parameter:
  # *   `in: zone`: a timezone *zone*, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  def self.now: (?in: String | Integer | nil) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - Time.utc(year, month=1, day=1, hour=0, min=0, sec_i=0, usec=0) -> new_time
  #   - Time.utc(sec_i, min, hour, day, month, year, dummy, dummy, dummy, dummy) -> new_time
  # -->
  # Returns a new Time object based the on given arguments; its timezone is UTC.
  #
  # In the first form (up to seven arguments), argument `year` is required.
  #
  #     Time.utc(2000)                  # => 2000-01-01 00:00:00 UTC
  #     Time.utc(0, 1, 2, 3, 4, 5, 6.5) # => 0000-01-02 03:04:05.0000065 UTC
  #
  # In the second form, all ten arguments are required, though the last four are
  # ignored. This form is useful for creating a time from a 10-element array such
  # as is returned by #to_a.
  #
  #     array = Time.now.to_a
  #     p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
  #     array[5] = 2000
  #     Time.utc(*array) # => 2000-04-24 13:26:57 UTC
  #
  # Parameters:
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `isec_i` is the integer number of seconds in the range `0..60`.
  # *   `usec` is the number of microseconds (Integer, Float, or Rational) in the
  #     range `0..1000000`.
  #
  #
  # Alias: Time.gm.
  #
  # Related: Time.local.
  #
  def self.utc: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time + numeric -> time
  # -->
  # Adds some number of seconds (possibly including subsecond) to *time* and
  # returns that value as a new Time object.
  #
  #     t = Time.now         #=> 2020-07-20 22:14:43.170490982 +0900
  #     t + (60 * 60 * 24)   #=> 2020-07-21 22:14:43.170490982 +0900
  #
  def +: (Numeric arg0) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time - other_time -> float
  #   - time - numeric    -> time
  # -->
  # Returns a difference in seconds as a Float between *time* and `other_time`, or
  # subtracts the given number of seconds in `numeric` from *time*.
  #
  #     t = Time.now       #=> 2020-07-20 22:15:49.302766336 +0900
  #     t2 = t + 2592000   #=> 2020-08-19 22:15:49.302766336 +0900
  #     t2 - t             #=> 2592000.0
  #     t2 - 2592000       #=> 2020-07-20 22:15:49.302766336 +0900
  #
  def -: (Time arg0) -> Float
       | (Numeric arg0) -> Time

  def <: (Time arg0) -> bool

  def <=: (Time arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time <=> other_time -> -1, 0, +1, or nil
  # -->
  # Compares `time` with `other_time`.
  #
  # -1, 0, +1 or nil depending on whether `time` is less than, equal to, or
  # greater than `other_time`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  #     t = Time.now       #=> 2007-11-19 08:12:12 -0600
  #     t2 = t + 2592000   #=> 2007-12-19 08:12:12 -0600
  #     t <=> t2           #=> -1
  #     t2 <=> t           #=> 1
  #
  #     t = Time.now       #=> 2007-11-19 08:13:38 -0600
  #     t2 = t + 0.1       #=> 2007-11-19 08:13:38 -0600
  #     t.nsec             #=> 98222999
  #     t2.nsec            #=> 198222999
  #     t <=> t2           #=> -1
  #     t2 <=> t           #=> 1
  #     t <=> t            #=> 0
  #
  def <=>: (Time other) -> Integer
         | (untyped other) -> Integer?

  def >: (Time arg0) -> bool

  def >=: (Time arg0) -> bool

  # <!-- rdoc-file=time.c -->
  # Returns a canonical string representation of *time*.
  #
  #     Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
  #     Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"
  #
  def asctime: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.asctime -> string
  #   - time.ctime   -> string
  # -->
  # Returns a canonical string representation of *time*.
  #
  #     Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
  #     Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"
  #
  def ctime: () -> String

  # <!-- rdoc-file=time.c -->
  # Returns the day of the month (1..31) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:03 -0600
  #     t.day          #=> 19
  #     t.mday         #=> 19
  #
  def day: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns `true` if *time* occurs during Daylight Saving Time in its time zone.
  #
  #     # CST6CDT:
  #       Time.local(2000, 1, 1).zone    #=> "CST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "CDT"
  #       Time.local(2000, 7, 1).isdst   #=> true
  #       Time.local(2000, 7, 1).dst?    #=> true
  #
  #     # Asia/Tokyo:
  #       Time.local(2000, 1, 1).zone    #=> "JST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "JST"
  #       Time.local(2000, 7, 1).isdst   #=> false
  #       Time.local(2000, 7, 1).dst?    #=> false
  #
  def dst?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.eql?(other_time)
  # -->
  # Returns `true` if *time* and `other_time` are both Time objects with the same
  # seconds (including subsecond) from the Epoch.
  #
  def eql?: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.friday? -> true or false
  # -->
  # Returns `true` if *time* represents Friday.
  #
  #     t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600
  #     t.friday?                        #=> true
  #
  def friday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.getgm  -> new_time
  #   - time.getutc -> new_time
  # -->
  # Returns a new Time object representing *time* in UTC.
  #
  #     t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #     t.gmt?                             #=> false
  #     y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
  #     y.gmt?                             #=> true
  #     t == y                             #=> true
  #
  def getgm: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.getlocal -> new_time
  #   - time.getlocal(utc_offset) -> new_time
  #   - time.getlocal(timezone) -> new_time
  # -->
  # Returns a new Time object representing *time* in local time (using the local
  # time zone in effect for this process).
  #
  # If `utc_offset` is given, it is used instead of the local time. `utc_offset`
  # can be given as a human-readable string (eg. `"+09:00"`) or as a number of
  # seconds (eg. `32400`).
  #
  #     t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                          #=> true
  #
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.utc?                          #=> false
  #     t == l                          #=> true
  #
  #     j = t.getlocal("+09:00")        #=> 2000-01-02 05:15:01 +0900
  #     j.utc?                          #=> false
  #     t == j                          #=> true
  #
  #     k = t.getlocal(9*60*60)         #=> 2000-01-02 05:15:01 +0900
  #     k.utc?                          #=> false
  #     t == k                          #=> true
  #
  def getlocal: (?Integer utc_offset) -> Time

  # <!-- rdoc-file=time.c -->
  # Returns a new Time object representing *time* in UTC.
  #
  #     t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #     t.gmt?                             #=> false
  #     y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
  #     y.gmt?                             #=> true
  #     t == y                             #=> true
  #
  def getutc: () -> Time

  # <!-- rdoc-file=time.c -->
  # Returns `true` if *time* represents a time in UTC (GMT).
  #
  #     t = Time.now                        #=> 2007-11-19 08:15:23 -0600
  #     t.utc?                              #=> false
  #     t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                              #=> true
  #
  #     t = Time.now                        #=> 2007-11-19 08:16:03 -0600
  #     t.gmt?                              #=> false
  #     t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
  #     t.gmt?                              #=> true
  #
  def gmt?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def gmt_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.gmtime    -> time
  #   - time.utc       -> time
  # -->
  # Converts *time* to UTC (GMT), modifying the receiver.
  #
  #     t = Time.now   #=> 2007-11-19 08:18:31 -0600
  #     t.gmt?         #=> false
  #     t.gmtime       #=> 2007-11-19 14:18:31 UTC
  #     t.gmt?         #=> true
  #
  #     t = Time.now   #=> 2007-11-19 08:18:51 -0600
  #     t.utc?         #=> false
  #     t.utc          #=> 2007-11-19 14:18:51 UTC
  #     t.utc?         #=> true
  #
  def gmtime: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.hash   -> integer
  # -->
  # Returns a hash code for this Time object.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.hour -> integer
  # -->
  # Returns the hour of the day (0..23) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:26:20 -0600
  #     t.hour         #=> 8
  #
  def hour: () -> Integer

  # <!--
  #   rdoc-file=timev.rb
  #   - new(year = (now = true), mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil)
  # -->
  # Returns a new Time object based on the given arguments.
  #
  # With no positional arguments, returns the value of Time.now:
  #
  #     Time.new                                       # => 2021-04-24 17:27:46.0512465 -0500
  #
  # Otherwise, returns a new Time object based on the given parameters:
  #
  #     Time.new(2000)                                 # => 2000-01-01 00:00:00 -0600
  #     Time.new(2000, 12, 31, 23, 59, 59.5)           # => 2000-12-31 23:59:59.5 -0600
  #     Time.new(2000, 12, 31, 23, 59, 59.5, '+09:00') # => 2000-12-31 23:59:59.5 +0900
  #
  # Parameters:
  #
  # *   `year`: an integer year.
  # *   `month`: a month value, which may be:
  #     *   An integer month in the range `1..12`.
  #     *   A 3-character string that matches regular expression
  #         `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.
  #
  # *   `day`: an integer day in the range `1..31` (less than 31 for some months).
  # *   `hour`: an integer hour in the range `0..23`.
  # *   `min`: an integer minute in the range `0..59`.
  # *   `sec` is the number of seconds (Integer, Float, or Rational) in the range
  #     `0..60`.
  # *   `zone`: a timezone, which may be:
  #     *   A string offset from UTC.
  #     *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
  #         so-called military timezone) excluded.
  #     *   An integer number of seconds.
  #     *   A timezone object; see [Timezone
  #         Argument](#class-Time-label-Timezone+Argument) for details.
  #
  # *   `in: zone`: a timezone *zone*, which may be as above.
  #
  def initialize: (?Integer? year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, ?String | Integer | nil) -> void
                | (?Integer? year, ?Integer? month, ?Integer? day, ?Integer? hour, ?Integer? min, ?Numeric? sec, in: String | Integer | nil) -> void

  # <!--
  #   rdoc-file=time.c
  #   - time.inspect -> string
  # -->
  # Returns a detailed string representing *time*. Unlike to_s, preserves
  # subsecond in the representation for easier debugging.
  #
  #     t = Time.now
  #     t.inspect                             #=> "2012-11-10 18:16:12.261257655 +0100"
  #     t.strftime "%Y-%m-%d %H:%M:%S.%N %z"  #=> "2012-11-10 18:16:12.261257655 +0100"
  #
  #     t.utc.inspect                          #=> "2012-11-10 17:16:12.261257655 UTC"
  #     t.strftime "%Y-%m-%d %H:%M:%S.%N UTC"  #=> "2012-11-10 17:16:12.261257655 UTC"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.isdst -> true or false
  #   - time.dst?  -> true or false
  # -->
  # Returns `true` if *time* occurs during Daylight Saving Time in its time zone.
  #
  #     # CST6CDT:
  #       Time.local(2000, 1, 1).zone    #=> "CST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "CDT"
  #       Time.local(2000, 7, 1).isdst   #=> true
  #       Time.local(2000, 7, 1).dst?    #=> true
  #
  #     # Asia/Tokyo:
  #       Time.local(2000, 1, 1).zone    #=> "JST"
  #       Time.local(2000, 1, 1).isdst   #=> false
  #       Time.local(2000, 1, 1).dst?    #=> false
  #       Time.local(2000, 7, 1).zone    #=> "JST"
  #       Time.local(2000, 7, 1).isdst   #=> false
  #       Time.local(2000, 7, 1).dst?    #=> false
  #
  def isdst: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.localtime -> time
  #   - time.localtime(utc_offset) -> time
  # -->
  # Converts *time* to local time (using the local time zone in effect at the
  # creation time of *time*) modifying the receiver.
  #
  # If `utc_offset` is given, it is used instead of the local time.
  #
  #     t = Time.utc(2000, "jan", 1, 20, 15, 1) #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                                  #=> true
  #
  #     t.localtime                             #=> 2000-01-01 14:15:01 -0600
  #     t.utc?                                  #=> false
  #
  #     t.localtime("+09:00")                   #=> 2000-01-02 05:15:01 +0900
  #     t.utc?                                  #=> false
  #
  # If `utc_offset` is not given and *time* is local time, just returns the
  # receiver.
  #
  def localtime: (?String utc_offset) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.day  -> integer
  #   - time.mday -> integer
  # -->
  # Returns the day of the month (1..31) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:03 -0600
  #     t.day          #=> 19
  #     t.mday         #=> 19
  #
  def mday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.min -> integer
  # -->
  # Returns the minute of the hour (0..59) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:25:51 -0600
  #     t.min          #=> 25
  #
  def min: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.mon   -> integer
  #   - time.month -> integer
  # -->
  # Returns the month of the year (1..12) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:30 -0600
  #     t.mon          #=> 11
  #     t.month        #=> 11
  #
  def mon: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.monday? -> true or false
  # -->
  # Returns `true` if *time* represents Monday.
  #
  #     t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500
  #     t.monday?                        #=> true
  #
  def monday?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the number of nanoseconds for the subsecond part of *time*. The result
  # is a non-negative integer less than 10**9.
  #
  #     t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
  #     t.nsec              #=> 963933942
  #
  # If *time* has fraction of nanosecond (such as picoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.nsec              #=> 666777888
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def nsec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.round([ndigits])   -> new_time
  # -->
  # Rounds subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.123456789r)
  #     t                       #=> 2010-03-30 05:43:25.123456789 UTC
  #     t.round                 #=> 2010-03-30 05:43:25 UTC
  #     t.round(0)              #=> 2010-03-30 05:43:25 UTC
  #     t.round(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.round(2)              #=> 2010-03-30 05:43:25.12 UTC
  #     t.round(3)              #=> 2010-03-30 05:43:25.123 UTC
  #     t.round(4)              #=> 2010-03-30 05:43:25.1235 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).round         #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.49).round        #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.5).round         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.4).round         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.49).round        #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.5).round         #=> 2000-01-01 00:00:01 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)     #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.123456789).round(4).iso8601(6)  #=> 1999-12-31 23:59:59.1235 UTC
  #
  def round: (?Integer arg0) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.saturday? -> true or false
  # -->
  # Returns `true` if *time* represents Saturday.
  #
  #     t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500
  #     t.saturday?                      #=> true
  #
  def saturday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.sec -> integer
  # -->
  # Returns the second of the minute (0..60) for *time*.
  #
  # **Note:** Seconds range from zero to 60 to allow the system to inject leap
  # seconds. See https://en.wikipedia.org/wiki/Leap_second for further details.
  #
  #     t = Time.now   #=> 2007-11-19 08:25:02 -0600
  #     t.sec          #=> 2
  #
  def sec: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.strftime( string ) -> string
  # -->
  # Formats *time* according to the directives in the given format string.
  #
  # The directives begin with a percent (%) character. Any text not listed as a
  # directive will be passed through to the output string.
  #
  # The directive consists of a percent (%) character, zero or more flags,
  # optional minimum field width, optional modifier and a conversion specifier as
  # follows:
  #
  #     %<flags><width><modifier><conversion>
  #
  # Flags:
  #     -  don't pad a numerical output
  #     _  use spaces for padding
  #     0  use zeros for padding
  #     ^  upcase the result string
  #     #  change case
  #     :  use colons for %z
  #
  # The minimum field width specifies the minimum width.
  #
  # The modifiers are "E" and "O". They are ignored.
  #
  # Format directives:
  #
  #     Date (Year, Month, Day):
  #       %Y - Year with century if provided, will pad result at least 4 digits.
  #               -0001, 0000, 1995, 2009, 14292, etc.
  #       %C - year / 100 (rounded down such as 20 in 2009)
  #       %y - year % 100 (00..99)
  #
  #       %m - Month of the year, zero-padded (01..12)
  #               %_m  blank-padded ( 1..12)
  #               %-m  no-padded (1..12)
  #       %B - The full month name (``January'')
  #               %^B  uppercased (``JANUARY'')
  #       %b - The abbreviated month name (``Jan'')
  #               %^b  uppercased (``JAN'')
  #       %h - Equivalent to %b
  #
  #       %d - Day of the month, zero-padded (01..31)
  #               %-d  no-padded (1..31)
  #       %e - Day of the month, blank-padded ( 1..31)
  #
  #       %j - Day of the year (001..366)
  #
  #     Time (Hour, Minute, Second, Subsecond):
  #       %H - Hour of the day, 24-hour clock, zero-padded (00..23)
  #       %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
  #       %I - Hour of the day, 12-hour clock, zero-padded (01..12)
  #       %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
  #       %P - Meridian indicator, lowercase (``am'' or ``pm'')
  #       %p - Meridian indicator, uppercase (``AM'' or ``PM'')
  #
  #       %M - Minute of the hour (00..59)
  #
  #       %S - Second of the minute (00..60)
  #
  #       %L - Millisecond of the second (000..999)
  #            The digits under millisecond are truncated to not produce 1000.
  #       %N - Fractional seconds digits, default is 9 digits (nanosecond)
  #               %3N  millisecond (3 digits)
  #               %6N  microsecond (6 digits)
  #               %9N  nanosecond (9 digits)
  #               %12N picosecond (12 digits)
  #               %15N femtosecond (15 digits)
  #               %18N attosecond (18 digits)
  #               %21N zeptosecond (21 digits)
  #               %24N yoctosecond (24 digits)
  #            The digits under the specified length are truncated to avoid
  #            carry up.
  #
  #     Time zone:
  #       %z - Time zone as hour and minute offset from UTC (e.g. +0900)
  #               %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
  #               %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
  #       %Z - Abbreviated time zone name or similar information.  (OS dependent)
  #
  #     Weekday:
  #       %A - The full weekday name (``Sunday'')
  #               %^A  uppercased (``SUNDAY'')
  #       %a - The abbreviated name (``Sun'')
  #               %^a  uppercased (``SUN'')
  #       %u - Day of the week (Monday is 1, 1..7)
  #       %w - Day of the week (Sunday is 0, 0..6)
  #
  #     ISO 8601 week-based year and week number:
  #     The first week of YYYY starts with a Monday and includes YYYY-01-04.
  #     The days in the year before the first week are in the last week of
  #     the previous year.
  #       %G - The week-based year
  #       %g - The last 2 digits of the week-based year (00..99)
  #       %V - Week number of the week-based year (01..53)
  #
  #     Week number:
  #     The first week of YYYY that starts with a Sunday or Monday (according to %U
  #     or %W). The days in the year before the first week are in week 0.
  #       %U - Week number of the year. The week starts with Sunday. (00..53)
  #       %W - Week number of the year. The week starts with Monday. (00..53)
  #
  #     Seconds since the Epoch:
  #       %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #
  #     Literal string:
  #       %n - Newline character (\n)
  #       %t - Tab character (\t)
  #       %% - Literal ``%'' character
  #
  #     Combination:
  #       %c - date and time (%a %b %e %T %Y)
  #       %D - Date (%m/%d/%y)
  #       %F - The ISO 8601 date format (%Y-%m-%d)
  #       %v - VMS date (%e-%^b-%4Y)
  #       %x - Same as %D
  #       %X - Same as %T
  #       %r - 12-hour time (%I:%M:%S %p)
  #       %R - 24-hour time (%H:%M)
  #       %T - 24-hour time (%H:%M:%S)
  #
  # This method is similar to strftime() function defined in ISO C and POSIX.
  #
  # While all directives are locale independent since Ruby 1.9, %Z is platform
  # dependent. So, the result may differ even if the same format string is used in
  # other systems such as C.
  #
  # %z is recommended over %Z. %Z doesn't identify the timezone. For example,
  # "CST" is used at America/Chicago (-06:00), America/Havana (-05:00),
  # Asia/Harbin (+08:00), Australia/Darwin (+09:30) and Australia/Adelaide
  # (+10:30). Also, %Z is highly dependent on the operating system. For example,
  # it may generate a non ASCII string on Japanese Windows, i.e. the result can be
  # different to "JST". So the numeric time zone offset, %z, is recommended.
  #
  # Examples:
  #
  #     t = Time.new(2007,11,19,8,37,48,"-06:00") #=> 2007-11-19 08:37:48 -0600
  #     t.strftime("Printed on %m/%d/%Y")         #=> "Printed on 11/19/2007"
  #     t.strftime("at %I:%M %p")                 #=> "at 08:37 AM"
  #
  # Various ISO 8601 formats:
  #     %Y%m%d           => 20071119                  Calendar date (basic)
  #     %F               => 2007-11-19                Calendar date (extended)
  #     %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
  #     %Y               => 2007                      Calendar date, reduced accuracy, specific year
  #     %C               => 20                        Calendar date, reduced accuracy, specific century
  #     %Y%j             => 2007323                   Ordinal date (basic)
  #     %Y-%j            => 2007-323                  Ordinal date (extended)
  #     %GW%V%u          => 2007W471                  Week date (basic)
  #     %G-W%V-%u        => 2007-W47-1                Week date (extended)
  #     %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
  #     %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
  #     %H%M%S           => 083748                    Local time (basic)
  #     %T               => 08:37:48                  Local time (extended)
  #     %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
  #     %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
  #     %H               => 08                        Local time, reduced accuracy, specific hour
  #     %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
  #     %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
  #     %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
  #     %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
  #     %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
  #     %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
  #     %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
  #     %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
  #     %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
  #     %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
  #     %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
  #     %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
  #     %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
  #     %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
  #     %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
  #     %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
  #     %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
  #     %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)
  #
  def strftime: (String arg0) -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.subsec    -> number
  # -->
  # Returns the subsecond for *time*.
  #
  # The return value can be a rational number.
  #
  #     t = Time.now        #=> 2020-07-20 15:40:26.867462289 +0900
  #     t.subsec            #=> (867462289/1000000000)
  #
  #     t = Time.now        #=> 2020-07-20 15:40:50.313828595 +0900
  #     t.subsec            #=> (62765719/200000000)
  #
  #     t = Time.new(2000,1,1,2,3,4) #=> 2000-01-01 02:03:04 +0900
  #     t.subsec                     #=> 0
  #
  #     Time.new(2000,1,1,0,0,1/3r,"UTC").subsec #=> (1/3)
  #
  def subsec: () -> Numeric

  # <!--
  #   rdoc-file=time.c
  #   - time.sunday? -> true or false
  # -->
  # Returns `true` if *time* represents Sunday.
  #
  #     t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600
  #     t.sunday?                        #=> true
  #
  def sunday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.thursday? -> true or false
  # -->
  # Returns `true` if *time* represents Thursday.
  #
  #     t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600
  #     t.thursday?                      #=> true
  #
  def thursday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.to_a -> array
  # -->
  # Returns a ten-element *array* of values for *time*:
  #
  #     [sec, min, hour, day, month, year, wday, yday, isdst, zone]
  #
  # See the individual methods for an explanation of the valid ranges of each
  # value. The ten elements can be passed directly to Time.utc or Time.local to
  # create a new Time object.
  #
  #     t = Time.now     #=> 2007-11-19 08:36:01 -0600
  #     now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, "CST"]
  #
  def to_a: () -> [ Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, bool, String ]

  # <!--
  #   rdoc-file=time.c
  #   - time.to_f -> float
  # -->
  # Returns the value of *time* as a floating point number of seconds since the
  # Epoch. The return value approximate the exact value in the Time object because
  # floating point numbers cannot represent all rational numbers exactly.
  #
  #     t = Time.now        #=> 2020-07-20 22:00:29.38740268 +0900
  #     t.to_f              #=> 1595250029.3874028
  #     t.to_i              #=> 1595250029
  #
  # Note that IEEE 754 double is not accurate enough to represent the exact number
  # of nanoseconds since the Epoch. (IEEE 754 double has 53bit mantissa. So it can
  # represent exact number of nanoseconds only in `2 ** 53 / 1_000_000_000 / 60 /
  # 60 / 24 = 104.2` days.) When Ruby uses a nanosecond-resolution clock function,
  # such as `clock_gettime` of POSIX, to obtain the current time, Time#to_f can
  # lose information of a Time object created with `Time.now`.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=time.c
  #   - time.to_i   -> int
  #   - time.tv_sec -> int
  # -->
  # Returns the value of *time* as an integer number of seconds since the Epoch.
  #
  # If *time* contains subsecond, they are truncated.
  #
  #     t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
  #     t.to_i              #=> 1595263289
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.to_r -> a_rational
  # -->
  # Returns the value of *time* as a rational number of seconds since the Epoch.
  #
  #     t = Time.now      #=> 2020-07-20 22:03:45.212167333 +0900
  #     t.to_r            #=> (1595250225212167333/1000000000)
  #
  # This method is intended to be used to get an accurate value representing the
  # seconds (including subsecond) since the Epoch.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=time.c
  #   - time.to_s    -> string
  # -->
  # Returns a string representing *time*. Equivalent to calling #strftime with the
  # appropriate format string.
  #
  #     t = Time.now
  #     t.to_s                              #=> "2012-11-10 18:16:12 +0100"
  #     t.strftime "%Y-%m-%d %H:%M:%S %z"   #=> "2012-11-10 18:16:12 +0100"
  #
  #     t.utc.to_s                          #=> "2012-11-10 17:16:12 UTC"
  #     t.strftime "%Y-%m-%d %H:%M:%S UTC"  #=> "2012-11-10 17:16:12 UTC"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=time.c
  #   - time.tuesday? -> true or false
  # -->
  # Returns `true` if *time* represents Tuesday.
  #
  #     t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600
  #     t.tuesday?                       #=> true
  #
  def tuesday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.nsec    -> int
  #   - time.tv_nsec -> int
  # -->
  # Returns the number of nanoseconds for the subsecond part of *time*. The result
  # is a non-negative integer less than 10**9.
  #
  #     t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
  #     t.nsec              #=> 963933942
  #
  # If *time* has fraction of nanosecond (such as picoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.nsec              #=> 666777888
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def tv_nsec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Returns the value of *time* as an integer number of seconds since the Epoch.
  #
  # If *time* contains subsecond, they are truncated.
  #
  #     t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
  #     t.to_i              #=> 1595263289
  #
  def tv_sec: () -> Numeric

  # <!--
  #   rdoc-file=time.c
  #   - time.usec    -> int
  #   - time.tv_usec -> int
  # -->
  # Returns the number of microseconds for the subsecond part of *time*. The
  # result is a non-negative integer less than 10**6.
  #
  #     t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
  #     t.usec              #=> 459785
  #
  # If *time* has fraction of microsecond (such as nanoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.usec              #=> 666777
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def tv_usec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Returns the number of microseconds for the subsecond part of *time*. The
  # result is a non-negative integer less than 10**6.
  #
  #     t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
  #     t.usec              #=> 459785
  #
  # If *time* has fraction of microsecond (such as nanoseconds), it is truncated.
  #
  #     t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
  #     t.usec              #=> 666777
  #
  # Time#subsec can be used to obtain the subsecond part exactly.
  #
  def usec: () -> Numeric

  # <!-- rdoc-file=time.c -->
  # Converts *time* to UTC (GMT), modifying the receiver.
  #
  #     t = Time.now   #=> 2007-11-19 08:18:31 -0600
  #     t.gmt?         #=> false
  #     t.gmtime       #=> 2007-11-19 14:18:31 UTC
  #     t.gmt?         #=> true
  #
  #     t = Time.now   #=> 2007-11-19 08:18:51 -0600
  #     t.utc?         #=> false
  #     t.utc          #=> 2007-11-19 14:18:51 UTC
  #     t.utc?         #=> true
  #
  def utc: () -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.utc? -> true or false
  #   - time.gmt? -> true or false
  # -->
  # Returns `true` if *time* represents a time in UTC (GMT).
  #
  #     t = Time.now                        #=> 2007-11-19 08:15:23 -0600
  #     t.utc?                              #=> false
  #     t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.utc?                              #=> true
  #
  #     t = Time.now                        #=> 2007-11-19 08:16:03 -0600
  #     t.gmt?                              #=> false
  #     t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
  #     t.gmt?                              #=> true
  #
  def utc?: () -> bool

  # <!-- rdoc-file=time.c -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def utc_offset: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.wday -> integer
  # -->
  # Returns an integer representing the day of the week, 0..6, with Sunday == 0.
  #
  #     t = Time.now   #=> 2007-11-20 02:35:35 -0600
  #     t.wday         #=> 2
  #     t.sunday?      #=> false
  #     t.monday?      #=> false
  #     t.tuesday?     #=> true
  #     t.wednesday?   #=> false
  #     t.thursday?    #=> false
  #     t.friday?      #=> false
  #     t.saturday?    #=> false
  #
  def wday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.wednesday? -> true or false
  # -->
  # Returns `true` if *time* represents Wednesday.
  #
  #     t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600
  #     t.wednesday?                     #=> true
  #
  def wednesday?: () -> bool

  # <!--
  #   rdoc-file=time.c
  #   - time.yday -> integer
  # -->
  # Returns an integer representing the day of the year, 1..366.
  #
  #     t = Time.now   #=> 2007-11-19 08:32:31 -0600
  #     t.yday         #=> 323
  #
  def yday: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.year -> integer
  # -->
  # Returns the year for *time* (including the century).
  #
  #     t = Time.now   #=> 2007-11-19 08:27:51 -0600
  #     t.year         #=> 2007
  #
  def year: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.zone -> string or timezone
  # -->
  # Returns the name of the time zone used for *time*. As of Ruby 1.8, returns
  # ``UTC'' rather than ``GMT'' for UTC times.
  #
  #     t = Time.gm(2000, "jan", 1, 20, 15, 1)
  #     t.zone   #=> "UTC"
  #     t = Time.local(2000, "jan", 1, 20, 15, 1)
  #     t.zone   #=> "CST"
  #
  def zone: () -> String

  # Same as Time::gm, but interprets the values in the local time zone.
  #
  #     Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
  #
  def self.mktime: (Integer year, ?Integer | String month, ?Integer day, ?Integer hour, ?Integer min, ?Numeric sec, ?Numeric usec_with_frac) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.gmt_offset -> integer
  #   - time.gmtoff     -> integer
  #   - time.utc_offset -> integer
  # -->
  # Returns the offset in seconds between the timezone of *time* and UTC.
  #
  #     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
  #     t.gmt_offset                    #=> 0
  #     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
  #     l.gmt_offset                    #=> -21600
  #
  def gmtoff: () -> Integer

  # <!-- rdoc-file=time.c -->
  # Returns the month of the year (1..12) for *time*.
  #
  #     t = Time.now   #=> 2007-11-19 08:27:30 -0600
  #     t.mon          #=> 11
  #     t.month        #=> 11
  #
  def month: () -> Integer

  # <!--
  #   rdoc-file=time.c
  #   - time.floor([ndigits])   -> new_time
  # -->
  # Floors subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.123456789r)
  #     t                       #=> 2010-03-30 05:43:25.123456789 UTC
  #     t.floor                 #=> 2010-03-30 05:43:25 UTC
  #     t.floor(0)              #=> 2010-03-30 05:43:25 UTC
  #     t.floor(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.floor(2)              #=> 2010-03-30 05:43:25.12 UTC
  #     t.floor(3)              #=> 2010-03-30 05:43:25.123 UTC
  #     t.floor(4)              #=> 2010-03-30 05:43:25.1234 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).floor    #=> 1999-12-31 23:59:59 UTC
  #     (t + 0.9).floor    #=> 1999-12-31 23:59:59 UTC
  #     (t + 1.4).floor    #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.9).floor    #=> 2000-01-01 00:00:00 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.123456789).floor(4)  #=> 1999-12-31 23:59:59.1234 UTC
  #
  def floor: (?Integer ndigits) -> Time

  # <!--
  #   rdoc-file=time.c
  #   - time.ceil([ndigits])   -> new_time
  # -->
  # Ceils subsecond to a given precision in decimal digits (0 digits by default).
  # It returns a new Time object. `ndigits` should be zero or a positive integer.
  #
  #     t = Time.utc(2010,3,30, 5,43,25.0123456789r)
  #     t                      #=> 2010-03-30 05:43:25 123456789/10000000000 UTC
  #     t.ceil                 #=> 2010-03-30 05:43:26 UTC
  #     t.ceil(0)              #=> 2010-03-30 05:43:26 UTC
  #     t.ceil(1)              #=> 2010-03-30 05:43:25.1 UTC
  #     t.ceil(2)              #=> 2010-03-30 05:43:25.02 UTC
  #     t.ceil(3)              #=> 2010-03-30 05:43:25.013 UTC
  #     t.ceil(4)              #=> 2010-03-30 05:43:25.0124 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.4).ceil         #=> 2000-01-01 00:00:00 UTC
  #     (t + 0.9).ceil         #=> 2000-01-01 00:00:00 UTC
  #     (t + 1.4).ceil         #=> 2000-01-01 00:00:01 UTC
  #     (t + 1.9).ceil         #=> 2000-01-01 00:00:01 UTC
  #
  #     t = Time.utc(1999,12,31, 23,59,59)
  #     (t + 0.123456789).ceil(4)  #=> 1999-12-31 23:59:59.1235 UTC
  #
  def ceil: (?Integer ndigits) -> Time
end

Time::RFC2822_DAY_NAME: Array[String]

Time::RFC2822_MONTH_NAME: Array[String]

# <!-- rdoc-file=random.c -->
# Random provides an interface to Ruby's pseudo-random number generator, or
# PRNG.  The PRNG produces a deterministic sequence of bits which approximate
# true randomness. The sequence may be represented by integers, floats, or
# binary strings.
#
# The generator may be initialized with either a system-generated or
# user-supplied seed value by using Random.srand.
#
# The class method Random.rand provides the base functionality of Kernel.rand
# along with better handling of floating point values. These are both interfaces
# to the Ruby system PRNG.
#
# Random.new will create a new PRNG with a state independent of the Ruby system
# PRNG, allowing multiple generators with different seed values or sequence
# positions to exist simultaneously. Random objects can be marshaled, allowing
# sequences to be saved and resumed.
#
# PRNGs are currently implemented as a modified Mersenne Twister with a period
# of 2**19937-1.  As this algorithm is *not* for cryptographical use, you must
# use SecureRandom for security purpose, instead of this PRNG.
#
class Random < Object
  include Random::Formatter

  # <!--
  #   rdoc-file=random.c
  #   - prng1 == prng2 -> true or false
  # -->
  # Returns true if the two generators have the same internal state, otherwise
  # false.  Equivalent generators will return the same sequence of pseudo-random
  # numbers.  Two generators will generally have the same state only if they were
  # initialized with the same seed
  #
  #     Random.new == Random.new             # => false
  #     Random.new(1234) == Random.new(1234) # => true
  #
  # and have the same invocation history.
  #
  #     prng1 = Random.new(1234)
  #     prng2 = Random.new(1234)
  #     prng1 == prng2 # => true
  #
  #     prng1.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => false
  #
  #     prng2.rand     # => 0.1915194503788923
  #     prng1 == prng2 # => true
  #
  def ==: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=random.c
  #   - prng.bytes(size) -> string
  # -->
  # Returns a random binary string containing `size` bytes.
  #
  #     random_string = Random.new.bytes(10) # => "\xD7:R\xAB?\x83\xCE\xFAkO"
  #     random_string.size                   # => 10
  #
  def bytes: (Integer size) -> String

  # <!--
  #   rdoc-file=random.c
  #   - Random.new(seed = Random.new_seed) -> prng
  # -->
  # Creates a new PRNG using `seed` to set the initial state. If `seed` is
  # omitted, the generator is initialized with Random.new_seed.
  #
  # See Random.srand for more information on the use of seed values.
  #
  def initialize: (?Integer seed) -> void

  # <!--
  #   rdoc-file=random.c
  #   - prng.rand -> float
  #   - prng.rand(max) -> number
  #   - prng.rand(range) -> number
  # -->
  # When `max` is an Integer, `rand` returns a random integer greater than or
  # equal to zero and less than `max`. Unlike Kernel.rand, when `max` is a
  # negative integer or zero, `rand` raises an ArgumentError.
  #
  #     prng = Random.new
  #     prng.rand(100)       # => 42
  #
  # When `max` is a Float, `rand` returns a random floating point number between
  # 0.0 and `max`, including 0.0 and excluding `max`.
  #
  #     prng.rand(1.5)       # => 1.4600282860034115
  #
  # When `range` is a Range, `rand` returns a random number where
  # `range.member?(number) == true`.
  #
  #     prng.rand(5..9)      # => one of [5, 6, 7, 8, 9]
  #     prng.rand(5...9)     # => one of [5, 6, 7, 8]
  #     prng.rand(5.0..9.0)  # => between 5.0 and 9.0, including 9.0
  #     prng.rand(5.0...9.0) # => between 5.0 and 9.0, excluding 9.0
  #
  # Both the beginning and ending values of the range must respond to subtract
  # (`-`) and add (`+`)methods, or rand will raise an ArgumentError.
  #
  def rand: () -> Float
          | (Integer | ::Range[Integer] max) -> Integer
          | (Float | ::Range[Float] max) -> Float

  # <!--
  #   rdoc-file=random.c
  #   - prng.seed -> integer
  # -->
  # Returns the seed value used to initialize the generator. This may be used to
  # initialize another generator with the same state at a later time, causing it
  # to produce the same sequence of numbers.
  #
  #     prng1 = Random.new(1234)
  #     prng1.seed       #=> 1234
  #     prng1.rand(100)  #=> 47
  #
  #     prng2 = Random.new(prng1.seed)
  #     prng2.rand(100)  #=> 47
  #
  def seed: () -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.new_seed -> integer
  # -->
  # Returns an arbitrary seed value. This is used by Random.new when no seed value
  # is specified as an argument.
  #
  #     Random.new_seed  #=> 115032730400174366788466674494640623225
  #
  def self.new_seed: () -> Integer

  # <!--
  #   rdoc-file=random.c
  #   - Random.rand -> float
  #   - Random.rand(max) -> number
  #   - Random.rand(range) -> number
  # -->
  # Returns a random number using the Ruby system PRNG.
  #
  # See also Random#rand.
  #
  def self.rand: () -> Float
               | (Integer | ::Range[Integer] max) -> Integer
               | (Float | ::Range[Float] max) -> Float

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self.srand: (?Integer number) -> Integer
end

Random::DEFAULT: Random

# <!-- rdoc-file=lib/random/formatter.rb -->
# ## Random number formatter.
#
# Formats generated random numbers in many manners.
#
# ### Examples
#
# Generate random hexadecimal strings:
#
#     require 'random/formatter'
#
#     prng.hex(10) #=> "52750b30ffbc7de3b362"
#     prng.hex(10) #=> "92b15d6c8dc4beb5f559"
#     prng.hex(13) #=> "39b290146bea6ce975c37cfc23"
#
# Generate random base64 strings:
#
#     prng.base64(10) #=> "EcmTPZwWRAozdA=="
#     prng.base64(10) #=> "KO1nIU+p9DKxGg=="
#     prng.base64(12) #=> "7kJSM/MzBJI+75j8"
#
# Generate random binary strings:
#
#     prng.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
#     prng.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"
#
# Generate alphanumeric strings:
#
#     prng.alphanumeric(10) #=> "S8baxMJnPl"
#     prng.alphanumeric(10) #=> "aOxAg8BAJe"
#
# Generate UUIDs:
#
#     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
#     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
#
# <!-- rdoc-file=random.c -->
# Generate a random number in the given range as Random does
#
#     prng.random_number       #=> 0.5816771641321361
#     prng.random_number(1000) #=> 485
#     prng.random_number(1..6) #=> 3
#     prng.rand                #=> 0.5816771641321361
#     prng.rand(1000)          #=> 485
#     prng.rand(1..6)          #=> 3
#
module Random::Formatter
  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - base64(n=nil)
  # -->
  # Random::Formatter#base64 generates a random base64 string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the result string is about 4/3 of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The result may contain A-Z, a-z, 0-9, "+", "/" and "=".
  #
  #     require 'random/formatter'
  #
  #     prng.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="
  #     prng.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="
  #
  # See RFC 3548 for the definition of base64.
  #
  def base64: (?Integer? n) -> String

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - hex(n=nil)
  # -->
  # Random::Formatter#hex generates a random hexadecimal string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the resulting hexadecimal string is twice of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The result may contain 0-9 and a-f.
  #
  #     require 'random/formatter'
  #
  #     prng.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"
  #     prng.hex #=> "91dc3bfb4de5b11d029d376634589b61"
  #
  def hex: (?Integer? n) -> String

  # <!-- rdoc-file=random.c -->
  # Generates formatted random number from raw random bytes. See Random#rand.
  #
  def rand: () -> Float
          | (?Float? n) -> Float
          | (?Integer? n) -> Integer
          | (?Numeric? n) -> Numeric
          | (?::Range[Float]? n) -> Float
          | (?::Range[Integer]? n) -> Integer
          | (?::Range[Numeric]? n) -> Numeric

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - random_bytes(n=nil)
  # -->
  # Random::Formatter#random_bytes generates a random binary string.
  #
  # The argument *n* specifies the length of the result string.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in future.
  #
  # The result may contain any byte: "x00" - "xff".
  #
  #     require 'random/formatter'
  #
  #     prng.random_bytes #=> "\xD8\\\xE0\xF4\r\xB2\xFC*WM\xFF\x83\x18\xF45\xB6"
  #     prng.random_bytes #=> "m\xDC\xFC/\a\x00Uf\xB2\xB2P\xBD\xFF6S\x97"
  #
  def random_bytes: (?Integer? n) -> String

  # <!--
  #   rdoc-file=random.c
  #   - prng.random_number        -> float
  #   - prng.random_number(max)   -> number
  #   - prng.random_number(range) -> number
  #   - prng.rand                 -> float
  #   - prng.rand(max)            -> number
  #   - prng.rand(range)          -> number
  # -->
  # Generates formatted random number from raw random bytes. See Random#rand.
  #
  def random_number: () -> Float
                   | (?Float? n) -> Float
                   | (?Integer? n) -> Integer
                   | (?Numeric? n) -> Numeric
                   | (?::Range[Float]? n) -> Float
                   | (?::Range[Integer]? n) -> Integer
                   | (?::Range[Numeric]? n) -> Numeric

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - urlsafe_base64(n=nil, padding=false)
  # -->
  # Random::Formatter#urlsafe_base64 generates a random URL-safe base64 string.
  #
  # The argument *n* specifies the length, in bytes, of the random number to be
  # generated. The length of the result string is about 4/3 of *n*.
  #
  # If *n* is not specified or is nil, 16 is assumed. It may be larger in the
  # future.
  #
  # The boolean argument *padding* specifies the padding. If it is false or nil,
  # padding is not generated. Otherwise padding is generated. By default, padding
  # is not generated because "=" may be used as a URL delimiter.
  #
  # The result may contain A-Z, a-z, 0-9, "-" and "_". "=" is also used if
  # *padding* is true.
  #
  #     require 'random/formatter'
  #
  #     prng.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"
  #     prng.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"
  #
  #     prng.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="
  #     prng.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="
  #
  # See RFC 3548 for the definition of URL-safe base64.
  #
  def urlsafe_base64: (?Integer? n, ?boolish padding) -> String

  # <!--
  #   rdoc-file=lib/random/formatter.rb
  #   - uuid()
  # -->
  # Random::Formatter#uuid generates a random v4 UUID (Universally Unique
  # IDentifier).
  #
  #     require 'random/formatter'
  #
  #     prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
  #     prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
  #     prng.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"
  #
  # The version 4 UUID is purely random (except the version). It doesn't contain
  # meaningful information such as MAC addresses, timestamps, etc.
  #
  # The result contains 122 random bits (15.25 random bytes).
  #
  # See RFC 4122 for details of UUID.
  #
  def uuid: () -> String
end

# <!-- rdoc-file=object.c -->
# The global value `false` is the only instance of class FalseClass and
# represents a logically false value in boolean expressions. The class provides
# operators allowing `false` to participate correctly in logical expressions.
#
class FalseClass
  public

  def !: () -> true

  # <!--
  #   rdoc-file=object.c
  #   - false & obj   -> false
  #   - nil & obj     -> false
  # -->
  # And---Returns `false`. *obj* is always evaluated as it is the argument to a
  # method call---there is no short-circuit evaluation in this case.
  #
  def &: (untyped obj) -> false

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (false) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - false ^ obj    -> true or false
  #   - nil   ^ obj    -> true or false
  # -->
  # Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
  # returns `true`.
  #
  def ^: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  # <!-- rdoc-file=object.c -->
  # The string representation of `false` is "false".
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=object.c
  #   - false.to_s   ->  "false"
  # -->
  # The string representation of `false` is "false".
  #
  def to_s: () -> "false"

  # <!--
  #   rdoc-file=object.c
  #   - false | obj   ->   true or false
  #   - nil   | obj   ->   true or false
  # -->
  # Or---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.
  #
  def |: (nil) -> false
       | (false) -> false
       | (untyped obj) -> true

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=rbconfig.rb -->
# The module storing Ruby interpreter configurations on building.
#
# This file was created by mkconfig.rb when ruby was built.  It contains build
# information for ruby which is used e.g. by mkmf to build compatible native
# extensions.  Any changes made to this file will be lost the next time ruby is
# built.
#
module RbConfig
  # <!--
  #   rdoc-file=rbconfig.rb
  #   - RbConfig.expand(val)         -> string
  #   - RbConfig.expand(val, config) -> string
  # -->
  # expands variable with given `val` value.
  #
  #     RbConfig.expand("$(bindir)") # => /home/foobar/all-ruby/ruby19x/bin
  #
  def self.expand: (String val, ?Hash[String, String] config) -> String

  def self.fire_update!: (String key, String val, ?Hash[String, String] mkconf, ?Hash[String, String] conf) -> Array[String]?

  def self.ruby: () -> String
end

# <!-- rdoc-file=rbconfig.rb -->
# The hash configurations stored.
#
RbConfig::CONFIG: Hash[String, String]

# <!-- rdoc-file=rbconfig.rb -->
# DESTDIR on make install.
#
RbConfig::DESTDIR: String

# <!-- rdoc-file=rbconfig.rb -->
# Almost same with CONFIG. MAKEFILE_CONFIG has other variable reference like
# below.
#
#     MAKEFILE_CONFIG["bindir"] = "$(exec_prefix)/bin"
#
# The values of this constant is used for creating Makefile.
#
#     require 'rbconfig'
#
#     print <<-END_OF_MAKEFILE
#     prefix = #{RbConfig::MAKEFILE_CONFIG['prefix']}
#     exec_prefix = #{RbConfig::MAKEFILE_CONFIG['exec_prefix']}
#     bindir = #{RbConfig::MAKEFILE_CONFIG['bindir']}
#     END_OF_MAKEFILE
#
#     => prefix = /usr/local
#        exec_prefix = $(prefix)
#        bindir = $(exec_prefix)/bin  MAKEFILE_CONFIG = {}
#
# RbConfig.expand is used for resolving references like above in rbconfig.
#
#     require 'rbconfig'
#     p RbConfig.expand(RbConfig::MAKEFILE_CONFIG["bindir"])
#     # => "/usr/local/bin"
#
RbConfig::MAKEFILE_CONFIG: Hash[String, String]

# <!-- rdoc-file=rbconfig.rb -->
# Ruby installed directory.
#
RbConfig::TOPDIR: String

# <!-- rdoc-file=signal.c -->
# Many operating systems allow signals to be sent to running processes. Some
# signals have a defined effect on the process, while others may be trapped at
# the code level and acted upon. For example, your process may trap the USR1
# signal and use it to toggle debugging, and may use TERM to initiate a
# controlled shutdown.
#
#     pid = fork do
#       Signal.trap("USR1") do
#         $debug = !$debug
#         puts "Debug now: #$debug"
#       end
#       Signal.trap("TERM") do
#         puts "Terminating..."
#         shutdown()
#       end
#       # . . . do some work . . .
#     end
#
#     Process.detach(pid)
#
#     # Controlling program:
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("USR1", pid)
#     # ...
#     Process.kill("TERM", pid)
#
# produces:
#      Debug now: true
#      Debug now: false
#     Terminating...
#
# The list of available signal names and their interpretation is system
# dependent. Signal delivery semantics may also vary between systems; in
# particular signal delivery may not always be reliable.
#
module Signal
  # <!--
  #   rdoc-file=signal.c
  #   - Signal.list -> a_hash
  # -->
  # Returns a list of signal names mapped to the corresponding underlying signal
  # numbers.
  #
  #     Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4, "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11, "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19, "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22, "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28, "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}
  #
  def self.list: () -> ::Hash[String, Integer]

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.signame(signo)  ->  string or nil
  # -->
  # Convert signal number to signal name. Returns `nil` if the signo is an invalid
  # signal number.
  #
  #     Signal.trap("INT") { |signo| puts Signal.signame(signo) }
  #     Process.kill("INT", 0)
  #
  # *produces:*
  #
  #     INT
  #
  def self.signame: (Integer arg0) -> String?

  # <!--
  #   rdoc-file=signal.c
  #   - Signal.trap( signal, command ) -> obj
  #   - Signal.trap( signal ) {| | block } -> obj
  # -->
  # Specifies the handling of signals. The first parameter is a signal name (a
  # string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The
  # characters ``SIG'' may be omitted from the signal name. The command or block
  # specifies code to be run when the signal is raised. If the command is the
  # string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command
  # is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler will be invoked. If
  # the command is ``EXIT'', the script will be terminated by the signal. If the
  # command is ``SYSTEM_DEFAULT'', the operating system's default handler will be
  # invoked. Otherwise, the given command or block will be run. The special signal
  # name ``EXIT'' or signal number zero will be invoked just prior to program
  # termination. trap returns the previous handler for the given signal.
  #
  #     Signal.trap(0, proc { puts "Terminating: #{$$}" })
  #     Signal.trap("CLD")  { puts "Child died" }
  #     fork && Process.wait
  #
  # produces:
  #     Terminating: 27461
  #     Child died
  #     Terminating: 27460
  #
  def self.trap: (Integer | String | Symbol signal, ?untyped command) -> (String | Proc)
               | (Integer | String | Symbol signal) { (Integer arg0) -> untyped } -> (String | Proc)
end

# <!-- rdoc-file=class.c -->
# Refinement is a class of the `self` (current context) inside `refine`
# statement. It allows to import methods from other modules, see
# #import_methods.
#
class Refinement < Module
  private

  # <!--
  #   rdoc-file=class.c
  #   - import_methods(module, ...)    -> self
  # -->
  # Imports methods from modules. Unlike Module#include, Refinement#import_methods
  # copies methods and adds them into the refinement, so the refinement is
  # activated in the imported methods.
  #
  # Note that due to method copying, only methods defined in Ruby code can be
  # imported.
  #
  #     module StrUtils
  #       def indent(level)
  #         ' ' * level + self
  #       end
  #     end
  #
  #     module M
  #       refine String do
  #         import_methods StrUtils
  #       end
  #     end
  #
  #     using M
  #     "foo".indent(3)
  #     #=> "   foo"
  #
  #     module M
  #       refine String do
  #         import_methods Enumerable
  #         # Can't import method which is not defined with Ruby code: Enumerable#drop
  #       end
  #     end
  #
  def import_methods: (*Module) -> self
end

# <!-- rdoc-file=numeric.c -->
# An Integer object represents an integer value.
#
# You can create an Integer object explicitly with:
#
# *   An [integer
#     literal](doc/syntax/literals_rdoc.html#label-Integer+Literals).
#
#
# You can convert certain objects to Integers with:
#
# *   Method [Integer](Kernel.html#method-i-Integer).
#
#
# An attempt to add a singleton method to an instance of this class causes an
# exception to be raised.
#
# ## What's Here
#
# First, what's elsewhere. Class Integer:
#
# *   Inherits from [class
#     Numeric](Numeric.html#class-Numeric-label-What-27s+Here).
#
#
# Here, class Integer provides methods for:
#
# *   [Querying](#class-Integer-label-Querying)
# *   [Comparing](#class-Integer-label-Comparing)
# *   [Converting](#class-Integer-label-Converting)
# *   [Other](#class-Integer-label-Other)
#
#
# ### Querying
#
#     #allbits?
# :       Returns whether all bits in `self` are set.
#
#     #anybits?
# :       Returns whether any bits in `self` are set.
#
#     #nobits?
# :       Returns whether no bits in `self` are set.
#
#
#
# ### Comparing
#
#     [<](#method-i-3C)
# :       Returns whether `self` is less than the given value.
#
#     [<=](#method-i-3C-3D)
# :       Returns whether `self` is less than or equal to the given value.
#
#     [<=>](#method-i-3C-3D-3E)
# :       Returns a number indicating whether `self` is less than, equal to, or
#         greater than the given value.
#
#     [==](#method-i-3D-3D) (aliased as #===)
# :       Returns whether `self` is equal to the given value.
#
#     [>](#method-i-3E)
# :       Returns whether `self` is greater than the given value.
#
#     [>=](#method-i-3E-3D)
# :       Returns whether `self` is greater than or equal to the given value.
#
#
#
# ### Converting
#
#     ::sqrt
# :       Returns the integer square root of the given value.
#
#     ::try_convert
# :       Returns the given value converted to an Integer.
#
#     #% (aliased as #modulo)
# :       Returns `self` modulo the given value.
#
#     [&](#method-i-26)
# :       Returns the bitwise AND of `self` and the given value.
#
#     #*
# :       Returns the product of `self` and the given value.
#
#     [**](#method-i-2A-2A)
# :       Returns the value of `self` raised to the power of the given value.
#
#     #+
# :       Returns the sum of `self` and the given value.
#
#     #-
# :       Returns the difference of `self` and the given value.
#
#     [/](#method-i-2F)
# :       Returns the quotient of `self` and the given value.
#
#     #<<
# :       Returns the value of `self` after a leftward bit-shift.
#
#     #>>
# :       Returns the value of `self` after a rightward bit-shift.
#
#     #[]
# :       Returns a slice of bits from `self`.
#
#     [^](#method-i-5E)
# :       Returns the bitwise EXCLUSIVE OR of `self` and the given value.
#
#     #ceil
# :       Returns the smallest number greater than or equal to `self`.
#
#     #chr
# :       Returns a 1-character string containing the character represented by
#         the value of `self`.
#
#     #digits
# :       Returns an array of integers representing the base-radix digits of
#         `self`.
#
#     #div
# :       Returns the integer result of dividing `self` by the given value.
#
#     #divmod
# :       Returns a 2-element array containing the quotient and remainder
#         results of dividing `self` by the given value.
#
#     #fdiv
# :       Returns the Float result of dividing `self` by the given value.
#
#     #floor
# :       Returns the greatest number smaller than or equal to `self`.
#
#     #pow
# :       Returns the modular exponentiation of `self`.
#
#     #pred
# :       Returns the integer predecessor of `self`.
#
#     #remainder
# :       Returns the remainder after dividing `self` by the given value.
#
#     #round
# :       Returns `self` rounded to the nearest value with the given precision.
#
#     #succ (aliased as #next)
# :       Returns the integer successor of `self`.
#
#     #to_f
# :       Returns `self` converted to a Float.
#
#     #to_s (aliased as #inspect)
# :       Returns a string containing the place-value representation of `self`
#         in the given radix.
#
#     #truncate
# :       Returns `self` truncated to the given precision.
#
#     [/](#method-i-7C)
# :       Returns the bitwise OR of `self` and the given value.
#
#
#
# ### Other
#
#     #downto
# :       Calls the given block with each integer value from `self` down to the
#         given value.
#
#     #times
# :       Calls the given block `self` times with each integer in `(0..self-1)`.
#
#     #upto
# :       Calls the given block with each integer value from `self` up to the
#         given value.
#
class Integer < Numeric
  # <!--
  #   rdoc-file=numeric.c
  #   - Integer.sqrt(numeric) -> integer
  # -->
  # Returns the integer square root of the non-negative integer `n`, which is the
  # largest non-negative integer less than or equal to the square root of
  # `numeric`.
  #
  #     Integer.sqrt(0)       # => 0
  #     Integer.sqrt(1)       # => 1
  #     Integer.sqrt(24)      # => 4
  #     Integer.sqrt(25)      # => 5
  #     Integer.sqrt(10**400) # => 10**200
  #
  # If `numeric` is not an Integer, it is converted to an Integer:
  #
  #     Integer.sqrt(Complex(4, 0))  # => 2
  #     Integer.sqrt(Rational(4, 1)) # => 2
  #     Integer.sqrt(4.0)            # => 2
  #     Integer.sqrt(3.14159)        # => 1
  #
  # This method is equivalent to `Math.sqrt(numeric).floor`, except that the
  # result of the latter code may differ from the true value due to the limited
  # precision of floating point arithmetic.
  #
  #     Integer.sqrt(10**46)    # => 100000000000000000000000
  #     Math.sqrt(10**46).floor # => 99999999999999991611392
  #
  # Raises an exception if `numeric` is negative.
  #
  def self.sqrt: (int n) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - Integer.try_convert(object) -> object, integer, or nil
  # -->
  # If `object` is an Integer object, returns `object`.
  #     Integer.try_convert(1) # => 1
  #
  # Otherwise if `object` responds to `:to_int`, calls `object.to_int` and returns
  # the result.
  #     Integer.try_convert(1.25) # => 1
  #
  # Returns `nil` if `object` does not respond to `:to_int`
  #     Integer.try_convert([]) # => nil
  #
  # Raises an exception unless `object.to_int` returns an Integer object.
  #
  def self.try_convert: (int) -> Integer
                      | (untyped) -> Integer?

  public

  # <!--
  #   rdoc-file=numeric.c
  #   - self % other -> real_number
  # -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  # Integer#modulo is an alias for Integer#%.
  #
  def %: (Float) -> Float
       | (Rational) -> Rational
       | (Integer) -> Integer
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - self & other ->  integer
  # -->
  # Bitwise AND; each bit in the result is 1 if both corresponding bits in `self`
  # and `other` are 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 & 0b0110) # => "0100"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#| (bitwise OR), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def &: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self * numeric -> numeric_result
  # -->
  # Performs multiplication:
  #
  #     4 * 2              # => 8
  #     4 * -2             # => -8
  #     -4 * 2             # => -8
  #     4 * 2.0            # => 8.0
  #     4 * Rational(1, 3) # => (4/3)
  #     4 * Complex(2, 0)  # => (8+0i)
  #
  def *: (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex
       | (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ** numeric -> numeric_result
  # -->
  # Raises `self` to the power of `numeric`:
  #
  #     2 ** 3              # => 8
  #     2 ** -3             # => (1/8)
  #     -2 ** 3             # => -8
  #     -2 ** -3            # => (-1/8)
  #     2 ** 3.3            # => 9.849155306759329
  #     2 ** Rational(3, 1) # => (8/1)
  #     2 ** Complex(3, 0)  # => (8+0i)
  #
  def **: (Integer) -> Numeric
        | (Float) -> Numeric
        | (Rational) -> Numeric
        | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self + numeric -> numeric_result
  # -->
  # Performs addition:
  #
  #     2 + 2              # => 4
  #     -2 + 2             # => 0
  #     -2 + -2            # => -4
  #     2 + 2.0            # => 4.0
  #     2 + Rational(2, 1) # => (4/1)
  #     2 + Complex(2, 0)  # => (4+0i)
  #
  def +: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  def +@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self - numeric -> numeric_result
  # -->
  # Performs subtraction:
  #
  #     4 - 2              # => 2
  #     -4 - 2             # => -6
  #     -4 - -2            # => -2
  #     4 - 2.0            # => 2.0
  #     4 - Rational(2, 1) # => (2/1)
  #     4 - Complex(2, 0)  # => (2+0i)
  #
  def -: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.rb
  #   - -int  ->  integer
  # -->
  # Returns `int`, negated.
  #
  def -@: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self / numeric -> numeric_result
  # -->
  # Performs division; for integer `numeric`, truncates the result to an integer:
  #
  #      4 / 3              # => 1
  #      4 / -3             # => -2
  #      -4 / 3             # => -2
  #      -4 / -3            # => 1
  #
  #     For other +numeric+, returns non-integer result:
  #
  #      4 / 3.0            # => 1.3333333333333333
  #      4 / Rational(3, 1) # => (4/3)
  #      4 / Complex(3, 0)  # => ((4/3)+0i)
  #
  def /: (Integer) -> Integer
       | (Float) -> Float
       | (Rational) -> Rational
       | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if the value of `self` is less than that of `other`:
  #
  #       1 < 0              # => false
  #       1 < 1              # => false
  #       1 < 2              # => true
  #       1 < 0.5            # => false
  #       1 < Rational(1, 2) # => false
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self << count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the left, or to the
  # right if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n << 1)  # => "111100000"
  #     "%08b" % (n << 3)  # => "11110000000"
  #     "%08b" % (n << -1) # => "01111000"
  #     "%08b" % (n << -3) # => "00011110"
  #
  # Related: Integer#>>.
  #
  def <<: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self <= real -> true or false
  # -->
  # Returns `true` if the value of `self` is less than or equal to that of
  # `other`:
  #
  #     1 <= 0              # => false
  #     1 <= 1              # => true
  #     1 <= 2              # => true
  #     1 <= 0.5            # => false
  #     1 <= Rational(1, 2) # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self <=> other  ->  -1, 0, +1, or nil
  # -->
  # Returns:
  #
  # *   -1, if `self` is less than `other`.
  # *   0, if `self` is equal to `other`.
  # *   1, if `self` is greater then `other`.
  # *   `nil`, if `self` and `other` are incomparable.
  #
  #
  # Examples:
  #
  #     1 <=> 2              # => -1
  #     1 <=> 1              # => 0
  #     1 <=> 0              # => 1
  #     1 <=> 'foo'          # => nil
  #
  #     1 <=> 1.0            # => 0
  #     1 <=> Rational(1, 1) # => 0
  #     1 <=> Complex(1, 0)  # => 0
  #
  # This method is the basis for comparisons in module Comparable.
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  # Integer#=== is an alias for Integer#==.
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self == other -> true or false
  # -->
  # Returns `true` if `self` is numerically equal to `other`; `false` otherwise.
  #
  #     1 == 2     #=> false
  #     1 == 1.0   #=> true
  #
  # Related: Integer#eql? (requires `other` to be an Integer).
  #
  # Integer#=== is an alias for Integer#==.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than that of `other`:
  #
  #       1 > 0              # => true
  #       1 > 1              # => false
  #       1 > 2              # => false
  #       1 > 0.5            # => true
  #       1 > Rational(1, 2) # => true
  #
  #     Raises an exception if the comparison cannot be made.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >= real -> true or false
  # -->
  # Returns `true` if the value of `self` is greater than or equal to that of
  # `other`:
  #
  #     1 >= 0              # => true
  #     1 >= 1              # => true
  #     1 >= 2              # => false
  #     1 >= 0.5            # => true
  #     1 >= Rational(1, 2) # => true
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self >> count -> integer
  # -->
  # Returns `self` with bits shifted `count` positions to the right, or to the
  # left if `count` is negative:
  #
  #     n = 0b11110000
  #     "%08b" % (n >> 1)  # => "01111000"
  #     "%08b" % (n >> 3)  # => "00011110"
  #     "%08b" % (n >> -1) # => "111100000"
  #     "%08b" % (n >> -3) # => "11110000000"
  #
  # Related: Integer#<<.
  #
  def >>: (int) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self[offset]    -> 0 or 1
  #   - self[offset, size] -> integer
  #   - self[range] -> integer
  # -->
  # Returns a slice of bits from `self`.
  #
  # With argument `offset`, returns the bit at the given offset, where offset 0
  # refers to the least significant bit:
  #
  #     n = 0b10 # => 2
  #     n[0]     # => 0
  #     n[1]     # => 1
  #     n[2]     # => 0
  #     n[3]     # => 0
  #
  # In principle, `n[i]` is equivalent to `(n >> i) & 1`. Thus, negative index
  # always returns zero:
  #
  #     255[-1] # => 0
  #
  # With arguments `offset` and `size`, returns `size` bits from `self`, beginning
  # at `offset` and including bits of greater significance:
  #
  #     n = 0b111000       # => 56
  #     "%010b" % n[0, 10] # => "0000111000"
  #     "%010b" % n[4, 10] # => "0000000011"
  #
  # With argument `range`, returns `range.size` bits from `self`, beginning at
  # `range.begin` and including bits of greater significance:
  #
  #     n = 0b111000      # => 56
  #     "%010b" % n[0..9] # => "0000111000"
  #     "%010b" % n[4..9] # => "0000000011"
  #
  # Raises an exception if the slice cannot be constructed.
  #
  def []: (int) -> Integer
        | (int i, int len) -> Integer
        | (Range[int]) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - self ^ other -> integer
  # -->
  # Bitwise EXCLUSIVE OR; each bit in the result is 1 if the corresponding bits in
  # `self` and `other` are different, 0 otherwise:
  #
  #     "%04b" % (0b0101 ^ 0b0110) # => "0011"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#| (bitwise OR).
  #
  def ^: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.abs        ->  integer
  #   - int.magnitude  ->  integer
  # -->
  # Returns the absolute value of `int`.
  #
  #     (-12345).abs   #=> 12345
  #     -12345.abs     #=> 12345
  #     12345.abs      #=> 12345
  #
  # Integer#magnitude is an alias for Integer#abs.
  #
  def abs: () -> Integer

  def abs2: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - allbits?(mask) -> true or false
  # -->
  # Returns `true` if all bits that are set (=1) in `mask` are also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b1010101  self
  #     0b1010100  mask
  #     0b1010100  self & mask
  #          true  self.allbits?(mask)
  #
  #     0b1010100  self
  #     0b1010101  mask
  #     0b1010100  self & mask
  #         false  self.allbits?(mask)
  #
  # Related: Integer#anybits?, Integer#nobits?.
  #
  def allbits?: (int mask) -> bool

  def angle: () -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - anybits?(mask) -> true or false
  # -->
  # Returns `true` if any bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b10000010  self
  #     0b11111111  mask
  #     0b10000010  self & mask
  #           true  self.anybits?(mask)
  #
  #     0b00000000  self
  #     0b11111111  mask
  #     0b00000000  self & mask
  #          false  self.anybits?(mask)
  #
  # Related: Integer#allbits?, Integer#nobits?.
  #
  def anybits?: (int mask) -> bool

  alias arg angle

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.bit_length  ->  integer
  # -->
  # Returns the number of bits of the value of `int`.
  #
  # "Number of bits" means the bit position of the highest bit which is different
  # from the sign bit (where the least significant bit has bit position 1). If
  # there is no such bit (zero or minus one), zero is returned.
  #
  # I.e. this method returns *ceil(log2(int < 0 ? -int : int+1))*.
  #
  #     (-2**1000-1).bit_length   #=> 1001
  #     (-2**1000).bit_length     #=> 1000
  #     (-2**1000+1).bit_length   #=> 1000
  #     (-2**12-1).bit_length     #=> 13
  #     (-2**12).bit_length       #=> 12
  #     (-2**12+1).bit_length     #=> 12
  #     -0x101.bit_length         #=> 9
  #     -0x100.bit_length         #=> 8
  #     -0xff.bit_length          #=> 8
  #     -2.bit_length             #=> 1
  #     -1.bit_length             #=> 0
  #     0.bit_length              #=> 0
  #     1.bit_length              #=> 1
  #     0xff.bit_length           #=> 8
  #     0x100.bit_length          #=> 9
  #     (2**12-1).bit_length      #=> 12
  #     (2**12).bit_length        #=> 13
  #     (2**12+1).bit_length      #=> 13
  #     (2**1000-1).bit_length    #=> 1000
  #     (2**1000).bit_length      #=> 1001
  #     (2**1000+1).bit_length    #=> 1001
  #
  # This method can be used to detect overflow in Array#pack as follows:
  #
  #     if n.bit_length < 32
  #       [n].pack("l") # no overflow
  #     else
  #       raise "overflow"
  #     end
  #
  def bit_length: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - ceil(ndigits = 0) -> integer
  # -->
  # Returns the smallest number greater than or equal to `self` with a precision
  # of `ndigits` decimal digits.
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros:
  #
  #     555.ceil(-1)  # => 560
  #     555.ceil(-2)  # => 600
  #     -555.ceil(-2) # => -500
  #     555.ceil(-3)  # => 1000
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.ceil     # => 555
  #     555.ceil(50) # => 555
  #
  # Related: Integer#floor.
  #
  def ceil: () -> Integer
          | (int digits) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.c
  #   - chr           -> string
  #   - chr(encoding) -> string
  # -->
  # Returns a 1-character string containing the character represented by the value
  # of `self`, according to the given `encoding`.
  #
  #     65.chr                   # => "A"
  #     0..chr                   # => "\x00"
  #     255.chr                  # => "\xFF"
  #     string = 255.chr(Encoding::UTF_8)
  #     string.encoding          # => Encoding::UTF_8
  #
  # Raises an exception if `self` is negative.
  #
  # Related: Integer#ord.
  #
  def chr: (?encoding) -> String

  # <!--
  #   rdoc-file=bignum.c
  #   - big.coerce(numeric)  ->  array
  # -->
  # Returns an array with both a `numeric` and a `big` represented as Bignum
  # objects.
  #
  # This is achieved by converting `numeric` to a Bignum.
  #
  # A TypeError is raised if the `numeric` is not a Fixnum or Bignum type.
  #
  #     (0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=> [42, 4611686018427387904]
  #
  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Integer

  def conjugate: () -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.denominator  ->  1
  # -->
  # Returns 1.
  #
  def denominator: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - digits(base = 10) -> array_of_integers
  # -->
  # Returns an array of integers representing the `base`-radix digits of `self`;
  # the first element of the array represents the least significant digit:
  #
  #     12345.digits      # => [5, 4, 3, 2, 1]
  #     12345.digits(7)   # => [4, 6, 6, 0, 5]
  #     12345.digits(100) # => [45, 23, 1]
  #
  # Raises an exception if `self` is negative or `base` is less than 2.
  #
  def digits: (?int base) -> ::Array[Integer]

  # <!--
  #   rdoc-file=numeric.c
  #   - div(numeric)  -> integer
  # -->
  # Performs integer division; returns the integer result of dividing `self` by
  # `numeric`:
  #
  #       4.div(3)      # => 1
  #       4.div(-3)      # => -2
  #       -4.div(3)      # => -2
  #       -4.div(-3)      # => 1
  #       4.div(3.0)      # => 1
  #       4.div(Rational(3, 1))      # => 1
  #
  #     Raises an exception if +numeric+ does not have method +div+.
  #
  def div: (Numeric) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - divmod(other) -> array
  # -->
  # Returns a 2-element array `[q, r]`, where
  #
  #     q = (self/other).floor    # Quotient
  #     r = self % other          # Remainder
  #
  # Examples:
  #
  #     11.divmod(4)              # => [2, 3]
  #     11.divmod(-4)             # => [-3, -1]
  #     -11.divmod(4)             # => [-3, 1]
  #     -11.divmod(-4)            # => [2, -3]
  #
  #     12.divmod(4)              # => [3, 0]
  #     12.divmod(-4)             # => [-3, 0]
  #     -12.divmod(4)             # => [-3, 0]
  #     -12.divmod(-4)            # => [3, 0]
  #
  #     13.divmod(4.0)            # => [3, 1.0]
  #     13.divmod(Rational(4, 1)) # => [3, (1/1)]
  #
  def divmod: (Integer) -> [ Integer, Integer ]
            | (Float) -> [ Float, Float ]
            | (Numeric) -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=numeric.c
  #   - downto(limit) {|i| ... } -> self
  #   - downto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` down to `limit`;
  # returns `self`:
  #
  #     a = []
  #     10.downto(5) {|i| a << i }              # => 10
  #     a                                       # => [10, 9, 8, 7, 6, 5]
  #     a = []
  #     0.downto(-5) {|i| a << i }              # => 0
  #     a                                       # => [0, -1, -2, -3, -4, -5]
  #     4.downto(5) {|i| fail 'Cannot happen' } # => 4
  #
  # With no block given, returns an Enumerator.
  #
  def downto: (Integer limit) { (Integer) -> void } -> Integer
            | (Integer limit) -> ::Enumerator[Integer, self]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.even?  ->  true or false
  # -->
  # Returns `true` if `int` is an even number.
  #
  def even?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - fdiv(numeric) -> float
  # -->
  # Returns the Float result of dividing `self` by `numeric`:
  #
  #     4.fdiv(2)      # => 2.0
  #     4.fdiv(-2)      # => -2.0
  #     -4.fdiv(2)      # => -2.0
  #     4.fdiv(2.0)      # => 2.0
  #     4.fdiv(Rational(3, 4))      # => 5.333333333333333
  #
  # Raises an exception if `numeric` cannot be converted to a Float.
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - floor(ndigits = 0) -> integer
  # -->
  # Returns the largest number less than or equal to `self` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.floor(-1)  # => 550
  #     555.floor(-2)  # => 500
  #     -555.floor(-2) # => -600
  #     555.floor(-3)  # => 0
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.floor     # => 555
  #     555.floor(50) # => 555
  #
  # Related: Integer#ceil.
  #
  def floor: (?int digits) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcd(other_int)  ->  integer
  # -->
  # Returns the greatest common divisor of the two integers. The result is always
  # positive. 0.gcd(x) and x.gcd(0) return x.abs.
  #
  #     36.gcd(60)                  #=> 12
  #     2.gcd(2)                    #=> 2
  #     3.gcd(-7)                   #=> 1
  #     ((1<<31)-1).gcd((1<<61)-1)  #=> 1
  #
  def gcd: (Integer) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - int.gcdlcm(other_int)  ->  array
  # -->
  # Returns an array with the greatest common divisor and the least common
  # multiple of the two integers, [gcd, lcm].
  #
  #     36.gcdlcm(60)                  #=> [12, 180]
  #     2.gcdlcm(2)                    #=> [2, 2]
  #     3.gcdlcm(-7)                   #=> [1, 21]
  #     ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]
  #
  def gcdlcm: (Integer) -> [ Integer, Integer ]

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!-- rdoc-file=numeric.c -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  # Integer#inspect is an alias for Integer#to_s.
  #
  alias inspect to_s

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.integer?  ->  true
  # -->
  # Since `int` is already an Integer, this always returns `true`.
  #
  def integer?: () -> true

  # <!--
  #   rdoc-file=rational.c
  #   - int.lcm(other_int)  ->  integer
  # -->
  # Returns the least common multiple of the two integers. The result is always
  # positive. 0.lcm(x) and x.lcm(0) return zero.
  #
  #     36.lcm(60)                  #=> 180
  #     2.lcm(2)                    #=> 2
  #     3.lcm(-7)                   #=> 21
  #     ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297
  #
  def lcm: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - magnitude()
  # -->
  #
  def magnitude: () -> Integer

  # <!-- rdoc-file=numeric.c -->
  # Returns `self` modulo `other` as a real number.
  #
  # For integer `n` and real number `r`, these expressions are equivalent:
  #
  #     n % r
  #     n-r*(n/r).floor
  #     n.divmod(r)[1]
  #
  # See Numeric#divmod.
  #
  # Examples:
  #
  #     10 % 2              # => 0
  #     10 % 3              # => 1
  #     10 % 4              # => 2
  #
  #     10 % -2             # => 0
  #     10 % -3             # => -2
  #     10 % -4             # => -2
  #
  #     10 % 3.0            # => 1.0
  #     10 % Rational(3, 1) # => (1/1)
  #
  # Integer#modulo is an alias for Integer#%.
  #
  alias modulo %

  def negative?: () -> bool

  # <!-- rdoc-file=numeric.c -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Integer#next is an alias for Integer#succ.
  #
  # Related: Integer#pred (predecessor value).
  #
  def next: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - nobits?(mask) -> true or false
  # -->
  # Returns `true` if no bit that is set (=1) in `mask` is also set in `self`;
  # returns `false` otherwise.
  #
  # Example values:
  #
  #     0b11110000  self
  #     0b00001111  mask
  #     0b00000000  self & mask
  #           true  self.nobits?(mask)
  #
  #     0b00000001  self
  #     0b11111111  mask
  #     0b00000001  self & mask
  #          false  self.nobits?(mask)
  #
  # Related: Integer#allbits?, Integer#anybits?.
  #
  def nobits?: (int mask) -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - int.numerator  ->  self
  # -->
  # Returns self.
  #
  def numerator: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.odd?  ->  true or false
  # -->
  # Returns `true` if `int` is an odd number.
  #
  def odd?: () -> bool

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.ord  ->  self
  # -->
  # Returns the `int` itself.
  #
  #     97.ord   #=> 97
  #
  # This method is intended for compatibility to character literals in Ruby 1.9.
  #
  # For example, `?a.ord` returns 97 both in 1.8 and 1.9.
  #
  def ord: () -> Integer

  alias phase angle

  def polar: () -> [ Integer, Integer | Float ]

  def positive?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - integer.pow(numeric)           ->  numeric
  #   - integer.pow(integer, integer)  ->  integer
  # -->
  # Returns (modular) exponentiation as:
  #
  #     a.pow(b)     #=> same as a**b
  #     a.pow(b, m)  #=> same as (a**b) % m, but avoids huge temporary values
  #
  def pow: (Integer other, ?Integer modulo) -> Integer
         | (Float) -> Float
         | (Rational) -> Rational
         | (Complex) -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - pred -> next_integer
  # -->
  # Returns the predecessor of `self` (equivalent to `self - 1`):
  #
  #     1.pred  #=> 0
  #     -1.pred #=> -2
  #
  # Related: Integer#succ (successor value).
  #
  def pred: () -> Integer

  def quo: (Integer) -> Rational
         | (Float) -> Float
         | (Rational) -> Rational
         | (Complex) -> Complex
         | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - int.rationalize([eps])  ->  rational
  # -->
  # Returns the value as a rational.  The optional argument `eps` is always
  # ignored.
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> self

  def real?: () -> true

  def rect: () -> [ Integer, Numeric ]

  alias rectangular rect

  # <!--
  #   rdoc-file=numeric.c
  #   - remainder(other) -> real_number
  # -->
  # Returns the remainder after dividing `self` by `other`.
  #
  # Examples:
  #
  #     11.remainder(4)              # => 3
  #     11.remainder(-4)             # => 3
  #     -11.remainder(4)             # => -3
  #     -11.remainder(-4)            # => -3
  #
  #     12.remainder(4)              # => 0
  #     12.remainder(-4)             # => 0
  #     -12.remainder(4)             # => 0
  #     -12.remainder(-4)            # => 0
  #
  #     13.remainder(4.0)            # => 1.0
  #     13.remainder(Rational(4, 1)) # => (1/1)
  #
  def remainder: (Integer) -> Integer
               | (Float) -> Float
               | (Rational) -> Rational
               | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=numeric.c
  #   - round(ndigits= 0, half: :up) -> integer
  # -->
  # Returns `self` rounded to the nearest value with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.round(-1)      # => 560
  #     555.round(-2)      # => 600
  #     555.round(-3)      # => 1000
  #     -555.round(-2)     # => -600
  #     555.round(-4)      # => 0
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.round     # => 555
  #     555.round(1)  # => 555
  #     555.round(50) # => 555
  #
  # If keyword argument `half` is given, and `self` is equidistant from the two
  # candidate  values, the rounding is according to the given `half` value:
  #
  # *   `:up` or `nil`: round away from zero:
  #
  #         25.round(-1, half: :up)      # => 30
  #         (-25).round(-1, half: :up)   # => -30
  #
  # *   `:down`: round toward zero:
  #
  #         25.round(-1, half: :down)    # => 20
  #         (-25).round(-1, half: :down) # => -20
  #
  # *   `:even`: round toward the candidate whose last nonzero digit is even:
  #
  #         25.round(-1, half: :even)    # => 20
  #         15.round(-1, half: :even)    # => 20
  #         (-25).round(-1, half: :even) # => -20
  #
  #
  # Raises and exception if the value for `half` is invalid.
  #
  # Related: Integer#truncate.
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (int digits, ?half: :up | :down | :even) -> (Integer | Float)

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.size  ->  int
  # -->
  # Document-method: Integer#size
  #
  # Returns the number of bytes in the machine representation of `int` (machine
  # dependent).
  #
  #     1.size               #=> 8
  #     -1.size              #=> 8
  #     2147483647.size      #=> 8
  #     (256**10 - 1).size   #=> 10
  #     (256**20 - 1).size   #=> 20
  #     (256**40 - 1).size   #=> 40
  #
  def size: () -> Integer

  def step: () { (Integer) -> void } -> void
          | (Numeric limit, ?Integer step) { (Integer) -> void } -> void
          | (Numeric limit, ?Numeric step) { (Numeric) -> void } -> void
          | (to: Numeric, ?by: Integer) { (Integer) -> void } -> void
          | (by: Numeric, ?to: Numeric) { (Numeric) -> void } -> void
          | () -> Enumerator[Integer, bot]
          | (Numeric limit, ?Integer step) -> Enumerator[Integer, void]
          | (Numeric limit, ?Numeric step) -> Enumerator[Numeric, void]
          | (to: Numeric, ?by: Integer) -> Enumerator[Integer, void]
          | (by: Numeric, ?to: Numeric) -> Enumerator[Numeric, void]

  # <!--
  #   rdoc-file=numeric.c
  #   - succ -> next_integer
  # -->
  # Returns the successor integer of `self` (equivalent to `self + 1`):
  #
  #     1.succ  #=> 2
  #     -1.succ #=> 0
  #
  # Integer#next is an alias for Integer#succ.
  #
  # Related: Integer#pred (predecessor value).
  #
  def succ: () -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - times {|i| ... } -> self
  #   - times            -> enumerator
  # -->
  # Calls the given block `self` times with each integer in `(0..self-1)`:
  #
  #     a = []
  #     5.times {|i| a.push(i) } # => 5
  #     a                        # => [0, 1, 2, 3, 4]
  #
  # With no block given, returns an Enumerator.
  #
  def times: () { (Integer) -> void } -> self
           | () -> ::Enumerator[Integer, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=numeric.c
  #   - to_f -> float
  # -->
  # Converts `self` to a Float:
  #
  #     1.to_f  # => 1.0
  #     -1.to_f # => -1.0
  #
  # If the value of `self` does not fit in a Float, the result is infinity:
  #
  #     (10**400).to_f  # => Infinity
  #     (-10**400).to_f # => -Infinity
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.to_i    ->  integer
  # -->
  # Since `int` is already an Integer, returns `self`.
  #
  # #to_int is an alias for #to_i.
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.to_int  ->  integer
  # -->
  # Since `int` is already an Integer, returns `self`.
  #
  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - int.to_r  ->  rational
  # -->
  # Returns the value as a rational.
  #
  #     1.to_r        #=> (1/1)
  #     (1<<64).to_r  #=> (18446744073709551616/1)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=numeric.c
  #   - to_s(base = 10)  ->  string
  # -->
  # Returns a string containing the place-value representation of `self` in radix
  # `base` (in 2..36).
  #
  #     12345.to_s               # => "12345"
  #     12345.to_s(2)            # => "11000000111001"
  #     12345.to_s(8)            # => "30071"
  #     12345.to_s(10)           # => "12345"
  #     12345.to_s(16)           # => "3039"
  #     12345.to_s(36)           # => "9ix"
  #     78546939656932.to_s(36)  # => "rubyrules"
  #
  # Raises an exception if `base` is out of range.
  #
  # Integer#inspect is an alias for Integer#to_s.
  #
  def to_s: () -> String
          | (2) -> String
          | (3) -> String
          | (4) -> String
          | (5) -> String
          | (6) -> String
          | (7) -> String
          | (8) -> String
          | (9) -> String
          | (10) -> String
          | (11) -> String
          | (12) -> String
          | (13) -> String
          | (14) -> String
          | (15) -> String
          | (16) -> String
          | (17) -> String
          | (18) -> String
          | (19) -> String
          | (20) -> String
          | (21) -> String
          | (22) -> String
          | (23) -> String
          | (24) -> String
          | (25) -> String
          | (26) -> String
          | (27) -> String
          | (28) -> String
          | (29) -> String
          | (30) -> String
          | (31) -> String
          | (32) -> String
          | (33) -> String
          | (34) -> String
          | (35) -> String
          | (36) -> String
          | (int base) -> String

  # <!--
  #   rdoc-file=numeric.c
  #   - truncate(ndigits = 0) -> integer
  # -->
  # Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
  # digits.
  #
  # When `ndigits` is negative, the returned value has at least `ndigits.abs`
  # trailing zeros:
  #
  #     555.truncate(-1)  # => 550
  #     555.truncate(-2)  # => 500
  #     -555.truncate(-2) # => -500
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  #     555.truncate     # => 555
  #     555.truncate(50) # => 555
  #
  # Related: Integer#round.
  #
  def truncate: () -> Integer
              | (int ndigits) -> Integer

  # <!--
  #   rdoc-file=numeric.c
  #   - upto(limit) {|i| ... } -> self
  #   - upto(limit)            ->  enumerator
  # -->
  # Calls the given block with each integer value from `self` up to `limit`;
  # returns `self`:
  #
  #     a = []
  #     5.upto(10) {|i| a << i }              # => 5
  #     a                                     # => [5, 6, 7, 8, 9, 10]
  #     a = []
  #     -5.upto(0) {|i| a << i }              # => -5
  #     a                                     # => [-5, -4, -3, -2, -1, 0]
  #     5.upto(4) {|i| fail 'Cannot happen' } # => 5
  #
  # With no block given, returns an Enumerator.
  #
  def upto: (Integer limit) { (Integer) -> void } -> Integer
          | (Integer limit) -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=numeric.rb
  #   - int.zero? -> true or false
  # -->
  # Returns `true` if `int` has a zero value.
  #
  def zero?: () -> bool

  # <!--
  #   rdoc-file=numeric.c
  #   - self | other -> integer
  # -->
  # Bitwise OR; each bit in the result is 1 if either corresponding bit in `self`
  # or `other` is 1, 0 otherwise:
  #
  #     "%04b" % (0b0101 | 0b0110) # => "0111"
  #
  # Raises an exception if `other` is not an Integer.
  #
  # Related: Integer#& (bitwise AND), Integer#^ (bitwise EXCLUSIVE OR).
  #
  def |: (Integer) -> Integer

  # <!--
  #   rdoc-file=numeric.rb
  #   - ~int  ->  integer
  # -->
  # One's complement: returns a number where each bit is flipped.
  #
  # Inverts the bits in an Integer. As integers are conceptually of infinite
  # length, the result acts as if it had an infinite number of one bits to the
  # left. In hex representations, this is displayed as two periods to the left of
  # the digits.
  #
  #     sprintf("%X", ~0x1122334455)    #=> "..FEEDDCCBBAA"
  #
  def ~: () -> Integer
end

# <!-- rdoc-file=object.c -->
# The class of the singleton object `nil`.
#
class NilClass
  public

  # <!--
  #   rdoc-file=object.c
  #   - false & obj   -> false
  #   - nil & obj     -> false
  # -->
  # And---Returns `false`. *obj* is always evaluated as it is the argument to a
  # method call---there is no short-circuit evaluation in this case.
  #
  def &: (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj === other   -> true or false
  # -->
  # Case Equality -- For class Object, effectively the same as calling `#==`, but
  # typically overridden by descendants to provide meaningful semantics in `case`
  # statements.
  #
  def ===: (nil) -> true
         | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - nil =~ other  -> nil
  # -->
  # Dummy pattern matching -- always returns nil.
  #
  def =~: (untyped obj) -> nil

  # <!--
  #   rdoc-file=object.c
  #   - false ^ obj    -> true or false
  #   - nil   ^ obj    -> true or false
  # -->
  # Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
  # returns `true`.
  #
  def ^: (nil) -> false
       | (false) -> false
       | (untyped obj) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - nil.inspect  -> "nil"
  # -->
  # Always returns the string "nil".
  #
  def inspect: () -> "nil"

  # <!--
  #   rdoc-file=object.c
  #   - nil.nil?               -> true
  # -->
  # Only the object *nil* responds `true` to `nil?`.
  #
  def nil?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - nil.rationalize([eps])  ->  (0/1)
  # -->
  # Returns zero as a rational.  The optional argument `eps` is always ignored.
  #
  def rationalize: (?untyped eps) -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_a    -> []
  # -->
  # Always returns an empty array.
  #
  #     nil.to_a   #=> []
  #
  def to_a: () -> [ ]

  # <!--
  #   rdoc-file=complex.c
  #   - nil.to_c  ->  (0+0i)
  # -->
  # Returns zero as a complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_f    -> 0.0
  # -->
  # Always returns zero.
  #
  #     nil.to_f   #=> 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_h    -> {}
  # -->
  # Always returns an empty hash.
  #
  #     nil.to_h   #=> {}
  #
  def to_h: () -> ::Hash[untyped, untyped]

  # <!--
  #   rdoc-file=nilclass.rb
  #   - nil.to_i -> 0
  # -->
  # Always returns zero.
  #
  #     nil.to_i   #=> 0
  #
  def to_i: () -> 0

  # <!--
  #   rdoc-file=rational.c
  #   - nil.to_r  ->  (0/1)
  # -->
  # Returns zero as a rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - nil.to_s    -> ""
  # -->
  # Always returns the empty string.
  #
  def to_s: () -> ""

  # <!--
  #   rdoc-file=object.c
  #   - false | obj   ->   true or false
  #   - nil   | obj   ->   true or false
  # -->
  # Or---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.
  #
  def |: (nil) -> false
       | (false) -> false
       | (untyped obj) -> bool

  def clone: (?freeze: true?) -> self
end

# <!-- rdoc-file=error.c -->
# Raised when the arguments are wrong and there isn't a more specific Exception
# class.
#
# Ex: passing the wrong number of arguments
#
#     [1, 2, 3].first(4, 5)
#
# *raises the exception:*
#
#     ArgumentError: wrong number of arguments (given 2, expected 1)
#
# Ex: passing an argument that is not acceptable:
#
#     [1, 2, 3].first(-4)
#
# *raises the exception:*
#
#     ArgumentError: negative array size
#
class ArgumentError < StandardError
end

# <!-- rdoc-file=thread_sync.c -->
# The exception class which will be raised when pushing into a closed Queue.
# See Thread::Queue#close and Thread::SizedQueue#close.
#
class ClosedQueueError < StopIteration
end

# <!-- rdoc-file=error.c -->
# EncodingError is the base class for encoding errors.
#
class EncodingError < StandardError
end

# <!-- rdoc-file=io.c -->
# Raised by some IO operations when reaching the end of file. Many IO methods
# exist in two forms,
#
# one that returns `nil` when the end of file is reached, the other raises
# `EOFError`.
#
# `EOFError` is a subclass of `IOError`.
#
#     file = File.open("/etc/hosts")
#     file.read
#     file.gets     #=> nil
#     file.readline #=> EOFError: end of file reached
#
class EOFError < IOError
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to convert special float values (in particular
# `Infinity` or `NaN`) to numerical classes which don't support them.
#
#     Float::INFINITY.to_r   #=> FloatDomainError: Infinity
#
class FloatDomainError < RangeError
end

# <!-- rdoc-file=error.c -->
# Raised when there is an attempt to modify a frozen object.
#
#     [1, 2, 3].freeze << 4
#
# *raises the exception:*
#
#     FrozenError: can't modify frozen Array
#
class FrozenError[T] < RuntimeError
  # <!--
  #   rdoc-file=error.c
  #   - FrozenError.new(msg=nil, receiver: nil)  -> frozen_error
  # -->
  # Construct a new FrozenError exception. If given the *receiver* parameter may
  # subsequently be examined using the FrozenError#receiver method.
  #
  #     a = [].freeze
  #     raise FrozenError.new("can't modify frozen array", receiver: a)
  #
  def initialize: (?string? msg, ?receiver: T?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - frozen_error.receiver  -> object
  # -->
  # Return the receiver associated with this FrozenError exception.
  #
  def receiver: () -> T?
end

# <!-- rdoc-file=error.c -->
# Raised when the given index is invalid.
#
#     a = [:foo, :bar]
#     a.fetch(0)   #=> :foo
#     a[4]         #=> nil
#     a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2
#
class IndexError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the interrupt signal is received, typically because the user has
# pressed Control-C (on most posix platforms). As such, it is a subclass of
# `SignalException`.
#
#     begin
#       puts "Press ctrl-C when you get bored"
#       loop {}
#     rescue Interrupt => e
#       puts "Note: You will typically use Signal.trap instead."
#     end
#
# *produces:*
#
#     Press ctrl-C when you get bored
#
# *then waits until it is interrupted with Control-C and then prints:*
#
#     Note: You will typically use Signal.trap instead.
#
class Interrupt < SignalException
  def initialize: (?string) -> void
end

# <!-- rdoc-file=io.c -->
# Raised when an IO operation fails.
#
#     File.open("/etc/hosts") {|f| f << "example"}
#       #=> IOError: not opened for writing
#
#     File.open("/etc/hosts") {|f| f.close; f.read }
#       #=> IOError: closed stream
#
# Note that some IO failures raise `SystemCallError`s and these are not
# subclasses of IOError:
#
#     File.open("does/not/exist")
#       #=> Errno::ENOENT: No such file or directory - does/not/exist
#
class IOError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when the specified key is not found. It is a subclass of IndexError.
#
#     h = {"foo" => :bar}
#     h.fetch("foo") #=> :bar
#     h.fetch("baz") #=> KeyError: key not found: "baz"
#
class KeyError[K, R] < IndexError
  # <!--
  #   rdoc-file=error.c
  #   - KeyError.new(message=nil, receiver: nil, key: nil) -> key_error
  # -->
  # Construct a new `KeyError` exception with the given message, receiver and key.
  #
  def initialize: (?string msg, ?receiver: R?, ?key: K?) -> void

  # <!--
  #   rdoc-file=error.c
  #   - key_error.key  -> object
  # -->
  # Return the key caused this KeyError exception.
  #
  def key: () -> K?

  # <!--
  #   rdoc-file=error.c
  #   - key_error.receiver  -> object
  # -->
  # Return the receiver associated with this KeyError exception.
  #
  def receiver: () -> R?
end

# <!-- rdoc-file=error.c -->
# Raised when a file required (a Ruby script, extension library, ...) fails to
# load.
#
#     require 'this/file/does/not/exist'
#
# *raises the exception:*
#
#     LoadError: no such file to load -- this/file/does/not/exist
#
class LoadError < ScriptError
  # <!-- rdoc-file=error.c -->
  # the path failed to load
  #
  def path: () -> String?
end

# <!-- rdoc-file=proc.c -->
# Raised when Ruby can't yield as requested.
#
# A typical scenario is attempting to yield when no block is given:
#
#     def call_block
#       yield 42
#     end
#     call_block
#
# *raises the exception:*
#
#     LocalJumpError: no block given (yield)
#
# A more subtle example:
#
#     def get_me_a_return
#       Proc.new { return 42 }
#     end
#     get_me_a_return.call
#
# *raises the exception:*
#
#     LocalJumpError: unexpected return
#
class LocalJumpError < StandardError
  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.exit_value  -> obj
  # -->
  # Returns the exit value associated with this `LocalJumpError`.
  #
  def exit_value: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - local_jump_error.reason   -> symbol
  # -->
  # The reason this block was terminated: :break, :redo, :retry, :next, :return,
  # or :noreason.
  #
  def reason: () -> Symbol
end

# <!-- rdoc-file=error.c -->
# Raised when a given name is invalid or undefined.
#
#     puts foo
#
# *raises the exception:*
#
#     NameError: undefined local variable or method `foo' for main:Object
#
# Since constant names must start with a capital:
#
#     Integer.const_set :answer, 42
#
# *raises the exception:*
#
#     NameError: wrong constant name answer
#
class NameError[T] < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - NameError.new(msg=nil, name=nil, receiver: nil)  -> name_error
  # -->
  # Construct a new NameError exception. If given the *name* parameter may
  # subsequently be examined using the NameError#name method. *receiver* parameter
  # allows to pass object in context of which the error happened. Example:
  #
  #     [1, 2, 3].method(:rject) # NameError with name "rject" and receiver: Array
  #     [1, 2, 3].singleton_method(:rject) # NameError with name "rject" and receiver: [1, 2, 3]
  #
  def initialize: (?string msg, ?String? name, ?receiver: T?) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - name_error.local_variables  ->  array
  # -->
  # Return a list of the local variable names defined where this NameError
  # exception was raised.
  #
  # Internal use only.
  #
  def local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=error.c
  #   - name_error.name    ->  string or nil
  # -->
  # Return the name associated with this NameError exception.
  #
  def name: () -> String?

  # <!--
  #   rdoc-file=error.c
  #   - name_error.receiver  -> object
  # -->
  # Return the receiver associated with this NameError exception.
  #
  def receiver: () -> T?
end

# <!-- rdoc-file=error.c -->
# Raised when memory allocation fails.
#
class NoMemoryError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a method is called on a receiver which doesn't have it defined and
# also fails to respond with `method_missing`.
#
#     "hello".to_ary
#
# *raises the exception:*
#
#     NoMethodError: undefined method `to_ary' for "hello":String
#
class NoMethodError[T] < NameError[T]
  # <!--
  #   rdoc-file=error.c
  #   - NoMethodError.new(msg=nil, name=nil, args=nil, private=false, receiver: nil)  -> no_method_error
  # -->
  # Construct a NoMethodError exception for a method of the given name called with
  # the given arguments. The name may be accessed using the `#name` method on the
  # resulting object, and the arguments using the `#args` method.
  #
  # If *private* argument were passed, it designates method was attempted to call
  # in private context, and can be accessed with `#private_call?` method.
  #
  # *receiver* argument stores an object whose method was called.
  #
  def initialize: (?string? msg, ?String? name, ?Array[untyped] args, ?boolish `private`, ?receiver: T?) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.args  -> obj
  # -->
  # Return the arguments passed in as the third parameter to the constructor.
  #
  def args: () -> Array[untyped]

  # <!--
  #   rdoc-file=error.c
  #   - no_method_error.private_call?  -> true or false
  # -->
  # Return true if the caused method was called as private.
  #
  def private_call?: () -> bool
end

# <!-- rdoc-file=error.c -->
# Raised when a feature is not implemented on the current platform. For example,
# methods depending on the `fsync` or `fork` system calls may raise this
# exception if the underlying operating system or Ruby runtime does not support
# them.
#
# Note that if `fork` raises a `NotImplementedError`, then `respond_to?(:fork)`
# returns `false`.
#
class NotImplementedError < ScriptError
end

# <!-- rdoc-file=error.c -->
# Raised when a given numerical value is out of range.
#
#     [1, 2, 3].drop(1 << 100)
#
# *raises the exception:*
#
#     RangeError: bignum too big to convert into `long'
#
class RangeError < StandardError
end

# <!-- rdoc-file=re.c -->
# Raised when given an invalid regexp expression.
#
#     Regexp.new("?")
#
# *raises the exception:*
#
#     RegexpError: target of repeat operator is not specified: /?/
#
class RegexpError < StandardError
end

# <!-- rdoc-file=error.c -->
# A generic error class raised when an invalid operation is attempted.
# Kernel#raise will raise a RuntimeError if no Exception class is specified.
#
#     raise "ouch"
#
# *raises the exception:*
#
#     RuntimeError: ouch
#
class RuntimeError < StandardError
end

# <!-- rdoc-file=error.c -->
# ScriptError is the superclass for errors raised when a script can not be
# executed because of a `LoadError`, `NotImplementedError` or a `SyntaxError`.
# Note these type of `ScriptErrors` are not `StandardError` and will not be
# rescued unless it is specified explicitly (or its ancestor `Exception`).
#
class ScriptError < Exception
end

# <!-- rdoc-file=error.c -->
# No longer used by internal code.
#
class SecurityError < Exception
end

# <!-- rdoc-file=error.c -->
# Raised when a signal is received.
#
#     begin
#       Process.kill('HUP',Process.pid)
#       sleep # wait for receiver to handle signal sent by Process.kill
#     rescue SignalException => e
#       puts "received Exception #{e}"
#     end
#
# *produces:*
#
#     received Exception SIGHUP
#
class SignalException < Exception
  # <!--
  #   rdoc-file=signal.c
  #   - SignalException.new(sig_name)              ->  signal_exception
  #   - SignalException.new(sig_number [, name])   ->  signal_exception
  # -->
  # Construct a new SignalException object.  `sig_name` should be a known signal
  # name.
  #
  def initialize: (?string sig_name) -> void
                | (int sig_number, ?string sig_name) -> void

  public

  def signm: () -> String

  # <!--
  #   rdoc-file=signal.c
  #   - signal_exception.signo   ->  num
  # -->
  # Returns a signal number.
  #
  def signo: () -> Integer
end

# <!-- rdoc-file=error.c -->
# The most standard error types are subclasses of StandardError. A rescue clause
# without an explicit Exception class will rescue all StandardErrors (and only
# those).
#
#     def foo
#       raise "Oups"
#     end
#     foo rescue "Hello"   #=> "Hello"
#
# On the other hand:
#
#     require 'does/not/exist' rescue "Hi"
#
# *raises the exception:*
#
#     LoadError: no such file to load -- does/not/exist
#
class StandardError < Exception
end

# <!-- rdoc-file=enumerator.c -->
# Raised to stop the iteration, in particular by Enumerator#next. It is rescued
# by Kernel#loop.
#
#     loop do
#       puts "Hello"
#       raise StopIteration
#       puts "World"
#     end
#     puts "Done!"
#
# *produces:*
#
#     Hello
#     Done!
#
class StopIteration < IndexError
  # <!--
  #   rdoc-file=enumerator.c
  #   - result       -> value
  # -->
  # Returns the return value of the iterator.
  #
  #     o = Object.new
  #     def o.each
  #       yield 1
  #       yield 2
  #       yield 3
  #       100
  #     end
  #
  #     e = o.to_enum
  #
  #     puts e.next                   #=> 1
  #     puts e.next                   #=> 2
  #     puts e.next                   #=> 3
  #
  #     begin
  #       e.next
  #     rescue StopIteration => ex
  #       puts ex.result              #=> 100
  #     end
  #
  def result: () -> untyped
end

# <!-- rdoc-file=error.c -->
# Raised when encountering Ruby code with an invalid syntax.
#
#     eval("1+1=2")
#
# *raises the exception:*
#
#     SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end
#
class SyntaxError < ScriptError
  # <!--
  #   rdoc-file=error.c
  #   - SyntaxError.new([msg])  -> syntax_error
  # -->
  # Construct a SyntaxError exception.
  #
  def initialize: (?string msg) -> void
end

# <!-- rdoc-file=error.c -->
# SystemCallError is the base class for all low-level platform-dependent errors.
#
# The errors available on the current platform are subclasses of SystemCallError
# and are defined in the Errno module.
#
#     File.open("does/not/exist")
#
# *raises the exception:*
#
#     Errno::ENOENT: No such file or directory - does/not/exist
#
class SystemCallError < StandardError
  # <!--
  #   rdoc-file=error.c
  #   - SystemCallError.new(msg, errno)  -> system_call_error_subclass
  # -->
  # If *errno* corresponds to a known system error code, constructs the
  # appropriate Errno class for that error, otherwise constructs a generic
  # SystemCallError object. The error number is subsequently available via the
  # #errno method.
  #
  def initialize: (string msg, Integer errno) -> SystemCallError

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error === other  -> true or false
  # -->
  # Return `true` if the receiver is a generic `SystemCallError`, or if the error
  # numbers `self` and *other* are the same.
  #
  def self.===: (untyped other) -> bool

  public

  # <!--
  #   rdoc-file=error.c
  #   - system_call_error.errno   -> integer
  # -->
  # Return this SystemCallError's error number.
  #
  def errno: () -> Integer
end

# <!-- rdoc-file=error.c -->
# Raised by `exit` to initiate the termination of the script.
#
class SystemExit < Exception
  # <!--
  #   rdoc-file=error.c
  #   - SystemExit.new              -> system_exit
  #   - SystemExit.new(status)      -> system_exit
  #   - SystemExit.new(status, msg) -> system_exit
  #   - SystemExit.new(msg)         -> system_exit
  # -->
  # Create a new `SystemExit` exception with the given status and message. Status
  # is true, false, or an integer. If status is not given, true is used.
  #
  def initialize: () -> void
                | (string msg) -> void
                | (true | false | int status, ?string msg) -> void

  public

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.status   -> integer
  # -->
  # Return the status value associated with this system exit.
  #
  def status: () -> Integer

  # <!--
  #   rdoc-file=error.c
  #   - system_exit.success?  -> true or false
  # -->
  # Returns `true` if exiting successful, `false` if not.
  #
  def success?: () -> bool
end

# <!-- rdoc-file=proc.c -->
# Raised in case of a stack overflow.
#
#     def me_myself_and_i
#       me_myself_and_i
#     end
#     me_myself_and_i
#
# *raises the exception:*
#
#     SystemStackError: stack level too deep
#
class SystemStackError < Exception
end

# <!-- rdoc-file=thread.c -->
# Raised when an invalid operation is attempted on a thread.
#
# For example, when no other thread has been started:
#
#     Thread.stop
#
# This will raises the following exception:
#
#     ThreadError: stopping only thread
#     note: use sleep to stop forever
#
class ThreadError < StandardError
end

# <!-- rdoc-file=error.c -->
# Raised when encountering an object that is not of the expected type.
#
#     [1, 2, 3].first("two")
#
# *raises the exception:*
#
#     TypeError: no implicit conversion of String into Integer
#
class TypeError < StandardError
end

# <!-- rdoc-file=vm_eval.c -->
# Raised when `throw` is called with a *tag* which does not have corresponding
# `catch` block.
#
#     throw "foo", "bar"
#
# *raises the exception:*
#
#     UncaughtThrowError: uncaught throw "foo"
#
class UncaughtThrowError < ArgumentError
  # <!--
  #   rdoc-file=vm_eval.c
  #   - new(*args)
  # -->
  # Document-class: UncaughtThrowError
  #
  # Raised when `throw` is called with a *tag* which does not have corresponding
  # `catch` block.
  #
  #     throw "foo", "bar"
  #
  # *raises the exception:*
  #
  #     UncaughtThrowError: uncaught throw "foo"
  #
  def initialize: (untyped tag, untyped value) -> void

  public

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.tag   -> obj
  # -->
  # Return the tag object which was called for.
  #
  def tag: () -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.to_s   ->  string
  # -->
  # Returns formatted message with the inspected tag.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=vm_eval.c
  #   - uncaught_throw.value   -> obj
  # -->
  # Return the return value which was called for.
  #
  def value: () -> untyped
end

# <!-- rdoc-file=numeric.c -->
# Raised when attempting to divide an integer by 0.
#
#     42 / 0   #=> ZeroDivisionError: divided by 0
#
# Note that only division by an exact 0 will raise the exception:
#
#     42 /  0.0   #=> Float::INFINITY
#     42 / -0.0   #=> -Float::INFINITY
#     0  /  0.0   #=> NaN
#
class ZeroDivisionError < StandardError
end

# <!-- rdoc-file=cont.c -->
# Raised when an invalid operation is attempted on a Fiber, in particular when
# attempting to call/resume a dead fiber, attempting to yield from the root
# fiber, or calling a fiber across threads.
#
#     fiber = Fiber.new{}
#     fiber.resume #=> nil
#     fiber.resume #=> FiberError: dead fiber called
#
class FiberError < StandardError
end

# <!-- rdoc-file=vm.c -->
# Threads are the Ruby implementation for a concurrent programming model.
#
# Programs that require multiple threads of execution are a perfect candidate
# for Ruby's Thread class.
#
# For example, we can create a new thread separate from the main thread's
# execution using ::new.
#
#     thr = Thread.new { puts "What's the big deal" }
#
# Then we are able to pause the execution of the main thread and allow our new
# thread to finish, using #join:
#
#     thr.join #=> "What's the big deal"
#
# If we don't call `thr.join` before the main thread terminates, then all other
# threads including `thr` will be killed.
#
# Alternatively, you can use an array for handling multiple threads at once,
# like in the following example:
#
#     threads = []
#     threads << Thread.new { puts "What's the big deal" }
#     threads << Thread.new { 3.times { puts "Threads are fun!" } }
#
# After creating a few threads we wait for them all to finish consecutively.
#
#     threads.each { |thr| thr.join }
#
# To retrieve the last value of a thread, use #value
#
#     thr = Thread.new { sleep 1; "Useful value" }
#     thr.value #=> "Useful value"
#
# ### Thread initialization
#
# In order to create new threads, Ruby provides ::new, ::start, and ::fork. A
# block must be provided with each of these methods, otherwise a ThreadError
# will be raised.
#
# When subclassing the Thread class, the `initialize` method of your subclass
# will be ignored by ::start and ::fork. Otherwise, be sure to call super in
# your `initialize` method.
#
# ### Thread termination
#
# For terminating threads, Ruby provides a variety of ways to do this.
#
# The class method ::kill, is meant to exit a given thread:
#
#     thr = Thread.new { sleep }
#     Thread.kill(thr) # sends exit() to thr
#
# Alternatively, you can use the instance method #exit, or any of its aliases
# #kill or #terminate.
#
#     thr.exit
#
# ### Thread status
#
# Ruby provides a few instance methods for querying the state of a given thread.
# To get a string with the current thread's state use #status
#
#     thr = Thread.new { sleep }
#     thr.status # => "sleep"
#     thr.exit
#     thr.status # => false
#
# You can also use #alive? to tell if the thread is running or sleeping, and
# #stop? if the thread is dead or sleeping.
#
# ### Thread variables and scope
#
# Since threads are created with blocks, the same rules apply to other Ruby
# blocks for variable scope. Any local variables created within this block are
# accessible to only this thread.
#
# #### Fiber-local vs. Thread-local
#
# Each fiber has its own bucket for Thread#[] storage. When you set a new
# fiber-local it is only accessible within this Fiber. To illustrate:
#
#     Thread.new {
#       Thread.current[:foo] = "bar"
#       Fiber.new {
#         p Thread.current[:foo] # => nil
#       }.resume
#     }.join
#
# This example uses #[] for getting and #[]= for setting fiber-locals, you can
# also use #keys to list the fiber-locals for a given thread and #key? to check
# if a fiber-local exists.
#
# When it comes to thread-locals, they are accessible within the entire scope of
# the thread. Given the following example:
#
#     Thread.new{
#       Thread.current.thread_variable_set(:foo, 1)
#       p Thread.current.thread_variable_get(:foo) # => 1
#       Fiber.new{
#         Thread.current.thread_variable_set(:foo, 2)
#         p Thread.current.thread_variable_get(:foo) # => 2
#       }.resume
#       p Thread.current.thread_variable_get(:foo)   # => 2
#     }.join
#
# You can see that the thread-local `:foo` carried over into the fiber and was
# changed to `2` by the end of the thread.
#
# This example makes use of #thread_variable_set to create new thread-locals,
# and #thread_variable_get to reference them.
#
# There is also #thread_variables to list all thread-locals, and
# #thread_variable? to check if a given thread-local exists.
#
# ### Exception handling
#
# When an unhandled exception is raised inside a thread, it will terminate. By
# default, this exception will not propagate to other threads. The exception is
# stored and when another thread calls #value or #join, the exception will be
# re-raised in that thread.
#
#     t = Thread.new{ raise 'something went wrong' }
#     t.value #=> RuntimeError: something went wrong
#
# An exception can be raised from outside the thread using the Thread#raise
# instance method, which takes the same parameters as Kernel#raise.
#
# Setting Thread.abort_on_exception = true, Thread#abort_on_exception = true, or
# $DEBUG = true will cause a subsequent unhandled exception raised in a thread
# to be automatically re-raised in the main thread.
#
# With the addition of the class method ::handle_interrupt, you can now handle
# exceptions asynchronously with threads.
#
# ### Scheduling
#
# Ruby provides a few ways to support scheduling threads in your program.
#
# The first way is by using the class method ::stop, to put the current running
# thread to sleep and schedule the execution of another thread.
#
# Once a thread is asleep, you can use the instance method #wakeup to mark your
# thread as eligible for scheduling.
#
# You can also try ::pass, which attempts to pass execution to another thread
# but is dependent on the OS whether a running thread will switch or not. The
# same goes for #priority, which lets you hint to the thread scheduler which
# threads you want to take precedence when passing execution. This method is
# also dependent on the OS and may be ignored on some platforms.
#
class Thread < Object
  # <!--
  #   rdoc-file=thread.c
  #   - Thread.current   -> thread
  # -->
  # Returns the currently executing thread.
  #
  #     Thread.current   #=> #<Thread:0x401bdf4c run>
  #
  def self.current: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.main   -> thread
  # -->
  # Returns the main thread.
  #
  def self.main: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym]   -> obj or nil
  # -->
  # Attribute Reference---Returns the value of a fiber-local variable (current
  # thread's root fiber if not explicitly inside a Fiber), using either a symbol
  # or a string name. If the specified variable does not exist, returns `nil`.
  #
  #     [
  #       Thread.new { Thread.current["name"] = "A" },
  #       Thread.new { Thread.current[:name]  = "B" },
  #       Thread.new { Thread.current["name"] = "C" }
  #     ].each do |th|
  #       th.join
  #       puts "#{th.inspect}: #{th[:name]}"
  #     end
  #
  # This will produce:
  #
  #     #<Thread:0x00000002a54220 dead>: A
  #     #<Thread:0x00000002a541a8 dead>: B
  #     #<Thread:0x00000002a54130 dead>: C
  #
  # Thread#[] and Thread#[]= are not thread-local but fiber-local. This confusion
  # did not exist in Ruby 1.8 because fibers are only available since Ruby 1.9.
  # Ruby 1.9 chooses that the methods behaves fiber-local to save following idiom
  # for dynamic scope.
  #
  #     def meth(newvalue)
  #       begin
  #         oldvalue = Thread.current[:name]
  #         Thread.current[:name] = newvalue
  #         yield
  #       ensure
  #         Thread.current[:name] = oldvalue
  #       end
  #     end
  #
  # The idiom may not work as dynamic scope if the methods are thread-local and a
  # given block switches fiber.
  #
  #     f = Fiber.new {
  #       meth(1) {
  #         Fiber.yield
  #       }
  #     }
  #     meth(2) {
  #       f.resume
  #     }
  #     f.resume
  #     p Thread.current[:name]
  #     #=> nil if fiber-local
  #     #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)
  #
  # For thread-local variables, please see #thread_variable_get and
  # #thread_variable_set.
  #
  def []: (String | Symbol key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr[sym] = obj   -> obj
  # -->
  # Attribute Assignment---Sets or creates the value of a fiber-local variable,
  # using either a symbol or a string.
  #
  # See also Thread#[].
  #
  # For thread-local variables, please see #thread_variable_set and
  # #thread_variable_get.
  #
  def []=: (String | Symbol key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.alive?   -> true or false
  # -->
  # Returns `true` if `thr` is running or sleeping.
  #
  #     thr = Thread.new { }
  #     thr.join                #=> #<Thread:0x401b3fb0 dead>
  #     Thread.current.alive?   #=> true
  #     thr.alive?              #=> false
  #
  # See also #stop? and #status.
  #
  def alive?: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.exit        -> thr
  #   - thr.kill        -> thr
  #   - thr.terminate   -> thr
  # -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def kill: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``abort on exception'' condition for
  # this `thr`.
  #
  # The default is `false`.
  #
  # See also #abort_on_exception=.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception.
  #
  def abort_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if this `thr` is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # See also #abort_on_exception.
  #
  # There is also a class level method to set this for all threads, see
  # ::abort_on_exception=.
  #
  def abort_on_exception=: (boolish abort_on_exception) -> untyped

  # <!--
  #   rdoc-file=vm_trace.c
  #   - thr.add_trace_func(proc)    -> proc
  # -->
  # Adds *proc* as a handler for tracing.
  #
  # See Thread#set_trace_func and Kernel#set_trace_func.
  #
  def add_trace_func: (untyped proc) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace    -> array or nil
  # -->
  # Returns the current backtrace of the target thread.
  #
  def backtrace: (*untyped args) -> ::Array[untyped]

  # <!--
  #   rdoc-file=thread.c
  #   - thread.backtrace_locations(*args)   -> array or nil
  # -->
  # Returns the execution stack for the target thread---an array containing
  # backtrace location objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # This method behaves similarly to Kernel#caller_locations except it applies to
  # a specific thread.
  #
  def backtrace_locations: (*untyped args) -> ::Array[untyped]?

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def exit: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.fetch(sym)           -> obj
  #   - thr.fetch(sym) { }       -> obj
  #   - thr.fetch(sym, default)  -> obj
  # -->
  # Returns a fiber-local for the given key. If the key can't be found, there are
  # several options: With no other arguments, it will raise a KeyError exception;
  # if *default* is given, then that will be returned; if the optional code block
  # is specified, then that will be run and its result returned.  See Thread#[]
  # and Hash#fetch.
  #
  def fetch: (*untyped sym) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.group   -> thgrp or nil
  # -->
  # Returns the ThreadGroup which contains the given thread.
  #
  #     Thread.main.group   #=> #<ThreadGroup:0x4029d914>
  #
  def group: () -> ThreadGroup?

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.new { ... }                  -> thread
  #   - Thread.new(*args, &proc)            -> thread
  #   - Thread.new(*args) { |args| ... }    -> thread
  # -->
  # Creates a new thread executing the given block.
  #
  # Any `args` given to ::new will be passed to the block:
  #
  #     arr = []
  #     a, b, c = 1, 2, 3
  #     Thread.new(a,b,c) { |d,e,f| arr << d << e << f }.join
  #     arr #=> [1, 2, 3]
  #
  # A ThreadError exception is raised if ::new is called without a block.
  #
  # If you're going to subclass Thread, be sure to call super in your `initialize`
  # method, otherwise a ThreadError will be raised.
  #
  def initialize: (*untyped) { (*untyped) -> void } -> void

  # <!--
  #   rdoc-file=thread.c
  #   - thr.join          -> thr
  #   - thr.join(limit)   -> thr
  # -->
  # The calling thread will suspend execution and run this `thr`.
  #
  # Does not return until `thr` exits or until the given `limit` seconds have
  # passed.
  #
  # If the time limit expires, `nil` will be returned, otherwise `thr` is
  # returned.
  #
  # Any threads not joined will be killed when the main program exits.
  #
  # If `thr` had previously raised an exception and the ::abort_on_exception or
  # $DEBUG flags are not set, (so the exception has not yet been processed), it
  # will be processed at this time.
  #
  #     a = Thread.new { print "a"; sleep(10); print "b"; print "c" }
  #     x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }
  #     x.join # Let thread x finish, thread a will be killed on exit.
  #     #=> "axyz"
  #
  # The following example illustrates the `limit` parameter.
  #
  #     y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}
  #     puts "Waiting" until y.join(0.15)
  #
  # This will produce:
  #
  #     tick...
  #     Waiting
  #     tick...
  #     Waiting
  #     tick...
  #     tick...
  #
  def join: (*untyped limit) -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - thr.key?(sym)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a fiber-local
  # variable.
  #
  #     me = Thread.current
  #     me[:oliver] = "a"
  #     me.key?(:oliver)    #=> true
  #     me.key?(:stanley)   #=> false
  #
  def key?: (Symbol sym) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.keys   -> array
  # -->
  # Returns an array of the names of the fiber-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current[:cat] = 'meow'
  #       Thread.current["dog"] = 'woof'
  #     end
  #     thr.join   #=> #<Thread:0x401b3f10 dead>
  #     thr.keys   #=> [:dog, :cat]
  #
  def keys: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name   -> string
  # -->
  # show the name of the thread.
  #
  def name: () -> String

  # <!--
  #   rdoc-file=thread.c
  #   - thr.name=(name)   -> string
  # -->
  # set given name to the ruby thread. On some platform, it may set the name to
  # pthread and/or kernel.
  #
  def name=: (untyped name) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.native_thread_id   -> integer
  # -->
  # Return the native thread ID which is used by the Ruby thread.
  #
  # The ID depends on the OS. (not POSIX thread ID returned by pthread_self(3))
  # *   On Linux it is TID returned by gettid(2).
  # *   On macOS it is the system-wide unique integral ID of thread returned by
  #     pthread_threadid_np(3).
  # *   On FreeBSD it is the unique integral ID of the thread returned by
  #     pthread_getthreadid_np(3).
  # *   On Windows it is the thread identifier returned by GetThreadId().
  # *   On other platforms, it raises NotImplementedError.
  #
  #
  # NOTE: If the thread is not associated yet or already deassociated with a
  # native thread, it returns *nil*. If the Ruby implementation uses M:N thread
  # model, the ID may change depending on the timing.
  #
  def native_thread_id: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - target_thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty for the target thread.
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # See ::pending_interrupt? for more information.
  #
  def pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority   -> integer
  # -->
  # Returns the priority of *thr*. Default is inherited from the current thread
  # which creating the new thread, or zero for the initial main thread;
  # higher-priority thread will run more frequently than lower-priority threads
  # (but lower-priority threads can also run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     Thread.current.priority   #=> 0
  #
  def priority: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.priority= integer   -> thr
  # -->
  # Sets the priority of *thr* to *integer*. Higher-priority threads will run more
  # frequently than lower-priority threads (but lower-priority threads can also
  # run).
  #
  # This is just hint for Ruby thread scheduler.  It may be ignored on some
  # platform.
  #
  #     count1 = count2 = 0
  #     a = Thread.new do
  #           loop { count1 += 1 }
  #         end
  #     a.priority = -1
  #
  #     b = Thread.new do
  #           loop { count2 += 1 }
  #         end
  #     b.priority = -2
  #     sleep 1   #=> 1
  #     count1    #=> 622504
  #     count2    #=> 5832
  #
  def priority=: (Integer priority) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception   -> true or false
  # -->
  # Returns the status of the thread-local ``report on exception'' condition for
  # this `thr`.
  #
  # The default value when creating a Thread is the value of the global flag
  # Thread.report_on_exception.
  #
  # See also #report_on_exception=.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception: () -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.report_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, a message is printed on $stderr if an exception kills this
  # `thr`.  See ::report_on_exception for details.
  #
  # See also #report_on_exception.
  #
  # There is also a class level method to set this for all new threads, see
  # ::report_on_exception=.
  #
  def report_on_exception=: (boolish report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.run   -> thr
  # -->
  # Wakes up `thr`, making it eligible for scheduling.
  #
  #     a = Thread.new { puts "a"; Thread.stop; puts "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     puts "Got here"
  #     a.run
  #     a.join
  #
  # This will produce:
  #
  #     a
  #     Got here
  #     c
  #
  # See also the instance method #wakeup.
  #
  def run: () -> Thread

  # Returns the safe level.
  #
  # This method is obsolete because $SAFE is a process global state. Simply
  # check $SAFE.
  def safe_level: () -> Integer

  # <!--
  #   rdoc-file=thread.c
  #   - thr.status   -> string, false or nil
  # -->
  # Returns the status of `thr`.
  #
  # `"sleep"`
  # :   Returned if this thread is sleeping or waiting on I/O
  # `"run"`
  # :   When this thread is executing
  # `"aborting"`
  # :   If this thread is aborting
  # `false`
  # :   When this thread is terminated normally
  # `nil`
  # :   If terminated with an exception.
  #
  #
  #     a = Thread.new { raise("die now") }
  #     b = Thread.new { Thread.stop }
  #     c = Thread.new { Thread.exit }
  #     d = Thread.new { sleep }
  #     d.kill                  #=> #<Thread:0x401b3678 aborting>
  #     a.status                #=> nil
  #     b.status                #=> "sleep"
  #     c.status                #=> false
  #     d.status                #=> "aborting"
  #     Thread.current.status   #=> "run"
  #
  # See also the instance methods #alive? and #stop?
  #
  def status: () -> (String | bool)?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.stop?   -> true or false
  # -->
  # Returns `true` if `thr` is dead or sleeping.
  #
  #     a = Thread.new { Thread.stop }
  #     b = Thread.current
  #     a.stop?   #=> true
  #     b.stop?   #=> false
  #
  # See also #alive? and #status.
  #
  def stop?: () -> bool

  # <!-- rdoc-file=thread.c -->
  # Terminates `thr` and schedules another thread to be run, returning the
  # terminated Thread.  If this is the main thread, or the last thread, exits the
  # process.
  #
  def terminate: () -> Thread?

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable?(key)   -> true or false
  # -->
  # Returns `true` if the given string (or symbol) exists as a thread-local
  # variable.
  #
  #     me = Thread.current
  #     me.thread_variable_set(:oliver, "a")
  #     me.thread_variable?(:oliver)    #=> true
  #     me.thread_variable?(:stanley)   #=> false
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variable?: (String | Symbol key) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_get(key)  -> obj or nil
  # -->
  # Returns the value of a thread local variable that has been set.  Note that
  # these are different than fiber local values.  For fiber local values, please
  # see Thread#[] and Thread#[]=.
  #
  # Thread local values are carried along with threads, and do not respect fibers.
  #  For example:
  #
  #     Thread.new {
  #       Thread.current.thread_variable_set("foo", "bar") # set a thread local
  #       Thread.current["foo"] = "bar"                    # set a fiber local
  #
  #       Fiber.new {
  #         Fiber.yield [
  #           Thread.current.thread_variable_get("foo"), # get the thread local
  #           Thread.current["foo"],                     # get the fiber local
  #         ]
  #       }.resume
  #     }.join.value # => ['bar', nil]
  #
  # The value "bar" is returned for the thread local, where nil is returned for
  # the fiber local.  The fiber is executed in the same thread, so the thread
  # local values are available.
  #
  def thread_variable_get: (untyped key) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variable_set(key, value)
  # -->
  # Sets a thread local with `key` to `value`.  Note that these are local to
  # threads, and not to fibers.  Please see Thread#thread_variable_get and
  # Thread#[] for more information.
  #
  def thread_variable_set: (untyped key, untyped value) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.thread_variables   -> array
  # -->
  # Returns an array of the names of the thread-local variables (as Symbols).
  #
  #     thr = Thread.new do
  #       Thread.current.thread_variable_set(:cat, 'meow')
  #       Thread.current.thread_variable_set("dog", 'woof')
  #     end
  #     thr.join               #=> #<Thread:0x401b3f10 dead>
  #     thr.thread_variables   #=> [:dog, :cat]
  #
  # Note that these are not fiber local variables.  Please see Thread#[] and
  # Thread#thread_variable_get for more details.
  #
  def thread_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=thread.c
  #   - thr.value   -> obj
  # -->
  # Waits for `thr` to complete, using #join, and returns its value or raises the
  # exception which terminated the thread.
  #
  #     a = Thread.new { 2 + 2 }
  #     a.value   #=> 4
  #
  #     b = Thread.new { raise 'something went wrong' }
  #     b.value   #=> RuntimeError: something went wrong
  #
  def value: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - thr.wakeup   -> thr
  # -->
  # Marks a given thread as eligible for scheduling, however it may still remain
  # blocked on I/O.
  #
  # **Note:** This does not invoke the scheduler, see #run for more information.
  #
  #     c = Thread.new { Thread.stop; puts "hey!" }
  #     sleep 0.1 while c.status!='sleep'
  #     c.wakeup
  #     c.join
  #     #=> "hey!"
  #
  def wakeup: () -> Thread

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception   -> true or false
  # -->
  # Returns the status of the global ``abort on exception'' condition.
  #
  # The default is `false`.
  #
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread.
  #
  # Can also be specified by the global $DEBUG flag or command line option `-d`.
  #
  # See also ::abort_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception.
  #
  def self.abort_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.abort_on_exception= boolean   -> true or false
  # -->
  # When set to `true`, if any thread is aborted by an exception, the raised
  # exception will be re-raised in the main thread. Returns the new state.
  #
  #     Thread.abort_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "not reached"
  #
  # This will produce:
  #
  #     In new thread
  #     prog.rb:4: Exception from thread (RuntimeError)
  #      from prog.rb:2:in `initialize'
  #      from prog.rb:2:in `new'
  #      from prog.rb:2
  #
  # See also ::abort_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #abort_on_exception=.
  #
  def self.abort_on_exception=: (untyped abort_on_exception) -> untyped

  # Wraps the block in a single, VM-global
  # [Mutex\#synchronize](https://ruby-doc.org/core-2.6.3/Mutex.html#method-i-synchronize)
  # , returning the value of the block. A thread executing inside the
  # exclusive section will only block other threads which also use the
  # [::exclusive](Thread.downloaded.ruby_doc#method-c-exclusive) mechanism.
  def self.exclusive: () { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.exit   -> thread
  # -->
  # Terminates the currently running thread and schedules another thread to be
  # run.
  #
  # If this thread is already marked to be killed, ::exit returns the Thread.
  #
  # If this is the main thread, or the last  thread, exit the process.
  #
  def self.exit: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.fork: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.handle_interrupt(hash) { ... } -> result of the block
  # -->
  # Changes asynchronous interrupt timing.
  #
  # *interrupt* means asynchronous event and corresponding procedure by
  # Thread#raise, Thread#kill, signal trap (not supported yet) and main thread
  # termination (if main thread terminates, then all other thread will be killed).
  #
  # The given `hash` has pairs like `ExceptionClass => :TimingSymbol`. Where the
  # ExceptionClass is the interrupt handled by the given block. The TimingSymbol
  # can be one of the following symbols:
  #
  # `:immediate`
  # :   Invoke interrupts immediately.
  # `:on_blocking`
  # :   Invoke interrupts while *BlockingOperation*.
  # `:never`
  # :   Never invoke all interrupts.
  #
  #
  # *BlockingOperation* means that the operation will block the calling thread,
  # such as read and write.  On CRuby implementation, *BlockingOperation* is any
  # operation executed without GVL.
  #
  # Masked asynchronous interrupts are delayed until they are enabled. This method
  # is similar to sigprocmask(3).
  #
  # ### NOTE
  #
  # Asynchronous interrupts are difficult to use.
  #
  # If you need to communicate between threads, please consider to use another way
  # such as Queue.
  #
  # Or use them with deep understanding about this method.
  #
  # ### Usage
  #
  # In this example, we can guard from Thread#raise exceptions.
  #
  # Using the `:never` TimingSymbol the RuntimeError exception will always be
  # ignored in the first block of the main thread. In the second
  # ::handle_interrupt block we can purposefully handle RuntimeError exceptions.
  #
  #     th = Thread.new do
  #       Thread.handle_interrupt(RuntimeError => :never) {
  #         begin
  #           # You can write resource allocation code safely.
  #           Thread.handle_interrupt(RuntimeError => :immediate) {
  #             # ...
  #           }
  #         ensure
  #           # You can write resource deallocation code safely.
  #         end
  #       }
  #     end
  #     Thread.pass
  #     # ...
  #     th.raise "stop"
  #
  # While we are ignoring the RuntimeError exception, it's safe to write our
  # resource allocation code. Then, the ensure block is where we can safely
  # deallocate your resources.
  #
  # #### Guarding from Timeout::Error
  #
  # In the next example, we will guard from the Timeout::Error exception. This
  # will help prevent from leaking resources when Timeout::Error exceptions occur
  # during normal ensure clause. For this example we use the help of the standard
  # library Timeout, from lib/timeout.rb
  #
  #     require 'timeout'
  #     Thread.handle_interrupt(Timeout::Error => :never) {
  #       timeout(10){
  #         # Timeout::Error doesn't occur here
  #         Thread.handle_interrupt(Timeout::Error => :on_blocking) {
  #           # possible to be killed by Timeout::Error
  #           # while blocking operation
  #         }
  #         # Timeout::Error doesn't occur here
  #       }
  #     }
  #
  # In the first part of the `timeout` block, we can rely on Timeout::Error being
  # ignored. Then in the `Timeout::Error => :on_blocking` block, any operation
  # that will block the calling thread is susceptible to a Timeout::Error
  # exception being raised.
  #
  # #### Stack control settings
  #
  # It's possible to stack multiple levels of ::handle_interrupt blocks in order
  # to control more than one ExceptionClass and TimingSymbol at a time.
  #
  #     Thread.handle_interrupt(FooError => :never) {
  #       Thread.handle_interrupt(BarError => :never) {
  #          # FooError and BarError are prohibited.
  #       }
  #     }
  #
  # #### Inheritance with ExceptionClass
  #
  # All exceptions inherited from the ExceptionClass parameter will be considered.
  #
  #     Thread.handle_interrupt(Exception => :never) {
  #       # all exceptions inherited from Exception are prohibited.
  #     }
  #
  # For handling all interrupts, use `Object` and not `Exception` as the
  # ExceptionClass, as kill/terminate interrupts are not handled by `Exception`.
  #
  def self.handle_interrupt: (untyped hash) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.kill(thread)   -> thread
  # -->
  # Causes the given `thread` to exit, see also Thread::exit.
  #
  #     count = 0
  #     a = Thread.new { loop { count += 1 } }
  #     sleep(0.1)       #=> 0
  #     Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>
  #     count            #=> 93947
  #     a.alive?         #=> false
  #
  def self.kill: (Thread thread) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.list   -> array
  # -->
  # Returns an array of Thread objects for all threads that are either runnable or
  # stopped.
  #
  #     Thread.new { sleep(200) }
  #     Thread.new { 1000000.times {|i| i*i } }
  #     Thread.new { Thread.stop }
  #     Thread.list.each {|t| p t}
  #
  # This will produce:
  #
  #     #<Thread:0x401b3e84 sleep>
  #     #<Thread:0x401b3f38 run>
  #     #<Thread:0x401b3fb0 sleep>
  #     #<Thread:0x401bdf4c run>
  #
  def self.list: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pass   -> nil
  # -->
  # Give the thread scheduler a hint to pass execution to another thread. A
  # running thread may or may not switch, it depends on OS and processor.
  #
  def self.pass: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.pending_interrupt?(error = nil) -> true/false
  # -->
  # Returns whether or not the asynchronous queue is empty.
  #
  # Since Thread::handle_interrupt can be used to defer asynchronous events, this
  # method can be used to determine if there are any deferred events.
  #
  # If you find this method returns true, then you may finish `:never` blocks.
  #
  # For example, the following method processes deferred asynchronous events
  # immediately.
  #
  #     def Thread.kick_interrupt_immediately
  #       Thread.handle_interrupt(Object => :immediate) {
  #         Thread.pass
  #       }
  #     end
  #
  # If `error` is given, then check only for `error` type deferred events.
  #
  # ### Usage
  #
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           if Thread.pending_interrupt?
  #             Thread.handle_interrupt(Object => :immediate){}
  #           end
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     th.raise # stop thread
  #
  # This example can also be written as the following, which you should use to
  # avoid asynchronous interrupts.
  #
  #     flag = true
  #     th = Thread.new{
  #       Thread.handle_interrupt(RuntimeError => :on_blocking){
  #         while true
  #           ...
  #           # reach safe point to invoke interrupt
  #           break if flag == false
  #           ...
  #         end
  #       }
  #     }
  #     ...
  #     flag = false # stop thread
  #
  def self.pending_interrupt?: (*untyped args) -> bool

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception   -> true or false
  # -->
  # Returns the status of the global ``report on exception'' condition.
  #
  # The default is `true` since Ruby 2.5.
  #
  # All threads created when this flag is true will report a message on $stderr if
  # an exception kills the thread.
  #
  #     Thread.new { 1.times { raise } }
  #
  # will produce this output on $stderr:
  #
  #     #<Thread:...> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #             2: from -e:1:in `block in <main>'
  #             1: from -e:1:in `times'
  #
  # This is done to catch errors in threads early. In some cases, you might not
  # want this output. There are multiple ways to avoid the extra output:
  #
  # *   If the exception is not intended, the best is to fix the cause of the
  #     exception so it does not happen anymore.
  # *   If the exception is intended, it might be better to rescue it closer to
  #     where it is raised rather then let it kill the Thread.
  # *   If it is guaranteed the Thread will be joined with Thread#join or
  #     Thread#value, then it is safe to disable this report with
  #     `Thread.current.report_on_exception = false` when starting the Thread.
  #     However, this might handle the exception much later, or not at all if the
  #     Thread is never joined due to the parent thread being blocked, etc.
  #
  #
  # See also ::report_on_exception=.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception: () -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.report_on_exception= boolean   -> true or false
  # -->
  # Returns the new state. When set to `true`, all threads created afterwards will
  # inherit the condition and report a message on $stderr if an exception kills a
  # thread:
  #
  #     Thread.report_on_exception = true
  #     t1 = Thread.new do
  #       puts  "In new thread"
  #       raise "Exception from thread"
  #     end
  #     sleep(1)
  #     puts "In the main thread"
  #
  # This will produce:
  #
  #     In new thread
  #     #<Thread:...prog.rb:2> terminated with exception (report_on_exception is true):
  #     Traceback (most recent call last):
  #     prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)
  #     In the main thread
  #
  # See also ::report_on_exception.
  #
  # There is also an instance level method to set this for a specific thread, see
  # #report_on_exception=.
  #
  def self.report_on_exception=: (untyped report_on_exception) -> untyped

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.start([args]*) {|args| block }   -> thread
  #   - Thread.fork([args]*) {|args| block }    -> thread
  # -->
  # Basically the same as ::new. However, if class Thread is subclassed, then
  # calling `start` in that subclass will not invoke the subclass's `initialize`
  # method.
  #
  def self.start: (*untyped args) { (*untyped) -> void } -> instance

  # <!--
  #   rdoc-file=thread.c
  #   - Thread.stop   -> nil
  # -->
  # Stops execution of the current thread, putting it into a ``sleep'' state, and
  # schedules execution of another thread.
  #
  #     a = Thread.new { print "a"; Thread.stop; print "c" }
  #     sleep 0.1 while a.status!='sleep'
  #     print "b"
  #     a.run
  #     a.join
  #     #=> "abc"
  #
  def self.stop: () -> untyped
end

# <!-- rdoc-file=vm_backtrace.c -->
# An internal representation of the backtrace. The user will never interact with
# objects of this class directly, but class methods can be used to get backtrace
# settings of the current session.
#
class Thread::Backtrace < Object
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - Threade::Backtrace::limit -> integer
  # -->
  # Returns maximum backtrace length set by `--backtrace-limit` command-line
  # option. The defalt is `-1` which means unlimited backtraces. If the value is
  # zero or positive, the error backtraces, produced by Exception#full_message,
  # are abbreviated and the extra lines are replaced by `... 3 levels... `
  #
  #     $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     - 1
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #         from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
  #         from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
  #         from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
  #         from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
  #         from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
  #         from -e:1:in `<main>'
  #
  #     $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     2
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #         from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
  #         from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
  #          ... 7 levels...
  #
  #     $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
  #     0
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
  #          ... 9 levels...
  #     .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
  #          ... 9 levels...
  #
  def self.limit: () -> Integer
end

# <!-- rdoc-file=vm_backtrace.c -->
# An object representation of a stack frame, initialized by
# Kernel#caller_locations.
#
# For example:
#
#     # caller_locations.rb
#     def a(skip)
#       caller_locations(skip)
#     end
#     def b(skip)
#       a(skip)
#     end
#     def c(skip)
#       b(skip)
#     end
#
#     c(0..2).map do |call|
#       puts call.to_s
#     end
#
# Running `ruby caller_locations.rb` will produce:
#
#     caller_locations.rb:2:in `a'
#     caller_locations.rb:5:in `b'
#     caller_locations.rb:8:in `c'
#
# Here's another example with a slightly different result:
#
#     # foo.rb
#     class Foo
#       attr_accessor :locations
#       def initialize(skip)
#         @locations = caller_locations(skip)
#       end
#     end
#
#     Foo.new(0..2).locations.map do |call|
#       puts call.to_s
#     end
#
# Now run `ruby foo.rb` and you should see:
#
#     init.rb:4:in `initialize'
#     init.rb:8:in `new'
#     init.rb:8:in `<main>'
#
class Thread::Backtrace::Location
  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - absolute_path()
  # -->
  # Returns the full file path of this frame.
  #
  # Same as #path, except that it will return absolute path even if the frame is
  # in the main script.
  #
  def absolute_path: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - base_label()
  # -->
  # Returns the base label of this frame.
  #
  # Usually same as #label, without decoration.
  #
  def base_label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - label()
  # -->
  # Returns the label of this frame.
  #
  # Usually consists of method, class, module, etc names with decoration.
  #
  # Consider the following example:
  #
  #     def foo
  #       puts caller_locations(0).first.label
  #
  #       1.times do
  #         puts caller_locations(0).first.label
  #
  #         1.times do
  #           puts caller_locations(0).first.label
  #         end
  #
  #       end
  #     end
  #
  # The result of calling `foo` is this:
  #
  #     label: foo
  #     label: block in foo
  #     label: block (2 levels) in foo
  #
  def label: () -> String?

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - lineno()
  # -->
  # Returns the line number of this frame.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.lineno #=> 2
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - path()
  # -->
  # Returns the file name of this frame. This will generally be an absolute path,
  # unless the frame is in the main script, in which case it will be the script
  # location passed on the command line.
  #
  # For example, using `caller_locations.rb` from Thread::Backtrace::Location
  #
  #     loc = c(0..1).first
  #     loc.path #=> caller_locations.rb
  #
  def path: () -> String?
end

# <!-- rdoc-file=thread_sync.c -->
# ConditionVariable objects augment class Mutex. Using condition variables, it
# is possible to suspend while in the middle of a critical section until a
# resource becomes available.
#
# Example:
#
#     mutex = Thread::Mutex.new
#     resource = Thread::ConditionVariable.new
#
#     a = Thread.new {
#        mutex.synchronize {
#          # Thread 'a' now needs the resource
#          resource.wait(mutex)
#          # 'a' can now have the resource
#        }
#     }
#
#     b = Thread.new {
#        mutex.synchronize {
#          # Thread 'b' has finished using the resource
#          resource.signal
#        }
#     }
#
class Thread::ConditionVariable < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - broadcast()
  # -->
  # Wakes up all threads waiting for this lock.
  #
  def broadcast: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - signal()
  # -->
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - wait(mutex, timeout=nil)
  # -->
  # Releases the lock held in `mutex` and waits; reacquires the lock on wakeup.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed,
  # even if no other thread doesn't signal.
  #
  # Returns the slept result on `mutex`.
  #
  def wait: (Thread::Mutex mutex, ?Integer timeout) -> self
end

# <!-- rdoc-file=thread_sync.c -->
# Thread::Mutex implements a simple semaphore that can be used to coordinate
# access to shared data from multiple concurrent threads.
#
# Example:
#
#     semaphore = Thread::Mutex.new
#
#     a = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
#     b = Thread.new {
#       semaphore.synchronize {
#         # access shared resource
#       }
#     }
#
class Thread::Mutex < Object
  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.lock  -> self
  # -->
  # Attempts to grab the lock and waits if it isn't available. Raises
  # `ThreadError` if `mutex` was locked by the current thread.
  #
  def lock: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.locked?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by some thread.
  #
  def locked?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.owned?  -> true or false
  # -->
  # Returns `true` if this lock is currently held by current thread.
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.synchronize { ... }    -> result of the block
  # -->
  # Obtains a lock, runs the block, and releases the lock when the block
  # completes.  See the example under Thread::Mutex.
  #
  def synchronize: [X] () { () -> X } -> X

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.try_lock  -> true or false
  # -->
  # Attempts to obtain the lock and returns immediately. Returns `true` if the
  # lock was granted.
  #
  def try_lock: () -> bool

  # <!--
  #   rdoc-file=thread_sync.c
  #   - mutex.unlock    -> self
  # -->
  # Releases the lock. Raises `ThreadError` if `mutex` wasn't locked by the
  # current thread.
  #
  def unlock: () -> self
end

# <!-- rdoc-file=thread_sync.c -->
# The Thread::Queue class implements multi-producer, multi-consumer queues.  It
# is especially useful in threaded programming when information must be
# exchanged safely between multiple threads. The Thread::Queue class implements
# all the required locking semantics.
#
# The class implements FIFO type of queue. In a FIFO queue, the first tasks
# added are the first retrieved.
#
# Example:
#
#     queue = Thread::Queue.new
#
#     producer = Thread.new do
#       5.times do |i|
#          sleep rand(i) # simulate expense
#          queue << i
#          puts "#{i} produced"
#       end
#     end
#
#     consumer = Thread.new do
#       5.times do |i|
#          value = queue.pop
#          sleep rand(i/2) # simulate expense
#          puts "consumed #{value}"
#       end
#     end
#
#     consumer.join
#
class Thread::Queue < Object
  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias << push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - clear()
  # -->
  # Removes all objects from the queue.
  #
  def clear: () -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - close
  # -->
  # Closes the queue. A closed queue cannot be re-opened.
  #
  # After the call to close completes, the following are true:
  #
  # *   `closed?` will return true
  #
  # *   `close` will be ignored.
  #
  # *   calling enq/push/<< will raise a `ClosedQueueError`.
  #
  # *   when `empty?` is false, calling deq/pop/shift will return an object from
  #     the queue as usual.
  # *   when `empty?` is true, deq(false) will not suspend the thread and will
  #     return nil. deq(true) will raise a `ThreadError`.
  #
  #
  # ClosedQueueError is inherited from StopIteration, so that you can break loop
  # block.
  #
  # Example:
  #
  #     q = Thread::Queue.new
  #     Thread.new{
  #       while e = q.deq # wait for nil to break loop
  #         # ...
  #       end
  #     }
  #     q.close
  #
  def close: () -> self

  # <!--
  #   rdoc-file=thread_sync.c
  #   - closed?
  # -->
  # Returns `true` if the queue is closed.
  #
  def closed?: () -> bool

  # <!-- rdoc-file=thread_sync.c -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  alias deq pop

  # <!--
  #   rdoc-file=thread_sync.c
  #   - empty?
  # -->
  # Returns `true` if the queue is empty.
  #
  def empty?: () -> bool

  # <!-- rdoc-file=thread_sync.c -->
  # Pushes the given `object` to the queue.
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - length
  #   - size
  # -->
  # Returns the length of the queue.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - num_waiting()
  # -->
  # Returns the number of threads waiting on the queue.
  #
  def num_waiting: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - pop(non_block=false)
  #   - deq(non_block=false)
  #   - shift(non_block=false)
  # -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  def pop: (?boolish non_block) -> untyped

  # <!--
  #   rdoc-file=thread_sync.c
  #   - push(object)
  #   - enq(object)
  #   - <<(object)
  # -->
  # Pushes the given `object` to the queue.
  #
  def push: (untyped obj) -> void

  # <!-- rdoc-file=thread_sync.c -->
  # Retrieves data from the queue.
  #
  # If the queue is empty, the calling thread is suspended until data is pushed
  # onto the queue. If `non_block` is true, the thread isn't suspended, and
  # `ThreadError` is raised.
  #
  alias shift pop

  # <!-- rdoc-file=thread_sync.c -->
  # Returns the length of the queue.
  #
  alias size length
end

# <!-- rdoc-file=thread_sync.c -->
# This class represents queues of specified size capacity.  The push operation
# may be blocked if the capacity is full.
#
# See Thread::Queue for an example of how a Thread::SizedQueue works.
#
class Thread::SizedQueue < Thread::Queue
  # <!-- rdoc-file=thread_sync.c -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  alias << push

  # <!-- rdoc-file=thread_sync.c -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  alias enq push

  # <!--
  #   rdoc-file=thread_sync.c
  #   - new(max)
  # -->
  # Creates a fixed-length queue with a maximum size of `max`.
  #
  def initialize: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max()
  # -->
  # Returns the maximum size of the queue.
  #
  def max: () -> Integer

  # <!--
  #   rdoc-file=thread_sync.c
  #   - max=(number)
  # -->
  # Sets the maximum size of the queue to the given `number`.
  #
  def max=: (Integer max) -> void

  # <!--
  #   rdoc-file=thread_sync.c
  #   - push(object, non_block=false)
  #   - enq(object, non_block=false)
  #   - <<(object)
  # -->
  # Pushes `object` to the queue.
  #
  # If there is no space left in the queue, waits until space becomes available,
  # unless `non_block` is true.  If `non_block` is true, the thread isn't
  # suspended, and `ThreadError` is raised.
  #
  def push: (untyped obj, ?boolish non_block) -> void
end

ConditionVariable: singleton(Thread::ConditionVariable)

Mutex: singleton(Thread::Mutex)

Queue: singleton(Thread::Queue)

SizedQueue: singleton(Thread::SizedQueue)

# <!-- rdoc-file=proc.c -->
# Method objects are created by Object#method, and are associated with a
# particular object (not just with a class).  They may be used to invoke the
# method within the object, and as a block associated with an iterator.  They
# may also be unbound from one object (creating an UnboundMethod) and bound to
# another.
#
#     class Thing
#       def square(n)
#         n*n
#       end
#     end
#     thing = Thing.new
#     meth  = thing.method(:square)
#
#     meth.call(9)                 #=> 81
#     [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]
#
#     [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3
#
#     require 'date'
#     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
#     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
#
class Method < Object
  # <!--
  #   rdoc-file=proc.c
  #   - meth.to_proc    -> proc
  # -->
  # Returns a Proc object corresponding to this method.
  #
  def to_proc: () -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.call(args, ...)    -> obj
  # -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  def call: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth << g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls *g* with them then
  # calls this method with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f << g).call(2) #=> 16
  #
  def <<: (Proc g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias === call

  # <!--
  #   rdoc-file=proc.c
  #   - meth >> g -> a_proc
  # -->
  # Returns a proc that is the composition of this method and the given *g*. The
  # returned proc takes a variable number of arguments, calls this method with
  # them then calls *g* with the result.
  #
  #     def f(x)
  #       x * x
  #     end
  #
  #     f = self.method(:f)
  #     g = proc {|x| x + x }
  #     p (f >> g).call(2) #=> 8
  #
  def >>: (Proc g) -> Proc

  # <!-- rdoc-file=proc.c -->
  # Invokes the *meth* with the specified arguments, returning the method's return
  # value.
  #
  #     m = 12.method("+")
  #     m.call(3)    #=> 15
  #     m.call(20)   #=> 32
  #
  alias [] call

  # <!--
  #   rdoc-file=proc.c
  #   - meth.arity    -> integer
  # -->
  # Returns an indication of the number of arguments accepted by a method. Returns
  # a nonnegative integer for methods that take a fixed number of arguments. For
  # Ruby methods that take a variable number of arguments, returns -n-1, where n
  # is the number of required arguments. Keyword arguments will be considered as a
  # single additional argument, that argument being mandatory if any keyword
  # argument is mandatory. For methods written in C, returns -1 if the call takes
  # a variable number of arguments.
  #
  #     class C
  #       def one;    end
  #       def two(a); end
  #       def three(*a);  end
  #       def four(a, b); end
  #       def five(a, b, *c);    end
  #       def six(a, b, *c, &d); end
  #       def seven(a, b, x:0); end
  #       def eight(x:, y:); end
  #       def nine(x:, y:, **z); end
  #       def ten(*a, x:, y:); end
  #     end
  #     c = C.new
  #     c.method(:one).arity     #=> 0
  #     c.method(:two).arity     #=> 1
  #     c.method(:three).arity   #=> -1
  #     c.method(:four).arity    #=> 2
  #     c.method(:five).arity    #=> -3
  #     c.method(:six).arity     #=> -3
  #     c.method(:seven).arity   #=> -3
  #     c.method(:eight).arity   #=> 1
  #     c.method(:nine).arity    #=> 1
  #     c.method(:ten).arity     #=> -2
  #
  #     "cat".method(:size).arity      #=> 0
  #     "cat".method(:replace).arity   #=> 1
  #     "cat".method(:squeeze).arity   #=> -1
  #     "cat".method(:count).arity     #=> -1
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - method.clone -> new_method
  # -->
  # Returns a clone of this method.
  #
  #     class A
  #       def foo
  #         return "bar"
  #       end
  #     end
  #
  #     m = A.new.method(:foo)
  #     m.call # => "bar"
  #     n = m.clone.call # => "bar"
  #
  def clone: () -> Method

  # <!--
  #   rdoc-file=proc.c
  #   - meth.curry        -> proc
  #   - meth.curry(arity) -> proc
  # -->
  # Returns a curried proc based on the method. When the proc is called with a
  # number of arguments that is lower than the method's arity, then another
  # curried proc is returned. Only when enough arguments have been supplied to
  # satisfy the method signature, will the method actually be called.
  #
  # The optional *arity* argument should be supplied when currying methods with
  # variable arguments to determine how many arguments are needed before the
  # method is called.
  #
  #     def foo(a,b,c)
  #       [a, b, c]
  #     end
  #
  #     proc  = self.method(:foo).curry
  #     proc2 = proc.call(1, 2)          #=> #<Proc>
  #     proc2.call(3)                    #=> [1,2,3]
  #
  #     def vararg(*args)
  #       args
  #     end
  #
  #     proc = self.method(:vararg).curry(4)
  #     proc2 = proc.call(:x)      #=> #<Proc>
  #     proc3 = proc2.call(:y, :z) #=> #<Proc>
  #     proc3.call(:a)             #=> [:x, :y, :z, :a]
  #
  def curry: (?Integer arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - meth.name    -> symbol
  # -->
  # Returns the name of the method.
  #
  def name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.original_name    -> symbol
  # -->
  # Returns the original name of the method.
  #
  #     class C
  #       def foo; end
  #       alias bar foo
  #     end
  #     C.instance_method(:bar).original_name # => :foo
  #
  def original_name: () -> Symbol

  # <!--
  #   rdoc-file=proc.c
  #   - meth.owner    -> class_or_module
  # -->
  # Returns the class or module that defines the method. See also Method#receiver.
  #
  #     (1..3).method(:map).owner #=> Enumerable
  #
  def owner: () -> (Class | Module)

  # <!--
  #   rdoc-file=proc.c
  #   - meth.parameters  -> array
  # -->
  # Returns the parameter information of this method.
  #
  #     def foo(bar); end
  #     method(:foo).parameters #=> [[:req, :bar]]
  #
  #     def foo(bar, baz, bat, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]
  #
  #     def foo(bar, *args); end
  #     method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]
  #
  #     def foo(bar, baz, *args, &blk); end
  #     method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
  #
  def parameters: () -> ::Array[[ :req | :opt | :rest | :keyreq | :key | :keyrest | :block, Symbol ] | [ :rest | :keyrest ]]

  # <!--
  #   rdoc-file=proc.c
  #   - meth.private? -> true or false
  # -->
  # Returns whether the method is private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.protected? -> true or false
  # -->
  # Returns whether the method is protected.
  #
  def protected?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.public? -> true or false
  # -->
  # Returns whether the method is public.
  #
  def public?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - meth.receiver    -> object
  # -->
  # Returns the bound receiver of the method object.
  #
  #     (1..3).method(:map).receiver # => 1..3
  #
  def receiver: () -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - meth.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this method or nil
  # if this method was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.super_method  -> method
  # -->
  # Returns a Method of superclass which would be called when super is used or nil
  # if there is no method on superclass.
  #
  def super_method: () -> Method?

  # <!--
  #   rdoc-file=proc.c
  #   - meth.unbind    -> unbound_method
  # -->
  # Dissociates *meth* from its current receiver. The resulting UnboundMethod can
  # subsequently be bound to a new object of the same class (see UnboundMethod).
  #
  def unbind: () -> UnboundMethod
end

# <!-- rdoc-file=rational.c -->
# A rational number can be represented as a pair of integer numbers: a/b (b>0),
# where a is the numerator and b is the denominator. Integer a equals rational
# a/1 mathematically.
#
# You can create a Rational object explicitly with:
#
# *   A [rational
#     literal](doc/syntax/literals_rdoc.html#label-Rational+Literals).
#
#
# You can convert certain objects to Rationals with:
#
# *   Method [Rational](Kernel.html#method-i-Rational).
#
#
# Examples
#
#     Rational(1)      #=> (1/1)
#     Rational(2, 3)   #=> (2/3)
#     Rational(4, -6)  #=> (-2/3) # Reduced.
#     3.to_r           #=> (3/1)
#     2/3r             #=> (2/3)
#
# You can also create rational objects from floating-point numbers or strings.
#
#     Rational(0.3)    #=> (5404319552844595/18014398509481984)
#     Rational('0.3')  #=> (3/10)
#     Rational('2/3')  #=> (2/3)
#
#     0.3.to_r         #=> (5404319552844595/18014398509481984)
#     '0.3'.to_r       #=> (3/10)
#     '2/3'.to_r       #=> (2/3)
#     0.3.rationalize  #=> (3/10)
#
# A rational object is an exact number, which helps you to write programs
# without any rounding errors.
#
#     10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
#     10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)
#
# However, when an expression includes an inexact component (numerical value or
# operation), it will produce an inexact result.
#
#     Rational(10) / 3   #=> (10/3)
#     Rational(10) / 3.0 #=> 3.3333333333333335
#
#     Rational(-8) ** Rational(1, 3)
#                        #=> (1.0000000000000002+1.7320508075688772i)
#
class Rational < Numeric
  public

  def %: (Integer) -> Rational
       | (Float) -> Float
       | (Rational) -> Rational
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat * numeric  ->  numeric
  # -->
  # Performs multiplication.
  #
  #     Rational(2, 3)  * Rational(2, 3)   #=> (4/9)
  #     Rational(900)   * Rational(1)      #=> (900/1)
  #     Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)
  #     Rational(9, 8)  * 4                #=> (9/2)
  #     Rational(20, 9) * 9.8              #=> 21.77777777777778
  #
  def *: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat ** numeric  ->  numeric
  # -->
  # Performs exponentiation.
  #
  #     Rational(2)    ** Rational(3)     #=> (8/1)
  #     Rational(10)   ** -2              #=> (1/100)
  #     Rational(10)   ** -2.0            #=> 0.01
  #     Rational(-4)   ** Rational(1, 2)  #=> (0.0+2.0i)
  #     Rational(1, 2) ** 0               #=> (1/1)
  #     Rational(1, 2) ** 0.0             #=> 1.0
  #
  def **: (Complex) -> Complex
        | (Numeric) -> Numeric

  # <!--
  #   rdoc-file=rational.c
  #   - rat + numeric  ->  numeric
  # -->
  # Performs addition.
  #
  #     Rational(2, 3)  + Rational(2, 3)   #=> (4/3)
  #     Rational(900)   + Rational(1)      #=> (901/1)
  #     Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)
  #     Rational(9, 8)  + 4                #=> (41/8)
  #     Rational(20, 9) + 9.8              #=> 12.022222222222222
  #
  def +: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  def +@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat - numeric  ->  numeric
  # -->
  # Performs subtraction.
  #
  #     Rational(2, 3)  - Rational(2, 3)   #=> (0/1)
  #     Rational(900)   - Rational(1)      #=> (899/1)
  #     Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)
  #     Rational(9, 8)  - 4                #=> (-23/8)
  #     Rational(20, 9) - 9.8              #=> -7.577777777777778
  #
  def -: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - -rat  ->  rational
  # -->
  # Negates `rat`.
  #
  def -@: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat / numeric     ->  numeric
  #   - rat.quo(numeric)  ->  numeric
  # -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def /: (Float) -> Float
       | (Complex) -> Complex
       | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rational <=> numeric  ->  -1, 0, +1, or nil
  # -->
  # Returns -1, 0, or +1 depending on whether `rational` is less than, equal to,
  # or greater than `numeric`.
  #
  # `nil` is returned if the two values are incomparable.
  #
  #     Rational(2, 3) <=> Rational(2, 3)  #=> 0
  #     Rational(5)    <=> 5               #=> 0
  #     Rational(2, 3) <=> Rational(1, 3)  #=> 1
  #     Rational(1, 3) <=> 1               #=> -1
  #     Rational(1, 3) <=> 0.3             #=> 1
  #
  #     Rational(1, 3) <=> "0.3"           #=> nil
  #
  def <=>: (Integer | Rational) -> Integer
         | (untyped) -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat == object  ->  true or false
  # -->
  # Returns `true` if `rat` equals `object` numerically.
  #
  #     Rational(2, 3)  == Rational(2, 3)   #=> true
  #     Rational(5)     == 5                #=> true
  #     Rational(0)     == 0.0              #=> true
  #     Rational('1/3') == 0.33             #=> false
  #     Rational('1/2') == '1/2'            #=> false
  #
  def ==: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.abs        ->  rational
  #   - rat.magnitude  ->  rational
  # -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  # Rational#magnitude is an alias for Rational#abs.
  #
  def abs: () -> Rational

  def abs2: () -> Rational

  def angle: () -> (Integer | Float)

  alias arg angle

  # <!--
  #   rdoc-file=rational.c
  #   - rat.ceil([ndigits])  ->  integer or rational
  # -->
  # Returns the smallest number greater than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).ceil      #=> 3
  #     Rational(2, 3).ceil   #=> 1
  #     Rational(-3, 2).ceil  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').ceil(+1).to_f  #=> -123.4
  #     Rational('-123.456').ceil(-1)       #=> -120
  #
  def ceil: () -> Integer
          | (Integer digits) -> (Integer | Rational)

  def coerce: (Numeric) -> [ Numeric, Numeric ]

  def conj: () -> Rational

  def conjugate: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.denominator  ->  integer
  # -->
  # Returns the denominator (always positive).
  #
  #     Rational(7).denominator             #=> 1
  #     Rational(7, 1).denominator          #=> 1
  #     Rational(9, -4).denominator         #=> 4
  #     Rational(-2, -10).denominator       #=> 5
  #
  def denominator: () -> Integer

  def div: (Numeric) -> Integer

  def divmod: (Numeric) -> [ Numeric, Numeric ]

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.fdiv(numeric)  ->  float
  # -->
  # Performs division and returns the value as a Float.
  #
  #     Rational(2, 3).fdiv(1)       #=> 0.6666666666666666
  #     Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333
  #     Rational(2).fdiv(3)          #=> 0.6666666666666666
  #
  def fdiv: (Numeric) -> Float

  def finite?: () -> bool

  # <!--
  #   rdoc-file=rational.c
  #   - rat.floor([ndigits])  ->  integer or rational
  # -->
  # Returns the largest number less than or equal to `rat` with a precision of
  # `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).floor      #=> 3
  #     Rational(2, 3).floor   #=> 0
  #     Rational(-3, 2).floor  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').floor(+1).to_f  #=> -123.5
  #     Rational('-123.456').floor(-1)       #=> -130
  #
  def floor: () -> Integer
           | (Integer digits) -> (Integer | Rational)

  # <!--
  #   rdoc-file=rational.c
  #   - hash()
  # -->
  #
  def hash: () -> Integer

  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Rational(2).inspect      #=> "(2/1)"
  #     Rational(-8, 6).inspect  #=> "(-4/3)"
  #     Rational('1/2').inspect  #=> "(1/2)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Returns the absolute value of `rat`.
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  # Rational#magnitude is an alias for Rational#abs.
  #
  alias magnitude abs

  def modulo: (Float) -> Float
            | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.negative?  ->  true or false
  # -->
  # Returns `true` if `rat` is less than 0.
  #
  def negative?: () -> bool

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=rational.c
  #   - rat.numerator  ->  integer
  # -->
  # Returns the numerator.
  #
  #     Rational(7).numerator        #=> 7
  #     Rational(7, 1).numerator     #=> 7
  #     Rational(9, -4).numerator    #=> -9
  #     Rational(-2, -10).numerator  #=> 1
  #
  def numerator: () -> Integer

  alias phase angle

  def polar: () -> [ Rational, Integer | Float ]

  # <!--
  #   rdoc-file=rational.c
  #   - rat.positive?  ->  true or false
  # -->
  # Returns `true` if `rat` is greater than 0.
  #
  def positive?: () -> bool

  # <!-- rdoc-file=rational.c -->
  # Performs division.
  #
  #     Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
  #     Rational(900)   / Rational(1)      #=> (900/1)
  #     Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
  #     Rational(9, 8)  / 4                #=> (9/32)
  #     Rational(20, 9) / 9.8              #=> 0.22675736961451246
  #
  def quo: (Float) -> Float
         | (Complex) -> Complex
         | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.rationalize       ->  self
  #   - rat.rationalize(eps)  ->  rational
  # -->
  # Returns a simpler approximation of the value if the optional argument `eps` is
  # given (rat-|eps| <= result <= rat+|eps|), self otherwise.
  #
  #     r = Rational(5033165, 16777216)
  #     r.rationalize                    #=> (5033165/16777216)
  #     r.rationalize(Rational('0.01'))  #=> (3/10)
  #     r.rationalize(Rational('0.1'))   #=> (1/3)
  #
  def rationalize: (?Numeric eps) -> Rational

  def real: () -> Rational

  def real?: () -> true

  def rect: () -> [ Rational, Numeric ]

  alias rectangular rect

  def remainder: (Float) -> Float
               | (Numeric) -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.round([ndigits] [, half: mode])  ->  integer or rational
  # -->
  # Returns `rat` rounded to the nearest value with a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).round      #=> 3
  #     Rational(2, 3).round   #=> 1
  #     Rational(-3, 2).round  #=> -2
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').round(+1).to_f  #=> -123.5
  #     Rational('-123.456').round(-1)       #=> -120
  #
  # The optional `half` keyword argument is available similar to Float#round.
  #
  #     Rational(25, 100).round(1, half: :up)    #=> (3/10)
  #     Rational(25, 100).round(1, half: :down)  #=> (1/5)
  #     Rational(25, 100).round(1, half: :even)  #=> (1/5)
  #     Rational(35, 100).round(1, half: :up)    #=> (2/5)
  #     Rational(35, 100).round(1, half: :down)  #=> (3/10)
  #     Rational(35, 100).round(1, half: :even)  #=> (2/5)
  #     Rational(-25, 100).round(1, half: :up)   #=> (-3/10)
  #     Rational(-25, 100).round(1, half: :down) #=> (-1/5)
  #     Rational(-25, 100).round(1, half: :even) #=> (-1/5)
  #
  def round: (?half: :up | :down | :even) -> Integer
           | (Integer digits, ?half: :up | :down | :even) -> (Integer | Rational)

  def step: (?Numeric limit, ?Numeric step) { (Rational) -> void } -> self
          | (?Numeric limit, ?Numeric step) -> Enumerator[Rational, self]
          | (?by: Numeric, ?to: Numeric) { (Rational) -> void } -> self
          | (?by: Numeric, ?to: Numeric) -> Enumerator[Rational, self]

  def to_c: () -> Complex

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_f  ->  float
  # -->
  # Returns the value as a Float.
  #
  #     Rational(2).to_f      #=> 2.0
  #     Rational(9, 4).to_f   #=> 2.25
  #     Rational(-3, 4).to_f  #=> -0.75
  #     Rational(20, 3).to_f  #=> 6.666666666666667
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_i  ->  integer
  # -->
  # Returns the truncated value as an integer.
  #
  # Equivalent to Rational#truncate.
  #
  #     Rational(2, 3).to_i    #=> 0
  #     Rational(3).to_i       #=> 3
  #     Rational(300.6).to_i   #=> 300
  #     Rational(98, 71).to_i  #=> 1
  #     Rational(-31, 2).to_i  #=> -15
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_r  ->  self
  # -->
  # Returns self.
  #
  #     Rational(2).to_r      #=> (2/1)
  #     Rational(-8, 6).to_r  #=> (-4/3)
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=rational.c
  #   - rat.to_s  ->  string
  # -->
  # Returns the value as a string.
  #
  #     Rational(2).to_s      #=> "2/1"
  #     Rational(-8, 6).to_s  #=> "-4/3"
  #     Rational('1/2').to_s  #=> "1/2"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=rational.c
  #   - rat.truncate([ndigits])  ->  integer or rational
  # -->
  # Returns `rat` truncated (toward zero) to a precision of `ndigits` decimal
  # digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at least
  # `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an integer.
  #
  #     Rational(3).truncate      #=> 3
  #     Rational(2, 3).truncate   #=> 0
  #     Rational(-3, 2).truncate  #=> -1
  #
  #       #    decimal      -  1  2  3 . 4  5  6
  #       #                   ^  ^  ^  ^   ^  ^
  #       #   precision      -3 -2 -1  0  +1 +2
  #
  #     Rational('-123.456').truncate(+1).to_f  #=> -123.4
  #     Rational('-123.456').truncate(-1)       #=> -120
  #
  def truncate: () -> Integer
              | (Integer ndigits) -> (Integer | Rational)

  def zero?: () -> bool
end

# <!-- rdoc-file=string.c -->
# A String object has an arbitrary sequence of bytes, typically representing
# text or binary data. A String object may be created using String::new or as
# literals.
#
# String objects differ from Symbol objects in that Symbol objects are designed
# to be used as identifiers, instead of text or data.
#
# You can create a String object explicitly with:
#
# *   A [string literal](doc/syntax/literals_rdoc.html#label-String+Literals).
# *   A [heredoc
#     literal](doc/syntax/literals_rdoc.html#label-Here+Document+Literals).
#
#
# You can convert certain objects to Strings with:
#
# *   Method [String](Kernel.html#method-i-String).
#
#
# Some String methods modify `self`. Typically, a method whose name ends with
# `!` modifies `self` and returns `self`; often a similarly named method
# (without the `!`) returns a new string.
#
# In general, if there exist both bang and non-bang version of method, the bang!
# mutates and the non-bang! does not. However, a method without a bang can also
# mutate, such as String#replace.
#
# ## Substitution Methods
#
# These methods perform substitutions:
#
# *   String#sub: One substitution (or none); returns a new string.
# *   String#sub!: One substitution (or none); returns `self`.
# *   String#gsub: Zero or more substitutions; returns a new string.
# *   String#gsub!: Zero or more substitutions; returns `self`.
#
#
# Each of these methods takes:
#
# *   A first argument, `pattern` (string or regexp), that specifies the
#     substring(s) to be replaced.
#
# *   Either of these:
#
#     *   A second argument, `replacement` (string or hash), that determines the
#         replacing string.
#     *   A block that will determine the replacing string.
#
#
#
# The examples in this section mostly use methods String#sub and String#gsub;
# the principles illustrated apply to all four substitution methods.
#
# **Argument `pattern`**
#
# Argument `pattern` is commonly a regular expression:
#
#     s = 'hello'
#     s.sub(/[aeiou]/, '*')  # => "h*llo"
#     s.gsub(/[aeiou]/, '*') # => "h*ll*"
#     s.gsub(/[aeiou]/, '')  # => "hll"
#     s.sub(/ell/, 'al')     # => "halo"
#     s.gsub(/xyzzy/, '*')   # => "hello"
#     'THX1138'.gsub(/\d+/, '00') # => "THX00"
#
# When `pattern` is a string, all its characters are treated as ordinary
# characters (not as regexp special characters):
#
#     'THX1138'.gsub('\d+', '00') # => "THX1138"
#
# **\String `replacement`**
#
# If `replacement` is a string, that string will determine the replacing string
# that is to be substituted for the matched text.
#
# Each of the examples above uses a simple string as the replacing string.
#
# String `replacement` may contain back-references to the pattern's captures:
#
# *   `\n` (*n* a non-negative integer) refers to `$n`.
# *   `\k<name>` refers to the named capture `name`.
#
#
# See regexp.rdoc for details.
#
# Note that within the string `replacement`, a character combination such as
# `$&` is treated as ordinary text, and not as a special match variable.
# However, you may refer to some special match variables using these
# combinations:
#
# *   `\&` and `\0` correspond to `$&`, which contains the complete matched
#     text.
# *   `\'` corresponds to `$'`, which contains string after match.
# *   `\`` corresponds to `$``, which contains string before match.
# *   `+` corresponds to `$+`, which contains last capture group.
#
#
# See regexp.rdoc for details.
#
# Note that `\\\` is interpreted as an escape, i.e., a single backslash.
#
# Note also that a string literal consumes backslashes. See [String
# Literals](doc/syntax/literals_rdoc.html#label-String+Literals) for details
# about string literals.
#
# A back-reference is typically preceded by an additional backslash. For
# example, if you want to write a back-reference `\&` in `replacement` with a
# double-quoted string literal, you need to write `"..\\\\&.."`.
#
# If you want to write a non-back-reference string `\&` in `replacement`, you
# need first to escape the backslash to prevent this method from interpreting it
# as a back-reference, and then you need to escape the backslashes again to
# prevent a string literal from consuming them: `"..\\\\\\\\&.."`.
#
# You may want to use the block form to avoid a lot of backslashes.
#
# **\Hash `replacement`**
#
# If argument `replacement` is a hash, and `pattern` matches one of its keys,
# the replacing string is the value for that key:
#
#     h = {'foo' => 'bar', 'baz' => 'bat'}
#     'food'.sub('foo', h) # => "bard"
#
# Note that a symbol key does not match:
#
#     h = {foo: 'bar', baz: 'bat'}
#     'food'.sub('foo', h) # => "d"
#
# **Block**
#
# In the block form, the current match string is passed to the block; the
# block's return value becomes the replacing string:
#
#      s = '@'
#     '1234'.gsub(/\d/) {|match| s.succ! } # => "ABCD"
#
# Special match variables such as `$1`, `$2`, `$``, `$&`, and `$'` are set
# appropriately.
#
# ## What's Here
#
# First, what's elsewhere. Class String:
#
# *   Inherits from [class
#     Object](Object.html#class-Object-label-What-27s+Here).
# *   Includes [module
#     Comparable](Comparable.html#module-Comparable-label-What-27s+Here).
#
#
# Here, class String provides methods that are useful for:
#
# *   [Creating a String](#class-String-label-Methods+for+Creating+a+String)
# *   [Frozen/Unfrozen
#     Strings](#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String)
# *   [Querying](#class-String-label-Methods+for+Querying)
# *   [Comparing](#class-String-label-Methods+for+Comparing)
# *   [Modifying a String](#class-String-label-Methods+for+Modifying+a+String)
# *   [Converting to New
#     String](#class-String-label-Methods+for+Converting+to+New+String)
# *   [Converting to
#     Non-String](#class-String-label-Methods+for+Converting+to+Non--5CString)
# *   [Iterating](#class-String-label-Methods+for+Iterating)
#
#
# ### Methods for Creating a String
#
#     ::new
# :       Returns a new string.
#
#     ::try_convert
# :       Returns a new string created from a given object.
#
#
#
# ### Methods for a Frozen/Unfrozen String
#
#     [#+string](#method-i-2B-40)
# :       Returns a string that is not frozen: `self`, if not frozen; `self.dup`
#         otherwise.
#
#     [#-string](#method-i-2D-40)
# :       Returns a string that is frozen: `self`, if already frozen;
#         `self.freeze` otherwise.
#
#     #freeze
# :       Freezes `self`, if not already frozen; returns `self`.
#
#
#
# ### Methods for Querying
#
# *Counts*
#
#     #length, #size
# :       Returns the count of characters (not bytes).
#
#     #empty?
# :       Returns `true` if `self.length` is zero; `false` otherwise.
#
#     #bytesize
# :       Returns the count of bytes.
#
#     #count
# :       Returns the count of substrings matching given strings.
#
#
#
# *Substrings*
#
#     [#=~](#method-i-3D~)
# :       Returns the index of the first substring that matches a given Regexp
#         or other object; returns `nil` if no match is found.
#
#     #index
# :       Returns the index of the *first* occurrence of a given substring;
#         returns `nil` if none found.
#
#     #rindex
# :       Returns the index of the *last* occurrence of a given substring;
#         returns `nil` if none found.
#
#     #include?
# :       Returns `true` if the string contains a given substring; `false`
#         otherwise.
#
#     #match
# :       Returns a MatchData object if the string matches a given Regexp; `nil`
#         otherwise.
#
#     #match?
# :       Returns `true` if the string matches a given Regexp; `false`
#         otherwise.
#
#     #start_with?
# :       Returns `true` if the string begins with any of the given substrings.
#
#     #end_with?
# :       Returns `true` if the string ends with any of the given substrings.
#
#
#
# *Encodings*
#
#     #encoding
# :       Returns the Encoding object that represents the encoding of the
#         string.
#
#     #unicode_normalized?
# :       Returns `true` if the string is in Unicode normalized form; `false`
#         otherwise.
#
#     #valid_encoding?
# :       Returns `true` if the string contains only characters that are valid
#         for its encoding.
#
#     #ascii_only?
# :       Returns `true` if the string has only ASCII characters; `false`
#         otherwise.
#
#
#
# *Other*
#
#     #sum
# :       Returns a basic checksum for the string: the sum of each byte.
#
#     #hash
# :       Returns the integer hash code.
#
#
#
# ### Methods for Comparing
#
#     [#==, #===](#method-i-3D-3D)
# :       Returns `true` if a given other string has the same content as `self`.
#
#     #eql?
# :       Returns `true` if the content is the same as the given other string.
#
#     [#<=>](#method-i-3C-3D-3E)
# :       Returns -1, 0, or 1 as a given other string is smaller than, equal to,
#         or larger than `self`.
#
#     #casecmp
# :       Ignoring case, returns -1, 0, or 1 as a given other string is smaller
#         than, equal to, or larger than `self`.
#
#     #casecmp?
# :       Returns `true` if the string is equal to a given string after Unicode
#         case folding; `false` otherwise.
#
#
#
# ### Methods for Modifying a String
#
# Each of these methods modifies `self`.
#
# *Insertion*
#
#     #insert
# :       Returns `self` with a given string inserted at a given offset.
#
#     #<<
# :       Returns `self` concatenated with a given string or integer.
#
#
#
# *Substitution*
#
#     #sub!
# :       Replaces the first substring that matches a given pattern with a given
#         replacement string; returns `self` if any changes, `nil` otherwise.
#
#     #gsub!
# :       Replaces each substring that matches a given pattern with a given
#         replacement string; returns `self` if any changes, `nil` otherwise.
#
#     #succ!, #next!
# :       Returns `self` modified to become its own successor.
#
#     #replace
# :       Returns `self` with its entire content replaced by a given string.
#
#     #reverse!
# :       Returns `self` with its characters in reverse order.
#
#     #setbyte
# :       Sets the byte at a given integer offset to a given value; returns the
#         argument.
#
#     #tr!
# :       Replaces specified characters in `self` with specified replacement
#         characters; returns `self` if any changes, `nil` otherwise.
#
#     #tr_s!
# :       Replaces specified characters in `self` with specified replacement
#         characters, removing duplicates from the substrings that were
#         modified; returns `self` if any changes, `nil` otherwise.
#
#
#
# *Casing*
#
#     #capitalize!
# :       Upcases the initial character and downcases all others; returns `self`
#         if any changes, `nil` otherwise.
#
#     #downcase!
# :       Downcases all characters; returns `self` if any changes, `nil`
#         otherwise.
#
#     #upcase!
# :       Upcases all characters; returns `self` if any changes, `nil`
#         otherwise.
#
#     #swapcase!
# :       Upcases each downcase character and downcases each upcase character;
#         returns `self` if any changes, `nil` otherwise.
#
#
#
# *Encoding*
#
#     #encode!
# :       Returns `self` with all characters transcoded from one given encoding
#         into another.
#
#     #unicode_normalize!
# :       Unicode-normalizes `self`; returns `self`.
#
#     #scrub!
# :       Replaces each invalid byte with a given character; returns `self`.
#
#     #force_encoding
# :       Changes the encoding to a given encoding; returns `self`.
#
#
#
# *Deletion*
#
#     #clear
# :       Removes all content, so that `self` is empty; returns `self`.
#
#     #slice!, #[]=
# :       Removes a substring determined by a given index, start/length, range,
#         regexp, or substring.
#
#     #squeeze!
# :       Removes contiguous duplicate characters; returns `self`.
#
#     #delete!
# :       Removes characters as determined by the intersection of substring
#         arguments.
#
#     #lstrip!
# :       Removes leading whitespace; returns `self` if any changes, `nil`
#         otherwise.
#
#     #rstrip!
# :       Removes trailing whitespace; returns `self` if any changes, `nil`
#         otherwise.
#
#     #strip!
# :       Removes leading and trailing whitespace; returns `self` if any
#         changes, `nil` otherwise.
#
#     #chomp!
# :       Removes trailing record separator, if found; returns `self` if any
#         changes, `nil` otherwise.
#
#     #chop!
# :       Removes trailing whitespace if found, otherwise removes the last
#         character; returns `self` if any changes, `nil` otherwise.
#
#
#
# ### Methods for Converting to New String
#
# Each of these methods returns a new String based on `self`, often just a
# modified copy of `self`.
#
# *Extension*
#
#     #*
# :       Returns the concatenation of multiple copies of `self`,
#
#     #+
# :       Returns the concatenation of `self` and a given other string.
#
#     #center
# :       Returns a copy of `self` centered between pad substring.
#
#     #concat
# :       Returns the concatenation of `self` with given other strings.
#
#     #prepend
# :       Returns the concatenation of a given other string with `self`.
#
#     #ljust
# :       Returns a copy of `self` of a given length, right-padded with a given
#         other string.
#
#     #rjust
# :       Returns a copy of `self` of a given length, left-padded with a given
#         other string.
#
#
#
# *Encoding*
#
#     #b
# :       Returns a copy of `self` with ASCII-8BIT encoding.
#
#     #scrub
# :       Returns a copy of `self` with each invalid byte replaced with a given
#         character.
#
#     #unicode_normalize
# :       Returns a copy of `self` with each character Unicode-normalized.
#
#     #encode
# :       Returns a copy of `self` with all characters transcoded from one given
#         encoding into another.
#
#
#
# *Substitution*
#
#     #dump
# :       Returns a copy of +self with all non-printing characters replaced by
#         xHH notation and all special characters escaped.
#
#     #undump
# :       Returns a copy of +self with all `\xNN` notation replace by `\uNNNN`
#         notation and all escaped characters unescaped.
#
#     #sub
# :       Returns a copy of `self` with the first substring matching a given
#         pattern replaced with a given replacement string;.
#
#     #gsub
# :       Returns a copy of `self` with each substring that matches a given
#         pattern replaced with a given replacement string.
#
#     #succ, #next
# :       Returns the string that is the successor to `self`.
#
#     #reverse
# :       Returns a copy of `self` with its characters in reverse order.
#
#     #tr
# :       Returns a copy of `self` with specified characters replaced with
#         specified replacement characters.
#
#     #tr_s
# :       Returns a copy of `self` with specified characters replaced with
#         specified replacement characters, removing duplicates from the
#         substrings that were modified.
#
#     #%
# :       Returns the string resulting from formatting a given object into
#         `self`
#
#
#
# *Casing*
#
#     #capitalize
# :       Returns a copy of `self` with the first character upcased and all
#         other characters downcased.
#
#     #downcase
# :       Returns a copy of `self` with all characters downcased.
#
#     #upcase
# :       Returns a copy of `self` with all characters upcased.
#
#     #swapcase
# :       Returns a copy of `self` with all upcase characters downcased and all
#         downcase characters upcased.
#
#
#
# *Deletion*
#
#     #delete
# :       Returns a copy of `self` with characters removed
#
#     #delete_prefix
# :       Returns a copy of `self` with a given prefix removed.
#
#     #delete_suffix
# :       Returns a copy of `self` with a given suffix removed.
#
#     #lstrip
# :       Returns a copy of `self` with leading whitespace removed.
#
#     #rstrip
# :       Returns a copy of `self` with trailing whitespace removed.
#
#     #strip
# :       Returns a copy of `self` with leading and trailing whitespace removed.
#
#     #chomp
# :       Returns a copy of `self` with a trailing record separator removed, if
#         found.
#
#     #chop
# :       Returns a copy of `self` with trailing whitespace or the last
#         character removed.
#
#     #squeeze
# :       Returns a copy of `self` with contiguous duplicate characters removed.
#
#     #[], #slice
# :       Returns a substring determined by a given index, start/length, or
#         range, or string.
#
#     #byteslice
# :       Returns a substring determined by a given index, start/length, or
#         range.
#
#     #chr
# :       Returns the first character.
#
#
#
# *Duplication*
#
#     #to_s, $to_str
# :       If `self` is a subclass of String, returns `self` copied into a
#         String; otherwise, returns `self`.
#
#
#
# ### Methods for Converting to Non-String
#
# Each of these methods converts the contents of `self` to a non-String.
#
# *Characters, Bytes, and Clusters*
#
#     #bytes
# :       Returns an array of the bytes in `self`.
#
#     #chars
# :       Returns an array of the characters in `self`.
#
#     #codepoints
# :       Returns an array of the integer ordinals in `self`.
#
#     #getbyte
# :       Returns an integer byte as determined by a given index.
#
#     #grapheme_clusters
# :       Returns an array of the grapheme clusters in `self`.
#
#
#
# *Splitting*
#
#     #lines
# :       Returns an array of the lines in `self`, as determined by a given
#         record separator.
#
#     #partition
# :       Returns a 3-element array determined by the first substring that
#         matches a given substring or regexp,
#
#     #rpartition
# :       Returns a 3-element array determined by the last substring that
#         matches a given substring or regexp,
#
#     #split
# :       Returns an array of substrings determined by a given delimiter --
#         regexp or string -- or, if a block given, passes those substrings to
#         the block.
#
#
#
# *Matching*
#
#     #scan
# :       Returns an array of substrings matching a given regexp or string, or,
#         if a block given, passes each matching substring to the  block.
#
#     #unpack
# :       Returns an array of substrings extracted from `self` according to a
#         given format.
#
#     #unpack1
# :       Returns the first substring extracted from `self` according to a given
#         format.
#
#
#
# *Numerics*
#
#     #hex
# :       Returns the integer value of the leading characters, interpreted as
#         hexadecimal digits.
#
#     #oct
# :       Returns the integer value of the leading characters, interpreted as
#         octal digits.
#
#     #ord
# :       Returns the integer ordinal of the first character in `self`.
#
#     #to_i
# :       Returns the integer value of leading characters, interpreted as an
#         integer.
#
#     #to_f
# :       Returns the floating-point value of leading characters, interpreted as
#         a floating-point number.
#
#
#
# *Strings and Symbols*
#
#     #inspect
# :       Returns copy of `self`, enclosed in double-quotes, with special
#         characters escaped.
#
#     #to_sym, #intern
# :       Returns the symbol corresponding to `self`.
#
#
#
# ### Methods for Iterating
#
#     #each_byte
# :       Calls the given block with each successive byte in `self`.
#
#     #each_char
# :       Calls the given block with each successive character in `self`.
#
#     #each_codepoint
# :       Calls the given block with each successive integer codepoint in
#         `self`.
#
#     #each_grapheme_cluster
# :       Calls the given block with each successive grapheme cluster in `self`.
#
#     #each_line
# :       Calls the given block with each successive line in `self`, as
#         determined by a given record separator.
#
#     #upto
# :       Calls the given block with each string value returned by successive
#         calls to #succ.
#
class String
  include Comparable

  # <!--
  #   rdoc-file=string.c
  #   - String.try_convert(object) -> object, new_string, or nil
  # -->
  # If `object` is a String object, returns `object`.
  #
  # Otherwise if `object` responds to `:to_str`, calls `object.to_str` and returns
  # the result.
  #
  # Returns `nil` if `object` does not respond to `:to_str`.
  #
  # Raises an exception unless `object.to_str` returns a String object.
  #
  def self.try_convert: (untyped obj) -> String?

  public

  # <!--
  #   rdoc-file=string.c
  #   - string % object -> new_string
  # -->
  # Returns the result of formatting `object` into the format specification `self`
  # (see Kernel#sprintf for formatting details):
  #
  #     "%05d" % 123 # => "00123"
  #
  # If `self` contains multiple substitutions, `object` must be an Array or Hash
  # containing the values to be substituted:
  #
  #     "%-5s: %016x" % [ "ID", self.object_id ] # => "ID   : 00002b054ec93168"
  #     "foo = %{foo}" % {foo: 'bar'} # => "foo = bar"
  #     "foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'} # => "foo = bar, baz = bat"
  #
  def %: (Hash[Symbol, untyped]) -> String
       | (Array[untyped]) -> String
       | (untyped arg) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string * integer -> new_string
  # -->
  # Returns a new String containing `integer` copies of `self`:
  #
  #     "Ho! " * 3 # => "Ho! Ho! Ho! "
  #     "Ho! " * 0 # => ""
  #
  def *: (int n) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string + other_string -> new_string
  # -->
  # Returns a new String containing `other_string` concatenated to `self`:
  #
  #     "Hello from " + self.to_s # => "Hello from main"
  #
  def +: (string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - +string -> new_string or self
  # -->
  # Returns `self` if `self` is not frozen.
  #
  # Otherwise. returns `self.dup`, which is not frozen.
  #
  def +@: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - -string -> frozen_string
  # -->
  # Returns a frozen, possibly pre-existing copy of the string.
  #
  # The returned String will be deduplicated as long as it does not have any
  # instance variables set on it.
  #
  def -@: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - string << object -> string
  # -->
  # Concatenates `object` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s << 'bar' # => "foobar"
  #     s          # => "foobar"
  #
  # If `object` is an Integer, the value is considered a codepoint and converted
  # to a character before concatenation:
  #
  #     s = 'foo'
  #     s << 33 # => "foo!"
  #
  # Related: String#concat, which takes multiple arguments.
  #
  def <<: (string | Integer str_or_codepoint) -> String

  # <!--
  #   rdoc-file=string.c
  #   - string <=> other_string -> -1, 0, 1, or nil
  # -->
  # Compares `self` and `other_string`, returning:
  #
  # *   -1 if `other_string` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string` is smaller.
  # *   `nil` if the two are incomparable.
  #
  #
  # Examples:
  #
  #     'foo' <=> 'foo' # => 0
  #     'foo' <=> 'food' # => -1
  #     'food' <=> 'foo' # => 1
  #     'FOO' <=> 'foo' # => -1
  #     'foo' <=> 'FOO' # => 1
  #     'foo' <=> 1 # => nil
  #
  def <=>: (string other) -> Integer
         | (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - string == object -> true or false
  #   - string === object -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of String but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  def ==: (untyped obj) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s == 'foo' # => true
  #     s == 'food' # => false
  #     s == 'FOO' # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #     "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false
  #
  # If `object` is not an instance of String but responds to `to_str`, then the
  # two strings are compared using `object.==`.
  #
  def ===: (untyped obj) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - string =~ regexp -> integer or nil
  #   - string =~ object -> integer or nil
  # -->
  # Returns the Integer index of the first substring that matches the given
  # `regexp`, or `nil` if no match found:
  #
  #     'foo' =~ /f/ # => 0
  #     'foo' =~ /o/ # => 1
  #     'foo' =~ /x/ # => nil
  #
  # Note: also updates [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # If the given `object` is not a Regexp, returns the value returned by `object
  # =~ self`.
  #
  # Note that `string =~ regexp` is different from `regexp =~ string` (see
  # [Regexp#=~](https://ruby-doc.org/core-2.7.1/Regexp.html#method-i-3D-7E)):
  #
  #     number= nil
  #     "no. 9" =~ /(?<number>\d+)/
  #     number # => nil (not assigned)
  #     /(?<number>\d+)/ =~ "no. 9"
  #     number #=> "9"
  #
  def =~: (untyped obj) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - string[index] -> new_string or nil
  #   - string[start, length] -> new_string or nil
  #   - string[range] -> new_string or nil
  #   - string[regexp, capture = 0] -> new_string or nil
  #   - string[substring] -> new_string or nil
  # -->
  # Returns the substring of `self` specified by the arguments.
  #
  # When the single Integer argument `index` is given, returns the 1-character
  # substring found in `self` at offset `index`:
  #
  #     'bar'[2] # => "r"
  #
  # Counts backward from the end of `self` if `index` is negative:
  #
  #     'foo'[-3] # => "f"
  #
  # Returns `nil` if `index` is out of range:
  #
  #     'foo'[3] # => nil
  #     'foo'[-4] # => nil
  #
  # When the two Integer arguments  `start` and `length` are given, returns the
  # substring of the given `length` found in `self` at offset `start`:
  #
  #     'foo'[0, 2] # => "fo"
  #     'foo'[0, 0] # => ""
  #
  # Counts backward from the end of `self` if `start` is negative:
  #
  #     'foo'[-2, 2] # => "oo"
  #
  # Special case: returns a new empty String if `start` is equal to the length of
  # `self`:
  #
  #     'foo'[3, 2] # => ""
  #
  # Returns `nil` if `start` is out of range:
  #
  #     'foo'[4, 2] # => nil
  #     'foo'[-4, 2] # => nil
  #
  # Returns the trailing substring of `self` if `length` is large:
  #
  #     'foo'[1, 50] # => "oo"
  #
  # Returns `nil` if `length` is negative:
  #
  #     'foo'[0, -1] # => nil
  #
  # When the single Range argument `range` is given, derives `start` and `length`
  # values from the given `range`, and returns values as above:
  #
  # *   `'foo'[0..1]` is equivalent to `'foo'[0, 2]`.
  # *   `'foo'[0...1]` is equivalent to `'foo'[0, 1]`.
  #
  #
  # When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
  # returns the first matching substring found in `self`, or `nil` if none found:
  #
  #     'foo'[/o/] # => "o"
  #     'foo'[/x/] # => nil
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/] # => "ell"
  #     s[/[aeiou](.)\1/, 0] # => "ell"
  #
  # If argument `capture` is given and not `0`, it should be either an Integer
  # capture group index or a String or Symbol capture group name; the method call
  # returns only the specified capture (see [Regexp
  # Capturing](Regexp.html#class-Regexp-label-Capturing)):
  #
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/, 1] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel] # => "e"
  #
  # If an invalid capture group index is given, `nil` is returned.  If an invalid
  # capture group name is given, `IndexError` is raised.
  #
  # When the single String argument `substring` is given, returns the substring
  # from `self` if found, otherwise `nil`:
  #
  #     'foo'['oo'] # => "oo"
  #     'foo'['xx'] # => nil
  #
  # String#slice is an alias for String#[].
  #
  def []: (int index) -> String?
        | (int start, int length) -> String?
        | (Range[Integer] | Range[Integer?] range) -> String?
        | (Regexp regexp) -> String?
        | (Regexp regexp, int | String capture) -> String?
        | (String match_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str[integer] = new_str
  #   - str[integer, integer] = new_str
  #   - str[range] = aString
  #   - str[regexp] = new_str
  #   - str[regexp, integer] = new_str
  #   - str[regexp, name] = new_str
  #   - str[other_str] = new_str
  # -->
  # Element Assignment---Replaces some or all of the content of *str*. The portion
  # of the string affected is determined using the same criteria as String#[]. If
  # the replacement string is not the same length as the text it is replacing, the
  # string will be adjusted accordingly. If the regular expression or string is
  # used as the index doesn't match a position in the string, IndexError is
  # raised. If the regular expression form is used, the optional second Integer
  # allows you to specify which portion of the match to replace (effectively using
  # the MatchData indexing rules. The forms that take an Integer will raise an
  # IndexError if the value is out of range; the Range form will raise a
  # RangeError, and the Regexp and String will raise an IndexError on negative
  # match.
  #
  def []=: (int pos, String new_str) -> String
         | (int begin_pos, int end_pos, String new_str) -> String
         | (Range[Integer] | Range[Integer?] range, String new_str) -> String
         | (Regexp regexp, String new_str) -> String
         | (Regexp regexp, int capture, String new_str) -> String
         | (Regexp regexp, String name, String new_str) -> String
         | (String other_str, String new_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.ascii_only?  -> true or false
  # -->
  # Returns true for a string which has only ASCII characters.
  #
  #     "abc".force_encoding("UTF-8").ascii_only?          #=> true
  #     "abc\u{6666}".force_encoding("UTF-8").ascii_only?  #=> false
  #
  def ascii_only?: () -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.b   -> str
  # -->
  # Returns a copied string whose encoding is ASCII-8BIT.
  #
  def b: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.bytes    -> an_array
  # -->
  # Returns an array of bytes in *str*.  This is a shorthand for
  # `str.each_byte.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_byte`.
  #
  def bytes: () -> Array[Integer]
           | () { (Integer byte) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - bytesize -> integer
  # -->
  # Returns the count  of bytes in `self`:
  #
  #     "\x80\u3042".bytesize # => 4
  #     "hello".bytesize # => 5
  #
  # Related: String#length.
  #
  def bytesize: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - byteslice(index, length = 1) -> string or nil
  #   - byteslice(range)             -> string or nil
  # -->
  # Returns a substring of `self`, or `nil` if the substring cannot be
  # constructed.
  #
  # With integer arguments `index` and `length` given, returns the substring
  # beginning at the given `index` of the given `length` (if possible), or `nil`
  # if `length` is negative or `index` falls outside of `self`:
  #
  #     s = '0123456789' # => "0123456789"
  #     s.byteslice(2)   # => "2"
  #     s.byteslice(200) # => nil
  #     s.byteslice(4, 3)  # => "456"
  #     s.byteslice(4, 30) # => "456789"
  #     s.byteslice(4, -1) # => nil
  #     s.byteslice(40, 2) # => nil
  #
  # In either case above, counts backwards from the end of `self` if `index` is
  # negative:
  #
  #     s = '0123456789'   # => "0123456789"
  #     s.byteslice(-4)    # => "6"
  #     s.byteslice(-4, 3) # => "678"
  #
  # With Range argument `range` given, returns `byteslice(range.begin,
  # range.size)`:
  #
  #     s = '0123456789'    # => "0123456789"
  #     s.byteslice(4..6)   # => "456"
  #     s.byteslice(-6..-4) # => "456"
  #     s.byteslice(5..2)   # => "" # range.size is zero.
  #     s.byteslice(40..42) # => nil
  #
  # In all cases, a returned string has the same encoding as `self`:
  #
  #     s.encoding              # => #<Encoding:UTF-8>
  #     s.byteslice(4).encoding # => #<Encoding:UTF-8>
  #
  def byteslice: (int start, ?int length) -> String?
               | (Range[Integer] | Range[Integer?] range) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - capitalize(*options) -> string
  # -->
  # Returns a string containing the characters in `self`; the first character is
  # upcased; the remaining characters are downcased:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize       # => "Hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#capitalize!.
  #
  def capitalize: () -> String
                | (:ascii | :lithuanian | :turkic) -> String
                | (:lithuanian, :turkic) -> String
                | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - capitalize!(*options) -> self or nil
  # -->
  # Upcases the first character in `self`; downcases the remaining characters;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'hello World!' # => "hello World!"
  #     s.capitalize!      # => "Hello world!"
  #     s                  # => "Hello world!"
  #     s.capitalize!      # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#capitalize.
  #
  def capitalize!: () -> String?
                 | (:ascii | :lithuanian | :turkic) -> String?
                 | (:lithuanian, :turkic) -> String?
                 | (:turkic, :lithuanian) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp(other_string) -> -1, 0, 1, or nil
  # -->
  # Compares `self.downcase` and `other_string.downcase`; returns:
  #
  # *   -1 if `other_string.downcase` is larger.
  # *   0 if the two are equal.
  # *   1 if `other_string.downcase` is smaller.
  # *   `nil` if the two are incomparable.
  #
  #
  # Examples:
  #
  #     'foo'.casecmp('foo') # => 0
  #     'foo'.casecmp('food') # => -1
  #     'food'.casecmp('foo') # => 1
  #     'FOO'.casecmp('foo') # => 0
  #     'foo'.casecmp('FOO') # => 0
  #     'foo'.casecmp(1) # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#casecmp?.
  #
  def casecmp: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - casecmp?(other_string) -> true, false, or nil
  # -->
  # Returns `true` if `self` and `other_string` are equal after Unicode case
  # folding, otherwise `false`:
  #
  #     'foo'.casecmp?('foo') # => true
  #     'foo'.casecmp?('food') # => false
  #     'food'.casecmp?('foo') # => false
  #     'FOO'.casecmp?('foo') # => true
  #     'foo'.casecmp?('FOO') # => true
  #
  # Returns `nil` if the two values are incomparable:
  #
  #     'foo'.casecmp?(1) # => nil
  #
  # See [Case Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#casecmp.
  #
  def casecmp?: (untyped other) -> bool?

  # <!--
  #   rdoc-file=string.c
  #   - str.center(width, padstr=' ')   -> new_str
  # -->
  # Centers `str` in `width`.  If `width` is greater than the length of `str`,
  # returns a new String of length `width` with `str` centered and padded with
  # `padstr`; otherwise, returns `str`.
  #
  #     "hello".center(4)         #=> "hello"
  #     "hello".center(20)        #=> "       hello        "
  #     "hello".center(20, '123') #=> "1231231hello12312312"
  #
  def center: (int width, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chars    -> an_array
  # -->
  # Returns an array of characters in *str*.  This is a shorthand for
  # `str.each_char.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_char`.
  #
  def chars: () -> Array[String]
           | () { (String char) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chomp(separator=$/)   -> new_str
  # -->
  # Returns a new String with the given record separator removed from the end of
  # *str* (if present). If `$/` has not been changed from the default Ruby record
  # separator, then `chomp` also removes carriage return characters (that is, it
  # will remove `\n`, `\r`, and `\r\n`). If `$/` is an empty string, it will
  # remove all trailing newlines from the string.
  #
  #     "hello".chomp                #=> "hello"
  #     "hello\n".chomp              #=> "hello"
  #     "hello\r\n".chomp            #=> "hello"
  #     "hello\n\r".chomp            #=> "hello\n"
  #     "hello\r".chomp              #=> "hello"
  #     "hello \n there".chomp       #=> "hello \n there"
  #     "hello".chomp("llo")         #=> "he"
  #     "hello\r\n\r\n".chomp('')    #=> "hello"
  #     "hello\r\n\r\r\n".chomp('')  #=> "hello\r\n\r"
  #
  def chomp: (?string separator) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chomp!(separator=$/)   -> str or nil
  # -->
  # Modifies *str* in place as described for String#chomp, returning *str*, or
  # `nil` if no modifications were made.
  #
  def chomp!: (?string separator) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.chop   -> new_str
  # -->
  # Returns a new String with the last character removed.  If the string ends with
  # `\r\n`, both characters are removed. Applying `chop` to an empty string
  # returns an empty string. String#chomp is often a safer alternative, as it
  # leaves the string unchanged if it doesn't end in a record separator.
  #
  #     "string\r\n".chop   #=> "string"
  #     "string\n\r".chop   #=> "string\n"
  #     "string\n".chop     #=> "string"
  #     "string".chop       #=> "strin"
  #     "x".chop.chop       #=> ""
  #
  def chop: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.chop!   -> str or nil
  # -->
  # Processes *str* as for String#chop, returning *str*, or `nil` if *str* is the
  # empty string.  See also String#chomp!.
  #
  def chop!: () -> String?

  # <!--
  #   rdoc-file=string.c
  #   - chr -> string
  # -->
  # Returns a string containing the first character of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.chr     # => "f"
  #
  def chr: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - clear -> self
  # -->
  # Removes the contents of `self`:
  #
  #     s = 'foo' # => "foo"
  #     s.clear   # => ""
  #
  def clear: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.codepoints   -> an_array
  # -->
  # Returns an array of the Integer ordinals of the characters in *str*.  This is
  # a shorthand for `str.each_codepoint.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_codepoint`.
  #
  def codepoints: () -> ::Array[Integer]
                | () { (Integer codepoint) -> void } -> String

  # <!--
  #   rdoc-file=string.c
  #   - concat(*objects) -> string
  # -->
  # Concatenates each object in `objects` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.concat('bar', 'baz') # => "foobarbaz"
  #     s                      # => "foobarbaz"
  #
  # For each given object `object` that is an Integer, the value is considered a
  # codepoint and converted to a character before concatenation:
  #
  #     s = 'foo'
  #     s.concat(32, 'bar', 32, 'baz') # => "foo bar baz"
  #
  # Related: String#<<, which takes a single argument.
  #
  def concat: (*string | Integer str_or_codepoint) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.count([other_str]+)   -> integer
  # -->
  # Each `other_str` parameter defines a set of characters to count.  The
  # intersection of these sets defines the characters to count in `str`.  Any
  # `other_str` that starts with a caret `^` is negated.  The sequence `c1-c2`
  # means all characters between c1 and c2.  The backslash character `\` can be
  # used to escape `^` or `-` and is otherwise ignored unless it appears at the
  # end of a sequence or the end of a `other_str`.
  #
  #     a = "hello world"
  #     a.count "lo"                   #=> 5
  #     a.count "lo", "o"              #=> 2
  #     a.count "hello", "^l"          #=> 4
  #     a.count "ej-m"                 #=> 4
  #
  #     "hello^world".count "\\^aeiou" #=> 4
  #     "hello-world".count "a\\-eo"   #=> 4
  #
  #     c = "hello world\\r\\n"
  #     c.count "\\"                   #=> 2
  #     c.count "\\A"                  #=> 0
  #     c.count "X-\\w"                #=> 3
  #
  def count: (string other_str, *string other_strs) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.crypt(salt_str)   -> new_str
  # -->
  # Returns the string generated by calling `crypt(3)` standard library function
  # with `str` and `salt_str`, in this order, as its arguments.  Please do not use
  # this method any longer.  It is legacy; provided only for backward
  # compatibility with ruby scripts in earlier days.  It is bad to use in
  # contemporary programs for several reasons:
  #
  # *   Behaviour of C's `crypt(3)` depends on the OS it is run.  The generated
  #     string lacks data portability.
  #
  # *   On some OSes such as Mac OS, `crypt(3)` never fails (i.e. silently ends up
  #     in unexpected results).
  #
  # *   On some OSes such as Mac OS, `crypt(3)` is not thread safe.
  #
  # *   So-called "traditional" usage of `crypt(3)` is very very very weak.
  #     According to its manpage, Linux's traditional `crypt(3)` output has only
  #     2**56 variations; too easy to brute force today.  And this is the default
  #     behaviour.
  #
  # *   In order to make things robust some OSes implement so-called "modular"
  #     usage. To go through, you have to do a complex build-up of the `salt_str`
  #     parameter, by hand. Failure in generation of a proper salt string tends
  #     not to yield any errors; typos in parameters are normally not detectable.
  #
  #     *   For instance, in the following example, the second invocation of
  #         String#crypt is wrong; it has a typo in "round=" (lacks "s").  However
  #         the call does not fail and something unexpected is generated.
  #
  #             "foo".crypt("$5$rounds=1000$salt$") # OK, proper usage
  #             "foo".crypt("$5$round=1000$salt$")  # Typo not detected
  #
  #
  # *   Even in the "modular" mode, some hash functions are considered archaic and
  #     no longer recommended at all; for instance module `$1$` is officially
  #     abandoned by its author: see http://phk.freebsd.dk/sagas/md5crypt_eol/ .
  #     For another instance module `$3$` is considered completely broken: see the
  #     manpage of FreeBSD.
  #
  # *   On some OS such as Mac OS, there is no modular mode. Yet, as written
  #     above, `crypt(3)` on Mac OS never fails. This means even if you build up a
  #     proper salt string it generates a traditional DES hash anyways, and there
  #     is no way for you to be aware of.
  #
  #         "foo".crypt("$5$rounds=1000$salt$") # => "$5fNPQMxC5j6."
  #
  #
  # If for some reason you cannot migrate to other secure contemporary password
  # hashing algorithms, install the string-crypt gem and `require 'string/crypt'`
  # to continue using it.
  #
  def crypt: (string salt_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete([other_str]+)   -> new_str
  # -->
  # Returns a copy of *str* with all characters in the intersection of its
  # arguments deleted. Uses the same rules for building the set of characters as
  # String#count.
  #
  #     "hello".delete "l","lo"        #=> "heo"
  #     "hello".delete "lo"            #=> "he"
  #     "hello".delete "aeiou", "^e"   #=> "hell"
  #     "hello".delete "ej-m"          #=> "ho"
  #
  def delete: (string other_str, *string other_strs) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete!([other_str]+)   -> str or nil
  # -->
  # Performs a `delete` operation in place, returning *str*, or `nil` if *str* was
  # not modified.
  #
  def delete!: (string other_str, *string other_strs) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_prefix(prefix) -> new_str
  # -->
  # Returns a copy of *str* with leading `prefix` deleted.
  #
  #     "hello".delete_prefix("hel") #=> "lo"
  #     "hello".delete_prefix("llo") #=> "hello"
  #
  def delete_prefix: (string prefix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_prefix!(prefix) -> self or nil
  # -->
  # Deletes leading `prefix` from *str*, returning `nil` if no change was made.
  #
  #     "hello".delete_prefix!("hel") #=> "lo"
  #     "hello".delete_prefix!("llo") #=> nil
  #
  def delete_prefix!: (string prefix) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_suffix(suffix) -> new_str
  # -->
  # Returns a copy of *str* with trailing `suffix` deleted.
  #
  #     "hello".delete_suffix("llo") #=> "he"
  #     "hello".delete_suffix("hel") #=> "hello"
  #
  def delete_suffix: (string suffix) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.delete_suffix!(suffix) -> self or nil
  # -->
  # Deletes trailing `suffix` from *str*, returning `nil` if no change was made.
  #
  #     "hello".delete_suffix!("llo") #=> "he"
  #     "hello".delete_suffix!("hel") #=> nil
  #
  def delete_suffix!: (string suffix) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - downcase(*options) -> string
  # -->
  # Returns a string containing the downcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase         # => "hello world!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#downcase!, String#upcase, String#upcase!.
  #
  def downcase: () -> String
              | (:ascii | :fold | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - downcase!(*options) -> self or nil
  # -->
  # Downcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.downcase!        # => "hello world!"
  #     s                  # => "hello world!"
  #     s.downcase!        # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#downcase, String#upcase, String#upcase!.
  #
  def downcase!: () -> String?
               | (:ascii | :fold | :lithuanian | :turkic) -> String?
               | (:lithuanian, :turkic) -> String?
               | (:turkic, :lithuanian) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - dump -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, with special
  # characters escaped, and with non-printing characters replaced by hexadecimal
  # notation:
  #
  #     "hello \n ''".dump    # => "\"hello \\n ''\""
  #     "\f\x00\xff\\\"".dump # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #
  # Related: String#undump (inverse of String#dump).
  #
  def dump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.each_byte {|integer| block }    -> str
  #   - str.each_byte                      -> an_enumerator
  # -->
  # Passes each byte in *str* to the given block, or returns an enumerator if no
  # block is given.
  #
  #     "hello".each_byte {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     104 101 108 108 111
  #
  def each_byte: () { (Integer byte) -> void } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_char {|cstr| block }    -> str
  #   - str.each_char                    -> an_enumerator
  # -->
  # Passes each character in *str* to the given block, or returns an enumerator if
  # no block is given.
  #
  #     "hello".each_char {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     h e l l o
  #
  def each_char: () { (String char) -> void } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_codepoint {|integer| block }    -> str
  #   - str.each_codepoint                       -> an_enumerator
  # -->
  # Passes the Integer ordinal of each character in *str*, also known as a
  # *codepoint* when applied to Unicode strings to the given block.  For encodings
  # other than UTF-8/UTF-16(BE|LE)/UTF-32(BE|LE), values are directly derived from
  # the binary representation of each character.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     "hello\u0639".each_codepoint {|c| print c, ' ' }
  #
  # *produces:*
  #
  #     104 101 108 108 111 1593
  #
  def each_codepoint: () { (Integer codepoint) -> void } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_grapheme_cluster {|cstr| block }    -> str
  #   - str.each_grapheme_cluster                    -> an_enumerator
  # -->
  # Passes each grapheme cluster in *str* to the given block, or returns an
  # enumerator if no block is given. Unlike String#each_char, this enumerates by
  # grapheme clusters defined by Unicode Standard Annex #29
  # http://unicode.org/reports/tr29/
  #
  #     "a\u0300".each_char.to_a.size #=> 2
  #     "a\u0300".each_grapheme_cluster.to_a.size #=> 1
  #
  def each_grapheme_cluster: () { (String grapheme) -> void } -> self
                           | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - str.each_line(separator=$/, chomp: false) {|substr| block } -> str
  #   - str.each_line(separator=$/, chomp: false)                   -> an_enumerator
  # -->
  # Splits *str* using the supplied parameter as the record separator (`$/` by
  # default), passing each substring in turn to the supplied block.  If a
  # zero-length record separator is supplied, the string is split into paragraphs
  # delimited by multiple successive newlines.
  #
  # If `chomp` is `true`, `separator` will be removed from the end of each line.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     "hello\nworld".each_line {|s| p s}
  #     # prints:
  #     #   "hello\n"
  #     #   "world"
  #
  #     "hello\nworld".each_line('l') {|s| p s}
  #     # prints:
  #     #   "hel"
  #     #   "l"
  #     #   "o\nworl"
  #     #   "d"
  #
  #     "hello\n\n\nworld".each_line('') {|s| p s}
  #     # prints
  #     #   "hello\n\n"
  #     #   "world"
  #
  #     "hello\nworld".each_line(chomp: true) {|s| p s}
  #     # prints:
  #     #   "hello"
  #     #   "world"
  #
  #     "hello\nworld".each_line('l', chomp: true) {|s| p s}
  #     # prints:
  #     #   "he"
  #     #   ""
  #     #   "o\nwor"
  #     #   "d"
  #
  def each_line: (?string separator, ?chomp: boolish) { (String line) -> void } -> self
               | (?string separator, ?chomp: boolish) -> Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - empty? -> true or false
  # -->
  # Returns `true` if the length of `self` is zero, `false` otherwise:
  #
  #     "hello".empty? # => false
  #     " ".empty? # => false
  #     "".empty? # => true
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=transcode.c
  #   - str.encode(encoding, **options)   -> str
  #   - str.encode(dst_encoding, src_encoding, **options)   -> str
  #   - str.encode(**options)   -> str
  # -->
  # The first form returns a copy of `str` transcoded to encoding `encoding`. The
  # second form returns a copy of `str` transcoded from src_encoding to
  # dst_encoding. The last form returns a copy of `str` transcoded to
  # `Encoding.default_internal`.
  #
  # By default, the first and second form raise Encoding::UndefinedConversionError
  # for characters that are undefined in the destination encoding, and
  # Encoding::InvalidByteSequenceError for invalid byte sequences in the source
  # encoding. The last form by default does not raise exceptions but uses
  # replacement strings.
  #
  # The `options` keyword arguments give details for conversion. The arguments
  # are:
  #
  # :invalid
  # :   If the value is `:replace`, #encode replaces invalid byte sequences in
  #     `str` with the replacement character.  The default is to raise the
  #     Encoding::InvalidByteSequenceError exception
  # :undef
  # :   If the value is `:replace`, #encode replaces characters which are
  #     undefined in the destination encoding with the replacement character. The
  #     default is to raise the Encoding::UndefinedConversionError.
  # :replace
  # :   Sets the replacement string to the given value. The default replacement
  #     string is "uFFFD" for Unicode encoding forms, and "?" otherwise.
  # :fallback
  # :   Sets the replacement string by the given object for undefined character.
  #     The object should be a Hash, a Proc, a Method, or an object which has []
  #     method. Its key is an undefined character encoded in the source encoding
  #     of current transcoder. Its value can be any encoding until it can be
  #     converted into the destination encoding of the transcoder.
  # :xml
  # :   The value must be `:text` or `:attr`. If the value is `:text` #encode
  #     replaces undefined characters with their (upper-case hexadecimal) numeric
  #     character references. '&', '<', and '>' are converted to "&amp;", "&lt;",
  #     and "&gt;", respectively. If the value is `:attr`, #encode also quotes the
  #     replacement result (using '"'), and replaces '"' with "&quot;".
  # :cr_newline
  # :   Replaces LF ("n") with CR ("r") if value is true.
  # :crlf_newline
  # :   Replaces LF ("n") with CRLF ("r\n") if value is true.
  # :universal_newline
  # :   Replaces CRLF ("r\n") and CR ("r") with LF ("n") if value is true.
  #
  def encode: (?encoding encoding, ?encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> String

  # <!--
  #   rdoc-file=transcode.c
  #   - str.encode!(encoding, **options)   -> str
  #   - str.encode!(dst_encoding, src_encoding, **options)   -> str
  # -->
  # The first form transcodes the contents of *str* from str.encoding to
  # `encoding`. The second form transcodes the contents of *str* from src_encoding
  # to dst_encoding. The `options` keyword arguments give details for conversion.
  # See String#encode for details. Returns the string even if no changes were
  # made.
  #
  def encode!: (?encoding encoding, ?encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> self

  # <!--
  #   rdoc-file=string.c
  #   - obj.encoding   -> encoding
  # -->
  # Returns the Encoding object that represents the encoding of obj.
  #
  def encoding: () -> Encoding

  # <!--
  #   rdoc-file=string.c
  #   - str.end_with?([suffixes]+)   -> true or false
  # -->
  # Returns true if `str` ends with one of the `suffixes` given.
  #
  #     "hello".end_with?("ello")               #=> true
  #
  #     # returns true if one of the +suffixes+ matches.
  #     "hello".end_with?("heaven", "ello")     #=> true
  #     "hello".end_with?("heaven", "paradise") #=> false
  #
  def end_with?: (*string suffixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - eql?(object) -> true or false
  # -->
  # Returns `true` if `object` has the same length and content; as `self`; `false`
  # otherwise:
  #
  #     s = 'foo'
  #     s.eql?('foo') # => true
  #     s.eql?('food') # => false
  #     s.eql?('FOO') # => false
  #
  # Returns `false` if the two strings' encodings are not compatible:
  #
  #     "\u{e4 f6 fc}".encode("ISO-8859-1").eql?("\u{c4 d6 dc}") # => false
  #
  def eql?: (untyped other) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.force_encoding(encoding)   -> str
  # -->
  # Changes the encoding to `encoding` and returns self.
  #
  def force_encoding: (string | Encoding encoding) -> self

  # <!--
  #   rdoc-file=string.c
  #   - freeze()
  # -->
  #
  def freeze: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - getbyte(index) -> integer
  # -->
  # Returns the byte at zero-based `index` as an integer:
  #
  #     s = 'abcde'  # => "abcde"
  #     s.getbyte(0) # => 97
  #     s.getbyte(1) # => 98
  #
  # Related: String#setbyte.
  #
  def getbyte: (int index) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - str.grapheme_clusters   -> an_array
  # -->
  # Returns an array of grapheme clusters in *str*.  This is a shorthand for
  # `str.each_grapheme_cluster.to_a`.
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_grapheme_cluster`.
  #
  def grapheme_clusters: () -> ::Array[::String]

  # <!--
  #   rdoc-file=string.c
  #   - gsub(pattern, replacement)   -> new_string
  #   - gsub(pattern) {|match| ... } -> new_string
  #   - gsub(pattern)                -> enumerator
  # -->
  # Returns a copy of `self` with all occurrences of the given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#sub!, String#gsub!.
  #
  def gsub: (Regexp | string pattern, string replacement) -> String
          | (Regexp | string pattern, Hash[String, String] hash) -> String
          | (Regexp | string pattern) { (String match) -> _ToS } -> String
          | (Regexp | string pattern) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - gsub!(pattern, replacement)   -> self or nil
  #   - gsub!(pattern) {|match| ... } -> self or nil
  #   - gsub!(pattern)                -> an_enumerator
  # -->
  # Performs the specified substring replacement(s) on `self`; returns `self` if
  # any replacement occurred, `nil` otherwise.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Returns an Enumerator if no `replacement` and no block given.
  #
  # Related: String#sub, String#gsub, String#sub!.
  #
  def gsub!: (Regexp | string pattern, string replacement) -> String?
           | (Regexp | string pattern, Hash[String, String] hash) -> String?
           | (Regexp | string pattern) { (String match) -> _ToS } -> String?
           | (Regexp | string pattern) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=string.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`. The value is based on the length,
  # content and encoding of `self`.
  #
  # Related: Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.hex   -> integer
  # -->
  # Treats leading characters from *str* as a string of hexadecimal digits (with
  # an optional sign and an optional `0x`) and returns the corresponding number.
  # Zero is returned on error.
  #
  #     "0x0a".hex     #=> 10
  #     "-1234".hex    #=> -4660
  #     "0".hex        #=> 0
  #     "wombat".hex   #=> 0
  #
  def hex: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - include? other_string -> true or false
  # -->
  # Returns `true` if `self` contains `other_string`, `false` otherwise:
  #
  #     s = 'foo'
  #     s.include?('f')    # => true
  #     s.include?('fo')   # => true
  #     s.include?('food') # => false
  #
  def include?: (string other_str) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - index(substring, offset = 0) -> integer or nil
  #   - index(regexp, offset = 0) -> integer or nil
  # -->
  # Returns the Integer index of the first occurrence of the given `substring`, or
  # `nil` if none found:
  #
  #     'foo'.index('f') # => 0
  #     'foo'.index('o') # => 1
  #     'foo'.index('oo') # => 1
  #     'foo'.index('ooo') # => nil
  #
  # Returns the Integer index of the first match for the given Regexp `regexp`, or
  # `nil` if none found:
  #
  #     'foo'.index(/f/) # => 0
  #     'foo'.index(/o/) # => 1
  #     'foo'.index(/oo/) # => 1
  #     'foo'.index(/ooo/) # => nil
  #
  # Integer argument `offset`, if given, specifies the position in the string to
  # begin the search:
  #
  #     'foo'.index('o', 1) # => 1
  #     'foo'.index('o', 2) # => 2
  #     'foo'.index('o', 3) # => nil
  #
  # If `offset` is negative, counts backward from the end of `self`:
  #
  #     'foo'.index('o', -1) # => 2
  #     'foo'.index('o', -2) # => 1
  #     'foo'.index('o', -3) # => 1
  #     'foo'.index('o', -4) # => nil
  #
  # Related: String#rindex.
  #
  def index: (Regexp | string substr_or_regexp, ?int offset) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - insert(index, other_string) -> self
  # -->
  # Inserts the given `other_string` into `self`; returns `self`.
  #
  # If the Integer `index` is positive, inserts `other_string` at offset `index`:
  #
  #     'foo'.insert(1, 'bar') # => "fbaroo"
  #
  # If the Integer `index` is negative, counts backward from the end of `self` and
  # inserts `other_string` at offset `index+1` (that is, *after* `self[index]`):
  #
  #     'foo'.insert(-2, 'bar') # => "fobaro"
  #
  def insert: (int index, string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - inspect -> string
  # -->
  # Returns a printable version of `self`, enclosed in double-quotes, and with
  # special characters escaped:
  #
  #     s = "foo\tbar\tbaz\n"
  #     # => "foo\tbar\tbaz\n"
  #     s.inspect
  #     # => "\"foo\\tbar\\tbaz\\n\""
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.intern   -> symbol
  #   - str.to_sym   -> symbol
  # -->
  # Returns the Symbol corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  def intern: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - length -> integer
  # -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     "\x80\u3042".length # => 2
  #     "hello".length # => 5
  #
  # String#size is an alias for String#length.
  #
  # Related: String#bytesize.
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.lines(separator=$/, chomp: false)  -> an_array
  # -->
  # Returns an array of lines in *str* split using the supplied record separator
  # (`$/` by default).  This is a shorthand for `str.each_line(separator,
  # getline_args).to_a`.
  #
  # If `chomp` is `true`, `separator` will be removed from the end of each line.
  #
  #     "hello\nworld\n".lines              #=> ["hello\n", "world\n"]
  #     "hello  world".lines(' ')           #=> ["hello ", " ", "world"]
  #     "hello\nworld\n".lines(chomp: true) #=> ["hello", "world"]
  #
  # If a block is given, which is a deprecated form, works the same as
  # `each_line`.
  #
  def lines: (?string separator, ?chomp: boolish) -> Array[String]

  # <!--
  #   rdoc-file=string.c
  #   - str.ljust(integer, padstr=' ')   -> new_str
  # -->
  # If *integer* is greater than the length of *str*, returns a new String of
  # length *integer* with *str* left justified and padded with *padstr*;
  # otherwise, returns *str*.
  #
  #     "hello".ljust(4)            #=> "hello"
  #     "hello".ljust(20)           #=> "hello               "
  #     "hello".ljust(20, '1234')   #=> "hello123412341234123"
  #
  def ljust: (int integer, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.lstrip   -> new_str
  # -->
  # Returns a copy of the receiver with leading whitespace removed. See also
  # String#rstrip and String#strip.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".lstrip   #=> "hello  "
  #     "hello".lstrip       #=> "hello"
  #
  def lstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.lstrip!   -> self or nil
  # -->
  # Removes leading whitespace from the receiver. Returns the altered receiver, or
  # `nil` if no change was made. See also String#rstrip! and String#strip!.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".lstrip!  #=> "hello  "
  #     "hello  ".lstrip!    #=> nil
  #     "hello".lstrip!      #=> nil
  #
  def lstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - match(pattern, offset = 0) -> matchdata or nil
  #   - match(pattern, offset = 0) {|matchdata| ... } -> object
  # -->
  # Returns a Matchdata object (or `nil`) based on `self` and the given `pattern`.
  #
  # Note: also updates [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # *   Computes `regexp` by converting `pattern` (if not already a Regexp).
  #         regexp = Regexp.new(pattern)
  #
  # *   Computes `matchdata`, which will be either a MatchData object or `nil`
  #     (see Regexp#match):
  #         matchdata = <tt>regexp.match(self)
  #
  #
  # With no block given, returns the computed `matchdata`:
  #
  #     'foo'.match('f') # => #<MatchData "f">
  #     'foo'.match('o') # => #<MatchData "o">
  #     'foo'.match('x') # => nil
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #
  #     'foo'.match('f', 1) # => nil
  #     'foo'.match('o', 1) # => #<MatchData "o">
  #
  # With a block given, calls the block with the computed `matchdata` and returns
  # the block's return value:
  #
  #     'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
  #     'foo'.match(/x/) {|matchdata| matchdata } # => nil
  #     'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil
  #
  def match: (Regexp | string pattern, ?int pos) -> MatchData?
           | [A] (Regexp | string pattern, ?int pos) { (MatchData) -> A } -> A

  # <!--
  #   rdoc-file=string.c
  #   - match?(pattern, offset = 0) -> true or false
  # -->
  # Returns `true` or `false` based on whether a match is found for `self` and
  # `pattern`.
  #
  # Note: does not update [Regexp-related global
  # variables](Regexp.html#class-Regexp-label-Special+global+variables).
  #
  # Computes `regexp` by converting `pattern` (if not already a Regexp).
  #     regexp = Regexp.new(pattern)
  #
  # Returns `true` if `self+.match(regexp)` returns a Matchdata object, `false`
  # otherwise:
  #
  #     'foo'.match?(/o/) # => true
  #     'foo'.match?('o') # => true
  #     'foo'.match?(/x/) # => false
  #
  # If Integer argument `offset` is given, the search begins at index `offset`:
  #     'foo'.match?('f', 1) # => false
  #     'foo'.match?('o', 1) # => true
  #
  def match?: (Regexp | string pattern, ?int pos) -> bool

  # <!-- rdoc-file=string.c -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty String is a new empty String:
  #
  #     ''.succ # => ""
  #
  # String#next is an alias for String#succ.
  #
  def next: () -> String

  # <!-- rdoc-file=string.c -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  # String#next! is an alias for String#succ!.
  #
  def next!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.oct   -> integer
  # -->
  # Treats leading characters of *str* as a string of octal digits (with an
  # optional sign) and returns the corresponding number.  Returns 0 if the
  # conversion fails.
  #
  #     "123".oct       #=> 83
  #     "-377".oct      #=> -255
  #     "bad".oct       #=> 0
  #     "0377bad".oct   #=> 255
  #
  # If `str` starts with `0`, radix indicators are honored. See Kernel#Integer.
  #
  def oct: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.ord   -> integer
  # -->
  # Returns the Integer ordinal of a one-character string.
  #
  #     "a".ord         #=> 97
  #
  def ord: () -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - str.partition(sep)              -> [head, sep, tail]
  #   - str.partition(regexp)           -> [head, match, tail]
  # -->
  # Searches *sep* or pattern (*regexp*) in the string and returns the part before
  # it, the match, and the part after it. If it is not found, returns two empty
  # strings and *str*.
  #
  #     "hello".partition("l")         #=> ["he", "l", "lo"]
  #     "hello".partition("x")         #=> ["hello", "", ""]
  #     "hello".partition(/.l/)        #=> ["h", "el", "lo"]
  #
  def partition: (Regexp | string sep_or_regexp) -> [ String, String, String ]

  # <!--
  #   rdoc-file=string.c
  #   - prepend(*other_strings)  -> string
  # -->
  # Prepends each string in `other_strings` to `self` and returns `self`:
  #
  #     s = 'foo'
  #     s.prepend('bar', 'baz') # => "barbazfoo"
  #     s                       # => "barbazfoo"
  #
  # Related: String#concat.
  #
  def prepend: (*string other_strs) -> String

  # <!-- rdoc-file=string.c -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  def replace: (string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - reverse -> string
  # -->
  # Returns a new string with the characters from `self` in reverse order.
  #
  #     'stressed'.reverse # => "desserts"
  #
  def reverse: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - reverse! -> self
  # -->
  # Returns `self` with its characters reversed:
  #
  #     s = 'stressed'
  #     s.reverse! # => "desserts"
  #     s          # => "desserts"
  #
  def reverse!: () -> self

  # <!--
  #   rdoc-file=string.c
  #   - rindex(substring, offset = self.length) -> integer or nil
  #   - rindex(regexp, offset = self.length) -> integer or nil
  # -->
  # Returns the Integer index of the *last* occurrence of the given `substring`,
  # or `nil` if none found:
  #
  #     'foo'.rindex('f') # => 0
  #     'foo'.rindex('o') # => 2
  #     'foo'.rindex('oo') # => 1
  #     'foo'.rindex('ooo') # => nil
  #
  # Returns the Integer index of the *last* match for the given Regexp `regexp`,
  # or `nil` if none found:
  #
  #     'foo'.rindex(/f/) # => 0
  #     'foo'.rindex(/o/) # => 2
  #     'foo'.rindex(/oo/) # => 1
  #     'foo'.rindex(/ooo/) # => nil
  #
  # The *last* match means starting at the possible last position, not the last of
  # longest matches.
  #
  #     'foo'.rindex(/o+/) # => 2
  #     $~ #=> #<MatchData "o">
  #
  # To get the last longest match, needs to combine with negative lookbehind.
  #
  #     'foo'.rindex(/(?<!o)o+/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Or String#index with negative lookforward.
  #
  #     'foo'.index(/o+(?!.*o)/) # => 1
  #     $~ #=> #<MatchData "oo">
  #
  # Integer argument `offset`, if given and non-negative, specifies the maximum
  # starting position in the
  #     string to _end_ the search:
  #
  #      'foo'.rindex('o', 0) # => nil
  #      'foo'.rindex('o', 1) # => 1
  #      'foo'.rindex('o', 2) # => 2
  #      'foo'.rindex('o', 3) # => 2
  #
  # If `offset` is a negative Integer, the maximum starting position in the string
  # to *end* the search is the sum of the string's length and `offset`:
  #
  #     'foo'.rindex('o', -1) # => 2
  #     'foo'.rindex('o', -2) # => 1
  #     'foo'.rindex('o', -3) # => nil
  #     'foo'.rindex('o', -4) # => nil
  #
  # Related: String#index.
  #
  def rindex: (string | Regexp substr_or_regexp, ?int pos) -> Integer?

  # <!--
  #   rdoc-file=string.c
  #   - str.rjust(integer, padstr=' ')   -> new_str
  # -->
  # If *integer* is greater than the length of *str*, returns a new String of
  # length *integer* with *str* right justified and padded with *padstr*;
  # otherwise, returns *str*.
  #
  #     "hello".rjust(4)            #=> "hello"
  #     "hello".rjust(20)           #=> "               hello"
  #     "hello".rjust(20, '1234')   #=> "123412341234123hello"
  #
  def rjust: (int integer, ?string padstr) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.rpartition(sep)             -> [head, sep, tail]
  #   - str.rpartition(regexp)          -> [head, match, tail]
  # -->
  # Searches *sep* or pattern (*regexp*) in the string from the end of the string,
  # and returns the part before it, the match, and the part after it. If it is not
  # found, returns two empty strings and *str*.
  #
  #     "hello".rpartition("l")         #=> ["hel", "l", "o"]
  #     "hello".rpartition("x")         #=> ["", "", "hello"]
  #     "hello".rpartition(/.l/)        #=> ["he", "ll", "o"]
  #
  # The match from the end means starting at the possible last position, not the
  # last of longest matches.
  #
  #     "hello".rpartition(/l+/)        #=> ["hel", "l", "o"]
  #
  # To partition at the last longest match, needs to combine with negative
  # lookbehind.
  #
  #     "hello".rpartition(/(?<!l)l+/)  #=> ["he", "ll", "o"]
  #
  # Or String#partition with negative lookforward.
  #
  #     "hello".partition(/l+(?!.*l)/)  #=> ["he", "ll", "o"]
  #
  def rpartition: (string | Regexp sep_or_regexp) -> [ String, String, String ]

  # <!--
  #   rdoc-file=string.c
  #   - str.rstrip   -> new_str
  # -->
  # Returns a copy of the receiver with trailing whitespace removed. See also
  # String#lstrip and String#strip.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".rstrip   #=> "  hello"
  #     "hello".rstrip       #=> "hello"
  #
  def rstrip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.rstrip!   -> self or nil
  # -->
  # Removes trailing whitespace from the receiver. Returns the altered receiver,
  # or `nil` if no change was made. See also String#lstrip! and String#strip!.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".rstrip!  #=> "  hello"
  #     "  hello".rstrip!    #=> nil
  #     "hello".rstrip!      #=> nil
  #
  def rstrip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - str.scan(pattern)                         -> array
  #   - str.scan(pattern) {|match, ...| block }   -> str
  # -->
  # Both forms iterate through *str*, matching the pattern (which may be a Regexp
  # or a String). For each match, a result is generated and either added to the
  # result array or passed to the block. If the pattern contains no groups, each
  # individual result consists of the matched string, `$&`.  If the pattern
  # contains groups, each individual result is itself an array containing one
  # entry per group.
  #
  #     a = "cruel world"
  #     a.scan(/\w+/)        #=> ["cruel", "world"]
  #     a.scan(/.../)        #=> ["cru", "el ", "wor"]
  #     a.scan(/(...)/)      #=> [["cru"], ["el "], ["wor"]]
  #     a.scan(/(..)(..)/)   #=> [["cr", "ue"], ["l ", "wo"]]
  #
  # And the block form:
  #
  #     a.scan(/\w+/) {|w| print "<<#{w}>> " }
  #     print "\n"
  #     a.scan(/(.)(.)/) {|x,y| print y, x }
  #     print "\n"
  #
  # *produces:*
  #
  #     <<cruel>> <<world>>
  #     rceu lowlr
  #
  def scan: (Regexp | string pattern) -> Array[String | Array[String]]
          | (Regexp | string pattern) { (String | Array[String]) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.scrub -> new_str
  #   - str.scrub(repl) -> new_str
  #   - str.scrub{|bytes|} -> new_str
  # -->
  # If the string is invalid byte sequence then replace invalid bytes with given
  # replacement character, else returns self. If block is given, replace invalid
  # bytes with returned value of the block.
  #
  #     "abc\u3042\x81".scrub #=> "abc\u3042\uFFFD"
  #     "abc\u3042\x81".scrub("*") #=> "abc\u3042*"
  #     "abc\u3042\xE3\x80".scrub{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"
  #
  def scrub: (?string repl) -> String
           | () { (String bytes) -> string } -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.scrub! -> str
  #   - str.scrub!(repl) -> str
  #   - str.scrub!{|bytes|} -> str
  # -->
  # If the string is invalid byte sequence then replace invalid bytes with given
  # replacement character, else returns self. If block is given, replace invalid
  # bytes with returned value of the block.
  #
  #     "abc\u3042\x81".scrub! #=> "abc\u3042\uFFFD"
  #     "abc\u3042\x81".scrub!("*") #=> "abc\u3042*"
  #     "abc\u3042\xE3\x80".scrub!{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"
  #
  def scrub!: (?string repl) -> self
            | () { (String bytes) -> string } -> self

  # <!--
  #   rdoc-file=string.c
  #   - setbyte(index, integer) -> integer
  # -->
  # Sets the byte at zero-based `index` to `integer`; returns `integer`:
  #
  #     s = 'abcde'      # => "abcde"
  #     s.setbyte(0, 98) # => 98
  #     s                # => "bbcde"
  #
  # Related: String#getbyte.
  #
  def setbyte: (int index, int integer) -> int

  # <!-- rdoc-file=string.c -->
  # Returns the count of characters (not bytes) in `self`:
  #
  #     "\x80\u3042".length # => 2
  #     "hello".length # => 5
  #
  # String#size is an alias for String#length.
  #
  # Related: String#bytesize.
  #
  alias size length

  # <!-- rdoc-file=string.c -->
  # Returns the substring of `self` specified by the arguments.
  #
  # When the single Integer argument `index` is given, returns the 1-character
  # substring found in `self` at offset `index`:
  #
  #     'bar'[2] # => "r"
  #
  # Counts backward from the end of `self` if `index` is negative:
  #
  #     'foo'[-3] # => "f"
  #
  # Returns `nil` if `index` is out of range:
  #
  #     'foo'[3] # => nil
  #     'foo'[-4] # => nil
  #
  # When the two Integer arguments  `start` and `length` are given, returns the
  # substring of the given `length` found in `self` at offset `start`:
  #
  #     'foo'[0, 2] # => "fo"
  #     'foo'[0, 0] # => ""
  #
  # Counts backward from the end of `self` if `start` is negative:
  #
  #     'foo'[-2, 2] # => "oo"
  #
  # Special case: returns a new empty String if `start` is equal to the length of
  # `self`:
  #
  #     'foo'[3, 2] # => ""
  #
  # Returns `nil` if `start` is out of range:
  #
  #     'foo'[4, 2] # => nil
  #     'foo'[-4, 2] # => nil
  #
  # Returns the trailing substring of `self` if `length` is large:
  #
  #     'foo'[1, 50] # => "oo"
  #
  # Returns `nil` if `length` is negative:
  #
  #     'foo'[0, -1] # => nil
  #
  # When the single Range argument `range` is given, derives `start` and `length`
  # values from the given `range`, and returns values as above:
  #
  # *   `'foo'[0..1]` is equivalent to `'foo'[0, 2]`.
  # *   `'foo'[0...1]` is equivalent to `'foo'[0, 1]`.
  #
  #
  # When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
  # returns the first matching substring found in `self`, or `nil` if none found:
  #
  #     'foo'[/o/] # => "o"
  #     'foo'[/x/] # => nil
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/] # => "ell"
  #     s[/[aeiou](.)\1/, 0] # => "ell"
  #
  # If argument `capture` is given and not `0`, it should be either an Integer
  # capture group index or a String or Symbol capture group name; the method call
  # returns only the specified capture (see [Regexp
  # Capturing](Regexp.html#class-Regexp-label-Capturing)):
  #
  #     s = 'hello there'
  #     s[/[aeiou](.)\1/, 1] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
  #     s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel] # => "e"
  #
  # If an invalid capture group index is given, `nil` is returned.  If an invalid
  # capture group name is given, `IndexError` is raised.
  #
  # When the single String argument `substring` is given, returns the substring
  # from `self` if found, otherwise `nil`:
  #
  #     'foo'['oo'] # => "oo"
  #     'foo'['xx'] # => nil
  #
  # String#slice is an alias for String#[].
  #
  alias slice []

  # <!--
  #   rdoc-file=string.c
  #   - slice!(index)               -> new_string or nil
  #   - slice!(start, length)       -> new_string or nil
  #   - slice!(range)               -> new_string or nil
  #   - slice!(regexp, capture = 0) -> new_string or nil
  #   - slice!(substring)           -> new_string or nil
  # -->
  # Removes the substring of `self` specified by the arguments; returns the
  # removed substring.
  #
  # See String#[] for details about the arguments that specify the substring.
  #
  # A few examples:
  #
  #     string = "This is a string"
  #     string.slice!(2)        #=> "i"
  #     string.slice!(3..6)     #=> " is "
  #     string.slice!(/s.*t/)   #=> "sa st"
  #     string.slice!("r")      #=> "r"
  #     string                  #=> "Thing"
  #
  def slice!: (int integer, ?int integer) -> String?
            | (Range[Integer] | Range[Integer?] range) -> String?
            | (Regexp regexp, ?int | String capture) -> String?
            | (String other_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.split(pattern=nil, [limit])                -> an_array
  #   - str.split(pattern=nil, [limit]) {|sub| block } -> str
  # -->
  # Divides *str* into substrings based on a delimiter, returning an array of
  # these substrings.
  #
  # If *pattern* is a String, then its contents are used as the delimiter when
  # splitting *str*. If *pattern* is a single space, *str* is split on whitespace,
  # with leading and trailing whitespace and runs of contiguous whitespace
  # characters ignored.
  #
  # If *pattern* is a Regexp, *str* is divided where the pattern matches. Whenever
  # the pattern matches a zero-length string, *str* is split into individual
  # characters. If *pattern* contains groups, the respective matches will be
  # returned in the array as well.
  #
  # If *pattern* is `nil`, the value of `$;` is used. If `$;` is `nil` (which is
  # the default), *str* is split on whitespace as if ' ' were specified.
  #
  # If the *limit* parameter is omitted, trailing null fields are suppressed. If
  # *limit* is a positive number, at most that number of split substrings will be
  # returned (captured groups will be returned as well, but are not counted
  # towards the limit). If *limit* is `1`, the entire string is returned as the
  # only entry in an array. If negative, there is no limit to the number of fields
  # returned, and trailing null fields are not suppressed.
  #
  # When the input `str` is empty an empty Array is returned as the string is
  # considered to have no fields to split.
  #
  #     " now's  the time ".split       #=> ["now's", "the", "time"]
  #     " now's  the time ".split(' ')  #=> ["now's", "the", "time"]
  #     " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]
  #     "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]
  #     "hello".split(//)               #=> ["h", "e", "l", "l", "o"]
  #     "hello".split(//, 3)            #=> ["h", "e", "llo"]
  #     "hi mom".split(%r{\s*})         #=> ["h", "i", "m", "o", "m"]
  #
  #     "mellow yellow".split("ello")   #=> ["m", "w y", "w"]
  #     "1,2,,3,4,,".split(',')         #=> ["1", "2", "", "3", "4"]
  #     "1,2,,3,4,,".split(',', 4)      #=> ["1", "2", "", "3,4,,"]
  #     "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]
  #
  #     "1:2:3".split(/(:)()()/, 2)     #=> ["1", ":", "", "", "2:3"]
  #
  #     "".split(',', -1)               #=> []
  #
  # If a block is given, invoke the block with each split substring.
  #
  def split: (?Regexp | string pattern, ?int limit) -> Array[String]
           | (?Regexp | string pattern, ?int limit) { (String) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.squeeze([other_str]*)    -> new_str
  # -->
  # Builds a set of characters from the *other_str* parameter(s) using the
  # procedure described for String#count. Returns a new string where runs of the
  # same character that occur in this set are replaced by a single character. If
  # no arguments are given, all runs of identical characters are replaced by a
  # single character.
  #
  #     "yellow moon".squeeze                  #=> "yelow mon"
  #     "  now   is  the".squeeze(" ")         #=> " now is the"
  #     "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
  #
  def squeeze: (*string other_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.squeeze!([other_str]*)   -> str or nil
  # -->
  # Squeezes *str* in place, returning either *str*, or `nil` if no changes were
  # made.
  #
  def squeeze!: (*string other_str) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - str.start_with?([prefixes]+)   -> true or false
  # -->
  # Returns true if `str` starts with one of the `prefixes` given. Each of the
  # `prefixes` should be a String or a Regexp.
  #
  #     "hello".start_with?("hell")               #=> true
  #     "hello".start_with?(/H/i)                 #=> true
  #
  #     # returns true if one of the prefixes matches.
  #     "hello".start_with?("heaven", "hell")     #=> true
  #     "hello".start_with?("heaven", "paradise") #=> false
  #
  def start_with?: (*string prefixes) -> bool

  # <!--
  #   rdoc-file=string.c
  #   - str.strip   -> new_str
  # -->
  # Returns a copy of the receiver with leading and trailing whitespace removed.
  #
  # Whitespace is defined as any of the following characters: null, horizontal
  # tab, line feed, vertical tab, form feed, carriage return, space.
  #
  #     "    hello    ".strip   #=> "hello"
  #     "\tgoodbye\r\n".strip   #=> "goodbye"
  #     "\x00\t\n\v\f\r ".strip #=> ""
  #     "hello".strip           #=> "hello"
  #
  def strip: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.strip!   -> self or nil
  # -->
  # Removes leading and trailing whitespace from the receiver. Returns the altered
  # receiver, or `nil` if there was no change.
  #
  # Refer to String#strip for the definition of whitespace.
  #
  #     "  hello  ".strip!  #=> "hello"
  #     "hello".strip!      #=> nil
  #
  def strip!: () -> self?

  # <!--
  #   rdoc-file=string.c
  #   - sub(pattern, replacement)   -> new_string
  #   - sub(pattern) {|match| ... } -> new_string
  # -->
  # Returns a copy of `self` with only the first occurrence (not all occurrences)
  # of the given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Related: String#sub!, String#gsub, String#gsub!.
  #
  def sub: (Regexp | string pattern, string | Hash[String, String] replacement) -> String
         | (Regexp | string pattern) { (String match) -> _ToS } -> String

  # <!--
  #   rdoc-file=string.c
  #   - sub!(pattern, replacement)   -> self or nil
  #   - sub!(pattern) {|match| ... } -> self or nil
  # -->
  # Returns `self` with only the first occurrence (not all occurrences) of the
  # given `pattern` replaced.
  #
  # See [Substitution Methods](#class-String-label-Substitution+Methods).
  #
  # Related: String#sub, String#gsub, String#gsub!.
  #
  def sub!: (Regexp | string pattern, string | Hash[String, String] replacement) -> self?
          | (Regexp | string pattern) { (String match) -> _ToS } -> String?

  # <!--
  #   rdoc-file=string.c
  #   - succ -> new_str
  # -->
  # Returns the successor to `self`. The successor is calculated by incrementing
  # characters.
  #
  # The first character to be incremented is the rightmost alphanumeric: or, if no
  # alphanumerics, the rightmost character:
  #
  #     'THX1138'.succ # => "THX1139"
  #     '<<koala>>'.succ # => "<<koalb>>"
  #     '***'.succ # => '**+'
  #
  # The successor to a digit is another digit, "carrying" to the next-left
  # character for a "rollover" from 9 to 0, and prepending another digit if
  # necessary:
  #
  #     '00'.succ # => "01"
  #     '09'.succ # => "10"
  #     '99'.succ # => "100"
  #
  # The successor to a letter is another letter of the same case, carrying to the
  # next-left character for a rollover, and prepending another same-case letter if
  # necessary:
  #
  #     'aa'.succ # => "ab"
  #     'az'.succ # => "ba"
  #     'zz'.succ # => "aaa"
  #     'AA'.succ # => "AB"
  #     'AZ'.succ # => "BA"
  #     'ZZ'.succ # => "AAA"
  #
  # The successor to a non-alphanumeric character is the next character in the
  # underlying character set's collating sequence, carrying to the next-left
  # character for a rollover, and prepending another character if necessary:
  #
  #     s = 0.chr * 3
  #     s # => "\x00\x00\x00"
  #     s.succ # => "\x00\x00\x01"
  #     s = 255.chr * 3
  #     s # => "\xFF\xFF\xFF"
  #     s.succ # => "\x01\x00\x00\x00"
  #
  # Carrying can occur between and among mixtures of alphanumeric characters:
  #
  #     s = 'zz99zz99'
  #     s.succ # => "aaa00aa00"
  #     s = '99zz99zz'
  #     s.succ # => "100aa00aa"
  #
  # The successor to an empty String is a new empty String:
  #
  #     ''.succ # => ""
  #
  # String#next is an alias for String#succ.
  #
  def succ: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - succ! -> self
  # -->
  # Equivalent to String#succ, but modifies `self` in place; returns `self`.
  #
  # String#next! is an alias for String#succ!.
  #
  def succ!: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.sum(n=16)   -> integer
  # -->
  # Returns a basic *n*-bit checksum of the characters in *str*, where *n* is the
  # optional Integer parameter, defaulting to 16. The result is simply the sum of
  # the binary value of each byte in *str* modulo `2**n - 1`. This is not a
  # particularly good checksum.
  #
  def sum: (?int n) -> Integer

  # <!--
  #   rdoc-file=string.c
  #   - swapcase(*options) -> string
  # -->
  # Returns a string containing the characters in `self`, with cases reversed;
  # each uppercase character is downcased; each lowercase character is upcased:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase         # => "hELLO wORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#swapcase!.
  #
  def swapcase: () -> String
              | (:ascii | :lithuanian | :turkic) -> String
              | (:lithuanian, :turkic) -> String
              | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - swapcase!(*options) -> self or nil
  # -->
  # Upcases each lowercase character in `self`; downcases uppercase character;
  # returns `self` if any changes were made, `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.swapcase!        # => "hELLO wORLD!"
  #     s                  # => "Hello World!"
  #     ''.swapcase!       # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#swapcase.
  #
  def swapcase!: () -> self?
               | (:ascii | :lithuanian | :turkic) -> self?
               | (:lithuanian, :turkic) -> self?
               | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - str.to_c  ->  complex
  # -->
  # Returns a complex which denotes the string form.  The parser ignores leading
  # whitespaces and trailing garbage.  Any digit sequences can be separated by an
  # underscore.  Returns zero for null or garbage string.
  #
  #     '9'.to_c           #=> (9+0i)
  #     '2.5'.to_c         #=> (2.5+0i)
  #     '2.5/1'.to_c       #=> ((5/2)+0i)
  #     '-3/2'.to_c        #=> ((-3/2)+0i)
  #     '-i'.to_c          #=> (0-1i)
  #     '45i'.to_c         #=> (0+45i)
  #     '3-4i'.to_c        #=> (3-4i)
  #     '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)
  #     '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)
  #     '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)
  #     'ruby'.to_c        #=> (0+0i)
  #
  # See Kernel.Complex.
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=string.c
  #   - to_f -> float
  # -->
  # Returns the result of interpreting leading characters in `self` as a Float:
  #
  #     '3.14159'.to_f  # => 3.14159
  #     '1.234e-2'.to_f # => 0.01234
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '3.14 (pi to two places)'.to_f # => 3.14
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_f # => 0.0
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=string.c
  #   - to_i(base = 10) -> integer
  # -->
  # Returns the result of interpreting leading characters in `self` as an integer
  # in the given `base` (which must be in (2..36)):
  #
  #     '123456'.to_i     # => 123456
  #     '123def'.to_i(16) # => 1195503
  #
  # Characters past a leading valid number (in the given `base`) are ignored:
  #
  #     '12.345'.to_i   # => 12
  #     '12345'.to_i(2) # => 1
  #
  # Returns zero if there is no leading valid number:
  #
  #     'abcdef'.to_i # => 0
  #     '2'.to_i(2)   # => 0
  #
  def to_i: (?int base) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - str.to_r  ->  rational
  # -->
  # Returns the result of interpreting leading characters in `str` as a rational.
  # Leading whitespace and extraneous characters past the end of a valid number
  # are ignored. Digit sequences can be separated by an underscore. If there is
  # not a valid number at the start of `str`, zero is returned.  This method never
  # raises an exception.
  #
  #     '  2  '.to_r       #=> (2/1)
  #     '300/2'.to_r       #=> (150/1)
  #     '-9.2'.to_r        #=> (-46/5)
  #     '-9.2e2'.to_r      #=> (-920/1)
  #     '1_234_567'.to_r   #=> (1234567/1)
  #     '21 June 09'.to_r  #=> (21/1)
  #     '21/06/09'.to_r    #=> (7/2)
  #     'BWV 1079'.to_r    #=> (0/1)
  #
  # NOTE: "0.3".to_r isn't the same as 0.3.to_r.  The former is equivalent to
  # "3/10".to_r, but the latter isn't so.
  #
  #     "0.3".to_r == 3/10r  #=> true
  #     0.3.to_r   == 3/10r  #=> false
  #
  # See also Kernel#Rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=string.c
  #   - to_s -> self or string
  # -->
  # Returns `self` if `self` is a String, or `self` converted to a String if
  # `self` is a subclass of String.
  #
  # String#to_str is an alias for String#to_s.
  #
  def to_s: () -> String

  # <!-- rdoc-file=string.c -->
  # Returns `self` if `self` is a String, or `self` converted to a String if
  # `self` is a subclass of String.
  #
  # String#to_str is an alias for String#to_s.
  #
  def to_str: () -> String

  # <!-- rdoc-file=string.c -->
  # Returns the Symbol corresponding to *str*, creating the symbol if it did not
  # previously exist. See Symbol#id2name.
  #
  #     "Koala".intern         #=> :Koala
  #     s = 'cat'.to_sym       #=> :cat
  #     s == :cat              #=> true
  #     s = '@cat'.to_sym      #=> :@cat
  #     s == :@cat             #=> true
  #
  # This can also be used to create symbols that cannot be represented using the
  # `:xxx` notation.
  #
  #     'cat and dog'.to_sym   #=> :"cat and dog"
  #
  def to_sym: () -> Symbol

  # <!--
  #   rdoc-file=string.c
  #   - str.tr(from_str, to_str)   => new_str
  # -->
  # Returns a copy of `str` with the characters in `from_str` replaced by the
  # corresponding characters in `to_str`.  If `to_str` is shorter than `from_str`,
  # it is padded with its last character in order to maintain the correspondence.
  #
  #     "hello".tr('el', 'ip')      #=> "hippo"
  #     "hello".tr('aeiou', '*')    #=> "h*ll*"
  #     "hello".tr('aeiou', 'AA*')  #=> "hAll*"
  #
  # Both strings may use the `c1-c2` notation to denote ranges of characters, and
  # `from_str` may start with a `^`, which denotes all characters except those
  # listed.
  #
  #     "hello".tr('a-y', 'b-z')    #=> "ifmmp"
  #     "hello".tr('^aeiou', '*')   #=> "*e**o"
  #
  # The backslash character `\` can be used to escape `^` or `-` and is otherwise
  # ignored unless it appears at the end of a range or the end of the `from_str`
  # or `to_str`:
  #
  #     "hello^world".tr("\\^aeiou", "*") #=> "h*ll**w*rld"
  #     "hello-world".tr("a\\-eo", "*")   #=> "h*ll**w*rld"
  #
  #     "hello\r\nworld".tr("\r", "")   #=> "hello\nworld"
  #     "hello\r\nworld".tr("\\r", "")  #=> "hello\r\nwold"
  #     "hello\r\nworld".tr("\\\r", "") #=> "hello\nworld"
  #
  #     "X['\\b']".tr("X\\", "")   #=> "['b']"
  #     "X['\\b']".tr("X-\\]", "") #=> "'b'"
  #
  def tr: (string from_str, string to_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.tr!(from_str, to_str)   -> str or nil
  # -->
  # Translates *str* in place, using the same rules as String#tr. Returns *str*,
  # or `nil` if no changes were made.
  #
  def tr!: (string from_str, string to_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - str.tr_s(from_str, to_str)   -> new_str
  # -->
  # Processes a copy of *str* as described under String#tr, then removes duplicate
  # characters in regions that were affected by the translation.
  #
  #     "hello".tr_s('l', 'r')     #=> "hero"
  #     "hello".tr_s('el', '*')    #=> "h*o"
  #     "hello".tr_s('el', 'hx')   #=> "hhxo"
  #
  def tr_s: (string from_str, string to_str) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.tr_s!(from_str, to_str)   -> str or nil
  # -->
  # Performs String#tr_s processing on *str* in place, returning *str*, or `nil`
  # if no changes were made.
  #
  def tr_s!: (string from_str, string to_str) -> String?

  # <!--
  #   rdoc-file=string.c
  #   - undump -> string
  # -->
  # Returns an unescaped version of `self`:
  #
  #     s_orig = "\f\x00\xff\\\""    # => "\f\u0000\xFF\\\""
  #     s_dumped = s_orig.dump       # => "\"\\f\\x00\\xFF\\\\\\\"\""
  #     s_undumped = s_dumped.undump # => "\f\u0000\xFF\\\""
  #     s_undumped == s_orig         # => true
  #
  # Related: String#dump (inverse of String#undump).
  #
  def undump: () -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalize(form=:nfc)
  # -->
  # Unicode Normalization---Returns a normalized form of `str`, using Unicode
  # normalizations NFC, NFD, NFKC, or NFKD. The normalization form used is
  # determined by `form`, which can be any of the four values `:nfc`, `:nfd`,
  # `:nfkc`, or `:nfkd`. The default is `:nfc`.
  #
  # If the string is not in a Unicode Encoding, then an Exception is raised. In
  # this context, 'Unicode Encoding' means any of UTF-8, UTF-16BE/LE, and
  # UTF-32BE/LE, as well as GB18030, UCS_2BE, and UCS_4BE. Anything other than
  # UTF-8 is implemented by converting to UTF-8, which makes it slower than UTF-8.
  #
  #     "a\u0300".unicode_normalize        #=> "\u00E0"
  #     "a\u0300".unicode_normalize(:nfc)  #=> "\u00E0"
  #     "\u00E0".unicode_normalize(:nfd)   #=> "a\u0300"
  #     "\xE0".force_encoding('ISO-8859-1').unicode_normalize(:nfd)
  #                                        #=> Encoding::CompatibilityError raised
  #
  def unicode_normalize: (?:nfc | :nfd | :nfkc | :nfkd) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalize!(form=:nfc)
  # -->
  # Destructive version of String#unicode_normalize, doing Unicode normalization
  # in place.
  #
  def unicode_normalize!: (?:nfc | :nfd | :nfkc | :nfkd) -> String

  # <!--
  #   rdoc-file=string.c
  #   - str.unicode_normalized?(form=:nfc)
  # -->
  # Checks whether `str` is in Unicode normalization form `form`, which can be any
  # of the four values `:nfc`, `:nfd`, `:nfkc`, or `:nfkd`. The default is `:nfc`.
  #
  # If the string is not in a Unicode Encoding, then an Exception is raised. For
  # details, see String#unicode_normalize.
  #
  #     "a\u0300".unicode_normalized?        #=> false
  #     "a\u0300".unicode_normalized?(:nfd)  #=> true
  #     "\u00E0".unicode_normalized?         #=> true
  #     "\u00E0".unicode_normalized?(:nfd)   #=> false
  #     "\xE0".force_encoding('ISO-8859-1').unicode_normalized?
  #                                          #=> Encoding::CompatibilityError raised
  #
  def unicode_normalized?: (?:nfc | :nfd | :nfkc | :nfkd) -> bool

  # <!--
  #   rdoc-file=pack.rb
  #   - str.unpack(format)    ->  anArray
  #   - str.unpack(format, offset: anInteger)    ->  anArray
  # -->
  # Decodes *str* (which may contain binary data) according to the format string,
  # returning an array of each value extracted. The format string consists of a
  # sequence of single-character directives, summarized in the table at the end of
  # this entry. Each directive may be followed by a number, indicating the number
  # of times to repeat with this directive. An asterisk (```*`'') will use up all
  # remaining elements. The directives `sSiIlL` may each be followed by an
  # underscore (```_`'') or exclamation mark (```!`'') to use the underlying
  # platform's native size for the specified type; otherwise, it uses a
  # platform-independent consistent size. Spaces are ignored in the format string.
  #
  # See also String#unpack1,  Array#pack.
  #
  #     "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
  #     "abc \0\0".unpack('a3a3')           #=> ["abc", " \000\000"]
  #     "abc \0abc \0".unpack('Z*Z*')       #=> ["abc ", "abc "]
  #     "aa".unpack('b8B8')                 #=> ["10000110", "01100001"]
  #     "aaa".unpack('h2H2c')               #=> ["16", "61", 97]
  #     "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]
  #     "now=20is".unpack('M*')             #=> ["now is"]
  #     "whole".unpack('xax2aX2aX1aX2a')    #=> ["h", "e", "l", "l", "o"]
  #
  # This table summarizes the various formats and the Ruby classes returned by
  # each.
  #
  #     Integer       |         |
  #     Directive     | Returns | Meaning
  #     ------------------------------------------------------------------
  #     C             | Integer | 8-bit unsigned (unsigned char)
  #     S             | Integer | 16-bit unsigned, native endian (uint16_t)
  #     L             | Integer | 32-bit unsigned, native endian (uint32_t)
  #     Q             | Integer | 64-bit unsigned, native endian (uint64_t)
  #     J             | Integer | pointer width unsigned, native endian (uintptr_t)
  #                   |         |
  #     c             | Integer | 8-bit signed (signed char)
  #     s             | Integer | 16-bit signed, native endian (int16_t)
  #     l             | Integer | 32-bit signed, native endian (int32_t)
  #     q             | Integer | 64-bit signed, native endian (int64_t)
  #     j             | Integer | pointer width signed, native endian (intptr_t)
  #                   |         |
  #     S_ S!         | Integer | unsigned short, native endian
  #     I I_ I!       | Integer | unsigned int, native endian
  #     L_ L!         | Integer | unsigned long, native endian
  #     Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #     J!            | Integer | uintptr_t, native endian (same with J)
  #                   |         |
  #     s_ s!         | Integer | signed short, native endian
  #     i i_ i!       | Integer | signed int, native endian
  #     l_ l!         | Integer | signed long, native endian
  #     q_ q!         | Integer | signed long long, native endian (ArgumentError
  #                   |         | if the platform has no long long type.)
  #     j!            | Integer | intptr_t, native endian (same with j)
  #                   |         |
  #     S> s> S!> s!> | Integer | same as the directives without ">" except
  #     L> l> L!> l!> |         | big endian
  #     I!> i!>       |         |
  #     Q> q> Q!> q!> |         | "S>" is the same as "n"
  #     J> j> J!> j!> |         | "L>" is the same as "N"
  #                   |         |
  #     S< s< S!< s!< | Integer | same as the directives without "<" except
  #     L< l< L!< l!< |         | little endian
  #     I!< i!<       |         |
  #     Q< q< Q!< q!< |         | "S<" is the same as "v"
  #     J< j< J!< j!< |         | "L<" is the same as "V"
  #                   |         |
  #     n             | Integer | 16-bit unsigned, network (big-endian) byte order
  #     N             | Integer | 32-bit unsigned, network (big-endian) byte order
  #     v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
  #     V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
  #                   |         |
  #     U             | Integer | UTF-8 character
  #     w             | Integer | BER-compressed integer (see Array#pack)
  #
  #     Float        |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     D d          | Float   | double-precision, native format
  #     F f          | Float   | single-precision, native format
  #     E            | Float   | double-precision, little-endian byte order
  #     e            | Float   | single-precision, little-endian byte order
  #     G            | Float   | double-precision, network (big-endian) byte order
  #     g            | Float   | single-precision, network (big-endian) byte order
  #
  #     String       |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     A            | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)
  #     a            | String  | arbitrary binary string
  #     Z            | String  | null-terminated string
  #     B            | String  | bit string (MSB first)
  #     b            | String  | bit string (LSB first)
  #     H            | String  | hex string (high nibble first)
  #     h            | String  | hex string (low nibble first)
  #     u            | String  | UU-encoded string
  #     M            | String  | quoted-printable, MIME encoding (see RFC2045)
  #     m            | String  | base64 encoded string (RFC 2045) (default)
  #                  |         | base64 encoded string (RFC 4648) if followed by 0
  #     P            | String  | pointer to a structure (fixed-length string)
  #     p            | String  | pointer to a null-terminated string
  #
  #     Misc.        |         |
  #     Directive    | Returns | Meaning
  #     -----------------------------------------------------------------
  #     @            | ---     | skip to the offset given by the length argument
  #     X            | ---     | skip backward one byte
  #     x            | ---     | skip forward one byte
  #
  # The keyword *offset* can be given to start the decoding after skipping the
  # specified amount of bytes:
  #     "abc".unpack("C*") # => [97, 98, 99]
  #     "abc".unpack("C*", offset: 2) # => [99]
  #     "abc".unpack("C*", offset: 4) # => offset outside of string (ArgumentError)
  #
  # HISTORY
  #
  # *   J, J! j, and j! are available since Ruby 2.3.
  # *   Q_, Q!, q_, and q! are available since Ruby 2.1.
  # *   I!<, i!<, I!>, and i!> are available since Ruby 1.9.3.
  #
  def unpack: (String format, ?offset: Integer) -> Array[Integer | Float | String | nil]

  # <!--
  #   rdoc-file=pack.rb
  #   - str.unpack1(format)    ->  obj
  #   - str.unpack1(format, offset: anInteger)    ->  obj
  # -->
  # Decodes *str* (which may contain binary data) according to the format string,
  # returning the first value extracted.
  #
  # See also String#unpack, Array#pack.
  #
  # Contrast with String#unpack:
  #
  #     "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
  #     "abc \0\0abc \0\0".unpack1('A6Z6')  #=> "abc"
  #
  # In that case data would be lost but often it's the case that the array only
  # holds one value, especially when unpacking binary data. For instance:
  #
  #     "\xff\x00\x00\x00".unpack("l")         #=>  [255]
  #     "\xff\x00\x00\x00".unpack1("l")        #=>  255
  #
  # Thus unpack1 is convenient, makes clear the intention and signals the expected
  # return value to those reading the code.
  #
  # The keyword *offset* can be given to start the decoding after skipping the
  # specified amount of bytes:
  #     "abc".unpack1("C*") # => 97
  #     "abc".unpack1("C*", offset: 2) # => 99
  #     "abc".unpack1("C*", offset: 4) # => offset outside of string (ArgumentError)
  #
  def unpack1: (String format) -> (Integer | Float | String | nil)

  # <!--
  #   rdoc-file=string.c
  #   - upcase(*options) -> string
  # -->
  # Returns a string containing the upcased characters in `self`:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase           # => "HELLO WORLD!"
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#upcase!, String#downcase, String#downcase!.
  #
  def upcase: () -> String
            | (:ascii | :lithuanian | :turkic) -> String
            | (:lithuanian, :turkic) -> String
            | (:turkic, :lithuanian) -> String

  # <!--
  #   rdoc-file=string.c
  #   - upcase!(*options) -> self or nil
  # -->
  # Upcases the characters in `self`; returns `self` if any changes were made,
  # `nil` otherwise:
  #
  #     s = 'Hello World!' # => "Hello World!"
  #     s.upcase!          # => "HELLO WORLD!"
  #     s                  # => "HELLO WORLD!"
  #     s.upcase!          # => nil
  #
  # The casing may be affected by the given `options`; see [Case
  # Mapping](doc/case_mapping_rdoc.html).
  #
  # Related: String#upcase, String#downcase, String#downcase!.
  #
  def upcase!: () -> self?
             | (:ascii | :lithuanian | :turkic) -> self?
             | (:lithuanian, :turkic) -> self?
             | (:turkic, :lithuanian) -> self?

  # <!--
  #   rdoc-file=string.c
  #   - upto(other_string, exclusive = false) {|string| ... } -> self
  #   - upto(other_string, exclusive = false) -> new_enumerator
  # -->
  # With a block given, calls the block with each String value returned by
  # successive calls to String#succ; the first value is `self`, the next is
  # `self.succ`, and so on; the sequence terminates when value `other_string` is
  # reached; returns `self`:
  #
  #     'a8'.upto('b6') {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5 b6
  #
  # If argument `exclusive` is given as a truthy object, the last value is
  # omitted:
  #
  #     'a8'.upto('b6', true) {|s| print s, ' ' } # => "a8"
  #
  # Output:
  #
  #     a8 a9 b0 b1 b2 b3 b4 b5
  #
  # If `other_string` would not be reached, does not call the block:
  #
  #     '25'.upto('5') {|s| fail s }
  #     'aa'.upto('a') {|s| fail s }
  #
  # With no block given, returns a new Enumerator:
  #
  #     'a8'.upto('b6') # => #<Enumerator: "a8":upto("b6")>
  #
  def upto: (string other_str, ?boolish exclusive) -> Enumerator[String, self]
          | (string other_str, ?boolish exclusive) { (String s) -> void } -> self

  # <!--
  #   rdoc-file=string.c
  #   - str.valid_encoding?  -> true or false
  # -->
  # Returns true for a string which is encoded correctly.
  #
  #     "\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true
  #     "\xc2".force_encoding("UTF-8").valid_encoding?      #=> false
  #     "\x80".force_encoding("UTF-8").valid_encoding?      #=> false
  #
  def valid_encoding?: () -> bool

  private

  # <!--
  #   rdoc-file=string.c
  #   - String.new(string = '') -> new_string
  #   - String.new(string = '', encoding: encoding) -> new_string
  #   - String.new(string = '', capacity: size) -> new_string
  # -->
  # Returns a new String that is a copy of `string`.
  #
  # With no arguments, returns the empty string with the Encoding `ASCII-8BIT`:
  #     s = String.new
  #     s # => ""
  #     s.encoding # => #<Encoding:ASCII-8BIT>
  #
  # With the single String argument `string`, returns a copy of `string` with the
  # same encoding as `string`:
  #     s = String.new("Que veut dire \u{e7}a?")
  #     s # => "Que veut dire \u{e7}a?"
  #     s.encoding # => #<Encoding:UTF-8>
  #
  # Literal strings like `""` or here-documents always use [script
  # encoding](Encoding.html#class-Encoding-label-Script+encoding), unlike
  # String.new.
  #
  # With keyword `encoding`, returns a copy of `str` with the specified encoding:
  #     s = String.new(encoding: 'ASCII')
  #     s.encoding # => #<Encoding:US-ASCII>
  #     s = String.new('foo', encoding: 'ASCII')
  #     s.encoding # => #<Encoding:US-ASCII>
  #
  # Note that these are equivalent:
  #     s0 = String.new('foo', encoding: 'ASCII')
  #     s1 = 'foo'.force_encoding('ASCII')
  #     s0.encoding == s1.encoding # => true
  #
  # With keyword `capacity`, returns a copy of `str`; the given `capacity` may set
  # the size of the internal buffer, which may affect performance:
  #     String.new(capacity: 1) # => ""
  #     String.new(capacity: 4096) # => ""
  #
  # The `string`, `encoding`, and `capacity` arguments may all be used together:
  #
  #     String.new('hello', encoding: 'UTF-8', capacity: 25)
  #
  def initialize: (?string str, ?encoding: encoding, ?capacity: int) -> void

  # <!--
  #   rdoc-file=string.c
  #   - replace(other_string) -> self
  # -->
  # Replaces the contents of `self` with the contents of `other_string`:
  #
  #     s = 'foo'        # => "foo"
  #     s.replace('bar') # => "bar"
  #
  alias initialize_copy replace
end

interface _ArefFromStringToString
  def []: (String) -> String
end

type String::encode_fallback = Hash[String, String] | Proc | Method | _ArefFromStringToString

# <!-- rdoc-file=proc.c -->
# A `Proc` object is an encapsulation of a block of code, which can be stored in
# a local variable, passed to a method or another Proc, and can be called. Proc
# is an essential concept in Ruby and a core of its functional programming
# features.
#
#     square = Proc.new {|x| x**2 }
#
#     square.call(3)  #=> 9
#     # shorthands:
#     square.(3)      #=> 9
#     square[3]       #=> 9
#
# Proc objects are *closures*, meaning they remember and can use the entire
# context in which they were created.
#
#     def gen_times(factor)
#       Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
#     end
#
#     times3 = gen_times(3)
#     times5 = gen_times(5)
#
#     times3.call(12)               #=> 36
#     times5.call(5)                #=> 25
#     times3.call(times5.call(4))   #=> 60
#
# ## Creation
#
# There are several methods to create a Proc
#
# *   Use the Proc class constructor:
#
#         proc1 = Proc.new {|x| x**2 }
#
# *   Use the Kernel#proc method as a shorthand of Proc.new:
#
#         proc2 = proc {|x| x**2 }
#
# *   Receiving a block of code into proc argument (note the `&`):
#
#         def make_proc(&block)
#           block
#         end
#
#         proc3 = make_proc {|x| x**2 }
#
# *   Construct a proc with lambda semantics using the Kernel#lambda method (see
#     below for explanations about lambdas):
#
#         lambda1 = lambda {|x| x**2 }
#
# *   Use the [Lambda proc
#     literal](doc/syntax/literals_rdoc.html#label-Lambda+Proc+Literals) syntax
#     (also constructs a proc with lambda semantics):
#
#         lambda2 = ->(x) { x**2 }
#
#
# ## Lambda and non-lambda semantics
#
# Procs are coming in two flavors: lambda and non-lambda (regular procs).
# Differences are:
#
# *   In lambdas, `return` and `break` means exit from this lambda;
# *   In non-lambda procs, `return` means exit from embracing method (and will
#     throw `LocalJumpError` if invoked outside the method);
# *   In non-lambda procs, `break` means exit from the method which the block
#     given for. (and will throw `LocalJumpError` if invoked after the method
#     returns);
# *   In lambdas, arguments are treated in the same way as in methods: strict,
#     with `ArgumentError` for mismatching argument number, and no additional
#     argument processing;
# *   Regular procs accept arguments more generously: missing arguments are
#     filled with `nil`, single Array arguments are deconstructed if the proc
#     has multiple arguments, and there is no error raised on extra arguments.
#
#
# Examples:
#
#     # +return+ in non-lambda proc, +b+, exits +m2+.
#     # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
#     #=> []
#
#     # +break+ in non-lambda proc, +b+, exits +m1+.
#     # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
#     #=> [:m2]
#
#     # +next+ in non-lambda proc, +b+, exits the block.
#     # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # Using +proc+ method changes the behavior as follows because
#     # The block is given for +proc+ method and embraced by +m2+.
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
#     #=> []
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
#     # break from proc-closure (LocalJumpError)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     # +return+, +break+ and +next+ in the stubby lambda exits the block.
#     # (+lambda+ method behaves same.)
#     # (The block is given for stubby lambda syntax and embraced by +m2+.)
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#     $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
#     #=> [:m1, :m2]
#
#     p = proc {|x, y| "x=#{x}, y=#{y}" }
#     p.call(1, 2)      #=> "x=1, y=2"
#     p.call([1, 2])    #=> "x=1, y=2", array deconstructed
#     p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
#     p.call(1)         #=> "x=1, y=", nil substituted instead of error
#
#     l = lambda {|x, y| "x=#{x}, y=#{y}" }
#     l.call(1, 2)      #=> "x=1, y=2"
#     l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
#     l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
#     l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)
#
#     def test_return
#       -> { return 3 }.call      # just returns from lambda into method body
#       proc { return 4 }.call    # returns from method
#       return 5
#     end
#
#     test_return # => 4, return from proc
#
# Lambdas are useful as self-sufficient functions, in particular useful as
# arguments to higher-order functions, behaving exactly like Ruby methods.
#
# Procs are useful for implementing iterators:
#
#     def test
#       [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
#                                 #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# Inside `map`, the block of code is treated as a regular (non-lambda) proc,
# which means that the internal arrays will be deconstructed to pairs of
# arguments, and `return` will exit from the method `test`. That would not be
# possible with a stricter lambda.
#
# You can tell a lambda from a regular proc by using the #lambda? instance
# method.
#
# Lambda semantics is typically preserved during the proc lifetime, including
# `&`-deconstruction to a block of code:
#
#     p = proc {|x, y| x }
#     l = lambda {|x, y| x }
#     [[1, 2], [3, 4]].map(&p) #=> [1, 3]
#     [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)
#
# The only exception is dynamic method definition: even if defined by passing a
# non-lambda proc, methods still have normal semantics of argument checking.
#
#     class C
#       define_method(:e, &proc {})
#     end
#     C.new.e(1,2)       #=> ArgumentError
#     C.new.method(:e).to_proc.lambda?   #=> true
#
# This exception ensures that methods never have unusual argument passing
# conventions, and makes it easy to have wrappers defining methods that behave
# as usual.
#
#     class C
#       def self.def2(name, &body)
#         define_method(name, &body)
#       end
#
#       def2(:f) {}
#     end
#     C.new.f(1,2)       #=> ArgumentError
#
# The wrapper `def2` receives *body* as a non-lambda proc, yet defines a method
# which has normal semantics.
#
# ## Conversion of other objects to procs
#
# Any object that implements the `to_proc` method can be converted into a proc
# by the `&` operator, and therefore can be consumed by iterators.
#
#     class Greeter
#       def initialize(greeting)
#         @greeting = greeting
#       end
#
#       def to_proc
#         proc {|name| "#{@greeting}, #{name}!" }
#       end
#     end
#
#     hi = Greeter.new("Hi")
#     hey = Greeter.new("Hey")
#     ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
#     ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]
#
# Of the Ruby core classes, this method is implemented by Symbol, Method, and
# Hash.
#
#     :to_s.to_proc.call(1)           #=> "1"
#     [1, 2].map(&:to_s)              #=> ["1", "2"]
#
#     method(:puts).to_proc.call(1)   # prints 1
#     [1, 2].each(&method(:puts))     # prints 1, 2
#
#     {test: 1}.to_proc.call(:test)       #=> 1
#     %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]
#
# ## Orphaned Proc
#
# `return` and `break` in a block exit a method. If a Proc object is generated
# from the block and the Proc object survives until the method is returned,
# `return` and `break` cannot work. In such case, `return` and `break` raises
# LocalJumpError. A Proc object in such situation is called as orphaned Proc
# object.
#
# Note that the method to exit is different for `return` and `break`. There is a
# situation that orphaned for `break` but not orphaned for `return`.
#
#     def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
#     def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok
#
#     def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
#     def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError
#
#     def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
#     def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError
#
# Since `return` and `break` exits the block itself in lambdas, lambdas cannot
# be orphaned.
#
# ## Numbered parameters
#
# Numbered parameters are implicitly defined block parameters intended to
# simplify writing short blocks:
#
#     # Explicit parameter:
#     %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]
#
#     # Implicit parameter:
#     %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
#     (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]
#
# Parameter names from `_1` to `_9` are supported:
#
#     [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
#     # => [120, 150, 180]
#
# Though, it is advised to resort to them wisely, probably limiting yourself to
# `_1` and `_2`, and to one-line blocks.
#
# Numbered parameters can't be used together with explicitly named ones:
#
#     [10, 20, 30].map { |x| _1**2 }
#     # SyntaxError (ordinary parameter is defined)
#
# To avoid conflicts, naming local variables or method arguments `_1`, `_2` and
# so on, causes a warning.
#
#     _1 = 'test'
#     # warning: `_1' is reserved as numbered parameter
#
# Using implicit numbered parameters affects block's arity:
#
#     p = proc { _1 + _2 }
#     l = lambda { _1 + _2 }
#     p.parameters     # => [[:opt, :_1], [:opt, :_2]]
#     p.arity          # => 2
#     l.parameters     # => [[:req, :_1], [:req, :_2]]
#     l.arity          # => 2
#
# Blocks with numbered parameters can't be nested:
#
#     %w[test me].each { _1.each_char { p _1 } }
#     # SyntaxError (numbered parameter is already used in outer block here)
#     # %w[test me].each { _1.each_char { p _1 } }
#     #                    ^~
#
# Numbered parameters were introduced in Ruby 2.7.
#
class Proc < Object
  def clone: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - prc.arity -> integer
  # -->
  # Returns the number of mandatory arguments. If the block is declared to take no
  # arguments, returns 0. If the block is known to take exactly n arguments,
  # returns n. If the block has optional arguments, returns -n-1, where n is the
  # number of mandatory arguments, with the exception for blocks that are not
  # lambdas and have only a finite number of optional arguments; in this latter
  # case, returns n. Keyword arguments will be considered as a single additional
  # argument, that argument being mandatory if any keyword argument is mandatory.
  # A #proc with no argument declarations is the same as a block declaring `||` as
  # its arguments.
  #
  #     proc {}.arity                  #=>  0
  #     proc { || }.arity              #=>  0
  #     proc { |a| }.arity             #=>  1
  #     proc { |a, b| }.arity          #=>  2
  #     proc { |a, b, c| }.arity       #=>  3
  #     proc { |*a| }.arity            #=> -1
  #     proc { |a, *b| }.arity         #=> -2
  #     proc { |a, *b, c| }.arity      #=> -3
  #     proc { |x:, y:, z:0| }.arity   #=>  1
  #     proc { |*a, x:, y:0| }.arity   #=> -2
  #
  #     proc   { |a=0| }.arity         #=>  0
  #     lambda { |a=0| }.arity         #=> -1
  #     proc   { |a=0, b| }.arity      #=>  1
  #     lambda { |a=0, b| }.arity      #=> -2
  #     proc   { |a=0, b=0| }.arity    #=>  0
  #     lambda { |a=0, b=0| }.arity    #=> -1
  #     proc   { |a, b=0| }.arity      #=>  1
  #     lambda { |a, b=0| }.arity      #=> -2
  #     proc   { |(a, b), c=0| }.arity #=>  1
  #     lambda { |(a, b), c=0| }.arity #=> -2
  #     proc   { |a, x:0, y:0| }.arity #=>  1
  #     lambda { |a, x:0, y:0| }.arity #=> -2
  #
  def arity: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - prc.binding    -> binding
  # -->
  # Returns the binding associated with *prc*.
  #
  #     def fred(param)
  #       proc {}
  #     end
  #
  #     b = fred(99)
  #     eval("param", b.binding)   #=> 99
  #
  def binding: () -> Binding

  # <!--
  #   rdoc-file=proc.c
  #   - prc.call(params,...)   -> obj
  #   - prc[params,...]        -> obj
  #   - prc.(params,...)       -> obj
  #   - prc.yield(params,...)  -> obj
  # -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  def call: (*untyped arg0) -> untyped

  # <!-- rdoc-file=proc.c -->
  # Invokes the block, setting the block's parameters to the values in *params*
  # using something close to method calling semantics. Returns the value of the
  # last expression evaluated in the block.
  #
  #     a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
  #     a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
  #     a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
  #     a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
  #     a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]
  #
  # Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
  # syntactic sugar to hide "call".
  #
  # For procs created using #lambda or `->()` an error is generated if the wrong
  # number of parameters are passed to the proc.  For procs created using Proc.new
  # or Kernel.proc, extra parameters are silently discarded and missing parameters
  # are set to `nil`.
  #
  #     a_proc = proc {|a,b| [a,b] }
  #     a_proc.call(1)   #=> [1, nil]
  #
  #     a_proc = lambda {|a,b| [a,b] }
  #     a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
  #
  # See also Proc#lambda?.
  #
  def []: (*untyped arg0) -> untyped

  # <!--
  #   rdoc-file=proc.c
  #   - prc.curry         -> a_proc
  #   - prc.curry(arity)  -> a_proc
  # -->
  # Returns a curried proc. If the optional *arity* argument is given, it
  # determines the number of arguments. A curried proc receives some arguments. If
  # a sufficient number of arguments are supplied, it passes the supplied
  # arguments to the original proc and returns the result. Otherwise, returns
  # another curried proc that takes the rest of arguments.
  #
  #     b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 6
  #     p b.curry(5)[1][2][3][4][5]  #=> 6
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 6
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)[1]              #=> 1
  #
  #     b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> wrong number of arguments (given 4, expected 3)
  #     p b.curry(5)                 #=> wrong number of arguments (given 5, expected 3)
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  #     p b.curry[1][2][3]           #=> 6
  #     p b.curry[1, 2][3, 4]        #=> 10
  #     p b.curry(5)[1][2][3][4][5]  #=> 15
  #     p b.curry(5)[1, 2][3, 4][5]  #=> 15
  #     p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)
  #
  #     b = proc { :foo }
  #     p b.curry[]                  #=> :foo
  #
  def curry: (?_ToInt arity) -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - prc.hash   ->  integer
  # -->
  # Returns a hash value corresponding to proc body.
  #
  # See also Object#hash.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=proc.c
  #   - Proc.new {|...| block } -> a_proc
  # -->
  # Creates a new Proc object, bound to the current context.
  #
  #     proc = Proc.new { "hello" }
  #     proc.call   #=> "hello"
  #
  # Raises ArgumentError if called without a block.
  #
  #     Proc.new    #=> ArgumentError
  #
  def initialize: () { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=proc.c
  #   - prc.lambda? -> true or false
  # -->
  # Returns `true` if a Proc object is lambda. `false` if non-lambda.
  #
  # The lambda-ness affects argument handling and the behavior of `return` and
  # `break`.
  #
  # A Proc object generated by `proc` ignores extra arguments.
  #
  #     proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]
  #
  # It provides `nil` for missing arguments.
  #
  #     proc {|a,b| [a,b] }.call(1)        #=> [1,nil]
  #
  # It expands a single array argument.
  #
  #     proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]
  #
  # A Proc object generated by `lambda` doesn't have such tricks.
  #
  #     lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
  #     lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError
  #
  # Proc#lambda? is a predicate for the tricks. It returns `true` if no tricks
  # apply.
  #
  #     lambda {}.lambda?            #=> true
  #     proc {}.lambda?              #=> false
  #
  # Proc.new is the same as `proc`.
  #
  #     Proc.new {}.lambda?          #=> false
  #
  # `lambda`, `proc` and Proc.new preserve the tricks of a Proc object given by
  # `&` argument.
  #
  #     lambda(&lambda {}).lambda?   #=> true
  #     proc(&lambda {}).lambda?     #=> true
  #     Proc.new(&lambda {}).lambda? #=> true
  #
  #     lambda(&proc {}).lambda?     #=> false
  #     proc(&proc {}).lambda?       #=> false
  #     Proc.new(&proc {}).lambda?   #=> false
  #
  # A Proc object generated by `&` argument has the tricks
  #
  #     def n(&b) b.lambda? end
  #     n {}                         #=> false
  #
  # The `&` argument preserves the tricks if a Proc object is given by `&`
  # argument.
  #
  #     n(&lambda {})                #=> true
  #     n(&proc {})                  #=> false
  #     n(&Proc.new {})              #=> false
  #
  # A Proc object converted from a method has no tricks.
  #
  #     def m() end
  #     method(:m).to_proc.lambda?   #=> true
  #
  #     n(&method(:m))               #=> true
  #     n(&method(:m).to_proc)       #=> true
  #
  # `define_method` is treated the same as method definition. The defined method
  # has no tricks.
  #
  #     class C
  #       define_method(:d) {}
  #     end
  #     C.new.d(1,2)       #=> ArgumentError
  #     C.new.method(:d).to_proc.lambda?   #=> true
  #
  # `define_method` always defines a method without the tricks, even if a
  # non-lambda Proc object is given. This is the only exception for which the
  # tricks are not preserved.
  #
  #     class C
  #       define_method(:e, &proc {})
  #     end
  #     C.new.e(1,2)       #=> ArgumentError
  #     C.new.method(:e).to_proc.lambda?   #=> true
  #
  # This exception ensures that methods never have tricks and makes it easy to
  # have wrappers to define methods that behave as usual.
  #
  #     class C
  #       def self.def2(name, &body)
  #         define_method(name, &body)
  #       end
  #
  #       def2(:f) {}
  #     end
  #     C.new.f(1,2)       #=> ArgumentError
  #
  # The wrapper *def2* defines a method which has no tricks.
  #
  def lambda?: () -> bool

  # <!--
  #   rdoc-file=proc.c
  #   - prc.parameters  -> array
  # -->
  # Returns the parameter information of this proc.
  #
  #     prc = lambda{|x, y=42, *other|}
  #     prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]
  #
  def parameters: () -> ::Array[[ Symbol, Symbol ]]

  # <!--
  #   rdoc-file=proc.c
  #   - prc.source_location  -> [String, Integer]
  # -->
  # Returns the Ruby source filename and line number containing this proc or `nil`
  # if this proc was not defined in Ruby (i.e. native).
  #
  def source_location: () -> [ String, Integer ]

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_proc -> proc
  # -->
  # Part of the protocol for converting objects to Proc objects. Instances of
  # class Proc simply return themselves.
  #
  def to_proc: () -> self

  # <!--
  #   rdoc-file=proc.c
  #   - prc.to_s   -> string
  # -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  def to_s: () -> String

  # <!-- rdoc-file=proc.c -->
  # Returns the unique identifier for this proc, along with an indication of where
  # the proc was defined.
  #
  def inspect: () -> String
end

# <!-- rdoc-file=object.c -->
# The Kernel module is included by class Object, so its methods are available in
# every Ruby object.
#
# The Kernel instance methods are documented in class Object while the module
# methods are documented here.  These methods are called without a receiver and
# thus can be called in functional form:
#
#     sprintf "%.1f", 1.234 #=> "1.2"
#
# ## What's Here
#
# Module Kernel provides methods that are useful for:
#
# *   [Converting](#module-Kernel-label-Converting)
# *   [Querying](#module-Kernel-label-Querying)
# *   [Exiting](#module-Kernel-label-Exiting)
# *   [Exceptions](#module-Kernel-label-Exceptions)
# *   [IO](#module-Kernel-label-IO)
# *   [Procs](#module-Kernel-label-Procs)
# *   [Tracing](#module-Kernel-label-Tracing)
# *   [Subprocesses](#module-Kernel-label-Subprocesses)
# *   [Loading](#module-Kernel-label-Loading)
# *   [Yielding](#module-Kernel-label-Yielding)
# *   [Random Values](#module-Kernel-label-Random+Values)
# *   [Other](#module-Kernel-label-Other)
#
#
# ### Converting
#
#     [#Array](#method-i-Array)
# :       Returns an Array based on the given argument.
#
#     [#Complex](#method-i-Complex)
# :       Returns a Complex based on the given arguments.
#
#     [#Float](#method-i-Float)
# :       Returns a Float based on the given arguments.
#
#     [#Hash](#method-i-Hash)
# :       Returns a Hash based on the given argument.
#
#     [#Integer](#method-i-Integer)
# :       Returns an Integer based on the given arguments.
#
#     [#Rational](#method-i-Rational)
# :       Returns a Rational based on the given arguments.
#
#     [#String](#method-i-String)
# :       Returns a String based on the given argument.
#
#
#
# ### Querying
#
#     [#__callee__](#method-i-__callee__)
# :       Returns the called name of the current method as a symbol.
#
#     [#__dir__](#method-i-__dir__)
# :       Returns the path to the directory from which the current method is
#         called.
#
#     [#__method__](#method-i-__method__)
# :       Returns the name of the current method as a symbol.
#
#     #autoload?
# :       Returns the file to be loaded when the given module is referenced.
#
#     #binding
# :       Returns a Binding for the context at the point of call.
#
#     #block_given?
# :       Returns `true` if a block was passed to the calling method.
#
#     #caller
# :       Returns the current execution stack as an array of strings.
#
#     #caller_locations
# :       Returns the current execution stack as an array of
#         Thread::Backtrace::Location objects.
#
#     #class
# :       Returns the class of `self`.
#
#     #frozen?
# :       Returns whether `self` is frozen.
#
#     #global_variables
# :       Returns an array of global variables as symbols.
#
#     #local_variables
# :       Returns an array of local variables as symbols.
#
#     #test
# :       Performs specified tests on the given single file or pair of files.
#
#
#
# ### Exiting
#
#     #abort
# :       Exits the current process after printing the given arguments.
#
#     #at_exit
# :       Executes the given block when the process exits.
#
#     #exit
# :       Exits the current process after calling any registered `at_exit`
#         handlers.
#
#     #exit!
# :       Exits the current process without calling any registered `at_exit`
#         handlers.
#
#
#
# ### Exceptions
#
#     #catch
# :       Executes the given block, possibly catching a thrown object.
#
#     #raise (aliased as #fail)
# :       Raises an exception based on the given arguments.
#
#     #throw
# :       Returns from the active catch block waiting for the given tag.
#
#
#
# ### IO
#
#     #gets
# :       Returns and assigns to `$_` the next line from the current input.
#
#     #open
# :       Creates an IO object connected to the given stream, file, or
#         subprocess.
#
#     #p
# :       Prints the given objects' inspect output to the standard output.
#
#     #pp
# :       Prints the given objects in pretty form.
#
#     #print
# :       Prints the given objects to standard output without a newline.
#
#     #printf
# :       Prints the string resulting from applying the given format string to
#         any additional arguments.
#
#     #putc
# :       Equivalent to <tt.$stdout.putc(object)</tt> for the given object.
#
#     #puts
# :       Equivalent to `$stdout.puts(*objects)` for the given objects.
#
#     #readline
# :       Similar to #gets, but raises an exception at the end of file.
#
#     #readlines
# :       Returns an array of the remaining lines from the current input.
#
#     #select
# :       Same as IO.select.
#
#
#
# ### Procs
#
#     #lambda
# :       Returns a lambda proc for the given block.
#
#     #proc
# :       Returns a new Proc; equivalent to Proc.new.
#
#
#
# ### Tracing
#
#     #set_trace_func
# :       Sets the given proc as the handler for tracing, or disables tracing if
#         given `nil`.
#
#     #trace_var
# :       Starts tracing assignments to the given global variable.
#
#     #untrace_var
# :       Disables tracing of assignments to the given global variable.
#
#
#
# ### Subprocesses
#
#     #`cmd`
# :       Returns the standard output of running `cmd` in a subshell.
#
#     #exec
# :       Replaces current process with a new process.
#
#     #fork
# :       Forks the current process into two processes.
#
#     #spawn
# :       Executes the given command and returns its pid without waiting for
#         completion.
#
#     #system
# :       Executes the given command in a subshell.
#
#
#
# ### Loading
#
#     #autoload
# :       Registers the given file to be loaded when the given constant is first
#         referenced.
#
#     #load
# :       Loads the given Ruby file.
#
#     #require
# :       Loads the given Ruby file unless it has already been loaded.
#
#     #require_relative
# :       Loads the Ruby file path relative to the calling file, unless it has
#         already been loaded.
#
#
#
# ### Yielding
#
#     #tap
# :       Yields `self` to the given block; returns `self`.
#
#     #then (aliased as #yield_self)
# :       Yields `self` to the block and returns the result of the block.
#
#
#
# ### Random Values
#
#     #rand
# :       Returns a pseudo-random floating point number strictly between 0.0 and
#         1.0.
#
#     #srand
# :       Seeds the pseudo-random number generator with the given number.
#
#
#
# ### Other
#
#     #eval
# :       Evaluates the given string as Ruby code.
#
#     #loop
# :       Repeatedly executes the given block.
#
#     #sleep
# :       Suspends the current thread for the given number of seconds.
#
#     #sprintf (aliased as #format)
# :       Returns the string resulting from applying the given format string to
#         any additional arguments.
#
#     #syscall
# :       Runs an operating system call.
#
#     #trap
# :       Specifies the handling of system signals.
#
#     #warn
# :       Issue a warning based on the given messages and options.
#
%a{annotate:rdoc:source:from=object.c}
module Kernel : BasicObject
  private

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller(start=1, length=nil)  -> array or nil
  #   - caller(range)                -> array or nil
  # -->
  # Returns the current execution stack---an array containing strings in the form
  # `file:line` or `file:line: in `method'`.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  #     def a(skip)
  #       caller(skip)
  #     end
  #     def b(skip)
  #       a(skip)
  #     end
  #     def c(skip)
  #       b(skip)
  #     end
  #     c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
  #     c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
  #     c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
  #     c(3)   #=> ["prog:13:in `<main>'"]
  #     c(4)   #=> []
  #     c(5)   #=> nil
  #
  def self?.caller: (Integer start_or_range, ?Integer length) -> ::Array[String]?
                  | (::Range[Integer] start_or_range) -> ::Array[String]?
                  | () -> ::Array[String]

  # <!--
  #   rdoc-file=vm_backtrace.c
  #   - caller_locations(start=1, length=nil)    -> array or nil
  #   - caller_locations(range)                  -> array or nil
  # -->
  # Returns the current execution stack---an array containing backtrace location
  # objects.
  #
  # See Thread::Backtrace::Location for more information.
  #
  # The optional *start* parameter determines the number of initial stack entries
  # to omit from the top of the stack.
  #
  # A second optional `length` parameter can be used to limit how many entries are
  # returned from the stack.
  #
  # Returns `nil` if *start* is greater than the size of current execution stack.
  #
  # Optionally you can pass a range, which will return an array containing the
  # entries within the specified range.
  #
  def self?.caller_locations: (?Integer start_or_range, ?Integer length) -> ::Array[Thread::Backtrace::Location]?
                            | (?::Range[Integer] start_or_range) -> ::Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=vm_eval.c
  #   - catch([tag]) {|tag| block }  -> obj
  # -->
  # `catch` executes its block. If `throw` is not called, the block executes
  # normally, and `catch` returns the value of the last expression evaluated.
  #
  #     catch(1) { 123 }            # => 123
  #
  # If `throw(tag2, val)` is called, Ruby searches up its stack for a `catch`
  # block whose `tag` has the same `object_id` as *tag2*. When found, the block
  # stops executing and returns *val* (or `nil` if no second argument was given to
  # `throw`).
  #
  #     catch(1) { throw(1, 456) }  # => 456
  #     catch(1) { throw(1) }       # => nil
  #
  # When `tag` is passed as the first argument, `catch` yields it as the parameter
  # of the block.
  #
  #     catch(1) {|x| x + 2 }       # => 3
  #
  # When no `tag` is given, `catch` yields a new unique object (as from
  # `Object.new`) as the block parameter. This object can then be used as the
  # argument to `throw`, and will match the correct `catch` block.
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_B, 123)
  #         puts "This puts is not reached"
  #       end
  #
  #       puts "This puts is displayed"
  #       456
  #     end
  #
  #     # => 456
  #
  #     catch do |obj_A|
  #       catch do |obj_B|
  #         throw(obj_A, 123)
  #         puts "This puts is still not reached"
  #       end
  #
  #       puts "Now this puts is also not reached"
  #       456
  #     end
  #
  #     # => 123
  #
  def self?.catch: [T] (T tag) { (T tag) -> untyped } -> untyped
                 | () { (Object tag) -> untyped } -> untyped

  # <!--
  #   rdoc-file=kernel.rb
  #   - obj.class    -> class
  # -->
  # Returns the class of *obj*. This method must always be called with an explicit
  # receiver, as #class is also a reserved word in Ruby.
  #
  #     1.class      #=> Integer
  #     self.class   #=> Object
  #
  def class: () -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - eval(string [, binding [, filename [,lineno]]])  -> obj
  # -->
  # Evaluates the Ruby expression(s) in *string*. If *binding* is given, which
  # must be a Binding object, the evaluation is performed in its context. If the
  # optional *filename* and *lineno* parameters are present, they will be used
  # when reporting syntax errors.
  #
  #     def get_binding(str)
  #       return binding
  #     end
  #     str = "hello"
  #     eval "str + ' Fred'"                      #=> "hello Fred"
  #     eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
  #
  def self?.eval: (String arg0, ?Binding arg1, ?String filename, ?Integer lineno) -> untyped

  # <!--
  #   rdoc-file=vm_eval.c
  #   - block_given?   -> true or false
  # -->
  # Returns `true` if `yield` would execute a block in the current context. The
  # `iterator?` form is mildly deprecated.
  #
  #     def try
  #       if block_given?
  #         yield
  #       else
  #         "no block"
  #       end
  #     end
  #     try                  #=> "no block"
  #     try { "hello" }      #=> "hello"
  #     try do "hello" end   #=> "hello"
  #
  def self?.block_given?: () -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - local_variables    -> array
  # -->
  # Returns the names of the current local variables.
  #
  #     fred = 1
  #     for i in 1..10
  #        # ...
  #     end
  #     local_variables   #=> [:fred, :i]
  #
  def self?.local_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=random.c
  #   - srand(number = Random.new_seed) -> old_seed
  # -->
  # Seeds the system pseudo-random number generator, with `number`. The previous
  # seed value is returned.
  #
  # If `number` is omitted, seeds the generator using a source of entropy provided
  # by the operating system, if available (/dev/urandom on Unix systems or the RSA
  # cryptographic provider on Windows), which is then combined with the time, the
  # process id, and a sequence number.
  #
  # srand may be used to ensure repeatable sequences of pseudo-random numbers
  # between different runs of the program. By setting the seed to a known value,
  # programs can be made deterministic during testing.
  #
  #     srand 1234               # => 268519324636777531569100071560086917274
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #     [ rand(10), rand(1000) ] # => [4, 664]
  #     srand 1234               # => 1234
  #     [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
  #
  def self?.srand: (?Numeric number) -> Numeric

  # <!--
  #   rdoc-file=process.c
  #   - Kernel.fork  [{ block }]   -> integer or nil
  #   - Process.fork [{ block }]   -> integer or nil
  # -->
  # Creates a subprocess. If a block is specified, that block is run in the
  # subprocess, and the subprocess terminates with a status of zero. Otherwise,
  # the `fork` call returns twice, once in the parent, returning the process ID of
  # the child, and once in the child, returning *nil*. The child process can exit
  # using Kernel.exit! to avoid running any `at_exit` functions. The parent
  # process should use Process.wait to collect the termination statuses of its
  # children or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # The thread calling fork is the only thread in the created child process. fork
  # doesn't copy other threads.
  #
  # If fork is not usable, Process.respond_to?(:fork) returns false.
  #
  # Note that fork(2) is not available on some platforms like Windows and NetBSD
  # 4. Therefore you should use spawn() instead of fork().
  #
  def self?.fork: () -> Integer?
                | () { () -> untyped } -> Integer?

  def initialize_copy: (self object) -> self

  # <!--
  #   rdoc-file=object.c
  #   - Array(arg)    -> array
  # -->
  # Returns `arg` as an Array.
  #
  # First tries to call `to_ary` on `arg`, then `to_a`. If `arg` does not respond
  # to `to_ary` or `to_a`, returns an Array of length 1 containing `arg`.
  #
  # If `to_ary` or `to_a` returns something other than an Array, raises a
  # TypeError.
  #
  #     Array(["a", "b"])  #=> ["a", "b"]
  #     Array(1..5)        #=> [1, 2, 3, 4, 5]
  #     Array(key: :value) #=> [[:key, :value]]
  #     Array(nil)         #=> []
  #     Array(1)           #=> [1]
  #
  def self?.Array: (NilClass x) -> [ ]
                 | [T] (::Array[T] x) -> ::Array[T]
                 | [T] (::Range[T] x) -> ::Array[T]
                 | [T] (_Each[T] x) -> ::Array[T]
                 | [K, V] (::Hash[K, V] x) -> ::Array[[ K, V ]]
                 | [T] (T x) -> ::Array[T]

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(x[, y], exception: true)  ->  numeric or nil
  # -->
  # Returns x+i*y;
  #
  #     Complex(1, 2)    #=> (1+2i)
  #     Complex('1+2i')  #=> (1+2i)
  #     Complex(nil)     #=> TypeError
  #     Complex(1, nil)  #=> TypeError
  #
  #     Complex(1, nil, exception: false)  #=> nil
  #     Complex('1+2', exception: false)   #=> nil
  #
  # Syntax of string form:
  #
  #     string form = extra spaces , complex , extra spaces ;
  #     complex = real part | [ sign ] , imaginary part
  #             | real part , sign , imaginary part
  #             | rational , "@" , rational ;
  #     real part = rational ;
  #     imaginary part = imaginary unit | unsigned rational , imaginary unit ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     imaginary unit = "i" | "I" | "j" | "J" ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit };
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See String#to_c.
  #
  def self?.Complex: (Numeric | String x, ?Numeric | String y, ?exception: bool exception) -> Complex

  # <!--
  #   rdoc-file=kernel.rb
  #   - Float(arg, exception: true)    -> float or nil
  # -->
  # Returns *arg* converted to a float. Numeric types are converted directly, and
  # with exception to String and `nil` the rest are converted using *arg*`.to_f`.
  # Converting a String with invalid characters will result in a ArgumentError.
  # Converting `nil` generates a TypeError.  Exceptions can be suppressed by
  # passing `exception: false`.
  #
  #     Float(1)                 #=> 1.0
  #     Float("123.456")         #=> 123.456
  #     Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
  #     Float(nil)               #=> TypeError: can't convert nil into Float
  #     Float("123.0_badstring", exception: false)  #=> nil
  #
  def self?.Float: (Numeric | String x, ?exception: bool exception) -> Float

  # <!--
  #   rdoc-file=object.c
  #   - Hash(arg)    -> hash
  # -->
  # Converts *arg* to a Hash by calling *arg*`.to_hash`. Returns an empty Hash
  # when *arg* is `nil` or `[]`.
  #
  #     Hash([])          #=> {}
  #     Hash(nil)         #=> {}
  #     Hash(key: :value) #=> {:key => :value}
  #     Hash([1, 2, 3])   #=> TypeError
  #
  def self?.Hash: [K, V] (Object x) -> ::Hash[K, V]

  # <!--
  #   rdoc-file=object.c
  #   - Integer(arg, base=0, exception: true)    -> integer or nil
  # -->
  # Converts *arg* to an Integer. Numeric types are converted directly (with
  # floating point numbers being truncated).  *base* (0, or between 2 and 36) is a
  # base for integer string representation.  If *arg* is a String, when *base* is
  # omitted or equals zero, radix indicators (`0`, `0b`, and `0x`) are honored. In
  # any case, strings should consist only of one or more digits, except for that a
  # sign, one underscore between two digits, and leading/trailing spaces are
  # optional.  This behavior is different from that of String#to_i.  Non string
  # values will be converted by first trying `to_int`, then `to_i`.
  #
  # Passing `nil` raises a TypeError, while passing a String that does not conform
  # with numeric representation raises an ArgumentError. This behavior can be
  # altered by passing `exception: false`, in this case a not convertible value
  # will return `nil`.
  #
  #     Integer(123.999)    #=> 123
  #     Integer("0x1a")     #=> 26
  #     Integer(Time.new)   #=> 1204973019
  #     Integer("0930", 10) #=> 930
  #     Integer("111", 2)   #=> 7
  #     Integer(" +1_0 ")   #=> 10
  #     Integer(nil)        #=> TypeError: can't convert nil into Integer
  #     Integer("x")        #=> ArgumentError: invalid value for Integer(): "x"
  #
  #     Integer("x", exception: false)        #=> nil
  #
  def self?.Integer: (Numeric | String arg, ?exception: bool exception) -> Integer
                   | (String arg, ?Integer base, ?exception: bool exception) -> Integer

  # <!--
  #   rdoc-file=rational.c
  #   - Rational(x, y, exception: true)  ->  rational or nil
  #   - Rational(arg, exception: true)   ->  rational or nil
  # -->
  # Returns `x/y` or `arg` as a Rational.
  #
  #     Rational(2, 3)   #=> (2/3)
  #     Rational(5)      #=> (5/1)
  #     Rational(0.5)    #=> (1/2)
  #     Rational(0.3)    #=> (5404319552844595/18014398509481984)
  #
  #     Rational("2/3")  #=> (2/3)
  #     Rational("0.3")  #=> (3/10)
  #
  #     Rational("10 cents")  #=> ArgumentError
  #     Rational(nil)         #=> TypeError
  #     Rational(1, nil)      #=> TypeError
  #
  #     Rational("10 cents", exception: false)  #=> nil
  #
  # Syntax of the string form:
  #
  #     string form = extra spaces , rational , extra spaces ;
  #     rational = [ sign ] , unsigned rational ;
  #     unsigned rational = numerator | numerator , "/" , denominator ;
  #     numerator = integer part | fractional part | integer part , fractional part ;
  #     denominator = digits ;
  #     integer part = digits ;
  #     fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
  #     sign = "-" | "+" ;
  #     digits = digit , { digit | "_" , digit } ;
  #     digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
  #     extra spaces = ? \s* ? ;
  #
  # See also String#to_r.
  #
  def self?.Rational: (Numeric | String | Object x, ?Numeric | String y, ?exception: bool exception) -> Rational

  # <!--
  #   rdoc-file=object.c
  #   - String(arg)   -> string
  # -->
  # Returns *arg* as a String.
  #
  # First tries to call its `to_str` method, then its `to_s` method.
  #
  #     String(self)        #=> "main"
  #     String(self.class)  #=> "Object"
  #     String(123456)      #=> "123456"
  #
  def self?.String: (_ToStr | _ToS x) -> String

  # <!--
  #   rdoc-file=eval.c
  #   - __callee__         -> symbol
  # -->
  # Returns the called name of the current method as a Symbol. If called outside
  # of a method, it returns `nil`.
  #
  def self?.__callee__: () -> Symbol?

  # <!--
  #   rdoc-file=eval.c
  #   - __dir__         -> string
  # -->
  # Returns the canonicalized absolute path of the directory of the file from
  # which this method is called. It means symlinks in the path is resolved. If
  # `__FILE__` is `nil`, it returns `nil`. The return value equals to
  # `File.dirname(File.realpath(__FILE__))`.
  #
  def self?.__dir__: () -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - __method__         -> symbol
  # -->
  # Returns the name at the definition of the current method as a Symbol. If
  # called outside of a method, it returns `nil`.
  #
  def self?.__method__: () -> Symbol?

  # <!--
  #   rdoc-file=io.c
  #   - `cmd`    -> string
  # -->
  # Returns the standard output of running *cmd* in a subshell. The built-in
  # syntax `%x{...}` uses this method. Sets `$?` to the process status.
  #
  #     `date`                   #=> "Wed Apr  9 08:56:30 CDT 2003\n"
  #     `ls testdir`.split[1]    #=> "main.rb"
  #     `echo oops && exit 99`   #=> "oops\n"
  #     $?.exitstatus            #=> 99
  #
  def self?.`: (String arg0) -> String

  # <!--
  #   rdoc-file=process.c
  #   - abort
  #   - Kernel::abort([msg])
  #   - Process.abort([msg])
  # -->
  # Terminate execution immediately, effectively by calling `Kernel.exit(false)`.
  # If *msg* is given, it is written to STDERR prior to terminating.
  #
  def self?.abort: (?String msg) -> bot

  # <!--
  #   rdoc-file=eval_jump.c
  #   - at_exit { block } -> proc
  # -->
  # Converts *block* to a `Proc` object (and therefore binds it at the point of
  # call) and registers it for execution when the program exits. If multiple
  # handlers are registered, they are executed in reverse order of registration.
  #
  #     def do_at_exit(str1)
  #       at_exit { print str1 }
  #     end
  #     at_exit { puts "cruel world" }
  #     do_at_exit("goodbye ")
  #     exit
  #
  # *produces:*
  #
  #     goodbye cruel world
  #
  def self?.at_exit: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=load.c
  #   - autoload(module, filename)   -> nil
  # -->
  # Registers *filename* to be loaded (using Kernel::require) the first time that
  # *module* (which may be a String or a symbol) is accessed.
  #
  #     autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")
  #
  def self?.autoload: (String | Symbol _module, String filename) -> NilClass

  # <!--
  #   rdoc-file=load.c
  #   - autoload?(name, inherit=true)   -> String or nil
  # -->
  # Returns *filename* to be loaded if *name* is registered as `autoload`.
  #
  #     autoload(:B, "b")
  #     autoload?(:B)            #=> "b"
  #
  def self?.autoload?: (Symbol | String name) -> String?

  # <!--
  #   rdoc-file=proc.c
  #   - binding -> a_binding
  # -->
  # Returns a `Binding` object, describing the variable and method bindings at the
  # point of call. This object can be used when calling `eval` to execute the
  # evaluated command in this environment. See also the description of class
  # `Binding`.
  #
  #     def get_binding(param)
  #       binding
  #     end
  #     b = get_binding("hello")
  #     eval("param", b)   #=> "hello"
  #
  def self?.binding: () -> Binding

  # <!--
  #   rdoc-file=process.c
  #   - exit(status=true)
  #   - Kernel::exit(status=true)
  #   - Process::exit(status=true)
  # -->
  # Initiates the termination of the Ruby script by raising the SystemExit
  # exception. This exception may be caught. The optional parameter is used to
  # return a status code to the invoking environment. `true` and `FALSE` of
  # *status* means success and failure respectively.  The interpretation of other
  # integer values are system dependent.
  #
  #     begin
  #       exit
  #       puts "never get here"
  #     rescue SystemExit
  #       puts "rescued a SystemExit exception"
  #     end
  #     puts "after begin block"
  #
  # *produces:*
  #
  #     rescued a SystemExit exception
  #     after begin block
  #
  # Just prior to termination, Ruby executes any `at_exit` functions (see
  # Kernel::at_exit) and runs any object finalizers (see
  # ObjectSpace::define_finalizer).
  #
  #     at_exit { puts "at_exit function" }
  #     ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
  #     exit
  #
  # *produces:*
  #
  #     at_exit function
  #     in finalizer
  #
  def self?.exit: () -> bot
                | (?Integer | TrueClass | FalseClass status) -> bot

  # <!--
  #   rdoc-file=process.c
  #   - Process.exit!(status=false)
  # -->
  # Exits the process immediately. No exit handlers are run. *status* is returned
  # to the underlying system as the exit status.
  #
  #     Process.exit!(true)
  #
  def self?.exit!: (Integer | TrueClass | FalseClass status) -> bot

  # <!-- rdoc-file=eval.c -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  def self?.fail: () -> bot
                | (String arg0) -> bot
                | (_Exception arg0, ?untyped arg1, ?::Array[String] arg2) -> bot

  # <!--
  #   rdoc-file=eval.c
  #   - raise
  #   - raise(string, cause: $!)
  #   - raise(exception [, string [, array]], cause: $!)
  #   - fail
  #   - fail(string, cause: $!)
  #   - fail(exception [, string [, array]], cause: $!)
  # -->
  # With no arguments, raises the exception in `$!` or raises a RuntimeError if
  # `$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
  # the string as a message. Otherwise, the first parameter should be an
  # `Exception` class (or another object that returns an `Exception` object when
  # sent an `exception` message).  The optional second parameter sets the message
  # associated with the exception (accessible via Exception#message), and the
  # third parameter is an array of callback information (accessible via
  # Exception#backtrace). The `cause` of the generated exception (accessible via
  # Exception#cause) is automatically set to the "current" exception (`$!`), if
  # any. An alternative value, either an `Exception` object or `nil`, can be
  # specified via the `:cause` argument.
  #
  # Exceptions are caught by the `rescue` clause of `begin...end` blocks.
  #
  #     raise "Failed to create socket"
  #     raise ArgumentError, "No parameters", caller
  #
  alias raise fail

  alias self.raise self.fail

  # <!-- rdoc-file=object.c -->
  # Returns the string resulting from applying *format_string* to any additional
  # arguments.  Within the format string, any characters other than format
  # sequences are copied to the result.
  #
  # The syntax of a format sequence is as follows.
  #
  #     %[flags][width][.precision]type
  #
  # A format sequence consists of a percent sign, followed by optional flags,
  # width, and precision indicators, then terminated with a field type character.
  # The field type controls how the corresponding `sprintf` argument is to be
  # interpreted, while the flags modify that interpretation.
  #
  # The field type characters are:
  #
  #     Field |  Integer Format
  #     ------+--------------------------------------------------------------
  #       b   | Convert argument as a binary number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..1'.
  #       B   | Equivalent to `b', but uses an uppercase 0B for prefix
  #           | in the alternative format by #.
  #       d   | Convert argument as a decimal number.
  #       i   | Identical to `d'.
  #       o   | Convert argument as an octal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..7'.
  #       u   | Identical to `d'.
  #       x   | Convert argument as a hexadecimal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..f' (representing an infinite string of
  #           | leading 'ff's).
  #       X   | Equivalent to `x', but uses uppercase letters.
  #
  #     Field |  Float Format
  #     ------+--------------------------------------------------------------
  #       e   | Convert floating point argument into exponential notation
  #           | with one digit before the decimal point as [-]d.dddddde[+-]dd.
  #           | The precision specifies the number of digits after the decimal
  #           | point (defaulting to six).
  #       E   | Equivalent to `e', but uses an uppercase E to indicate
  #           | the exponent.
  #       f   | Convert floating point argument as [-]ddd.dddddd,
  #           | where the precision specifies the number of digits after
  #           | the decimal point.
  #       g   | Convert a floating point number using exponential form
  #           | if the exponent is less than -4 or greater than or
  #           | equal to the precision, or in dd.dddd form otherwise.
  #           | The precision specifies the number of significant digits.
  #       G   | Equivalent to `g', but use an uppercase `E' in exponent form.
  #       a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
  #           | which is consisted from optional sign, "0x", fraction part
  #           | as hexadecimal, "p", and exponential part as decimal.
  #       A   | Equivalent to `a', but use uppercase `X' and `P'.
  #
  #     Field |  Other Format
  #     ------+--------------------------------------------------------------
  #       c   | Argument is the numeric code for a single character or
  #           | a single character string itself.
  #       p   | The valuing of argument.inspect.
  #       s   | Argument is a string to be substituted.  If the format
  #           | sequence contains a precision, at most that many characters
  #           | will be copied.
  #       %   | A percent sign itself will be displayed.  No argument taken.
  #
  # The flags modifies the behavior of the formats. The flag characters are:
  #
  #     Flag     | Applies to    | Meaning
  #     ---------+---------------+-----------------------------------------
  #     space    | bBdiouxX      | Leave a space at the start of
  #              | aAeEfgG       | non-negative numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     (digit)$ | all           | Specifies the absolute argument number
  #              |               | for this field.  Absolute and relative
  #              |               | argument numbers cannot be mixed in a
  #              |               | sprintf string.
  #     ---------+---------------+-----------------------------------------
  #      #       | bBoxX         | Use an alternative format.
  #              | aAeEfgG       | For the conversions `o', increase the precision
  #              |               | until the first digit will be `0' if
  #              |               | it is not formatted as complements.
  #              |               | For the conversions `x', `X', `b' and `B'
  #              |               | on non-zero, prefix the result with ``0x'',
  #              |               | ``0X'', ``0b'' and ``0B'', respectively.
  #              |               | For `a', `A', `e', `E', `f', `g', and 'G',
  #              |               | force a decimal point to be added,
  #              |               | even if no digits follow.
  #              |               | For `g' and 'G', do not remove trailing zeros.
  #     ---------+---------------+-----------------------------------------
  #     +        | bBdiouxX      | Add a leading plus sign to non-negative
  #              | aAeEfgG       | numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     -        | all           | Left-justify the result of this conversion.
  #     ---------+---------------+-----------------------------------------
  #     0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
  #              | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
  #              | (numeric fmt) | is used for negative numbers formatted as
  #              |               | complements.
  #     ---------+---------------+-----------------------------------------
  #     *        | all           | Use the next argument as the field width.
  #              |               | If negative, left-justify the result. If the
  #              |               | asterisk is followed by a number and a dollar
  #              |               | sign, use the indicated argument as the width.
  #
  # Examples of flags:
  #
  #     # `+' and space flag specifies the sign of non-negative numbers.
  #     sprintf("%d", 123)  #=> "123"
  #     sprintf("%+d", 123) #=> "+123"
  #     sprintf("% d", 123) #=> " 123"
  #
  #     # `#' flag for `o' increases number of digits to show `0'.
  #     # `+' and space flag changes format of negative numbers.
  #     sprintf("%o", 123)   #=> "173"
  #     sprintf("%#o", 123)  #=> "0173"
  #     sprintf("%+o", -123) #=> "-173"
  #     sprintf("%o", -123)  #=> "..7605"
  #     sprintf("%#o", -123) #=> "..7605"
  #
  #     # `#' flag for `x' add a prefix `0x' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%x", 123)   #=> "7b"
  #     sprintf("%#x", 123)  #=> "0x7b"
  #     sprintf("%+x", -123) #=> "-7b"
  #     sprintf("%x", -123)  #=> "..f85"
  #     sprintf("%#x", -123) #=> "0x..f85"
  #     sprintf("%#x", 0)    #=> "0"
  #
  #     # `#' for `X' uses the prefix `0X'.
  #     sprintf("%X", 123)  #=> "7B"
  #     sprintf("%#X", 123) #=> "0X7B"
  #
  #     # `#' flag for `b' add a prefix `0b' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%b", 123)   #=> "1111011"
  #     sprintf("%#b", 123)  #=> "0b1111011"
  #     sprintf("%+b", -123) #=> "-1111011"
  #     sprintf("%b", -123)  #=> "..10000101"
  #     sprintf("%#b", -123) #=> "0b..10000101"
  #     sprintf("%#b", 0)    #=> "0"
  #
  #     # `#' for `B' uses the prefix `0B'.
  #     sprintf("%B", 123)  #=> "1111011"
  #     sprintf("%#B", 123) #=> "0B1111011"
  #
  #     # `#' for `e' forces to show the decimal point.
  #     sprintf("%.0e", 1)  #=> "1e+00"
  #     sprintf("%#.0e", 1) #=> "1.e+00"
  #
  #     # `#' for `f' forces to show the decimal point.
  #     sprintf("%.0f", 1234)  #=> "1234"
  #     sprintf("%#.0f", 1234) #=> "1234."
  #
  #     # `#' for `g' forces to show the decimal point.
  #     # It also disables stripping lowest zeros.
  #     sprintf("%g", 123.4)   #=> "123.4"
  #     sprintf("%#g", 123.4)  #=> "123.400"
  #     sprintf("%g", 123456)  #=> "123456"
  #     sprintf("%#g", 123456) #=> "123456."
  #
  # The field width is an optional integer, followed optionally by a period and a
  # precision.  The width specifies the minimum number of characters that will be
  # written to the result for this field.
  #
  # Examples of width:
  #
  #     # padding is done by spaces,       width=20
  #     # 0 or radix-1.             <------------------>
  #     sprintf("%20d", 123)   #=> "                 123"
  #     sprintf("%+20d", 123)  #=> "                +123"
  #     sprintf("%020d", 123)  #=> "00000000000000000123"
  #     sprintf("%+020d", 123) #=> "+0000000000000000123"
  #     sprintf("% 020d", 123) #=> " 0000000000000000123"
  #     sprintf("%-20d", 123)  #=> "123                 "
  #     sprintf("%-+20d", 123) #=> "+123                "
  #     sprintf("%- 20d", 123) #=> " 123                "
  #     sprintf("%020x", -123) #=> "..ffffffffffffffff85"
  #
  # For numeric fields, the precision controls the number of decimal places
  # displayed.  For string fields, the precision determines the maximum number of
  # characters to be copied from the string.  (Thus, the format sequence `%10.10s`
  # will always contribute exactly ten characters to the result.)
  #
  # Examples of precisions:
  #
  #     # precision for `d', 'o', 'x' and 'b' is
  #     # minimum number of digits               <------>
  #     sprintf("%20.8d", 123)  #=> "            00000123"
  #     sprintf("%20.8o", 123)  #=> "            00000173"
  #     sprintf("%20.8x", 123)  #=> "            0000007b"
  #     sprintf("%20.8b", 123)  #=> "            01111011"
  #     sprintf("%20.8d", -123) #=> "           -00000123"
  #     sprintf("%20.8o", -123) #=> "            ..777605"
  #     sprintf("%20.8x", -123) #=> "            ..ffff85"
  #     sprintf("%20.8b", -11)  #=> "            ..110101"
  #
  #     # "0x" and "0b" for `#x' and `#b' is not counted for
  #     # precision but "0" for `#o' is counted.  <------>
  #     sprintf("%#20.8d", 123)  #=> "            00000123"
  #     sprintf("%#20.8o", 123)  #=> "            00000173"
  #     sprintf("%#20.8x", 123)  #=> "          0x0000007b"
  #     sprintf("%#20.8b", 123)  #=> "          0b01111011"
  #     sprintf("%#20.8d", -123) #=> "           -00000123"
  #     sprintf("%#20.8o", -123) #=> "            ..777605"
  #     sprintf("%#20.8x", -123) #=> "          0x..ffff85"
  #     sprintf("%#20.8b", -11)  #=> "          0b..110101"
  #
  #     # precision for `e' is number of
  #     # digits after the decimal point           <------>
  #     sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"
  #
  #     # precision for `f' is number of
  #     # digits after the decimal point               <------>
  #     sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"
  #
  #     # precision for `g' is number of
  #     # significant digits                          <------->
  #     sprintf("%20.8g", 1234.56789) #=> "           1234.5679"
  #
  #     #                                         <------->
  #     sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"
  #
  #     # precision for `s' is
  #     # maximum number of characters                    <------>
  #     sprintf("%20.8s", "string test") #=> "            string t"
  #
  # Examples:
  #
  #     sprintf("%d %04x", 123, 123)               #=> "123 007b"
  #     sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
  #     sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
  #     sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
  #     sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
  #     sprintf("%u", -123)                        #=> "-123"
  #
  # For more complex formatting, Ruby supports a reference by name. %<name>s style
  # uses format style, but %{name} style doesn't.
  #
  # Examples:
  #     sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
  #       #=> 1 : 2.000000
  #     sprintf("%{foo}f", { :foo => 1 })
  #       # => "1f"
  #
  def self?.format: (String format, *untyped args) -> String

  # <!--
  #   rdoc-file=object.c
  #   - format(format_string [, arguments...] )   -> string
  #   - sprintf(format_string [, arguments...] )  -> string
  # -->
  # Returns the string resulting from applying *format_string* to any additional
  # arguments.  Within the format string, any characters other than format
  # sequences are copied to the result.
  #
  # The syntax of a format sequence is as follows.
  #
  #     %[flags][width][.precision]type
  #
  # A format sequence consists of a percent sign, followed by optional flags,
  # width, and precision indicators, then terminated with a field type character.
  # The field type controls how the corresponding `sprintf` argument is to be
  # interpreted, while the flags modify that interpretation.
  #
  # The field type characters are:
  #
  #     Field |  Integer Format
  #     ------+--------------------------------------------------------------
  #       b   | Convert argument as a binary number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..1'.
  #       B   | Equivalent to `b', but uses an uppercase 0B for prefix
  #           | in the alternative format by #.
  #       d   | Convert argument as a decimal number.
  #       i   | Identical to `d'.
  #       o   | Convert argument as an octal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..7'.
  #       u   | Identical to `d'.
  #       x   | Convert argument as a hexadecimal number.
  #           | Negative numbers will be displayed as a two's complement
  #           | prefixed with `..f' (representing an infinite string of
  #           | leading 'ff's).
  #       X   | Equivalent to `x', but uses uppercase letters.
  #
  #     Field |  Float Format
  #     ------+--------------------------------------------------------------
  #       e   | Convert floating point argument into exponential notation
  #           | with one digit before the decimal point as [-]d.dddddde[+-]dd.
  #           | The precision specifies the number of digits after the decimal
  #           | point (defaulting to six).
  #       E   | Equivalent to `e', but uses an uppercase E to indicate
  #           | the exponent.
  #       f   | Convert floating point argument as [-]ddd.dddddd,
  #           | where the precision specifies the number of digits after
  #           | the decimal point.
  #       g   | Convert a floating point number using exponential form
  #           | if the exponent is less than -4 or greater than or
  #           | equal to the precision, or in dd.dddd form otherwise.
  #           | The precision specifies the number of significant digits.
  #       G   | Equivalent to `g', but use an uppercase `E' in exponent form.
  #       a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
  #           | which is consisted from optional sign, "0x", fraction part
  #           | as hexadecimal, "p", and exponential part as decimal.
  #       A   | Equivalent to `a', but use uppercase `X' and `P'.
  #
  #     Field |  Other Format
  #     ------+--------------------------------------------------------------
  #       c   | Argument is the numeric code for a single character or
  #           | a single character string itself.
  #       p   | The valuing of argument.inspect.
  #       s   | Argument is a string to be substituted.  If the format
  #           | sequence contains a precision, at most that many characters
  #           | will be copied.
  #       %   | A percent sign itself will be displayed.  No argument taken.
  #
  # The flags modifies the behavior of the formats. The flag characters are:
  #
  #     Flag     | Applies to    | Meaning
  #     ---------+---------------+-----------------------------------------
  #     space    | bBdiouxX      | Leave a space at the start of
  #              | aAeEfgG       | non-negative numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     (digit)$ | all           | Specifies the absolute argument number
  #              |               | for this field.  Absolute and relative
  #              |               | argument numbers cannot be mixed in a
  #              |               | sprintf string.
  #     ---------+---------------+-----------------------------------------
  #      #       | bBoxX         | Use an alternative format.
  #              | aAeEfgG       | For the conversions `o', increase the precision
  #              |               | until the first digit will be `0' if
  #              |               | it is not formatted as complements.
  #              |               | For the conversions `x', `X', `b' and `B'
  #              |               | on non-zero, prefix the result with ``0x'',
  #              |               | ``0X'', ``0b'' and ``0B'', respectively.
  #              |               | For `a', `A', `e', `E', `f', `g', and 'G',
  #              |               | force a decimal point to be added,
  #              |               | even if no digits follow.
  #              |               | For `g' and 'G', do not remove trailing zeros.
  #     ---------+---------------+-----------------------------------------
  #     +        | bBdiouxX      | Add a leading plus sign to non-negative
  #              | aAeEfgG       | numbers.
  #              | (numeric fmt) | For `o', `x', `X', `b' and `B', use
  #              |               | a minus sign with absolute value for
  #              |               | negative values.
  #     ---------+---------------+-----------------------------------------
  #     -        | all           | Left-justify the result of this conversion.
  #     ---------+---------------+-----------------------------------------
  #     0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
  #              | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
  #              | (numeric fmt) | is used for negative numbers formatted as
  #              |               | complements.
  #     ---------+---------------+-----------------------------------------
  #     *        | all           | Use the next argument as the field width.
  #              |               | If negative, left-justify the result. If the
  #              |               | asterisk is followed by a number and a dollar
  #              |               | sign, use the indicated argument as the width.
  #
  # Examples of flags:
  #
  #     # `+' and space flag specifies the sign of non-negative numbers.
  #     sprintf("%d", 123)  #=> "123"
  #     sprintf("%+d", 123) #=> "+123"
  #     sprintf("% d", 123) #=> " 123"
  #
  #     # `#' flag for `o' increases number of digits to show `0'.
  #     # `+' and space flag changes format of negative numbers.
  #     sprintf("%o", 123)   #=> "173"
  #     sprintf("%#o", 123)  #=> "0173"
  #     sprintf("%+o", -123) #=> "-173"
  #     sprintf("%o", -123)  #=> "..7605"
  #     sprintf("%#o", -123) #=> "..7605"
  #
  #     # `#' flag for `x' add a prefix `0x' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%x", 123)   #=> "7b"
  #     sprintf("%#x", 123)  #=> "0x7b"
  #     sprintf("%+x", -123) #=> "-7b"
  #     sprintf("%x", -123)  #=> "..f85"
  #     sprintf("%#x", -123) #=> "0x..f85"
  #     sprintf("%#x", 0)    #=> "0"
  #
  #     # `#' for `X' uses the prefix `0X'.
  #     sprintf("%X", 123)  #=> "7B"
  #     sprintf("%#X", 123) #=> "0X7B"
  #
  #     # `#' flag for `b' add a prefix `0b' for non-zero numbers.
  #     # `+' and space flag disables complements for negative numbers.
  #     sprintf("%b", 123)   #=> "1111011"
  #     sprintf("%#b", 123)  #=> "0b1111011"
  #     sprintf("%+b", -123) #=> "-1111011"
  #     sprintf("%b", -123)  #=> "..10000101"
  #     sprintf("%#b", -123) #=> "0b..10000101"
  #     sprintf("%#b", 0)    #=> "0"
  #
  #     # `#' for `B' uses the prefix `0B'.
  #     sprintf("%B", 123)  #=> "1111011"
  #     sprintf("%#B", 123) #=> "0B1111011"
  #
  #     # `#' for `e' forces to show the decimal point.
  #     sprintf("%.0e", 1)  #=> "1e+00"
  #     sprintf("%#.0e", 1) #=> "1.e+00"
  #
  #     # `#' for `f' forces to show the decimal point.
  #     sprintf("%.0f", 1234)  #=> "1234"
  #     sprintf("%#.0f", 1234) #=> "1234."
  #
  #     # `#' for `g' forces to show the decimal point.
  #     # It also disables stripping lowest zeros.
  #     sprintf("%g", 123.4)   #=> "123.4"
  #     sprintf("%#g", 123.4)  #=> "123.400"
  #     sprintf("%g", 123456)  #=> "123456"
  #     sprintf("%#g", 123456) #=> "123456."
  #
  # The field width is an optional integer, followed optionally by a period and a
  # precision.  The width specifies the minimum number of characters that will be
  # written to the result for this field.
  #
  # Examples of width:
  #
  #     # padding is done by spaces,       width=20
  #     # 0 or radix-1.             <------------------>
  #     sprintf("%20d", 123)   #=> "                 123"
  #     sprintf("%+20d", 123)  #=> "                +123"
  #     sprintf("%020d", 123)  #=> "00000000000000000123"
  #     sprintf("%+020d", 123) #=> "+0000000000000000123"
  #     sprintf("% 020d", 123) #=> " 0000000000000000123"
  #     sprintf("%-20d", 123)  #=> "123                 "
  #     sprintf("%-+20d", 123) #=> "+123                "
  #     sprintf("%- 20d", 123) #=> " 123                "
  #     sprintf("%020x", -123) #=> "..ffffffffffffffff85"
  #
  # For numeric fields, the precision controls the number of decimal places
  # displayed.  For string fields, the precision determines the maximum number of
  # characters to be copied from the string.  (Thus, the format sequence `%10.10s`
  # will always contribute exactly ten characters to the result.)
  #
  # Examples of precisions:
  #
  #     # precision for `d', 'o', 'x' and 'b' is
  #     # minimum number of digits               <------>
  #     sprintf("%20.8d", 123)  #=> "            00000123"
  #     sprintf("%20.8o", 123)  #=> "            00000173"
  #     sprintf("%20.8x", 123)  #=> "            0000007b"
  #     sprintf("%20.8b", 123)  #=> "            01111011"
  #     sprintf("%20.8d", -123) #=> "           -00000123"
  #     sprintf("%20.8o", -123) #=> "            ..777605"
  #     sprintf("%20.8x", -123) #=> "            ..ffff85"
  #     sprintf("%20.8b", -11)  #=> "            ..110101"
  #
  #     # "0x" and "0b" for `#x' and `#b' is not counted for
  #     # precision but "0" for `#o' is counted.  <------>
  #     sprintf("%#20.8d", 123)  #=> "            00000123"
  #     sprintf("%#20.8o", 123)  #=> "            00000173"
  #     sprintf("%#20.8x", 123)  #=> "          0x0000007b"
  #     sprintf("%#20.8b", 123)  #=> "          0b01111011"
  #     sprintf("%#20.8d", -123) #=> "           -00000123"
  #     sprintf("%#20.8o", -123) #=> "            ..777605"
  #     sprintf("%#20.8x", -123) #=> "          0x..ffff85"
  #     sprintf("%#20.8b", -11)  #=> "          0b..110101"
  #
  #     # precision for `e' is number of
  #     # digits after the decimal point           <------>
  #     sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"
  #
  #     # precision for `f' is number of
  #     # digits after the decimal point               <------>
  #     sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"
  #
  #     # precision for `g' is number of
  #     # significant digits                          <------->
  #     sprintf("%20.8g", 1234.56789) #=> "           1234.5679"
  #
  #     #                                         <------->
  #     sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"
  #
  #     # precision for `s' is
  #     # maximum number of characters                    <------>
  #     sprintf("%20.8s", "string test") #=> "            string t"
  #
  # Examples:
  #
  #     sprintf("%d %04x", 123, 123)               #=> "123 007b"
  #     sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
  #     sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
  #     sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
  #     sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
  #     sprintf("%u", -123)                        #=> "-123"
  #
  # For more complex formatting, Ruby supports a reference by name. %<name>s style
  # uses format style, but %{name} style doesn't.
  #
  # Examples:
  #     sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
  #       #=> 1 : 2.000000
  #     sprintf("%{foo}f", { :foo => 1 })
  #       # => "1f"
  #
  alias sprintf format

  alias self.sprintf self.format

  # <!--
  #   rdoc-file=io.c
  #   - gets(sep=$/ [, getline_args])     -> string or nil
  #   - gets(limit [, getline_args])      -> string or nil
  #   - gets(sep, limit [, getline_args]) -> string or nil
  # -->
  # Returns (and assigns to `$_`) the next line from the list of files in `ARGV`
  # (or `$*`), or from standard input if no files are present on the command line.
  # Returns `nil` at end of file. The optional argument specifies the record
  # separator. The separator is included with the contents of each record. A
  # separator of `nil` reads the entire contents, and a zero-length separator
  # reads the input one paragraph at a time, where paragraphs are divided by two
  # consecutive newlines.  If the first argument is an integer, or optional second
  # argument is given, the returning string would not be longer than the given
  # value in bytes.  If multiple filenames are present in `ARGV`, `gets(nil)` will
  # read the contents one file at a time.
  #
  #     ARGV << "testfile"
  #     print while gets
  #
  # *produces:*
  #
  #     This is line one
  #     This is line two
  #     This is line three
  #     And so on...
  #
  # The style of programming using `$_` as an implicit parameter is gradually
  # losing favor in the Ruby community.
  #
  def self?.gets: (?String arg0, ?Integer arg1) -> String?

  # <!--
  #   rdoc-file=eval.c
  #   - global_variables    -> array
  # -->
  # Returns an array of the names of global variables. This includes special
  # regexp global variables such as `$~` and `$+`, but does not include the
  # numbered regexp global variables (`$1`, `$2`, etc.).
  #
  #     global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]
  #
  def self?.global_variables: () -> ::Array[Symbol]

  # <!--
  #   rdoc-file=load.c
  #   - load(filename, wrap=false)   -> true
  # -->
  # Loads and executes the Ruby program in the file *filename*.
  #
  # If the filename is an absolute path (e.g. starts with '/'), the file will be
  # loaded directly using the absolute path.
  #
  # If the filename is an explicit relative path (e.g. starts with './' or '../'),
  # the file will be loaded using the relative path from the current directory.
  #
  # Otherwise, the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the file is found in a directory, it will attempt to
  # load the file relative to that directory.  If the file is not found in any of
  # the directories in `$LOAD_PATH`, the file will be loaded using the relative
  # path from the current directory.
  #
  # If the file doesn't exist when there is an attempt to load it, a LoadError
  # will be raised.
  #
  # If the optional *wrap* parameter is `true`, the loaded script will be executed
  # under an anonymous module, protecting the calling program's global namespace.
  # If the optional *wrap* parameter is a module, the loaded script will be
  # executed under the given module. In no circumstance will any local variables
  # in the loaded file be propagated to the loading environment.
  #
  def self?.load: (String filename, ?Module | bool) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - loop { block }
  #   - loop            -> an_enumerator
  # -->
  # Repeatedly executes the block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     loop do
  #       print "Input: "
  #       line = gets
  #       break if !line or line =~ /^qQ/
  #       # ...
  #     end
  #
  # StopIteration raised in the block breaks the loop.  In this case, loop returns
  # the "result" value stored in the exception.
  #
  #     enum = Enumerator.new { |y|
  #       y << "one"
  #       y << "two"
  #       :ok
  #     }
  #
  #     result = loop {
  #       puts enum.next
  #     } #=> :ok
  #
  def self?.loop: () { (nil) -> untyped } -> bot
                | () -> ::Enumerator[nil, bot]

  # <!--
  #   rdoc-file=io.c
  #   - open(path [, mode [, perm]] [, opt])                -> io or nil
  #   - open(path [, mode [, perm]] [, opt]) {|io| block }  -> obj
  # -->
  # Creates an IO object connected to the given stream, file, or subprocess.
  #
  # If `path` does not start with a pipe character (`|`), treat it as the name of
  # a file to open using the specified mode (defaulting to "r").
  #
  # The `mode` is either a string or an integer.  If it is an integer, it must be
  # bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.  If it is a
  # string, it is either "fmode", "fmode:ext_enc", or "fmode:ext_enc:int_enc".
  #
  # See the documentation of IO.new for full documentation of the `mode` string
  # directives.
  #
  # If a file is being created, its initial permissions may be set using the
  # `perm` parameter.  See File.new and the open(2) and chmod(2) man pages for a
  # description of permissions.
  #
  # If a block is specified, it will be invoked with the IO object as a parameter,
  # and the IO will be automatically closed when the block terminates.  The call
  # returns the value of the block.
  #
  # If `path` starts with a pipe character (`"|"`), a subprocess is created,
  # connected to the caller by a pair of pipes.  The returned IO object may be
  # used to write to the standard input and read from the standard output of this
  # subprocess.
  #
  # If the command following the pipe is a single minus sign (`"|-"`), Ruby forks,
  # and this subprocess is connected to the parent.  If the command is not `"-"`,
  # the subprocess runs the command.  Note that the command may be processed by
  # shell if it contains shell metacharacters.
  #
  # When the subprocess is Ruby (opened via `"|-"`), the `open` call returns
  # `nil`.  If a block is associated with the open call, that block will run twice
  # --- once in the parent and once in the child.
  #
  # The block parameter will be an IO object in the parent and `nil` in the child.
  # The parent's `IO` object will be connected to the child's $stdin and $stdout.
  # The subprocess will be terminated at the end of the block.
  #
  # ### Examples
  #
  # Reading from "testfile":
  #
  #     open("testfile") do |f|
  #       print f.gets
  #     end
  #
  # Produces:
  #
  #     This is line one
  #
  # Open a subprocess and read its output:
  #
  #     cmd = open("|date")
  #     print cmd.gets
  #     cmd.close
  #
  # Produces:
  #
  #     Wed Apr  9 08:56:31 CDT 2003
  #
  # Open a subprocess running the same Ruby program:
  #
  #     f = open("|-", "w+")
  #     if f.nil?
  #       puts "in Child"
  #       exit
  #     else
  #       puts "Got: #{f.gets}"
  #     end
  #
  # Produces:
  #
  #     Got: in Child
  #
  # Open a subprocess using a block to receive the IO object:
  #
  #     open "|-" do |f|
  #       if f then
  #         # parent process
  #         puts "Got: #{f.gets}"
  #       else
  #         # child process
  #         puts "in Child"
  #       end
  #     end
  #
  # Produces:
  #
  #     Got: in Child
  #
  def self?.open: (String name, ?String mode, ?Integer perm) -> IO?
                | [T] (String name, ?String mode, ?Integer perm) { (IO) -> T } -> T

  # <!--
  #   rdoc-file=io.c
  #   - print(obj, ...)    -> nil
  # -->
  # Prints each object in turn to `$stdout`. If the output field separator (`$,`)
  # is not `nil`, its contents will appear between each field. If the output
  # record separator (`$\`) is not `nil`, it will be appended to the output. If no
  # arguments are given, prints `$_`. Objects that aren't strings will be
  # converted by calling their `to_s` method.
  #
  #     print "cat", [1,2,3], 99, "\n"
  #     $, = ", "
  #     $\ = "\n"
  #     print "cat", [1,2,3], 99
  #
  # *produces:*
  #
  #     cat12399
  #     cat, 1, 2, 3, 99
  #
  def self?.print: (*Kernel args) -> nil

  # <!--
  #   rdoc-file=io.c
  #   - printf(io, string [, obj ... ])    -> nil
  #   - printf(string [, obj ... ])        -> nil
  # -->
  # Equivalent to:
  #     io.write(sprintf(string, obj, ...))
  #
  # or
  #     $stdout.write(sprintf(string, obj, ...))
  #
  def self?.printf: (IO arg0, String arg1, *untyped args) -> nil
                  | (String arg1, *untyped args) -> nil
                  | () -> nil

  # <!--
  #   rdoc-file=proc.c
  #   - proc   { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new.
  #
  def self?.proc: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=proc.c
  #   - lambda { |...| block }  -> a_proc
  # -->
  # Equivalent to Proc.new, except the resulting Proc objects check the number of
  # parameters passed when called.
  #
  def self?.lambda: () { () -> untyped } -> Proc

  # <!--
  #   rdoc-file=io.c
  #   - putc(int)   -> int
  # -->
  # Equivalent to:
  #
  #     $stdout.putc(int)
  #
  # Refer to the documentation for IO#putc for important information regarding
  # multi-byte characters.
  #
  def self?.putc: (Integer arg0) -> Integer
                | (String arg0) -> String

  # <!--
  #   rdoc-file=io.c
  #   - puts(obj, ...)    -> nil
  # -->
  # Equivalent to
  #
  #     $stdout.puts(obj, ...)
  #
  def self?.puts: (*untyped arg0) -> NilClass

  # <!--
  #   rdoc-file=io.c
  #   - p(obj)              -> obj
  #   - p(obj1, obj2, ...)  -> [obj, ...]
  #   - p()                 -> nil
  # -->
  # For each object, directly writes *obj*.`inspect` followed by a newline to the
  # program's standard output.
  #
  #     S = Struct.new(:name, :state)
  #     s = S['dave', 'TX']
  #     p s
  #
  # *produces:*
  #
  #     #<S name="dave", state="TX">
  #
  def self?.p: [T] (T arg0) -> T
             | (*untyped arg0) -> Array[untyped]

  # <!--
  #   rdoc-file=lib/pp.rb
  #   - pp(*objs)
  # -->
  # prints arguments in pretty form.
  #
  # pp returns argument(s).
  #
  def self?.pp: [T] (T arg0) -> T
              | (*untyped arg0) -> Array[untyped]

  # <!--
  #   rdoc-file=random.c
  #   - rand(max=0)    -> number
  # -->
  # If called without an argument, or if `max.to_i.abs == 0`, rand returns a
  # pseudo-random floating point number between 0.0 and 1.0, including 0.0 and
  # excluding 1.0.
  #
  #     rand        #=> 0.2725926052826416
  #
  # When `max.abs` is greater than or equal to 1, `rand` returns a pseudo-random
  # integer greater than or equal to 0 and less than `max.to_i.abs`.
  #
  #     rand(100)   #=> 12
  #
  # When `max` is a Range, `rand` returns a random number where
  # range.member?(number) == true.
  #
  # Negative or floating point values for `max` are allowed, but may give
  # surprising results.
  #
  #     rand(-100) # => 87
  #     rand(-0.5) # => 0.8130921818028143
  #     rand(1.9)  # equivalent to rand(1), which is always 0
  #
  # Kernel.srand may be used to ensure that sequences of random numbers are
  # reproducible between different runs of a program.
  #
  # See also Random.rand.
  #
  def self?.rand: () -> Float
                | (Integer arg0) -> Integer
                | (::Range[Integer] arg0) -> Integer
                | (::Range[Float] arg0) -> Float

  # <!--
  #   rdoc-file=io.c
  #   - readline(sep=$/)     -> string
  #   - readline(limit)      -> string
  #   - readline(sep, limit) -> string
  # -->
  # Equivalent to Kernel::gets, except `readline` raises `EOFError` at end of
  # file.
  #
  def self?.readline: (?String arg0, ?Integer arg1) -> String

  # <!--
  #   rdoc-file=io.c
  #   - readlines(sep=$/)     -> array
  #   - readlines(limit)      -> array
  #   - readlines(sep, limit) -> array
  # -->
  # Returns an array containing the lines returned by calling `Kernel.gets(*sep*)`
  # until the end of file.
  #
  def self?.readlines: (?String arg0, ?Integer arg1) -> ::Array[String]

  # <!--
  #   rdoc-file=load.c
  #   - require(name)    -> true or false
  # -->
  # Loads the given `name`, returning `true` if successful and `false` if the
  # feature is already loaded.
  #
  # If the filename neither resolves to an absolute path nor starts with './' or
  # '../', the file will be searched for in the library directories listed in
  # `$LOAD_PATH` (`$:`). If the filename starts with './' or '../', resolution is
  # based on Dir.pwd.
  #
  # If the filename has the extension ".rb", it is loaded as a source file; if the
  # extension is ".so", ".o", or ".dll", or the default shared library extension
  # on the current platform, Ruby loads the shared library as a Ruby extension.
  # Otherwise, Ruby tries adding ".rb", ".so", and so on to the name until found.
  # If the file named cannot be found, a LoadError will be raised.
  #
  # For Ruby extensions the filename given may use any shared library extension.
  # For example, on Linux the socket extension is "socket.so" and `require
  # 'socket.dll'` will load the socket extension.
  #
  # The absolute path of the loaded file is added to `$LOADED_FEATURES` (`$"`).  A
  # file will not be loaded again if its path already appears in `$"`.  For
  # example, `require 'a'; require './a'` will not load `a.rb` again.
  #
  #     require "my-library.rb"
  #     require "db-driver"
  #
  # Any constants or globals within the loaded source file will be available in
  # the calling program's global namespace. However, local variables will not be
  # propagated to the loading environment.
  #
  def self?.require: (String path) -> bool

  # <!--
  #   rdoc-file=load.c
  #   - require_relative(string) -> true or false
  # -->
  # Ruby tries to load the library named *string* relative to the requiring file's
  # path.  If the file's path cannot be determined a LoadError is raised. If a
  # file is loaded `true` is returned and false otherwise.
  #
  def self?.require_relative: (String feature) -> bool

  # <!--
  #   rdoc-file=io.c
  #   - IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil
  # -->
  # Calls select(2) system call. It monitors given arrays of IO objects, waits
  # until one or more of IO objects are ready for reading, are ready for writing,
  # and have pending exceptions respectively, and returns an array that contains
  # arrays of those IO objects.  It will return `nil` if optional *timeout* value
  # is given and no IO object is ready in *timeout* seconds.
  #
  # IO.select peeks the buffer of IO objects for testing readability. If the IO
  # buffer is not empty, IO.select immediately notifies readability.  This "peek"
  # only happens for IO objects.  It does not happen for IO-like objects such as
  # OpenSSL::SSL::SSLSocket.
  #
  # The best way to use IO.select is invoking it after nonblocking methods such as
  # #read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
  # extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
  # caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
  # should wait for reading.  If IO::WaitWritable is raised, the caller should
  # wait for writing.
  #
  # So, blocking read (#readpartial) can be emulated using #read_nonblock and
  # IO.select as follows:
  #
  #     begin
  #       result = io_like.read_nonblock(maxlen)
  #     rescue IO::WaitReadable
  #       IO.select([io_like])
  #       retry
  #     rescue IO::WaitWritable
  #       IO.select(nil, [io_like])
  #       retry
  #     end
  #
  # Especially, the combination of nonblocking methods and IO.select is preferred
  # for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
  # return underlying IO object.  IO.select calls #to_io to obtain the file
  # descriptor to wait.
  #
  # This means that readability notified by IO.select doesn't mean readability
  # from OpenSSL::SSL::SSLSocket object.
  #
  # The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
  # IO.select doesn't see the buffer.  So IO.select can block when
  # OpenSSL::SSL::SSLSocket#readpartial doesn't block.
  #
  # However, several more complicated situations exist.
  #
  # SSL is a protocol which is sequence of records. The record consists of
  # multiple bytes. So, the remote side of SSL sends a partial record, IO.select
  # notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
  # OpenSSL::SSL::SSLSocket#readpartial will block.
  #
  # Also, the remote side can request SSL renegotiation which forces the local SSL
  # engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
  # invoke #write system call and it can block. In such a situation,
  # OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
  # blocking. So, the caller should wait for ready for writability as above
  # example.
  #
  # The combination of nonblocking methods and IO.select is also useful for
  # streams such as tty, pipe socket socket when multiple processes read from a
  # stream.
  #
  # Finally, Linux kernel developers don't guarantee that readability of select(2)
  # means readability of following read(2) even for a single process. See
  # select(2) manual on GNU/Linux system.
  #
  # Invoking IO.select before IO#readpartial works well as usual. However it is
  # not the best way to use IO.select.
  #
  # The writability notified by select(2) doesn't show how many bytes are
  # writable. IO#write method blocks until given whole string is written. So,
  # `IO#write(two or more bytes)` can block after writability is notified by
  # IO.select.  IO#write_nonblock is required to avoid the blocking.
  #
  # Blocking write (#write) can be emulated using #write_nonblock and IO.select as
  # follows: IO::WaitReadable should also be rescued for SSL renegotiation in
  # OpenSSL::SSL::SSLSocket.
  #
  #     while 0 < string.bytesize
  #       begin
  #         written = io_like.write_nonblock(string)
  #       rescue IO::WaitReadable
  #         IO.select([io_like])
  #         retry
  #       rescue IO::WaitWritable
  #         IO.select(nil, [io_like])
  #         retry
  #       end
  #       string = string.byteslice(written..-1)
  #     end
  #
  # ### Parameters
  # read_array
  # :   an array of IO objects that wait until ready for read
  # write_array
  # :   an array of IO objects that wait until ready for write
  # error_array
  # :   an array of IO objects that wait for exceptions
  # timeout
  # :   a numeric value in second
  #
  #
  # ### Example
  #
  #     rp, wp = IO.pipe
  #     mesg = "ping "
  #     100.times {
  #       # IO.select follows IO#read.  Not the best way to use IO.select.
  #       rs, ws, = IO.select([rp], [wp])
  #       if r = rs[0]
  #         ret = r.read(5)
  #         print ret
  #         case ret
  #         when /ping/
  #           mesg = "pong\n"
  #         when /pong/
  #           mesg = "ping "
  #         end
  #       end
  #       if w = ws[0]
  #         w.write(mesg)
  #       end
  #     }
  #
  # *produces:*
  #
  #     ping pong
  #     ping pong
  #     ping pong
  #     (snipped)
  #     ping
  #
  def self?.select: (::Array[IO] read, ?::Array[IO] write, ?::Array[IO] error, ?Integer timeout) -> ::Array[String]

  # <!--
  #   rdoc-file=process.c
  #   - sleep([duration])    -> integer
  # -->
  # Suspends the current thread for *duration* seconds (which may be any number,
  # including a `Float` with fractional seconds). Returns the actual number of
  # seconds slept (rounded), which may be less than that asked for if another
  # thread calls Thread#run. Called without an argument, sleep() will sleep
  # forever.
  #
  #     Time.new    #=> 2008-03-08 19:56:19 +0900
  #     sleep 1.2   #=> 1
  #     Time.new    #=> 2008-03-08 19:56:20 +0900
  #     sleep 1.9   #=> 2
  #     Time.new    #=> 2008-03-08 19:56:22 +0900
  #
  def self?.sleep: () -> bot
                 | (Numeric duration) -> Integer

  # <!--
  #   rdoc-file=io.c
  #   - syscall(num [, args...])   -> integer
  # -->
  # Calls the operating system function identified by *num* and returns the result
  # of the function or raises SystemCallError if it failed.
  #
  # Arguments for the function can follow *num*. They must be either `String`
  # objects or `Integer` objects. A `String` object is passed as a pointer to the
  # byte sequence. An `Integer` object is passed as an integer whose bit size is
  # the same as a pointer. Up to nine parameters may be passed.
  #
  # The function identified by *num* is system dependent. On some Unix systems,
  # the numbers may be obtained from a header file called `syscall.h`.
  #
  #     syscall 4, 1, "hello\n", 6   # '4' is write(2) on our box
  #
  # *produces:*
  #
  #     hello
  #
  # Calling `syscall` on a platform which does not have any way to an arbitrary
  # system function just fails with NotImplementedError.
  #
  # **Note:** `syscall` is essentially unsafe and unportable. Feel free to shoot
  # your foot. The DL (Fiddle) library is preferred for safer and a bit more
  # portable programming.
  #
  def self?.syscall: (Integer num, *untyped args) -> untyped

  # <!--
  #   rdoc-file=file.c
  #   - test(cmd, file1 [, file2] ) -> obj
  # -->
  # Uses the character `cmd` to perform various tests on `file1` (first table
  # below) or on `file1` and `file2` (second table).
  #
  # File tests on a single file:
  #
  #     Cmd    Returns   Meaning
  #     "A"  | Time    | Last access time for file1
  #     "b"  | boolean | True if file1 is a block device
  #     "c"  | boolean | True if file1 is a character device
  #     "C"  | Time    | Last change time for file1
  #     "d"  | boolean | True if file1 exists and is a directory
  #     "e"  | boolean | True if file1 exists
  #     "f"  | boolean | True if file1 exists and is a regular file
  #     "g"  | boolean | True if file1 has the \CF{setgid} bit
  #          |         | set (false under NT)
  #     "G"  | boolean | True if file1 exists and has a group
  #          |         | ownership equal to the caller's group
  #     "k"  | boolean | True if file1 exists and has the sticky bit set
  #     "l"  | boolean | True if file1 exists and is a symbolic link
  #     "M"  | Time    | Last modification time for file1
  #     "o"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's effective uid
  #     "O"  | boolean | True if file1 exists and is owned by
  #          |         | the caller's real uid
  #     "p"  | boolean | True if file1 exists and is a fifo
  #     "r"  | boolean | True if file1 is readable by the effective
  #          |         | uid/gid of the caller
  #     "R"  | boolean | True if file is readable by the real
  #          |         | uid/gid of the caller
  #     "s"  | int/nil | If file1 has nonzero size, return the size,
  #          |         | otherwise return nil
  #     "S"  | boolean | True if file1 exists and is a socket
  #     "u"  | boolean | True if file1 has the setuid bit set
  #     "w"  | boolean | True if file1 exists and is writable by
  #          |         | the effective uid/gid
  #     "W"  | boolean | True if file1 exists and is writable by
  #          |         | the real uid/gid
  #     "x"  | boolean | True if file1 exists and is executable by
  #          |         | the effective uid/gid
  #     "X"  | boolean | True if file1 exists and is executable by
  #          |         | the real uid/gid
  #     "z"  | boolean | True if file1 exists and has a zero length
  #
  # Tests that take two files:
  #
  #     "-"  | boolean | True if file1 and file2 are identical
  #     "="  | boolean | True if the modification times of file1
  #          |         | and file2 are equal
  #     "<"  | boolean | True if the modification time of file1
  #          |         | is prior to that of file2
  #     ">"  | boolean | True if the modification time of file1
  #          |         | is after that of file2
  #
  def self?.test: (String | Integer cmd, String | IO file1, ?String | IO file2) -> (TrueClass | FalseClass | Time | nil | Integer)

  # <!--
  #   rdoc-file=vm_eval.c
  #   - throw(tag [, obj])
  # -->
  # Transfers control to the end of the active `catch` block waiting for *tag*.
  # Raises `UncaughtThrowError` if there is no `catch` block for the *tag*. The
  # optional second parameter supplies a return value for the `catch` block, which
  # otherwise defaults to `nil`. For examples, see Kernel::catch.
  #
  def self?.throw: (Object tag, ?untyped obj) -> bot

  # <!--
  #   rdoc-file=warning.rb
  #   - warn(*msgs, uplevel: nil, category: nil)   -> nil
  # -->
  # If warnings have been disabled (for example with the `-W0` flag), does
  # nothing.  Otherwise, converts each of the messages to strings, appends a
  # newline character to the string if the string does not end in a newline, and
  # calls Warning.warn with the string.
  #
  #       warn("warning 1", "warning 2")
  #
  #     <em>produces:</em>
  #
  #       warning 1
  #       warning 2
  #
  # If the `uplevel` keyword argument is given, the string will be prepended with
  # information for the given caller frame in the same format used by the
  # `rb_warn` C function.
  #
  #       # In baz.rb
  #       def foo
  #         warn("invalid call to foo", uplevel: 1)
  #       end
  #
  #       def bar
  #         foo
  #       end
  #
  #       bar
  #
  #     <em>produces:</em>
  #
  #       baz.rb:6: warning: invalid call to foo
  #
  # If `category` keyword argument is given, passes the category to
  # `Warning.warn`.  The category given must be be one of the following
  # categories:
  #
  # :deprecated
  # :   Used for warning for deprecated functionality that may be removed in the
  #     future.
  # :experimental
  # :   Used for experimental features that may change in future releases.
  #
  def self?.warn: (*untyped msg, ?uplevel: Integer | nil) -> NilClass

  # <!--
  #   rdoc-file=process.c
  #   - exec([env,] command... [,options])
  # -->
  # Replaces the current process by running the given external *command*, which
  # can take one of the following forms:
  #
  # `exec(commandline)`
  # :   command line string which is passed to the standard shell
  # `exec(cmdname, arg1, ...)`
  # :   command name and one or more arguments (no shell)
  # `exec([cmdname, argv0], arg1, ...)`
  # :   command name, [argv](0) and zero or more arguments (no shell)
  #
  #
  # In the first form, the string is taken as a command line that is subject to
  # shell expansion before being executed.
  #
  # The standard shell always means `"/bin/sh"` on Unix-like systems, otherwise,
  # `ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows and similar.  The command is
  # passed as an argument to the `"-c"` switch to the shell, except in the case of
  # `COMSPEC`.
  #
  # If the string from the first form (`exec("command")`) follows these simple
  # rules:
  #
  # *   no meta characters
  # *   not starting with shell reserved word or special built-in
  # *   Ruby invokes the command directly without shell
  #
  #
  # You can force shell invocation by adding ";" to the string (because ";" is a
  # meta character).
  #
  # Note that this behavior is observable by pid obtained (return value of spawn()
  # and IO#pid for IO.popen) is the pid of the invoked command, not shell.
  #
  # In the second form (`exec("command1", "arg1", ...)`), the first is taken as a
  # command name and the rest are passed as parameters to command with no shell
  # expansion.
  #
  # In the third form (`exec(["command", "argv0"], "arg1", ...)`), starting a
  # two-element array at the beginning of the command, the first element is the
  # command to be executed, and the second argument is used as the `argv[0]`
  # value, which may show up in process listings.
  #
  # In order to execute the command, one of the `exec(2)` system calls are used,
  # so the running command may inherit some of the environment of the original
  # program (including open file descriptors).
  #
  # This behavior is modified by the given `env` and `options` parameters. See
  # ::spawn for details.
  #
  # If the command fails to execute (typically Errno::ENOENT when it was not
  # found) a SystemCallError exception is raised.
  #
  # This method modifies process attributes according to given `options` before
  # `exec(2)` system call. See ::spawn for more details about the given `options`.
  #
  # The modified attributes may be retained when `exec(2)` system call fails.
  #
  # For example, hard resource limits are not restorable.
  #
  # Consider to create a child process using ::spawn or Kernel#system if this is
  # not acceptable.
  #
  #     exec "echo *"       # echoes list of files in current directory
  #     # never get here
  #
  #     exec "echo", "*"    # echoes an asterisk
  #     # never get here
  #
  def self?.exec: (*String args) -> bot

  type redirect_fd = Integer | :in | :out | :err | IO | String | [ String ] | [ String, string | int ] | [ String, string | int, int ] | [ :child, int ] | :close

  # <!--
  #   rdoc-file=process.c
  #   - spawn([env,] command... [,options])     -> pid
  #   - Process.spawn([env,] command... [,options])     -> pid
  # -->
  # spawn executes specified command and return its pid.
  #
  #     pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
  #     Process.wait pid
  #
  #     pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
  #     Process.wait pid
  #
  # This method is similar to Kernel#system but it doesn't wait for the command to
  # finish.
  #
  # The parent process should use Process.wait to collect the termination status
  # of its child or use Process.detach to register disinterest in their status;
  # otherwise, the operating system may accumulate zombie processes.
  #
  # spawn has bunch of options to specify process attributes:
  #
  #     env: hash
  #       name => val : set the environment variable
  #       name => nil : unset the environment variable
  #
  #       the keys and the values except for +nil+ must be strings.
  #     command...:
  #       commandline                 : command line string which is passed to the standard shell
  #       cmdname, arg1, ...          : command name and one or more arguments (This form does not use the shell. See below for caveats.)
  #       [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)
  #     options: hash
  #       clearing environment variables:
  #         :unsetenv_others => true   : clear environment variables except specified by env
  #         :unsetenv_others => false  : don't clear (default)
  #       process group:
  #         :pgroup => true or 0 : make a new process group
  #         :pgroup => pgid      : join the specified process group
  #         :pgroup => nil       : don't change the process group (default)
  #       create new process group: Windows only
  #         :new_pgroup => true  : the new process is the root process of a new process group
  #         :new_pgroup => false : don't create a new process group (default)
  #       resource limit: resourcename is core, cpu, data, etc.  See Process.setrlimit.
  #         :rlimit_resourcename => limit
  #         :rlimit_resourcename => [cur_limit, max_limit]
  #       umask:
  #         :umask => int
  #       redirection:
  #         key:
  #           FD              : single file descriptor in child process
  #           [FD, FD, ...]   : multiple file descriptor in child process
  #         value:
  #           FD                        : redirect to the file descriptor in parent process
  #           string                    : redirect to file with open(string, "r" or "w")
  #           [string]                  : redirect to file with open(string, File::RDONLY)
  #           [string, open_mode]       : redirect to file with open(string, open_mode, 0644)
  #           [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)
  #           [:child, FD]              : redirect to the redirected file descriptor
  #           :close                    : close the file descriptor in child process
  #         FD is one of follows
  #           :in     : the file descriptor 0 which is the standard input
  #           :out    : the file descriptor 1 which is the standard output
  #           :err    : the file descriptor 2 which is the standard error
  #           integer : the file descriptor of specified the integer
  #           io      : the file descriptor specified as io.fileno
  #       file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not
  #         :close_others => false  : inherit
  #       current directory:
  #         :chdir => str
  #
  # The `cmdname, arg1, ...` form does not use the shell. However, on different
  # OSes, different things are provided as built-in commands. An example of this
  # is +'echo'+, which is a built-in on Windows, but is a normal program on Linux
  # and Mac OS X. This means that `Process.spawn 'echo', '%Path%'` will display
  # the contents of the `%Path%` environment variable on Windows, but
  # `Process.spawn 'echo', '$PATH'` prints the literal `$PATH`.
  #
  # If a hash is given as `env`, the environment is updated by `env` before
  # `exec(2)` in the child process. If a pair in `env` has nil as the value, the
  # variable is deleted.
  #
  #     # set FOO as BAR and unset BAZ.
  #     pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)
  #
  # If a hash is given as `options`, it specifies process group, create new
  # process group, resource limit, current directory, umask and redirects for the
  # child process. Also, it can be specified to clear environment variables.
  #
  # The `:unsetenv_others` key in `options` specifies to clear environment
  # variables, other than specified by `env`.
  #
  #     pid = spawn(command, :unsetenv_others=>true) # no environment variable
  #     pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only
  #
  # The `:pgroup` key in `options` specifies a process group. The corresponding
  # value should be true, zero, a positive integer, or nil. true and zero cause
  # the process to be a process leader of a new process group. A non-zero positive
  # integer causes the process to join the provided process group. The default
  # value, nil, causes the process to remain in the same process group.
  #
  #     pid = spawn(command, :pgroup=>true) # process leader
  #     pid = spawn(command, :pgroup=>10) # belongs to the process group 10
  #
  # The `:new_pgroup` key in `options` specifies to pass
  # `CREATE_NEW_PROCESS_GROUP` flag to `CreateProcessW()` that is Windows API.
  # This option is only for Windows. true means the new process is the root
  # process of the new process group. The new process has CTRL+C disabled. This
  # flag is necessary for `Process.kill(:SIGINT, pid)` on the subprocess.
  # :new_pgroup is false by default.
  #
  #     pid = spawn(command, :new_pgroup=>true)  # new process group
  #     pid = spawn(command, :new_pgroup=>false) # same process group
  #
  # The `:rlimit_`*foo* key specifies a resource limit. *foo* should be one of
  # resource types such as `core`. The corresponding value should be an integer or
  # an array which have one or two integers: same as cur_limit and max_limit
  # arguments for Process.setrlimit.
  #
  #     cur, max = Process.getrlimit(:CORE)
  #     pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
  #     pid = spawn(command, :rlimit_core=>max) # enable core dump
  #     pid = spawn(command, :rlimit_core=>0) # never dump core.
  #
  # The `:umask` key in `options` specifies the umask.
  #
  #     pid = spawn(command, :umask=>077)
  #
  # The :in, :out, :err, an integer, an IO and an array key specifies a
  # redirection. The redirection maps a file descriptor in the child process.
  #
  # For example, stderr can be merged into stdout as follows:
  #
  #     pid = spawn(command, :err=>:out)
  #     pid = spawn(command, 2=>1)
  #     pid = spawn(command, STDERR=>:out)
  #     pid = spawn(command, STDERR=>STDOUT)
  #
  # The hash keys specifies a file descriptor in the child process started by
  # #spawn. :err, 2 and STDERR specifies the standard error stream (stderr).
  #
  # The hash values specifies a file descriptor in the parent process which
  # invokes #spawn. :out, 1 and STDOUT specifies the standard output stream
  # (stdout).
  #
  # In the above example, the standard output in the child process is not
  # specified. So it is inherited from the parent process.
  #
  # The standard input stream (stdin) can be specified by :in, 0 and STDIN.
  #
  # A filename can be specified as a hash value.
  #
  #     pid = spawn(command, :in=>"/dev/null") # read mode
  #     pid = spawn(command, :out=>"/dev/null") # write mode
  #     pid = spawn(command, :err=>"log") # write mode
  #     pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
  #     pid = spawn(command, 3=>"/dev/null") # read mode
  #
  # For stdout and stderr (and combination of them), it is opened in write mode.
  # Otherwise read mode is used.
  #
  # For specifying flags and permission of file creation explicitly, an array is
  # used instead.
  #
  #     pid = spawn(command, :in=>["file"]) # read mode is assumed
  #     pid = spawn(command, :in=>["file", "r"])
  #     pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
  #     pid = spawn(command, :out=>["log", "w", 0600])
  #     pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])
  #
  # The array specifies a filename, flags and permission. The flags can be a
  # string or an integer. If the flags is omitted or nil, File::RDONLY is assumed.
  # The permission should be an integer. If the permission is omitted or nil, 0644
  # is assumed.
  #
  # If an array of IOs and integers are specified as a hash key, all the elements
  # are redirected.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, [:out, :err]=>["log", "w"])
  #
  # Another way to merge multiple file descriptors is [:child, fd]. [:child, fd]
  # means the file descriptor in the child process. This is different from fd. For
  # example, :err=>:out means redirecting child stderr to parent stdout. But
  # :err=>[:child, :out] means redirecting child stderr to child stdout. They
  # differ if stdout is redirected in the child process as follows.
  #
  #     # stdout and stderr is redirected to log file.
  #     # The file "log" is opened just once.
  #     pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])
  #
  # [:child, :out] can be used to merge stderr into stdout in IO.popen. In this
  # case, IO.popen redirects stdout to a pipe in the child process and [:child,
  # :out] refers the redirected stdout.
  #
  #     io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
  #     p io.read #=> "out\nerr\n"
  #
  # The `:chdir` key in `options` specifies the current directory.
  #
  #     pid = spawn(command, :chdir=>"/var/tmp")
  #
  # spawn closes all non-standard unspecified descriptors by default. The
  # "standard" descriptors are 0, 1 and 2. This behavior is specified by
  # :close_others option. :close_others doesn't affect the standard descriptors
  # which are closed only if :close is specified explicitly.
  #
  #     pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
  #     pid = spawn(command, :close_others=>false) # don't close 3,4,5,...
  #
  # :close_others is false by default for spawn and IO.popen.
  #
  # Note that fds which close-on-exec flag is already set are closed regardless of
  # :close_others option.
  #
  # So IO.pipe and spawn can be used as IO.popen.
  #
  #     # similar to r = IO.popen(command)
  #     r, w = IO.pipe
  #     pid = spawn(command, :out=>w)   # r, w is closed in the child process.
  #     w.close
  #
  # :close is specified as a hash value to close a fd individually.
  #
  #     f = open(foo)
  #     system(command, f=>:close)        # don't inherit f.
  #
  # If a file descriptor need to be inherited, io=>io can be used.
  #
  #     # valgrind has --log-fd option for log destination.
  #     # log_w=>log_w indicates log_w.fileno inherits to child process.
  #     log_r, log_w = IO.pipe
  #     pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
  #     log_w.close
  #     p log_r.read
  #
  # It is also possible to exchange file descriptors.
  #
  #     pid = spawn(command, :out=>:err, :err=>:out)
  #
  # The hash keys specify file descriptors in the child process. The hash values
  # specifies file descriptors in the parent process. So the above specifies
  # exchanging stdout and stderr. Internally, `spawn` uses an extra file
  # descriptor to resolve such cyclic file descriptor mapping.
  #
  # See Kernel.exec for the standard shell.
  #
  def self?.spawn: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer
                 | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> Integer

  # <!--
  #   rdoc-file=process.c
  #   - system([env,] command... [,options], exception: false)    -> true, false or nil
  # -->
  # Executes *command...* in a subshell. *command...* is one of following forms.
  #
  # `commandline`
  # :   command line string which is passed to the standard shell
  # `cmdname, arg1, ...`
  # :   command name and one or more arguments (no shell)
  # `[cmdname, argv0], arg1, ...`
  # :   command name, `argv[0]` and zero or more arguments (no shell)
  #
  #
  # system returns `true` if the command gives zero exit status, `false` for non
  # zero exit status. Returns `nil` if command execution fails. An error status is
  # available in `$?`.
  #
  # If the `exception: true` argument is passed, the method raises an exception
  # instead of returning `false` or `nil`.
  #
  # The arguments are processed in the same way as for Kernel#spawn.
  #
  # The hash arguments, env and options, are same as #exec and #spawn. See
  # Kernel#spawn for details.
  #
  #     system("echo *")
  #     system("echo", "*")
  #
  # *produces:*
  #
  #     config.h main.rb
  #     *
  #
  # Error handling:
  #
  #     system("cat nonexistent.txt")
  #     # => false
  #     system("catt nonexistent.txt")
  #     # => nil
  #
  #     system("cat nonexistent.txt", exception: true)
  #     # RuntimeError (Command failed with exit 1: cat)
  #     system("catt nonexistent.txt", exception: true)
  #     # Errno::ENOENT (No such file or directory - catt)
  #
  # See Kernel#exec for the standard shell.
  #
  def self?.system: (String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)
                  | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: boolish, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: boolish, ?chdir: String) -> (NilClass | FalseClass | TrueClass)
end

Kernel::RUBYGEMS_ACTIVATION_MONITOR: untyped

# <!-- rdoc-file=file.c -->
# A File is an abstraction of any file object accessible by the program and is
# closely associated with class IO.  File includes the methods of module
# FileTest as class methods, allowing you to write (for example)
# `File.exist?("foo")`.
#
# In the description of File methods, *permission bits* are a platform-specific
# set of bits that indicate permissions of a file. On Unix-based systems,
# permissions are viewed as a set of three octets, for the owner, the group, and
# the rest of the world. For each of these entities, permissions may be set to
# read, write, or execute the file:
#
# The permission bits `0644` (in octal) would thus be interpreted as read/write
# for owner, and read-only for group and other. Higher-order bits may also be
# used to indicate the type of file (plain, directory, pipe, socket, and so on)
# and various other special features. If the permissions are for a directory,
# the meaning of the execute bit changes; when set the directory can be
# searched.
#
# On non-Posix operating systems, there may be only the ability to make a file
# read-only or read-write. In this case, the remaining permission bits will be
# synthesized to resemble typical values. For instance, on Windows NT the
# default permission bits are `0644`, which means read/write for owner,
# read-only for all others. The only change that can be made is to make the file
# read-only, which is reported as `0444`.
#
# Various constants for the methods in File can be found in File::Constants.
#
# ## What's Here
#
# First, what's elsewhere. Class File:
#
# *   Inherits from [class IO](IO.html#class-IO-label-What-27s+Here), in
#     particular, methods for creating, reading, and writing files
# *   Includes [module
#     FileTest](FileTest.html#module-FileTest-label-What-27s+Here). which
#     provides dozens of additional methods.
#
#
# Here, class File provides methods that are useful for:
#
# *   [Creating](#class-File-label-Creating)
# *   [Querying](#class-File-label-Querying)
# *   [Settings](#class-File-label-Settings)
# *   [Other](#class-File-label-Other)
#
#
# ### Creating
#
#     ::new
# :       Opens the file at the given path; returns the file.
#
#     ::open
# :       Same as ::new, but when given a block will yield the file to the
#         block, and close the file upon exiting the block.
#
#     ::link
# :       Creates a new name for an existing file using a hard link.
#
#     ::mkfifo
# :       Returns the FIFO file created at the given path.
#
#     ::symlink
# :       Creates a symbolic link for the given file path.
#
#
#
# ### Querying
#
# *Paths*
#
#     ::absolute_path
# :       Returns the absolute file path for the given path.
#
#     ::absolute_path?
# :       Returns whether the given path is the absolute file path.
#
#     ::basename
# :       Returns the last component of the given file path.
#
#     ::dirname
# :       Returns all but the last component of the given file path.
#
#     ::expand_path
# :       Returns the absolute file path for the given path, expanding `~` for a
#         home directory.
#
#     ::extname
# :       Returns the file extension for the given file path.
#
#     ::fnmatch? (aliased as ::fnmatch)
# :       Returns whether the given file path matches the given pattern.
#
#     ::join
# :       Joins path components into a single path string.
#
#     ::path
# :       Returns the string representation of the given path.
#
#     ::readlink
# :       Returns the path to the file at the given symbolic link.
#
#     ::realdirpath
# :       Returns the real path for the given file path, where the last
#         component need not exist.
#
#     ::realpath
# :       Returns the real path for the given file path, where all components
#         must exist.
#
#     ::split
# :       Returns an array of two strings: the directory name and basename of
#         the file at the given path.
#
#     #path (aliased as #to_path)
# :       Returns the string representation of the given path.
#
#
#
# *Times*
#
#     ::atime
# :       Returns a Time for the most recent access to the given file.
#
#     ::birthtime
# :       Returns a Time  for the creation of the given file.
#
#     ::ctime
# :       Returns a Time  for the metadata change of the given file.
#
#     ::mtime
# :       Returns a Time for the most recent data modification to the content of
#         the given file.
#
#     #atime
# :       Returns a Time for the most recent access to `self`.
#
#     #birthtime
# :       Returns a Time  the creation for `self`.
#
#     #ctime
# :       Returns a Time for the metadata change of `self`.
#
#     #mtime
# :       Returns a Time for the most recent data modification to the content of
#         `self`.
#
#
#
# *Types*
#
#     ::blockdev?
# :       Returns whether the file at the given path is a block device.
#
#     ::chardev?
# :       Returns whether the file at the given path is a character device.
#
#     ::directory?
# :       Returns whether the file at the given path is a diretory.
#
#     ::executable?
# :       Returns whether the file at the given path is executable by the
#         effective user and group of the current process.
#
#     ::executable_real?
# :       Returns whether the file at the given path is executable by the real
#         user and group of the current process.
#
#     ::exist?
# :       Returns whether the file at the given path exists.
#
#     ::file?
# :       Returns whether the file at the given path is a regular file.
#
#     ::ftype
# :       Returns a string giving the type of the file at the given path.
#
#     ::grpowned?
# :       Returns whether the effective group of the current process owns the
#         file at the given path.
#
#     ::identical?
# :       Returns whether the files at two given paths are identical.
#
#     ::lstat
# :       Returns the File::Stat object for the last symbolic link in the given
#         path.
#
#     ::owned?
# :       Returns whether the effective user of the current process owns the
#         file at the given path.
#
#     ::pipe?
# :       Returns whether the file at the given path is a pipe.
#
#     ::readable?
# :       Returns whether the file at the given path is readable by the
#         effective user and group of the current process.
#
#     ::readable_real?
# :       Returns whether the file at the given path is readable by the real
#         user and group of the current process.
#
#     ::setgid?
# :       Returns whether the setgid bit is set for the file at the given path.
#
#     ::setuid?
# :       Returns whether the setuid bit is set for the file at the given path.
#
#     ::socket?
# :       Returns whether the file at the given path is a socket.
#
#     ::stat
# :       Returns the File::Stat object for the file at the given path.
#
#     ::sticky?
# :       Returns whether the file at the given path has its sticky bit set.
#
#     ::symlink?
# :       Returns whether the file at the given path is a symbolic link.
#
#     ::umask
# :       Returns the umask value for the current process.
#
#     ::world_readable?
# :       Returns whether the file at the given path is readable by others.
#
#     ::world_writable?
# :       Returns whether the file at the given path is writable by others.
#
#     ::writable?
# :       Returns whether the file at the given path is writable by the
#         effective user and group of the current process.
#
#     ::writable_real?
# :       Returns whether the file at the given path is writable by the real
#         user and group of the current process.
#
#     #lstat
# :       Returns the File::Stat object for the last symbolic link in the path
#         for `self`.
#
#
#
# *Contents*
#
#     ::empty? (aliased as ::zero?)
# :       Returns whether the file at the given path exists and is empty.
#
#     ::size
# :       Returns the size (bytes) of the file at the given path.
#
#     ::size?
# :       Returns `nil` if there is no file at the given path, or if that file
#         is empty; otherwise returns the file size (bytes).
#
#     #size
# :       Returns the size (bytes) of `self`.
#
#
#
# ### Settings
#
#     ::chmod
# :       Changes permissions of the file at the given path.
#
#     ::chown
# :       Change ownership of the file at the given path.
#
#     ::lchmod
# :       Changes permissions of the last symbolic link in the given path.
#
#     ::lchown
# :       Change ownership of the last symbolic in the given path.
#
#     ::lutime
# :       For each given file path, sets the access time and modification time
#         of the last symbolic link in the path.
#
#     ::rename
# :       Moves the file at one given path to another given path.
#
#     ::utime
# :       Sets the access time and modification time of each file at the given
#         paths.
#
#     #flock
# :       Locks or unlocks `self`.
#
#
#
# ### Other
#
#     ::truncate
# :       Truncates the file at the given file path to the given size.
#
#     ::unlink (aliased as ::delete)
# :       Deletes the file for each given file path.
#
#     #truncate
# :       Truncates `self` to the given size.
#
class File < IO
  # <!--
  #   rdoc-file=io.c
  #   - File.new(filename, mode="r" [, opt])            -> file
  #   - File.new(filename [, mode [, perm]] [, opt])    -> file
  # -->
  # Opens the file named by `filename` according to the given `mode` and returns a
  # new File object.
  #
  # See IO.new for a description of `mode` and `opt`.
  #
  # If a file is being created, permission bits may be given in `perm`.  These
  # mode and permission bits are platform dependent; on Unix systems, see open(2)
  # and chmod(2) man pages for details.
  #
  # The new File object is buffered mode (or non-sync mode), unless `filename` is
  # a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync= about sync mode.
  #
  # ### Examples
  #
  #     f = File.new("testfile", "r")
  #     f = File.new("newfile",  "w+")
  #     f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)
  #
  def initialize: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> File

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless *dir_string* is
  # given, in which case it will be used as the starting point. If the given
  # pathname starts with a ```~`'' it is NOT expanded, it is treated as a normal
  # directory name.
  #
  #     File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
  #
  def self.absolute_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.absolute_path?(file_name)  ->  true or false
  # -->
  # Returns `true` if `file_name` is an absolute path, and `false` otherwise.
  #
  #     File.absolute_path?("c:/foo")     #=> false (on Linux), true (on Windows)
  #
  def self.absolute_path?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.atime(file_name)  ->  time
  # -->
  # Returns the last access time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003
  #
  def self.atime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.basename(file_name [, suffix] )  ->  base_name
  # -->
  # Returns the last component of the filename given in *file_name* (after first
  # stripping trailing separators), which can be formed using both File::SEPARATOR
  # and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not
  # `nil`. If *suffix* is given and present at the end of *file_name*, it is
  # removed. If *suffix* is ".*", any extension will be removed.
  #
  #     File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
  #     File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
  #     File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"
  #
  def self.basename: (string | _ToPath file_name, ?string suffix) -> String

  # <!--
  #   rdoc-file=file.c
  #   - birthtime(p1)
  # -->
  #
  def self.birthtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.blockdev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a block device.
  #
  # *file_name* can be an IO object.
  #
  def self.blockdev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chardev?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a character device.
  #
  # *file_name* can be an IO object.
  #
  def self.chardev?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.chmod(mode_int, file_name, ... )  ->  integer
  # -->
  # Changes permission bits on the named file(s) to the bit pattern represented by
  # *mode_int*. Actual effects are operating system dependent (see the beginning
  # of this section). On Unix systems, see `chmod(2)` for details. Returns the
  # number of files processed.
  #
  #     File.chmod(0644, "testfile", "out")   #=> 2
  #
  def self.chmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.chown(owner_int, group_int, file_name, ...)  ->  integer
  # -->
  # Changes the owner and group of the named file(s) to the given numeric owner
  # and group id's. Only a process with superuser privileges may change the owner
  # of a file. The current owner of a file may change the file's group to any
  # group to which the owner belongs. A `nil` or -1 owner or group id is ignored.
  # Returns the number of files processed.
  #
  #     File.chown(nil, 100, "testfile")
  #
  def self.chown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.ctime(file_name)  -> time
  # -->
  # Returns the change time for the named file (the time at which directory
  # information about the file was changed, not the file itself).
  #
  # *file_name* can be an IO object.
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
  #
  def self.ctime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  alias self.delete self.unlink

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def self.directory?: (string | _ToPath | IO path) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.dirname(file_name, level = 1)  ->  dir_name
  # -->
  # Returns all components of the filename given in *file_name* except the last
  # one (after first stripping trailing separators). The filename can be formed
  # using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when
  # File::ALT_SEPARATOR is not `nil`.
  #
  #     File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"
  #
  # If `level` is given, removes the last `level` components, not only one.
  #
  #     File.dirname("/home/gumby/work/ruby.rb", 2) #=> "/home/gumby"
  #     File.dirname("/home/gumby/work/ruby.rb", 4) #=> "/"
  #
  def self.dirname: (string | _ToPath file_name, ?Integer level) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  alias self.empty? self.zero?

  # <!--
  #   rdoc-file=file.c
  #   - File.executable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the effective user/group.
  #
  def self.executable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.executable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is executable by the real user and group id
  # of this process. See access(3).
  #
  # Windows does not support execute permissions separately from read permissions.
  # On Windows, a file is only considered executable if it ends in .bat, .cmd,
  # .com, or .exe.
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not executable by the real user/group.
  #
  def self.executable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.exist?(file_name)    ->  true or false
  # -->
  # Return `true` if the named file exists.
  #
  # *file_name* can be an IO object.
  #
  # "file exists" means that stat() or fstat() system call is successful.
  #
  def self.exist?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.expand_path(file_name [, dir_string] )  ->  abs_file_name
  # -->
  # Converts a pathname to an absolute pathname. Relative paths are referenced
  # from the current working directory of the process unless `dir_string` is
  # given, in which case it will be used as the starting point. The given pathname
  # may start with a ```~`'', which expands to the process owner's home directory
  # (the environment variable `HOME` must be set correctly). ```~`*user*'' expands
  # to the named user's home directory.
  #
  #     File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"
  #
  # A simple example of using `dir_string` is as follows.
  #     File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"
  #
  # A more complex example which also resolves parent directory is as follows.
  # Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.
  #
  #     File.expand_path("../../lib/mygem.rb", __FILE__)
  #     #=> ".../path/to/project/lib/mygem.rb"
  #
  # So first it resolves the parent of __FILE__, that is bin/, then go to the
  # parent, the root of the project and appends `lib/mygem.rb`.
  #
  def self.expand_path: (string | _ToPath file_name, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.extname(path)  ->  string
  # -->
  # Returns the extension (the portion of file name in `path` starting from the
  # last period).
  #
  # If `path` is a dotfile, or starts with a period, then the starting dot is not
  # dealt with the start of the extension.
  #
  # An empty string will also be returned when the period is the last character in
  # `path`.
  #
  # On Windows, trailing dots are truncated.
  #
  #     File.extname("test.rb")         #=> ".rb"
  #     File.extname("a/b/d/test.rb")   #=> ".rb"
  #     File.extname(".a/b/d/test.rb")  #=> ".rb"
  #     File.extname("foo.")            #=> "" on Windows
  #     File.extname("foo.")            #=> "." on non-Windows
  #     File.extname("test")            #=> ""
  #     File.extname(".profile")        #=> ""
  #     File.extname(".profile.sh")     #=> ".sh"
  #
  def self.extname: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.file?(file) -> true or false
  # -->
  # Returns `true` if the named `file` exists and is a regular file.
  #
  # `file` can be an IO object.
  #
  # If the `file` argument is a symbolic link, it will resolve the symbolic link
  # and use the file referenced by the link.
  #
  def self.file?: (string | _ToPath | IO file) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - File.fnmatch( pattern, path, [flags] ) -> (true or false)
  #   - File.fnmatch?( pattern, path, [flags] ) -> (true or false)
  # -->
  # Returns true if `path` matches against `pattern`.  The pattern is not a
  # regular expression; instead it follows rules similar to shell filename
  # globbing.  It may contain the following metacharacters:
  #
  # `*`
  # :   Matches any file. Can be restricted by other values in the glob.
  #     Equivalent to `/.*/x` in regexp.
  #
  #     `*`
  # :       Matches all regular files
  #     `c*`
  # :       Matches all files beginning with `c`
  #     `*c`
  # :       Matches all files ending with `c`
  #     `*c*`
  # :       Matches all files that have `c` in them (including at the beginning or
  #         end).
  #
  #
  #     To match hidden files (that start with a `.`) set the File::FNM_DOTMATCH
  #     flag.
  #
  # `**`
  # :   Matches directories recursively or files expansively.
  #
  # `?`
  # :   Matches any one character. Equivalent to `/.{1}/` in regexp.
  #
  # `[set]`
  # :   Matches any one character in `set`.  Behaves exactly like character sets
  #     in Regexp, including set negation (`[^a-z]`).
  #
  # `\`
  # :   Escapes the next metacharacter.
  #
  # `{a,b}`
  # :   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.
  #     Behaves like a Regexp union (`(?:a|b)`).
  #
  #
  # `flags` is a bitwise OR of the `FNM_XXX` constants. The same glob pattern and
  # flags are used by Dir::glob.
  #
  # Examples:
  #
  #     File.fnmatch('cat',       'cat')        #=> true  # match entire string
  #     File.fnmatch('cat',       'category')   #=> false # only match partial string
  #
  #     File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
  #     File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB
  #
  #     File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
  #     File.fnmatch('c??t',    'cat')          #=> false # ditto
  #     File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
  #     File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
  #     File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
  #     File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')
  #
  #     File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive
  #     File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default
  #
  #     File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
  #     File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
  #     File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto
  #
  #     File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
  #     File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
  #     File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
  #     File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression
  #
  #     File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
  #     File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
  #     File.fnmatch('.*',  '.profile')                      #=> true
  #
  #     File.fnmatch('**/*.rb', 'main.rb')                  #=> false
  #     File.fnmatch('**/*.rb', './main.rb')                #=> false
  #     File.fnmatch('**/*.rb', 'lib/song.rb')              #=> true
  #     File.fnmatch('**.rb', 'main.rb')                    #=> true
  #     File.fnmatch('**.rb', './main.rb')                  #=> false
  #     File.fnmatch('**.rb', 'lib/song.rb')                #=> true
  #     File.fnmatch('*',     'dave/.profile')              #=> true
  #
  #     File.fnmatch('**/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
  #     File.fnmatch('**/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
  #     File.fnmatch('**/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
  #     File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
  #
  def self.fnmatch: (string pattern, string | _ToPath path, ?int flags) -> bool

  # <!--
  #   rdoc-file=dir.rb
  #   - fnmatch?(pattern, path, flags = 0)
  # -->
  #
  alias self.fnmatch? self.fnmatch

  # <!--
  #   rdoc-file=file.c
  #   - File.ftype(file_name)   -> string
  # -->
  # Identifies the type of the named file; the return string is one of ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.ftype("testfile")            #=> "file"
  #     File.ftype("/dev/tty")            #=> "characterSpecial"
  #     File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
  #
  def self.ftype: (string | _ToPath file_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.grpowned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective group id of the
  # calling process is the owner of the file. Returns `false` on Windows.
  #
  # *file_name* can be an IO object.
  #
  def self.grpowned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.identical?(file_1, file_2)   ->  true or false
  # -->
  # Returns `true` if the named files are identical.
  #
  # *file_1* and *file_2* can be an IO object.
  #
  #     open("a", "w") {}
  #     p File.identical?("a", "a")      #=> true
  #     p File.identical?("a", "./a")    #=> true
  #     File.link("a", "b")
  #     p File.identical?("a", "b")      #=> true
  #     File.symlink("a", "c")
  #     p File.identical?("a", "c")      #=> true
  #     open("d", "w") {}
  #     p File.identical?("a", "d")      #=> false
  #
  def self.identical?: (string | _ToPath | IO file_1, string | _ToPath | IO file_2) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.join(string, ...)  ->  string
  # -->
  # Returns a new string formed by joining the strings using `"/"`.
  #
  #     File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"
  #
  def self.join: (*string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.lchmod(mode_int, file_name, ...)  -> integer
  # -->
  # Equivalent to File::chmod, but does not follow symbolic links (so it will
  # change the permissions associated with the link, not the file referenced by
  # the link). Often not available.
  #
  def self.lchmod: (int mode, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.lchown(owner_int, group_int, file_name,..) -> integer
  # -->
  # Equivalent to File::chown, but does not follow symbolic links (so it will
  # change the owner associated with the link, not the file referenced by the
  # link). Often not available. Returns number of files in the argument list.
  #
  def self.lchown: (int? owner, int? group, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.link(old_name, new_name)    -> 0
  # -->
  # Creates a new name for an existing file using a hard link. Will not overwrite
  # *new_name* if it already exists (raising a subclass of SystemCallError). Not
  # available on all platforms.
  #
  #     File.link("testfile", ".testfile")   #=> 0
  #     IO.readlines(".testfile")[0]         #=> "This is line one\n"
  #
  def self.link: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.lstat(file_name)   -> stat
  # -->
  # Same as File::stat, but does not follow the last symbolic link. Instead,
  # reports on the link itself.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.stat("testfile").size              #=> 66
  #     File.lstat("link2test").size            #=> 8
  #     File.stat("link2test").size             #=> 66
  #
  def self.lstat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.lutime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon the link itself as
  # opposed to its referent; for the inverse behavior, see File.utime. Returns the
  # number of file names in the argument list.
  #
  def self.lutime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.mkfifo(file_name, mode=0666)  => 0
  # -->
  # Creates a FIFO special file with name *file_name*.  *mode* specifies the
  # FIFO's permissions. It is modified by the process's umask in the usual way:
  # the permissions of the created file are (mode & ~umask).
  #
  def self.mkfifo: (string | _ToPath file_name, ?int mode) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.mtime(file_name)  ->  time
  # -->
  # Returns the modification time for the named file as a Time object.
  #
  # *file_name* can be an IO object.
  #
  #     File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003
  #
  def self.mtime: (string | _ToPath | IO file_name) -> Time

  # <!--
  #   rdoc-file=io.c
  #   - File.open(filename, mode="r" [, opt])                 -> file
  #   - File.open(filename [, mode [, perm]] [, opt])         -> file
  #   - File.open(filename, mode="r" [, opt]) {|file| block } -> obj
  #   - File.open(filename [, mode [, perm]] [, opt]) {|file| block } -> obj
  # -->
  # With no associated block, File.open is a synonym for File.new. If the optional
  # code block is given, it will be passed the opened `file` as an argument and
  # the File object will automatically be closed when the block terminates.  The
  # value of the block will be returned from File.open.
  #
  # If a file is being created, its initial permissions may be set using the
  # `perm` parameter.  See File.new for further discussion.
  #
  # See IO.new for a description of the `mode` and `opt` parameters.
  #
  def self.open: (string | _ToPath | int file_name, ?string | int mode, ?int perm) -> instance
               | [T] (string | _ToPath | int file_name, ?string | int mode, ?int perm) { (File) -> T } -> T

  # <!--
  #   rdoc-file=file.c
  #   - File.owned?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and the effective used id of the
  # calling process is the owner of the file.
  #
  # *file_name* can be an IO object.
  #
  def self.owned?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.path(path)  ->  string
  # -->
  # Returns the string representation of the path
  #
  #     File.path("/dev/null")          #=> "/dev/null"
  #     File.path(Pathname.new("/tmp")) #=> "/tmp"
  #
  def self.path: (string | _ToPath path) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.pipe?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a pipe.
  #
  # *file_name* can be an IO object.
  #
  def self.pipe?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the effective user/group.
  #
  def self.readable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is readable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not readable by the real user/group.
  #
  def self.readable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.readlink(link_name)  ->  file_name
  # -->
  # Returns the name of the file referenced by the given link. Not available on
  # all platforms.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.readlink("link2test")              #=> "testfile"
  #
  def self.readlink: (string | _ToPath link_name) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realdirpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem.
  # The real pathname doesn't contain symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # The last component of the real pathname can be nonexistent.
  #
  def self.realdirpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.realpath(pathname [, dir_string])  ->  real_pathname
  # -->
  # Returns the real (absolute) pathname of *pathname* in the actual filesystem
  # not containing symlinks or useless dots.
  #
  # If *dir_string* is given, it is used as a base directory for interpreting
  # relative pathname instead of the current directory.
  #
  # All components of the pathname must exist when this method is called.
  #
  def self.realpath: (string | _ToPath pathname, ?string | _ToPath dir_string) -> String

  # <!--
  #   rdoc-file=file.c
  #   - File.rename(old_name, new_name)   -> 0
  # -->
  # Renames the given file to the new name. Raises a SystemCallError if the file
  # cannot be renamed.
  #
  #     File.rename("afile", "afile.bak")   #=> 0
  #
  def self.rename: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.setgid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setgid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setgid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.setuid?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the setuid bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.setuid?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.size(file_name)   -> integer
  # -->
  # Returns the size of `file_name`.
  #
  # *file_name* can be an IO object.
  #
  def self.size: (string | _ToPath | IO file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.size?(file_name)   -> Integer or nil
  # -->
  # Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
  # file otherwise.
  #
  # *file_name* can be an IO object.
  #
  def self.size?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.socket?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a socket.
  #
  # *file_name* can be an IO object.
  #
  def self.socket?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.split(file_name)   -> array
  # -->
  # Splits the given string into a directory and a file component and returns them
  # in a two-element array. See also File::dirname and File::basename.
  #
  #     File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]
  #
  def self.split: (string | _ToPath file_name) -> [ String, String ]

  # <!--
  #   rdoc-file=file.c
  #   - File.stat(file_name)   ->  stat
  # -->
  # Returns a File::Stat object for the named file (see File::Stat).
  #
  #     File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003
  #
  def self.stat: (string | _ToPath file_name) -> File::Stat

  # <!--
  #   rdoc-file=file.c
  #   - File.sticky?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file has the sticky bit set.
  #
  # *file_name* can be an IO object.
  #
  def self.sticky?: (string | _ToPath | IO file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink(old_name, new_name)   -> 0
  # -->
  # Creates a symbolic link called *new_name* for the existing file *old_name*.
  # Raises a NotImplemented exception on platforms that do not support symbolic
  # links.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #
  def self.symlink: (string | _ToPath old_name, string | _ToPath new_name) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.symlink?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a symbolic link.
  #
  def self.symlink?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.truncate(file_name, integer)  -> 0
  # -->
  # Truncates the file *file_name* to be at most *integer* bytes long. Not
  # available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.write("1234567890")     #=> 10
  #     f.close                   #=> nil
  #     File.truncate("out", 5)   #=> 0
  #     File.size("out")          #=> 5
  #
  def self.truncate: (string | _ToPath file_name, int length) -> 0

  # <!--
  #   rdoc-file=file.c
  #   - File.umask()          -> integer
  #   - File.umask(integer)   -> integer
  # -->
  # Returns the current umask value for this process. If the optional argument is
  # given, set the umask to that value and return the previous value. Umask values
  # are *subtracted* from the default permissions, so a umask of `0222` would make
  # a file read-only for everyone.
  #
  #     File.umask(0006)   #=> 18
  #     File.umask         #=> 6
  #
  def self.umask: (?int umask) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.delete(file_name, ...)  -> integer
  #   - File.unlink(file_name, ...)  -> integer
  # -->
  # Deletes the named files, returning the number of names passed as arguments.
  # Raises an exception on any error. Since the underlying implementation relies
  # on the `unlink(2)` system call, the type of exception raised depends on its
  # error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
  # Errno::ENOENT.
  #
  # See also Dir::rmdir.
  #
  def self.unlink: (*string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.utime(atime, mtime, file_name, ...)   ->  integer
  # -->
  # Sets the access and modification times of each named file to the first two
  # arguments. If a file is a symlink, this method acts upon its referent rather
  # than the link itself; for the inverse behavior see File.lutime. Returns the
  # number of file names in the argument list.
  #
  def self.utime: (Time | Numeric atime, Time | Numeric mtime, *string | _ToPath file_name) -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.world_readable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is readable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_readable?("/etc/passwd")           #=> 420
  #     m = File.world_readable?("/etc/passwd")
  #     sprintf("%o", m)                              #=> "644"
  #
  def self.world_readable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.world_writable?(file_name)   -> integer or nil
  # -->
  # If *file_name* is writable by others, returns an integer representing the file
  # permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
  # bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  # *file_name* can be an IO object.
  #
  #     File.world_writable?("/tmp")                  #=> 511
  #     m = File.world_writable?("/tmp")
  #     sprintf("%o", m)                              #=> "777"
  #
  def self.world_writable?: (string | _ToPath | IO file_name) -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - File.writable?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the effective user and group
  # id of this process. See eaccess(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the effective user/group.
  #
  def self.writable?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.writable_real?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file is writable by the real user and group id of
  # this process. See access(3).
  #
  # Note that some OS-level security features may cause this to return true even
  # though the file is not writable by the real user/group.
  #
  def self.writable_real?: (string | _ToPath file_name) -> bool

  # <!--
  #   rdoc-file=file.c
  #   - File.zero?(file_name)   -> true or false
  # -->
  # Returns `true` if the named file exists and has a zero size.
  #
  # *file_name* can be an IO object.
  #
  def self.zero?: (string | _ToPath | IO file_name) -> bool

  public

  # <!--
  #   rdoc-file=file.c
  #   - file.atime    -> time
  # -->
  # Returns the last access time (a Time object) for *file*, or epoch if *file*
  # has not been accessed.
  #
  #     File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.birthtime  ->  time
  # -->
  # Returns the birth time for *file*.
  #
  #     File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.chmod(mode_int)   -> 0
  # -->
  # Changes permission bits on *file* to the bit pattern represented by
  # *mode_int*. Actual effects are platform dependent; on Unix systems, see
  # `chmod(2)` for details. Follows symbolic links. Also see File#lchmod.
  #
  #     f = File.new("out", "w");
  #     f.chmod(0644)   #=> 0
  #
  def chmod: (int mode) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.chown(owner_int, group_int )   -> 0
  # -->
  # Changes the owner and group of *file* to the given numeric owner and group
  # id's. Only a process with superuser privileges may change the owner of a file.
  # The current owner of a file may change the file's group to any group to which
  # the owner belongs. A `nil` or -1 owner or group id is ignored. Follows
  # symbolic links. See also File#lchown.
  #
  #     File.new("testfile").chown(502, 1000)
  #
  def chown: (int? owner, int? group) -> (0 | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.ctime  ->  time
  # -->
  # Returns the change time for *file* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.flock(locking_constant) -> 0 or false
  # -->
  # Locks or unlocks a file according to *locking_constant* (a logical *or* of the
  # values in the table below). Returns `false` if File::LOCK_NB is specified and
  # the operation would otherwise have blocked. Not available on all platforms.
  #
  # Locking constants (in class File):
  #
  #     LOCK_EX   | Exclusive lock. Only one process may hold an
  #               | exclusive lock for a given file at a time.
  #     ----------+------------------------------------------------
  #     LOCK_NB   | Don't block when locking. May be combined
  #               | with other lock options using logical or.
  #     ----------+------------------------------------------------
  #     LOCK_SH   | Shared lock. Multiple processes may each hold a
  #               | shared lock for a given file at the same time.
  #     ----------+------------------------------------------------
  #     LOCK_UN   | Unlock.
  #
  # Example:
  #
  #     # update a counter using write lock
  #     # don't use "w" because it truncates the file before lock.
  #     File.open("counter", File::RDWR|File::CREAT, 0644) {|f|
  #       f.flock(File::LOCK_EX)
  #       value = f.read.to_i + 1
  #       f.rewind
  #       f.write("#{value}\n")
  #       f.flush
  #       f.truncate(f.pos)
  #     }
  #
  #     # read the counter using read lock
  #     File.open("counter", "r") {|f|
  #       f.flock(File::LOCK_SH)
  #       p f.read
  #     }
  #
  def flock: (int locking_constant) -> (0 | false)

  # <!--
  #   rdoc-file=file.c
  #   - file.lstat   ->  stat
  # -->
  # Same as IO#stat, but does not follow the last symbolic link. Instead, reports
  # on the link itself.
  #
  #     File.symlink("testfile", "link2test")   #=> 0
  #     File.stat("testfile").size              #=> 66
  #     f = File.new("link2test")
  #     f.lstat.size                            #=> 8
  #     f.stat.size                             #=> 66
  #
  def lstat: () -> (File::Stat | nil)

  # <!--
  #   rdoc-file=file.c
  #   - file.mtime  ->  time
  # -->
  # Returns the modification time for *file*.
  #
  #     File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - file.path  ->  filename
  #   - file.to_path  ->  filename
  # -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  def path: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - size()
  # -->
  #
  def size: () -> Integer

  # <!-- rdoc-file=file.c -->
  # Returns the pathname used to create *file* as a string. Does not normalize the
  # name.
  #
  # The pathname may not point to the file corresponding to *file*. For instance,
  # the pathname becomes void when the file has been moved or deleted.
  #
  # This method raises IOError for a *file* created using File::Constants::TMPFILE
  # because they don't have a pathname.
  #
  #     File.new("testfile").path               #=> "testfile"
  #     File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
  #
  alias to_path path

  # <!--
  #   rdoc-file=file.c
  #   - file.truncate(integer)    -> 0
  # -->
  # Truncates *file* to at most *integer* bytes. The file must be opened for
  # writing. Not available on all platforms.
  #
  #     f = File.new("out", "w")
  #     f.syswrite("1234567890")   #=> 10
  #     f.truncate(5)              #=> 0
  #     f.close()                  #=> nil
  #     File.size("out")           #=> 5
  #
  def truncate: (int length) -> 0
end

# <!-- rdoc-file=file.c -->
# platform specific alternative separator
#
File::ALT_SEPARATOR: String?

# <!-- rdoc-file=file.c -->
# path list separator
#
File::PATH_SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::SEPARATOR: String

# <!-- rdoc-file=file.c -->
# separates directory parts in path
#
File::Separator: String

module File::Constants
end

File::Constants::APPEND: Integer

File::Constants::BINARY: Integer

File::Constants::CREAT: Integer

File::Constants::DIRECT: Integer

File::Constants::DSYNC: Integer

File::Constants::EXCL: Integer

File::Constants::FNM_CASEFOLD: Integer

File::Constants::FNM_DOTMATCH: Integer

File::Constants::FNM_EXTGLOB: Integer

File::Constants::FNM_NOESCAPE: Integer

File::Constants::FNM_PATHNAME: Integer

File::Constants::FNM_SHORTNAME: Integer

File::Constants::FNM_SYSCASE: Integer

File::Constants::LOCK_EX: Integer

File::Constants::LOCK_NB: Integer

File::Constants::LOCK_SH: Integer

File::Constants::LOCK_UN: Integer

File::Constants::NOATIME: Integer

File::Constants::NOCTTY: Integer

File::Constants::NOFOLLOW: Integer

File::Constants::NONBLOCK: Integer

File::Constants::NULL: String

File::Constants::RDONLY: Integer

File::Constants::RDWR: Integer

File::Constants::RSYNC: Integer

File::Constants::SHARE_DELETE: Integer

File::Constants::SYNC: Integer

File::Constants::TMPFILE: Integer

File::Constants::TRUNC: Integer

File::Constants::WRONLY: Integer

# <!-- rdoc-file=file.c -->
# Objects of class File::Stat encapsulate common status information for File
# objects. The information is recorded at the moment the File::Stat object is
# created; changes made to the file after that point will not be reflected.
# File::Stat objects are returned by IO#stat, File::stat, File#lstat, and
# File::lstat. Many of these methods return platform-specific values, and not
# all values are meaningful on all systems. See also Kernel#test.
#
class File::Stat < Object
  include Comparable

  # <!--
  #   rdoc-file=file.c
  #   - File::Stat.new(file_name)  -> stat
  # -->
  # Create a File::Stat object for the given file name (raising an exception if
  # the file doesn't exist).
  #
  def initialize: (String file) -> Object

  # <!--
  #   rdoc-file=file.c
  #   - stat <=> other_stat    -> -1, 0, 1, nil
  # -->
  # Compares File::Stat objects by comparing their respective modification times.
  #
  # `nil` is returned if `other_stat` is not a File::Stat object
  #
  #     f1 = File.new("f1", "w")
  #     sleep 1
  #     f2 = File.new("f2", "w")
  #     f1.stat <=> f2.stat   #=> -1
  #
  def <=>: (File::Stat other) -> Integer
         | (untyped) -> nil

  # <!--
  #   rdoc-file=file.c
  #   - stat.atime   -> time
  # -->
  # Returns the last access time for this file as an object of class Time.
  #
  #     File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.birthtime  ->  aTime
  # -->
  # Returns the birth time for *stat*.
  #
  # If the platform doesn't have birthtime, raises NotImplementedError.
  #
  #     File.write("testfile", "foo")
  #     sleep 10
  #     File.write("testfile", "bar")
  #     sleep 10
  #     File.chmod(0644, "testfile")
  #     sleep 10
  #     File.read("testfile")
  #     File.stat("testfile").birthtime   #=> 2014-02-24 11:19:17 +0900
  #     File.stat("testfile").mtime       #=> 2014-02-24 11:19:27 +0900
  #     File.stat("testfile").ctime       #=> 2014-02-24 11:19:37 +0900
  #     File.stat("testfile").atime       #=> 2014-02-24 11:19:47 +0900
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.blksize   -> integer or nil
  # -->
  # Returns the native file system's block size. Will return `nil` on platforms
  # that don't support this information.
  #
  #     File.stat("testfile").blksize   #=> 4096
  #
  def blksize: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.blockdev?   -> true or false
  # -->
  # Returns `true` if the file is a block device, `false` if it isn't or if the
  # operating system doesn't support this feature.
  #
  #     File.stat("testfile").blockdev?    #=> false
  #     File.stat("/dev/hda1").blockdev?   #=> true
  #
  def blockdev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.blocks    -> integer or nil
  # -->
  # Returns the number of native file system blocks allocated for this file, or
  # `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("testfile").blocks   #=> 2
  #
  def blocks: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.chardev?    -> true or false
  # -->
  # Returns `true` if the file is a character device, `false` if it isn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("/dev/tty").chardev?   #=> true
  #
  def chardev?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ctime  ->  aTime
  # -->
  # Returns the change time for *stat* (that is, the time directory information
  # about the file was changed, not the file itself).
  #
  # Note that on Windows (NTFS), returns creation time (birth time).
  #
  #     File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def ctime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev    -> integer
  # -->
  # Returns an integer representing the device on which *stat* resides.
  #
  #     File.stat("testfile").dev   #=> 774
  #
  def dev: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_major   #=> 2
  #     File.stat("/dev/tty").dev_major   #=> 5
  #
  def dev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.dev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#dev` or `nil`.
  #
  #     File.stat("/dev/fd1").dev_minor   #=> 1
  #     File.stat("/dev/tty").dev_minor   #=> 0
  #
  def dev_minor: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - File.directory?(file_name)   ->  true or false
  # -->
  # Returns `true` if the named file is a directory, or a symlink that points at a
  # directory, and `false` otherwise.
  #
  # *file_name* can be an IO object.
  #
  #     File.directory?(".")
  #
  def directory?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable?    -> true or false
  # -->
  # Returns `true` if *stat* is executable or if the operating system doesn't
  # distinguish executable files from nonexecutable files. The tests are made
  # using the effective owner of the process.
  #
  #     File.stat("testfile").executable?   #=> false
  #
  def executable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.executable_real?    -> true or false
  # -->
  # Same as `executable?`, but tests using the real owner of the process.
  #
  def executable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.file?    -> true or false
  # -->
  # Returns `true` if *stat* is a regular file (not a device file, pipe, socket,
  # etc.).
  #
  #     File.stat("testfile").file?   #=> true
  #
  def file?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ftype   -> string
  # -->
  # Identifies the type of *stat*. The return string is one of: ```file`'',
  # ```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
  # ```link`'', ```socket`'', or ```unknown`''.
  #
  #     File.stat("/dev/tty").ftype   #=> "characterSpecial"
  #
  def ftype: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.gid   -> integer
  # -->
  # Returns the numeric group id of the owner of *stat*.
  #
  #     File.stat("testfile").gid   #=> 500
  #
  def gid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.grpowned?   -> true or false
  # -->
  # Returns true if the effective group id of the process is the same as the group
  # id of *stat*. On Windows NT, returns `false`.
  #
  #     File.stat("testfile").grpowned?      #=> true
  #     File.stat("/etc/passwd").grpowned?   #=> false
  #
  def grpowned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.ino   -> integer
  # -->
  # Returns the inode number for *stat*.
  #
  #     File.stat("testfile").ino   #=> 1083669
  #
  def ino: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.inspect  ->  string
  # -->
  # Produce a nicely formatted description of *stat*.
  #
  #     File.stat("/etc/passwd").inspect
  #        #=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,
  #        #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,
  #        #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,
  #        #    mtime=Fri Sep 12 15:41:41 CDT 2003,
  #        #    ctime=Mon Oct 27 11:20:27 CST 2003,
  #        #    birthtime=Mon Aug 04 08:13:49 CDT 2003>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=file.c
  #   - stat.mode   -> integer
  # -->
  # Returns an integer representing the permission bits of *stat*. The meaning of
  # the bits is platform dependent; on Unix systems, see `stat(2)`.
  #
  #     File.chmod(0644, "testfile")   #=> 1
  #     s = File.stat("testfile")
  #     sprintf("%o", s.mode)          #=> "100644"
  #
  def mode: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.mtime  ->  aTime
  # -->
  # Returns the modification time of *stat*.
  #
  #     File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=file.c
  #   - stat.nlink   -> integer
  # -->
  # Returns the number of hard links to *stat*.
  #
  #     File.stat("testfile").nlink             #=> 1
  #     File.link("testfile", "testfile.bak")   #=> 0
  #     File.stat("testfile").nlink             #=> 2
  #
  def nlink: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.owned?    -> true or false
  # -->
  # Returns `true` if the effective user id of the process is the same as the
  # owner of *stat*.
  #
  #     File.stat("testfile").owned?      #=> true
  #     File.stat("/etc/passwd").owned?   #=> false
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.pipe?    -> true or false
  # -->
  # Returns `true` if the operating system supports pipes and *stat* is a pipe;
  # `false` otherwise.
  #
  def pipe?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev   ->  integer or nil
  # -->
  # Returns an integer representing the device type on which *stat* resides.
  # Returns `nil` if the operating system doesn't support this feature.
  #
  #     File.stat("/dev/fd1").rdev   #=> 513
  #     File.stat("/dev/tty").rdev   #=> 1280
  #
  def rdev: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_major   -> integer
  # -->
  # Returns the major part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_major   #=> 2
  #     File.stat("/dev/tty").rdev_major   #=> 5
  #
  def rdev_major: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.rdev_minor   -> integer
  # -->
  # Returns the minor part of `File_Stat#rdev` or `nil`.
  #
  #     File.stat("/dev/fd1").rdev_minor   #=> 1
  #     File.stat("/dev/tty").rdev_minor   #=> 0
  #
  def rdev_minor: () -> Integer

  def read: (?int? length, ?string outbuf) -> String?

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable?    -> true or false
  # -->
  # Returns `true` if *stat* is readable by the effective user id of this process.
  #
  #     File.stat("testfile").readable?   #=> true
  #
  def readable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.readable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is readable by the real user id of this process.
  #
  #     File.stat("testfile").readable_real?   #=> true
  #
  def readable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setgid?   -> true or false
  # -->
  # Returns `true` if *stat* has the set-group-id permission bit set, `false` if
  # it doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/usr/sbin/lpc").setgid?   #=> true
  #
  def setgid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.setuid?    -> true or false
  # -->
  # Returns `true` if *stat* has the set-user-id permission bit set, `false` if it
  # doesn't or if the operating system doesn't support this feature.
  #
  #     File.stat("/bin/su").setuid?   #=> true
  #
  def setuid?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.size    -> integer
  # -->
  # Returns the size of *stat* in bytes.
  #
  #     File.stat("testfile").size   #=> 66
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.size?    -> Integer or nil
  # -->
  # Returns `nil` if *stat* is a zero-length file, the size of the file otherwise.
  #
  #     File.stat("testfile").size?   #=> 66
  #     File.stat("/dev/null").size?  #=> nil
  #
  def size?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.socket?    -> true or false
  # -->
  # Returns `true` if *stat* is a socket, `false` if it isn't or if the operating
  # system doesn't support this feature.
  #
  #     File.stat("testfile").socket?   #=> false
  #
  def socket?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.sticky?    -> true or false
  # -->
  # Returns `true` if *stat* has its sticky bit set, `false` if it doesn't or if
  # the operating system doesn't support this feature.
  #
  #     File.stat("testfile").sticky?   #=> false
  #
  def sticky?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.symlink?    -> true or false
  # -->
  # Returns `true` if *stat* is a symbolic link, `false` if it isn't or if the
  # operating system doesn't support this feature. As File::stat automatically
  # follows symbolic links, #symlink? will always be `false` for an object
  # returned by File::stat.
  #
  #     File.symlink("testfile", "alink")   #=> 0
  #     File.stat("alink").symlink?         #=> false
  #     File.lstat("alink").symlink?        #=> true
  #
  def symlink?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.uid    -> integer
  # -->
  # Returns the numeric user id of the owner of *stat*.
  #
  #     File.stat("testfile").uid   #=> 501
  #
  def uid: () -> Integer

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_readable? -> integer or nil
  # -->
  # If *stat* is readable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/etc/passwd").world_readable?  #=> 420
  #     sprintf("%o", m)                              #=> "644"
  #
  def world_readable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.world_writable?  ->  integer or nil
  # -->
  # If *stat* is writable by others, returns an integer representing the file
  # permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
  # platform dependent; on Unix systems, see `stat(2)`.
  #
  #     m = File.stat("/tmp").world_writable?         #=> 511
  #     sprintf("%o", m)                              #=> "777"
  #
  def world_writable?: () -> Integer?

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the effective user id of this process.
  #
  #     File.stat("testfile").writable?   #=> true
  #
  def writable?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.writable_real?  ->  true or false
  # -->
  # Returns `true` if *stat* is writable by the real user id of this process.
  #
  #     File.stat("testfile").writable_real?   #=> true
  #
  def writable_real?: () -> bool

  # <!--
  #   rdoc-file=file.c
  #   - stat.zero?    -> true or false
  # -->
  # Returns `true` if *stat* is a zero-length file; `false` otherwise.
  #
  #     File.stat("testfile").zero?   #=> false
  #
  def zero?: () -> bool
end

# <!-- rdoc-file=error.c -->
# Class Exception and its subclasses are used to communicate between
# Kernel#raise and `rescue` statements in `begin ... end` blocks.
#
# An Exception object carries information about an exception:
# *   Its type (the exception's class).
# *   An optional descriptive message.
# *   Optional backtrace information.
#
#
# Some built-in subclasses of Exception have additional methods: e.g.,
# NameError#name.
#
# ## Defaults
#
# Two Ruby statements have default exception classes:
# *   `raise`: defaults to RuntimeError.
# *   `rescue`: defaults to StandardError.
#
#
# ## Global Variables
#
# When an exception has been raised but not yet handled (in `rescue`, `ensure`,
# `at_exit` and `END` blocks), two global variables are set:
# *   `$!` contains the current exception.
# *   `$@` contains its backtrace.
#
#
# ## Custom Exceptions
#
# To provide additional or alternate information, a program may create custom
# exception classes that derive from the built-in exception classes.
#
# A good practice is for a library to create a single "generic" exception class
# (typically a subclass of StandardError or RuntimeError) and have its other
# exception classes derive from that class. This allows the user to rescue the
# generic exception, thus catching all exceptions the library may raise even if
# future versions of the library add new exception subclasses.
#
# For example:
#
#     class MyLibrary
#       class Error < ::StandardError
#       end
#
#       class WidgetError < Error
#       end
#
#       class FrobError < Error
#       end
#
#     end
#
# To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library
# user can rescue MyLibrary::Error.
#
# ## Built-In Exception Classes
#
# The built-in subclasses of Exception are:
#
# *   NoMemoryError
# *   ScriptError
#     *   LoadError
#     *   NotImplementedError
#     *   SyntaxError
#
# *   SecurityError
# *   SignalException
#     *   Interrupt
#
# *   StandardError
#     *   ArgumentError
#         *   UncaughtThrowError
#
#     *   EncodingError
#     *   FiberError
#     *   IOError
#         *   EOFError
#
#     *   IndexError
#         *   KeyError
#         *   StopIteration
#             *   ClosedQueueError
#
#
#     *   LocalJumpError
#     *   NameError
#         *   NoMethodError
#
#     *   RangeError
#         *   FloatDomainError
#
#     *   RegexpError
#     *   RuntimeError
#         *   FrozenError
#
#     *   SystemCallError
#         *   Errno::*
#
#     *   ThreadError
#     *   TypeError
#     *   ZeroDivisionError
#
# *   SystemExit
# *   SystemStackError
# *   fatal
#
class Exception < Object
  # <!--
  #   rdoc-file=error.c
  #   - Exception.to_tty?   ->  true or false
  # -->
  # Returns `true` if exception messages will be sent to a tty.
  #
  def self.to_tty?: () -> bool

  # <!--
  #   rdoc-file=error.c
  #   - exc.exception([string])  ->  an_exception or exc
  # -->
  # With no argument, or if the argument is the same as the receiver, return the
  # receiver. Otherwise, create a new exception object of the same class as the
  # receiver, but with a message equal to `string.to_str`.
  #
  def self.exception: (?String msg) -> Exception

  # <!--
  #   rdoc-file=error.c
  #   - exc == obj   -> true or false
  # -->
  # Equality---If *obj* is not an Exception, returns `false`. Otherwise, returns
  # `true` if *exc* and *obj* share same class, messages, and backtrace.
  #
  def ==: (untyped arg0) -> bool

  # <!--
  #   rdoc-file=error.c
  #   - exception.backtrace    -> array or nil
  # -->
  # Returns any backtrace associated with the exception. The backtrace is an array
  # of strings, each containing either ``filename:lineNo: in `method''' or
  # ``filename:lineNo.''
  #
  #     def a
  #       raise "boom"
  #     end
  #
  #     def b
  #       a()
  #     end
  #
  #     begin
  #       b()
  #     rescue => detail
  #       print detail.backtrace.join("\n")
  #     end
  #
  # *produces:*
  #
  #     prog.rb:2:in `a'
  #     prog.rb:6:in `b'
  #     prog.rb:10
  #
  # In the case no backtrace has been set, `nil` is returned
  #
  #     ex = StandardError.new
  #     ex.backtrace
  #     #=> nil
  #
  def backtrace: () -> ::Array[String]?

  # <!--
  #   rdoc-file=error.c
  #   - exception.backtrace_locations    -> array or nil
  # -->
  # Returns any backtrace associated with the exception. This method is similar to
  # Exception#backtrace, but the backtrace is an array of
  # Thread::Backtrace::Location.
  #
  # This method is not affected by Exception#set_backtrace().
  #
  def backtrace_locations: () -> ::Array[Thread::Backtrace::Location]?

  # <!--
  #   rdoc-file=error.c
  #   - exception.cause   -> an_exception or nil
  # -->
  # Returns the previous exception ($!) at the time this exception was raised.
  # This is useful for wrapping exceptions and retaining the original exception
  # information.
  #
  def cause: () -> Exception?

  # <!--
  #   rdoc-file=error.c
  #   - exc.exception([string])  ->  an_exception or exc
  # -->
  # With no argument, or if the argument is the same as the receiver, return the
  # receiver. Otherwise, create a new exception object of the same class as the
  # receiver, but with a message equal to `string.to_str`.
  #
  def exception: () -> self
               | (String arg0) -> Exception

  # <!--
  #   rdoc-file=error.c
  #   - Exception.new(msg = nil)        ->  exception
  #   - Exception.exception(msg = nil)  ->  exception
  # -->
  # Construct a new Exception object, optionally passing in a message.
  #
  def initialize: (?String arg0) -> void

  # <!--
  #   rdoc-file=error.c
  #   - exception.inspect   -> string
  # -->
  # Return this exception's class name and message.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exception.message   ->  string
  # -->
  # Returns the result of invoking `exception.to_s`. Normally this returns the
  # exception's message or name.
  #
  def message: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exc.set_backtrace(backtrace)   ->  array
  # -->
  # Sets the backtrace information associated with `exc`. The `backtrace` must be
  # an array of String objects or a single String in the format described in
  # Exception#backtrace.
  #
  def set_backtrace: (String | ::Array[String] arg0) -> ::Array[String]
                   | (nil) -> nil

  # <!--
  #   rdoc-file=error.c
  #   - exception.to_s   ->  string
  # -->
  # Returns exception's message (or the name of the exception if no message is
  # set).
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=error.c
  #   - exception.full_message(highlight: bool, order: [:top or :bottom]) ->  string
  # -->
  # Returns formatted string of *exception*. The returned string is formatted
  # using the same format that Ruby uses when printing an uncaught exceptions to
  # stderr.
  #
  # If *highlight* is `true` the default error handler will send the messages to a
  # tty.
  #
  # *order* must be either of `:top` or `:bottom`, and places the error message
  # and the innermost backtrace come at the top or the bottom.
  #
  # The default values of these options depend on `$stderr` and its `tty?` at the
  # timing of a call.
  #
  def full_message: (?highlight: bool, ?order: :top | :bottom) -> String
end

# <!-- rdoc-file=complex.c -->
# A complex number can be represented as a paired real number with imaginary
# unit; a+bi.  Where a is real part, b is imaginary part and i is imaginary
# unit.  Real a equals complex a+0i mathematically.
#
# You can create a Complex object explicitly with:
#
# *   A [complex literal](doc/syntax/literals_rdoc.html#label-Complex+Literals).
#
#
# You can convert certain objects to Complex objects with:
#
# *   Method [Complex](Kernel.html#method-i-Complex).
#
#
# Complex object can be created as literal, and also by using Kernel#Complex,
# Complex::rect, Complex::polar or to_c method.
#
#     2+1i                 #=> (2+1i)
#     Complex(1)           #=> (1+0i)
#     Complex(2, 3)        #=> (2+3i)
#     Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
#     3.to_c               #=> (3+0i)
#
# You can also create complex object from floating-point numbers or strings.
#
#     Complex(0.3)         #=> (0.3+0i)
#     Complex('0.3-0.5i')  #=> (0.3-0.5i)
#     Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
#     Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)
#
#     0.3.to_c             #=> (0.3+0i)
#     '0.3-0.5i'.to_c      #=> (0.3-0.5i)
#     '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
#     '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)
#
# A complex object is either an exact or an inexact number.
#
#     Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
#     Complex(1, 1) / 2.0  #=> (0.5+0.5i)
#
class Complex < Numeric
  # <!--
  #   rdoc-file=complex.c
  #   - Complex.polar(abs[, arg])  ->  complex
  # -->
  # Returns a complex object which denotes the given polar form.
  #
  #     Complex.polar(3, 0)            #=> (3.0+0.0i)
  #     Complex.polar(3, Math::PI/2)   #=> (1.836909530733566e-16+3.0i)
  #     Complex.polar(3, Math::PI)     #=> (-3.0+3.673819061467132e-16i)
  #     Complex.polar(3, -Math::PI/2)  #=> (1.836909530733566e-16-3.0i)
  #
  def self.polar: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real[, imag])         ->  complex
  #   - Complex.rectangular(real[, imag])  ->  complex
  # -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  def self.rect: (Numeric, ?Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - Complex.rect(real[, imag])         ->  complex
  #   - Complex.rectangular(real[, imag])  ->  complex
  # -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  alias self.rectangular self.rect

  public

  # <!--
  #   rdoc-file=complex.c
  #   - cmp * numeric  ->  complex
  # -->
  # Performs multiplication.
  #
  #     Complex(2, 3)  * Complex(2, 3)   #=> (-5+12i)
  #     Complex(900)   * Complex(1)      #=> (900+0i)
  #     Complex(-2, 9) * Complex(-9, 2)  #=> (0-85i)
  #     Complex(9, 8)  * 4               #=> (36+32i)
  #     Complex(20, 9) * 9.8             #=> (196.0+88.2i)
  #
  def *: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp ** numeric  ->  complex
  # -->
  # Performs exponentiation.
  #
  #     Complex('i') ** 2              #=> (-1+0i)
  #     Complex(-8) ** Rational(1, 3)  #=> (1.0000000000000002+1.7320508075688772i)
  #
  def **: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp + numeric  ->  complex
  # -->
  # Performs addition.
  #
  #     Complex(2, 3)  + Complex(2, 3)   #=> (4+6i)
  #     Complex(900)   + Complex(1)      #=> (901+0i)
  #     Complex(-2, 9) + Complex(-9, 2)  #=> (-11+11i)
  #     Complex(9, 8)  + 4               #=> (13+8i)
  #     Complex(20, 9) + 9.8             #=> (29.8+9i)
  #
  def +: (Numeric) -> Complex

  def +@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp - numeric  ->  complex
  # -->
  # Performs subtraction.
  #
  #     Complex(2, 3)  - Complex(2, 3)   #=> (0+0i)
  #     Complex(900)   - Complex(1)      #=> (899+0i)
  #     Complex(-2, 9) - Complex(-9, 2)  #=> (7+7i)
  #     Complex(9, 8)  - 4               #=> (5+8i)
  #     Complex(20, 9) - 9.8             #=> (10.2+9i)
  #
  def -: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - -cmp  ->  complex
  # -->
  # Returns negation of the value.
  #
  #     -Complex(1, 2)  #=> (-1-2i)
  #
  def -@: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp / numeric     ->  complex
  #   - cmp.quo(numeric)  ->  complex
  # -->
  # Performs division.
  #
  #     Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
  #     Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
  #     Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
  #     Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
  #     Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)
  #
  def /: (Numeric) -> Complex

  def <: (Numeric) -> bot

  def <=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp <=> object  ->  0, 1, -1, or nil
  # -->
  # If `cmp`'s imaginary part is zero, and `object` is also a real number (or a
  # Complex number where the imaginary part is zero), compare the real part of
  # `cmp` to object.  Otherwise, return nil.
  #
  #     Complex(2, 3)  <=> Complex(2, 3)   #=> nil
  #     Complex(2, 3)  <=> 1               #=> nil
  #     Complex(2)     <=> 1               #=> 1
  #     Complex(2)     <=> 2               #=> 0
  #     Complex(2)     <=> 3               #=> -1
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp == object  ->  true or false
  # -->
  # Returns true if cmp equals object numerically.
  #
  #     Complex(2, 3)  == Complex(2, 3)   #=> true
  #     Complex(5)     == 5               #=> true
  #     Complex(0)     == 0.0             #=> true
  #     Complex('1/3') == 0.33            #=> false
  #     Complex('1/2') == '1/2'           #=> false
  #
  def ==: (untyped) -> bool

  def >: (Numeric) -> bot

  def >=: (Numeric) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.abs        ->  real
  #   - cmp.magnitude  ->  real
  # -->
  # Returns the absolute part of its polar form.
  #
  #     Complex(-1).abs         #=> 1
  #     Complex(3.0, -4.0).abs  #=> 5.0
  #
  def abs: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.abs2  ->  real
  # -->
  # Returns square of the absolute value.
  #
  #     Complex(-1).abs2         #=> 1
  #     Complex(3.0, -4.0).abs2  #=> 25.0
  #
  def abs2: () -> Numeric

  # <!-- rdoc-file=complex.c -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  def angle: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.arg    ->  float
  #   - cmp.angle  ->  float
  #   - cmp.phase  ->  float
  # -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  alias arg angle

  def ceil: (*untyped) -> bot

  def coerce: (Numeric) -> [ Complex, Complex ]

  # <!-- rdoc-file=complex.c -->
  # Returns the complex conjugate.
  #
  #     Complex(1, 2).conjugate  #=> (1-2i)
  #
  def conj: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.conj       ->  complex
  #   - cmp.conjugate  ->  complex
  # -->
  # Returns the complex conjugate.
  #
  #     Complex(1, 2).conjugate  #=> (1-2i)
  #
  def conjugate: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.denominator  ->  integer
  # -->
  # Returns the denominator (lcm of both denominator - real and imag).
  #
  # See numerator.
  #
  def denominator: () -> Integer

  def div: (Numeric) -> bot

  def divmod: (Numeric) -> bot

  def dup: () -> self

  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.fdiv(numeric)  ->  complex
  # -->
  # Performs division as each part is a float, never returns a float.
  #
  #     Complex(11, 22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)
  #
  def fdiv: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.finite?  ->  true or false
  # -->
  # Returns `true` if `cmp`'s real and imaginary parts are both finite numbers,
  # otherwise returns `false`.
  #
  def finite?: () -> bool

  def floor: (?Integer) -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - hash()
  # -->
  #
  def hash: () -> Integer

  def i: () -> bot

  # <!-- rdoc-file=complex.c -->
  # Returns the imaginary part.
  #
  #     Complex(7).imaginary      #=> 0
  #     Complex(9, -4).imaginary  #=> -4
  #
  def imag: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.imag       ->  real
  #   - cmp.imaginary  ->  real
  # -->
  # Returns the imaginary part.
  #
  #     Complex(7).imaginary      #=> 0
  #     Complex(9, -4).imaginary  #=> -4
  #
  def imaginary: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.infinite?  ->  nil or 1
  # -->
  # Returns `1` if `cmp`'s real or imaginary part is an infinite number, otherwise
  # returns `nil`.
  #
  #     For example:
  #
  #        (1+1i).infinite?                   #=> nil
  #        (Float::INFINITY + 1i).infinite?   #=> 1
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Complex(2).inspect                       #=> "(2+0i)"
  #     Complex('-8/6').inspect                  #=> "((-4/3)+0i)"
  #     Complex('1/2i').inspect                  #=> "(0+(1/2)*i)"
  #     Complex(0, Float::INFINITY).inspect      #=> "(0+Infinity*i)"
  #     Complex(Float::NAN, Float::NAN).inspect  #=> "(NaN+NaN*i)"
  #
  def inspect: () -> String

  def integer?: () -> bool

  # <!-- rdoc-file=complex.c -->
  # Returns the absolute part of its polar form.
  #
  #     Complex(-1).abs         #=> 1
  #     Complex(3.0, -4.0).abs  #=> 5.0
  #
  alias magnitude abs

  def modulo: (Numeric) -> bot

  def negative?: () -> bot

  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.numerator  ->  numeric
  # -->
  # Returns the numerator.
  #
  #         1   2       3+4i  <-  numerator
  #         - + -i  ->  ----
  #         2   3        6    <-  denominator
  #
  #     c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)
  #     n = c.numerator          #=> (3+4i)
  #     d = c.denominator        #=> 6
  #     n / d                    #=> ((1/2)+(2/3)*i)
  #     Complex(Rational(n.real, d), Rational(n.imag, d))
  #                              #=> ((1/2)+(2/3)*i)
  #
  # See denominator.
  #
  def numerator: () -> Complex

  # <!-- rdoc-file=complex.c -->
  # Returns the angle part of its polar form.
  #
  #     Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  #
  alias phase angle

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.polar  ->  array
  # -->
  # Returns an array; [cmp.abs, cmp.arg].
  #
  #     Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]
  #
  def polar: () -> [ Numeric, Float ]

  def positive?: () -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - cmp / numeric     ->  complex
  #   - cmp.quo(numeric)  ->  complex
  # -->
  # Performs division.
  #
  #     Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
  #     Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
  #     Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
  #     Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
  #     Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)
  #
  def quo: (Numeric) -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.rationalize([eps])  ->  rational
  # -->
  # Returns the value as a rational if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1.0/3, 0).rationalize  #=> (1/3)
  #     Complex(1, 0.0).rationalize    # RangeError
  #     Complex(1, 2).rationalize      # RangeError
  #
  # See to_r.
  #
  def rationalize: (?Numeric eps) -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.real  ->  real
  # -->
  # Returns the real part.
  #
  #     Complex(7).real      #=> 7
  #     Complex(9, -4).real  #=> 9
  #
  def real: () -> Numeric

  # <!--
  #   rdoc-file=complex.c
  #   - Complex(1).real?     ->  false
  #   - Complex(1, 2).real?  ->  false
  # -->
  # Returns false, even if the complex number has no imaginary part.
  #
  def real?: () -> false

  # <!-- rdoc-file=complex.c -->
  # Returns a complex object which denotes the given rectangular form.
  #
  #     Complex.rectangular(1, 2)  #=> (1+2i)
  #
  def rect: () -> [ Numeric, Numeric ]

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.rect         ->  array
  #   - cmp.rectangular  ->  array
  # -->
  # Returns an array; [cmp.real, cmp.imag].
  #
  #     Complex(1, 2).rectangular  #=> [1, 2]
  #
  alias rectangular rect

  def reminder: (Numeric) -> bot

  def round: (*untyped) -> bot

  def step: (*untyped) ?{ (*untyped) -> untyped } -> bot

  # <!--
  #   rdoc-file=complex.c
  #   - complex.to_c  ->  self
  # -->
  # Returns self.
  #
  #     Complex(2).to_c      #=> (2+0i)
  #     Complex(-8, 6).to_c  #=> (-8+6i)
  #
  def to_c: () -> Complex

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_f  ->  float
  # -->
  # Returns the value as a float if possible (the imaginary part should be exactly
  # zero).
  #
  #     Complex(1, 0).to_f    #=> 1.0
  #     Complex(1, 0.0).to_f  # RangeError
  #     Complex(1, 2).to_f    # RangeError
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_i  ->  integer
  # -->
  # Returns the value as an integer if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1, 0).to_i    #=> 1
  #     Complex(1, 0.0).to_i  # RangeError
  #     Complex(1, 2).to_i    # RangeError
  #
  def to_i: () -> Integer

  alias to_int to_i

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_r  ->  rational
  # -->
  # Returns the value as a rational if possible (the imaginary part should be
  # exactly zero).
  #
  #     Complex(1, 0).to_r    #=> (1/1)
  #     Complex(1, 0.0).to_r  # RangeError
  #     Complex(1, 2).to_r    # RangeError
  #
  # See rationalize.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=complex.c
  #   - cmp.to_s  ->  string
  # -->
  # Returns the value as a string.
  #
  #     Complex(2).to_s                       #=> "2+0i"
  #     Complex('-8/6').to_s                  #=> "-4/3+0i"
  #     Complex('1/2i').to_s                  #=> "0+1/2i"
  #     Complex(0, Float::INFINITY).to_s      #=> "0+Infinity*i"
  #     Complex(Float::NAN, Float::NAN).to_s  #=> "NaN+NaN*i"
  #
  def to_s: () -> String

  def truncate: (?Integer) -> bot

  def zero?: () -> bool
end

# <!-- rdoc-file=complex.c -->
# The imaginary unit.
#
Complex::I: Complex

%a{annotate:rdoc:skip}
class IO
  # <!-- rdoc-file=io_buffer.c -->
  # IO::Buffer is a low-level efficient buffer for input/output. There are three
  # ways of using buffer:
  #
  # *   Create an empty buffer with ::new, fill it with data using #copy or
  #     #set_value, #set_string, get data with #get_string;
  # *   Create a buffer mapped to some string with ::for, then it could be used
  #     both for reading with #get_string or #get_value, and writing (writing will
  #     change the source string, too);
  # *   Create a buffer mapped to some file with ::map, then it could be used for
  #     reading and writing the underlying file.
  #
  #
  # Interaction with string and file memory is performed by efficient low-level C
  # mechanisms like `memcpy`.
  #
  # The class is meant to be an utility for implementing more high-level
  # mechanisms like Fiber::SchedulerInterface#io_read and
  # Fiber::SchedulerInterface#io_write.
  #
  # **Examples of usage:**
  #
  # Empty buffer:
  #
  #     buffer = IO::Buffer.new(8)  # create empty 8-byte buffer
  #     #  =>
  #     # #<IO::Buffer 0x0000555f5d1a5c50+8 INTERNAL>
  #     # ...
  #     buffer
  #     #  =>
  #     # <IO::Buffer 0x0000555f5d156ab0+8 INTERNAL>
  #     # 0x00000000  00 00 00 00 00 00 00 00
  #     buffer.set_string('test', 2) # put there bytes of the "test" string, starting from offset 2
  #     # => 4
  #     buffer.get_string  # get the result
  #     # => "\x00\x00test\x00\x00"
  #
  # Buffer from string:
  #
  #     string = 'data'
  #     buffer = IO::Buffer.for(str)
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # ...
  #     buffer
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # 0x00000000  64 61 74 61                                     data
  #
  #     buffer.get_string(2)  # read content starting from offset 2
  #     # => "ta"
  #     buffer.set_string('---', 1) # write content, starting from offset 1
  #     # => 3
  #     buffer
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
  #     # 0x00000000  64 2d 2d 2d                                     d---
  #     string  # original string changed, too
  #     # => "d---"
  #
  # Buffer from file:
  #
  #     File.write('test.txt', 'test data')
  #     # => 9
  #     buffer = IO::Buffer.map(File.open('test.txt'))
  #     #  =>
  #     # #<IO::Buffer 0x00007f3f0768c000+9 MAPPED IMMUTABLE>
  #     # ...
  #     buffer.get_string(5, 2) # read 2 bytes, starting from offset 5
  #     # => "da"
  #     buffer.set_string('---', 1) # attempt to write
  #     # in `set_string': Buffer is not writable! (IO::Buffer::AccessError)
  #
  #     # To create writable file-mapped buffer
  #     # Open file for read-write, pass size, offset, and flags=0
  #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 9, 0, 0)
  #     buffer.set_string('---', 1)
  #     # => 3 -- bytes written
  #     File.read('test.txt')
  #     # => "t--- data"
  #
  # **The class is experimental and the interface is subject to change.**
  #
  class Buffer
    include Comparable

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.for(string) -> io_buffer
    # -->
    # Creates a IO::Buffer from the given string's memory. The buffer remains
    # associated with the string, and writing to a buffer will update the string's
    # contents.
    #
    # Until #free is invoked on the buffer, either explicitly or via the garbage
    # collector, the source string will be locked and cannot be modified.
    #
    # If the string is frozen, it will create a read-only buffer which cannot be
    # modified.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(str)
    #     buffer.external? #=> true
    #
    #     buffer.get_string(0, 1)
    #     # => "t"
    #     string
    #     # => "best"
    #
    #     buffer.resize(100)
    #     # in `resize': Cannot resize external buffer! (IO::Buffer::AccessError)
    #
    def self.for: (String) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.map(file, [size, [offset, [flags]]]) -> io_buffer
    # -->
    # Create an IO::Buffer for reading from `file` by memory-mapping the file.
    # `file_io` should be a `File` instance, opened for reading.
    #
    # Optional `size` and `offset` of mapping can be specified.
    #
    # By default, the buffer would be immutable (read only); to create a writable
    # mapping, you need to open a file in read-write mode, and explicitly pass
    # `flags` argument without IO::Buffer::IMMUTABLE.
    #
    #     File.write('test.txt', 'test')
    #
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     # => #<IO::Buffer 0x00000001014a0000+4 MAPPED READONLY>
    #
    #     buffer.readonly?   # => true
    #
    #     buffer.get_string
    #     # => "test"
    #
    #     buffer.set_string('b', 0)
    #     # `set_string': Buffer is not writable! (IO::Buffer::AccessError)
    #
    #     # create read/write mapping: length 4 bytes, offset 0, flags 0
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 4, 0)
    #     buffer.set_string('b', 0)
    #     # => 1
    #
    #     # Check it
    #     File.read('test.txt')
    #     # => "best"
    #
    # Note that some operating systems may not have cache coherency between mapped
    # buffers and file reads.
    #
    def self.map: (File file, ?Integer? size, ?Integer offset, ?Integer flags) -> Buffer

    public

    # <!--
    #   rdoc-file=io_buffer.c
    #   - <=>(other) -> true or false
    # -->
    # Buffers are compared by size and exact contents of the memory they are
    # referencing using `memcmp`.
    #
    def <=>: (Buffer) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - clear(value = 0, [offset, [length]]) -> self
    # -->
    # Fill buffer with `value`, starting with `offset` and going for `length` bytes.
    #
    #     buffer = IO::Buffer.for('test')
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  74 65 73 74         test
    #
    #     buffer.clear
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  00 00 00 00         ....
    #
    #     buf.clear(1) # fill with 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 01 01 01         ....
    #
    #     buffer.clear(2, 1, 2) # fill with 2, starting from offset 1, for 2 bytes
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 02 02 01         ....
    #
    #     buffer.clear(2, 1) # fill with 2, starting from offset 1
    #     # =>
    #     #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #     #   0x00000000  01 02 02 02         ....
    #
    def clear: (?Integer value, ?Integer offset, ?Integer length) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - copy(source, [offset, [length, [source_offset]]]) -> size
    # -->
    # Efficiently copy data from a source IO::Buffer into the buffer, at `offset`
    # using `memcpy`. For copying String instances, see #set_string.
    #
    #     buffer = IO::Buffer.new(32)
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5ca22520+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................  *
    #
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # => 4 -- size of data copied
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5cf8fe40+32 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00 74 65 73 74 00 00 00 00 ........test....
    #     # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ *
    #
    # #copy can be used to put data into strings associated with buffer:
    #
    #     string= "data:    "
    #     # => "data:    "
    #     buffer = IO::Buffer.for(str)
    #     buffer.copy(IO::Buffer.for("test"), 5)
    #     # => 4
    #     string
    #     # => "data:test"
    #
    # Attempt to copy into a read-only buffer will fail:
    #
    #     File.write('test.txt', 'test')
    #     buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    #     buffer.copy(IO::Buffer.for("test"), 8)
    #     # in `copy': Buffer is not writable! (IO::Buffer::AccessError)
    #
    # See ::map for details of creation of mutable file mappings, this will work:
    #
    #     buffer = IO::Buffer.map(File.open('test.txt', 'r+'))
    #     buffer.copy("boom", 0)
    #     # => 4
    #     File.read('test.txt')
    #     # => "boom"
    #
    # Attempt to copy the data which will need place outside of buffer's bounds will
    # fail:
    #
    #     buffer = IO::Buffer.new(2)
    #     buffer.copy('test', 0)
    #     # in `copy': Specified offset+length exceeds source size! (ArgumentError)
    #
    def copy: (Buffer source, ?Integer offset, ?Integer length, ?Integer source_offset) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - external? -> true or false
    # -->
    # If the buffer is _external_, meaning it references from memory which is not
    #     allocated or mapped by the buffer itself.
    #
    #     A buffer created using ::for has an external reference to the string's
    #     memory.
    #
    # External buffer can't be resized.
    #
    def empty?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - external?()
    # -->
    #
    def external?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - free -> self
    # -->
    # If the buffer references memory, release it back to the operating system.
    # *   for a *mapped* buffer (e.g. from file): unmap.
    # *   for a buffer created from scratch: free memory.
    # *   for a buffer created from string: undo the association.
    #
    #
    # After the buffer is freed, no further operations can't be performed on it.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.free
    #     # => #<IO::Buffer 0x0000000000000000+0 NULL>
    #
    #     buffer.get_value(:U8, 0)
    #     # in `get_value': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.get_string
    #     # in `get_string': The buffer is not allocated! (IO::Buffer::AllocationError)
    #
    #     buffer.null?
    #     # => true
    #
    # You can resize a freed buffer to re-allocate it.
    #
    def free: () -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_string([offset, [length, [encoding]]]) -> string
    # -->
    # Read a chunk or all of the buffer into a string, in the specified `encoding`.
    # If no encoding is provided `Encoding::BINARY` is used.
    #
    #     buffer = IO::Buffer.for('test')
    #     buffer.get_string
    #     # => "test"
    #     buffer.get_string(2)
    #     # => "st"
    #     buffer.get_string(2, 1)
    #     # => "s"
    #
    def get_string: (?Integer offset, ?Integer length, ?Encoding encoding) -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - get_value(type, offset) -> numeric
    # -->
    # Read from buffer a value of `type` at `offset`. `type` should be one of
    # symbols:
    #
    # *   `:U8`: unsigned integer, 1 byte
    # *   `:S8`: signed integer, 1 byte
    # *   `:u16`: unsigned integer, 2 bytes, little-endian
    # *   `:U16`: unsigned integer, 2 bytes, big-endian
    # *   `:s16`: signed integer, 2 bytes, little-endian
    # *   `:S16`: signed integer, 2 bytes, big-endian
    # *   `:u32`: unsigned integer, 4 bytes, little-endian
    # *   `:U32`: unsigned integer, 4 bytes, big-endian
    # *   `:s32`: signed integer, 4 bytes, little-endian
    # *   `:S32`: signed integer, 4 bytes, big-endian
    # *   `:u64`: unsigned integer, 8 bytes, little-endian
    # *   `:U64`: unsigned integer, 8 bytes, big-endian
    # *   `:s64`: signed integer, 8 bytes, little-endian
    # *   `:S64`: signed integer, 8 bytes, big-endian
    # *   `:f32`: float, 4 bytes, little-endian
    # *   `:F32`: float, 4 bytes, big-endian
    # *   `:f64`: double, 8 bytes, little-endian
    # *   `:F64`: double, 8 bytes, big-endian
    #
    #
    # Example:
    #
    #     string = [1.5].pack('f')
    #     # => "\x00\x00\xC0?"
    #     IO::Buffer.for(string).get_value(:f32, 0)
    #     # => 1.5
    #
    def get_value: (int_get_type, Integer offset) -> Integer
                 | (float_get_type, Integer offset) -> Float

    type int_get_type = :U8 | :S8
                      | :u16 | :U16 | :s16 | :S16
                      | :u32 | :U32 | :s32 | :S32
                      | :u64 | :U64 | :s64 | :S64

    type float_get_type = :f32 | :F32 | :f64 | :F64

    # <!--
    #   rdoc-file=io_buffer.c
    #   - hexdump()
    # -->
    #
    def hexdump: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - internal? -> true or false
    # -->
    # If the buffer is *internal*, meaning it references memory allocated by the
    # buffer itself.
    #
    # An internal buffer is not associated with any external memory (e.g. string) or
    # file mapping.
    #
    # Internal buffers are created using ::new and is the default when the requested
    # size is less than the IO::Buffer::PAGE_SIZE and it was not requested to be
    # mapped on creation.
    #
    # Internal buffers can be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def internal?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked { ... }
    # -->
    # Allows to process a buffer in exclusive way, for concurrency-safety. While the
    # block is performed, the buffer is considered locked, and no other code can
    # enter the lock. Also, locked buffer can't be changed with #resize or #free.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.locked? #=> false
    #
    #     Fiber.schedule do
    #       buffer.locked do
    #         buffer.write(io) # theoretical system call interface
    #       end
    #     end
    #
    #     Fiber.schedule do
    #       # in `locked': Buffer already locked! (IO::Buffer::LockedError)
    #       buffer.locked do
    #         buffer.set_string(...)
    #       end
    #     end
    #
    # The following operations acquire a lock: #resize, #free.
    #
    # Locking is not thread safe. It is designed as a safety net around non-blocking
    # system calls. You can only share a buffer between threads with appropriate
    # synchronisation techniques.
    #
    def locked: [A] () { (IO::Buffer) -> A } -> A

    # <!--
    #   rdoc-file=io_buffer.c
    #   - locked? -> true or false
    # -->
    # If the buffer is *locked*, meaning it is inside #locked block execution.
    # Locked buffer can't be resized or freed, and another lock can't be acquired on
    # it.
    #
    # Locking is not thread safe, but is a semantic used to ensure buffers don't
    # move while being used by a system call.
    #
    #     buffer.locked do
    #       buffer.write(io) # theoretical system call interface
    #     end
    #
    def locked?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - mapped? -> true or false
    # -->
    # If the buffer is *mapped*, meaning it references memory mapped by the buffer.
    #
    # Mapped buffers are either anonymous, if created by ::new with the
    # IO::Buffer::MAPPED flag or if the size was at least IO::Buffer::PAGE_SIZE, or
    # backed by a file if created with ::map.
    #
    # Mapped buffers can usually be resized, and such an operation will typically
    # invalidate all slices, but not always.
    #
    def mapped?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - null? -> true or false
    # -->
    # If the buffer was freed with #free or was never allocated in the first place.
    #
    def null?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pread(p1, p2, p3)
    # -->
    #
    def pread: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - pwrite(p1, p2, p3)
    # -->
    #
    def pwrite: (untyped, untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - read(p1, p2)
    # -->
    #
    def read: (untyped, untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - readonly?()
    # -->
    #
    def readonly?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - resize(new_size) -> self
    # -->
    # Resizes a buffer to a `new_size` bytes, preserving its content. Depending on
    # the old and new size, the memory area associated with the buffer might be
    # either extended, or rellocated at different address with content being copied.
    #
    #     buffer = IO::Buffer.new(4)
    #     buffer.set_string("test", 0)
    #     buffer.resize(8) # resize to 8 bytes
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5d1a1630+8 INTERNAL>
    #     # 0x00000000  74 65 73 74 00 00 00 00                         test....
    #
    # External buffer (created with ::for), and locked buffer can not be resized.
    #
    def resize: (Integer) -> self

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_string(*args)
    # -->
    #
    def set_string: (*untyped) -> untyped

    # <!--
    #   rdoc-file=io_buffer.c
    #   - set_value(type, offset, value) -> offset
    # -->
    # Write to a buffer a `value` of `type` at `offset`. `type` should be one of
    # symbols described in #get_value.
    #
    #     buffer = IO::Buffer.new(8)
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 00 00 00 00 00 00 00
    #     buffer.set_value(:U8, 1, 111)
    #     # => 1
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     # 0x00000000  00 6f 00 00 00 00 00 00                         .o......
    #
    # Note that if the `type` is integer and `value` is Float, the implicit
    # truncation is performed:
    #
    #     buffer = IO::Buffer.new(8)
    #     buffer.set_value(:U32, 0, 2.5)
    #     buffer
    #     #   =>
    #     #  #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #     #  0x00000000  00 00 00 02 00 00 00 00
    #     #                       ^^ the same as if we'd pass just integer 2
    #
    def set_value: (int_get_type | float_get_type, Integer offset, Float | Integer value) -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - size -> integer
    # -->
    # Returns the size of the buffer that was explicitly set (on creation with ::new
    # or on #resize), or deduced on buffer's creation from string or file.
    #
    def size: () -> Integer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - slice(offset, length) -> io_buffer
    # -->
    # Produce another IO::Buffer which is a slice (or view into) the current one
    # starting at `offset` bytes and going for `length` bytes.
    #
    # The slicing happens without copying of memory, and the slice keeps being
    # associated with the original buffer's source (string, or file), if any.
    #
    # Raises RuntimeError if the <tt>offset+length<tt> is out of the current
    # buffer's bounds.
    #
    #     string = 'test'
    #     buffer = IO::Buffer.for(string)
    #
    #     slice = buffer.slice(1, 2)
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     #  0x00000000  65 73                                           es
    #
    #     # Put "o" into 0s position of the slice
    #     slice.set_string('o', 0)
    #     slice
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #     #  0x00000000  6f 73                                           os
    #
    #     # it is also visible at position 1 of the original buffer
    #     buffer
    #     # =>
    #     #  #<IO::Buffer 0x00007fc3d31e2d80+4 SLICE>
    #     #  0x00000000  74 6f 73 74                                     tost
    #
    #     # ...and original string
    #     string
    #     # => tost
    #
    def slice: (Integer offset, Integer length) -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - to_s -> string
    # -->
    # Short representation of the buffer. It includes the address, size and symbolic
    # flags. This format is subject to change.
    #
    #     puts IO::Buffer.new(4) # uses to_s internally
    #     # #<IO::Buffer 0x000055769f41b1a0+4 INTERNAL>
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=io_buffer.c
    #   - transfer -> new_io_buffer
    # -->
    # Transfers ownership to a new buffer, deallocating the current one.
    #
    #     buffer = IO::Buffer.new('test')
    #     other = buffer.transfer
    #     other
    #     #  =>
    #     # #<IO::Buffer 0x00007f136a15f7b0+4 SLICE>
    #     # 0x00000000  74 65 73 74                                     test
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x0000000000000000+0 NULL>
    #     buffer.null?
    #     # => true
    #
    def transfer: () -> Buffer

    # <!--
    #   rdoc-file=io_buffer.c
    #   - valid? -> true or false
    # -->
    # Returns whether the buffer data is accessible.
    #
    # A buffer becomes invalid if it is a slice of another buffer which has been
    # freed.
    #
    def valid?: () -> bool

    # <!--
    #   rdoc-file=io_buffer.c
    #   - write(p1, p2)
    # -->
    #
    def write: (untyped, untyped) -> untyped

    private

    # <!--
    #   rdoc-file=io_buffer.c
    #   - IO::Buffer.new([size = DEFAULT_SIZE, [flags = 0]]) -> io_buffer
    # -->
    # Create a new zero-filled IO::Buffer of `size` bytes. By default, the buffer
    # will be *internal*: directly allocated chunk of the memory. But if the
    # requested `size` is more than OS-specific IO::Bufer::PAGE_SIZE, the buffer
    # would be allocated using the virtual memory mechanism (anonymous `mmap` on
    # Unix, `VirtualAlloc` on Windows). The behavior can be forced by passing
    # IO::Buffer::MAPPED as a second parameter.
    #
    # Examples
    #
    #     buffer = IO::Buffer.new(4)
    #     # =>
    #     #  #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     #  0x00000000  00 00 00 00                                     ....
    #
    #     buffer.get_string(0, 1) # => "\x00"
    #
    #     buffer.set_string("test")
    #     buffer
    #     #  =>
    #     # #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #     # 0x00000000  74 65 73 74                                     test
    #
    def initialize: (?Integer size, ?Integer flags) -> void

    BIG_ENDIAN: Integer

    DEFAULT_SIZE: Integer

    EXTERNAL: Integer

    HOST_ENDIAN: Integer

    INTERNAL: Integer

    LITTLE_ENDIAN: Integer

    LOCKED: Integer

    MAPPED: Integer

    NETWORK_ENDIAN: Integer

    PAGE_SIZE: Integer

    PRIVATE: Integer

    READONLY: Integer
  end
end

%a{annotate:rdoc:skip}
class IO
  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.nread -> int
  # -->
  # Returns number of bytes that can be read without blocking. Returns zero if no
  # information available.
  #
  def nread: () -> Integer

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.ready? -> true or false
  # -->
  # Returns `true` if input available without blocking, or `false`.
  #
  def ready?: () -> boolish

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait(events, timeout) -> event mask or false.
  #   - io.wait(timeout = nil, mode = :read) -> event mask or false.
  # -->
  # Waits until the IO becomes ready for the specified events and returns the
  # subset of events that become ready, or `false` when times out.
  #
  # The events can be a bit mask of `IO::READABLE`, `IO::WRITABLE` or
  # `IO::PRIORITY`.
  #
  # Returns `true` immediately when buffered data is available.
  #
  # Optional parameter `mode` is one of `:read`, `:write`, or `:read_write`.
  #
  def wait: (Integer events, ?Numeric timeout) -> (self | bool | nil)
          | (?Numeric? timeout, *wait_mode mode) -> (self | bool | nil)

  type wait_mode = :read | :r | :readable | :write | :w | :writable | :read_write | :rw | :readable_writable

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_readable          -> true or false
  #   - io.wait_readable(timeout) -> true or false
  # -->
  # Waits until IO is readable and returns `true`, or `false` when times out.
  # Returns `true` immediately when buffered data is available.
  #
  def wait_readable: (?Numeric? timeout) -> (self | bool | nil)?

  # <!--
  #   rdoc-file=ext/io/wait/wait.c
  #   - io.wait_writable          -> true or false
  #   - io.wait_writable(timeout) -> true or false
  # -->
  # Waits until IO is writable and returns `true` or `false` when times out.
  #
  def wait_writable: (?Numeric? timeout) -> (self | bool | nil)?
end

# <!-- rdoc-file=numeric.c -->
# An obsolete class, use Integer
#
Fixnum: singleton(Integer)

# <!-- rdoc-file=bignum.c -->
# An obsolete class, use Integer
#
Bignum: singleton(Integer)

# <!-- rdoc-file=enumerator.c -->
# A class which allows both internal and external iteration.
#
# An Enumerator can be created by the following methods.
# *   Object#to_enum
# *   Object#enum_for
# *   Enumerator.new
#
#
# Most methods have two forms: a block form where the contents are evaluated for
# each item in the enumeration, and a non-block form which returns a new
# Enumerator wrapping the iteration.
#
#     enumerator = %w(one two three).each
#     puts enumerator.class # => Enumerator
#
#     enumerator.each_with_object("foo") do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
#     enum_with_obj = enumerator.each_with_object("foo")
#     puts enum_with_obj.class # => Enumerator
#
#     enum_with_obj.each do |item, obj|
#       puts "#{obj}: #{item}"
#     end
#
#     # foo: one
#     # foo: two
#     # foo: three
#
# This allows you to chain Enumerators together.  For example, you can map a
# list's elements to strings containing the index and the element as a string
# via:
#
#     puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
#     # => ["0:foo", "1:bar", "2:baz"]
#
# An Enumerator can also be used as an external iterator. For example,
# Enumerator#next returns the next value of the iterator or raises StopIteration
# if the Enumerator is at the end.
#
#     e = [1,2,3].each   # returns an enumerator object.
#     puts e.next   # => 1
#     puts e.next   # => 2
#     puts e.next   # => 3
#     puts e.next   # raises StopIteration
#
# Note that enumeration sequence by `next`, `next_values`, `peek` and
# `peek_values` do not affect other non-external enumeration methods, unless the
# underlying iteration method itself has side-effect, e.g. IO#each_line.
#
# Moreover, implementation typically uses fibers so performance could be slower
# and exception stacktraces different than expected.
#
# You can use this to implement an internal iterator as follows:
#
#     def ext_each(e)
#       while true
#         begin
#           vs = e.next_values
#         rescue StopIteration
#           return $!.result
#         end
#         y = yield(*vs)
#         e.feed y
#       end
#     end
#
#     o = Object.new
#
#     def o.each
#       puts yield
#       puts yield(1)
#       puts yield(1, 2)
#       3
#     end
#
#     # use o.each as an internal iterator directly.
#     puts o.each {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
#     # convert o.each to an external iterator for
#     # implementing an internal iterator.
#     puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
#     # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
#
class Enumerator[unchecked out Elem, out Return] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - enum.each { |elm| block }                    -> obj
  #   - enum.each                                    -> enum
  #   - enum.each(*appending_args) { |elm| block }   -> obj
  #   - enum.each(*appending_args)                   -> an_enumerator
  # -->
  # Iterates over the block according to how this Enumerator was constructed. If
  # no block and no arguments are given, returns self.
  #
  # ### Examples
  #
  #     "Hello, world!".scan(/\w+/)                     #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan, /\w+/).to_a      #=> ["Hello", "world"]
  #     "Hello, world!".to_enum(:scan).each(/\w+/).to_a #=> ["Hello", "world"]
  #
  #     obj = Object.new
  #
  #     def obj.each_arg(a, b=:b, *rest)
  #       yield a
  #       yield b
  #       yield rest
  #       :method_returned
  #     end
  #
  #     enum = obj.to_enum :each_arg, :a, :x
  #
  #     enum.each.to_a                  #=> [:a, :x, []]
  #     enum.each.equal?(enum)          #=> true
  #     enum.each { |elm| elm }         #=> :method_returned
  #
  #     enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]
  #     enum.each(:y, :z).equal?(enum)  #=> false
  #     enum.each(:y, :z) { |elm| elm } #=> :method_returned
  #
  def each: () { (Elem arg0) -> untyped } -> Return
          | () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.feed obj   -> nil
  # -->
  # Sets the value to be returned by the next yield inside `e`.
  #
  # If the value is not set, the yield returns nil.
  #
  # This value is cleared after being yielded.
  #
  #     # Array#map passes the array's elements to "yield" and collects the
  #     # results of "yield" as an array.
  #     # Following example shows that "next" returns the passed elements and
  #     # values passed to "feed" are collected as an array which can be
  #     # obtained by StopIteration#result.
  #     e = [1,2,3].map
  #     p e.next           #=> 1
  #     e.feed "a"
  #     p e.next           #=> 2
  #     e.feed "b"
  #     p e.next           #=> 3
  #     e.feed "c"
  #     begin
  #       e.next
  #     rescue StopIteration
  #       p $!.result      #=> ["a", "b", "c"]
  #     end
  #
  #     o = Object.new
  #     def o.each
  #       x = yield         # (2) blocks
  #       p x               # (5) => "foo"
  #       x = yield         # (6) blocks
  #       p x               # (8) => nil
  #       x = yield         # (9) blocks
  #       p x               # not reached w/o another e.next
  #     end
  #
  #     e = o.to_enum
  #     e.next              # (1)
  #     e.feed "foo"        # (3)
  #     e.next              # (4)
  #     e.next              # (7)
  #                         # (10)
  #
  def feed: (Elem arg0) -> NilClass

  # <!--
  #   rdoc-file=enumerator.c
  #   - Enumerator.new(size = nil) { |yielder| ... }
  # -->
  # Creates a new Enumerator object, which can be used as an Enumerable.
  #
  # Iteration is defined by the given block, in which a "yielder" object, given as
  # block parameter, can be used to yield a value by calling the `yield` method
  # (aliased as `<<`):
  #
  #     fib = Enumerator.new do |y|
  #       a = b = 1
  #       loop do
  #         y << a
  #         a, b = b, a + b
  #       end
  #     end
  #
  #     fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
  #
  # The optional parameter can be used to specify how to calculate the size in a
  # lazy fashion (see Enumerator#size). It can either be a value or a callable
  # object.
  #
  def initialize: (?Integer arg0) { (Enumerator::Yielder arg0) -> void } -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.inspect  -> string
  # -->
  # Creates a printable version of *e*.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next   -> object
  # -->
  # Returns the next object in the enumerator, and move the internal position
  # forward.  When the position reached at the end, StopIteration is raised.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.next   #raises StopIteration
  #
  # See class-level notes about external iterators.
  #
  def next: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.next_values   -> array
  # -->
  # Returns the next object as an array in the enumerator, and move the internal
  # position forward.  When the position reached at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # This method can be used to distinguish `yield` and `yield nil`.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #       yield nil
  #       yield [1, 2]
  #     end
  #     e = o.to_enum
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     p e.next_values
  #     e = o.to_enum
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #     p e.next
  #
  #     ## yield args       next_values      next
  #     #  yield            []               nil
  #     #  yield 1          [1]              1
  #     #  yield 1, 2       [1, 2]           [1, 2]
  #     #  yield nil        [nil]            nil
  #     #  yield [1, 2]     [[1, 2]]         [1, 2]
  #
  def next_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek   -> object
  # -->
  # Returns the next object in the enumerator, but doesn't move the internal
  # position forward.  If the position is already at the end, StopIteration is
  # raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     a = [1,2,3]
  #     e = a.to_enum
  #     p e.next   #=> 1
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.peek   #=> 2
  #     p e.next   #=> 2
  #     p e.next   #=> 3
  #     p e.peek   #raises StopIteration
  #
  def peek: () -> Elem

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.peek_values   -> array
  # -->
  # Returns the next object as an array, similar to Enumerator#next_values, but
  # doesn't move the internal position forward.  If the position is already at the
  # end, StopIteration is raised.
  #
  # See class-level notes about external iterators.
  #
  # ### Example
  #
  #     o = Object.new
  #     def o.each
  #       yield
  #       yield 1
  #       yield 1, 2
  #     end
  #     e = o.to_enum
  #     p e.peek_values    #=> []
  #     e.next
  #     p e.peek_values    #=> [1]
  #     p e.peek_values    #=> [1]
  #     e.next
  #     p e.peek_values    #=> [1, 2]
  #     e.next
  #     p e.peek_values    # raises StopIteration
  #
  def peek_values: () -> ::Array[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.rewind   -> e
  # -->
  # Rewinds the enumeration sequence to the beginning.
  #
  # If the enclosed object responds to a "rewind" method, it is called.
  #
  def rewind: () -> self

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.size          -> int, Float::INFINITY or nil
  # -->
  # Returns the size of the enumerator, or `nil` if it can't be calculated lazily.
  #
  #     (1..100).to_a.permutation(4).size # => 94109400
  #     loop.size # => Float::INFINITY
  #     (1..100).drop_while.size # => nil
  #
  def size: () -> (Integer | Float)?

  # <!--
  #   rdoc-file=enumerator.c
  #   - e.with_index(offset = 0) {|(*args), idx| ... }
  #   - e.with_index(offset = 0)
  # -->
  # Iterates the given block for each element with an index, which starts from
  # `offset`.  If no block is given, returns a new Enumerator that includes the
  # index, starting from `offset`
  #
  # `offset`
  # :   the starting index to use
  #
  def with_index: (?Integer offset) { (Elem arg0, Integer arg1) -> untyped } -> Return
                | (?Integer offset) -> ::Enumerator[[ Elem, Integer ], Return]

  # <!-- rdoc-file=enumerator.c -->
  # Iterates the given block for each element with an arbitrary object, `obj`, and
  # returns `obj`
  #
  # If no block is given, returns a new Enumerator.
  #
  # ### Example
  #
  #     to_three = Enumerator.new do |y|
  #       3.times do |x|
  #         y << x
  #       end
  #     end
  #
  #     to_three_with_string = to_three.with_object("foo")
  #     to_three_with_string.each do |x,string|
  #       puts "#{string}: #{x}"
  #     end
  #
  #     # => foo: 0
  #     # => foo: 1
  #     # => foo: 2
  #
  def with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                 | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]
end

# <!-- rdoc-file=enumerator.c -->
# Generator
#
class Enumerator::Generator[out Elem] < Object
  include Enumerable[Elem]

  def each: () { (Elem) -> void } -> void
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Lazy is a special type of Enumerator, that allows constructing
# chains of operations without evaluating them immediately, and evaluating
# values on as-needed basis. In order to do so it redefines most of Enumerable
# methods so that they just construct another lazy enumerator.
#
# Enumerator::Lazy can be constructed from any Enumerable with the
# Enumerable#lazy method.
#
#     lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
#     # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>
#
# The real enumeration is performed when any non-redefined Enumerable method is
# called, like Enumerable#first or Enumerable#to_a (the latter is aliased as
# #force for more semantic code):
#
#     lazy.first(2)
#     #=> [21, 23]
#
#     lazy.force
#     #=> [21, 23, 25, 27, 29]
#
# Note that most Enumerable methods that could be called with or without a
# block, on Enumerator::Lazy will always require a block:
#
#     [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
#     [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block
#
# This class allows idiomatic calculations on long or infinite sequences, as
# well as chaining of calculations without constructing intermediate arrays.
#
# Example for working with a slowly calculated sequence:
#
#     require 'open-uri'
#
#     # This will fetch all URLs before selecting
#     # necessary data
#     URLS.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
#     # This will fetch URLs one-by-one, only till
#     # there is enough data to satisfy the condition
#     URLS.lazy.map { |u| JSON.parse(URI.open(u).read) }
#       .select { |data| data.key?('stats') }
#       .first(5)
#
# Ending a chain with ".eager" generates a non-lazy enumerator, which is
# suitable for returning or passing to another method that expects a normal
# enumerator.
#
#     def active_items
#       groups
#         .lazy
#         .flat_map(&:items)
#         .reject(&:disabled)
#         .eager
#     end
#
#     # This works lazily; if a checked item is found, it stops
#     # iteration and does not look into remaining groups.
#     first_checked = active_items.find(&:checked)
#
#     # This returns an array of items like a normal enumerator does.
#     all_checked = active_items.select(&:checked)
#
class Enumerator::Lazy[out Elem, out Return] < Enumerator[Elem, Return]
  # <!-- rdoc-file=enumerator.c -->
  # Expands `lazy` enumerator to an array. See Enumerable#to_a.
  #
  alias force to_a

  # <!--
  #   rdoc-file=enumerator.c
  #   - lazy.compact                  -> lazy_enumerator
  # -->
  # Like Enumerable#compact, but chains operation to be lazy-evaluated.
  #
  def compact: () -> Enumerator::Lazy[Elem, Return]
end

# <!-- rdoc-file=enumerator.c -->
# Yielder
#
class Enumerator::Yielder < Object
  def <<: (untyped arg0) -> void

  def yield: (*untyped arg0) -> void

  # <!--
  #   rdoc-file=enumerator.c
  #   - to_proc()
  # -->
  # Returns a Proc object that takes arguments and yields them.
  #
  # This method is implemented so that a Yielder object can be directly passed to
  # another method as a block argument.
  #
  #     enum = Enumerator.new { |y|
  #       Dir.glob("*.rb") { |file|
  #         File.open(file) { |f| f.each_line(&y) }
  #       }
  #     }
  #
  def to_proc: () -> Proc
end

# <!-- rdoc-file=enumerator.c -->
# Enumerator::Chain is a subclass of Enumerator, which represents a chain of
# enumerables that works as a single enumerator.
#
# This type of objects can be created by Enumerable#chain and Enumerator#+.
#
class Enumerator::Chain[out Elem] < Object
  include Enumerable[Elem]

  # <!--
  #   rdoc-file=enumerator.c
  #   - obj.each(*args) { |...| ... } -> obj
  #   - obj.each(*args) -> enumerator
  # -->
  # Iterates over the elements of the first enumerable by calling the "each"
  # method on it with the given arguments, then proceeds to the following
  # enumerables in sequence until all of the enumerables are exhausted.
  #
  # If no block is given, returns an enumerator.
  #
  def each: () { (Elem) -> void } -> void
end

# <!-- rdoc-file=vm.c -->
# The RubyVM module only exists on MRI. `RubyVM` is not defined in other Ruby
# implementations such as JRuby and TruffleRuby.
#
# The RubyVM module provides some access to MRI internals. This module is for
# very limited purposes, such as debugging, prototyping, and research.  Normal
# users must not use it. This module is not portable between Ruby
# implementations.
#
class RubyVM < Object
end

# <!-- rdoc-file=vm.c -->
# DEFAULT_PARAMS This constant exposes the VM's default parameters. Note that
# changing these values does not affect VM execution. Specification is not
# stable and you should not depend on this value. Of course, this constant is
# MRI specific.
#
RubyVM::DEFAULT_PARAMS: Hash[Symbol, Integer]

# <!-- rdoc-file=vm.c -->
# INSTRUCTION_NAMES A list of bytecode instruction names in MRI. This constant
# is MRI specific.
#
RubyVM::INSTRUCTION_NAMES: Array[String]

# <!-- rdoc-file=vm.c -->
# OPTS An Array of VM build options. This constant is MRI specific.
#
RubyVM::OPTS: Array[String]

# <!-- rdoc-file=iseq.c -->
# The InstructionSequence class represents a compiled sequence of instructions
# for the Virtual Machine used in MRI. Not all implementations of Ruby may
# implement this class, and for the implementations that implement it, the
# methods defined and behavior of the methods can change in any version.
#
# With it, you can get a handle to the instructions that make up a method or a
# proc, compile strings of Ruby code down to VM instructions, and disassemble
# instruction sequences to strings for easy inspection. It is mostly useful if
# you want to learn how YARV works, but it also lets you control various
# settings for the Ruby iseq compiler.
#
# You can find the source for the VM instructions in `insns.def` in the Ruby
# source.
#
# The instruction sequence results will almost certainly change as Ruby changes,
# so example output in this documentation may be different from what you see.
#
# Of course, this class is MRI specific.
#
class RubyVM::InstructionSequence < Object
end

# <!-- rdoc-file=ext/stringio/stringio.c -->
# Pseudo I/O on String object, with interface corresponding to IO.
#
# Commonly used to simulate `$stdio` or `$stderr`
#
# ### Examples
#
#     require 'stringio'
#
#     # Writing stream emulation
#     io = StringIO.new
#     io.puts "Hello World"
#     io.string #=> "Hello World\n"
#
#     # Reading stream emulation
#     io = StringIO.new "first\nsecond\nlast\n"
#     io.getc #=> "f"
#     io.gets #=> "irst\n"
#     io.read #=> "second\nlast\n"
#
class StringIO
  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.new(string=""[, mode])
  # -->
  # Creates new StringIO instance from with *string* and *mode*.
  #
  def initialize: (?String string, ?String? mode) -> void

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - StringIO.open(string=""[, mode]) {|strio| ...}
  # -->
  # Equivalent to StringIO.new except that when it is called with a block, it
  # yields with the new instance and closes it, and returns the result which
  # returned from the block.
  #
  def self.open: [U] (?String string, ?String? mode) { (StringIO arg) -> U } -> U

  def <<: (untyped arg0) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.binmode    -> stringio
  # -->
  # Puts stream into binary mode. See IO#binmode.
  #
  def binmode: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close  -> nil
  # -->
  # Closes a StringIO. The stream is unavailable for any further data operations;
  # an `IOError` is raised if such an attempt is made.
  #
  def close: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close_read    -> nil
  # -->
  # Closes the read end of a StringIO.  Will raise an `IOError` if the receiver is
  # not readable.
  #
  def close_read: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.close_write    -> nil
  # -->
  # Closes the write end of a StringIO.  Will raise an  `IOError` if the receiver
  # is not writeable.
  #
  def close_write: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed?    -> true or false
  # -->
  # Returns `true` if the stream is completely closed, `false` otherwise.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed_read?    -> true or false
  # -->
  # Returns `true` if the stream is not readable, `false` otherwise.
  #
  def closed_read?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.closed_write?    -> true or false
  # -->
  # Returns `true` if the stream is not writable, `false` otherwise.
  #
  def closed_write?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each(sep=$/, chomp: false) {|line| block }         -> strio
  #   - strio.each(limit, chomp: false) {|line| block }          -> strio
  #   - strio.each(sep, limit, chomp: false) {|line| block }     -> strio
  #   - strio.each(...)                                          -> anEnumerator
  #   - strio.each_line(sep=$/, chomp: false) {|line| block }     -> strio
  #   - strio.each_line(limit, chomp: false) {|line| block }      -> strio
  #   - strio.each_line(sep, limit, chomp: false) {|line| block } -> strio
  #   - strio.each_line(...)                                      -> anEnumerator
  # -->
  # See IO#each.
  #
  def each: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
          | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_byte {|byte| block }  -> strio
  #   - strio.each_byte                  -> anEnumerator
  # -->
  # See IO#each_byte.
  #
  def each_byte: () { (Integer arg0) -> untyped } -> self
               | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_char {|char| block }  -> strio
  #   - strio.each_char                  -> anEnumerator
  # -->
  # See IO#each_char.
  #
  def each_char: () { (String arg0) -> untyped } -> self
               | () -> ::Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.each_codepoint {|c| block }  -> strio
  #   - strio.each_codepoint               -> anEnumerator
  # -->
  # See IO#each_codepoint.
  #
  def each_codepoint: () { (Integer arg0) -> untyped } -> self
                    | () -> ::Enumerator[Integer, self]

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.eof     -> true or false
  #   - strio.eof?    -> true or false
  # -->
  # Returns true if the stream is at the end of the data (underlying string). The
  # stream must be opened for reading or an `IOError` will be raised.
  #
  def eof: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fcntl(*args)
  # -->
  # Raises NotImplementedError.
  #
  def fcntl: (Integer integer_cmd, String | Integer arg) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fileno()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def fileno: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - flush()
  # -->
  # Returns an object itself.  Just for compatibility to IO.
  #
  def flush: () -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - fsync()
  # -->
  # Returns 0.  Just for compatibility to IO.
  #
  def fsync: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.getbyte   -> fixnum or nil
  # -->
  # See IO#getbyte.
  #
  def getbyte: () -> Integer?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.getc   -> string or nil
  # -->
  # See IO#getc.
  #
  def getc: () -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.gets(sep=$/, chomp: false)     -> string or nil
  #   - strio.gets(limit, chomp: false)      -> string or nil
  #   - strio.gets(sep, limit, chomp: false) -> string or nil
  # -->
  # See IO#gets.
  #
  def gets: (?String sep, ?Integer limit, ?chomp: boolish) -> String?

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.internal_encoding   => encoding
  # -->
  # Returns the Encoding of the internal string if conversion is specified.
  # Otherwise returns `nil`.
  #
  def internal_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.external_encoding   => encoding
  # -->
  # Returns the Encoding object that represents the encoding of the file. If the
  # stream is write mode and no encoding is specified, returns `nil`.
  #
  def external_encoding: () -> Encoding

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - isatty()
  # -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def isatty: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.lineno    -> integer
  # -->
  # Returns the current line number. The stream must be opened for reading.
  # `lineno` counts the number of times  `gets` is called, rather than the number
  # of newlines  encountered. The two values will differ if `gets` is  called with
  # a separator other than newline.  See also the  `$.` variable.
  #
  def lineno: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.lineno = integer    -> integer
  # -->
  # Manually sets the current line number to the given value. `$.` is updated only
  # on the next read.
  #
  def lineno=: (Integer arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - pid()
  # -->
  # Returns `nil`.  Just for compatibility to IO.
  #
  def pid: () -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos     -> integer
  #   - strio.tell    -> integer
  # -->
  # Returns the current offset (in bytes).
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos = integer    -> integer
  # -->
  # Seeks to the given position (in bytes).
  #
  def pos=: (Integer arg0) -> Integer

  def print: (*untyped arg0) -> nil

  def printf: (String format_string, *untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.putc(obj)    -> obj
  # -->
  # See IO#putc.
  #
  def putc: (Numeric | String arg0) -> untyped

  def puts: (*untyped arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.read([length [, outbuf]])    -> string, outbuf, or nil
  # -->
  # See IO#read.
  #
  def read: (?int? length, ?string outbuf) -> String?

  def read_nonblock: (int len, ?string buf) -> String

  def readbyte: () -> Integer

  def readchar: () -> String

  def readline: (?String sep, ?Integer limit) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.readlines(sep=$/, chomp: false)     ->   array
  #   - strio.readlines(limit, chomp: false)      ->   array
  #   - strio.readlines(sep, limit, chomp: false) ->   array
  # -->
  # See IO#readlines.
  #
  def readlines: (?String sep, ?Integer limit, ?chomp: boolish) -> ::Array[String]

  def readpartial: (int maxlen, ?string outbuf) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.reopen(other_StrIO)     -> strio
  #   - strio.reopen(string, mode)    -> strio
  # -->
  # Reinitializes the stream with the given *other_StrIO* or *string* and *mode*
  # (see StringIO#new).
  #
  def reopen: (StringIO other) -> self
            | (String other, ?String mode_str) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.rewind    -> 0
  # -->
  # Positions the stream to the beginning of input, resetting `lineno` to zero.
  #
  def rewind: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.seek(amount, whence=SEEK_SET) -> 0
  # -->
  # Seeks to a given offset *amount* in the stream according to the value of
  # *whence* (see IO#seek).
  #
  def seek: (Integer amount, ?Integer whence) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.set_encoding(ext_enc, [int_enc[, opt]])  => strio
  # -->
  # Specify the encoding of the StringIO as *ext_enc*. Use the default external
  # encoding if *ext_enc* is nil. 2nd argument *int_enc* and optional hash *opt*
  # argument are ignored; they are for API compatibility to IO.
  #
  def set_encoding: (?String | Encoding ext_or_ext_int_enc) -> self
                  | (?String | Encoding ext_or_ext_int_enc, ?String | Encoding int_enc) -> self

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.string     -> string
  # -->
  # Returns underlying String object, the subject of IO.
  #
  def string: () -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.string = string  -> string
  # -->
  # Changes underlying String object, the subject of IO.
  #
  def string=: (String str) -> String

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.length -> integer
  #   - strio.size   -> integer
  # -->
  # Returns the size of the buffer string.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.sync    -> true
  # -->
  # Returns `true` always.
  #
  def sync: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - sync=(p1)
  # -->
  # Returns the argument unchanged.  Just for compatibility to IO.
  #
  def sync=: (boolish) -> bool

  def sysread: (Integer maxlen, String outbuf) -> String

  def syswrite: (String arg0) -> Integer

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.pos     -> integer
  #   - strio.tell    -> integer
  # -->
  # Returns the current offset (in bytes).
  #
  def tell: () -> Integer

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns `false`.  Just for compatibility to IO.
  #
  def tty?: () -> bool

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.ungetbyte(fixnum)   -> nil
  # -->
  # See IO#ungetbyte
  #
  def ungetbyte: (String | Integer arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.ungetc(string)   -> nil
  # -->
  # Pushes back one character (passed as a parameter) such that a subsequent
  # buffered read will return it.  There is no limitation for multiple pushbacks
  # including pushing back behind the beginning of the buffer string.
  #
  def ungetc: (String arg0) -> nil

  # <!--
  #   rdoc-file=ext/stringio/stringio.c
  #   - strio.write(string, ...) -> integer
  #   - strio.syswrite(string)   -> integer
  # -->
  # Appends the given string to the underlying buffer string. The stream must be
  # opened for writing.  If the argument is not a string, it will be converted to
  # a string using `to_s`. Returns the number of bytes written.  See IO#write.
  #
  def write: (String arg0) -> Integer

  # This is a deprecated alias for #each_byte.
  #
  def bytes: () { (Integer arg0) -> untyped } -> self
           | () -> ::Enumerator[Integer, self]

  # This is a deprecated alias for #each_char.
  #
  def chars: () { (String arg0) -> untyped } -> self
           | () -> ::Enumerator[String, self]

  # This is a deprecated alias for #each_codepoint.
  #
  def codepoints: () { (Integer arg0) -> untyped } -> self
                | () -> ::Enumerator[Integer, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # See IO#each.
  #
  def each_line: (?String sep, ?Integer limit, ?chomp: boolish) { (String) -> untyped } -> self
               | (?String sep, ?Integer limit, ?chomp: boolish) -> ::Enumerator[String, self]

  # <!-- rdoc-file=ext/stringio/stringio.c -->
  # Returns true if the stream is at the end of the data (underlying string). The
  # stream must be opened for reading or an `IOError` will be raised.
  #
  def eof?: () -> bool

  # This is a deprecated alias for #each_line.
  #
  def lines: (?String sep, ?Integer limit) { (String arg0) -> untyped } -> self
           | (?String sep, ?Integer limit) -> ::Enumerator[String, self]
end

# <!-- rdoc-file=object.c -->
# BasicObject is the parent class of all classes in Ruby.  It's an explicit
# blank class.
#
# BasicObject can be used for creating object hierarchies independent of Ruby's
# object hierarchy, proxy objects like the Delegator class, or other uses where
# namespace pollution from Ruby's methods and classes must be avoided.
#
# To avoid polluting BasicObject for other users an appropriately named subclass
# of BasicObject should be created instead of directly modifying BasicObject:
#
#     class MyObjectSystem < BasicObject
#     end
#
# BasicObject does not include Kernel (for methods like `puts`) and BasicObject
# is outside of the namespace of the standard library so common classes will not
# be found without using a full class path.
#
# A variety of strategies can be used to provide useful portions of the standard
# library to subclasses of BasicObject.  A subclass could `include Kernel` to
# obtain `puts`, `exit`, etc.  A custom Kernel-like module could be created and
# included or delegation can be used via #method_missing:
#
#     class MyObjectSystem < BasicObject
#       DELEGATE = [:puts, :p]
#
#       def method_missing(name, *args, &block)
#         return super unless DELEGATE.include? name
#         ::Kernel.send(name, *args, &block)
#       end
#
#       def respond_to_missing?(name, include_private = false)
#         DELEGATE.include?(name) or super
#       end
#     end
#
# Access to classes and modules from the Ruby standard library can be obtained
# in a BasicObject subclass by referencing the desired constant from the root
# like `::File` or `::Enumerator`. Like #method_missing, #const_missing can be
# used to delegate constant lookup to `Object`:
#
#     class MyObjectSystem < BasicObject
#       def self.const_missing(name)
#         ::Object.const_get(name)
#       end
#     end
#
# ### What's Here
#
# These are the methods defined for BasicObject:
#
#     ::new
# :       Returns a new BasicObject instance.
#
#     [!](#method-i-21)
# :       Returns the boolean negation of `self`: `true` or `false`.
#
#     [!=](#method-i-21-3D)
# :       Returns whether `self` and the given object are *not* equal.
#
#     [==](#method-i-3D-3D)
# :       Returns whether `self` and the given object are equivalent.
#
#     [__id__](#method-i-__id__)
# :       Returns the integer object identifier for `self`.
#
#     [__send__](#method-i-__send__)
# :       Calls the method identified by the given symbol.
#
#     #equal?
# :       Returns whether `self` and the given object are the same object.
#
#     #instance_eval
# :       Evaluates the given string or block in the context of `self`.
#
#     #instance_exec
# :       Executes the given block in the context of `self`, passing the given
#         arguments.
#
#     #method_missing
# :       Method called when an undefined method is called on `self`.
#
#     #singleton_method_added
# :       Method called when a singleton method is added to `self`.
#
#     #singleton_method_removed
# :       Method called when a singleton method is added removed from `self`.
#
#     #singleton_method_undefined
# :       Method called when a singleton method is undefined in `self`.
#
class BasicObject
  # <!--
  #   rdoc-file=object.c
  #   - !obj    -> true or false
  # -->
  # Boolean negate.
  #
  def !: () -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj != other        -> true or false
  # -->
  # Returns true if two objects are not-equal, otherwise false.
  #
  def !=: (untyped other) -> bool

  # <!--
  #   rdoc-file=object.c
  #   - obj == other        -> true or false
  #   - obj.equal?(other)   -> true or false
  #   - obj.eql?(other)     -> true or false
  # -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - obj.__id__       -> integer
  #   - obj.object_id    -> integer
  # -->
  # Returns an integer identifier for `obj`.
  #
  # The same number will be returned on all calls to `object_id` for a given
  # object, and no two active objects will share an id.
  #
  # Note: that some objects of builtin classes are reused for optimization. This
  # is the case for immediate values and frozen string literals.
  #
  # BasicObject implements +__id__+, Kernel implements `object_id`.
  #
  # Immediate values are not passed by reference but are passed by value: `nil`,
  # `true`, `false`, Fixnums, Symbols, and some Floats.
  #
  #     Object.new.object_id  == Object.new.object_id  # => false
  #     (21 * 2).object_id    == (21 * 2).object_id    # => true
  #     "hello".object_id     == "hello".object_id     # => false
  #     "hi".freeze.object_id == "hi".freeze.object_id # => true
  #
  def __id__: () -> Integer

  # <!--
  #   rdoc-file=vm_eval.c
  #   - foo.send(symbol [, args...])       -> obj
  #   - foo.__send__(symbol [, args...])   -> obj
  #   - foo.send(string [, args...])       -> obj
  #   - foo.__send__(string [, args...])   -> obj
  # -->
  # Invokes the method identified by *symbol*, passing it any arguments specified.
  # When the method is identified by a string, the string is converted to a
  # symbol.
  #
  # BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
  # safer than `send` when *obj* has the same method name like `Socket`. See also
  # `public_send`.
  #
  #     class Klass
  #       def hello(*args)
  #         "Hello " + args.join(' ')
  #       end
  #     end
  #     k = Klass.new
  #     k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
  #
  def __send__: (String | Symbol arg0, *untyped args) -> untyped

  # <!-- rdoc-file=object.c -->
  # Equality --- At the Object level, #== returns `true` only if `obj` and `other`
  # are the same object.  Typically, this method is overridden in descendant
  # classes to provide class-specific meaning.
  #
  # Unlike #==, the #equal? method should never be overridden by subclasses as it
  # is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  #
  #     obj = "a"
  #     other = obj.dup
  #
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  #
  # The #eql? method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For any pair of
  # objects where #eql? returns `true`, the #hash value of both objects must be
  # equal. So any subclass that overrides #eql? should also override #hash
  # appropriately.
  #
  # For objects of class Object, #eql?  is synonymous with #==.  Subclasses
  # normally continue this tradition by aliasing #eql? to their overridden #==
  # method, but there are exceptions. Numeric types, for example, perform type
  # conversion across #==, but not across #eql?, so:
  #
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  #
  def equal?: (untyped other) -> bool

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_eval(string [, filename [, lineno]] )   -> obj
  #   - obj.instance_eval {|obj| block }                     -> obj
  # -->
  # Evaluates a string containing Ruby source code, or the given block, within the
  # context of the receiver (*obj*). In order to set the context, the variable
  # `self` is set to *obj* while the code is executing, giving the code access to
  # *obj*'s instance variables and private methods.
  #
  # When `instance_eval` is given a block, *obj* is also passed in as the block's
  # only argument.
  #
  # When `instance_eval` is given a `String`, the optional second and third
  # parameters supply a filename and starting line number that are used when
  # reporting compilation errors.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #       private
  #       def the_secret
  #         "Ssssh! The secret is #{@secret}."
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_eval { @secret }          #=> 99
  #     k.instance_eval { the_secret }       #=> "Ssssh! The secret is 99."
  #     k.instance_eval {|obj| obj == self } #=> true
  #
  def instance_eval: (String, ?String filename, ?Integer lineno) -> untyped
                   | [U] () { (self) -> U } -> U

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.instance_exec(arg...) {|var...| block }                       -> obj
  # -->
  # Executes the given block within the context of the receiver (*obj*). In order
  # to set the context, the variable `self` is set to *obj* while the code is
  # executing, giving the code access to *obj*'s instance variables.  Arguments
  # are passed as block parameters.
  #
  #     class KlassWithSecret
  #       def initialize
  #         @secret = 99
  #       end
  #     end
  #     k = KlassWithSecret.new
  #     k.instance_exec(5) {|x| @secret+x }   #=> 104
  #
  def instance_exec: [U, V] (*V args) { (*V args) -> U } -> U

  # <!--
  #   rdoc-file=object.c
  #   - BasicObject.new
  # -->
  # Returns a new BasicObject.
  #
  def initialize: () -> void

  private

  # <!--
  #   rdoc-file=vm_eval.c
  #   - obj.method_missing(symbol [, *args] )   -> result
  # -->
  # Invoked by Ruby when *obj* is sent a message it cannot handle. *symbol* is the
  # symbol for the method called, and *args* are any arguments that were passed to
  # it. By default, the interpreter raises an error when this method is called.
  # However, it is possible to override the method to provide more dynamic
  # behavior. If it is decided that a particular method should not be handled,
  # then *super* should be called, so that ancestors can pick up the missing
  # method. The example below creates a class `Roman`, which responds to methods
  # with names consisting of roman numerals, returning the corresponding integer
  # values.
  #
  #     class Roman
  #       def roman_to_int(str)
  #         # ...
  #       end
  #
  #       def method_missing(symbol, *args)
  #         str = symbol.id2name
  #         begin
  #           roman_to_int(str)
  #         rescue
  #           super(symbol, *args)
  #         end
  #       end
  #     end
  #
  #     r = Roman.new
  #     r.iv      #=> 4
  #     r.xxiii   #=> 23
  #     r.mm      #=> 2000
  #     r.foo     #=> NoMethodError
  #
  def method_missing: (Symbol, *untyped, **untyped) ?{ (*untyped, **untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_added(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is added to the receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_added(id)
  #         puts "Adding #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #     end
  #
  # *produces:*
  #
  #     Adding singleton_method_added
  #     Adding one
  #     Adding three
  #
  def singleton_method_added: (Symbol) -> void

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_removed(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is removed from the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_removed(id)
  #         puts "Removing #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #       class << self
  #         remove_method :three
  #         remove_method :one
  #       end
  #     end
  #
  # *produces:*
  #
  #     Removing three
  #     Removing one
  #
  def singleton_method_removed: (Symbol) -> void

  # <!--
  #   rdoc-file=object.c
  #   - singleton_method_undefined(symbol)
  # -->
  # Invoked as a callback whenever a singleton method is undefined in the
  # receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_undefined(id)
  #         puts "Undefining #{id.id2name}"
  #       end
  #       def Chatty.one()   end
  #       class << self
  #          undef_method(:one)
  #       end
  #     end
  #
  # *produces:*
  #
  #     Undefining one
  #
  def singleton_method_undefined: (Symbol) -> void
end

# <!-- rdoc-file=marshal.c -->
# The marshaling library converts collections of Ruby objects into a byte
# stream, allowing them to be stored outside the currently active script. This
# data may subsequently be read and the original objects reconstituted.
#
# Marshaled data has major and minor version numbers stored along with the
# object information. In normal use, marshaling can only load data written with
# the same major version number and an equal or lower minor version number. If
# Ruby's ``verbose'' flag is set (normally using -d, -v, -w, or --verbose) the
# major and minor numbers must match exactly. Marshal versioning is independent
# of Ruby's version numbers. You can extract the version by reading the first
# two bytes of marshaled data.
#
#     str = Marshal.dump("thing")
#     RUBY_VERSION   #=> "1.9.0"
#     str[0].ord     #=> 4
#     str[1].ord     #=> 8
#
# Some objects cannot be dumped: if the objects to be dumped include bindings,
# procedure or method objects, instances of class IO, or singleton objects, a
# TypeError will be raised.
#
# If your class has special serialization needs (for example, if you want to
# serialize in some specific format), or if it contains objects that would
# otherwise not be serializable, you can implement your own serialization
# strategy.
#
# There are two methods of doing this, your object can define either
# marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
# precedence over _dump if both are defined.  marshal_dump may result in smaller
# Marshal strings.
#
# ## Security considerations
#
# By design, Marshal.load can deserialize almost any class loaded into the Ruby
# process. In many cases this can lead to remote code execution if the Marshal
# data is loaded from an untrusted source.
#
# As a result, Marshal.load is not suitable as a general purpose serialization
# format and you should never unmarshal user supplied input or other untrusted
# data.
#
# If you need to deserialize untrusted data, use JSON or another serialization
# format that is only able to load simple, 'primitive' types such as String,
# Array, Hash, etc. Never allow user input to specify arbitrary types to
# deserialize into.
#
# ## marshal_dump and marshal_load
#
# When dumping an object the method marshal_dump will be called. marshal_dump
# must return a result containing the information necessary for marshal_load to
# reconstitute the object.  The result can be any object.
#
# When loading an object dumped using marshal_dump the object is first allocated
# then marshal_load is called with the result from marshal_dump. marshal_load
# must recreate the object from the information in the result.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def marshal_dump
#         [@name, @version]
#       end
#
#       def marshal_load array
#         @name, @version = array
#       end
#     end
#
# ## _dump and _load
#
# Use _dump and _load when you need to allocate the object you're restoring
# yourself.
#
# When dumping an object the instance method _dump is called with an Integer
# which indicates the maximum depth of objects to dump (a value of -1 implies
# that you should disable depth checking).  _dump must return a String
# containing the information necessary to reconstitute the object.
#
# The class method _load should take a String and use it to return an object of
# the same class.
#
# Example:
#
#     class MyObj
#       def initialize name, version, data
#         @name    = name
#         @version = version
#         @data    = data
#       end
#
#       def _dump level
#         [@name, @version].join ':'
#       end
#
#       def self._load args
#         new(*args.split(':'))
#       end
#     end
#
# Since Marshal.dump outputs a string you can have _dump return a Marshal string
# which is Marshal.loaded in _load for complex objects.
#
module Marshal
  # <!--
  #   rdoc-file=marshal.c
  #   - dump( obj [, anIO] , limit=-1 ) -> anIO
  # -->
  # Serializes obj and all descendant objects. If anIO is specified, the
  # serialized data will be written to it, otherwise the data will be returned as
  # a String. If limit is specified, the traversal of subobjects will be limited
  # to that depth. If limit is negative, no checking of depth will be performed.
  #
  #     class Klass
  #       def initialize(str)
  #         @str = str
  #       end
  #       def say_hello
  #         @str
  #       end
  #     end
  #
  # (produces no output)
  #
  #     o = Klass.new("hello\n")
  #     data = Marshal.dump(o)
  #     obj = Marshal.load(data)
  #     obj.say_hello  #=> "hello\n"
  #
  # Marshal can't dump following objects:
  # *   anonymous Class/Module.
  # *   objects which are related to system (ex: Dir, File::Stat, IO, File, Socket
  #     and so on)
  # *   an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,
  #     ThreadGroup, Continuation
  # *   objects which define singleton methods
  #
  def self.dump: (untyped obj, untyped port, ?Integer limit) -> untyped
               | (untyped obj, ?Integer limit) -> String

  # <!--
  #   rdoc-file=marshal.rb
  #   - load(source, proc = nil, freeze: false) -> obj
  #   - restore(source, proc = nil, freeze: false) -> obj
  # -->
  # Returns the result of converting the serialized data in source into a Ruby
  # object (possibly with associated subordinate objects). source may be either an
  # instance of IO or an object that responds to to_str. If proc is specified,
  # each object will be passed to the proc, as the object is being deserialized.
  #
  # Never pass untrusted data (including user supplied input) to this method.
  # Please see the overview for further details.
  #
  # If the `freeze: true` argument is passed, deserialized object would be deeply
  # frozen. Note that it may lead to more efficient memory usage due to frozen
  # strings deduplication:
  #
  #     serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])
  #
  #     deserialized = Marshal.load(serialized)
  #     deserialized.map(&:frozen?)
  #     # => [false, false, false, false]
  #     deserialized.map(&:object_id)
  #     # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects
  #
  #     deserialized = Marshal.load(serialized, freeze: true)
  #     deserialized.map(&:frozen?)
  #     # => [true, true, true, true]
  #     deserialized.map(&:object_id)
  #     # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating
  #
  def self.load: (String | untyped port, ?freeze: boolish) -> untyped
               | [A] (String | untyped port, ^(untyped) -> A, ?freeze: boolish) -> A

  # <!--
  #   rdoc-file=marshal.rb
  #   - restore(source, proc = nil, freeze: false)
  # -->
  #
  alias self.restore self.load
end

# <!-- rdoc-file=marshal.c -->
# major version
#
Marshal::MAJOR_VERSION: Integer

# <!-- rdoc-file=marshal.c -->
# minor version
#
Marshal::MINOR_VERSION: Integer

# <!-- rdoc-file=error.c -->
# The Warning module contains a single method named #warn, and the module
# extends itself, making Warning.warn available. Warning.warn is called for all
# warnings issued by Ruby. By default, warnings are printed to $stderr.
#
# Changing the behavior of Warning.warn is useful to customize how warnings are
# handled by Ruby, for instance by filtering some warnings, and/or outputting
# warnings somewhere other than $stderr.
#
# If you want to change the behavior of Warning.warn you should use
# +Warning.extend(MyNewModuleWithWarnMethod)+ and you can use `super` to get the
# default behavior of printing the warning to $stderr.
#
# Example:
#     module MyWarningFilter
#       def warn(message, category: nil, **kwargs)
#         if /some warning I want to ignore/.match?(message)
#           # ignore
#         else
#           super
#         end
#       end
#     end
#     Warning.extend MyWarningFilter
#
# You should never redefine Warning#warn (the instance method), as that will
# then no longer provide a way to use the default behavior.
#
# The `warning` gem provides convenient ways to customize Warning.warn.
#
module Warning
  # <!--
  #   rdoc-file=error.c
  #   - warn(msg, category: nil)  -> nil
  # -->
  # Writes warning message `msg` to $stderr. This method is called by Ruby for all
  # emitted warnings. A `category` may be included with the warning.
  #
  # See the documentation of the Warning module for how to customize this.
  #
  def warn: (String) -> nil
end

# <!-- rdoc-file=gc.rb -->
# The GC module provides an interface to Ruby's mark and sweep garbage
# collection mechanism.
#
# Some of the underlying methods are also available via the ObjectSpace module.
#
# You may obtain information about the operation of the GC through GC::Profiler.
#
module GC
  # <!--
  #   rdoc-file=gc.rb
  #   - GC.count -> Integer
  # -->
  # The number of times GC occurred.
  #
  # It returns the number of times GC occurred since the process started.
  #
  def self.count: () -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.disable    -> true or false
  # -->
  # Disables garbage collection, returning `true` if garbage collection was
  # already disabled.
  #
  #     GC.disable   #=> false
  #     GC.disable   #=> true
  #
  def self.disable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.enable    -> true or false
  # -->
  # Enables garbage collection, returning `true` if garbage collection was
  # previously disabled.
  #
  #     GC.disable   #=> false
  #     GC.enable    #=> true
  #     GC.enable    #=> false
  #
  def self.enable: () -> bool

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.start                     -> nil
  #   - ObjectSpace.garbage_collect  -> nil
  #   - include GC; garbage_collect  -> nil
  #   - GC.start(full_mark: true, immediate_sweep: true)           -> nil
  #   - ObjectSpace.garbage_collect(full_mark: true, immediate_sweep: true) -> nil
  #   - include GC; garbage_collect(full_mark: true, immediate_sweep: true) -> nil
  # -->
  # Initiates garbage collection, even if manually disabled.
  #
  # This method is defined with keyword arguments that default to true:
  #
  #     def GC.start(full_mark: true, immediate_sweep: true); end
  #
  # Use full_mark: false to perform a minor GC. Use immediate_sweep: false to
  # defer sweeping (use lazy sweep).
  #
  # Note: These keyword arguments are implementation and version dependent. They
  # are not guaranteed to be future-compatible, and may be ignored if the
  # underlying implementation does not support them.
  #
  def self.start: (?immediate_sweep: boolish immediate_sweep, ?immediate_mark: boolish immediate_mark, ?full_mark: boolish full_mark) -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stat -> Hash
  #   - GC.stat(hash) -> Hash
  #   - GC.stat(:key) -> Numeric
  # -->
  # Returns a Hash containing information about the GC.
  #
  # The contents of the hash are implementation specific and may change in the
  # future without notice.
  #
  # The hash includes information about internal statistics about GC such as:
  #
  # count
  # :   The total number of garbage collections ran since application start (count
  #     includes both minor and major garbage collections)
  # heap_allocated_pages
  # :   The total number of `:heap_eden_pages` + `:heap_tomb_pages`
  # heap_sorted_length
  # :   The number of pages that can fit into the buffer that holds references to
  #     all pages
  # heap_allocatable_pages
  # :   The total number of pages the application could allocate without
  #     additional GC
  # heap_available_slots
  # :   The total number of slots in all `:heap_allocated_pages`
  # heap_live_slots
  # :   The total number of slots which contain live objects
  # heap_free_slots
  # :   The total number of slots which do not contain live objects
  # heap_final_slots
  # :   The total number of slots with pending finalizers to be run
  # heap_marked_slots
  # :   The total number of objects marked in the last GC
  # heap_eden_pages
  # :   The total number of pages which contain at least one live slot
  # heap_tomb_pages
  # :   The total number of pages which do not contain any live slots
  # total_allocated_pages
  # :   The cumulative number of pages allocated since application start
  # total_freed_pages
  # :   The cumulative number of pages freed since application start
  # total_allocated_objects
  # :   The cumulative number of objects allocated since application start
  # total_freed_objects
  # :   The cumulative number of objects freed since application start
  # malloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by any GC
  # malloc_increase_bytes_limit
  # :   When `:malloc_increase_bytes` crosses this limit, GC is triggered
  # minor_gc_count
  # :   The total number of minor garbage collections run since process start
  # major_gc_count
  # :   The total number of major garbage collections run since process start
  # remembered_wb_unprotected_objects
  # :   The total number of objects without write barriers
  # remembered_wb_unprotected_objects_limit
  # :   When `:remembered_wb_unprotected_objects` crosses this limit, major GC is
  #     triggered
  # old_objects
  # :   Number of live, old objects which have survived at least 3 garbage
  #     collections
  # old_objects_limit
  # :   When `:old_objects` crosses this limit, major GC is triggered
  # oldmalloc_increase_bytes
  # :   Amount of memory allocated on the heap for objects. Decreased by major GC
  # oldmalloc_increase_bytes_limit
  # :   When `:old_malloc_increase_bytes` crosses this limit, major GC is
  #     triggered
  #
  #
  # If the optional argument, hash, is given, it is overwritten and returned. This
  # is intended to avoid probe effect.
  #
  # This method is only expected to work on CRuby.
  #
  def self.stat: (?::Hash[Symbol, Integer] arg0) -> ::Hash[Symbol, Integer]
               | (?Symbol arg0) -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress            -> integer, true or false
  # -->
  # Returns current status of GC stress mode.
  #
  def self.stress: () -> (Integer | TrueClass | FalseClass)

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.stress = flag          -> flag
  # -->
  # Updates the GC stress mode.
  #
  # When stress mode is enabled, the GC is invoked at every GC opportunity: all
  # memory and object allocations.
  #
  # Enabling stress mode will degrade performance, it is only for debugging.
  #
  # flag can be true, false, or an integer bit-ORed following flags.
  #     0x01:: no major GC
  #     0x02:: no immediate sweep
  #     0x04:: full mark after malloc/calloc/realloc
  #
  def self.stress=: (Integer | TrueClass | FalseClass flag) -> (Integer | TrueClass | FalseClass)

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.total_time -> int
  # -->
  # Return measured GC total time in nano seconds.
  #
  def self.total_time: () -> Integer

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.compact
  # -->
  # This function compacts objects together in Ruby's heap.  It eliminates unused
  # space (or fragmentation) in the heap by moving objects in to that unused
  # space.  This function returns a hash which contains statistics about which
  # objects were moved.  See `GC.latest_gc_info` for details about compaction
  # statistics.
  #
  # This method is implementation specific and not expected to be implemented in
  # any implementation besides MRI.
  #
  def self.compact: () -> ::Hash[:considered | :moved, Hash[Symbol | Integer, Integer]]

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.verify_compaction_references(toward: nil, double_heap: false) -> hash
  # -->
  # Verify compaction reference consistency.
  #
  # This method is implementation specific.  During compaction, objects that were
  # moved are replaced with T_MOVED objects.  No object should have a reference to
  # a T_MOVED object after compaction.
  #
  # This function doubles the heap to ensure room to move all objects, compacts
  # the heap to make sure everything moves, updates all references, then performs
  # a full GC.  If any object contains a reference to a T_MOVED object, that
  # object should be pushed on the mark stack, and will make a SEGV.
  #
  def self.verify_compaction_references: () -> ::Hash[:considered | :moved, Hash[Symbol | Integer, Integer]]

  # <!--
  #   rdoc-file=gc.c
  #   - GC.verify_internal_consistency                  -> nil
  # -->
  # Verify internal consistency.
  #
  # This method is implementation specific. Now this method checks generational
  # consistency if RGenGC is supported.
  #
  def self.verify_internal_consistency: () -> nil

  # <!--
  #   rdoc-file=gc.c
  #   - verify_transient_heap_internal_consistency()
  # -->
  #
  def self.verify_transient_heap_internal_consistency: () -> nil

  # <!--
  #   rdoc-file=gc.rb
  #   - GC.latest_gc_info -> {:gc_by=>:newobj}
  #   - GC.latest_gc_info(hash) -> hash
  #   - GC.latest_gc_info(:major_by) -> :malloc
  # -->
  # Returns information about the most recent garbage collection.
  #
  # If the optional argument, hash, is given, it is overwritten and returned. This
  # is intended to avoid probe effect.
  #
  def self.latest_gc_info: () -> ::Hash[::Symbol, untyped]
                         | [K] (?Hash[K, untyped] hash) -> ::Hash[::Symbol | K, untyped]
                         | (Symbol key) -> untyped

  # <!--
  #   rdoc-file=gc.rb
  #   - garbage_collect(full_mark: true, immediate_mark: true, immediate_sweep: true)
  # -->
  #
  def garbage_collect: (?immediate_sweep: boolish immediate_sweep, ?immediate_mark: boolish immediate_mark, ?full_mark: boolish full_mark) -> nil
end

# <!-- rdoc-file=gc.c -->
# internal constants
#
GC::INTERNAL_CONSTANTS: Hash[Symbol, Integer]

# <!-- rdoc-file=gc.c -->
# GC build options
#
GC::OPTS: Array[String]

# <!-- rdoc-file=gc.c -->
# The GC profiler provides access to information on GC runs including time,
# length and object space size.
#
# Example:
#
#     GC::Profiler.enable
#
#     require 'rdoc/rdoc'
#
#     GC::Profiler.report
#
#     GC::Profiler.disable
#
# See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations
#
module GC::Profiler
  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.clear          -> nil
  # -->
  # Clears the GC profiler data.
  #
  def self.clear: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.disable      -> nil
  # -->
  # Stops the GC profiler.
  #
  def self.disable: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.enable       -> nil
  # -->
  # Starts the GC profiler.
  #
  def self.enable: () -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.enabled?     -> true or false
  # -->
  # The current status of GC profile mode.
  #
  def self.enabled?: () -> bool

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.raw_data    -> [Hash, ...]
  # -->
  # Returns an Array of individual raw profile data Hashes ordered from earliest
  # to latest by `:GC_INVOKE_TIME`.
  #
  # For example:
  #
  #     [
  #       {
  #          :GC_TIME=>1.3000000000000858e-05,
  #          :GC_INVOKE_TIME=>0.010634999999999999,
  #          :HEAP_USE_SIZE=>289640,
  #          :HEAP_TOTAL_SIZE=>588960,
  #          :HEAP_TOTAL_OBJECTS=>14724,
  #          :GC_IS_MARKED=>false
  #       },
  #       # ...
  #     ]
  #
  # The keys mean:
  #
  # `:GC_TIME`
  # :   Time elapsed in seconds for this GC run
  # `:GC_INVOKE_TIME`
  # :   Time elapsed in seconds from startup to when the GC was invoked
  # `:HEAP_USE_SIZE`
  # :   Total bytes of heap used
  # `:HEAP_TOTAL_SIZE`
  # :   Total size of heap in bytes
  # `:HEAP_TOTAL_OBJECTS`
  # :   Total number of objects
  # `:GC_IS_MARKED`
  # :   Returns `true` if the GC is in mark phase
  #
  #
  # If ruby was built with `GC_PROFILE_MORE_DETAIL`, you will also have access to
  # the following hash keys:
  #
  # `:GC_MARK_TIME`
  # `:GC_SWEEP_TIME`
  # `:ALLOCATE_INCREASE`
  # `:ALLOCATE_LIMIT`
  # `:HEAP_USE_PAGES`
  # `:HEAP_LIVE_OBJECTS`
  # `:HEAP_FREE_OBJECTS`
  # `:HAVE_FINALIZE`
  # :
  #
  def self.raw_data: () -> ::Array[::Hash[Symbol, untyped]]

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.report
  #   - GC::Profiler.report(io)
  # -->
  # Writes the GC::Profiler.result to `$stdout` or the given IO object.
  #
  def self.report: (?IO io) -> void

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.result  -> String
  # -->
  # Returns a profile data report such as:
  #
  #     GC 1 invokes.
  #     Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object                    GC time(ms)
  #         1               0.012               159240               212940                10647         0.00000000000001530000
  #
  def self.result: () -> String

  # <!--
  #   rdoc-file=gc.c
  #   - GC::Profiler.total_time  -> float
  # -->
  # The total time used for garbage collection in seconds
  #
  def self.total_time: () -> Float
end

%a{annotate:rdoc:skip}
class Integer
  # <!--
  #   rdoc-file=lib/prime.rb
  #   - each_prime(ubound) { |prime| ... }
  # -->
  # Iterates the given block over all prime numbers.
  #
  # See `Prime`#each for more details.
  #
  def self.each_prime: (Integer) { (Integer) -> void } -> void

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - from_prime_division(pd)
  # -->
  # Re-composes a prime factorization and returns the product.
  #
  # See Prime#int_from_prime_division for more details.
  #
  def self.from_prime_division: (Array[[ String ]]) -> Integer

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime_division(generator = Prime::Generator23.new)
  # -->
  # Returns the factorization of `self`.
  #
  # See Prime#prime_division for more details.
  #
  def prime_division: (?Prime::PseudoPrimeGenerator) -> Array[[ Integer, Integer ]]

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime?()
  # -->
  # Returns true if `self` is a prime number, else returns false. Not recommended
  # for very big integers (> 10**23).
  #
  def prime?: () -> bool
end

# <!-- rdoc-file=lib/prime.rb -->
# The set of all prime numbers.
#
# ## Example
#
#     Prime.each(100) do |prime|
#       p prime  #=> 2, 3, 5, 7, 11, ...., 97
#     end
#
# Prime is Enumerable:
#
#     Prime.first 5 # => [2, 3, 5, 7, 11]
#
# ## Retrieving the instance
#
# For convenience, each instance method of `Prime`.instance can be accessed as a
# class method of `Prime`.
#
# e.g.
#     Prime.instance.prime?(2)  #=> true
#     Prime.prime?(2)           #=> true
#
# ## Generators
#
# A "generator" provides an implementation of enumerating pseudo-prime numbers
# and it remembers the position of enumeration and upper bound. Furthermore, it
# is an external iterator of prime enumeration which is compatible with an
# Enumerator.
#
# `Prime`::`PseudoPrimeGenerator` is the base class for generators. There are
# few implementations of generator.
#
# `Prime`::`EratosthenesGenerator`
# :   Uses Eratosthenes' sieve.
# `Prime`::`TrialDivisionGenerator`
# :   Uses the trial division method.
# `Prime`::`Generator23`
# :   Generates all positive integers which are not divisible by either 2 or 3.
#     This sequence is very bad as a pseudo-prime sequence. But this is faster
#     and uses much less memory than the other generators. So, it is suitable
#     for factorizing an integer which is not large but has many prime factors.
#     e.g. for Prime#prime? .
#
class Prime
  include Singleton

  include Enumerable[Integer]

  extend Enumerable[Integer]

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - each(ubound = nil, generator = EratosthenesGenerator.new, &block)
  # -->
  # Iterates the given block over all prime numbers.
  #
  # ## Parameters
  #
  # `ubound`
  # :   Optional. An arbitrary positive number. The upper bound of enumeration.
  #     The method enumerates prime numbers infinitely if `ubound` is nil.
  # `generator`
  # :   Optional. An implementation of pseudo-prime generator.
  #
  #
  # ## Return value
  #
  # An evaluated value of the given block at the last time. Or an enumerator which
  # is compatible to an `Enumerator` if no block given.
  #
  # ## Description
  #
  # Calls `block` once for each prime number, passing the prime as a parameter.
  #
  # `ubound`
  # :   Upper bound of prime numbers. The iterator stops after it yields all prime
  #     numbers p <= `ubound`.
  #
  def self?.each: (?Integer? ubound, ?PseudoPrimeGenerator generator) { (Integer) -> void } -> void
                | (?Integer? ubound, ?PseudoPrimeGenerator generator) -> PseudoPrimeGenerator

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - int_from_prime_division(pd)
  # -->
  # Re-composes a prime factorization and returns the product.
  #
  # For the decomposition:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]],
  #
  # it returns:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n.
  #
  # ## Parameters
  # `pd`
  # :   Array of pairs of integers. Each pair consists of a prime number -- a
  #     prime factor -- and a natural number -- its exponent (multiplicity).
  #
  #
  # ## Example
  #     Prime.int_from_prime_division([[3, 2], [5, 1]])  #=> 45
  #     3**2 * 5                                         #=> 45
  #
  def self?.int_from_prime_division: (Array[[ Integer, Integer ]]) -> Integer

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime?(value, generator = Prime::Generator23.new)
  # -->
  # Returns true if `value` is a prime number, else returns false. Integer#prime?
  # is much more performant.
  #
  # ## Parameters
  #
  # `value`
  # :   an arbitrary integer to be checked.
  # `generator`
  # :   optional. A pseudo-prime generator.
  #
  def self?.prime?: (Integer value, ?PseudoPrimeGenerator generator) -> bool

  # <!--
  #   rdoc-file=lib/prime.rb
  #   - prime_division(value, generator = Prime::Generator23.new)
  # -->
  # Returns the factorization of `value`.
  #
  # For an arbitrary integer:
  #
  #     p_1**e_1 * p_2**e_2 * ... * p_n**e_n,
  #
  # prime_division returns an array of pairs of integers:
  #
  #     [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]].
  #
  # Each pair consists of a prime number -- a prime factor -- and a natural number
  # -- its exponent (multiplicity).
  #
  # ## Parameters
  # `value`
  # :   An arbitrary integer.
  # `generator`
  # :   Optional. A pseudo-prime generator. `generator`.succ must return the next
  #     pseudo-prime number in ascending order. It must generate all prime
  #     numbers, but may also generate non-prime numbers, too.
  #
  #
  # ### Exceptions
  # `ZeroDivisionError`
  # :   when `value` is zero.
  #
  #
  # ## Example
  #
  #     Prime.prime_division(45)  #=> [[3, 2], [5, 1]]
  #     3**2 * 5                  #=> 45
  #
  def self?.prime_division: (Integer, ?PseudoPrimeGenerator generator) -> Array[[ Integer, Integer ]]

  # Returns the singleton instance.
  #
  def self.instance: () -> Prime

  # <!-- rdoc-file=lib/prime.rb -->
  # An abstract class for enumerating pseudo-prime numbers.
  #
  # Concrete subclasses should override succ, next, rewind.
  #
  class PseudoPrimeGenerator
    # <!--
    #   rdoc-file=lib/prime.rb
    #   - new(ubound = nil)
    # -->
    #
    def initialize: (?Integer?) -> void

    include Enumerable[Integer]

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - upper_bound()
    # -->
    # ----
    # <!--
    #   rdoc-file=lib/prime.rb
    #   - upper_bound=(ubound)
    # -->
    #
    attr_accessor upper_bound(): Integer?

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - each() { |prime| ... }
    # -->
    # Iterates the given block for each prime number.
    #
    def each: () { (Integer) -> void } -> void

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - next()
    # -->
    # alias of `succ`.
    #
    def next: () -> Integer

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - rewind()
    # -->
    # Rewinds the internal position for enumeration.
    #
    # See `Enumerator`#rewind.
    #
    def rewind: () -> void

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - size()
    # -->
    #
    def size: () -> Float

    # <!--
    #   rdoc-file=lib/prime.rb
    #   - succ()
    # -->
    # returns the next pseudo-prime number, and move the internal position forward.
    #
    # `PseudoPrimeGenerator`#succ raises `NotImplementedError`.
    #
    def succ: () -> Integer
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # An implementation of `PseudoPrimeGenerator`.
  #
  # Uses `EratosthenesSieve`.
  #
  class EratosthenesGenerator < PseudoPrimeGenerator
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # An implementation of `PseudoPrimeGenerator` which uses a prime table generated
  # by trial division.
  #
  class TrialDivisionGenerator < PseudoPrimeGenerator
  end

  # <!-- rdoc-file=lib/prime.rb -->
  # Generates all integers which are greater than 2 and are not divisible by
  # either 2 or 3.
  #
  # This is a pseudo-prime generator, suitable on checking primality of an integer
  # by brute force method.
  #
  class Generator23 < PseudoPrimeGenerator
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/https.rb -->
  # The default port for HTTPS URIs is 443, and the scheme is 'https:' rather than
  # 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs; see
  # URI::HTTP.
  #
  class HTTPS < HTTP
    # <!-- rdoc-file=lib/uri/https.rb -->
    # A Default port of 443 for URI::HTTPS
    #
    DEFAULT_PORT: Integer
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/mailto.rb -->
  # RFC6068, the mailto URL scheme.
  #
  class MailTo < Generic
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ldaps.rb -->
  # The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather than
  # 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs; see
  # URI::LDAP.
  #
  class LDAPS < LDAP
    # <!-- rdoc-file=lib/uri/ldaps.rb -->
    # A Default port of 636 for URI::LDAPS
    #
    DEFAULT_PORT: Integer
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/http.rb -->
  # The syntax of HTTP URIs is defined in RFC1738 section 3.3.
  #
  # Note that the Ruby URI library allows HTTP URLs containing usernames and
  # passwords. This is not legal as per the RFC, but used to be supported in
  # Internet Explorer 5 and 6, before the MS04-004 security update. See
  # <URL:http://support.microsoft.com/kb/834489>.
  #
  class HTTP < Generic
    # <!-- rdoc-file=lib/uri/http.rb -->
    # A Default port of 80 for URI::HTTP.
    #
    DEFAULT_PORT: Integer

    # <!-- rdoc-file=lib/uri/http.rb -->
    # An Array of the available components for URI::HTTP.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::HTTP object from components, with syntax checking.
    #
    # The components accepted are userinfo, host, port, path, query, and fragment.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[userinfo,
    # host, port, path, query, fragment]`.
    #
    # Example:
    #
    #     uri = URI::HTTP.build(host: 'www.example.com', path: '/foo/bar')
    #
    #     uri = URI::HTTP.build([nil, "www.example.com", nil, "/path",
    #       "query", 'fragment'])
    #
    # Currently, if passed userinfo components this method generates invalid HTTP
    # URIs as per RFC 1738.
    #
    def self.build: (Array[String | Integer] args) -> URI::HTTP
                  | ({ userinfo: String, host: String, port: Integer, path: String, query: String, fragment: String }) -> URI::HTTP

    # <!--
    #   rdoc-file=lib/uri/http.rb
    #   - request_uri()
    # -->
    # ## Description
    #
    # Returns the full path for an HTTP request, as required by Net::HTTP::Get.
    #
    # If the URI contains a query, the full path is URI#path + '?' + URI#query.
    # Otherwise, the path is simply URI#path.
    #
    # Example:
    #
    #     uri = URI::HTTP.build(path: '/foo/bar', query: 'test=true')
    #     uri.request_uri #  => "/foo/bar?test=true"
    #
    def request_uri: () -> String
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ws.rb -->
  # The syntax of WS URIs is defined in RFC6455 section 3.
  #
  # Note that the Ruby URI library allows WS URLs containing usernames and
  # passwords. This is not legal as per the RFC, but used to be supported in
  # Internet Explorer 5 and 6, before the MS04-004 security update. See
  # <URL:http://support.microsoft.com/kb/834489>.
  #
  class WS < Generic
  end
end

# <!-- rdoc-file=lib/uri.rb -->
# URI is a module providing classes to handle Uniform Resource Identifiers
# ([RFC2396](http://tools.ietf.org/html/rfc2396)).
#
# ## Features
#
# *   Uniform way of handling URIs.
# *   Flexibility to introduce custom URI schemes.
# *   Flexibility to have an alternate URI::Parser (or just different patterns
#     and regexp's).
#
#
# ## Basic example
#
#     require 'uri'
#
#     uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
#     #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>
#
#     uri.scheme    #=> "http"
#     uri.host      #=> "foo.com"
#     uri.path      #=> "/posts"
#     uri.query     #=> "id=30&limit=5"
#     uri.fragment  #=> "time=1305298413"
#
#     uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"
#
# ## Adding custom URIs
#
#     module URI
#       class RSYNC < Generic
#         DEFAULT_PORT = 873
#       end
#       register_scheme 'RSYNC', RSYNC
#     end
#     #=> URI::RSYNC
#
#     URI.scheme_list
#     #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
#     #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
#     #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}
#
#     uri = URI("rsync://rsync.foo.com")
#     #=> #<URI::RSYNC rsync://rsync.foo.com>
#
# ## RFC References
#
# A good place to view an RFC spec is http://www.ietf.org/rfc.html.
#
# Here is a list of all related RFC's:
# *   [RFC822](http://tools.ietf.org/html/rfc822)
# *   [RFC1738](http://tools.ietf.org/html/rfc1738)
# *   [RFC2255](http://tools.ietf.org/html/rfc2255)
# *   [RFC2368](http://tools.ietf.org/html/rfc2368)
# *   [RFC2373](http://tools.ietf.org/html/rfc2373)
# *   [RFC2396](http://tools.ietf.org/html/rfc2396)
# *   [RFC2732](http://tools.ietf.org/html/rfc2732)
# *   [RFC3986](http://tools.ietf.org/html/rfc3986)
#
#
# ## Class tree
#
# *   URI::Generic (in uri/generic.rb)
#     *   URI::File - (in uri/file.rb)
#     *   URI::FTP - (in uri/ftp.rb)
#     *   URI::HTTP - (in uri/http.rb)
#         *   URI::HTTPS - (in uri/https.rb)
#
#     *   URI::LDAP - (in uri/ldap.rb)
#         *   URI::LDAPS - (in uri/ldaps.rb)
#
#     *   URI::MailTo - (in uri/mailto.rb)
#
# *   URI::Parser - (in uri/common.rb)
# *   URI::REGEXP - (in uri/common.rb)
#     *   URI::REGEXP::PATTERN - (in uri/common.rb)
#
# *   URI::Util - (in uri/common.rb)
# *   URI::Error - (in uri/common.rb)
#     *   URI::InvalidURIError - (in uri/common.rb)
#     *   URI::InvalidComponentError - (in uri/common.rb)
#     *   URI::BadURIError - (in uri/common.rb)
#
#
#
# ## Copyright Info
#
# Author
# :   Akira Yamada <akira@ruby-lang.org>
# Documentation
# :   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
#     Vincent Batts <vbatts@hashbangbash.com>
# License
# :   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
#     it and/or modify it under the same term as Ruby.
#
module URI
  # <!-- rdoc-file=lib/uri/generic.rb -->
  # Base class for all URI classes. Implements generic URI syntax as per RFC 2396.
  #
  class Generic
    include URI

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # A Default port of nil for URI::Generic.
    #
    DEFAULT_PORT: nil | Integer

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - default_port()
    # -->
    # Returns default port.
    #
    def self.default_port: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - default_port()
    # -->
    # Returns default port.
    #
    def default_port: () -> (nil | Integer)

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # An Array of the available components for URI::Generic.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component()
    # -->
    # Components of the URI in the order.
    #
    def self.component: () -> Array[Symbol]

    USE_REGISTRY: bool

    def self.use_registry: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - build2(args)
    # -->
    # ## Synopsis
    #
    # See ::new.
    #
    # ## Description
    #
    # At first, tries to create a new URI::Generic instance using
    # URI::Generic::build. But, if exception URI::InvalidComponentError is raised,
    # then it does URI::Escape.escape all URI components and tries again.
    #
    def self.build2: (Array[nil | String | Integer]) -> URI::Generic
                   | ({ scheme: String, userinfo: String, host: String, port: Integer, registry: String?, path: String, opaque: String?, query: String, fragment: String }) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - build(args)
    # -->
    # ## Synopsis
    #
    # See ::new.
    #
    # ## Description
    #
    # Creates a new URI::Generic instance from components of URI::Generic with
    # check.  Components are: scheme, userinfo, host, port, registry, path, opaque,
    # query, and fragment. You can provide arguments either by an Array or a Hash.
    # See ::new for hash keys to use or for order of array items.
    #
    def self.build: (Array[nil | String | Integer]) -> URI::Generic
                  | ({ scheme: String, userinfo: String, host: String, port: Integer, registry: String?, path: String, opaque: String?, query: String, fragment: String }) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - new(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = DEFAULT_PARSER, arg_check = false)
    # -->
    # ## Args
    #
    # `scheme`
    # :   Protocol scheme, i.e. 'http','ftp','mailto' and so on.
    # `userinfo`
    # :   User name and password, i.e. 'sdmitry:bla'.
    # `host`
    # :   Server host name.
    # `port`
    # :   Server port.
    # `registry`
    # :   Registry of naming authorities.
    # `path`
    # :   Path on server.
    # `opaque`
    # :   Opaque part.
    # `query`
    # :   Query data.
    # `fragment`
    # :   Part of the URI after '#' character.
    # `parser`
    # :   Parser for internal use [URI::DEFAULT_PARSER by default].
    # `arg_check`
    # :   Check arguments [false by default].
    #
    #
    # ## Description
    #
    # Creates a new URI::Generic instance from ``generic'' components without check.
    #
    def initialize: (String? scheme, String? userinfo, String? host, (String | Integer)? port, nil registry, String? path, String? opaque, String? query, String? fragment, ?untyped parser, ?boolish arg_check) -> void

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the scheme component of the URI.
    #
    #     URI("http://foo/bar/baz").scheme #=> "http"
    #
    attr_reader scheme: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the host component of the URI.
    #
    #     URI("http://foo/bar/baz").host #=> "foo"
    #
    # It returns nil if no host component exists.
    #
    #     URI("mailto:foo@example.org").host #=> nil
    #
    # The component does not contain the port number.
    #
    #     URI("http://foo:8080/bar/baz").host #=> "foo"
    #
    # Since IPv6 addresses are wrapped with brackets in URIs, this method returns
    # IPv6 addresses wrapped with brackets. This form is not appropriate to pass to
    # socket methods such as TCPSocket.open. If unwrapped host names are required,
    # use the #hostname method.
    #
    #     URI("http://[::1]/bar/baz").host     #=> "[::1]"
    #     URI("http://[::1]/bar/baz").hostname #=> "::1"
    #
    attr_reader host: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the port component of the URI.
    #
    #     URI("http://foo/bar/baz").port      #=> 80
    #     URI("http://foo:8080/bar/baz").port #=> 8080
    #
    attr_reader port: Integer?

    def registry: () -> nil

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the path component of the URI.
    #
    #     URI("http://foo/bar/baz").path #=> "/bar/baz"
    #
    attr_reader path: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the query component of the URI.
    #
    #     URI("http://foo/bar/baz?search=FooBar").query #=> "search=FooBar"
    #
    attr_reader query: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the opaque part of the URI.
    #
    #     URI("mailto:foo@example.org").opaque #=> "foo@example.org"
    #     URI("http://foo/bar/baz").opaque     #=> nil
    #
    # The portion of the path that does not make use of the slash '/'. The path
    # typically refers to an absolute path or an opaque part. (See RFC2396 Section 3
    # and 5.2.)
    #
    attr_reader opaque: String?

    # <!-- rdoc-file=lib/uri/generic.rb -->
    # Returns the fragment component of the URI.
    #
    #     URI("http://foo/bar/baz?search=FooBar#ponies").fragment #=> "ponies"
    #
    attr_reader fragment: String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - parser()
    # -->
    # Returns the parser to be used.
    #
    # Unless a URI::Parser is defined, DEFAULT_PARSER is used.
    #
    def parser: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - replace!(oth)
    # -->
    # Replaces self by other URI object.
    #
    def replace!: (URI::Generic oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component()
    # -->
    # Components of the URI in the order.
    #
    def component: () -> Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_scheme(v)
    # -->
    # Checks the scheme `v` component against the URI::Parser Regexp for :SCHEME.
    #
    def check_scheme: (String? v) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_scheme(v)
    # -->
    # Protected setter for the scheme component `v`.
    #
    # See also URI::Generic.scheme=.
    #
    def set_scheme: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - scheme=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the scheme component `v` (with validation).
    #
    # See also URI::Generic.check_scheme.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.scheme = "https"
    #     uri.to_s  #=> "https://my.example.com"
    #
    def scheme=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_userinfo(user, password = nil)
    # -->
    # Checks the `user` and `password`.
    #
    # If `password` is not provided, then `user` is split, using
    # URI::Generic.split_userinfo, to pull `user` and +password.
    #
    # See also URI::Generic.check_user, URI::Generic.check_password.
    #
    def check_userinfo: (String user, ?String? password) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_user(v)
    # -->
    # Checks the user `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :USERINFO.
    #
    # Can not have a registry or opaque component defined, with a user component
    # defined.
    #
    def check_user: (String v) -> (String | true)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_password(v, user = @user)
    # -->
    # Checks the password `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :USERINFO.
    #
    # Can not have a registry or opaque component defined, with a user component
    # defined.
    #
    def check_password: (String? v, ?String user) -> (String? | true)

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - userinfo=(userinfo)
    # -->
    # Sets userinfo, argument is string like 'name:pass'.
    #
    def userinfo=: (String? userinfo) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - user=(user)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the `user` component (with validation).
    #
    # See also URI::Generic.check_user.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #     uri.user = "sam"
    #     uri.to_s  #=> "http://sam:V3ry_S3nsit1ve@my.example.com"
    #
    def user=: (String? user) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - password=(password)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the `password` component (with validation).
    #
    # See also URI::Generic.check_password.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #     uri.password = "V3ry_S3nsit1ve"
    #     uri.to_s  #=> "http://john:V3ry_S3nsit1ve@my.example.com"
    #
    def password=: (String? password) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_userinfo(user, password = nil)
    # -->
    # Protected setter for the `user` component, and `password` if available (with
    # validation).
    #
    # See also URI::Generic.userinfo=.
    #
    def set_userinfo: (String? user, ?String? password) -> [ String?, String? ]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_user(v)
    # -->
    # Protected setter for the user component `v`.
    #
    # See also URI::Generic.user=.
    #
    def set_user: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_password(v)
    # -->
    # Protected setter for the password component `v`.
    #
    # See also URI::Generic.password=.
    #
    def set_password: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - split_userinfo(ui)
    # -->
    # Returns the userinfo `ui` as `[user, password]` if properly formatted as
    # 'user:password'.
    #
    def split_userinfo: (String ui) -> Array[String | nil]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - escape_userpass(v)
    # -->
    # Escapes 'user:password' `v` based on RFC 1738 section 3.1.
    #
    def escape_userpass: (String v) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - userinfo()
    # -->
    # Returns the userinfo, either as 'user' or 'user:password'.
    #
    def userinfo: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - user()
    # -->
    # Returns the user component.
    #
    def user: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - password()
    # -->
    # Returns the password component.
    #
    def password: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_host(v)
    # -->
    # Checks the host `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :HOST.
    #
    # Can not have a registry or opaque component defined, with a host component
    # defined.
    #
    def check_host: (String? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_host(v)
    # -->
    # Protected setter for the host component `v`.
    #
    # See also URI::Generic.host=.
    #
    def set_host: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - host=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the host component `v` (with validation).
    #
    # See also URI::Generic.check_host.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.host = "foo.com"
    #     uri.to_s  #=> "http://foo.com"
    #
    def host=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hostname()
    # -->
    # Extract the host part of the URI and unwrap brackets for IPv6 addresses.
    #
    # This method is the same as URI::Generic#host except brackets for IPv6 (and
    # future IP) addresses are removed.
    #
    #     uri = URI("http://[::1]/bar")
    #     uri.hostname      #=> "::1"
    #     uri.host          #=> "[::1]"
    #
    def hostname: () -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hostname=(v)
    # -->
    # Sets the host part of the URI as the argument with brackets for IPv6
    # addresses.
    #
    # This method is the same as URI::Generic#host= except the argument can be a
    # bare IPv6 address.
    #
    #     uri = URI("http://foo/bar")
    #     uri.hostname = "::1"
    #     uri.to_s  #=> "http://[::1]/bar"
    #
    # If the argument seems to be an IPv6 address, it is wrapped with brackets.
    #
    def hostname=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_port(v)
    # -->
    # Checks the port `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :PORT.
    #
    # Can not have a registry or opaque component defined, with a port component
    # defined.
    #
    def check_port: ((String | Integer)? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_port(v)
    # -->
    # Protected setter for the port component `v`.
    #
    # See also URI::Generic.port=.
    #
    def set_port: ((String | Integer)? v) -> (String | Integer)?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - port=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the port component `v` (with validation).
    #
    # See also URI::Generic.check_port.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.port = 8080
    #     uri.to_s  #=> "http://my.example.com:8080"
    #
    def port=: ((String | Integer)? v) -> (String | Integer)?

    def check_registry: (String v) -> nil

    def set_registry: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - registry=(v)
    # -->
    #
    def registry=: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_path(v)
    # -->
    # Checks the path `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :ABS_PATH and :REL_PATH.
    #
    # Can not have a opaque component defined, with a path component defined.
    #
    def check_path: (String? v) -> true

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_path(v)
    # -->
    # Protected setter for the path component `v`.
    #
    # See also URI::Generic.path=.
    #
    def set_path: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - path=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the path component `v` (with validation).
    #
    # See also URI::Generic.check_path.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/pub/files")
    #     uri.path = "/faq/"
    #     uri.to_s  #=> "http://my.example.com/faq/"
    #
    def path=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - query=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the query component `v`.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/?id=25")
    #     uri.query = "id=1"
    #     uri.to_s  #=> "http://my.example.com/?id=1"
    #
    def query=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - check_opaque(v)
    # -->
    # Checks the opaque `v` component for RFC2396 compliance and against the
    # URI::Parser Regexp for :OPAQUE.
    #
    # Can not have a host, port, user, or path component defined, with an opaque
    # component defined.
    #
    def check_opaque: (String? v) -> true?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - set_opaque(v)
    # -->
    # Protected setter for the opaque component `v`.
    #
    # See also URI::Generic.opaque=.
    #
    def set_opaque: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - opaque=(v)
    # -->
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the opaque component `v` (with validation).
    #
    # See also URI::Generic.check_opaque.
    #
    def opaque=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - fragment=(v)
    # -->
    # Checks the fragment `v` component against the URI::Parser Regexp for
    # :FRAGMENT.
    #
    # ## Args
    #
    # `v`
    # :   String
    #
    #
    # ## Description
    #
    # Public setter for the fragment component `v` (with validation).
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/?id=25#time=1305212049")
    #     uri.fragment = "time=1305212086"
    #     uri.to_s  #=> "http://my.example.com/?id=25#time=1305212086"
    #
    def fragment=: (String? v) -> String?

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hierarchical?()
    # -->
    # Returns true if URI is hierarchical.
    #
    # ## Description
    #
    # URI has components listed in order of decreasing significance from left to
    # right, see RFC3986 https://tools.ietf.org/html/rfc3986 1.2.3.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com/")
    #     uri.hierarchical?
    #     #=> true
    #     uri = URI.parse("mailto:joe@example.com")
    #     uri.hierarchical?
    #     #=> false
    #
    def hierarchical?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - absolute?()
    # -->
    # Returns true if URI has a scheme (e.g. http:// or https://) specified.
    #
    def absolute?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - relative?()
    # -->
    # Returns true if URI does not have a scheme (e.g. http:// or https://)
    # specified.
    #
    def relative?: () -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - split_path(path)
    # -->
    # Returns an Array of the path split on '/'.
    #
    def split_path: (String path) -> Array[String]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge_path(base, rel)
    # -->
    # Merges a base path `base`, with relative path `rel`, returns a modified base
    # path.
    #
    def merge_path: (String base, String rel) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge!(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Destructive form of #merge.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.merge!("/main.rbx?page=1")
    #     uri.to_s  # => "http://my.example.com/main.rbx?page=1"
    #
    def merge!: (string oth) -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - merge(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Merges two URIs.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.merge("/main.rbx?page=1")
    #     # => "http://my.example.com/main.rbx?page=1"
    #
    def merge: (string oth) -> URI::Generic

    # :stopdoc:
    def route_from_path: (String src, String dst) -> String

    # :stopdoc:
    def route_from0: (String oth) -> Array[URI::Generic]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - route_from(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Calculates relative path from oth to self.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://my.example.com/main.rbx?page=1')
    #     uri.route_from('http://my.example.com')
    #     #=> #<URI::Generic /main.rbx?page=1>
    #
    def route_from: (String oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - route_to(oth)
    # -->
    # ## Args
    #
    # `oth`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Calculates relative path to oth from self.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://my.example.com')
    #     uri.route_to('http://my.example.com/main.rbx?page=1')
    #     #=> #<URI::Generic /main.rbx?page=1>
    #
    def route_to: (String oth) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - normalize()
    # -->
    # Returns normalized URI.
    #
    #     require 'uri'
    #
    #     URI("HTTP://my.EXAMPLE.com").normalize
    #     #=> #<URI::HTTP http://my.example.com/>
    #
    # Normalization here means:
    #
    # *   scheme and host are converted to lowercase,
    # *   an empty path component is set to "/".
    #
    def normalize: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - normalize!()
    # -->
    # Destructive version of #normalize.
    #
    def normalize!: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - to_s()
    # -->
    # Constructs String from URI.
    #
    def to_s: () -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - ==(oth)
    # -->
    # Compares two URIs.
    #
    def ==: (URI::Generic oth) -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - hash()
    # -->
    #
    def hash: () -> Integer

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - eql?(oth)
    # -->
    #
    def eql?: (URI::Generic oth) -> bool

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - component_ary()
    # -->
    # Returns an Array of the components defined from the COMPONENT Array.
    #
    def component_ary: () -> Array[nil | String | Integer]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - select(*components)
    # -->
    # ## Args
    #
    # `components`
    # :   Multiple Symbol arguments defined in URI::HTTP.
    #
    #
    # ## Description
    #
    # Selects specified components from URI.
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
    #     uri.select(:userinfo, :host, :path)
    #     # => ["myuser:mypass", "my.example.com", "/test.rbx"]
    #
    def select: (*Symbol components) -> Array[nil | String | Integer]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - coerce(oth)
    # -->
    # ## Args
    #
    # `v`
    # :   URI or String
    #
    #
    # ## Description
    #
    # Attempts to parse other URI `oth`, returns [parsed_oth, self].
    #
    # ## Usage
    #
    #     require 'uri'
    #
    #     uri = URI.parse("http://my.example.com")
    #     uri.coerce("http://foo.com")
    #     #=> [#<URI::HTTP http://foo.com>, #<URI::HTTP http://my.example.com>]
    #
    def coerce: (URI::Generic | String oth) -> Array[URI::Generic]

    # <!--
    #   rdoc-file=lib/uri/generic.rb
    #   - find_proxy(env=ENV)
    # -->
    # Returns a proxy URI. The proxy URI is obtained from environment variables such
    # as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is
    # returned.
    #
    # If the optional parameter `env` is specified, it is used instead of ENV.
    #
    # Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.) are
    # examined, too.
    #
    # But http_proxy and HTTP_PROXY is treated specially under CGI environment. It's
    # because HTTP_PROXY may be set by Proxy: header. So HTTP_PROXY is not used.
    # http_proxy is not used too if the variable is case insensitive. CGI_HTTP_PROXY
    # can be used instead.
    #
    def find_proxy: (?String env) -> (nil | URI::Generic)

    def self.use_proxy?: (String hostname, String addr, Integer port, String no_proxy) -> bool
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/wss.rb -->
  # The default port for WSS URIs is 443, and the scheme is 'wss:' rather than
  # 'ws:'. Other than that, WSS URIs are identical to WS URIs; see URI::WS.
  #
  class WSS < WS
  end
end

# <!-- rdoc-file=lib/uri.rb -->
# URI is a module providing classes to handle Uniform Resource Identifiers
# ([RFC2396](http://tools.ietf.org/html/rfc2396)).
#
# ## Features
#
# *   Uniform way of handling URIs.
# *   Flexibility to introduce custom URI schemes.
# *   Flexibility to have an alternate URI::Parser (or just different patterns
#     and regexp's).
#
#
# ## Basic example
#
#     require 'uri'
#
#     uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
#     #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>
#
#     uri.scheme    #=> "http"
#     uri.host      #=> "foo.com"
#     uri.path      #=> "/posts"
#     uri.query     #=> "id=30&limit=5"
#     uri.fragment  #=> "time=1305298413"
#
#     uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"
#
# ## Adding custom URIs
#
#     module URI
#       class RSYNC < Generic
#         DEFAULT_PORT = 873
#       end
#       register_scheme 'RSYNC', RSYNC
#     end
#     #=> URI::RSYNC
#
#     URI.scheme_list
#     #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
#     #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
#     #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}
#
#     uri = URI("rsync://rsync.foo.com")
#     #=> #<URI::RSYNC rsync://rsync.foo.com>
#
# ## RFC References
#
# A good place to view an RFC spec is http://www.ietf.org/rfc.html.
#
# Here is a list of all related RFC's:
# *   [RFC822](http://tools.ietf.org/html/rfc822)
# *   [RFC1738](http://tools.ietf.org/html/rfc1738)
# *   [RFC2255](http://tools.ietf.org/html/rfc2255)
# *   [RFC2368](http://tools.ietf.org/html/rfc2368)
# *   [RFC2373](http://tools.ietf.org/html/rfc2373)
# *   [RFC2396](http://tools.ietf.org/html/rfc2396)
# *   [RFC2732](http://tools.ietf.org/html/rfc2732)
# *   [RFC3986](http://tools.ietf.org/html/rfc3986)
#
#
# ## Class tree
#
# *   URI::Generic (in uri/generic.rb)
#     *   URI::File - (in uri/file.rb)
#     *   URI::FTP - (in uri/ftp.rb)
#     *   URI::HTTP - (in uri/http.rb)
#         *   URI::HTTPS - (in uri/https.rb)
#
#     *   URI::LDAP - (in uri/ldap.rb)
#         *   URI::LDAPS - (in uri/ldaps.rb)
#
#     *   URI::MailTo - (in uri/mailto.rb)
#
# *   URI::Parser - (in uri/common.rb)
# *   URI::REGEXP - (in uri/common.rb)
#     *   URI::REGEXP::PATTERN - (in uri/common.rb)
#
# *   URI::Util - (in uri/common.rb)
# *   URI::Error - (in uri/common.rb)
#     *   URI::InvalidURIError - (in uri/common.rb)
#     *   URI::InvalidComponentError - (in uri/common.rb)
#     *   URI::BadURIError - (in uri/common.rb)
#
#
#
# ## Copyright Info
#
# Author
# :   Akira Yamada <akira@ruby-lang.org>
# Documentation
# :   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
#     Vincent Batts <vbatts@hashbangbash.com>
# License
# :   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
#     it and/or modify it under the same term as Ruby.
#
module URI
  include URI::RFC2396_REGEXP

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - decode_www_form(str, enc=Encoding::UTF_8, separator: '&', use__charset_: false, isindex: false)
  # -->
  # Decodes URL-encoded form data from given `str`.
  #
  # This decodes application/x-www-form-urlencoded data and returns an array of
  # key-value arrays.
  #
  # This refers http://url.spec.whatwg.org/#concept-urlencoded-parser, so this
  # supports only &-separator, and doesn't support ;-separator.
  #
  #     ary = URI.decode_www_form("a=1&a=2&b=3")
  #     ary                   #=> [['a', '1'], ['a', '2'], ['b', '3']]
  #     ary.assoc('a').last   #=> '1'
  #     ary.assoc('b').last   #=> '3'
  #     ary.rassoc('a').last  #=> '2'
  #     Hash[ary]             #=> {"a"=>"2", "b"=>"3"}
  #
  # See URI.decode_www_form_component, URI.encode_www_form.
  #
  def self.decode_www_form: (String str, ?encoding enc, ?isindex: boolish, ?use__charset_: boolish, ?separator: String) -> Array[[ String, String ]]

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - decode_www_form_component(str, enc=Encoding::UTF_8)
  # -->
  # Decodes given `str` of URL-encoded form data.
  #
  # This decodes + to SP.
  #
  # See URI.encode_www_form_component, URI.decode_www_form.
  #
  def self.decode_www_form_component: (String str, ?encoding enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - encode_www_form(enum, enc=nil)
  # -->
  # Generates URL-encoded form data from given `enum`.
  #
  # This generates application/x-www-form-urlencoded data defined in HTML5 from
  # given an Enumerable object.
  #
  # This internally uses URI.encode_www_form_component(str).
  #
  # This method doesn't convert the encoding of given items, so convert them
  # before calling this method if you want to send data as other than original
  # encoding or mixed encoding data. (Strings which are encoded in an HTML5 ASCII
  # incompatible encoding are converted to UTF-8.)
  #
  # This method doesn't handle files.  When you send a file, use
  # multipart/form-data.
  #
  # This refers https://url.spec.whatwg.org/#concept-urlencoded-serializer
  #
  #     URI.encode_www_form([["q", "ruby"], ["lang", "en"]])
  #     #=> "q=ruby&lang=en"
  #     URI.encode_www_form("q" => "ruby", "lang" => "en")
  #     #=> "q=ruby&lang=en"
  #     URI.encode_www_form("q" => ["ruby", "perl"], "lang" => "en")
  #     #=> "q=ruby&q=perl&lang=en"
  #     URI.encode_www_form([["q", "ruby"], ["q", "perl"], ["lang", "en"]])
  #     #=> "q=ruby&q=perl&lang=en"
  #
  # See URI.encode_www_form_component, URI.decode_www_form.
  #
  def self.encode_www_form: (Enumerable[[ _ToS, _ToS ]] enum, ?encoding? enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - encode_www_form_component(str, enc=nil)
  # -->
  # Encodes given `str` to URL-encoded form data.
  #
  # This method doesn't convert *, -, ., 0-9, A-Z, _, a-z, but does convert SP
  # (ASCII space) to + and converts others to %XX.
  #
  # If `enc` is given, convert `str` to the encoding before percent encoding.
  #
  # This is an implementation of
  # https://www.w3.org/TR/2013/CR-html5-20130806/forms.html#url-encoded-form-data.
  #
  # See URI.decode_www_form_component, URI.encode_www_form.
  #
  def self.encode_www_form_component: (_ToS str, ?encoding? enc) -> String

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - extract(str, schemes = nil, &block)
  # -->
  # ## Synopsis
  #
  #     URI::extract(str[, schemes][,&blk])
  #
  # ## Args
  #
  # `str`
  # :   String to extract URIs from.
  # `schemes`
  # :   Limit URI matching to specific schemes.
  #
  #
  # ## Description
  #
  # Extracts URIs from a string. If block given, iterates through all matched
  # URIs. Returns nil if block given or array with matches.
  #
  # ## Usage
  #
  #     require "uri"
  #
  #     URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
  #     # => ["http://foo.example.com/bla", "mailto:test@example.com"]
  #
  def self.extract: (String str, ?Array[String] schemes) -> Array[String]
                  | (String str, ?Array[String] schemes) { (String) -> void } -> nil

  def self.get_encoding: (String label) -> Encoding?

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - join(*str)
  # -->
  # ## Synopsis
  #
  #     URI::join(str[, str, ...])
  #
  # ## Args
  #
  # `str`
  # :   String(s) to work with, will be converted to RFC3986 URIs before merging.
  #
  #
  # ## Description
  #
  # Joins URIs.
  #
  # ## Usage
  #
  #     require 'uri'
  #
  #     URI.join("http://example.com/","main.rbx")
  #     # => #<URI::HTTP http://example.com/main.rbx>
  #
  #     URI.join('http://example.com', 'foo')
  #     # => #<URI::HTTP http://example.com/foo>
  #
  #     URI.join('http://example.com', '/foo', '/bar')
  #     # => #<URI::HTTP http://example.com/bar>
  #
  #     URI.join('http://example.com', '/foo', 'bar')
  #     # => #<URI::HTTP http://example.com/bar>
  #
  #     URI.join('http://example.com', '/foo/', 'bar')
  #     # => #<URI::HTTP http://example.com/foo/bar>
  #
  def self.join: (String str, *String strs) -> URI::Generic

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - parse(uri)
  # -->
  # ## Synopsis
  #
  #     URI::parse(uri_str)
  #
  # ## Args
  #
  # `uri_str`
  # :   String with URI.
  #
  #
  # ## Description
  #
  # Creates one of the URI's subclasses instance from the string.
  #
  # ## Raises
  #
  # URI::InvalidURIError
  # :   Raised if URI given is not a correct one.
  #
  #
  # ## Usage
  #
  #     require 'uri'
  #
  #     uri = URI.parse("http://www.ruby-lang.org/")
  #     # => #<URI::HTTP http://www.ruby-lang.org/>
  #     uri.scheme
  #     # => "http"
  #     uri.host
  #     # => "www.ruby-lang.org"
  #
  # It's recommended to first ::escape the provided `uri_str` if there are any
  # invalid URI characters.
  #
  def self.parse: (_ToStr uri) -> (File | FTP | HTTP | HTTPS | LDAP | LDAPS | MailTo | WS | WSS | Generic)

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - regexp(schemes = nil)
  # -->
  # ## Synopsis
  #
  #     URI::regexp([match_schemes])
  #
  # ## Args
  #
  # `match_schemes`
  # :   Array of schemes. If given, resulting regexp matches to URIs whose scheme
  #     is one of the match_schemes.
  #
  #
  # ## Description
  #
  # Returns a Regexp object which matches to URI-like strings. The Regexp object
  # returned by this method includes arbitrary number of capture group
  # (parentheses).  Never rely on its number.
  #
  # ## Usage
  #
  #     require 'uri'
  #
  #     # extract first URI from html_string
  #     html_string.slice(URI.regexp)
  #
  #     # remove ftp URIs
  #     html_string.sub(URI.regexp(['ftp']), '')
  #
  #     # You should not rely on the number of parentheses
  #     html_string.scan(URI.regexp) do |*matches|
  #       p $&
  #     end
  #
  def self.regexp: (?Array[String]? schemes) -> Regexp

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - scheme_list()
  # -->
  # Returns a Hash of the defined schemes.
  #
  def self.scheme_list: () -> Hash[String, Class]

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - for(scheme, *arguments, default: Generic)
  # -->
  # Construct a URI instance, using the scheme to detect the appropriate class
  # from `URI.scheme_list`.
  #
  def self.for: (String scheme, *untyped arguments, ?default: Class) -> (File | FTP | HTTP | HTTPS | LDAP | LDAPS | MailTo | WS | WSS | Generic)

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - split(uri)
  # -->
  # ## Synopsis
  #
  #     URI::split(uri)
  #
  # ## Args
  #
  # `uri`
  # :   String with URI.
  #
  #
  # ## Description
  #
  # Splits the string on following parts and returns array with result:
  #
  # *   Scheme
  # *   Userinfo
  # *   Host
  # *   Port
  # *   Registry
  # *   Path
  # *   Opaque
  # *   Query
  # *   Fragment
  #
  #
  # ## Usage
  #
  #     require 'uri'
  #
  #     URI.split("http://www.ruby-lang.org/")
  #     # => ["http", nil, "www.ruby-lang.org", nil, nil, "/", nil, nil, nil]
  #
  def self.split: (_ToStr uri) -> [ String?, String?, String?, String?, nil, String?, String?, String?, String? ]
end

URI::ABS_PATH: Regexp

URI::ABS_URI: Regexp

URI::ABS_URI_REF: Regexp

# <!-- rdoc-file=lib/uri/common.rb -->
# URI::Parser.new
#
URI::DEFAULT_PARSER: URI::RFC2396_Parser

URI::ESCAPED: Regexp

URI::FRAGMENT: Regexp

URI::HOST: Regexp

URI::OPAQUE: Regexp

URI::PORT: Regexp

URI::QUERY: Regexp

URI::REGISTRY: Regexp

URI::REL_PATH: Regexp

URI::REL_URI: Regexp

URI::REL_URI_REF: Regexp

URI::RFC3986_PARSER: URI::RFC3986_Parser

URI::SCHEME: Regexp

URI::TBLDECWWWCOMP_: Hash[String, String]

URI::TBLENCWWWCOMP_: Hash[String, String]

URI::UNSAFE: Regexp

URI::URI_REF: Regexp

URI::USERINFO: Regexp

URI::VERSION: String

URI::VERSION_CODE: String

URI::WEB_ENCODINGS_: Hash[String, String]

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=lib/uri/common.rb
  #   - URI(uri)
  # -->
  # Returns `uri` converted to an URI object.
  #
  def self?.URI: (URI::Generic | String uri) -> URI::Generic
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
  # Includes URI::REGEXP::PATTERN
  #
  module RFC2396_REGEXP
  end

  # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
  # Class that parses String's into URI's.
  #
  # It contains a Hash set of patterns and Regexp's that match and validate.
  #
  class RFC2396_Parser
    include RFC2396_REGEXP

    # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
    # The Hash of patterns.
    #
    # See also URI::Parser.initialize_pattern.
    #
    attr_reader pattern: Hash[Symbol, String]

    # <!-- rdoc-file=lib/uri/rfc2396_parser.rb -->
    # The Hash of Regexp.
    #
    # See also URI::Parser.initialize_regexp.
    #
    attr_reader regexp: Hash[Symbol, Regexp]

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - new(opts = {})
    # -->
    # ## Synopsis
    #
    #     URI::Parser.new([opts])
    #
    # ## Args
    #
    # The constructor accepts a hash as options for parser. Keys of options are
    # pattern names of URI components and values of options are pattern strings. The
    # constructor generates set of regexps for parsing URIs.
    #
    # You can use the following keys:
    #
    #     * :ESCAPED (URI::PATTERN::ESCAPED in default)
    #     * :UNRESERVED (URI::PATTERN::UNRESERVED in default)
    #     * :DOMLABEL (URI::PATTERN::DOMLABEL in default)
    #     * :TOPLABEL (URI::PATTERN::TOPLABEL in default)
    #     * :HOSTNAME (URI::PATTERN::HOSTNAME in default)
    #
    # ## Examples
    #
    #     p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
    #     u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP http://example.jp/%uABCD>
    #     URI.parse(u.to_s) #=> raises URI::InvalidURIError
    #
    #     s = "http://example.com/ABCD"
    #     u1 = p.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    #     u2 = URI.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    #     u1 == u2 #=> true
    #     u1.eql?(u2) #=> false
    #
    def initialize: (?Hash[Symbol, String] opts) -> void

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - escape( str )
    #   - escape( str, unsafe )
    # -->
    # ## Args
    #
    # `str`
    # :   String to make safe
    # `unsafe`
    # :   Regexp to apply. Defaults to `self.regexp[:UNSAFE]`
    #
    #
    # ## Description
    #
    # Constructs a safe String from `str`, removing unsafe characters, replacing
    # them with codes.
    #
    def escape: (String str, ?Regexp unsafe) -> String

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - extract( str )
    #   - extract( str, schemes )
    #   - extract( str, schemes ) {|item| block }
    # -->
    # ## Args
    #
    # `str`
    # :   String to search
    # `schemes`
    # :   Patterns to apply to `str`
    #
    #
    # ## Description
    #
    # Attempts to parse and merge a set of URIs. If no `block` given, then returns
    # the result, else it calls `block` for each element in result.
    #
    # See also URI::Parser.make_regexp.
    #
    def extract: (String str, ?Array[String] schemes) -> Array[String]
               | (String str, ?Array[String] schemes) { (String) -> untyped } -> nil

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - join(*uris)
    # -->
    # ## Args
    #
    # `uris`
    # :   an Array of Strings
    #
    #
    # ## Description
    #
    # Attempts to parse and merge a set of URIs.
    #
    def join: (*String uris) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - make_regexp(schemes = nil)
    # -->
    # Returns Regexp that is default `self.regexp[:ABS_URI_REF]`, unless `schemes`
    # is provided. Then it is a Regexp.union with `self.pattern[:X_ABS_URI]`.
    #
    def make_regexp: (?Array[String] schemes) -> Regexp

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - parse(uri)
    # -->
    # ## Args
    #
    # `uri`
    # :   String
    #
    #
    # ## Description
    #
    # Parses `uri` and constructs either matching URI scheme object (File, FTP,
    # HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic.
    #
    # ## Usage
    #
    #     p = URI::Parser.new
    #     p.parse("ldap://ldap.example.com/dc=example?user=john")
    #     #=> #<URI::LDAP ldap://ldap.example.com/dc=example?user=john>
    #
    def parse: (String uri) -> URI::Generic

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - split(uri)
    # -->
    # Returns a split URI against `regexp[:ABS_URI]`.
    #
    def split: (String uri) -> [ String?, String?, String?, String?, String?, String?, String?, String?, String? ]

    # <!--
    #   rdoc-file=lib/uri/rfc2396_parser.rb
    #   - unescape( str )
    #   - unescape( str, escaped )
    # -->
    # ## Args
    #
    # `str`
    # :   String to remove escapes from
    # `escaped`
    # :   Regexp to apply. Defaults to `self.regexp[:ESCAPED]`
    #
    #
    # ## Description
    #
    # Removes escapes from `str`.
    #
    def unescape: (String str, ?Regexp escaped) -> String
  end
end

class URI::RFC3986_Parser
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/file.rb -->
  # The "file" URI is defined by RFC8089.
  #
  class File < Generic
    # <!-- rdoc-file=lib/uri/file.rb -->
    # A Default port of nil for URI::File.
    #
    DEFAULT_PORT: Integer?

    # <!-- rdoc-file=lib/uri/file.rb -->
    # An Array of the available components for URI::File.
    #
    COMPONENT: Array[Symbol]

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::File object from components, with syntax checking.
    #
    # The components accepted are `host` and `path`.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[host,
    # path]`.
    #
    # Examples:
    #
    #     require 'uri'
    #
    #     uri1 = URI::File.build(['host.example.com', '/path/file.zip'])
    #     uri1.to_s  # => "file://host.example.com/path/file.zip"
    #
    #     uri2 = URI::File.build({:host => 'host.example.com',
    #       :path => '/ruby/src'})
    #     uri2.to_s  # => "file://host.example.com/ruby/src"
    #
    def self.build: (Array[String] args) -> URI::File
                  | ({ host: String, path: String }) -> URI::File

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_host(v)
    # -->
    # Protected setter for the host component `v`.
    #
    # See also URI::Generic.host=.
    #
    def set_host: (String? v) -> String

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_port(v)
    # -->
    # do nothing
    #
    def set_port: (Integer v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_userinfo(user)
    # -->
    # raise InvalidURIError
    #
    def check_userinfo: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_user(user)
    # -->
    # raise InvalidURIError
    #
    def check_user: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - check_password(user)
    # -->
    # raise InvalidURIError
    #
    def check_password: (String user) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_userinfo(v)
    # -->
    # do nothing
    #
    def set_userinfo: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_user(v)
    # -->
    # do nothing
    #
    def set_user: (String v) -> nil

    # <!--
    #   rdoc-file=lib/uri/file.rb
    #   - set_password(v)
    # -->
    # do nothing
    #
    def set_password: (String v) -> nil
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ldap.rb -->
  # LDAP URI SCHEMA (described in RFC2255).
  #
  class LDAP < Generic
    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # A Default port of 389 for URI::LDAP.
    #
    DEFAULT_PORT: Integer

    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # An Array of the available components for URI::LDAP.
    #
    COMPONENT: Array[Symbol]

    # <!-- rdoc-file=lib/uri/ldap.rb -->
    # Scopes available for the starting point.
    #
    # *   SCOPE_BASE - the Base DN
    # *   SCOPE_ONE  - one level under the Base DN, not including the base DN and
    #     not including any entries under this
    # *   SCOPE_SUB  - subtrees, all entries at all levels
    #
    SCOPE: Array[String]

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - build(args)
    # -->
    # ## Description
    #
    # Creates a new URI::LDAP object from components, with syntax checking.
    #
    # The components accepted are host, port, dn, attributes, scope, filter, and
    # extensions.
    #
    # The components should be provided either as an Array, or as a Hash with keys
    # formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order `[host, port,
    # dn, attributes, scope, filter, extensions]`.
    #
    # Example:
    #
    #     uri = URI::LDAP.build({:host => 'ldap.example.com',
    #       :dn => '/dc=example'})
    #
    #     uri = URI::LDAP.build(["ldap.example.com", nil,
    #       "/dc=example;dc=com", "query", nil, nil, nil])
    #
    def self.build: (Array[nil | String | Integer] args) -> URI::LDAP
                  | ({ host: String, port: Integer?, dn: String, attributes: String?, scope: String?, filter: String?, extensions: String? }) -> URI::LDAP

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - new(*arg)
    # -->
    # ## Description
    #
    # Creates a new URI::LDAP object from generic URI components as per RFC 2396. No
    # LDAP-specific syntax checking is performed.
    #
    # Arguments are `scheme`, `userinfo`, `host`, `port`, `registry`, `path`,
    # `opaque`, `query`, and `fragment`, in that order.
    #
    # Example:
    #
    #     uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil, nil,
    #       "/dc=example;dc=com", nil, "query", nil)
    #
    # See also URI::Generic.new.
    #
    def initialize: (String schema, String? userinfo, String host, Integer? port, String? registry, String? path, String? opaque, String query, String? fragment) -> URI::LDAP

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - parse_dn()
    # -->
    # Private method to cleanup `dn` from using the `path` component attribute.
    #
    def parse_dn: () -> nil

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - parse_query()
    # -->
    # Private method to cleanup `attributes`, `scope`, `filter`, and `extensions`
    # from using the `query` component attribute.
    #
    def parse_query: () -> nil

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - build_path_query()
    # -->
    # Private method to assemble `query` from `attributes`, `scope`, `filter`, and
    # `extensions`.
    #
    def build_path_query: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - dn()
    # -->
    # Returns dn.
    #
    def dn: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_dn(val)
    # -->
    # Private setter for dn `val`.
    #
    def set_dn: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - dn=(val)
    # -->
    # Setter for dn `val`.
    #
    def dn=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - attributes()
    # -->
    # Returns attributes.
    #
    def attributes: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_attributes(val)
    # -->
    # Private setter for attributes `val`.
    #
    def set_attributes: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - attributes=(val)
    # -->
    # Setter for attributes `val`.
    #
    def attributes=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - scope()
    # -->
    # Returns scope.
    #
    def scope: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_scope(val)
    # -->
    # Private setter for scope `val`.
    #
    def set_scope: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - scope=(val)
    # -->
    # Setter for scope `val`.
    #
    def scope=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - filter()
    # -->
    # Returns filter.
    #
    def filter: () -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_filter(val)
    # -->
    # Private setter for filter `val`.
    #
    def set_filter: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - filter=(val)
    # -->
    # Setter for filter `val`.
    #
    def filter=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - extensions()
    # -->
    # Returns extensions.
    #
    def extensions: () -> untyped

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - set_extensions(val)
    # -->
    # Private setter for extensions `val`.
    #
    def set_extensions: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - extensions=(val)
    # -->
    # Setter for extensions `val`.
    #
    def extensions=: (String val) -> String

    # <!--
    #   rdoc-file=lib/uri/ldap.rb
    #   - hierarchical?()
    # -->
    # Checks if URI has a path. For URI::LDAP this will return `false`.
    #
    def hierarchical?: () -> ::FalseClass
  end
end

%a{annotate:rdoc:skip}
module URI
  # <!-- rdoc-file=lib/uri/ftp.rb -->
  # FTP URI syntax is defined by RFC1738 section 3.2.
  #
  # This class will be redesigned because of difference of implementations; the
  # structure of its path. draft-hoffman-ftp-uri-04 is a draft but it is a good
  # summary about the de facto spec.
  # http://tools.ietf.org/html/draft-hoffman-ftp-uri-04
  #
  class FTP < Generic
  end
end

%a{annotate:rdoc:skip}
class IO
  class ConsoleMode
    def echo=: (bool) -> bool
    def raw: (?min: int, ?time: int, ?intr: bool) -> self
    def raw!: (?min: int, ?time: int, ?intr: bool) -> self
  end

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - IO.console      -> #<File:/dev/tty>
  #   - IO.console(sym, *args)
  # -->
  # Returns an File instance opened console.
  #
  # If `sym` is given, it will be sent to the opened console with `args` and the
  # result will be returned instead of the console IO itself.
  #
  # You must require 'io/console' to use this method.
  #
  def self.console: () -> File?
                  | (:close) -> nil
                  | (Symbol sym, *untyped args) -> untyped

  # <!--
  #   rdoc-file=ext/io/console/lib/console/size.rb
  #   - console_size()
  # -->
  #
  def self.console_size: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/lib/console/size.rb
  #   - default_console_size()
  # -->
  # fallback to console window size
  #
  def self.default_console_size: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - beep()
  # -->
  #
  def beep: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - check_winsize_changed()
  # -->
  #
  def check_winsize_changed: () { () -> void } -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - clear_screen()
  # -->
  #
  def clear_screen: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.console_mode       -> mode
  # -->
  # Returns a data represents the current console mode.
  #
  # You must require 'io/console' to use this method.
  #
  def console_mode: () -> IO::ConsoleMode

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.console_mode = mode
  # -->
  # Sets the console mode to `mode`.
  #
  # You must require 'io/console' to use this method.
  #
  def console_mode=: (IO::ConsoleMode mode) -> IO::ConsoleMode

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cooked {|io| }
  # -->
  # Yields `self` within cooked mode.
  #
  #     STDIN.cooked(&:gets)
  #
  # will read and return a line with echo back and line editing.
  #
  # You must require 'io/console' to use this method.
  #
  def cooked: [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.cooked!
  # -->
  # Enables cooked mode.
  #
  # If the terminal mode needs to be back, use io.cooked { ... }.
  #
  # You must require 'io/console' to use this method.
  #
  def cooked!: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor()
  # -->
  #
  def cursor: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor=(p1)
  # -->
  #
  def cursor=: ([ Integer, Integer ]) -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor_down(p1)
  # -->
  #
  def cursor_down: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor_left(p1)
  # -->
  #
  def cursor_left: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor_right(p1)
  # -->
  #
  def cursor_right: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - cursor_up(p1)
  # -->
  #
  def cursor_up: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.echo = flag
  # -->
  # Enables/disables echo back. On some platforms, all combinations of this flags
  # and raw/cooked mode may not be valid.
  #
  # You must require 'io/console' to use this method.
  #
  def echo=: (bool flag) -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.echo?       -> true or false
  # -->
  # Returns `true` if echo back is enabled.
  #
  # You must require 'io/console' to use this method.
  #
  def echo?: () -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - erase_line(p1)
  # -->
  #
  def erase_line: (0 | 1 | 2 | nil) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - erase_screen(p1)
  # -->
  #
  def erase_screen: (0 | 1 | 2 | 3 | nil) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.getch(min: nil, time: nil, intr: nil) -> char
  # -->
  # Reads and returns a character in raw mode.
  #
  # See IO#raw for details on the parameters.
  #
  # You must require 'io/console' to use this method.
  #
  def getch: (?min: int, ?time: int, ?intr: bool) -> String

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.getpass(prompt=nil)       -> string
  # -->
  # Reads and returns a line without echo back. Prints `prompt` unless it is
  # `nil`.
  #
  # The newline character that terminates the read line is removed from the
  # returned string, see String#chomp!.
  #
  # You must require 'io/console' to use this method.
  #
  def getpass: (?String) -> String

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - goto(p1, p2)
  # -->
  #
  def goto: (int, int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - goto_column(p1)
  # -->
  #
  def goto_column: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.iflush
  # -->
  # Flushes input buffer in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def iflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.ioflush
  # -->
  # Flushes input and output buffers in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def ioflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.noecho {|io| }
  # -->
  # Yields `self` with disabling echo back.
  #
  #     STDIN.noecho(&:gets)
  #
  # will read and return a line without echo back.
  #
  # You must require 'io/console' to use this method.
  #
  def noecho: [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.oflush
  # -->
  # Flushes output buffer in kernel.
  #
  # You must require 'io/console' to use this method.
  #
  def oflush: () -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - pressed?(p1)
  # -->
  #
  def pressed?: (Integer | Symbol | String) -> bool

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.raw(min: nil, time: nil, intr: nil) {|io| }
  # -->
  # Yields `self` within raw mode, and returns the result of the block.
  #
  #     STDIN.raw(&:gets)
  #
  # will read and return a line without echo back and line editing.
  #
  # The parameter `min` specifies the minimum number of bytes that should be
  # received when a read operation is performed. (default: 1)
  #
  # The parameter `time` specifies the timeout in *seconds* with a precision of
  # 1/10 of a second. (default: 0)
  #
  # If the parameter `intr` is `true`, enables break, interrupt, quit, and suspend
  # special characters.
  #
  # Refer to the manual page of termios for further details.
  #
  # You must require 'io/console' to use this method.
  #
  def raw: [T] (?min: int, ?time: int, ?intr: bool) { (self) -> T } -> T

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.raw!(min: nil, time: nil, intr: nil) -> io
  # -->
  # Enables raw mode, and returns `io`.
  #
  # If the terminal mode needs to be back, use `io.raw { ... }`.
  #
  # See IO#raw for details on the parameters.
  #
  # You must require 'io/console' to use this method.
  #
  def raw!: (?min: int, ?time: int, ?intr: bool) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - scroll_backward(p1)
  # -->
  #
  def scroll_backward: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - scroll_forward(p1)
  # -->
  #
  def scroll_forward: (int) -> self

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.winsize     -> [rows, columns]
  # -->
  # Returns console size.
  #
  # You must require 'io/console' to use this method.
  #
  def winsize: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/io/console/console.c
  #   - io.winsize = [rows, columns]
  # -->
  # Tries to set console size.  The effect depends on the platform and the running
  # environment.
  #
  # You must require 'io/console' to use this method.
  #
  def winsize=: ([ Integer, Integer ]) -> [ Integer, Integer ]
              | ([ Integer, Integer, Integer, Integer ]) -> [ Integer, Integer, Integer, Integer ]
end

# <!-- rdoc-file=lib/set.rb -->
# This library provides the Set class, which deals with a collection
# of unordered values with no duplicates. It is a hybrid of Array's
# intuitive inter-operation facilities and Hash's fast lookup.
# The method `to_set` is added to Enumerable for convenience.
# Set implements a collection of unordered values with no duplicates.
# This is a hybrid of Array's intuitive inter-operation facilities and
# Hash's fast lookup.
# Set is easy to use with Enumerable objects (implementing `each`).
# Most of the initializer methods and binary operators accept generic
# Enumerable objects besides sets and arrays. An Enumerable object
# can be converted to Set using the `to_set` method.
# Set uses Hash as storage, so you must note the following points:
# *   Equality of elements is determined according to Object#eql? and
#      Object#hash. Use Set#compare_by_identity to make a set compare
#      its elements by their identity.
# *   Set assumes that the identity of each element does not change
#      while it is stored. Modifying an element of a set will render the
#      set to an unreliable state.
# *   When a string is to be stored, a frozen copy of the string is
#      stored instead unless the original string is already frozen.
#
# ## Comparison
# The comparison operators `<`, `>`, `<=`, and `>=` are implemented as
# shorthand for the {proper_,}{subset?,superset?} methods. The `<=>`
# operator reflects this order, or return `nil` for sets that both
# have distinct elements (`{x, y}` vs. `{x, z}` for example).
# ## Example
#     require 'set'
# s1 = Set[1, 2]                        #=> #<Set: {1, 2}>
# s2 = [1, 2].to_set                    #=> #<Set: {1, 2}>
# s1 == s2                              #=> true
# s1.add("foo")                         #=> #<Set: {1, 2, "foo"}>
# s1.merge([2, 6])                      #=> #<Set: {1, 2, "foo", 6}>
# s1.subset?(s2)                        #=> false
# s2.subset?(s1)                        #=> true
#
# ## Contact
# *   Akinori MUSHA <mailto:knu@iDaemons.org> (current maintainer)
#
# ## What's Here
# First, what's elsewhere. Class Set:
# *   Inherits from [class
#     Object](https://docs.ruby-lang.org/en/master/Object.html#class-Object-labe
#     l-What-27s+Here).
# *   Includes [module
#      which provides dozens of additional
#     g/en/master/Enumerable.html#module-Enumerable-label-What-27s+Here),
#      which provides dozens of additional methods.
#
# In particular, class Set does not have many methods of its own
# for fetching or for iterating.
# Instead, it relies on those in Enumerable.
# Here, class Set provides methods that are useful for:
# *   [Creating a Set](#class-Set-label-Methods+for+Creating+a+Set)
# *   [Set Operations](#class-Set-label-Methods+for+Set+Operations)
# *   [Comparing](#class-Set-label-Methods+for+Comparing)
# *   [Querying](#class-Set-label-Methods+for+Querying)
# *   [Assigning](#class-Set-label-Methods+for+Assigning)
# *   [Deleting](#class-Set-label-Methods+for+Deleting)
# *   [Converting](#class-Set-label-Methods+for+Converting)
# *   [Iterating](#class-Set-label-Methods+for+Iterating)
# *   [And more....](#class-Set-label-Other+Methods)
#
# ### Methods for Creating a Set
# *   ::[] -
#  Returns a new set containing the given objects.
# *   ::new -
#      Returns a new set containing either the given objects
#      (if no block given) or the return values from the called block
#      (if a block given).
#
# ### Methods for Set Operations
# *   [|](#method-i-7C) (aliased as #union and #+) -
#      Returns a new set containing all elements from `self`
#      and all elements from a given enumerable (no duplicates).
# *   [&](#method-i-26) (aliased as #intersection) -
#      Returns a new set containing all elements common to `self`
#      and a given enumerable.
# *   [-](#method-i-2D) (aliased as #difference) -
#      Returns a copy of `self` with all elements
#      in a given enumerable removed.
# *   [\^](#method-i-5E) -
#      Returns a new set containing all elements from `self`
#      and a given enumerable except those common to both.
#
# ### Methods for Comparing
# *   [<=>](#method-i-3C-3D-3E) -
#      Returns -1, 0, or 1 as `self` is less than, equal to,
#      or greater than a given object.
# *   [==](#method-i-3D-3D) -
#      Returns whether `self` and a given enumerable are equal,
#      as determined by Object#eql?.
# *   #compare_by_identity? -
#      Returns whether the set considers only identity
#  when comparing elements.
#
# ### Methods for Querying
# *   #length (aliased as #size) -
#  Returns the count of elements.
# *   #empty? -
#  Returns whether the set has no elements.
# *   #include? (aliased as #member? and #===) -
#      Returns whether a given object is an element in the set.
# *   #subset? (aliased as [<=](#method-i-3C-3D)) -
#      Returns whether a given object is a subset of the set.
# *   #proper_subset? (aliased as [<](#method-i-3C)) -
#      Returns whether a given enumerable is a proper subset of the set.
# *   #superset? (aliased as [<=](#method-i-3E-3D)]) -
#      Returns whether a given enumerable is a superset of the set.
# *   #proper_superset? (aliased as [>](#method-i-3E)) -
#      Returns whether a given enumerable is a proper superset of the set.
# *   #disjoint? -
#      Returns `true` if the set and a given enumerable
#      have no common elements, `false` otherwise.
# *   #intersect? -
#      Returns `true` if the set and a given enumerable -
#      have any common elements, `false` otherwise.
# *   #compare_by_identity? -
#      Returns whether the set considers only identity
#  when comparing elements.
#
# ### Methods for Assigning
# *   #add (aliased as #<<) -
#  Adds a given object to the set; returns `self`.
# *   #add? -
#      If the given object is not an element in the set,
#      adds it and returns `self`; otherwise, returns `nil`.
# *   #merge -
#  Adds each given object to the set; returns `self`.
# *   #replace -
#      Replaces the contents of the set with the contents
#      of a given enumerable.
#
# ### Methods for Deleting
# *   #clear -
#  Removes all elements in the set; returns `self`.
# *   #delete -
#  Removes a given object from the set; returns `self`.
# *   #delete? -
#      If the given object is an element in the set,
#      removes it and returns `self`; otherwise, returns `nil`.
# *   #subtract -
#  Removes each given object from the set; returns `self`.
# *   #delete_if - Removes elements specified by a given block.
# *   #select! (aliased as #filter!) -
#      Removes elements not specified by a given block.
# *   #keep_if -
#  Removes elements not specified by a given block.
# *   #reject!
#  Removes elements specified by a given block.
#
# ### Methods for Converting
# *   #classify -
#      Returns a hash that classifies the elements,
#      as determined by the given block.
# *   #collect! (aliased as #map!) -
#      Replaces each element with a block return-value.
# *   #divide -
#      Returns a hash that classifies the elements,
#      as determined by the given block;
#      differs from #classify in that the block may accept
#      either one or two arguments.
# *   #flatten -
#      Returns a new set that is a recursive flattening of `self`.
#      #flatten! -
#      Replaces each nested set in `self` with the elements from that set.
# *   #inspect (aliased as #to_s) -
#  Returns a string displaying the elements.
# *   #join -
#      Returns a string containing all elements, converted to strings
#      as needed, and joined by the given record separator.
# *   #to_a -
#  Returns an array containing all set elements.
# *   #to_set -
#      Returns `self` if given no arguments and no block;
#      with a block given, returns a new set consisting of block
#  return values.
#
# ### Methods for Iterating
# *   #each -
#  Calls the block with each successive element; returns `self`.
#
# ### Other Methods
# *   #reset -
#      Resets the internal state; useful if an object
#      has been modified while an element in the set.
#
class Set[A]
  # <!--
  #   rdoc-file=lib/set.rb
  #   - new(enum = nil) { |o| ... }
  # -->
  # Creates a new set containing the elements of the given enumerable
  # object.
  # If a block is given, the elements of enum are preprocessed by the
  # given block.
  #     Set.new([1, 2])                       #=> #<Set: {1, 2}>
  #     Set.new([1, 2, 1])                    #=> #<Set: {1, 2}>
  #     Set.new([1, 'c', :s])                 #=> #<Set: {1, "c", :s}>
  #     Set.new(1..5)                         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set.new([1, 2, 3]) { |x| x * x }      #=> #<Set: {1, 4, 9}>
  #
  def initialize: (_Each[A]) -> untyped
                | [X] (_Each[X]) { (X) -> A } -> untyped
                | (?nil) -> untyped

  # <!--
  #   rdoc-file=lib/set.rb
  #   - [](*ary)
  # -->
  # Creates a new set containing the given objects.
  #     Set[1, 2]                   # => #<Set: {1, 2}>
  #     Set[1, 2, 1]                # => #<Set: {1, 2}>
  #     Set[1, 'c', :s]             # => #<Set: {1, "c", :s}>
  #
  def self.[]: [X] (*X) -> Set[X]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - &(enum)
  # -->
  # Returns a new set containing elements common to the set and the
  # given enumerable object.
  #     Set[1, 3, 5] & Set[3, 2, 1]             #=> #<Set: {3, 1}>
  #     Set['a', 'b', 'z'] & ['a', 'b', 'c']    #=> #<Set: {"a", "b"}>
  #
  def &: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - intersection(enum)
  # -->
  #
  alias intersection &

  # <!--
  #   rdoc-file=lib/set.rb
  #   - |(enum)
  # -->
  # Returns a new set built by merging the set and the elements of the
  # given enumerable object.
  #     Set[1, 2, 3] | Set[2, 4, 5]         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set[1, 5, 'z'] | (1..6)             #=> #<Set: {1, 5, "z", 2, 3, 4, 6}>
  #
  def |: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - union(enum)
  # -->
  #
  alias union |

  # <!--
  #   rdoc-file=lib/set.rb
  #   - +(enum)
  # -->
  #
  alias + |

  # <!--
  #   rdoc-file=lib/set.rb
  #   - -(enum)
  # -->
  # Returns a new set built by duplicating the set, removing every
  # element that appears in the given enumerable object.
  #     Set[1, 3, 5] - Set[1, 5]                #=> #<Set: {3}>
  #     Set['a', 'b', 'z'] - ['a', 'c']         #=> #<Set: {"b", "z"}>
  #
  def -: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - difference(enum)
  # -->
  #
  alias difference -

  # <!--
  #   rdoc-file=lib/set.rb
  #   - add(o)
  # -->
  # Adds the given object to the set and returns self. Use `merge` to
  # add many elements at once.
  #     Set[1, 2].add(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add(2)                    #=> #<Set: {1, 2}>
  #
  def add: (A) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - <<(o)
  # -->
  #
  alias << add

  # <!--
  #   rdoc-file=lib/set.rb
  #   - add?(o)
  # -->
  # Adds the given object to the set and returns self. If the
  # object is already in the set, returns nil.
  #     Set[1, 2].add?(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add?([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add?(2)                    #=> nil
  #
  def add?: (A) -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - include?(o)
  # -->
  # Returns true if the set contains the given object.
  # Note that `include?` and `member?` do not test member
  # equality using `==` as do other Enumerables.
  # See also Enumerable#include?
  #
  def include?: (A) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - member?(o)
  # -->
  #
  alias member? include?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - ^(enum)
  # -->
  # Returns a new set containing elements exclusive between the set
  # and the given enumerable object. `(set ^ enum)` is equivalent to
  # `((set | enum) - (set & enum))`.
  #     Set[1, 2] ^ Set[2, 3]                   #=> #<Set: {3, 1}>
  #     Set[1, 'b', 'c'] ^ ['b', 'd']           #=> #<Set: {"d", 1, "c"}>
  #
  def ^: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - classify() { |o| ... }
  # -->
  # Classifies the set by the return value of the given block and
  # returns a hash of {value => set of elements} pairs. The block is
  # called once for each element of the set, passing the element as
  # parameter.
  #     require 'set'
  #     files = Set.new(Dir.glob("*.rb"))
  #     hash = files.classify { |f| File.mtime(f).year }
  #     hash       #=> {2000=>#<Set: {"a.rb", "b.rb"}>,
  #                #    2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,
  #                #    2002=>#<Set: {"f.rb"}>}
  #
  # Returns an enumerator if no block is given.
  #
  def classify: [X] () { (A) -> X } -> Hash[X, self]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - clear()
  # -->
  # Removes all elements and returns self.
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.clear                         #=> #<Set: {}>
  #     set                               #=> #<Set: {}>
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - collect!() { |o| ... }
  # -->
  # Replaces the elements with ones returned by `collect()`.
  # Returns an enumerator if no block is given.
  #
  def collect!: () { (A) -> A } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - map!()
  # -->
  #
  alias map! collect!

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete(o)
  # -->
  # Deletes the given object from the set and returns self. Use
  # `subtract` to delete many items at once.
  #
  def delete: (A) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete?(o)
  # -->
  # Deletes the given object from the set and returns self. If the
  # object is not in the set, returns nil.
  #
  def delete?: (A) -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - delete_if() { |o| ... }
  # -->
  # Deletes every element of the set for which block evaluates to
  # true, and returns self. Returns an enumerator if no block is
  # given.
  #
  def delete_if: () { (A) -> untyped } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - reject!(&block)
  # -->
  # Equivalent to Set#delete_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  #
  def reject!: () { (A) -> untyped } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - disjoint?(set)
  # -->
  # Returns true if the set and the given enumerable have
  # no element in common. This method is the opposite of `intersect?`.
  #     Set[1, 2, 3].disjoint? Set[3, 4]   #=> false
  #     Set[1, 2, 3].disjoint? Set[4, 5]   #=> true
  #     Set[1, 2, 3].disjoint? [3, 4]      #=> false
  #     Set[1, 2, 3].disjoint? 4..5        #=> true
  #
  def disjoint?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - divide(&func)
  # -->
  # Divides the set into a set of subsets according to the commonality
  # defined by the given block.
  # If the arity of the block is 2, elements o1 and o2 are in common
  # if block.call(o1, o2) is true. Otherwise, elements o1 and o2 are
  # in common if block.call(o1) == block.call(o2).
  #     require 'set'
  #     numbers = Set[1, 3, 4, 6, 9, 10, 11]
  #     set = numbers.divide { |i,j| (i - j).abs == 1 }
  #     set        #=> #<Set: {#<Set: {1}>,
  #                #           #<Set: {11, 9, 10}>,
  #                #           #<Set: {3, 4}>,
  #                #           #<Set: {6}>}>
  #
  # Returns an enumerator if no block is given.
  #
  def divide: () { (A, A) -> untyped } -> Set[self]
            | () { (A) -> untyped } -> Set[self]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - each(&block)
  # -->
  # Calls the given block once for each element in the set, passing
  # the element as parameter. Returns an enumerator if no block is
  # given.
  #
  def each: () { (A) -> void } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - empty?()
  # -->
  # Returns true if the set contains no elements.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - flatten()
  # -->
  # Returns a new set that is a copy of the set, flattening each
  # containing set recursively.
  #
  def flatten: () -> Set[untyped]

  # <!--
  #   rdoc-file=lib/set.rb
  #   - intersect?(set)
  # -->
  # Returns true if the set and the given enumerable have at least one
  # element in common.
  #     Set[1, 2, 3].intersect? Set[4, 5]   #=> false
  #     Set[1, 2, 3].intersect? Set[3, 4]   #=> true
  #     Set[1, 2, 3].intersect? 4..5        #=> false
  #     Set[1, 2, 3].intersect? [3, 4]      #=> true
  #
  def intersect?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - keep_if() { |o| ... }
  # -->
  # Deletes every element of the set for which block evaluates to
  # false, and returns self. Returns an enumerator if no block is
  # given.
  #
  def keep_if: () { (A) -> untyped } -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - size()
  # -->
  # Returns the number of elements.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=lib/set.rb
  #   - length()
  # -->
  #
  alias length size

  # <!--
  #   rdoc-file=lib/set.rb
  #   - merge(enum)
  # -->
  # Merges the elements of the given enumerable object to the set and
  # returns self.
  #
  def merge: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - subset?(set)
  # -->
  # Returns true if the set is a subset of the given set.
  #
  def subset?: (self) -> bool

  def proper_subst?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - superset?(set)
  # -->
  # Returns true if the set is a superset of the given set.
  #
  def superset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - proper_superset?(set)
  # -->
  # Returns true if the set is a proper superset of the given set.
  #
  def proper_superset?: (self) -> bool

  # <!--
  #   rdoc-file=lib/set.rb
  #   - replace(enum)
  # -->
  # Replaces the contents of the set with the contents of the given
  # enumerable object and returns self.
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.replace([1, 2])               #=> #<Set: {1, 2}>
  #     set                               #=> #<Set: {1, 2}>
  #
  def replace: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - reset()
  # -->
  # Resets the internal state after modification to existing elements
  # and returns self.
  # Elements will be reindexed and deduplicated.
  #
  def reset: () -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - select!(&block)
  # -->
  # Equivalent to Set#keep_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  #
  def select!: () { (A) -> untyped } -> self?

  # <!--
  #   rdoc-file=lib/set.rb
  #   - subtract(enum)
  # -->
  # Deletes every element that appears in the given enumerable object
  # and returns self.
  #
  def subtract: (_Each[A]) -> self

  # <!--
  #   rdoc-file=lib/set.rb
  #   - to_a()
  # -->
  # Converts the set to an array. The order of elements is uncertain.
  #     Set[1, 2].to_a                    #=> [1, 2]
  #     Set[1, 'c', :s].to_a              #=> [1, "c", :s]
  #
  def to_a: () -> Array[A]

  include Enumerable[A]
end

%a{annotate:rdoc:skip}
module Enumerable[unchecked out Elem]
  # <!--
  #   rdoc-file=lib/set.rb
  #   - to_set(klass = Set, *args, &block)
  # -->
  # Makes a set from the enumerable object with given arguments.
  # Needs to `require "set"` to use this method.
  #
  def to_set: () -> Set[Elem]
end

# <!-- rdoc-file=lib/shellwords.rb -->
# ## Manipulates strings like the UNIX Bourne shell
#
# This module manipulates strings according to the word parsing rules of the
# UNIX Bourne shell.
#
# The shellwords() function was originally a port of shellwords.pl, but modified
# to conform to the Shell & Utilities volume of the IEEE Std 1003.1-2008, 2016
# Edition [1].
#
# ### Usage
#
# You can use Shellwords to parse a string into a Bourne shell friendly Array.
#
#     require 'shellwords'
#
#     argv = Shellwords.split('three blind "mice"')
#     argv #=> ["three", "blind", "mice"]
#
# Once you've required Shellwords, you can use the #split alias
# String#shellsplit.
#
#     argv = "see how they run".shellsplit
#     argv #=> ["see", "how", "they", "run"]
#
# They treat quotes as special characters, so an unmatched quote will cause an
# ArgumentError.
#
#     argv = "they all ran after the farmer's wife".shellsplit
#          #=> ArgumentError: Unmatched quote: ...
#
# Shellwords also provides methods that do the opposite. Shellwords.escape, or
# its alias, String#shellescape, escapes shell metacharacters in a string for
# use in a command line.
#
#     filename = "special's.txt"
#
#     system("cat -- #{filename.shellescape}")
#     # runs "cat -- special\\'s.txt"
#
# Note the '--'.  Without it, cat(1) will treat the following argument as a
# command line option if it starts with '-'.  It is guaranteed that
# Shellwords.escape converts a string to a form that a Bourne shell will parse
# back to the original string, but it is the programmer's responsibility to make
# sure that passing an arbitrary argument to a command does no harm.
#
# Shellwords also comes with a core extension for Array, Array#shelljoin.
#
#     dir = "Funny GIFs"
#     argv = %W[ls -lta -- #{dir}]
#     system(argv.shelljoin + " | less")
#     # runs "ls -lta -- Funny\\ GIFs | less"
#
# You can use this method to build a complete command line out of an array of
# arguments.
#
# ### Authors
# *   Wakou Aoyama
# *   Akinori MUSHA <knu@iDaemons.org>
#
#
# ### Contact
# *   Akinori MUSHA <knu@iDaemons.org> (current maintainer)
#
#
# ### Resources
#
# 1: [IEEE Std 1003.1-2008, 2016 Edition, the Shell & Utilities
# volume](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.htm
# l)
#
module Shellwords
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellescape(str)
  # -->
  # Escapes a string so that it can be safely used in a Bourne shell command line.
  #  `str` can be a non-string object that responds to `to_s`.
  #
  # Note that a resulted string should be used unquoted and is not intended for
  # use in double quotes nor in single quotes.
  #
  #     argv = Shellwords.escape("It's better to give than to receive")
  #     argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  # String#shellescape is a shorthand for this function.
  #
  #     argv = "It's better to give than to receive".shellescape
  #     argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  #     # Search files in lib for method definitions
  #     pattern = "^[ \t]*def "
  #     open("| grep -Ern -e #{pattern.shellescape} lib") { |grep|
  #       grep.each_line { |line|
  #         file, lineno, matched_line = line.split(':', 3)
  #         # ...
  #       }
  #     }
  #
  # It is the caller's responsibility to encode the string in the right encoding
  # for the shell environment where this string is used.
  #
  # Multibyte characters are treated as multibyte characters, not as bytes.
  #
  # Returns an empty quoted String if `str` has a length of zero.
  #
  def self?.shellescape: (String str) -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shelljoin(array)
  # -->
  # Builds a command line string from an argument list, `array`.
  #
  # All elements are joined into a single string with fields separated by a space,
  # where each element is escaped for the Bourne shell and stringified using
  # `to_s`.
  #
  #     ary = ["There's", "a", "time", "and", "place", "for", "everything"]
  #     argv = Shellwords.join(ary)
  #     argv #=> "There\\'s a time and place for everything"
  #
  # Array#shelljoin is a shortcut for this function.
  #
  #     ary = ["Don't", "rock", "the", "boat"]
  #     argv = ary.shelljoin
  #     argv #=> "Don\\'t rock the boat"
  #
  # You can also mix non-string objects in the elements as allowed in Array#join.
  #
  #     output = `#{['ps', '-p', $$].shelljoin}`
  #
  def self?.shelljoin: (Array[String] array) -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellsplit(line)
  # -->
  # Splits a string into an array of tokens in the same way the UNIX Bourne shell
  # does.
  #
  #     argv = Shellwords.split('here are "two words"')
  #     argv #=> ["here", "are", "two words"]
  #
  # Note, however, that this is not a command line parser.  Shell metacharacters
  # except for the single and double quotes and backslash are not treated as such.
  #
  #     argv = Shellwords.split('ruby my_prog.rb | less')
  #     argv #=> ["ruby", "my_prog.rb", "|", "less"]
  #
  # String#shellsplit is a shortcut for this function.
  #
  #     argv = 'here are "two words"'.shellsplit
  #     argv #=> ["here", "are", "two words"]
  #
  def self?.shellsplit: (String line) -> Array[String]

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - escape(str)
  # -->
  #
  alias self.escape self.shellescape

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - join(array)
  # -->
  #
  alias self.join self.shelljoin

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellwords(line)
  # -->
  #
  alias self.shellwords self.shellsplit

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - split(line)
  # -->
  #
  alias self.split self.shellsplit

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - shellwords(line)
  # -->
  #
  alias shellwords shellsplit
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem]
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - array.shelljoin => string
  # -->
  # Builds a command line string from an argument list `array` joining all
  # elements escaped for the Bourne shell and separated by a space.
  #
  # See Shellwords.shelljoin for details.
  #
  def shelljoin: () -> String
end

%a{annotate:rdoc:skip}
class String
  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - str.shellescape => string
  # -->
  # Escapes `str` so that it can be safely used in a Bourne shell command line.
  #
  # See Shellwords.shellescape for details.
  #
  def shellescape: () -> String

  # <!--
  #   rdoc-file=lib/shellwords.rb
  #   - str.shellsplit => array
  # -->
  # Splits `str` into an array of tokens in the same way the UNIX Bourne shell
  # does.
  #
  # See Shellwords.shellsplit for details.
  #
  def shellsplit: () -> Array[String]
end

# <!-- rdoc-file=lib/singleton.rb -->
# The Singleton module implements the Singleton pattern.
#
# ## Usage
#
# To use Singleton, include the module in your class.
#
#     class Klass
#        include Singleton
#        # ...
#     end
#
# This ensures that only one instance of Klass can be created.
#
#     a,b = Klass.instance, Klass.instance
#
#     a == b
#     # => true
#
#     Klass.new
#     # => NoMethodError - new is private ...
#
# The instance is created at upon the first call of Klass.instance().
#
#     class OtherKlass
#       include Singleton
#       # ...
#     end
#
#     ObjectSpace.each_object(OtherKlass){}
#     # => 0
#
#     OtherKlass.instance
#     ObjectSpace.each_object(OtherKlass){}
#     # => 1
#
# This behavior is preserved under inheritance and cloning.
#
# ## Implementation
#
# This above is achieved by:
#
# *   Making Klass.new and Klass.allocate private.
#
# *   Overriding Klass.inherited(sub_klass) and Klass.clone() to ensure that the
#     Singleton properties are kept when inherited and cloned.
#
# *   Providing the Klass.instance() method that returns the same object each
#     time it is called.
#
# *   Overriding Klass._load(str) to call Klass.instance().
#
# *   Overriding Klass#clone and Klass#dup to raise TypeErrors to prevent
#     cloning or duping.
#
#
# ## Singleton and Marshal
#
# By default Singleton's #_dump(depth) returns the empty string. Marshalling by
# default will strip state information, e.g. instance variables from the
# instance. Classes using Singleton can provide custom _load(str) and
# _dump(depth) methods to retain some of the previous state of the instance.
#
#     require 'singleton'
#
#     class Example
#       include Singleton
#       attr_accessor :keep, :strip
#       def _dump(depth)
#         # this strips the @strip information from the instance
#         Marshal.dump(@keep, depth)
#       end
#
#       def self._load(str)
#         instance.keep = Marshal.load(str)
#         instance
#       end
#     end
#
#     a = Example.instance
#     a.keep = "keep this"
#     a.strip = "get rid of this"
#
#     stored_state = Marshal.dump(a)
#
#     a.keep = nil
#     a.strip = nil
#     b = Marshal.load(stored_state)
#     p a == b  #  => true
#     p a.keep  #  => "keep this"
#     p a.strip #  => nil
#
module Singleton
  def self.__init__: (Class klass) -> Class

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - instance()
  # -->
  # Returns the singleton instance.
  #
  def self.instance: () -> instance

  public

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - _dump(depth = -1)
  # -->
  # By default, do not retain any state when marshalling.
  #
  def _dump: (?Integer depth) -> String

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - clone()
  # -->
  # Raises a TypeError to prevent cloning.
  #
  def clone: () -> bot

  # <!--
  #   rdoc-file=lib/singleton.rb
  #   - dup()
  # -->
  # Raises a TypeError to prevent duping.
  #
  def dup: () -> bot
end

Singleton::VERSION: String

# <!-- rdoc-file=ext/socket/tcpsocket.c -->
# TCPSocket represents a TCP/IP client socket.
#
# A simple client may look like:
#
#     require 'socket'
#
#     s = TCPSocket.new 'localhost', 2000
#
#     while line = s.gets # Read lines from socket
#       puts line         # and print them
#     end
#
#     s.close             # close socket when done
#
class TCPSocket < IPSocket
  # <!--
  #   rdoc-file=ext/socket/tcpsocket.c
  #   - TCPSocket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]
  # -->
  # Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   The 3rd element of the result is the address family of the first address.
  #     The address families of the rest of the addresses are not returned.
  # *   gethostbyname() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  #
  # This method lookups host information by *hostname*.
  #
  #     TCPSocket.gethostbyname("localhost")
  #     #=> ["localhost", ["hal"], 2, "127.0.0.1"]
  #
  def self.gethostbyname: (String host) -> [ String, Array[String], Integer, String ]

  private

  # <!--
  #   rdoc-file=lib/resolv-replace.rb
  #   - new(host, serv, *rest)
  # -->
  #
  def initialize: (String remote_host, Integer remote_port, ?String local_host, ?Integer local_port) -> untyped
end

# <!-- rdoc-file=ext/socket/socket.c -->
# Class `Socket` provides access to the underlying operating system socket
# implementations.  It can be used to provide more operating system specific
# functionality than the protocol-specific socket classes.
#
# The constants defined under Socket::Constants are also defined under Socket.
# For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET.
# See Socket::Constants for the list of constants.
#
# ### What's a socket?
#
# Sockets are endpoints of a bidirectional communication channel. Sockets can
# communicate within a process, between processes on the same machine or between
# different machines.  There are many types of socket: TCPSocket, UDPSocket or
# UNIXSocket for example.
#
# Sockets have their own vocabulary:
#
# **domain:** The family of protocols:
# *   Socket::PF_INET
# *   Socket::PF_INET6
# *   Socket::PF_UNIX
# *   etc.
#
#
# **type:** The type of communications between the two endpoints, typically
# *   Socket::SOCK_STREAM
# *   Socket::SOCK_DGRAM.
#
#
# **protocol:** Typically *zero*. This may be used to identify a variant of a
# protocol.
#
# **hostname:** The identifier of a network interface:
# *   a string (hostname, IPv4 or IPv6 address or `broadcast` which specifies a
#     broadcast address)
# *   a zero-length string which specifies INADDR_ANY
# *   an integer (interpreted as binary address in host byte order).
#
#
# ### Quick start
#
# Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
# of sockets comparatively to the equivalent C programming interface.
#
# Let's create an internet socket using the IPv4 protocol in a C-like manner:
#
#     require 'socket'
#
#     s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
#     s.connect Socket.pack_sockaddr_in(80, 'example.com')
#
# You could also use the TCPSocket class:
#
#     s = TCPSocket.new 'example.com', 80
#
# A simple server might look like this:
#
#     require 'socket'
#
#     server = TCPServer.new 2000 # Server bound to port 2000
#
#     loop do
#       client = server.accept    # Wait for a client to connect
#       client.puts "Hello !"
#       client.puts "Time is #{Time.now}"
#       client.close
#     end
#
# A simple client may look like this:
#
#     require 'socket'
#
#     s = TCPSocket.new 'localhost', 2000
#
#     while line = s.gets # Read lines from socket
#       puts line         # and print them
#     end
#
#     s.close             # close socket when done
#
# ### Exception Handling
#
# Ruby's Socket implementation raises exceptions based on the error generated by
# the system dependent implementation.  This is why the methods are documented
# in a way that isolate Unix-based system exceptions from Windows based
# exceptions. If more information on a particular exception is needed, please
# refer to the Unix manual pages or the Windows WinSock reference.
#
# ### Convenience methods
#
# Although the general way to create socket is Socket.new, there are several
# methods of socket creation for most cases.
#
# TCP client socket
# :   Socket.tcp, TCPSocket.open
# TCP server socket
# :   Socket.tcp_server_loop, TCPServer.open
# UNIX client socket
# :   Socket.unix, UNIXSocket.open
# UNIX server socket
# :   Socket.unix_server_loop, UNIXServer.open
#
#
# ### Documentation by
#
# *   Zach Dennis
# *   Sam Roberts
# *   *Programming Ruby* from The Pragmatic Bookshelf.
#
#
# Much material in this documentation is taken with permission from *Programming
# Ruby* from The Pragmatic Bookshelf.
#
class Socket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - accept_loop(*sockets) { |socket, client_addrinfo| ... }
  # -->
  # yield socket and client address for each a connection accepted via given
  # sockets.
  #
  # The arguments are a list of sockets. The individual argument should be a
  # socket or an array of sockets.
  #
  # This method yields the block sequentially. It means that the next connection
  # is not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  def self.accept_loop: (*_ToIO sockets) { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) => array
  # -->
  # Obtains address information for *nodename*:*servname*.
  #
  # Note that Addrinfo.getaddrinfo provides the same functionality in an object
  # oriented style.
  #
  # *family* should be an address family such as: :INET, :INET6, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the family, and defaults to 0 for
  # the family.
  #
  # *flags* should be bitwise OR of Socket::AI_* constants.
  #
  #     Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
  #     #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #
  #     Socket.getaddrinfo("localhost", nil)
  #     #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
  #
  # *reverse_lookup* directs the form of the third element, and has to be one of
  # below.  If *reverse_lookup* is omitted, the default value is `nil`.
  #
  #     +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
  #     +false+, +:numeric+:  hostname is the same as numeric address.
  #     +nil+:              obey to the current +do_not_reverse_lookup+ flag.
  #
  # If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
  #
  def self.getaddrinfo: (String peer, String | Integer | nil protocol, ?Integer | Symbol | nil family, ?Integer | Symbol | nil socktype, ?Integer | Symbol | nil protocol, ?Integer | nil flags) -> [ String, Integer, String, String, Integer, Integer, Integer ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostbyaddr(address_string [, address_family]) => hostent
  # -->
  # Use Addrinfo#getnameinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyaddr() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  #
  # This method obtains the host information for *address*.
  #
  #     p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
  #     #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]
  #
  #     p Socket.gethostbyaddr([127,0,0,1].pack("CCCC"))
  #     ["localhost", [], 2, "\x7F\x00\x00\x01"]
  #     p Socket.gethostbyaddr(([0]*15+[1]).pack("C"*16))
  #     #=> ["localhost", ["ip6-localhost", "ip6-loopback"], 10,
  #          "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"]
  #
  def self.gethostbyaddr: (String ip) -> [ String, Array[String], Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]
  # -->
  # Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   The 3rd element of the result is the address family of the first address.
  #     The address families of the rest of the addresses are not returned.
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyname() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  #
  # This method obtains the host information for *hostname*.
  #
  #     p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]
  #
  def self.gethostbyname: (String name) -> [ String, Array[String], Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.gethostname => hostname
  # -->
  # Returns the hostname.
  #
  #     p Socket.gethostname #=> "hal"
  #
  # Note that it is not guaranteed to be able to convert to IP address using
  # gethostbyname, getaddrinfo, etc. If you need local IP address, use
  # Socket.ip_address_list.
  #
  def self.gethostname: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - Socket.getifaddrs => [ifaddr1, ...]
  # -->
  # Returns an array of interface addresses. An element of the array is an
  # instance of Socket::Ifaddr.
  #
  # This method can be used to find multicast-enabled interfaces:
  #
  #     pp Socket.getifaddrs.reject {|ifaddr|
  #       !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
  #     }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
  #     #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
  #     #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]
  #
  # Example result on GNU/Linux:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
  #     #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]
  #
  # Example result on FreeBSD:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
  #     #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]
  #
  def self.getifaddrs: () -> Array[Socket::Ifaddr]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getnameinfo(sockaddr [, flags]) => [hostname, servicename]
  # -->
  # Obtains name information for *sockaddr*.
  #
  # *sockaddr* should be one of follows.
  # *   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
  # *   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
  # *   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]
  #
  #
  # *flags* should be bitwise OR of Socket::NI_* constants.
  #
  # Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.
  #
  #     Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]
  #
  # If Addrinfo object is preferred, use Addrinfo#getnameinfo.
  #
  def self.getnameinfo: ([ String, Integer, String ]) -> Array[String]
                      | ([ String, Integer, String, String ]) -> Array[String]
                      | (String sockaddr) -> Array[String]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getservbyname(service_name)                => port_number
  #   - Socket.getservbyname(service_name, protocol_name) => port_number
  # -->
  # Obtains the port number for *service_name*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyname("smtp")          #=> 25
  #     Socket.getservbyname("shell")         #=> 514
  #     Socket.getservbyname("syslog", "udp") #=> 514
  #
  def self.getservbyname: (String service_proto) -> Integer
                        | (String service_proto, String layer4_proto) -> Integer

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.getservbyport(port [, protocol_name]) => service
  # -->
  # Obtains the port number for *port*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyport(80)         #=> "www"
  #     Socket.getservbyport(514, "tcp") #=> "shell"
  #     Socket.getservbyport(514, "udp") #=> "syslog"
  #
  def self.getservbyport: (Integer service_port) -> String
                        | (Integer service_port, String layer4_proto) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.ip_address_list => array
  # -->
  # Returns local IP addresses as an array.
  #
  # The array contains Addrinfo objects.
  #
  #     pp Socket.ip_address_list
  #     #=> [#<Addrinfo: 127.0.0.1>,
  #          #<Addrinfo: 192.168.0.128>,
  #          #<Addrinfo: ::1>,
  #          ...]
  #
  def self.ip_address_list: () -> Array[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_in(port, host)      => sockaddr
  #   - Socket.pack_sockaddr_in(port, host) => sockaddr
  # -->
  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  def self.pack_sockaddr_in: (Integer port, String ip) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_un(path)      => sockaddr
  #   - Socket.pack_sockaddr_un(path) => sockaddr
  # -->
  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  def self.pack_sockaddr_un: (String sockpath) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.pair(domain, type, protocol)       => [socket1, socket2]
  #   - Socket.socketpair(domain, type, protocol) => [socket1, socket2]
  # -->
  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  def self.pair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_in(port, host)      => sockaddr
  #   - Socket.pack_sockaddr_in(port, host) => sockaddr
  # -->
  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  def self.sockaddr_in: (Integer port, String ip) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.sockaddr_un(path)      => sockaddr
  #   - Socket.pack_sockaddr_un(path) => sockaddr
  # -->
  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  def self.sockaddr_un: (String sockpath) -> String

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.pair(domain, type, protocol)       => [socket1, socket2]
  #   - Socket.socketpair(domain, type, protocol) => [socket1, socket2]
  # -->
  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  def self.socketpair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }
  #   - Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])
  # -->
  # creates a new socket object connected to host:port using TCP/IP.
  #
  # If local_host:local_port is given, the socket is bound to it.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :connect_timeout
  # :   specify the timeout in seconds.
  # :resolv_timeout
  # :   specify the name resolution timeout in seconds.
  #
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     Socket.tcp("www.ruby-lang.org", 80) {|sock|
  #       sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       sock.close_write
  #       puts sock.read
  #     }
  #
  def self.tcp: (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Numeric, ?connect_timeout: Numeric) -> instance
              | (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Numeric, ?connect_timeout: Numeric) { (instance) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcp_server_loop(host=nil, port) { |socket, client_addrinfo| ... }
  # -->
  # creates a TCP/IP server on *port* and calls the block for each connection
  # accepted. The block is called with a socket and a client_address as an
  # Addrinfo object.
  #
  # If *host* is specified, it is used with *port* to determine the server
  # addresses.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it explicitly.
  #
  # This method calls the block sequentially. It means that the next connection is
  # not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  # Note that Addrinfo.getaddrinfo is used to determine the server socket
  # addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
  # IPv6 address for example, all of them are used. Socket.tcp_server_loop
  # succeeds if one socket can be used at least.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  #     # Threaded echo server
  #     # It services multiple clients at a time.
  #     # Note that it may accept connections too much.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       Thread.new {
  #         begin
  #           IO.copy_stream(sock, sock)
  #         ensure
  #           sock.close
  #         end
  #       }
  #     }
  #
  def self.tcp_server_loop: (?String host, Integer port) { (instance, Addrinfo) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcp_server_sockets(host=nil, port) { |sockets| ... }
  # -->
  # creates TCP/IP server sockets for *host* and *port*. *host* is optional.
  #
  # If no block given, it returns an array of listening sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If *port* is 0, actual port number is chosen dynamically. However all sockets
  # in the result has same port number.
  #
  #     # tcp_server_sockets returns two sockets.
  #     sockets = Socket.tcp_server_sockets(1296)
  #     p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #
  #     # The sockets contains IPv6 and IPv4 sockets.
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:1296 TCP>
  #     #   #<Addrinfo: 0.0.0.0:1296 TCP>
  #
  #     # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
  #     sockets = Socket.tcp_server_sockets(0)
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:53114 TCP>
  #     #   #<Addrinfo: 0.0.0.0:53114 TCP>
  #
  #     # The block is called with the sockets.
  #     Socket.tcp_server_sockets(0) {|sockets|
  #       p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #     }
  #
  def self.tcp_server_sockets: (?String host, Integer port) -> Array[TCPServer]
                             | (?String host, Integer port) { (Array[TCPServer]) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_loop(port) {|msg, msg_src| ... }
  #   - Socket.udp_server_loop(host, port) {|msg, msg_src| ... }
  # -->
  # creates a UDP/IP server on *port* and calls the block for each message
  # arrived. The block is called with the message and its source information.
  #
  # This method allocates sockets internally using *port*. If *host* is specified,
  # it is used conjunction with *port* to determine the server addresses.
  #
  # The *msg* is a string.
  #
  # The *msg_src* is a Socket::UDPSource object. It is used for reply.
  #
  #     # UDP/IP echo server.
  #     Socket.udp_server_loop(9261) {|msg, msg_src|
  #       msg_src.reply msg
  #     }
  #
  def self.udp_server_loop: (?String host, Integer port) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }
  # -->
  # Run UDP/IP server loop on the given sockets.
  #
  # The return value of Socket.udp_server_sockets is appropriate for the argument.
  #
  # It calls the block for each message received.
  #
  def self.udp_server_loop_on: (UDPSocket sockets) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_recv(sockets) {|msg, msg_src| ... }
  # -->
  # Receive UDP/IP packets from the given *sockets*. For each packet received, the
  # block is called.
  #
  # The block receives *msg* and *msg_src*. *msg* is a string which is the payload
  # of the received packet. *msg_src* is a Socket::UDPSource object which is used
  # for reply.
  #
  # Socket.udp_server_loop can be implemented using this method as follows.
  #
  #     udp_server_sockets(host, port) {|sockets|
  #       loop {
  #         readable, _, _ = IO.select(sockets)
  #         udp_server_recv(readable) {|msg, msg_src| ... }
  #       }
  #     }
  #
  def self.udp_server_recv: (Array[UDPSocket] sockets) { (String, Socket::UDPSource) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - Socket.udp_server_sockets([host, ] port)
  # -->
  # Creates UDP/IP sockets for a UDP server.
  #
  # If no block given, it returns an array of sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The sockets are closed when this method returns.
  #
  # If *port* is zero, some port is chosen. But the chosen port is used for the
  # all sockets.
  #
  #     # UDP/IP echo server
  #     Socket.udp_server_sockets(0) {|sockets|
  #       p sockets.first.local_address.ip_port     #=> 32963
  #       Socket.udp_server_loop_on(sockets) {|msg, msg_src|
  #         msg_src.reply msg
  #       }
  #     }
  #
  def self.udp_server_sockets: (?String host, Integer port) { (UDPSocket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix(path) { |socket| ... }
  # -->
  # creates a new socket connected to path using UNIX socket socket.
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     # talk to /tmp/sock socket.
  #     Socket.unix("/tmp/sock") {|sock|
  #       t = Thread.new { IO.copy_stream(sock, STDOUT) }
  #       IO.copy_stream(STDIN, sock)
  #       t.join
  #     }
  #
  def self.unix: (String path) -> UNIXSocket
               | (String path) { (UNIXSocket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix_server_loop(path) { |socket, client_addrinfo| ... }
  # -->
  # creates a UNIX socket server on *path*. It calls the block for each socket
  # accepted.
  #
  # If *host* is specified, it is used with *port* to determine the server ports.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it.
  #
  # This method deletes the socket file pointed by *path* at first if the file is
  # a socket file and it is owned by the user of the application. This is safe
  # only if the directory of *path* is not changed by a malicious user. So don't
  # use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
  # /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  def self.unix_server_loop: (String path) { (UNIXSocket, Addrinfo) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unix_server_socket(path) { |s| ... }
  # -->
  # creates a UNIX server socket on *path*
  #
  # If no block given, it returns a listening socket.
  #
  # If a block is given, it is called with the socket and the block value is
  # returned. When the block exits, the socket is closed and the socket file is
  # removed.
  #
  #     socket = Socket.unix_server_socket("/tmp/s")
  #     p socket                  #=> #<Socket:fd 3>
  #     p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>
  #
  #     Socket.unix_server_socket("/tmp/sock") {|s|
  #       p s                     #=> #<Socket:fd 3>
  #       p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
  #     }
  #
  def self.unix_server_socket: (String path) -> Socket
                             | (String path) { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.unpack_sockaddr_in(sockaddr) => [port, ip_address]
  # -->
  # Unpacks *sockaddr* into port and ip_address.
  #
  # *sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.
  #
  #     sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
  #     p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]
  #
  def self.unpack_sockaddr_in: (String | Addrinfo sockaddr) -> [ Integer, String ]

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.unpack_sockaddr_un(sockaddr) => path
  # -->
  # Unpacks *sockaddr* into path.
  #
  # *sockaddr* should be a string or an addrinfo for AF_UNIX.
  #
  #     sockaddr = Socket.sockaddr_un("/tmp/sock")
  #     p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"
  #
  def self.unpack_sockaddr_un: (String path) -> String

  public

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.accept => [client_socket, client_addrinfo]
  # -->
  # Accepts a next connection. Returns a new Socket object and Addrinfo object.
  #
  #     serv = Socket.new(:INET, :STREAM, 0)
  #     serv.listen(5)
  #     c = Socket.new(:INET, :STREAM, 0)
  #     c.connect(serv.connect_address)
  #     p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]
  #
  def accept: () -> [ Socket, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.accept_nonblock([options]) => [client_socket, client_addrinfo]
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an array containing the accepted socket
  # for the incoming connection, *client_socket*, and an Addrinfo,
  # *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     begin # emulate blocking accept
  #       client_socket, client_addrinfo = socket.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([socket])
  #       retry
  #     end
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *accept_nonblock* fails.
  #
  # Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
  # including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> ([ Socket, Addrinfo ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.bind(local_sockaddr) => 0
  # -->
  # Binds to the given local address.
  #
  # ### Parameter
  # *   `local_sockaddr` - the `struct` sockaddr contained in a string or an
  #     Addrinfo object
  #
  #
  # ### Example
  #     require 'socket'
  #
  #     # use Addrinfo
  #     socket = Socket.new(:INET, :STREAM, 0)
  #     socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
  #     p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>
  #
  #     # use struct sockaddr
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *bind* fails:
  # *   Errno::EACCES - the specified *sockaddr* is protected and the current user
  #     does not have permission to bind to it
  # *   Errno::EADDRINUSE - the specified *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the family of the calling `socket`
  # *   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
  # *   Errno::EFAULT - the *sockaddr* argument cannot be accessed
  # *   Errno::EINVAL - the `socket` is already bound to an address, and the
  #     protocol does not support binding to the new *sockaddr* or the `socket`
  #     has been shut down.
  # *   Errno::EINVAL - the address length is not a valid length for the address
  #     family
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
  #     binding to an address
  #
  #
  # On unix-based based systems if the address family of the calling `socket` is
  # Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
  # fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
  # *   Errno::EISDIR - same as Errno::EDESTADDRREQ
  # *   Errno::EIO - an i/o error occurred
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  # *   Errno::EROFS - the name would reside on a read only filesystem
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *bind* fails:
  # *   Errno::ENETDOWN-- the network is down
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
  #     this computer
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space addressed
  # *   Errno::EINVAL - the `socket` is already bound to an address
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  #
  #
  # ### See
  # *   bind manual pages on unix-based systems
  # *   bind function in Microsoft's Winsock functions reference
  #
  def bind: (String | Addrinfo local_sockaddr) -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.connect(remote_sockaddr) => 0
  # -->
  # Requests a connection to be made on the given `remote_sockaddr`. Returns 0 if
  # successful, otherwise an exception is raised.
  #
  # ### Parameter
  # *   `remote_sockaddr` - the `struct` sockaddr contained in a string or
  #     Addrinfo object
  #
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
  #     socket.connect( sockaddr )
  #     socket.write( "GET / HTTP/1.0\r\n\r\n" )
  #     results = socket.read
  #
  # ### Unix-based Exceptions
  # On unix-based systems the following system exceptions may be raised if the
  # call to *connect* fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EADDRINUSE - the *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the address family of the specified `socket`
  # *   Errno::EALREADY - a connection is already in progress for the specified
  #     socket
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::ECONNRESET - the remote host reset the connection request
  # *   Errno::EFAULT - the *sockaddr* cannot be accessed
  # *   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
  #     because the host is down or a remote router cannot reach it)
  # *   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
  #     connection cannot be immediately established; the connection will be
  #     established asynchronously
  # *   Errno::EINTR - the attempt to establish the connection was interrupted by
  #     delivery of a signal that was caught; the connection will be established
  #     asynchronously
  # *   Errno::EISCONN - the specified `socket` is already connected
  # *   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
  #     length for the address family or there is an invalid family in *sockaddr*
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENETDOWN - the local interface used to reach the destination is
  #     down
  # *   Errno::ENETUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
  #     connected
  # *   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
  #     bound to the specified peer address
  # *   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
  #     was made.
  #
  #
  # On unix-based systems if the address family of the calling `socket` is AF_UNIX
  # the follow exceptions may be raised if the call to *connect* fails:
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     file system
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *connect* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EINTR - the socket was cancelled
  # *   Errno::EINPROGRESS - a blocking socket is in progress or the service
  #     provider is still processing a callback function. Or a nonblocking connect
  #     call is in progress on the `socket`.
  # *   Errno::EALREADY - see Errno::EINVAL
  # *   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
  #     ADDR_ANY TODO check ADDRANY TO INADDR_ANY
  # *   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
  #     with with this `socket`
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space address
  # *   Errno::EINVAL - the `socket` is a listening socket
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::ENETUNREACH - the network cannot be reached from this host at this
  #     time
  # *   Errno::EHOSTUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
  #     was made.
  # *   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
  #     connection cannot be completed immediately
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  #
  #
  # ### See
  # *   connect manual pages on unix-based systems
  # *   connect function in Microsoft's Winsock functions reference
  #
  def connect: (String | Addrinfo remote_sockaddr) -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.connect_nonblock(remote_sockaddr, [options]) => 0
  # -->
  # Requests a connection to be made on the given `remote_sockaddr` after
  # O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
  # otherwise an exception is raised.
  #
  # ### Parameter
  #     # +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
  #     begin # emulate blocking connect
  #       socket.connect_nonblock(sockaddr)
  #     rescue IO::WaitWritable
  #       IO.select(nil, [socket]) # wait 3-way handshake completion
  #       begin
  #         socket.connect_nonblock(sockaddr) # check connection failure
  #       rescue Errno::EISCONN
  #       end
  #     end
  #     socket.write("GET / HTTP/1.0\r\n\r\n")
  #     results = socket.read
  #
  # Refer to Socket#connect for the exceptions that may be thrown if the call to
  # *connect_nonblock* fails.
  #
  # Socket#connect_nonblock may raise any error corresponding to connect(2)
  # failure, including Errno::EINPROGRESS.
  #
  # If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
  # IO::WaitWritable can be used to rescue the exceptions for retrying
  # connect_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # connect_nonblock should not raise an IO::WaitWritable exception, but return
  # the symbol `:wait_writable` instead.
  #
  # ### See
  #     # Socket#connect
  #
  def connect_nonblock: (untyped addr, ?exception: untyped) -> (Integer | :wait_writable)

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - ipv6only!()
  # -->
  # enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.
  #
  def ipv6only!: () -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog_len) -> void

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.recvfrom(maxlen) => [mesg, sender_addrinfo]
  #   - socket.recvfrom(maxlen, flags) => [mesg, sender_addrinfo]
  # -->
  # Receives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  #
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client, client_addrinfo = socket.accept
  #     data = client.recvfrom( 20 )[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *recvfrom* fails:
  # *   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
  #     no data is waiting to be received; or MSG_OOB is set and no out-of-band
  #     data is available and either the `socket` file descriptor is marked as
  #     O_NONBLOCK or the `socket` does not support blocking to wait for
  #     out-of-band-data
  # *   Errno::EWOULDBLOCK - see Errno::EAGAIN
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNRESET - a connection was forcibly closed by a peer
  # *   Errno::EFAULT - the socket's internal buffer, address or address length
  #     cannot be accessed or written
  # *   Errno::EINTR - a signal interrupted *recvfrom* before any data was
  #     available
  # *   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
  #     available
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     filesystem
  # *   Errno::ENOBUFS - insufficient resources were available in the system to
  #     perform the operation
  # *   Errno::ENOMEM - insufficient memory was available to fulfill the request
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
  #     is not connected
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
  #     type
  # *   Errno::ETIMEDOUT - the connection timed out during connection
  #     establishment or due to a transmission timeout on an active connection
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *recvfrom* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EFAULT - the internal buffer and from parameters on `socket` are
  #     not part of the user address space, or the internal fromlen parameter is
  #     too small to accommodate the peer address
  # *   Errno::EINTR - the (blocking) call was cancelled by an internal call to
  #     the WinSock function WSACancelBlockingCall
  # *   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
  #     the service provider is still processing a callback function
  # *   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
  #     unknown flag was specified, or MSG_OOB was specified for a socket with
  #     SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
  #     len parameter on `socket` was zero or negative
  # *   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
  #     not permitted with a connected socket on a socket that is connection
  #     oriented or connectionless.
  # *   Errno::ENETRESET - the connection has been broken due to the keep-alive
  #     activity detecting a failure while the operation was in progress.
  # *   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
  #     stream-style such as type SOCK_STREAM. OOB data is not supported in the
  #     communication domain associated with `socket`, or `socket` is
  #     unidirectional and supports only send operations
  # *   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
  #     *recvfrom* on a socket after *shutdown* has been invoked.
  # *   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
  #     *recvfrom* would block.
  # *   Errno::EMSGSIZE - the message was too large to fit into the specified
  #     buffer and was truncated.
  # *   Errno::ETIMEDOUT - the connection has been dropped, because of a network
  #     failure or because the system on the other end went down without notice
  # *   Errno::ECONNRESET - the virtual circuit was reset by the remote side
  #     executing a hard or abortive close. The application should close the
  #     socket; it is no longer usable. On a UDP-datagram socket this error
  #     indicates a previous send operation resulted in an ICMP Port Unreachable
  #     message.
  #
  def recvfrom: (Integer maxlen, ?Integer flags) -> [ String, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - socket.recvfrom_nonblock(maxlen[, flags[, outbuf[, opts]]]) => [mesg, sender_addrinfo]
  # -->
  # Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
  # is set for the underlying file descriptor. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
  # as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP,
  # etc.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `outbuf` - destination String buffer
  # *   `opts` - keyword hash, supporting `exception: false`
  #
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     client, client_addrinfo = socket.accept
  #     begin # emulate blocking recvfrom
  #       pair = client.recvfrom_nonblock(20)
  #     rescue IO::WaitReadable
  #       IO.select([client])
  #       retry
  #     end
  #     data = pair[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recvfrom_nonblock* fails.
  #
  # Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recvfrom_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recvfrom_nonblock: (Integer maxlen, ?Integer flags, ?untyped outbuf, ?exception: boolish) -> ([ String, Addrinfo ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - socket.sysaccept => [client_socket_fd, client_addrinfo]
  # -->
  # Accepts an incoming connection returning an array containing the (integer)
  # file descriptor for the incoming connection, *client_socket_fd*, and an
  # Addrinfo, *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client_fd, client_addrinfo = socket.sysaccept
  #     client_socket = Socket.for_fd( client_fd )
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *sysaccept* fails.
  #
  # ### See
  # *   Socket#accept
  #
  def sysaccept: () -> [ Integer, Addrinfo ]

  private

  def __accept_nonblock: (untyped) -> untyped

  def __connect_nonblock: (untyped, untyped) -> untyped

  def __recvfrom_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/socket.c
  #   - Socket.new(domain, socktype [, protocol]) => socket
  # -->
  # Creates a new socket object.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* is optional and should be a protocol defined in the domain. If
  # protocol is not given, 0 is used internally.
  #
  #     Socket.new(:INET, :STREAM) # TCP socket
  #     Socket.new(:INET, :DGRAM)  # UDP socket
  #     Socket.new(:UNIX, :STREAM) # UNIX stream socket
  #     Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket
  #
  def initialize: (Symbol domain, Symbol socktype, ?Integer protocol) -> untyped
end

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AppleTalk protocol
#
Socket::AF_APPLETALK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (now ITU-T) protocols
#
Socket::AF_CCITT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# MIT CHAOS protocols
#
Socket::AF_CHAOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Computer Network Technology
#
Socket::AF_CNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Connection-oriented IP
#
Socket::AF_COIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Datakit protocol
#
Socket::AF_DATAKIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DEC Direct Data Link Interface protocol
#
Socket::AF_DLI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (ITU-T) E.164 recommendation
#
Socket::AF_E164: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# European Computer Manufacturers protocols
#
Socket::AF_ECMA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NSC Hyperchannel protocol
#
Socket::AF_HYLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ARPANET IMP protocol
#
Socket::AF_IMPLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv4 protocol
#
Socket::AF_INET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv6 protocol
#
Socket::AF_INET6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPX protocol
#
Socket::AF_IPX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Integrated Services Digital Network
#
Socket::AF_ISDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::AF_ISO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Local Area Transport protocol
#
Socket::AF_LAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Link layer interface
#
Socket::AF_LINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Host-internal protocols
#
Socket::AF_LOCAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum address family for this platform
#
Socket::AF_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Native ATM access
#
Socket::AF_NATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Network driver raw access
#
Socket::AF_NDRV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NetBIOS
#
Socket::AF_NETBIOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XEROX NS protocols
#
Socket::AF_NS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::AF_OSI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Point-to-Point Protocol
#
Socket::AF_PPP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::AF_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Internal routing protocol
#
Socket::AF_ROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Simple Internet Protocol
#
Socket::AF_SIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IBM SNA protocol
#
Socket::AF_SNA: Integer

Socket::AF_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UNIX sockets
#
Socket::AF_UNIX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unspecified protocol, any supported address family
#
Socket::AF_UNSPEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept only if any address is assigned
#
Socket::AI_ADDRCONFIG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow all addresses
#
Socket::AI_ALL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Fill in the canonical name
#
Socket::AI_CANONNAME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default flags for getaddrinfo
#
Socket::AI_DEFAULT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Valid flag mask for getaddrinfo (not for application use)
#
Socket::AI_MASK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Prevent host name resolution
#
Socket::AI_NUMERICHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Prevent service name resolution
#
Socket::AI_NUMERICSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get address to use with bind()
#
Socket::AI_PASSIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept IPv4-mapped IPv6 addresses
#
Socket::AI_V4MAPPED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Accept IPv4 mapped addresses if the kernel supports it
#
Socket::AI_V4MAPPED_CFG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Address family for hostname not supported
#
Socket::EAI_ADDRFAMILY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Temporary failure in name resolution
#
Socket::EAI_AGAIN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Invalid flags
#
Socket::EAI_BADFLAGS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Invalid value for hints
#
Socket::EAI_BADHINTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Non-recoverable failure in name resolution
#
Socket::EAI_FAIL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Address family not supported
#
Socket::EAI_FAMILY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum error code from getaddrinfo
#
Socket::EAI_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Memory allocation failure
#
Socket::EAI_MEMORY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# No address associated with hostname
#
Socket::EAI_NODATA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hostname nor servname, or not known
#
Socket::EAI_NONAME: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Argument buffer overflow
#
Socket::EAI_OVERFLOW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Resolved protocol is unknown
#
Socket::EAI_PROTOCOL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Servname not supported for socket type
#
Socket::EAI_SERVICE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket type not supported
#
Socket::EAI_SOCKTYPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# System error returned in errno
#
Socket::EAI_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# receive all multicast packets
#
Socket::IFF_ALLMULTI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# use alternate physical connection
#
Socket::IFF_ALTPHYS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# broadcast address valid
#
Socket::IFF_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# turn on debugging
#
Socket::IFF_DEBUG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 0
#
Socket::IFF_LINK0: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 1
#
Socket::IFF_LINK1: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# per link layer defined bit 2
#
Socket::IFF_LINK2: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# loopback net
#
Socket::IFF_LOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# supports multicast
#
Socket::IFF_MULTICAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# no address resolution protocol
#
Socket::IFF_NOARP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# avoid use of trailers
#
Socket::IFF_NOTRAILERS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# transmission in progress
#
Socket::IFF_OACTIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# point-to-point link
#
Socket::IFF_POINTOPOINT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# receive all packets
#
Socket::IFF_PROMISC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# resources allocated
#
Socket::IFF_RUNNING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# can't hear own transmissions
#
Socket::IFF_SIMPLEX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# interface is up
#
Socket::IFF_UP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum interface name size
#
Socket::IFNAMSIZ: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum interface name size
#
Socket::IF_NAMESIZE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multicast group for all systems on this subset
#
Socket::INADDR_ALLHOSTS_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A socket bound to INADDR_ANY receives packets from all interfaces and sends
# from the default IP address
#
Socket::INADDR_ANY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The network broadcast address
#
Socket::INADDR_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The loopback address
#
Socket::INADDR_LOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The last local network multicast group
#
Socket::INADDR_MAX_LOCAL_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A bitmask for matching no valid IP address
#
Socket::INADDR_NONE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The reserved multicast group
#
Socket::INADDR_UNSPEC_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of an IPv6 address string
#
Socket::INET6_ADDRSTRLEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of an IPv4 address string
#
Socket::INET_ADDRSTRLEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default minimum address for bind or connect
#
Socket::IPPORT_RESERVED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default maximum address for bind or connect
#
Socket::IPPORT_USERRESERVED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 auth header
#
Socket::IPPROTO_AH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 destination option
#
Socket::IPPROTO_DSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Exterior Gateway Protocol
#
Socket::IPPROTO_EGP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO cnlp
#
Socket::IPPROTO_EON: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 Encapsulated Security Payload
#
Socket::IPPROTO_ESP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 fragmentation header
#
Socket::IPPROTO_FRAGMENT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Gateway to Gateway Protocol
#
Socket::IPPROTO_GGP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# "hello" routing protocol
#
Socket::IPPROTO_HELLO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 hop-by-hop options
#
Socket::IPPROTO_HOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Control message protocol
#
Socket::IPPROTO_ICMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ICMP6
#
Socket::IPPROTO_ICMPV6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XNS IDP
#
Socket::IPPROTO_IDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Group Management Protocol
#
Socket::IPPROTO_IGMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Dummy protocol for IP
#
Socket::IPPROTO_IP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 header
#
Socket::IPPROTO_IPV6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum IPPROTO constant
#
Socket::IPPROTO_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Sun net disk protocol
#
Socket::IPPROTO_ND: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 no next header
#
Socket::IPPROTO_NONE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::IPPROTO_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Raw IP packet
#
Socket::IPPROTO_RAW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 routing header
#
Socket::IPPROTO_ROUTING: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# TCP
#
Socket::IPPROTO_TCP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO transport protocol class 4
#
Socket::IPPROTO_TP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UDP
#
Socket::IPPROTO_UDP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Xpress Transport Protocol
#
Socket::IPPROTO_XTP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Checksum offset for raw sockets
#
Socket::IPV6_CHECKSUM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't fragment packets
#
Socket::IPV6_DONTFRAG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Destination option
#
Socket::IPV6_DSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hop limit
#
Socket::IPV6_HOPLIMIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hop-by-hop option
#
Socket::IPV6_HOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a group membership
#
Socket::IPV6_JOIN_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a group membership
#
Socket::IPV6_LEAVE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast hops
#
Socket::IPV6_MULTICAST_HOPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast interface
#
Socket::IPV6_MULTICAST_IF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 multicast loopback
#
Socket::IPV6_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Next hop address
#
Socket::IPV6_NEXTHOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve current path MTU
#
Socket::IPV6_PATHMTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive packet information with datagram
#
Socket::IPV6_PKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP6 options for response
#
Socket::IPV6_RECVDSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive hop limit with datagram
#
Socket::IPV6_RECVHOPLIMIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive hop-by-hop options
#
Socket::IPV6_RECVHOPOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive current path MTU with datagram
#
Socket::IPV6_RECVPATHMTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive destination IP address and incoming interface
#
Socket::IPV6_RECVPKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive routing header
#
Socket::IPV6_RECVRTHDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive traffic class
#
Socket::IPV6_RECVTCLASS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allows removal of sticky routing headers
#
Socket::IPV6_RTHDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allows removal of sticky destination options header
#
Socket::IPV6_RTHDRDSTOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Routing header type 0
#
Socket::IPV6_RTHDR_TYPE_0: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Specify the traffic class
#
Socket::IPV6_TCLASS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP6 unicast hops
#
Socket::IPV6_UNICAST_HOPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use the minimum MTU size
#
Socket::IPV6_USE_MIN_MTU: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Only bind IPv6 with a wildcard bind
#
Socket::IPV6_V6ONLY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Add a multicast group membership
#
Socket::IP_ADD_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Add a multicast group membership
#
Socket::IP_ADD_SOURCE_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Block IPv4 multicast packets with a give source address
#
Socket::IP_BLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default multicast loopback
#
Socket::IP_DEFAULT_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Default multicast TTL
#
Socket::IP_DEFAULT_MULTICAST_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Drop a multicast group membership
#
Socket::IP_DROP_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Drop a multicast group membership
#
Socket::IP_DROP_SOURCE_MEMBERSHIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Header is included with data
#
Socket::IP_HDRINCL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPsec security policy
#
Socket::IP_IPSEC_POLICY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum number multicast groups a socket can join
#
Socket::IP_MAX_MEMBERSHIPS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Multicast source filtering
#
Socket::IP_MSFILTER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast interface
#
Socket::IP_MULTICAST_IF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast loopback
#
Socket::IP_MULTICAST_LOOP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP multicast TTL
#
Socket::IP_MULTICAST_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP options to be included in packets
#
Socket::IP_OPTIONS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive packet information with datagrams
#
Socket::IP_PKTINFO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set the port range for sockets with unspecified port numbers
#
Socket::IP_PORTRANGE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive IP destination address with datagram
#
Socket::IP_RECVDSTADDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive interface information with datagrams
#
Socket::IP_RECVIF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP options with datagram
#
Socket::IP_RECVOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive all IP options for response
#
Socket::IP_RECVRETOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive TOS with incoming packets
#
Socket::IP_RECVTOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive IP TTL with datagrams
#
Socket::IP_RECVTTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP options to be included in datagrams
#
Socket::IP_RETOPTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP type-of-service
#
Socket::IP_TOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IP time-to-live
#
Socket::IP_TTL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unblock IPv4 multicast packets with a give source address
#
Socket::IP_UNBLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retrieve peer credentials
#
Socket::LOCAL_PEERCRED: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Block multicast packets from this source
#
Socket::MCAST_BLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Exclusive multicast source filter
#
Socket::MCAST_EXCLUDE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Inclusive multicast source filter
#
Socket::MCAST_INCLUDE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a multicast group
#
Socket::MCAST_JOIN_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Join a multicast source group
#
Socket::MCAST_JOIN_SOURCE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a multicast group
#
Socket::MCAST_LEAVE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave a multicast source group
#
Socket::MCAST_LEAVE_SOURCE_GROUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unblock multicast packets from this source
#
Socket::MCAST_UNBLOCK_SOURCE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Control data lost before delivery
#
Socket::MSG_CTRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send without using the routing tables
#
Socket::MSG_DONTROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# This message should be non-blocking
#
Socket::MSG_DONTWAIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data completes connection
#
Socket::MSG_EOF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data completes record
#
Socket::MSG_EOR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Start of a hold sequence.  Dumps to so_temp
#
Socket::MSG_FLUSH: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data ready to be read
#
Socket::MSG_HAVEMORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Hold fragment in so_temp
#
Socket::MSG_HOLD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Process out-of-band data
#
Socket::MSG_OOB: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Peek at incoming message
#
Socket::MSG_PEEK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data remains in the current packet
#
Socket::MSG_RCVMORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send the packet in so_temp
#
Socket::MSG_SEND: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Data discarded before delivery
#
Socket::MSG_TRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Wait for full request or error
#
Socket::MSG_WAITALL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# The service specified is a datagram service (looks up UDP ports)
#
Socket::NI_DGRAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of a hostname
#
Socket::NI_MAXHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum length of a service name
#
Socket::NI_MAXSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A name is required
#
Socket::NI_NAMEREQD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# An FQDN is not required for local hosts, return only the local part
#
Socket::NI_NOFQDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Return a numeric address
#
Socket::NI_NUMERICHOST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Return the service name as a digit string
#
Socket::NI_NUMERICSERV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# AppleTalk protocol
#
Socket::PF_APPLETALK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# CCITT (now ITU-T) protocols
#
Socket::PF_CCITT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# MIT CHAOS protocols
#
Socket::PF_CHAOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Computer Network Technology
#
Socket::PF_CNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Connection-oriented IP
#
Socket::PF_COIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Datakit protocol
#
Socket::PF_DATAKIT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# DEC Direct Data Link Interface protocol
#
Socket::PF_DLI: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# European Computer Manufacturers protocols
#
Socket::PF_ECMA: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NSC Hyperchannel protocol
#
Socket::PF_HYLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ARPANET IMP protocol
#
Socket::PF_IMPLINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv4 protocol
#
Socket::PF_INET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPv6 protocol
#
Socket::PF_INET6: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IPX protocol
#
Socket::PF_IPX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Integrated Services Digital Network
#
Socket::PF_ISDN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::PF_ISO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Key management protocol, originally developed for usage with IPsec
#
Socket::PF_KEY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Local Area Transport protocol
#
Socket::PF_LAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Link layer interface
#
Socket::PF_LINK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Host-internal protocols
#
Socket::PF_LOCAL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum address family for this platform
#
Socket::PF_MAX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Native ATM access
#
Socket::PF_NATM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Network driver raw access
#
Socket::PF_NDRV: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# NetBIOS
#
Socket::PF_NETBIOS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# XEROX NS protocols
#
Socket::PF_NS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# ISO Open Systems Interconnection protocols
#
Socket::PF_OSI: Integer

Socket::PF_PIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Point-to-Point Protocol
#
Socket::PF_PPP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# PARC Universal Packet protocol
#
Socket::PF_PUP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Internal routing protocol
#
Socket::PF_ROUTE: Integer

Socket::PF_RTIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Simple Internet Protocol
#
Socket::PF_SIP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# IBM SNA protocol
#
Socket::PF_SNA: Integer

Socket::PF_SYSTEM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# UNIX sockets
#
Socket::PF_UNIX: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Unspecified protocol, any supported address family
#
Socket::PF_UNSPEC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# eXpress Transfer Protocol
#
Socket::PF_XTP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Process credentials
#
Socket::SCM_CREDS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Access rights
#
Socket::SCM_RIGHTS: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Timestamp (timeval)
#
Socket::SCM_TIMESTAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the reading side of the socket
#
Socket::SHUT_RD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the both sides of the socket
#
Socket::SHUT_RDWR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Shut down the writing side of the socket
#
Socket::SHUT_WR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A datagram socket provides connectionless, unreliable messaging
#
Socket::SOCK_DGRAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A raw socket provides low-level access for direct access or implementing
# network protocols
#
Socket::SOCK_RAW: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A reliable datagram socket provides reliable delivery of messages
#
Socket::SOCK_RDM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A sequential packet socket provides sequenced, reliable two-way connection for
# datagrams
#
Socket::SOCK_SEQPACKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# A stream socket provides a sequenced, reliable two-way connection for a byte
# stream
#
Socket::SOCK_STREAM: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket-level options
#
Socket::SOL_SOCKET: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum connection requests that may be queued for a socket
#
Socket::SOMAXCONN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Socket has had listen() called on it
#
Socket::SO_ACCEPTCONN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Permit sending of broadcast messages
#
Socket::SO_BROADCAST: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Debug info recording
#
Socket::SO_DEBUG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Use interface addresses
#
Socket::SO_DONTROUTE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Retain unread data
#
Socket::SO_DONTTRUNC: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get and clear the error status
#
Socket::SO_ERROR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Keep connections alive
#
Socket::SO_KEEPALIVE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Linger on close if data is present
#
Socket::SO_LINGER: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Install socket-level Network Kernel Extension
#
Socket::SO_NKE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't SIGPIPE on EPIPE
#
Socket::SO_NOSIGPIPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get first packet byte count
#
Socket::SO_NREAD: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Leave received out-of-band data in-line
#
Socket::SO_OOBINLINE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive buffer size
#
Socket::SO_RCVBUF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive low-water mark
#
Socket::SO_RCVLOWAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive timeout
#
Socket::SO_RCVTIMEO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow local address reuse
#
Socket::SO_REUSEADDR: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Allow local address and port reuse
#
Socket::SO_REUSEPORT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send buffer size
#
Socket::SO_SNDBUF: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send low-water mark
#
Socket::SO_SNDLOWAT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Send timeout
#
Socket::SO_SNDTIMEO: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Receive timestamp with datagrams (timeval)
#
Socket::SO_TIMESTAMP: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Get the socket type
#
Socket::SO_TYPE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Bypass hardware when possible
#
Socket::SO_USELOOPBACK: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Give a hint when more data is ready
#
Socket::SO_WANTMORE: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# OOB data is wanted in MSG_FLAG on receive
#
Socket::SO_WANTOOBFLAG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Reduce step of the handshake process (Linux 3.7, glibc 2.18)
#
Socket::TCP_FASTOPEN: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Maximum number of keepalive probes allowed before dropping a connection (Linux
# 2.4, glibc 2.2)
#
Socket::TCP_KEEPCNT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Time between keepalive probes (Linux 2.4, glibc 2.2)
#
Socket::TCP_KEEPINTVL: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Set maximum segment size
#
Socket::TCP_MAXSEG: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't delay sending to coalesce packets
#
Socket::TCP_NODELAY: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't use TCP options
#
Socket::TCP_NOOPT: Integer

# <!-- rdoc-file=ext/socket/constdefs.c -->
# Don't push the last block of write
#
Socket::TCP_NOPUSH: Integer

# <!-- rdoc-file=ext/socket/ifaddr.c -->
# Socket::Ifaddr represents a result of getifaddrs() function.
#
class Socket::Ifaddr
  public

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.addr => addrinfo
  # -->
  # Returns the address of *ifaddr*. nil is returned if address is not available
  # in *ifaddr*.
  #
  def addr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.broadaddr => addrinfo
  # -->
  # Returns the broadcast address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_BROADCAST.
  #
  def broadaddr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.dstaddr => addrinfo
  # -->
  # Returns the destination address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_POINTOPOINT.
  #
  def dstaddr: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.flags => integer
  # -->
  # Returns the flags of *ifaddr*.
  #
  def flags: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.ifindex => integer
  # -->
  # Returns the interface index of *ifaddr*.
  #
  def ifindex: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.inspect => string
  # -->
  # Returns a string to show contents of *ifaddr*.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.name => string
  # -->
  # Returns the interface name of *ifaddr*.
  #
  def name: () -> String

  # <!--
  #   rdoc-file=ext/socket/ifaddr.c
  #   - ifaddr.netmask => addrinfo
  # -->
  # Returns the netmask address of *ifaddr*. nil is returned if netmask is not
  # available in *ifaddr*.
  #
  def netmask: () -> Addrinfo?
end

# <!-- rdoc-file=ext/socket/lib/socket.rb -->
# UDP/IP address information used by Socket.udp_server_loop.
#
class Socket::UDPSource
  public

  def inspect: () -> String

  # <!-- rdoc-file=ext/socket/lib/socket.rb -->
  # Local address
  #
  def local_address: () -> Addrinfo

  # <!-- rdoc-file=ext/socket/lib/socket.rb -->
  # Address of the source
  #
  def remote_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - reply(msg)
  # -->
  # Sends the String `msg` to the source
  #
  def reply: (String msg) -> void

  private

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - new(remote_address, local_address, &reply_proc)
  # -->
  # `remote_address` is an Addrinfo object.
  #
  # `local_address` is an Addrinfo object.
  #
  # `reply_proc` is a Proc used to send reply back to the source.
  #
  def initialize: (Addrinfo remote_address, Addrinfo local_address) { (String) -> void } -> void
end

# <!-- rdoc-file=ext/socket/ancdata.c -->
# Socket::AncillaryData represents the ancillary data (control information) used
# by sendmsg and recvmsg system call.  It contains socket #family, control
# message (cmsg) #level, cmsg #type and cmsg #data.
#
class Socket::AncillaryData
  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.int(family, cmsg_level, cmsg_type, integer) => ancillarydata
  # -->
  # Creates a new Socket::AncillaryData object which contains a int as data.
  #
  # The size and endian is dependent on the host.
  #
  #     require 'socket'
  #
  #     p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.int: (Symbol, Symbol, Symbol, Symbol) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.ip_pktinfo(addr, ifindex) => ancdata
  #   - Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst) => ancdata
  # -->
  # Returns new ancillary data for IP_PKTINFO.
  #
  # If spec_dst is not given, addr is used.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dst = Addrinfo.ip("127.0.0.1")
  #     p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)
  #     #=> #<Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1>
  #
  def self.ip_pktinfo: (Addrinfo addr, Integer ifindex, ?Addrinfo spec_dst) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.ipv6_pktinfo(addr, ifindex) => ancdata
  # -->
  # Returns new ancillary data for IPV6_PKTINFO.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0>
  #
  def self.ipv6_pktinfo: (Addrinfo addr, Integer ifindex) -> instance

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.unix_rights(io1, io2, ...) => ancillarydata
  # -->
  # Creates a new Socket::AncillaryData object which contains file descriptors as
  # data.
  #
  #     p Socket::AncillaryData.unix_rights(STDERR)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.unix_rights: (IO fd) -> instance

  public

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.cmsg_is?(level, type) => true or false
  # -->
  # tests the level and type of *ancillarydata*.
  #
  #     ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true
  #     ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true
  #     ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false
  #     ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false
  #
  def cmsg_is?: (Integer level, Integer ancillary_type) -> bool

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.data => string
  # -->
  # returns the cmsg data as a string.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").data
  #     #=> ""
  #
  def data: () -> String

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.family => integer
  # -->
  # returns the socket family as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").family
  #     #=> 10
  #
  def family: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.inspect => string
  # -->
  # returns a string which shows ancillarydata in human-readable form.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").inspect
  #     #=> "#<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.int => integer
  # -->
  # Returns the data in *ancillarydata* as an int.
  #
  # The size and endian is dependent on the host.
  #
  #     ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     p ancdata.int #=> 2
  #
  def int: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ip_pktinfo => [addr, ifindex, spec_dst]
  # -->
  # Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dest = Addrinfo.ip("127.0.0.1")
  #     ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)
  #     p ancdata.ip_pktinfo
  #     #=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]
  #
  def ip_pktinfo: () -> [ Addrinfo, Integer, Addrinfo ]

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo => [addr, ifindex]
  # -->
  # Extracts addr and ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]
  #
  def ipv6_pktinfo: () -> [ Addrinfo, Integer ]

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo_addr => addr
  # -->
  # Extracts addr from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>
  #
  def ipv6_pktinfo_addr: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancdata.ipv6_pktinfo_ifindex => addr
  # -->
  # Extracts ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_ifindex #=> 0
  #
  def ipv6_pktinfo_ifindex: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.level => integer
  # -->
  # returns the cmsg level as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").level
  #     #=> 41
  #
  def level: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.timestamp => time
  # -->
  # returns the timestamp as a time object.
  #
  # *ancillarydata* should be one of following type:
  # *   SOL_SOCKET/SCM_TIMESTAMP (microsecond) GNU/Linux, FreeBSD, NetBSD,
  #     OpenBSD, Solaris, MacOS X
  # *   SOL_SOCKET/SCM_TIMESTAMPNS (nanosecond) GNU/Linux
  # *   SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD
  #
  #     Addrinfo.udp("127.0.0.1", 0).bind {|s1|
  #         Addrinfo.udp("127.0.0.1", 0).bind {|s2|
  #           s1.setsockopt(:SOCKET, :TIMESTAMP, true)
  #           s2.send "a", 0, s1.local_address
  #           ctl = s1.recvmsg.last
  #           p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581>
  #           t = ctl.timestamp
  #           p t      #=> 2009-02-24 17:35:46 +0900
  #           p t.usec #=> 775581
  #           p t.nsec #=> 775581000
  #         }
  #
  #     }
  #
  def timestamp: () -> Time

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.type => integer
  # -->
  # returns the cmsg type as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").type
  #     #=> 2
  #
  def type: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - ancillarydata.unix_rights => array-of-IOs or nil
  # -->
  # returns the array of IO objects for SCM_RIGHTS control message in UNIX domain
  # socket.
  #
  # The class of the IO objects in the array is IO or Socket.
  #
  # The array is attached to *ancillarydata* when it is instantiated. For example,
  # BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control
  # message and :scm_rights=>true option is given.
  #
  #     # recvmsg needs :scm_rights=>true for unix_rights
  #     s1, s2 = UNIXSocket.pair
  #     p s1                                         #=> #<UNIXSocket:fd 3>
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg(:scm_rights=>true)
  #     p ctl                                        #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]
  #     p File.identical?(STDIN, ctl.unix_rights[0]) #=> true
  #     p File.identical?(s1, ctl.unix_rights[1])    #=> true
  #
  #     # If :scm_rights=>true is not given, unix_rights returns nil
  #     s1, s2 = UNIXSocket.pair
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg
  #     p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights #=> nil
  #
  def unix_rights: () -> Array[IO]?

  private

  # <!--
  #   rdoc-file=ext/socket/ancdata.c
  #   - Socket::AncillaryData.new(family, cmsg_level, cmsg_type, cmsg_data) -> ancillarydata
  # -->
  # *family* should be an integer, a string or a symbol.
  # *   Socket::AF_INET, "AF_INET", "INET", :AF_INET, :INET
  # *   Socket::AF_UNIX, "AF_UNIX", "UNIX", :AF_UNIX, :UNIX
  # *   etc.
  #
  #
  # *cmsg_level* should be an integer, a string or a symbol.
  # *   Socket::SOL_SOCKET, "SOL_SOCKET", "SOCKET", :SOL_SOCKET and :SOCKET
  # *   Socket::IPPROTO_IP, "IP" and :IP
  # *   Socket::IPPROTO_IPV6, "IPV6" and :IPV6
  # *   Socket::IPPROTO_TCP, "TCP" and :TCP
  # *   etc.
  #
  #
  # *cmsg_type* should be an integer, a string or a symbol. If a string/symbol is
  # specified, it is interpreted depend on *cmsg_level*.
  # *   Socket::SCM_RIGHTS, "SCM_RIGHTS", "RIGHTS", :SCM_RIGHTS, :RIGHTS for
  #     SOL_SOCKET
  # *   Socket::IP_RECVTTL, "RECVTTL" and :RECVTTL for IPPROTO_IP
  # *   Socket::IPV6_PKTINFO, "PKTINFO" and :PKTINFO for IPPROTO_IPV6
  # *   etc.
  #
  #
  # *cmsg_data* should be a string.
  #
  #     p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, "")
  #     #=> #<Socket::AncillaryData: INET TCP NODELAY "">
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO "">
  #
  def initialize: (Symbol | String | Integer family, Symbol | String | Integer cmsg_level, Symbol | String | Integer cmsg_data, String cmsg_data) -> untyped
end

# <!-- rdoc-file=ext/socket/unixsocket.c -->
# UNIXSocket represents a UNIX domain stream client socket.
#
class UNIXSocket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.pair([type [, protocol]])       => [unixsocket1, unixsocket2]
  #   - UNIXSocket.socketpair([type [, protocol]]) => [unixsocket1, unixsocket2]
  # -->
  # Creates a pair of sockets connected to each other.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain. 0 is default protocol
  # for the domain.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "ab"
  #
  def self.pair: (?Symbol socktype, ?Integer protocol) -> [ instance, instance ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.pair([type [, protocol]])       => [unixsocket1, unixsocket2]
  #   - UNIXSocket.socketpair([type [, protocol]]) => [unixsocket1, unixsocket2]
  # -->
  # Creates a pair of sockets connected to each other.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain. 0 is default protocol
  # for the domain.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "ab"
  #
  def self.socketpair: (?Symbol socktype, ?Integer protocol) -> [ instance, instance ]

  public

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.addr => [address_family, unix_path]
  # -->
  # Returns the local address as an array which contains address_family and
  # unix_path.
  #
  # Example
  #     serv = UNIXServer.new("/tmp/sock")
  #     p serv.addr #=> ["AF_UNIX", "/tmp/sock"]
  #
  def addr: () -> [ String, String ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.path => path
  # -->
  # Returns the path of the local address of unixsocket.
  #
  #     s = UNIXServer.new("/tmp/sock")
  #     p s.path #=> "/tmp/sock"
  #
  def path: () -> String

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.peeraddr => [address_family, unix_path]
  # -->
  # Returns the remote address as an array which contains address_family and
  # unix_path.
  #
  # Example
  #     serv = UNIXServer.new("/tmp/sock")
  #     c = UNIXSocket.new("/tmp/sock")
  #     p c.peeraddr #=> ["AF_UNIX", "/tmp/sock"]
  #
  def peeraddr: () -> [ String, String ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.recv_io([klass [, mode]]) => io
  # -->
  # Example
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         s = serv.accept
  #
  #         c.send_io STDOUT
  #         stdout = s.recv_io
  #
  #         p STDOUT.fileno #=> 1
  #         p stdout.fileno #=> 7
  #
  #         stdout.puts "hello" # outputs "hello\n" to standard output.
  #       }
  #     }
  #
  # *klass* will determine the class of *io* returned (using the IO.for_fd
  # singleton method or similar). If *klass* is `nil`, an integer file descriptor
  # is returned.
  #
  # *mode* is the same as the argument passed to IO.for_fd
  #
  def recv_io: (?singleton(BasicSocket), ?String mode) -> BasicSocket

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.recvfrom(maxlen [, flags[, outbuf]]) => [mesg, unixaddress]
  # -->
  # Receives a message via *unixsocket*.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *outbuf* will contain only the received data after the method call even if it
  # is not empty at the beginning.
  #
  #     s1 = Socket.new(:UNIX, :DGRAM, 0)
  #     s1_ai = Addrinfo.unix("/tmp/sock1")
  #     s1.bind(s1_ai)
  #
  #     s2 = Socket.new(:UNIX, :DGRAM, 0)
  #     s2_ai = Addrinfo.unix("/tmp/sock2")
  #     s2.bind(s2_ai)
  #     s3 = UNIXSocket.for_fd(s2.fileno)
  #
  #     s1.send "a", 0, s2_ai
  #     p s3.recvfrom(10) #=> ["a", ["AF_UNIX", "/tmp/sock1"]]
  #
  def recvfrom: (Integer maxlen, ?Integer flags, ?String outbuf) -> [ String, [ String, String ] ]

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - unixsocket.send_io(io) => nil
  # -->
  # Sends *io* as file descriptor passing.
  #
  #     s1, s2 = UNIXSocket.pair
  #
  #     s1.send_io STDOUT
  #     stdout = s2.recv_io
  #
  #     p STDOUT.fileno #=> 1
  #     p stdout.fileno #=> 6
  #
  #     stdout.puts "hello" # outputs "hello\n" to standard output.
  #
  # *io* may be any kind of IO object or integer file descriptor.
  #
  def send_io: (BasicSocket | Integer) -> void

  private

  # <!--
  #   rdoc-file=ext/socket/unixsocket.c
  #   - UNIXSocket.new(path) => unixsocket
  # -->
  # Creates a new UNIX client socket connected to *path*.
  #
  #     require 'socket'
  #
  #     s = UNIXSocket.new("/tmp/sock")
  #     s.send "hello", 0
  #
  def initialize: (String path) -> untyped
end

# <!-- rdoc-file=ext/socket/ipsocket.c -->
# IPSocket is the super class of TCPSocket and UDPSocket.
#
class IPSocket < BasicSocket
  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - IPSocket.getaddress(host)        => ipaddress
  # -->
  # Lookups the IP address of *host*.
  #
  #     require 'socket'
  #
  #     IPSocket.getaddress("localhost")     #=> "127.0.0.1"
  #     IPSocket.getaddress("ip6-localhost") #=> "::1"
  #
  def self.getaddress: (String host) -> String

  public

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.addr([reverse_lookup]) => [address_family, port, hostname, numeric_address]
  # -->
  # Returns the local address as an array which contains address_family, port,
  # hostname and numeric_address.
  #
  # If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
  # numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
  # hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
  # to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.addr #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(true)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(false) #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
  #       p sock.addr(:hostname)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
  #       p sock.addr(:numeric)   #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
  #     }
  #
  def addr: (?boolish | :hostname | :numeric reverse_lookup) -> [ String, Integer, String, String ]

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.inspect   -> string
  # -->
  # Return a string describing this IPSocket object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.peeraddr([reverse_lookup]) => [address_family, port, hostname, numeric_address]
  # -->
  # Returns the remote address as an array which contains address_family, port,
  # hostname and numeric_address. It is defined for connection oriented socket
  # such as TCPSocket.
  #
  # If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
  # numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
  # hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
  # to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.peeraddr #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(true)  #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(false) #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #       p sock.peeraddr(:hostname) #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
  #       p sock.peeraddr(:numeric)  #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #     }
  #
  def peeraddr: (?boolish | :hostname | :numeric reverse_lookup) -> [ String, Integer, String, String ]

  # <!--
  #   rdoc-file=ext/socket/ipsocket.c
  #   - ipsocket.recvfrom(maxlen)        => [mesg, ipaddr]
  #   - ipsocket.recvfrom(maxlen, flags) => [mesg, ipaddr]
  # -->
  # Receives a message and return the message as a string and an address which the
  # message come from.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # ipaddr is the same as IPSocket#{peeraddr,addr}.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u2 = UDPSocket.new
  #     u2.send "uuuu", 0, "127.0.0.1", 4913
  #     p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]
  #
  def recvfrom: (Integer maxlen, ?Integer flags) -> [ String, [ String, Integer, String, String ] ]
end

# <!-- rdoc-file=ext/socket/basicsocket.c -->
# BasicSocket is the super class for all the Socket classes.
#
class BasicSocket < IO
  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.do_not_reverse_lookup => true or false
  # -->
  # Gets the global do_not_reverse_lookup flag.
  #
  #     BasicSocket.do_not_reverse_lookup  #=> false
  #
  def self.do_not_reverse_lookup: () -> bool

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.do_not_reverse_lookup = bool
  # -->
  # Sets the global do_not_reverse_lookup flag.
  #
  # The flag is used for initial value of do_not_reverse_lookup for each socket.
  #
  #     s1 = TCPSocket.new("localhost", 80)
  #     p s1.do_not_reverse_lookup                 #=> true
  #     BasicSocket.do_not_reverse_lookup = false
  #     s2 = TCPSocket.new("localhost", 80)
  #     p s2.do_not_reverse_lookup                 #=> false
  #     p s1.do_not_reverse_lookup                 #=> true
  #
  def self.do_not_reverse_lookup=: (boolish) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - BasicSocket.for_fd(fd) => basicsocket
  # -->
  # Returns a socket object which contains the file descriptor, *fd*.
  #
  #     # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
  #     STDIN_SOCK = Socket.for_fd(STDIN.fileno)
  #     p STDIN_SOCK.remote_address
  #
  def self.for_fd: (Integer fileno) -> BasicSocket

  public

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.close_read => nil
  # -->
  # Disallows further read using shutdown system call.
  #
  #     s1, s2 = UNIXSocket.pair
  #     s1.close_read
  #     s2.puts #=> Broken pipe (Errno::EPIPE)
  #
  def close_read: () -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.close_write => nil
  # -->
  # Disallows further write using shutdown system call.
  #
  #     UNIXSocket.pair {|s1, s2|
  #       s1.print "ping"
  #       s1.close_write
  #       p s2.read        #=> "ping"
  #       s2.print "pong"
  #       s2.close
  #       p s1.read        #=> "pong"
  #     }
  #
  def close_write: () -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - connect_address()
  # -->
  # Returns an address of the socket suitable for connect in the local machine.
  #
  # This method returns *self*.local_address, except following condition.
  #
  # *   IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address
  #     (127.0.0.1).
  # *   IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).
  #
  #
  # If the local address is not suitable for connect, SocketError is raised. IPv4
  # and IPv6 address which port is 0 is not suitable for connect. Unix domain
  # socket which has no path is not suitable for connect.
  #
  #     Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
  #       p serv.connect_address #=> #<Addrinfo: 127.0.0.1:53660 TCP>
  #       serv.connect_address.connect {|c|
  #         s, _ = serv.accept
  #         p [c, s] #=> [#<Socket:fd 4>, #<Socket:fd 6>]
  #       }
  #     }
  #
  def connect_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.do_not_reverse_lookup => true or false
  # -->
  # Gets the do_not_reverse_lookup flag of *basicsocket*.
  #
  #     require 'socket'
  #
  #     BasicSocket.do_not_reverse_lookup = false
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup      #=> false
  #     }
  #     BasicSocket.do_not_reverse_lookup = true
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup      #=> true
  #     }
  #
  def do_not_reverse_lookup: () -> bool

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.do_not_reverse_lookup = bool
  # -->
  # Sets the do_not_reverse_lookup flag of *basicsocket*.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  #       p sock.do_not_reverse_lookup       #=> true
  #       p sock.peeraddr                    #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  #       sock.do_not_reverse_lookup = false
  #       p sock.peeraddr                    #=> ["AF_INET", 80, "carbon.ruby-lang.org", "54.163.249.195"]
  #     }
  #
  def do_not_reverse_lookup=: (boolish) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getpeereid => [euid, egid]
  # -->
  # Returns the user and group on the peer of the UNIX socket. The result is a two
  # element array which contains the effective uid and the effective gid.
  #
  #     Socket.unix_server_loop("/tmp/sock") {|s|
  #       begin
  #         euid, egid = s.getpeereid
  #
  #         # Check the connected client is myself or not.
  #         next if euid != Process.uid
  #
  #         # do something about my resource.
  #
  #       ensure
  #         s.close
  #       end
  #     }
  #
  def getpeereid: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getpeername => sockaddr
  # -->
  # Returns the remote address of the socket as a sockaddr string.
  #
  #     TCPServer.open("127.0.0.1", 1440) {|serv|
  #       c = TCPSocket.new("127.0.0.1", 1440)
  #       s = serv.accept
  #       p s.getpeername #=> "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     }
  #
  # If Addrinfo object is preferred over the binary string, use
  # BasicSocket#remote_address.
  #
  def getpeername: () -> String

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.getsockname => sockaddr
  # -->
  # Returns the local address of the socket as a sockaddr string.
  #
  #     TCPServer.open("127.0.0.1", 15120) {|serv|
  #       p serv.getsockname #=> "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     }
  #
  # If Addrinfo object is preferred over the binary string, use
  # BasicSocket#local_address.
  #
  def getsockname: () -> String

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - getsockopt(level, optname) => socketoption
  # -->
  # Gets a socket option. These are protocol and system specific, see your local
  # system documentation for details. The option is returned as a Socket::Option
  # object.
  #
  # ### Parameters
  # *   `level` is an integer, usually one of the SOL_ constants such as
  #     Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
  #     possibly without prefix, is also accepted.
  # *   `optname` is an integer, usually one of the SO_ constants, such as
  #     Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
  #     prefix, is also accepted.
  #
  #
  # ### Examples
  #
  # Some socket options are integers with boolean values, in this case #getsockopt
  # could be called like this:
  #
  #     reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool
  #
  #     optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
  #     optval = optval.unpack "i"
  #     reuseaddr = optval[0] == 0 ? false : true
  #
  # Some socket options are integers with numeric values, in this case #getsockopt
  # could be called like this:
  #
  #     ipttl = sock.getsockopt(:IP, :TTL).int
  #
  #     optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
  #     ipttl = optval.unpack1("i")
  #
  # Option values may be structs. Decoding them can be complex as it involves
  # examining your system headers to determine the correct definition. An example
  # is a +struct linger+, which may be defined in your system headers as:
  #     struct linger {
  #       int l_onoff;
  #       int l_linger;
  #     };
  #
  # In this case #getsockopt could be called like this:
  #
  #     # Socket::Option knows linger structure.
  #     onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger
  #
  #     optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
  #     onoff, linger = optval.unpack "ii"
  #     onoff = onoff == 0 ? false : true
  #
  def getsockopt: (Symbol | Integer, Symbol | Integer) -> (Integer | boolish | String)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - bsock.local_address => addrinfo
  # -->
  # Returns an Addrinfo object for local address obtained by getsockname.
  #
  # Note that addrinfo.protocol is filled by 0.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|s|
  #       p s.local_address #=> #<Addrinfo: 192.168.0.129:36873 TCP>
  #     }
  #
  #     TCPServer.open("127.0.0.1", 1512) {|serv|
  #       p serv.local_address #=> #<Addrinfo: 127.0.0.1:1512 TCP>
  #     }
  #
  def local_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.recv(maxlen[, flags[, outbuf]]) => mesg
  # -->
  # Receives a message.
  #
  # *maxlen* is the maximum number of bytes to receive.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *outbuf* will contain only the received data after the method call even if it
  # is not empty at the beginning.
  #
  #     UNIXSocket.pair {|s1, s2|
  #       s1.puts "Hello World"
  #       p s2.recv(4)                     #=> "Hell"
  #       p s2.recv(4, Socket::MSG_PEEK)   #=> "o Wo"
  #       p s2.recv(4)                     #=> "o Wo"
  #       p s2.recv(10)                    #=> "rld\n"
  #     }
  #
  def recv: (Integer maxlen, ?Integer flags, ?String outbuf) -> String
          | (Integer maxlen, ?String outbuf) -> String

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recv_nonblock(maxlen [, flags [, buf [, options ]]]) => mesg
  # -->
  # Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
  # is set for the underlying file descriptor. *flags* is zero or more of the
  # `MSG_` options. The result, *mesg*, is the data received.
  #
  # When recvfrom(2) returns 0, Socket#recv_nonblock returns an empty string as
  # data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
  #
  # ### Parameters
  # *   `maxlen` - the number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `buf` - destination String buffer
  # *   `options` - keyword hash, supporting `exception: false`
  #
  #
  # ### Example
  #     serv = TCPServer.new("127.0.0.1", 0)
  #     af, port, host, addr = serv.addr
  #     c = TCPSocket.new(addr, port)
  #     s = serv.accept
  #     c.send "aaa", 0
  #     begin # emulate blocking recv.
  #       p s.recv_nonblock(10) #=> "aaa"
  #     rescue IO::WaitReadable
  #       IO.select([s])
  #       retry
  #     end
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recv_nonblock* fails.
  #
  # BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recv_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recv_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recv_nonblock: (Integer maxlen, ?Integer flags, ?String buf, ?exception: boolish) -> (String | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recvmsg(maxmesglen=nil, flags=0, maxcontrollen=nil, opts={}) => [mesg, sender_addrinfo, rflags, *controls]
  # -->
  # recvmsg receives a message using recvmsg(2) system call in blocking manner.
  #
  # *maxmesglen* is the maximum length of mesg to receive.
  #
  # *flags* is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.
  #
  # *maxcontrollen* is the maximum length of controls (ancillary data) to receive.
  #
  # *opts* is option hash. Currently :scm_rights=>bool is the only option.
  #
  # :scm_rights option specifies that application expects SCM_RIGHTS control
  # message. If the value is nil or false, application don't expects SCM_RIGHTS
  # control message. In this case, recvmsg closes the passed file descriptors
  # immediately. This is the default behavior.
  #
  # If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS
  # control message. In this case, recvmsg creates IO objects for each file
  # descriptors for Socket::AncillaryData#unix_rights method.
  #
  # The return value is 4-elements array.
  #
  # *mesg* is a string of the received message.
  #
  # *sender_addrinfo* is a sender socket address for connection-less socket. It is
  # an Addrinfo object. For connection-oriented socket such as TCP,
  # sender_addrinfo is platform dependent.
  #
  # *rflags* is a flags on the received message which is bitwise OR of MSG_*
  # constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD
  # style old recvmsg system call.
  #
  # *controls* is ancillary data which is an array of Socket::AncillaryData
  # objects such as:
  #
  #     #<Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7>
  #
  # *maxmesglen* and *maxcontrollen* can be nil. In that case, the buffer will be
  # grown until the message is not truncated. Internally, MSG_PEEK is used. Buffer
  # full and MSG_CTRUNC are checked for truncation.
  #
  # recvmsg can be used to implement recv_io as follows:
  #
  #     mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=>true)
  #     controls.each {|ancdata|
  #       if ancdata.cmsg_is?(:SOCKET, :RIGHTS)
  #         return ancdata.unix_rights[0]
  #       end
  #     }
  #
  def recvmsg: (?Integer dlen, ?Integer flags, ?Integer clen, ?scm_rights: boolish) -> [ String, Addrinfo, Integer?, Array[Socket::AncillaryData] ]

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.recvmsg_nonblock(maxdatalen=nil, flags=0, maxcontrollen=nil, opts={}) => [data, sender_addrinfo, rflags, *controls]
  # -->
  # recvmsg receives a message using recvmsg(2) system call in non-blocking
  # manner.
  #
  # It is similar to BasicSocket#recvmsg but non-blocking flag is set before the
  # system call and it doesn't retry the system call.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvmsg_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  def recvmsg_nonblock: (?Integer dlen, ?Integer flags, ?Integer clen, ?exception: boolish, ?scm_rights: boolish) -> ([ String, Addrinfo, Integer?, Array[Socket::AncillaryData] ] | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - bsock.remote_address => addrinfo
  # -->
  # Returns an Addrinfo object for remote address obtained by getpeername.
  #
  # Note that addrinfo.protocol is filled by 0.
  #
  #     TCPSocket.open("www.ruby-lang.org", 80) {|s|
  #       p s.remote_address #=> #<Addrinfo: 221.186.184.68:80 TCP>
  #     }
  #
  #     TCPServer.open("127.0.0.1", 1728) {|serv|
  #       c = TCPSocket.new("127.0.0.1", 1728)
  #       s = serv.accept
  #       p s.remote_address #=> #<Addrinfo: 127.0.0.1:36504 TCP>
  #     }
  #
  def remote_address: () -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.send(mesg, flags [, dest_sockaddr]) => numbytes_sent
  # -->
  # send *mesg* via *basicsocket*.
  #
  # *mesg* should be a string.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  # *dest_sockaddr* should be a packed sockaddr string or an addrinfo.
  #
  #     TCPSocket.open("localhost", 80) {|s|
  #       s.send "GET / HTTP/1.0\r\n\r\n", 0
  #       p s.read
  #     }
  #
  def send: (String msg, ?Integer flags, ?Addrinfo | String dest_sockaddr) -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.sendmsg(mesg, flags=0, dest_sockaddr=nil, *controls) => numbytes_sent
  # -->
  # sendmsg sends a message using sendmsg(2) system call in blocking manner.
  #
  # *mesg* is a string to send.
  #
  # *flags* is bitwise OR of MSG_* constants such as Socket::MSG_OOB.
  #
  # *dest_sockaddr* is a destination socket address for connection-less socket. It
  # should be a sockaddr such as a result of Socket.sockaddr_in. An Addrinfo
  # object can be used too.
  #
  # *controls* is a list of ancillary data. The element of *controls* should be
  # Socket::AncillaryData or 3-elements array. The 3-element array should contains
  # cmsg_level, cmsg_type and data.
  #
  # The return value, *numbytes_sent* is an integer which is the number of bytes
  # sent.
  #
  # sendmsg can be used to implement send_io as follows:
  #
  #     # use Socket::AncillaryData.
  #     ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)
  #     sock.sendmsg("a", 0, nil, ancdata)
  #
  #     # use 3-element array.
  #     ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]
  #     sock.sendmsg("\0", 0, nil, ancdata)
  #
  def sendmsg: (String mesg, ?Integer flags, ?Addrinfo | String dest_sockaddr, *Socket::AncillaryData controls) -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - basicsocket.sendmsg_nonblock(mesg, flags=0, dest_sockaddr=nil, *controls, opts={}) => numbytes_sent
  # -->
  # sendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking
  # manner.
  #
  # It is similar to BasicSocket#sendmsg but the non-blocking flag is set before
  # the system call and it doesn't retry the system call.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # sendmsg_nonblock should not raise an IO::WaitWritable exception, but return
  # the symbol `:wait_writable` instead.
  #
  def sendmsg_nonblock: (String mesg, ?Integer flags, ?Addrinfo | String dest_sockaddr, *Socket::AncillaryData controls, ?exception: boolish) -> (Integer | :wait_writable)

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - setsockopt(level, optname, optval)
  #   - setsockopt(socketoption)
  # -->
  # Sets a socket option. These are protocol and system specific, see your local
  # system documentation for details.
  #
  # ### Parameters
  # *   `level` is an integer, usually one of the SOL_ constants such as
  #     Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
  #     possibly without prefix, is also accepted.
  # *   `optname` is an integer, usually one of the SO_ constants, such as
  #     Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
  #     prefix, is also accepted.
  # *   `optval` is the value of the option, it is passed to the underlying
  #     setsockopt() as a pointer to a certain number of bytes. How this is done
  #     depends on the type:
  #     *   Integer: value is assigned to an int, and a pointer to the int is
  #         passed, with length of sizeof(int).
  #     *   true or false: 1 or 0 (respectively) is assigned to an int, and the
  #         int is passed as for an Integer. Note that `false` must be passed, not
  #         `nil`.
  #     *   String: the string's data and length is passed to the socket.
  #
  # *   `socketoption` is an instance of Socket::Option
  #
  #
  # ### Examples
  #
  # Some socket options are integers with boolean values, in this case #setsockopt
  # could be called like this:
  #     sock.setsockopt(:SOCKET, :REUSEADDR, true)
  #     sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
  #     sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
  #
  # Some socket options are integers with numeric values, in this case #setsockopt
  # could be called like this:
  #     sock.setsockopt(:IP, :TTL, 255)
  #     sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
  #     sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
  #
  # Option values may be structs. Passing them can be complex as it involves
  # examining your system headers to determine the correct definition. An example
  # is an `ip_mreq`, which may be defined in your system headers as:
  #     struct ip_mreq {
  #       struct  in_addr imr_multiaddr;
  #       struct  in_addr imr_interface;
  #     };
  #
  # In this case #setsockopt could be called like this:
  #     optval = IPAddr.new("224.0.0.251").hton +
  #              IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
  #     sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
  #
  def setsockopt: (*Symbol | Integer, boolish | Integer | String) -> void

  # <!--
  #   rdoc-file=ext/socket/basicsocket.c
  #   - basicsocket.shutdown([how]) => 0
  # -->
  # Calls shutdown(2) system call.
  #
  # s.shutdown(Socket::SHUT_RD) disallows further read.
  #
  # s.shutdown(Socket::SHUT_WR) disallows further write.
  #
  # s.shutdown(Socket::SHUT_RDWR) disallows further read and write.
  #
  # *how* can be symbol or string:
  # *   :RD, :SHUT_RD, "RD" and "SHUT_RD" are accepted as Socket::SHUT_RD.
  # *   :WR, :SHUT_WR, "WR" and "SHUT_WR" are accepted as Socket::SHUT_WR.
  # *   :RDWR, :SHUT_RDWR, "RDWR" and "SHUT_RDWR" are accepted as
  #     Socket::SHUT_RDWR.
  #
  #     UNIXSocket.pair {|s1, s2|
  #         s1.puts "ping"
  #         s1.shutdown(:WR)
  #         p s2.read          #=> "ping\n"
  #         s2.puts "pong"
  #         s2.close
  #         p s1.read          #=> "pong\n"
  #
  #     }
  #
  def shutdown: (Symbol | String | Integer flags) -> void

  private

  def __recv_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  def __recvmsg: (untyped, untyped, untyped, untyped) -> untyped

  def __recvmsg_nonblock: (untyped, untyped, untyped, untyped, untyped) -> untyped

  def __sendmsg: (untyped, untyped, untyped, untyped) -> untyped

  def __sendmsg_nonblock: (untyped, untyped, untyped, untyped, untyped) -> untyped
end

# <!-- rdoc-file=ext/socket/udpsocket.c -->
# UDPSocket represents a UDP/IP socket.
#
class UDPSocket < IPSocket
  public

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.bind(host, port) #=> 0
  # -->
  # Binds *udpsocket* to *host*:*port*.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u1.send "message-to-self", 0, "127.0.0.1", 4913
  #     p u1.recvfrom(10) #=> ["message-to", ["AF_INET", 4913, "localhost", "127.0.0.1"]]
  #
  def bind: (String host, Integer port) -> void

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.connect(host, port) => 0
  # -->
  # Connects *udpsocket* to *host*:*port*.
  #
  # This makes possible to send without destination address.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #     u2 = UDPSocket.new
  #     u2.connect("127.0.0.1", 4913)
  #     u2.send "uuuu", 0
  #     p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]
  #
  def connect: (String host, Integer port) -> void

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - udpsocket.recvfrom_nonblock(maxlen [, flags[, outbuf [, options]]]) => [mesg, sender_inet_addr]
  # -->
  # Receives up to *maxlen* bytes from `udpsocket` using recvfrom(2) after
  # O_NONBLOCK is set for the underlying file descriptor. *flags* is zero or more
  # of the `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_inet_addr*, is an array to represent the
  # sender address.
  #
  # When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
  # as data. It means an empty packet.
  #
  # ### Parameters
  # *   `maxlen` - the number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `outbuf` - destination String buffer
  # *   `options` - keyword hash, supporting `exception: false`
  #
  #
  # ### Example
  #     require 'socket'
  #     s1 = UDPSocket.new
  #     s1.bind("127.0.0.1", 0)
  #     s2 = UDPSocket.new
  #     s2.bind("127.0.0.1", 0)
  #     s2.connect(*s1.addr.values_at(3,1))
  #     s1.connect(*s2.addr.values_at(3,1))
  #     s1.send "aaa", 0
  #     begin # emulate blocking recvfrom
  #       p s2.recvfrom_nonblock(10)  #=> ["aaa", ["AF_INET", 33302, "localhost.localdomain", "127.0.0.1"]]
  #     rescue IO::WaitReadable
  #       IO.select([s2])
  #       retry
  #     end
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recvfrom_nonblock* fails.
  #
  # UDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recvfrom_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  def recvfrom_nonblock: (Integer len, ?Integer flag, ?String outbuf, ?exception: boolish) -> [ String, [ String, Integer, String, String ] ]

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - udpsocket.send(mesg, flags, host, port)  => numbytes_sent
  #   - udpsocket.send(mesg, flags, sockaddr_to) => numbytes_sent
  #   - udpsocket.send(mesg, flags)              => numbytes_sent
  # -->
  # Sends *mesg* via *udpsocket*.
  #
  # *flags* should be a bitwise OR of Socket::MSG_* constants.
  #
  #     u1 = UDPSocket.new
  #     u1.bind("127.0.0.1", 4913)
  #
  #     u2 = UDPSocket.new
  #     u2.send "hi", 0, "127.0.0.1", 4913
  #
  #     mesg, addr = u1.recvfrom(10)
  #     u1.send mesg, 0, addr[3], addr[1]
  #
  #     p u2.recv(100) #=> "hi"
  #
  def send: (String msg, ?Integer flags, ?String host, ?Integer port) -> Integer

  private

  def __recvfrom_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/udpsocket.c
  #   - UDPSocket.new([address_family]) => socket
  # -->
  # Creates a new UDPSocket object.
  #
  # *address_family* should be an integer, a string or a symbol: Socket::AF_INET,
  # "AF_INET", :INET, etc.
  #
  #     require 'socket'
  #
  #     UDPSocket.new                   #=> #<UDPSocket:fd 3>
  #     UDPSocket.new(Socket::AF_INET6) #=> #<UDPSocket:fd 4>
  #
  def initialize: (?Integer family) -> untyped
end

# <!-- rdoc-file=ext/socket/unixserver.c -->
# UNIXServer represents a UNIX domain stream server socket.
#
class UNIXServer < UNIXSocket
  public

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - unixserver.accept => unixsocket
  # -->
  # Accepts an incoming connection. It returns a new UNIXSocket object.
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         s = serv.accept
  #         s.puts "hi"
  #         s.close
  #         p c.read #=> "hi\n"
  #       }
  #     }
  #
  def accept: () -> UNIXSocket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - unixserver.accept_nonblock([options]) => unixsocket
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an accepted UNIXSocket for the incoming
  # connection.
  #
  # ### Example
  #     require 'socket'
  #     serv = UNIXServer.new("/tmp/sock")
  #     begin # emulate blocking accept
  #       sock = serv.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([serv])
  #       retry
  #     end
  #     # sock is an accepted socket.
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # UNIXServer#accept_nonblock fails.
  #
  # UNIXServer#accept_nonblock may raise any error corresponding to accept(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   UNIXServer#accept
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> (UNIXSocket | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog) -> void

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - unixserver.sysaccept => file_descriptor
  # -->
  # Accepts a new connection. It returns the new file descriptor which is an
  # integer.
  #
  #     UNIXServer.open("/tmp/sock") {|serv|
  #       UNIXSocket.open("/tmp/sock") {|c|
  #         fd = serv.sysaccept
  #         s = IO.new(fd)
  #         s.puts "hi"
  #         s.close
  #         p c.read #=> "hi\n"
  #       }
  #     }
  #
  def sysaccept: () -> Integer

  private

  def __accept_nonblock: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/unixserver.c
  #   - UNIXServer.new(path) => unixserver
  # -->
  # Creates a new UNIX server socket bound to *path*.
  #
  #     require 'socket'
  #
  #     serv = UNIXServer.new("/tmp/sock")
  #     s = serv.accept
  #     p s.read
  #
  def initialize: (untyped) -> untyped
end

# <!-- rdoc-file=ext/socket/tcpserver.c -->
# TCPServer represents a TCP/IP server socket.
#
# A simple TCP server may look like:
#
#     require 'socket'
#
#     server = TCPServer.new 2000 # Server bind to port 2000
#     loop do
#       client = server.accept    # Wait for a client to connect
#       client.puts "Hello !"
#       client.puts "Time is #{Time.now}"
#       client.close
#     end
#
# A more usable server (serving multiple clients):
#
#     require 'socket'
#
#     server = TCPServer.new 2000
#     loop do
#       Thread.start(server.accept) do |client|
#         client.puts "Hello !"
#         client.puts "Time is #{Time.now}"
#         client.close
#       end
#     end
#
class TCPServer < TCPSocket
  public

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - tcpserver.accept => tcpsocket
  # -->
  # Accepts an incoming connection. It returns a new TCPSocket object.
  #
  #     TCPServer.open("127.0.0.1", 14641) {|serv|
  #       s = serv.accept
  #       s.puts Time.now
  #       s.close
  #     }
  #
  def accept: () -> TCPSocket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - tcpserver.accept_nonblock([options]) => tcpsocket
  # -->
  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an accepted TCPSocket for the incoming
  # connection.
  #
  # ### Example
  #     require 'socket'
  #     serv = TCPServer.new(2202)
  #     begin # emulate blocking accept
  #       sock = serv.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([serv])
  #       retry
  #     end
  #     # sock is an accepted socket.
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # TCPServer#accept_nonblock fails.
  #
  # TCPServer#accept_nonblock may raise any error corresponding to accept(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED,
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   TCPServer#accept
  # *   Socket#accept
  #
  def accept_nonblock: (?exception: boolish) -> (TCPSocket | :wait_readable)

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - socket.listen( int ) => 0
  # -->
  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  def listen: (Integer backlog) -> void

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - tcpserver.sysaccept => file_descriptor
  # -->
  # Returns a file descriptor of a accepted connection.
  #
  #     TCPServer.open("127.0.0.1", 28561) {|serv|
  #       fd = serv.sysaccept
  #       s = IO.for_fd(fd)
  #       s.puts Time.now
  #       s.close
  #     }
  #
  def sysaccept: () -> Integer

  private

  def __accept_nonblock: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/socket/tcpserver.c
  #   - TCPServer.new([hostname,] port) => tcpserver
  # -->
  # Creates a new server socket bound to *port*.
  #
  # If *hostname* is given, the socket is bound to it.
  #
  #     serv = TCPServer.new("127.0.0.1", 28561)
  #     s = serv.accept
  #     s.puts Time.now
  #     s.close
  #
  # Internally, TCPServer.new calls getaddrinfo() function to obtain addresses. If
  # getaddrinfo() returns multiple addresses, TCPServer.new tries to create a
  # server socket for each address and returns first one that is successful.
  #
  def initialize: (?String host, Integer port) -> untyped
end

class Addrinfo
  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - foreach(nodename, service, family=nil, socktype=nil, protocol=nil, flags=nil, timeout: nil, &block)
  # -->
  # iterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo.
  #
  #     Addrinfo.foreach(nil, 80) {|x| p x }
  #     #=> #<Addrinfo: 127.0.0.1:80 TCP (:80)>
  #     #   #<Addrinfo: 127.0.0.1:80 UDP (:80)>
  #     #   #<Addrinfo: [::1]:80 TCP (:80)>
  #     #   #<Addrinfo: [::1]:80 UDP (:80)>
  #
  def self.foreach: (String? nodename, String | Integer service, ?Integer? family, ?Symbol socktype, ?Symbol | Integer protocol, ?Integer flags, ?timeout: Numeric) { (Addrinfo) -> void } -> void
                  | (String? nodename, String | Integer service, ?Integer? family, ?Symbol socktype, ?Symbol | Integer protocol, ?Integer flags, ?timeout: Numeric) -> Enumerable[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags) => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol)        => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family, socktype)                  => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service, family)                            => [addrinfo, ...]
  #   - Addrinfo.getaddrinfo(nodename, service)                                    => [addrinfo, ...]
  # -->
  # returns a list of addrinfo objects as an array.
  #
  # This method converts nodename (hostname) and service (port) to addrinfo. Since
  # the conversion is not unique, the result is a list of addrinfo objects.
  #
  # nodename or service can be nil if no conversion intended.
  #
  # family, socktype and protocol are hint for preferred protocol. If the result
  # will be used for a socket with SOCK_STREAM, SOCK_STREAM should be specified as
  # socktype. If so, Addrinfo.getaddrinfo returns addrinfo list appropriate for
  # SOCK_STREAM. If they are omitted or nil is given, the result is not
  # restricted.
  #
  # Similarly, PF_INET6 as family restricts for IPv6.
  #
  # flags should be bitwise OR of Socket::AI_??? constants such as follows. Note
  # that the exact list of the constants depends on OS.
  #
  #     AI_PASSIVE      Get address to use with bind()
  #     AI_CANONNAME    Fill in the canonical name
  #     AI_NUMERICHOST  Prevent host name resolution
  #     AI_NUMERICSERV  Prevent service name resolution
  #     AI_V4MAPPED     Accept IPv4-mapped IPv6 addresses
  #     AI_ALL          Allow all addresses
  #     AI_ADDRCONFIG   Accept only if any address is assigned
  #
  # Note that socktype should be specified whenever application knows the usage of
  # the address. Some platform causes an error when socktype is omitted and
  # servname is specified as an integer because some port numbers, 512 for
  # example, are ambiguous without socktype.
  #
  #     Addrinfo.getaddrinfo("www.kame.net", 80, nil, :STREAM)
  #     #=> [#<Addrinfo: 203.178.141.194:80 TCP (www.kame.net)>,
  #     #    #<Addrinfo: [2001:200:dff:fff1:216:3eff:feb1:44d7]:80 TCP (www.kame.net)>]
  #
  def self.getaddrinfo: (String nodename, ?String | Integer service, ?Symbol? family, ?Symbol | Integer protocol) -> Array[Addrinfo]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.ip(host) => addrinfo
  # -->
  # returns an addrinfo object for IP address.
  #
  # The port, socktype, protocol of the result is filled by zero. So, it is not
  # appropriate to create a socket.
  #
  #     Addrinfo.ip("localhost") #=> #<Addrinfo: 127.0.0.1 (localhost)>
  #
  def self.ip: (String host) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.tcp(host, port) => addrinfo
  # -->
  # returns an addrinfo object for TCP address.
  #
  #     Addrinfo.tcp("localhost", "smtp") #=> #<Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)>
  #
  def self.tcp: (String host, String | Integer service) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.udp(host, port) => addrinfo
  # -->
  # returns an addrinfo object for UDP address.
  #
  #     Addrinfo.udp("localhost", "daytime") #=> #<Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)>
  #
  def self.udp: (String host, String | Integer service) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.unix(path [, socktype]) => addrinfo
  # -->
  # returns an addrinfo object for UNIX socket address.
  #
  # *socktype* specifies the socket type. If it is omitted, :STREAM is used.
  #
  #     Addrinfo.unix("/tmp/sock")         #=> #<Addrinfo: /tmp/sock SOCK_STREAM>
  #     Addrinfo.unix("/tmp/sock", :DGRAM) #=> #<Addrinfo: /tmp/sock SOCK_DGRAM>
  #
  def self.unix: (String path, ?Symbol socktype) -> Addrinfo

  public

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.afamily => integer
  # -->
  # returns the address family as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).afamily == Socket::AF_INET #=> true
  #
  def afamily: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - bind() { |sock| ... }
  # -->
  # creates a socket bound to self.
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.udp("0.0.0.0", 9981).bind {|s|
  #       s.local_address.connect {|s| s.send "hello", 0 }
  #       p s.recv(10) #=> "hello"
  #     }
  #
  def bind: () -> Socket
          | () { (Socket) -> void } -> void

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.canonname => string or nil
  # -->
  # returns the canonical name as a string.
  #
  # nil is returned if no canonical name.
  #
  # The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is
  # specified.
  #
  #     list = Addrinfo.getaddrinfo("www.ruby-lang.org", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
  #     p list[0] #=> #<Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org)>
  #     p list[0].canonname #=> "carbon.ruby-lang.org"
  #
  def canonname: () -> String

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect([opts]) {|socket| ... }
  #   - addrinfo.connect([opts])
  # -->
  # creates a socket connected to the address of self.
  #
  # The optional argument *opts* is options represented by a hash. *opts* may have
  # following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect: (?timeout: Numeric) { (Socket) -> void } -> void
             | (?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect_from([local_addr_args], [opts]) {|socket| ... }
  #   - addrinfo.connect_from([local_addr_args], [opts])
  # -->
  # creates a socket connected to the address of self.
  #
  # If one or more arguments given as *local_addr_args*, it is used as the local
  # address of the socket. *local_addr_args* is given for family_addrinfo to
  # obtain actual address.
  #
  # If *local_addr_args* is not given, the local address of the socket is not
  # bound.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect_from("0.0.0.0", 4649) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  #     # Addrinfo object can be taken for the argument.
  #     Addrinfo.tcp("www.ruby-lang.org", 80).connect_from(Addrinfo.tcp("0.0.0.0", 4649)) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect_from: (String host, Integer port, ?timeout: Numeric) { (Socket) -> void } -> void
                  | (String host, Integer port, ?timeout: Numeric) -> Socket
                  | (Addrinfo sockaddr, ?timeout: Numeric) { (Socket) -> void } -> void
                  | (Addrinfo sockaddr, ?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - addrinfo.connect_to([remote_addr_args], [opts]) {|socket| ... }
  #   - addrinfo.connect_to([remote_addr_args], [opts])
  # -->
  # creates a socket connected to *remote_addr_args* and bound to self.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :timeout
  # :   specify the timeout in seconds.
  #
  #
  # If a block is given, it is called with the socket and the value of the block
  # is returned. The socket is returned otherwise.
  #
  #     Addrinfo.tcp("0.0.0.0", 4649).connect_to("www.ruby-lang.org", 80) {|s|
  #       s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       puts s.read
  #     }
  #
  def connect_to: (String host, Integer port, ?timeout: Numeric) { (Socket) -> void } -> void
                | (String host, Integer port, ?timeout: Numeric) -> Socket
                | (Addrinfo sockaddr, ?timeout: Numeric) { (Socket) -> void } -> void
                | (Addrinfo sockaddr, ?timeout: Numeric) -> Socket

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - family_addrinfo(*args)
  # -->
  # creates an Addrinfo object from the arguments.
  #
  # The arguments are interpreted as similar to self.
  #
  #     Addrinfo.tcp("0.0.0.0", 4649).family_addrinfo("www.ruby-lang.org", 80)
  #     #=> #<Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)>
  #
  #     Addrinfo.unix("/tmp/sock").family_addrinfo("/tmp/sock2")
  #     #=> #<Addrinfo: /tmp/sock2 SOCK_STREAM>
  #
  def family_addrinfo: (String host, Integer port) -> Addrinfo
                     | (String path) -> Addrinfo

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.getnameinfo        => [nodename, service]
  #   - addrinfo.getnameinfo(flags) => [nodename, service]
  # -->
  # returns nodename and service as a pair of strings. This converts struct
  # sockaddr in addrinfo to textual representation.
  #
  # flags should be bitwise OR of Socket::NI_??? constants.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).getnameinfo #=> ["localhost", "www"]
  #
  #     Addrinfo.tcp("127.0.0.1", 80).getnameinfo(Socket::NI_NUMERICSERV)
  #     #=> ["localhost", "80"]
  #
  def getnameinfo: (?Integer flags) -> [ String, Integer ]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.inspect => string
  # -->
  # returns a string which shows addrinfo in human-readable form.
  #
  #     Addrinfo.tcp("localhost", 80).inspect #=> "#<Addrinfo: 127.0.0.1:80 TCP (localhost)>"
  #     Addrinfo.unix("/tmp/sock").inspect    #=> "#<Addrinfo: /tmp/sock SOCK_STREAM>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.inspect_sockaddr => string
  # -->
  # returns a string which shows the sockaddr in *addrinfo* with human-readable
  # form.
  #
  #     Addrinfo.tcp("localhost", 80).inspect_sockaddr     #=> "127.0.0.1:80"
  #     Addrinfo.tcp("ip6-localhost", 80).inspect_sockaddr #=> "[::1]:80"
  #     Addrinfo.unix("/tmp/sock").inspect_sockaddr        #=> "/tmp/sock"
  #
  def inspect_sockaddr: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip? => true or false
  # -->
  # returns true if addrinfo is internet (IPv4/IPv6) address. returns false
  # otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip? #=> true
  #     Addrinfo.tcp("::1", 80).ip?       #=> true
  #     Addrinfo.unix("/tmp/sock").ip?    #=> false
  #
  def ip?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_address => string
  # -->
  # Returns the IP address as a string.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_address    #=> "127.0.0.1"
  #     Addrinfo.tcp("::1", 80).ip_address          #=> "::1"
  #
  def ip_address: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_port => port
  # -->
  # Returns the port number as an integer.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_port    #=> 80
  #     Addrinfo.tcp("::1", 80).ip_port          #=> 80
  #
  def ip_port: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ip_unpack => [addr, port]
  # -->
  # Returns the IP address and port number as 2-element array.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ip_unpack    #=> ["127.0.0.1", 80]
  #     Addrinfo.tcp("::1", 80).ip_unpack          #=> ["::1", 80]
  #
  def ip_unpack: () -> [ String, Integer ]

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ipv4? => true or false
  # -->
  # returns true if addrinfo is IPv4 address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ipv4? #=> true
  #     Addrinfo.tcp("::1", 80).ipv4?       #=> false
  #     Addrinfo.unix("/tmp/sock").ipv4?    #=> false
  #
  def ipv4?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_loopback?()
  # -->
  # Returns true for IPv4 loopback address (127.0.0.0/8). It returns false
  # otherwise.
  #
  def ipv4_loopback?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_multicast?()
  # -->
  # Returns true for IPv4 multicast address (224.0.0.0/4). It returns false
  # otherwise.
  #
  def ipv4_multicast?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv4_private?()
  # -->
  # Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,
  # 192.168.0.0/16). It returns false otherwise.
  #
  def ipv4_private?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.ipv6? => true or false
  # -->
  # returns true if addrinfo is IPv6 address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).ipv6? #=> false
  #     Addrinfo.tcp("::1", 80).ipv6?       #=> true
  #     Addrinfo.unix("/tmp/sock").ipv6?    #=> false
  #
  def ipv6?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_linklocal?()
  # -->
  # Returns true for IPv6 link local address (ff80::/10). It returns false
  # otherwise.
  #
  def ipv6_linklocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_loopback?()
  # -->
  # Returns true for IPv6 loopback address (::1). It returns false otherwise.
  #
  def ipv6_loopback?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_global?()
  # -->
  # Returns true for IPv6 multicast global scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_global?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_linklocal?()
  # -->
  # Returns true for IPv6 multicast link-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_linklocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_nodelocal?()
  # -->
  # Returns true for IPv6 multicast node-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_nodelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_orglocal?()
  # -->
  # Returns true for IPv6 multicast organization-local scope address. It returns
  # false otherwise.
  #
  def ipv6_mc_orglocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_mc_sitelocal?()
  # -->
  # Returns true for IPv6 multicast site-local scope address. It returns false
  # otherwise.
  #
  def ipv6_mc_sitelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_multicast?()
  # -->
  # Returns true for IPv6 multicast address (ff00::/8). It returns false
  # otherwise.
  #
  def ipv6_multicast?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_sitelocal?()
  # -->
  # Returns true for IPv6 site local address (ffc0::/10). It returns false
  # otherwise.
  #
  def ipv6_sitelocal?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_to_ipv4()
  # -->
  # Returns IPv4 address of IPv4 mapped/compatible IPv6 address. It returns nil if
  # `self` is not IPv4 mapped/compatible IPv6 address.
  #
  #     Addrinfo.ip("::192.0.2.3").ipv6_to_ipv4      #=> #<Addrinfo: 192.0.2.3>
  #     Addrinfo.ip("::ffff:192.0.2.3").ipv6_to_ipv4 #=> #<Addrinfo: 192.0.2.3>
  #     Addrinfo.ip("::1").ipv6_to_ipv4              #=> nil
  #     Addrinfo.ip("192.0.2.3").ipv6_to_ipv4        #=> nil
  #     Addrinfo.unix("/tmp/sock").ipv6_to_ipv4      #=> nil
  #
  def ipv6_to_ipv4: () -> Addrinfo?

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_unique_local?()
  # -->
  # Returns true for IPv6 unique local address (fc00::/7, RFC4193). It returns
  # false otherwise.
  #
  def ipv6_unique_local?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_unspecified?()
  # -->
  # Returns true for IPv6 unspecified address (::). It returns false otherwise.
  #
  def ipv6_unspecified?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_v4compat?()
  # -->
  # Returns true for IPv4-compatible IPv6 address (::/80). It returns false
  # otherwise.
  #
  def ipv6_v4compat?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - ipv6_v4mapped?()
  # -->
  # Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80). It returns false
  # otherwise.
  #
  def ipv6_v4mapped?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/lib/socket.rb
  #   - listen(backlog=Socket::SOMAXCONN) { |sock| ... }
  # -->
  # creates a listening socket bound to self.
  #
  def listen: (Integer backlog) -> void

  def marshal_dump: () -> String

  def marshal_load: (String) -> instance

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.pfamily => integer
  # -->
  # returns the protocol family as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).pfamily == Socket::PF_INET #=> true
  #
  def pfamily: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.protocol => integer
  # -->
  # returns the socket type as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).protocol == Socket::IPPROTO_TCP #=> true
  #
  def protocol: () -> Integer

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.socktype => integer
  # -->
  # returns the socket type as an integer.
  #
  #     Addrinfo.tcp("localhost", 80).socktype == Socket::SOCK_STREAM #=> true
  #
  def socktype: () -> Integer

  # <!-- rdoc-file=ext/socket/raddrinfo.c -->
  # returns the socket address as packed struct sockaddr string.
  #
  #     Addrinfo.tcp("localhost", 80).to_sockaddr
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.to_sockaddr => string
  #   - addrinfo.to_s => string
  # -->
  # returns the socket address as packed struct sockaddr string.
  #
  #     Addrinfo.tcp("localhost", 80).to_sockaddr
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  def to_sockaddr: () -> String

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.unix? => true or false
  # -->
  # returns true if addrinfo is UNIX address. returns false otherwise.
  #
  #     Addrinfo.tcp("127.0.0.1", 80).unix? #=> false
  #     Addrinfo.tcp("::1", 80).unix?       #=> false
  #     Addrinfo.unix("/tmp/sock").unix?    #=> true
  #
  def unix?: () -> bool

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - addrinfo.unix_path => path
  # -->
  # Returns the socket path as a string.
  #
  #     Addrinfo.unix("/tmp/sock").unix_path       #=> "/tmp/sock"
  #
  def unix_path: () -> String

  private

  # <!--
  #   rdoc-file=ext/socket/raddrinfo.c
  #   - Addrinfo.new(sockaddr)                             => addrinfo
  #   - Addrinfo.new(sockaddr, family)                     => addrinfo
  #   - Addrinfo.new(sockaddr, family, socktype)           => addrinfo
  #   - Addrinfo.new(sockaddr, family, socktype, protocol) => addrinfo
  # -->
  # returns a new instance of Addrinfo. The instance contains sockaddr, family,
  # socktype, protocol. sockaddr means struct sockaddr which can be used for
  # connect(2), etc. family, socktype and protocol are integers which is used for
  # arguments of socket(2).
  #
  # sockaddr is specified as an array or a string. The array should be compatible
  # to the value of IPSocket#addr or UNIXSocket#addr. The string should be struct
  # sockaddr as generated by Socket.sockaddr_in or Socket.unpack_sockaddr_un.
  #
  # sockaddr examples:
  #
  #     "AF_INET", 46102, "localhost.localdomain", "127.0.0.1"
  # :
  #
  #     "AF_INET6", 42304, "ip6-localhost", "::1"
  # :
  #
  #     "AF_UNIX", "/tmp/sock"
  # :
  # *   Socket.sockaddr_in("smtp", "2001:DB8::1")
  # *   Socket.sockaddr_in(80, "172.18.22.42")
  # *   Socket.sockaddr_in(80, "www.ruby-lang.org")
  # *   Socket.sockaddr_un("/tmp/sock")
  #
  #
  # In an AF_INET/AF_INET6 sockaddr array, the 4th element, numeric IP address, is
  # used to construct socket address in the Addrinfo instance. If the 3rd element,
  # textual host name, is non-nil, it is also recorded but used only for
  # Addrinfo#inspect.
  #
  # family is specified as an integer to specify the protocol family such as
  # Socket::PF_INET. It can be a symbol or a string which is the constant name
  # with or without PF_ prefix such as :INET, :INET6, :UNIX, "PF_INET", etc. If
  # omitted, PF_UNSPEC is assumed.
  #
  # socktype is specified as an integer to specify the socket type such as
  # Socket::SOCK_STREAM. It can be a symbol or a string which is the constant name
  # with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, "SOCK_STREAM",
  # etc. If omitted, 0 is assumed.
  #
  # protocol is specified as an integer to specify the protocol such as
  # Socket::IPPROTO_TCP. It must be an integer, unlike family and socktype. If
  # omitted, 0 is assumed. Note that 0 is reasonable value for most protocols,
  # except raw socket.
  #
  def initialize: (String sockaddr, ?Symbol family, ?(Symbol | Integer)? socktype, ?Integer? protocol) -> untyped
end

# <!-- rdoc-file=ext/objspace/objspace.c -->
# The objspace library extends the ObjectSpace module and adds several methods
# to get internal statistic information about object/memory management.
#
# You need to `require 'objspace'` to use this extension module.
#
# Generally, you *SHOULD NOT* use this library if you do not know about the MRI
# implementation.  Mainly, this library is for (memory) profiler developers and
# MRI developers who need to know about MRI memory usage.
#
%a{annotate:rdoc:source:from=ext/objspace}
module ObjectSpace
  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_class_path(object) -> string
  # -->
  # Returns the class for the given `object`.
  #
  #     class A
  #       def foo
  #         ObjectSpace::trace_object_allocations do
  #           obj = Object.new
  #           p "#{ObjectSpace::allocation_class_path(obj)}"
  #         end
  #       end
  #     end
  #
  #     A.new.foo #=> "Class"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_class_path: (untyped) -> String

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_generation(object) -> integer or nil
  # -->
  # Returns garbage collector generation for the given `object`.
  #
  #     class B
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "Generation is #{allocation_generation(obj)}"
  #         end
  #       end
  #     end
  #
  #     B.new.foo #=> "Generation is 3"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_generation: (untyped) -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_method_id(object) -> string
  # -->
  # Returns the method identifier for the given `object`.
  #
  #     class A
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "#{allocation_class_path(obj)}##{allocation_method_id(obj)}"
  #         end
  #       end
  #     end
  #
  #     A.new.foo #=> "Class#new"
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_method_id: (untyped) -> Symbol

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_sourcefile(object) -> string
  # -->
  # Returns the source file origin from the given `object`.
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_sourcefile: (untyped) -> String

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - allocation_sourceline(object) -> integer
  # -->
  # Returns the original line from source for from the given `object`.
  #
  # See ::trace_object_allocations for more information and examples.
  #
  def self?.allocation_sourceline: (untyped) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_imemo_objects([result_hash]) -> hash
  # -->
  # Counts objects for each `T_IMEMO` type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {:imemo_ifunc=>8,
  #      :imemo_svar=>7,
  #      :imemo_cref=>509,
  #      :imemo_memo=>1,
  #      :imemo_throw_data=>1}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation specific and may change in
  # the future.
  #
  # In this version, keys are symbol objects.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_imemo_objects: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_nodes([result_hash]) -> hash
  # -->
  # Counts nodes for each node type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {:NODE_METHOD=>2027, :NODE_FBODY=>1927, :NODE_CFUNC=>1798, ...}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # Note: The contents of the returned hash is implementation defined. It may be
  # changed in future.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_nodes: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_objects_size([result_hash]) -> hash
  # -->
  # Counts objects size (in bytes) for each type.
  #
  # Note that this information is incomplete.  You need to deal with this
  # information as only a **HINT**.  Especially, total size of T_DATA may be
  # wrong.
  #
  # It returns a hash as:
  #     {:TOTAL=>1461154, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249, ...}
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation defined. It may be changed
  # in future.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_objects_size: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_symbols([result_hash]) -> hash
  # -->
  # Counts symbols for each Symbol type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # Note: The contents of the returned hash is implementation defined. It may be
  # changed in future.
  #
  # This method is only expected to work with C Ruby.
  #
  # On this version of MRI, they have 3 types of Symbols (and 1 total counts).
  #
  #     * mortal_dynamic_symbol: GC target symbols (collected by GC)
  #     * immortal_dynamic_symbol: Immortal symbols promoted from dynamic symbols (do not collected by GC)
  #     * immortal_static_symbol: Immortal symbols (do not collected by GC)
  #     * immortal_symbol: total immortal symbols (immortal_dynamic_symbol+immortal_static_symbol)
  #
  def self?.count_symbols: (?Hash[Symbol, Integer] result_hash) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.count_tdata_objects([result_hash]) -> hash
  # -->
  # Counts objects for each `T_DATA` type.
  #
  # This method is only for MRI developers interested in performance and memory
  # usage of Ruby programs.
  #
  # It returns a hash as:
  #
  #     {RubyVM::InstructionSequence=>504, :parser=>5, :barrier=>6,
  #      :mutex=>6, Proc=>60, RubyVM::Env=>57, Mutex=>1, Encoding=>99,
  #      ThreadGroup=>1, Binding=>1, Thread=>1, RubyVM=>1, :iseq=>1,
  #      Random=>1, ARGF.class=>1, Data=>1, :autoload=>3, Time=>2}
  #     # T_DATA objects existing at startup on r32276.
  #
  # If the optional argument, result_hash, is given, it is overwritten and
  # returned. This is intended to avoid probe effect.
  #
  # The contents of the returned hash is implementation specific and may change in
  # the future.
  #
  # In this version, keys are Class object or Symbol object.
  #
  # If object is kind of normal (accessible) object, the key is Class object. If
  # object is not a kind of normal (internal) object, the key is symbol name,
  # registered by rb_data_type_struct.
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.count_tdata_objects: (?Hash[untyped, Integer] result_hash) -> Hash[untyped, Integer]

  # <!--
  #   rdoc-file=ext/objspace/lib/objspace.rb
  #   - ObjectSpace.dump(obj[, output: :string]) # => "{ ... }"
  #   - ObjectSpace.dump(obj, output: :file)     # => #<File:/tmp/rubyobj20131125-88733-1xkfmpv.json>
  #   - ObjectSpace.dump(obj, output: :stdout)   # => nil
  # -->
  # Dump the contents of a ruby object as JSON.
  #
  # This method is only expected to work with C Ruby. This is an experimental
  # method and is subject to change. In particular, the function signature and
  # output format are not guaranteed to be compatible in future versions of ruby.
  #
  def self?.dump: (untyped obj, ?output: Symbol) -> (String | File | nil)

  # <!--
  #   rdoc-file=ext/objspace/lib/objspace.rb
  #   - ObjectSpace.dump_all([output: :file]) # => #<File:/tmp/rubyheap20131125-88469-laoj3v.json>
  #   - ObjectSpace.dump_all(output: :stdout) # => nil
  #   - ObjectSpace.dump_all(output: :string) # => "{...}\n{...}\n..."
  #   - ObjectSpace.dump_all(output:
  #   - File.open('heap.json','w'))         # => #<File:heap.json>
  #   - ObjectSpace.dump_all(output: :string,
  #   - since: 42)                          # => "{...}\n{...}\n..."
  # -->
  # Dump the contents of the ruby heap as JSON.
  #
  # *since* must be a non-negative integer or `nil`.
  #
  # If *since* is a positive integer, only objects of that generation and newer
  # generations are dumped. The current generation can be accessed using
  # GC::count.
  #
  # Objects that were allocated without object allocation tracing enabled are
  # ignored. See ::trace_object_allocations for more information and examples.
  #
  # If *since* is omitted or is `nil`, all objects are dumped.
  #
  # This method is only expected to work with C Ruby. This is an experimental
  # method and is subject to change. In particular, the function signature and
  # output format are not guaranteed to be compatible in future versions of ruby.
  #
  def self?.dump_all: (?since: Integer | nil, ?full: boolish, ?output: Symbol) -> (String | File | nil)

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.internal_class_of(obj) -> Class or Module
  # -->
  # MRI specific feature
  # :   Return internal class of obj.
  #
  # obj can be an instance of InternalObjectWrapper.
  #
  # Note that you should not use this method in your application.
  #
  def self?.internal_class_of: (untyped) -> Class

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.internal_super_of(cls) -> Class or Module
  # -->
  # MRI specific feature
  # :   Return internal super class of cls (Class or Module).
  #
  # obj can be an instance of InternalObjectWrapper.
  #
  # Note that you should not use this method in your application.
  #
  def self?.internal_super_of: (untyped) -> untyped

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.memsize_of(obj) -> Integer
  # -->
  # Return consuming memory size of obj in bytes.
  #
  # Note that the return size is incomplete.  You need to deal with this
  # information as only a **HINT**. Especially, the size of `T_DATA` may not be
  # correct.
  #
  # This method is only expected to work with C Ruby.
  #
  # From Ruby 2.2, memsize_of(obj) returns a memory size includes sizeof(RVALUE).
  #
  def self?.memsize_of: (untyped) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.memsize_of_all([klass]) -> Integer
  # -->
  # Return consuming memory size of all living objects in bytes.
  #
  # If `klass` (should be Class object) is given, return the total memory size of
  # instances of the given class.
  #
  # Note that the returned size is incomplete. You need to deal with this
  # information as only a **HINT**. Especially, the size of `T_DATA` may not be
  # correct.
  #
  # Note that this method does **NOT** return total malloc'ed memory size.
  #
  # This method can be defined by the following Ruby code:
  #
  #     def memsize_of_all klass = false
  #       total = 0
  #       ObjectSpace.each_object{|e|
  #         total += ObjectSpace.memsize_of(e) if klass == false || e.kind_of?(klass)
  #       }
  #       total
  #     end
  #
  # This method is only expected to work with C Ruby.
  #
  def self?.memsize_of_all: (?Class) -> Integer

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.reachable_objects_from(obj) -> array or nil
  # -->
  # MRI specific feature
  # :   Return all reachable objects from `obj'.
  #
  #
  # This method returns all reachable objects from `obj'.
  #
  # If `obj' has two or more references to the same object `x', then returned
  # array only includes one `x' object.
  #
  # If `obj' is a non-markable (non-heap management) object such as true, false,
  # nil, symbols and Fixnums (and Flonum) then it simply returns nil.
  #
  # If `obj' has references to an internal object, then it returns instances of
  # ObjectSpace::InternalObjectWrapper class. This object contains a reference to
  # an internal object and you can check the type of internal object with `type'
  # method.
  #
  # If `obj' is instance of ObjectSpace::InternalObjectWrapper class, then this
  # method returns all reachable object from an internal object, which is pointed
  # by `obj'.
  #
  # With this method, you can find memory leaks.
  #
  # This method is only expected to work except with C Ruby.
  #
  # Example:
  #     ObjectSpace.reachable_objects_from(['a', 'b', 'c'])
  #     #=> [Array, 'a', 'b', 'c']
  #
  #     ObjectSpace.reachable_objects_from(['a', 'a', 'a'])
  #     #=> [Array, 'a', 'a', 'a'] # all 'a' strings have different object id
  #
  #     ObjectSpace.reachable_objects_from([v = 'a', v, v])
  #     #=> [Array, 'a']
  #
  #     ObjectSpace.reachable_objects_from(1)
  #     #=> nil # 1 is not markable (heap managed) object
  #
  def self?.reachable_objects_from: (untyped) -> ([ untyped ] | nil)

  # <!--
  #   rdoc-file=ext/objspace/objspace.c
  #   - ObjectSpace.reachable_objects_from_root -> hash
  # -->
  # MRI specific feature
  # :   Return all reachable objects from root.
  #
  def self?.reachable_objects_from_root: () -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations { block }
  # -->
  # Starts tracing object allocations from the ObjectSpace extension module.
  #
  # For example:
  #
  #     require 'objspace'
  #
  #     class C
  #       include ObjectSpace
  #
  #       def foo
  #         trace_object_allocations do
  #           obj = Object.new
  #           p "#{allocation_sourcefile(obj)}:#{allocation_sourceline(obj)}"
  #         end
  #       end
  #     end
  #
  #     C.new.foo #=> "objtrace.rb:8"
  #
  # This example has included the ObjectSpace module to make it easier to read,
  # but you can also use the ::trace_object_allocations notation (recommended).
  #
  # Note that this feature introduces a huge performance decrease and huge memory
  # consumption.
  #
  def self.trace_object_allocations: () { (untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_clear
  # -->
  # Clear recorded tracing information.
  #
  def self?.trace_object_allocations_clear: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_debug_start()
  # -->
  #
  def self?.trace_object_allocations_debug_start: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_start
  # -->
  # Starts tracing object allocations.
  #
  def self?.trace_object_allocations_start: () -> void

  # <!--
  #   rdoc-file=ext/objspace/object_tracing.c
  #   - trace_object_allocations_stop
  # -->
  # Stop tracing object allocations.
  #
  # Note that if ::trace_object_allocations_start is called n-times, then tracing
  # will stop after calling ::trace_object_allocations_stop n-times.
  #
  def self?.trace_object_allocations_stop: () -> void
end

# <!-- rdoc-file=lib/forwardable.rb -->
# The Forwardable module provides delegation of specified methods to a
# designated object, using the methods #def_delegator and #def_delegators.
#
# For example, say you have a class RecordCollection which contains an array
# `@records`.  You could provide the lookup method #record_number(), which
# simply calls #[] on the `@records` array, like this:
#
#     require 'forwardable'
#
#     class RecordCollection
#       attr_accessor :records
#       extend Forwardable
#       def_delegator :@records, :[], :record_number
#     end
#
# We can use the lookup method like so:
#
#     r = RecordCollection.new
#     r.records = [4,5,6]
#     r.record_number(0)  # => 4
#
# Further, if you wish to provide the methods #size, #<<, and #map, all of which
# delegate to @records, this is how you can do it:
#
#     class RecordCollection # re-open RecordCollection class
#       def_delegators :@records, :size, :<<, :map
#     end
#
#     r = RecordCollection.new
#     r.records = [1,2,3]
#     r.record_number(0)   # => 1
#     r.size               # => 3
#     r << 4               # => [1, 2, 3, 4]
#     r.map { |x| x * 2 }  # => [2, 4, 6, 8]
#
# You can even extend regular objects with Forwardable.
#
#     my_hash = Hash.new
#     my_hash.extend Forwardable              # prepare object for delegation
#     my_hash.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
#     my_hash.puts "Howdy!"
#
# ## Another example
#
# You could use Forwardable as an alternative to inheritance, when you don't
# want to inherit all methods from the superclass. For instance, here is how you
# might add a range of `Array` instance methods to a new class `Queue`:
#
#     class Queue
#       extend Forwardable
#
#       def initialize
#         @q = [ ]    # prepare delegate object
#       end
#
#       # setup preferred interface, enq() and deq()...
#       def_delegator :@q, :push, :enq
#       def_delegator :@q, :shift, :deq
#
#       # support some general Array methods that fit Queues well
#       def_delegators :@q, :clear, :first, :push, :shift, :size
#     end
#
#     q = Thread::Queue.new
#     q.enq 1, 2, 3, 4, 5
#     q.push 6
#
#     q.shift    # => 1
#     while q.size > 0
#       puts q.deq
#     end
#
#     q.enq "Ruby", "Perl", "Python"
#     puts q.first
#     q.clear
#     puts q.first
#
# This should output:
#
#     2
#     3
#     4
#     5
#     6
#     Ruby
#     nil
#
# ## Notes
#
# Be advised, RDoc will not detect delegated methods.
#
# `forwardable.rb` provides single-method delegation via the def_delegator and
# def_delegators methods. For full-class delegation via DelegateClass, see
# `delegate.rb`.
#
module Forwardable
  # <!-- rdoc-file=lib/forwardable.rb -->
  # Version of `forwardable.rb`
  #
  VERSION: String

  FORWARDABLE_VERSION: String

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate method => accessor
  #   - delegate [method, method, ...] => accessor
  # -->
  # Takes a hash as its argument.  The key is a symbol or an array of symbols.
  # These symbols correspond to method names, instance variable names, or constant
  # names (see def_delegator).  The value is the accessor to which the methods
  # will be delegated.
  #
  def instance_delegate: (Hash[Symbol | Array[Symbol], Symbol] hash) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate(hash)
  # -->
  #
  alias delegate instance_delegate

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_instance_delegators(accessor, *methods)
  # -->
  # Shortcut for defining multiple delegator methods, but with no provision for
  # using a different name.  The following two code samples have the same effect:
  #
  #     def_delegators :@records, :size, :<<, :map
  #
  #     def_delegator :@records, :size
  #     def_delegator :@records, :<<
  #     def_delegator :@records, :map
  #
  def def_instance_delegators: (Symbol | String accessor, *Symbol methods) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegators(accessor, *methods)
  # -->
  #
  alias def_delegators def_instance_delegators

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_instance_delegator(accessor, method, ali = method)
  # -->
  # Define `method` as delegator instance method with an optional alias name
  # `ali`. Method calls to `ali` will be delegated to `accessor.method`.
  # `accessor` should be a method name, instance variable name, or constant name.
  # Use the full path to the constant if providing the constant name. Returns the
  # name of the method defined.
  #
  #     class MyQueue
  #       CONST = 1
  #       extend Forwardable
  #       attr_reader :queue
  #       def initialize
  #         @queue = []
  #       end
  #
  #       def_delegator :@queue, :push, :mypush
  #       def_delegator 'MyQueue::CONST', :to_i
  #     end
  #
  #     q = MyQueue.new
  #     q.mypush 42
  #     q.queue    #=> [42]
  #     q.push 23  #=> NoMethodError
  #     q.to_i     #=> 1
  #
  def def_instance_delegator: (Symbol | String accessor, Symbol method, ?Symbol ali) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegator(accessor, method, ali = method)
  # -->
  #
  alias def_delegator def_instance_delegator
end

# <!-- rdoc-file=lib/forwardable.rb -->
# SingleForwardable can be used to setup delegation at the object level as well.
#
#     printer = String.new
#     printer.extend SingleForwardable        # prepare object for delegation
#     printer.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
#     printer.puts "Howdy!"
#
# Also, SingleForwardable can be used to set up delegation for a Class or
# Module.
#
#     class Implementation
#       def self.service
#         puts "serviced!"
#       end
#     end
#
#     module Facade
#       extend SingleForwardable
#       def_delegator :Implementation, :service
#     end
#
#     Facade.service #=> serviced!
#
# If you want to use both Forwardable and SingleForwardable, you can use methods
# def_instance_delegator and def_single_delegator, etc.
#
module SingleForwardable
  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate method => accessor
  #   - delegate [method, method, ...] => accessor
  # -->
  # Takes a hash as its argument.  The key is a symbol or an array of symbols.
  # These symbols correspond to method names.  The value is the accessor to which
  # the methods will be delegated.
  #
  def single_delegate: (Hash[Symbol | Array[Symbol], Symbol] hash) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - delegate(hash)
  # -->
  #
  alias delegate single_delegate

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_single_delegators(accessor, *methods)
  # -->
  # Shortcut for defining multiple delegator methods, but with no provision for
  # using a different name.  The following two code samples have the same effect:
  #
  #     def_delegators :@records, :size, :<<, :map
  #
  #     def_delegator :@records, :size
  #     def_delegator :@records, :<<
  #     def_delegator :@records, :map
  #
  def def_single_delegators: (Symbol | String accessor, *Symbol methods) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegators(accessor, *methods)
  # -->
  #
  alias def_delegators def_single_delegators

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_single_delegator(accessor, method, new_name=method)
  # -->
  # Defines a method *method* which delegates to *accessor* (i.e. it calls the
  # method of the same name in *accessor*).  If *new_name* is provided, it is used
  # as the name for the delegate method. Returns the name of the method defined.
  #
  def def_single_delegator: (Symbol | String accessor, Symbol method, ?Symbol ali) -> void

  # <!--
  #   rdoc-file=lib/forwardable.rb
  #   - def_delegator(accessor, method, ali = method)
  # -->
  #
  alias def_delegator def_single_delegator
end

# <!-- rdoc-file=lib/tempfile.rb -->
# A utility class for managing temporary files. When you create a Tempfile
# object, it will create a temporary file with a unique filename. A Tempfile
# objects behaves just like a File object, and you can perform all the usual
# file operations on it: reading data, writing data, changing its permissions,
# etc. So although this class does not explicitly document all instance methods
# supported by File, you can in fact call any File instance method on a Tempfile
# object.
#
# ## Synopsis
#
#     require 'tempfile'
#
#     file = Tempfile.new('foo')
#     file.path      # => A unique filename in the OS's temp directory,
#                    #    e.g.: "/tmp/foo.24722.0"
#                    #    This filename contains 'foo' in its basename.
#     file.write("hello world")
#     file.rewind
#     file.read      # => "hello world"
#     file.close
#     file.unlink    # deletes the temp file
#
# ## Good practices
#
# ### Explicit close
#
# When a Tempfile object is garbage collected, or when the Ruby interpreter
# exits, its associated temporary file is automatically deleted. This means that
# it's unnecessary to explicitly delete a Tempfile after use, though it's a good
# practice to do so: not explicitly deleting unused Tempfiles can potentially
# leave behind a large number of temp files on the filesystem until they're
# garbage collected. The existence of these temp files can make it harder to
# determine a new Tempfile filename.
#
# Therefore, one should always call #unlink or close in an ensure block, like
# this:
#
#     file = Tempfile.new('foo')
#     begin
#        # ...do something with file...
#     ensure
#        file.close
#        file.unlink   # deletes the temp file
#     end
#
# Tempfile.create { ... } exists for this purpose and is more convenient to use.
# Note that Tempfile.create returns a File instance instead of a Tempfile, which
# also avoids the overhead and complications of delegation.
#
#     Tempfile.open('foo') do |file|
#        # ...do something with file...
#     end
#
# ### Unlink after creation
#
# On POSIX systems, it's possible to unlink a file right after creating it, and
# before closing it. This removes the filesystem entry without closing the file
# handle, so it ensures that only the processes that already had the file handle
# open can access the file's contents. It's strongly recommended that you do
# this if you do not want any other processes to be able to read from or write
# to the Tempfile, and you do not need to know the Tempfile's filename either.
#
# For example, a practical use case for unlink-after-creation would be this: you
# need a large byte buffer that's too large to comfortably fit in RAM, e.g. when
# you're writing a web server and you want to buffer the client's file upload
# data.
#
# Please refer to #unlink for more information and a code example.
#
# ## Minor notes
#
# Tempfile's filename picking method is both thread-safe and inter-process-safe:
# it guarantees that no other threads or processes will pick the same filename.
#
# Tempfile itself however may not be entirely thread-safe. If you access the
# same Tempfile object from multiple threads then you should protect it with a
# mutex.
#
class Tempfile < File
  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - create(basename="", tmpdir=nil, mode: 0, **options) { |tmpfile| ... }
  # -->
  # Creates a temporary file as a usual File object (not a Tempfile). It does not
  # use finalizer and delegation, which makes it more efficient and reliable.
  #
  # If no block is given, this is similar to Tempfile.new except creating File
  # instead of Tempfile. In that case, the created file is not removed
  # automatically. You should use File.unlink to remove it.
  #
  # If a block is given, then a File object will be constructed, and the block is
  # invoked with the object as the argument. The File object will be automatically
  # closed and the temporary file is removed after the block terminates, releasing
  # all resources that the block created. The call returns the value of the block.
  #
  # In any case, all arguments (`basename`, `tmpdir`, `mode`, and `**options`)
  # will be treated the same as for Tempfile.new.
  #
  #     Tempfile.create('foo', '/home/temp') do |f|
  #        # ... do something with f ...
  #     end
  #
  def self.create: (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) -> File
                 | [A] (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) { (File) -> A } -> A

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - open(*args, **kw) { |tempfile| ... }
  # -->
  # Creates a new Tempfile.
  #
  # This method is not recommended and exists mostly for backward compatibility.
  # Please use Tempfile.create instead, which avoids the cost of delegation, does
  # not rely on a finalizer, and also unlinks the file when given a block.
  #
  # Tempfile.open is still appropriate if you need the Tempfile to be unlinked by
  # a finalizer and you cannot explicitly know where in the program the Tempfile
  # can be unlinked safely.
  #
  # If no block is given, this is a synonym for Tempfile.new.
  #
  # If a block is given, then a Tempfile object will be constructed, and the block
  # is run with the Tempfile object as argument. The Tempfile object will be
  # automatically closed after the block terminates. However, the file will
  # **not** be unlinked and needs to be manually unlinked with Tempfile#close! or
  # Tempfile#unlink. The finalizer will try to unlink but should not be relied
  # upon as it can keep the file on the disk much longer than intended. For
  # instance, on CRuby, finalizers can be delayed due to conservative stack
  # scanning and references left in unused memory.
  #
  # The call returns the value of the block.
  #
  # In any case, all arguments (`*args`) will be passed to Tempfile.new.
  #
  #     Tempfile.open('foo', '/home/temp') do |f|
  #        # ... do something with f ...
  #     end
  #
  #     # Equivalent:
  #     f = Tempfile.open('foo', '/home/temp')
  #     begin
  #        # ... do something with f ...
  #     ensure
  #        f.close
  #     end
  #
  def self.open: (*untyped args, **untyped) -> Tempfile
               | [A] (*untyped args, **untyped) { (Tempfile) -> A } -> A

  public

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - close(unlink_now=false)
  # -->
  # Closes the file. If `unlink_now` is true, then the file will be unlinked
  # (deleted) after closing. Of course, you can choose to later call #unlink if
  # you do not unlink it now.
  #
  # If you don't explicitly unlink the temporary file, the removal will be delayed
  # until the object is finalized.
  #
  def close: (?boolish unlink_now) -> void

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - close!()
  # -->
  # Closes and unlinks (deletes) the file. Has the same effect as called
  # `close(true)`.
  #
  def close!: () -> void

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - delete()
  # -->
  #
  alias delete unlink

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - length()
  # -->
  #
  alias length size

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - open()
  # -->
  # Opens or reopens the file with mode "r+".
  #
  def open: () -> File

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - path()
  # -->
  # Returns the full path name of the temporary file. This will be nil if #unlink
  # has been called.
  #
  def path: () -> String?

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - size()
  # -->
  # Returns the size of the temporary file.  As a side effect, the IO buffer is
  # flushed before determining the size.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - unlink()
  # -->
  # Unlinks (deletes) the file from the filesystem. One should always unlink the
  # file after using it, as is explained in the "Explicit close" good practice
  # section in the Tempfile overview:
  #
  #     file = Tempfile.new('foo')
  #     begin
  #        # ...do something with file...
  #     ensure
  #        file.close
  #        file.unlink   # deletes the temp file
  #     end
  #
  # ### Unlink-before-close
  #
  # On POSIX systems it's possible to unlink a file before closing it. This
  # practice is explained in detail in the Tempfile overview (section "Unlink
  # after creation"); please refer there for more information.
  #
  # However, unlink-before-close may not be supported on non-POSIX operating
  # systems. Microsoft Windows is the most notable case: unlinking a non-closed
  # file will result in an error, which this method will silently ignore. If you
  # want to practice unlink-before-close whenever possible, then you should write
  # code like this:
  #
  #     file = Tempfile.new('foo')
  #     file.unlink   # On Windows this silently fails.
  #     begin
  #        # ... do something with file ...
  #     ensure
  #        file.close!   # Closes the file handle. If the file wasn't unlinked
  #                      # because #unlink failed, then this method will attempt
  #                      # to do so again.
  #     end
  #
  def unlink: () -> void

  class Remover
    public

    def call: (*untyped args) -> void

    private

    def initialize: (::Tempfile tmpfile) -> void
  end

  # <!--
  #   rdoc-file=lib/tempfile.rb
  #   - new(basename="", tmpdir=nil, mode: 0, **options)
  # -->
  # Creates a temporary file with permissions 0600 (= only readable and writable
  # by the owner) and opens it with mode "w+".
  #
  # It is recommended to use Tempfile.create { ... } instead when possible,
  # because that method avoids the cost of delegation and does not rely on a
  # finalizer to close and unlink the file, which is unreliable.
  #
  # The `basename` parameter is used to determine the name of the temporary file.
  # You can either pass a String or an Array with 2 String elements. In the former
  # form, the temporary file's base name will begin with the given string. In the
  # latter form, the temporary file's base name will begin with the array's first
  # element, and end with the second element. For example:
  #
  #     file = Tempfile.new('hello')
  #     file.path  # => something like: "/tmp/hello2843-8392-92849382--0"
  #
  #     # Use the Array form to enforce an extension in the filename:
  #     file = Tempfile.new(['hello', '.jpg'])
  #     file.path  # => something like: "/tmp/hello2843-8392-92849382--0.jpg"
  #
  # The temporary file will be placed in the directory as specified by the
  # `tmpdir` parameter. By default, this is `Dir.tmpdir`.
  #
  #     file = Tempfile.new('hello', '/home/aisaka')
  #     file.path  # => something like: "/home/aisaka/hello2843-8392-92849382--0"
  #
  # You can also pass an options hash. Under the hood, Tempfile creates the
  # temporary file using `File.open`. These options will be passed to `File.open`.
  # This is mostly useful for specifying encoding options, e.g.:
  #
  #     Tempfile.new('hello', '/home/aisaka', encoding: 'ascii-8bit')
  #
  #     # You can also omit the 'tmpdir' parameter:
  #     Tempfile.new('hello', encoding: 'ascii-8bit')
  #
  # Note: `mode` keyword argument, as accepted by Tempfile, can only be numeric,
  # combination of the modes defined in File::Constants.
  #
  # ### Exceptions
  #
  # If Tempfile.new cannot find a unique filename within a limited number of
  # tries, then it will raise an exception.
  #
  def self.new: (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) -> instance
              | [A] (?String | [ String, String ] basename, ?String? tmpdir, ?mode: Integer, **untyped) { (instance) -> A } -> A
end

# <!-- rdoc-file=lib/csv.rb -->
# ## CSV
# CSV (comma-separated variables) data is a text representation of a table:
# *   A *row* *separator* delimits table rows. A common row separator is the
#     newline character `"\n"`.
# *   A *column* *separator* delimits fields in a row. A common column separator
#     is the comma character `","`.
#
#
# This CSV String, with row separator `"\n"` and column separator `","`, has
# three rows and two columns:
#     "foo,0\nbar,1\nbaz,2\n"
#
# Despite the name CSV, a CSV representation can use different separators.
#
# For more about tables, see the Wikipedia article "[Table
# (information)](https://en.wikipedia.org/wiki/Table_(information))", especially
# its section "[Simple
# table](https://en.wikipedia.org/wiki/Table_(information)#Simple_table)"
#
# ## Class CSV
#
# Class CSV provides methods for:
# *   Parsing CSV data from a String object, a File (via its file path), or an
#     IO object.
# *   Generating CSV data to a String object.
#
#
# To make CSV available:
#     require 'csv'
#
# All examples here assume that this has been done.
#
# ## Keeping It Simple
#
# A CSV object has dozens of instance methods that offer fine-grained control of
# parsing and generating CSV data. For many needs, though, simpler approaches
# will do.
#
# This section summarizes the singleton methods in CSV that allow you to parse
# and generate without explicitly creating CSV objects. For details, follow the
# links.
#
# ### Simple Parsing
#
# Parsing methods commonly return either of:
# *   An Array of Arrays of Strings:
#     *   The outer Array is the entire "table".
#     *   Each inner Array is a row.
#     *   Each String is a field.
#
# *   A CSV::Table object.  For details, see [\CSV with
#     Headers](#class-CSV-label-CSV+with+Headers).
#
#
# #### Parsing a String
#
# The input to be parsed can be a string:
#     string = "foo,0\nbar,1\nbaz,2\n"
#
# Method CSV.parse returns the entire CSV data:
#     CSV.parse(string) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.parse_line returns only the first row:
#     CSV.parse_line(string) # => ["foo", "0"]
#
# CSV extends class String with instance method String#parse_csv, which also
# returns only the first row:
#     string.parse_csv # => ["foo", "0"]
#
# #### Parsing Via a File Path
#
# The input to be parsed can be in a file:
#     string = "foo,0\nbar,1\nbaz,2\n"
#     path = 't.csv'
#     File.write(path, string)
#
# Method CSV.read returns the entire CSV data:
#     CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.foreach iterates, passing each row to the given block:
#     CSV.foreach(path) do |row|
#       p row
#     end
#
# Output:
#     ["foo", "0"]
#     ["bar", "1"]
#     ["baz", "2"]
#
# Method CSV.table returns the entire CSV data as a CSV::Table object:
#     CSV.table(path) # => #<CSV::Table mode:col_or_row row_count:3>
#
# #### Parsing from an Open IO Stream
#
# The input to be parsed can be in an open IO stream:
#
# Method CSV.read returns the entire CSV data:
#     File.open(path) do |file|
#       CSV.read(file)
#     end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# As does method CSV.parse:
#     File.open(path) do |file|
#       CSV.parse(file)
#     end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Method CSV.parse_line returns only the first row:
#     File.open(path) do |file|
#      CSV.parse_line(file)
#     end # => ["foo", "0"]
#
# Method CSV.foreach iterates, passing each row to the given block:
#     File.open(path) do |file|
#       CSV.foreach(file) do |row|
#         p row
#       end
#     end
#
# Output:
#     ["foo", "0"]
#     ["bar", "1"]
#     ["baz", "2"]
#
# Method CSV.table returns the entire CSV data as a CSV::Table object:
#     File.open(path) do |file|
#       CSV.table(file)
#     end # => #<CSV::Table mode:col_or_row row_count:3>
#
# ### Simple Generating
#
# Method CSV.generate returns a String; this example uses method CSV#<< to
# append the rows that are to be generated:
#     output_string = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ['bar', 1]
#       csv << ['baz', 2]
#     end
#     output_string # => "foo,0\nbar,1\nbaz,2\n"
#
# Method CSV.generate_line returns a String containing the single row
# constructed from an Array:
#     CSV.generate_line(['foo', '0']) # => "foo,0\n"
#
# CSV extends class Array with instance method `Array#to_csv`, which forms an
# Array into a String:
#     ['foo', '0'].to_csv # => "foo,0\n"
#
# ### "Filtering" CSV
#
# Method CSV.filter provides a Unix-style filter for CSV data. The input data is
# processed to form the output data:
#     in_string = "foo,0\nbar,1\nbaz,2\n"
#     out_string = ''
#     CSV.filter(in_string, out_string) do |row|
#       row[0] = row[0].upcase
#       row[1] *= 4
#     end
#     out_string # => "FOO,0000\nBAR,1111\nBAZ,2222\n"
#
# ## CSV Objects
#
# There are three ways to create a CSV object:
# *   Method CSV.new returns a new CSV object.
# *   Method CSV.instance returns a new or cached CSV object.
# *   Method CSV() also returns a new or cached CSV object.
#
#
# ### Instance Methods
#
# CSV has three groups of instance methods:
# *   Its own internally defined instance methods.
# *   Methods included by module Enumerable.
# *   Methods delegated to class IO. See below.
#
#
# #### Delegated Methods
#
# For convenience, a CSV object will delegate to many methods in class IO. (A
# few have wrapper "guard code" in CSV.) You may call:
# *   IO#binmode
# *   #binmode?
# *   IO#close
# *   IO#close_read
# *   IO#close_write
# *   IO#closed?
# *   #eof
# *   #eof?
# *   IO#external_encoding
# *   IO#fcntl
# *   IO#fileno
# *   #flock
# *   IO#flush
# *   IO#fsync
# *   IO#internal_encoding
# *   #ioctl
# *   IO#isatty
# *   #path
# *   IO#pid
# *   IO#pos
# *   IO#pos=
# *   IO#reopen
# *   #rewind
# *   IO#seek
# *   #stat
# *   IO#string
# *   IO#sync
# *   IO#sync=
# *   IO#tell
# *   #to_i
# *   #to_io
# *   IO#truncate
# *   IO#tty?
#
#
# ### Options
#
# The default values for options are:
#     DEFAULT_OPTIONS = {
#       # For both parsing and generating.
#       col_sep:            ",",
#       row_sep:            :auto,
#       quote_char:         '"',
#       # For parsing.
#       field_size_limit:   nil,
#       converters:         nil,
#       unconverted_fields: nil,
#       headers:            false,
#       return_headers:     false,
#       header_converters:  nil,
#       skip_blanks:        false,
#       skip_lines:         nil,
#       liberal_parsing:    false,
#       nil_value:          nil,
#       empty_value:        "",
#       strip:              false,
#       # For generating.
#       write_headers:      nil,
#       quote_empty:        true,
#       force_quotes:       false,
#       write_converters:   nil,
#       write_nil_value:    nil,
#       write_empty_value:  "",
#     }
#
# #### Options for Parsing
#
# Options for parsing, described in detail below, include:
# *   `row_sep`: Specifies the row separator; used to delimit rows.
# *   `col_sep`: Specifies the column separator; used to delimit fields.
# *   `quote_char`: Specifies the quote character; used to quote fields.
# *   `field_size_limit`: Specifies the maximum field size allowed.
# *   `converters`: Specifies the field converters to be used.
# *   `unconverted_fields`: Specifies whether unconverted fields are to be
#     available.
# *   `headers`: Specifies whether data contains headers, or specifies the
#     headers themselves.
# *   `return_headers`: Specifies whether headers are to be returned.
# *   `header_converters`: Specifies the header converters to be used.
# *   `skip_blanks`: Specifies whether blanks lines are to be ignored.
# *   `skip_lines`: Specifies how comments lines are to be recognized.
# *   `strip`: Specifies whether leading and trailing whitespace are to be
#     stripped from fields. This must be compatible with `col_sep`; if it is
#     not, then an `ArgumentError` exception will be raised.
# *   `liberal_parsing`: Specifies whether CSV should attempt to parse
#     non-compliant data.
# *   `nil_value`: Specifies the object that is to be substituted for each null
#     (no-text) field.
# *   `empty_value`: Specifies the object that is to be substituted for each
#     empty field.
#
#
# ###### Option `row_sep`
#
# Specifies the row separator, a String or the Symbol `:auto` (see below), to be
# used for both parsing and generating.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto
#
# ---
#
# When `row_sep` is a String, that String becomes the row separator. The String
# will be transcoded into the data's Encoding before use.
#
# Using `"\n"`:
#     row_sep = "\n"
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `|` (pipe):
#     row_sep = '|'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0|bar,1|baz,2|"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `--` (two hyphens):
#     row_sep = '--'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0--bar,1--baz,2--"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     row_sep = ''
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0bar,1baz,2"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0bar", "1baz", "2"]]
#
# ---
#
# When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
# the row separator:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#
# Parsing, on the other hand, invokes auto-discovery of the row separator.
#
# Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
# `\r` sequence. The sequence will be selected even if it occurs in a quoted
# field, assuming that you would have the same line endings there.
#
# Example:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
# is true:
# *   None of those sequences is found.
# *   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
# *   The stream is only available for output.
#
#
# Obviously, discovery takes a little time. Set manually if speed is important.
# Also note that IO objects should be opened in binary mode on Windows if this
# feature will be used as the line-ending translation can cause problems with
# resetting the document position to where it was before the read ahead.
#
# ---
#
# Raises an exception if the given value is not String-convertible:
#     row_sep = BasicObject.new
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.generate(ary, row_sep: row_sep)
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.parse(str, row_sep: row_sep)
#
# ###### Option `col_sep`
#
# Specifies the String field separator to be used for both parsing and
# generating. The String will be transcoded into the data's Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)
#
# Using the default (comma):
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `:` (colon):
#     col_sep = ':'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo:0\nbar:1\nbaz:2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `::` (two colons):
#     col_sep = '::'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo::0\nbar::1\nbaz::2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     col_sep = ''
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo0\nbar1\nbaz2\n"
#
# ---
#
# Raises an exception if parsing with the empty String:
#     col_sep = ''
#     # Raises ArgumentError (:col_sep must be 1 or more characters: "")
#     CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
#
# Raises an exception if the given value is not String-convertible:
#     col_sep = BasicObject.new
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.generate(line, col_sep: col_sep)
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.parse(str, col_sep: col_sep)
#
# ###### Option `quote_char`
#
# Specifies the character (String of length 1) used used to quote fields in both
# parsing and generating. This String will be transcoded into the data's
# Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)
#
# This is useful for an application that incorrectly uses `'` (single-quote) to
# quote fields, instead of the correct `"` (double-quote).
#
# Using the default (double quote):
#     str = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# Using `'` (single-quote):
#     quote_char = "'"
#     str = CSV.generate(quote_char: quote_char) do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
#     ary = CSV.parse(str, quote_char: quote_char)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# ---
#
# Raises an exception if the String length is greater than 1:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: 'xx')
#
# Raises an exception if the value is not a String:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: :foo)
#
# ###### Option `field_size_limit`
#
# Specifies the Integer field size limit.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:field_size_limit) # => nil
#
# This is a maximum size CSV will read ahead looking for the closing quote for a
# field. (In truth, it reads to the first line ending beyond this size.) If a
# quote cannot be found within the limit CSV will raise a MalformedCSVError,
# assuming the data is faulty. You can use this limit to prevent what are
# effectively DoS attacks on the parser. However, this limit can cause a
# legitimate parse to fail; therefore the default value is `nil` (no limit).
#
# For the examples in this section:
#     str = <<~EOT
#       "a","b"
#       "
#       2345
#       ",""
#     EOT
#     str # => "\"a\",\"b\"\n\"\n2345\n\",\"\"\n"
#
# Using the default `nil`:
#     ary = CSV.parse(str)
#     ary # => [["a", "b"], ["\n2345\n", ""]]
#
# Using `50`:
#     field_size_limit = 50
#     ary = CSV.parse(str, field_size_limit: field_size_limit)
#     ary # => [["a", "b"], ["\n2345\n", ""]]
#
# ---
#
# Raises an exception if a field is too long:
#     big_str = "123456789\n" * 1024
#     # Raises CSV::MalformedCSVError (Field size exceeded in line 1.)
#     CSV.parse('valid,fields,"' + big_str + '"', field_size_limit: 2048)
#
# ###### Option `converters`
#
# Specifies converters to be used in parsing fields. See [Field
# Converters](#class-CSV-label-Field+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:converters) # => nil
#
# The value may be a field converter name (see [Stored
# Converters](#class-CSV-label-Stored+Converters)):
#     str = '1,2,3'
#     # Without a converter
#     array = CSV.parse_line(str)
#     array # => ["1", "2", "3"]
#     # With built-in converter :integer
#     array = CSV.parse_line(str, converters: :integer)
#     array # => [1, 2, 3]
#
# The value may be a converter list (see [Converter
# Lists](#class-CSV-label-Converter+Lists)):
#     str = '1,3.14159'
#     # Without converters
#     array = CSV.parse_line(str)
#     array # => ["1", "3.14159"]
#     # With built-in converters
#     array = CSV.parse_line(str, converters: [:integer, :float])
#     array # => [1, 3.14159]
#
# The value may be a Proc custom converter: (see [Custom Field
# Converters](#class-CSV-label-Custom+Field+Converters)):
#     str = ' foo  ,  bar  ,  baz  '
#     # Without a converter
#     array = CSV.parse_line(str)
#     array # => [" foo  ", "  bar  ", "  baz  "]
#     # With a custom converter
#     array = CSV.parse_line(str, converters: proc {|field| field.strip })
#     array # => ["foo", "bar", "baz"]
#
# See also [Custom Field Converters](#class-CSV-label-Custom+Field+Converters)
#
# ---
#
# Raises an exception if the converter is not a converter name or a Proc:
#     str = 'foo,0'
#     # Raises NoMethodError (undefined method `arity' for nil:NilClass)
#     CSV.parse(str, converters: :foo)
#
# ###### Option `unconverted_fields`
#
# Specifies the boolean that determines whether unconverted field values are to
# be available.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:unconverted_fields) # => nil
#
# The unconverted field values are those found in the source data, prior to any
# conversions performed via option `converters`.
#
# When option `unconverted_fields` is `true`, each returned row (Array or
# CSV::Row) has an added method, `unconverted_fields`, that returns the
# unconverted field values:
#     str = <<-EOT
#     foo,0
#     bar,1
#     baz,2
#     EOT
#     # Without unconverted_fields
#     csv = CSV.parse(str, converters: :integer)
#     csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
#     csv.first.respond_to?(:unconverted_fields) # => false
#     # With unconverted_fields
#     csv = CSV.parse(str, converters: :integer, unconverted_fields: true)
#     csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
#     csv.first.respond_to?(:unconverted_fields) # => true
#     csv.first.unconverted_fields # => ["foo", "0"]
#
# ###### Option `headers`
#
# Specifies a boolean, Symbol, Array, or String to be used to define column
# headers.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:headers) # => false
#
# ---
#
# Without `headers`:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str)
#     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
#     csv.headers # => nil
#     csv.shift # => ["Name", "Count"]
#
# ---
#
# If set to `true` or the Symbol `:first_row`, the first row of the data is
# treated as a row of headers:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: true)
#     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:2 col_sep:"," row_sep:"\n" quote_char:"\"" headers:["Name", "Count"]>
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ---
#
# If set to an Array, the Array elements are treated as headers:
#     str = <<-EOT
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: ['Name', 'Count'])
#     csv
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ---
#
# If set to a String `str`, method `CSV::parse_line(str, options)` is called
# with the current `options`, and the returned Array is treated as headers:
#     str = <<-EOT
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     csv = CSV.new(str, headers: 'Name,Count')
#     csv
#     csv.headers # => ["Name", "Count"]
#     csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">
#
# ###### Option `return_headers`
#
# Specifies the boolean that determines whether method #shift returns or ignores
# the header row.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:return_headers) # => false
#
# Examples:
#     str = <<-EOT
#     Name,Count
#     foo,0
#     bar,1
#     bax,2
#     EOT
#     # Without return_headers first row is str.
#     csv = CSV.new(str, headers: true)
#     csv.shift # => #<CSV::Row "Name":"foo" "Count":"0">
#     # With return_headers first row is headers.
#     csv = CSV.new(str, headers: true, return_headers: true)
#     csv.shift # => #<CSV::Row "Name":"Name" "Count":"Count">
#
# ###### Option `header_converters`
#
# Specifies converters to be used in parsing headers. See [Header
# Converters](#class-CSV-label-Header+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:header_converters) # => nil
#
# Identical in functionality to option
# [converters](#class-CSV-label-Option+converters) except that:
# *   The converters apply only to the header row.
# *   The built-in header converters are `:downcase` and `:symbol`.
#
#
# This section assumes prior execution of:
#     str = <<-EOT
#     Name,Value
#     foo,0
#     bar,1
#     baz,2
#     EOT
#     # With no header converter
#     table = CSV.parse(str, headers: true)
#     table.headers # => ["Name", "Value"]
#
# The value may be a header converter name (see [Stored
# Converters](#class-CSV-label-Stored+Converters)):
#     table = CSV.parse(str, headers: true, header_converters: :downcase)
#     table.headers # => ["name", "value"]
#
# The value may be a converter list (see [Converter
# Lists](#class-CSV-label-Converter+Lists)):
#     header_converters = [:downcase, :symbol]
#     table = CSV.parse(str, headers: true, header_converters: header_converters)
#     table.headers # => [:name, :value]
#
# The value may be a Proc custom converter (see [Custom Header
# Converters](#class-CSV-label-Custom+Header+Converters)):
#     upcase_converter = proc {|field| field.upcase }
#     table = CSV.parse(str, headers: true, header_converters: upcase_converter)
#     table.headers # => ["NAME", "VALUE"]
#
# See also [Custom Header Converters](#class-CSV-label-Custom+Header+Converters)
#
# ###### Option `skip_blanks`
#
# Specifies a boolean that determines whether blank lines in the input will be
# ignored; a line that contains a column separator is not considered to be
# blank.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:skip_blanks) # => false
#
# See also option [skiplines](#class-CSV-label-Option+skip_lines).
#
# For examples in this section:
#     str = <<-EOT
#     foo,0
#
#     bar,1
#     baz,2
#
#     ,
#     EOT
#
# Using the default, `false`:
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], [], ["bar", "1"], ["baz", "2"], [], [nil, nil]]
#
# Using `true`:
#     ary = CSV.parse(str, skip_blanks: true)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
#
# Using a truthy value:
#     ary = CSV.parse(str, skip_blanks: :foo)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
#
# ###### Option `skip_lines`
#
# Specifies an object to use in identifying comment lines in the input that are
# to be ignored:
# *   If a Regexp, ignores lines that match it.
# *   If a String, converts it to a Regexp, ignores lines that match it.
# *   If `nil`, no lines are considered to be comments.
#
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:skip_lines) # => nil
#
# For examples in this section:
#     str = <<-EOT
#     # Comment
#     foo,0
#     bar,1
#     baz,2
#     # Another comment
#     EOT
#     str # => "# Comment\nfoo,0\nbar,1\nbaz,2\n# Another comment\n"
#
# Using the default, `nil`:
#     ary = CSV.parse(str)
#     ary # => [["# Comment"], ["foo", "0"], ["bar", "1"], ["baz", "2"], ["# Another comment"]]
#
# Using a Regexp:
#     ary = CSV.parse(str, skip_lines: /^#/)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using a String:
#     ary = CSV.parse(str, skip_lines: '#')
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# ---
#
# Raises an exception if given an object that is not a Regexp, a String, or
# `nil`:
#     # Raises ArgumentError (:skip_lines has to respond to #match: 0)
#     CSV.parse(str, skip_lines: 0)
#
# ###### Option `strip`
#
# Specifies the boolean value that determines whether whitespace is stripped
# from each input field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:strip) # => false
#
# With default value `false`:
#     ary = CSV.parse_line(' a , b ')
#     ary # => [" a ", " b "]
#
# With value `true`:
#     ary = CSV.parse_line(' a , b ', strip: true)
#     ary # => ["a", "b"]
#
# ###### Option `liberal_parsing`
#
# Specifies the boolean value that determines whether CSV will attempt to parse
# input not conformant with RFC 4180, such as double quotes in unquoted fields.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:liberal_parsing) # => false
#
# For examples in this section:
#     str = 'is,this "three, or four",fields'
#
# Without `liberal_parsing`:
#     # Raises CSV::MalformedCSVError (Illegal quoting in str 1.)
#     CSV.parse_line(str)
#
# With `liberal_parsing`:
#     ary = CSV.parse_line(str, liberal_parsing: true)
#     ary # => ["is", "this \"three", " or four\"", "fields"]
#
# ###### Option `nil_value`
#
# Specifies the object that is to be substituted for each null (no-text) field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:nil_value) # => nil
#
# With the default, `nil`:
#     CSV.parse_line('a,,b,,c') # => ["a", nil, "b", nil, "c"]
#
# With a different object:
#     CSV.parse_line('a,,b,,c', nil_value: 0) # => ["a", 0, "b", 0, "c"]
#
# ###### Option `empty_value`
#
# Specifies the object that is to be substituted for each field that has an
# empty String.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:empty_value) # => "" (empty string)
#
# With the default, `""`:
#     CSV.parse_line('a,"",b,"",c') # => ["a", "", "b", "", "c"]
#
# With a different object:
#     CSV.parse_line('a,"",b,"",c', empty_value: 'x') # => ["a", "x", "b", "x", "c"]
#
# #### Options for Generating
#
# Options for generating, described in detail below, include:
# *   `row_sep`: Specifies the row separator; used to delimit rows.
# *   `col_sep`: Specifies the column separator; used to delimit fields.
# *   `quote_char`: Specifies the quote character; used to quote fields.
# *   `write_headers`: Specifies whether headers are to be written.
# *   `force_quotes`: Specifies whether each output field is to be quoted.
# *   `quote_empty`: Specifies whether each empty output field is to be quoted.
# *   `write_converters`: Specifies the field converters to be used in writing.
# *   `write_nil_value`: Specifies the object that is to be substituted for each
#     `nil`-valued field.
# *   `write_empty_value`: Specifies the object that is to be substituted for
#     each empty field.
#
#
# ###### Option `row_sep`
#
# Specifies the row separator, a String or the Symbol `:auto` (see below), to be
# used for both parsing and generating.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto
#
# ---
#
# When `row_sep` is a String, that String becomes the row separator. The String
# will be transcoded into the data's Encoding before use.
#
# Using `"\n"`:
#     row_sep = "\n"
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `|` (pipe):
#     row_sep = '|'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0|bar,1|baz,2|"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `--` (two hyphens):
#     row_sep = '--'
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0--bar,1--baz,2--"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     row_sep = ''
#     str = CSV.generate(row_sep: row_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0bar,1baz,2"
#     ary = CSV.parse(str, row_sep: row_sep)
#     ary # => [["foo", "0bar", "1baz", "2"]]
#
# ---
#
# When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
# the row separator:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#
# Parsing, on the other hand, invokes auto-discovery of the row separator.
#
# Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
# `\r` sequence. The sequence will be selected even if it occurs in a quoted
# field, assuming that you would have the same line endings there.
#
# Example:
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
# is true:
# *   None of those sequences is found.
# *   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
# *   The stream is only available for output.
#
#
# Obviously, discovery takes a little time. Set manually if speed is important.
# Also note that IO objects should be opened in binary mode on Windows if this
# feature will be used as the line-ending translation can cause problems with
# resetting the document position to where it was before the read ahead.
#
# ---
#
# Raises an exception if the given value is not String-convertible:
#     row_sep = BasicObject.new
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.generate(ary, row_sep: row_sep)
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.parse(str, row_sep: row_sep)
#
# ###### Option `col_sep`
#
# Specifies the String field separator to be used for both parsing and
# generating. The String will be transcoded into the data's Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)
#
# Using the default (comma):
#     str = CSV.generate do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `:` (colon):
#     col_sep = ':'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo:0\nbar:1\nbaz:2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `::` (two colons):
#     col_sep = '::'
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo::0\nbar::1\nbaz::2\n"
#     ary = CSV.parse(str, col_sep: col_sep)
#     ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Using `''` (empty string):
#     col_sep = ''
#     str = CSV.generate(col_sep: col_sep) do |csv|
#       csv << [:foo, 0]
#       csv << [:bar, 1]
#       csv << [:baz, 2]
#     end
#     str # => "foo0\nbar1\nbaz2\n"
#
# ---
#
# Raises an exception if parsing with the empty String:
#     col_sep = ''
#     # Raises ArgumentError (:col_sep must be 1 or more characters: "")
#     CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
#
# Raises an exception if the given value is not String-convertible:
#     col_sep = BasicObject.new
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.generate(line, col_sep: col_sep)
#     # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
#     CSV.parse(str, col_sep: col_sep)
#
# ###### Option `quote_char`
#
# Specifies the character (String of length 1) used used to quote fields in both
# parsing and generating. This String will be transcoded into the data's
# Encoding before use.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)
#
# This is useful for an application that incorrectly uses `'` (single-quote) to
# quote fields, instead of the correct `"` (double-quote).
#
# Using the default (double quote):
#     str = CSV.generate do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
#     ary = CSV.parse(str)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# Using `'` (single-quote):
#     quote_char = "'"
#     str = CSV.generate(quote_char: quote_char) do |csv|
#       csv << ['foo', 0]
#       csv << ["'bar'", 1]
#       csv << ['"baz"', 2]
#     end
#     str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
#     ary = CSV.parse(str, quote_char: quote_char)
#     ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
#
# ---
#
# Raises an exception if the String length is greater than 1:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: 'xx')
#
# Raises an exception if the value is not a String:
#     # Raises ArgumentError (:quote_char has to be nil or a single character String)
#     CSV.new('', quote_char: :foo)
#
# ###### Option `write_headers`
#
# Specifies the boolean that determines whether a header row is included in the
# output; ignored if there are no headers.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_headers) # => nil
#
# Without `write_headers`:
#     file_path = 't.csv'
#     CSV.open(file_path,'w',
#         :headers => ['Name','Value']
#       ) do |csv|
#         csv << ['foo', '0']
#     end
#     CSV.open(file_path) do |csv|
#       csv.shift
#     end # => ["foo", "0"]
#
# With `write_headers`":
#     CSV.open(file_path,'w',
#         :write_headers=> true,
#         :headers => ['Name','Value']
#       ) do |csv|
#         csv << ['foo', '0']
#     end
#     CSV.open(file_path) do |csv|
#       csv.shift
#     end # => ["Name", "Value"]
#
# ###### Option `force_quotes`
#
# Specifies the boolean that determines whether each output field is to be
# double-quoted.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:force_quotes) # => false
#
# For examples in this section:
#     ary = ['foo', 0, nil]
#
# Using the default, `false`:
#     str = CSV.generate_line(ary)
#     str # => "foo,0,\n"
#
# Using `true`:
#     str = CSV.generate_line(ary, force_quotes: true)
#     str # => "\"foo\",\"0\",\"\"\n"
#
# ###### Option `quote_empty`
#
# Specifies the boolean that determines whether an empty value is to be
# double-quoted.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:quote_empty) # => true
#
# With the default `true`:
#     CSV.generate_line(['"', ""]) # => "\"\"\"\",\"\"\n"
#
# With `false`:
#     CSV.generate_line(['"', ""], quote_empty: false) # => "\"\"\"\",\n"
#
# ###### Option `write_converters`
#
# Specifies converters to be used in generating fields. See [Write
# Converters](#class-CSV-label-Write+Converters)
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_converters) # => nil
#
# With no write converter:
#     str = CSV.generate_line(["\na\n", "\tb\t", " c "])
#     str # => "\"\na\n\",\tb\t, c \n"
#
# With a write converter:
#     strip_converter = proc {|field| field.strip }
#     str = CSV.generate_line(["\na\n", "\tb\t", " c "], write_converters: strip_converter)
#     str # => "a,b,c\n"
#
# With two write converters (called in order):
#     upcase_converter = proc {|field| field.upcase }
#     downcase_converter = proc {|field| field.downcase }
#     write_converters = [upcase_converter, downcase_converter]
#     str = CSV.generate_line(['a', 'b', 'c'], write_converters: write_converters)
#     str # => "a,b,c\n"
#
# See also [Write Converters](#class-CSV-label-Write+Converters)
#
# ---
#
# Raises an exception if the converter returns a value that is neither `nil` nor
# String-convertible:
#     bad_converter = proc {|field| BasicObject.new }
#     # Raises NoMethodError (undefined method `is_a?' for #<BasicObject:>)
#     CSV.generate_line(['a', 'b', 'c'], write_converters: bad_converter)#
#
# ###### Option `write_nil_value`
#
# Specifies the object that is to be substituted for each `nil`-valued field.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_nil_value) # => nil
#
# Without the option:
#     str = CSV.generate_line(['a', nil, 'c', nil])
#     str # => "a,,c,\n"
#
# With the option:
#     str = CSV.generate_line(['a', nil, 'c', nil], write_nil_value: "x")
#     str # => "a,x,c,x\n"
#
# ###### Option `write_empty_value`
#
# Specifies the object that is to be substituted for each field that has an
# empty String.
#
# Default value:
#     CSV::DEFAULT_OPTIONS.fetch(:write_empty_value) # => ""
#
# Without the option:
#     str = CSV.generate_line(['a', '', 'c', ''])
#     str # => "a,\"\",c,\"\"\n"
#
# With the option:
#     str = CSV.generate_line(['a', '', 'c', ''], write_empty_value: "x")
#     str # => "a,x,c,x\n"
#
# ### CSV with Headers
#
# CSV allows to specify column names of CSV file, whether they are in data, or
# provided separately. If headers are specified, reading methods return an
# instance of CSV::Table, consisting of CSV::Row.
#
#     # Headers are part of data
#     data = CSV.parse(<<~ROWS, headers: true)
#       Name,Department,Salary
#       Bob,Engineering,1000
#       Jane,Sales,2000
#       John,Management,5000
#     ROWS
#
#     data.class      #=> CSV::Table
#     data.first      #=> #<CSV::Row "Name":"Bob" "Department":"Engineering" "Salary":"1000">
#     data.first.to_h #=> {"Name"=>"Bob", "Department"=>"Engineering", "Salary"=>"1000"}
#
#     # Headers provided by developer
#     data = CSV.parse('Bob,Engineering,1000', headers: %i[name department salary])
#     data.first      #=> #<CSV::Row name:"Bob" department:"Engineering" salary:"1000">
#
# ### Converters
#
# By default, each value (field or header) parsed by CSV is formed into a
# String. You can use a *field* *converter* or  *header* *converter* to
# intercept and modify the parsed values:
# *   See [Field Converters](#class-CSV-label-Field+Converters).
# *   See [Header Converters](#class-CSV-label-Header+Converters).
#
#
# Also by default, each value to be written during generation is written
# 'as-is'. You can use a *write* *converter* to modify values before writing.
# *   See [Write Converters](#class-CSV-label-Write+Converters).
#
#
# #### Specifying Converters
#
# You can specify converters for parsing or generating in the `options` argument
# to various CSV methods:
# *   Option `converters` for converting parsed field values.
# *   Option `header_converters` for converting parsed header values.
# *   Option `write_converters` for converting values to be written (generated).
#
#
# There are three forms for specifying converters:
# *   A converter proc: executable code to be used for conversion.
# *   A converter name: the name of a stored converter.
# *   A converter list: an array of converter procs, converter names, and
#     converter lists.
#
#
# ##### Converter Procs
#
# This converter proc, `strip_converter`, accepts a value `field` and returns
# `field.strip`:
#     strip_converter = proc {|field| field.strip }
#
# In this call to `CSV.parse`, the keyword argument `converters:
# string_converter` specifies that:
# *   Proc `string_converter` is to be called for each parsed field.
# *   The converter's return value is to replace the `field` value.
#
# Example:
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# A converter proc can receive a second argument, `field_info`, that contains
# details about the field. This modified `strip_converter` displays its
# arguments:
#     strip_converter = proc do |field, field_info|
#       p [field, field_info]
#       field.strip
#     end
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# Output:
#     [" foo ", #<struct CSV::FieldInfo index=0, line=1, header=nil>]
#     [" 0 ", #<struct CSV::FieldInfo index=1, line=1, header=nil>]
#     [" bar ", #<struct CSV::FieldInfo index=0, line=2, header=nil>]
#     [" 1 ", #<struct CSV::FieldInfo index=1, line=2, header=nil>]
#     [" baz ", #<struct CSV::FieldInfo index=0, line=3, header=nil>]
#     [" 2 ", #<struct CSV::FieldInfo index=1, line=3, header=nil>]
#
# Each CSV::FieldInfo object shows:
# *   The 0-based field index.
# *   The 1-based line index.
# *   The field header, if any.
#
#
# ##### Stored Converters
#
# A converter may be given a name and stored in a structure where the parsing
# methods can find it by name.
#
# The storage structure for field converters is the Hash CSV::Converters. It has
# several built-in converter procs:
# *   `:integer`: converts each String-embedded integer into a true Integer.
# *   `:float`: converts each String-embedded float into a true Float.
# *   `:date`: converts each String-embedded date into a true Date.
# *   `:date_time`: converts each String-embedded date-time into a true DateTime
#
# . This example creates a converter proc, then stores it:
#     strip_converter = proc {|field| field.strip }
#     CSV::Converters[:strip] = strip_converter
#
# Then the parsing method call can refer to the converter by its name, `:strip`:
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: :strip)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# The storage structure for header converters is the Hash CSV::HeaderConverters,
# which works in the same way. It also has built-in converter procs:
# *   `:downcase`: Downcases each header.
# *   `:symbol`: Converts each header to a Symbol.
#
#
# There is no such storage structure for write headers.
#
# In order for the parsing methods to access stored converters in
# non-main-Ractors, the storage structure must be made shareable first.
# Therefore, `Ractor.make_shareable(CSV::Converters)` and
# `Ractor.make_shareable(CSV::HeaderConverters)` must be called before the
# creation of Ractors that use the converters stored in these structures. (Since
# making the storage structures shareable involves freezing them, any custom
# converters that are to be used must be added first.)
#
# ##### Converter Lists
#
# A *converter* *list* is an Array that may include any assortment of:
# *   Converter procs.
# *   Names of stored converters.
# *   Nested converter lists.
#
#
# Examples:
#     numeric_converters = [:integer, :float]
#     date_converters = [:date, :date_time]
#     [numeric_converters, strip_converter]
#     [strip_converter, date_converters, :float]
#
# Like a converter proc, a converter list may be named and stored in either
# CSV::Converters or CSV::HeaderConverters:
#     CSV::Converters[:custom] = [strip_converter, date_converters, :float]
#     CSV::HeaderConverters[:custom] = [:downcase, :symbol]
#
# There are two built-in converter lists:
#     CSV::Converters[:numeric] # => [:integer, :float]
#     CSV::Converters[:all] # => [:date_time, :numeric]
#
# #### Field Converters
#
# With no conversion, all parsed fields in all rows become Strings:
#     string = "foo,0\nbar,1\nbaz,2\n"
#     ary = CSV.parse(string)
#     ary # => # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# When you specify a field converter, each parsed field is passed to the
# converter; its return value becomes the stored value for the field. A
# converter might, for example, convert an integer embedded in a String into a
# true Integer. (In fact, that's what built-in field converter `:integer` does.)
#
# There are three ways to use field converters.
#
# *   Using option [converters](#class-CSV-label-Option+converters) with a
#     parsing method:
#         ary = CSV.parse(string, converters: :integer)
#         ary # => [0, 1, 2] # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
# *   Using option [converters](#class-CSV-label-Option+converters) with a new
#     CSV instance:
#         csv = CSV.new(string, converters: :integer)
#         # Field converters in effect:
#         csv.converters # => [:integer]
#         csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
# *   Using method #convert to add a field converter to a CSV instance:
#         csv = CSV.new(string)
#         # Add a converter.
#         csv.convert(:integer)
#         csv.converters # => [:integer]
#         csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]
#
#
# Installing a field converter does not affect already-read rows:
#     csv = CSV.new(string)
#     csv.shift # => ["foo", "0"]
#     # Add a converter.
#     csv.convert(:integer)
#     csv.converters # => [:integer]
#     csv.read # => [["bar", 1], ["baz", 2]]
#
# There are additional built-in converters, and custom converters are also
# supported.
#
# ##### Built-In Field Converters
#
# The built-in field converters are in Hash CSV::Converters:
# *   Each key is a field converter name.
# *   Each value is one of:
#     *   A Proc field converter.
#     *   An Array of field converter names.
#
#
#
# Display:
#     CSV::Converters.each_pair do |name, value|
#       if value.kind_of?(Proc)
#         p [name, value.class]
#       else
#         p [name, value]
#       end
#     end
#
# Output:
#     [:integer, Proc]
#     [:float, Proc]
#     [:numeric, [:integer, :float]]
#     [:date, Proc]
#     [:date_time, Proc]
#     [:all, [:date_time, :numeric]]
#
# Each of these converters transcodes values to UTF-8 before attempting
# conversion. If a value cannot be transcoded to UTF-8 the conversion will fail
# and the value will remain unconverted.
#
# Converter `:integer` converts each field that Integer() accepts:
#     data = '0,1,2,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["0", "1", "2", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :integer)
#     csv # => [0, 1, 2, "x"]
#
# Converter `:float` converts each field that Float() accepts:
#     data = '1.0,3.14159,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["1.0", "3.14159", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :float)
#     csv # => [1.0, 3.14159, "x"]
#
# Converter `:numeric` converts with both `:integer` and `:float`..
#
# Converter `:date` converts each field that Date::parse accepts:
#     data = '2001-02-03,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["2001-02-03", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :date)
#     csv # => [#<Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)>, "x"]
#
# Converter `:date_time` converts each field that DateTime::parse accepts:
#     data = '2020-05-07T14:59:00-05:00,x'
#     # Without the converter
#     csv = CSV.parse_line(data)
#     csv # => ["2020-05-07T14:59:00-05:00", "x"]
#     # With the converter
#     csv = CSV.parse_line(data, converters: :date_time)
#     csv # => [#<DateTime: 2020-05-07T14:59:00-05:00 ((2458977j,71940s,0n),-18000s,2299161j)>, "x"]
#
# Converter `:numeric` converts with both `:date_time` and `:numeric`..
#
# As seen above, method #convert adds converters to a CSV instance, and method
# #converters returns an Array of the converters in effect:
#     csv = CSV.new('0,1,2')
#     csv.converters # => []
#     csv.convert(:integer)
#     csv.converters # => [:integer]
#     csv.convert(:date)
#     csv.converters # => [:integer, :date]
#
# ##### Custom Field Converters
#
# You can define a custom field converter:
#     strip_converter = proc {|field| field.strip }
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: strip_converter)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# You can register the converter in Converters Hash, which allows you to refer
# to it by name:
#     CSV::Converters[:strip] = strip_converter
#     string = " foo , 0 \n bar , 1 \n baz , 2 \n"
#     array = CSV.parse(string, converters: :strip)
#     array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
#
# #### Header Converters
#
# Header converters operate only on headers (and not on other rows).
#
# There are three ways to use header converters; these examples use built-in
# header converter `:dowhcase`, which downcases each parsed header.
#
# *   Option `header_converters` with a singleton parsing method:
#         string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#         tbl = CSV.parse(string, headers: true, header_converters: :downcase)
#         tbl.class # => CSV::Table
#         tbl.headers # => ["name", "count"]
#
# *   Option `header_converters` with a new CSV instance:
#         csv = CSV.new(string, header_converters: :downcase)
#         # Header converters in effect:
#         csv.header_converters # => [:downcase]
#         tbl = CSV.parse(string, headers: true)
#         tbl.headers # => ["Name", "Count"]
#
# *   Method #header_convert adds a header converter to a CSV instance:
#         csv = CSV.new(string)
#         # Add a header converter.
#         csv.header_convert(:downcase)
#         csv.header_converters # => [:downcase]
#         tbl = CSV.parse(string, headers: true)
#         tbl.headers # => ["Name", "Count"]
#
#
# ##### Built-In Header Converters
#
# The built-in header converters are in Hash CSV::HeaderConverters. The keys
# there are the names of the converters:
#     CSV::HeaderConverters.keys # => [:downcase, :symbol]
#
# Converter `:downcase` converts each header by downcasing it:
#     string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#     tbl = CSV.parse(string, headers: true, header_converters: :downcase)
#     tbl.class # => CSV::Table
#     tbl.headers # => ["name", "count"]
#
# Converter `:symbol` converts each header by making it into a Symbol:
#     string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
#     tbl = CSV.parse(string, headers: true, header_converters: :symbol)
#     tbl.headers # => [:name, :count]
#
# Details:
# *   Strips leading and trailing whitespace.
# *   Downcases the header.
# *   Replaces embedded spaces with underscores.
# *   Removes non-word characters.
# *   Makes the string into a Symbol.
#
#
# ##### Custom Header Converters
#
# You can define a custom header converter:
#     upcase_converter = proc {|header| header.upcase }
#     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
#     table = CSV.parse(string, headers: true, header_converters: upcase_converter)
#     table # => #<CSV::Table mode:col_or_row row_count:4>
#     table.headers # => ["NAME", "VALUE"]
#
# You can register the converter in HeaderConverters Hash, which allows you to
# refer to it by name:
#     CSV::HeaderConverters[:upcase] = upcase_converter
#     table = CSV.parse(string, headers: true, header_converters: :upcase)
#     table # => #<CSV::Table mode:col_or_row row_count:4>
#     table.headers # => ["NAME", "VALUE"]
#
# ##### Write Converters
#
# When you specify a write converter for generating CSV, each field to be
# written is passed to the converter; its return value becomes the new value for
# the field. A converter might, for example, strip whitespace from a field.
#
# Using no write converter (all fields unmodified):
#     output_string = CSV.generate do |csv|
#       csv << [' foo ', 0]
#       csv << [' bar ', 1]
#       csv << [' baz ', 2]
#     end
#     output_string # => " foo ,0\n bar ,1\n baz ,2\n"
#
# Using option `write_converters` with two custom write converters:
#     strip_converter = proc {|field| field.respond_to?(:strip) ? field.strip : field }
#     upcase_converter = proc {|field| field.respond_to?(:upcase) ? field.upcase : field }
#     write_converters = [strip_converter, upcase_converter]
#     output_string = CSV.generate(write_converters: write_converters) do |csv|
#       csv << [' foo ', 0]
#       csv << [' bar ', 1]
#       csv << [' baz ', 2]
#     end
#     output_string # => "FOO,0\nBAR,1\nBAZ,2\n"
#
# ### Character Encodings (M17n or Multilingualization)
#
# This new CSV parser is m17n savvy.  The parser works in the Encoding of the IO
# or String object being read from or written to. Your data is never transcoded
# (unless you ask Ruby to transcode it for you) and will literally be parsed in
# the Encoding it is in. Thus CSV will return Arrays or Rows of Strings in the
# Encoding of your data. This is accomplished by transcoding the parser itself
# into your Encoding.
#
# Some transcoding must take place, of course, to accomplish this multiencoding
# support. For example, `:col_sep`, `:row_sep`, and `:quote_char` must be
# transcoded to match your data.  Hopefully this makes the entire process feel
# transparent, since CSV's defaults should just magically work for your data.
# However, you can set these values manually in the target Encoding to avoid the
# translation.
#
# It's also important to note that while all of CSV's core parser is now
# Encoding agnostic, some features are not. For example, the built-in converters
# will try to transcode data to UTF-8 before making conversions. Again, you can
# provide custom converters that are aware of your Encodings to avoid this
# translation. It's just too hard for me to support native conversions in all of
# Ruby's Encodings.
#
# Anyway, the practical side of this is simple: make sure IO and String objects
# passed into CSV have the proper Encoding set and everything should just work.
# CSV methods that allow you to open IO objects (CSV::foreach(), CSV::open(),
# CSV::read(), and CSV::readlines()) do allow you to specify the Encoding.
#
# One minor exception comes when generating CSV into a String with an Encoding
# that is not ASCII compatible. There's no existing data for CSV to use to
# prepare itself and thus you will probably need to manually specify the desired
# Encoding for most of those cases. It will try to guess using the fields in a
# row of output though, when using CSV::generate_line() or Array#to_csv().
#
# I try to point out any other Encoding issues in the documentation of methods
# as they come up.
#
# This has been tested to the best of my ability with all non-"dummy" Encodings
# Ruby ships with. However, it is brave new code and may have some bugs. Please
# feel free to [report](mailto:james@grayproductions.net) any issues you find
# with it.
#
class CSV < Object
  include Enumerable[untyped]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - foreach(path, mode='r', **options) {|row| ... )
  #   - foreach(io, mode='r', **options {|row| ... )
  #   - foreach(path, mode='r', headers: ..., **options) {|row| ... )
  #   - foreach(io, mode='r', headers: ..., **options {|row| ... )
  #   - foreach(path, mode='r', **options) -> new_enumerator
  #   - foreach(io, mode='r', **options -> new_enumerator
  # -->
  # Calls the block with each row read from source `path` or `io`.
  #
  # *   Argument `path`, if given, must be the path to a file.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  #
  # *   Argument `mode`, if given, must be a File mode See [Open
  #     Mode](IO.html#method-c-new-label-Open+Mode).
  # *   Arguments `**options` must be keyword options. See [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing).
  # *   This method optionally accepts an additional `:encoding` option that you
  #     can use to specify the Encoding of the data read from `path` or `io`. You
  #     must provide this unless your data is in the encoding given by
  #     `Encoding::default_external`. Parsing will use this to determine how to
  #     parse the data. You may provide a second Encoding to have the data
  #     transcoded as it is read. For example,
  #         encoding: 'UTF-32BE:UTF-8'
  #
  #     would read `UTF-32BE` data from the file but transcode it to `UTF-8`
  #     before parsing.
  #
  #
  # ###### Without Option `headers`
  #
  # Without option `headers`, returns each row as an Array object.
  #
  # These examples assume prior execution of:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Read rows from a file at `path`:
  #     CSV.foreach(path) {|row| p row }
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # Read rows from an IO object:
  #     File.open(path) do |file|
  #       CSV.foreach(file) {|row| p row }
  #     end
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # Returns a new Enumerator if no block given:
  #     CSV.foreach(path) # => #<Enumerator: CSV:foreach("t.csv", "r")>
  #     CSV.foreach(File.open(path)) # => #<Enumerator: CSV:foreach(#<File:t.csv>, "r")>
  #
  # Issues a warning if an encoding is unsupported:
  #     CSV.foreach(File.open(path), encoding: 'foo:bar') {|row| }
  #
  # Output:
  #     warning: Unsupported encoding foo ignored
  #     warning: Unsupported encoding bar ignored
  #
  # ###### With Option `headers`
  #
  # With {option `headers`[}](#class-CSV-label-Option+headers), returns each row
  # as a CSV::Row object.
  #
  # These examples assume prior execution of:
  #     string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Read rows from a file at `path`:
  #     CSV.foreach(path, headers: true) {|row| p row }
  #
  # Output:
  #     #<CSV::Row "Name":"foo" "Count":"0">
  #     #<CSV::Row "Name":"bar" "Count":"1">
  #     #<CSV::Row "Name":"baz" "Count":"2">
  #
  # Read rows from an IO object:
  #     File.open(path) do |file|
  #       CSV.foreach(file, headers: true) {|row| p row }
  #     end
  #
  # Output:
  #     #<CSV::Row "Name":"foo" "Count":"0">
  #     #<CSV::Row "Name":"bar" "Count":"1">
  #     #<CSV::Row "Name":"baz" "Count":"2">
  #
  # ---
  #
  # Raises an exception if `path` is a String, but not the path to a readable
  # file:
  #     # Raises Errno::ENOENT (No such file or directory @ rb_sysopen - nosuch.csv):
  #     CSV.foreach('nosuch.csv') {|row| }
  #
  # Raises an exception if `io` is an IO object, but not open for reading:
  #     io = File.open(path, 'w') {|row| }
  #     # Raises TypeError (no implicit conversion of nil into String):
  #     CSV.foreach(io) {|row| }
  #
  # Raises an exception if `mode` is invalid:
  #     # Raises ArgumentError (invalid access mode nosuch):
  #     CSV.foreach(path, 'nosuch') {|row| }
  #
  def self.foreach: [U] (String | IO | StringIO path, ?::Hash[Symbol, U] options) { (::Array[String?] arg0) -> void } -> void

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - CSV.new(string)
  #   - CSV.new(io)
  #   - CSV.new(string, **options)
  #   - CSV.new(io, **options)
  # -->
  # Returns the new CSV object created using `string` or `io` and the specified
  # `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  #
  # *   Argument `options`: See:
  #     *   [Options for Parsing](#class-CSV-label-Options+for+Parsing)
  #     *   [Options for Generating](#class-CSV-label-Options+for+Generating)
  #
  #     For performance reasons, the options cannot be overridden in a CSV object,
  #     so those specified here will endure.
  #
  #
  # In addition to the CSV instance methods, several IO methods are delegated. See
  # [Delegated Methods](#class-CSV-label-Delegated+Methods).
  #
  # ---
  #
  # Create a CSV object from a String object:
  #     csv = CSV.new('foo,0')
  #     csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
  #
  # Create a CSV object from a File object:
  #     File.write('t.csv', 'foo,0')
  #     csv = CSV.new(File.open('t.csv'))
  #     csv # => #<CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
  #
  # ---
  #
  # Raises an exception if the argument is `nil`:
  #     # Raises ArgumentError (Cannot parse nil as CSV):
  #     CSV.new(nil)
  #
  def initialize: (?String | IO | StringIO io, ?::Hash[Symbol, untyped] options) -> void

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - parse(string) -> array_of_arrays
  #   - parse(io) -> array_of_arrays
  #   - parse(string, headers: ..., **options) -> csv_table
  #   - parse(io, headers: ..., **options) -> csv_table
  #   - parse(string, **options) {|row| ... }
  #   - parse(io, **options) {|row| ... }
  # -->
  # Parses `string` or `io` using the specified `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  #
  # *   Argument `options`: see [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing)
  #
  #
  # ###### Without Option `headers`
  #
  # Without {option `headers`[}](#class-CSV-label-Option+headers) case.
  #
  # These examples assume prior execution of:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # ---
  #
  # With no block given, returns an Array of Arrays formed from the source.
  #
  # Parse a String:
  #     a_of_a = CSV.parse(string)
  #     a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # Parse an open File:
  #     a_of_a = File.open(path) do |file|
  #       CSV.parse(file)
  #     end
  #     a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # ---
  #
  # With a block given, calls the block with each parsed row:
  #
  # Parse a String:
  #     CSV.parse(string) {|row| p row }
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # Parse an open File:
  #     File.open(path) do |file|
  #       CSV.parse(file) {|row| p row }
  #     end
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # ###### With Option `headers`
  #
  # With {option `headers`[}](#class-CSV-label-Option+headers) case.
  #
  # These examples assume prior execution of:
  #     string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # ---
  #
  # With no block given, returns a CSV::Table object formed from the source.
  #
  # Parse a String:
  #     csv_table = CSV.parse(string, headers: ['Name', 'Count'])
  #     csv_table # => #<CSV::Table mode:col_or_row row_count:5>
  #
  # Parse an open File:
  #     csv_table = File.open(path) do |file|
  #       CSV.parse(file, headers: ['Name', 'Count'])
  #     end
  #     csv_table # => #<CSV::Table mode:col_or_row row_count:4>
  #
  # ---
  #
  # With a block given, calls the block with each parsed row, which has been
  # formed into a CSV::Row object:
  #
  # Parse a String:
  #     CSV.parse(string, headers: ['Name', 'Count']) {|row| p row }
  #
  # Output:
  #     # <CSV::Row "Name":"foo" "Count":"0">
  #     # <CSV::Row "Name":"bar" "Count":"1">
  #     # <CSV::Row "Name":"baz" "Count":"2">
  #
  # Parse an open File:
  #     File.open(path) do |file|
  #       CSV.parse(file, headers: ['Name', 'Count']) {|row| p row }
  #     end
  #
  # Output:
  #     # <CSV::Row "Name":"foo" "Count":"0">
  #     # <CSV::Row "Name":"bar" "Count":"1">
  #     # <CSV::Row "Name":"baz" "Count":"2">
  #
  # ---
  #
  # Raises an exception if the argument is not a String object or IO object:
  #     # Raises NoMethodError (undefined method `close' for :foo:Symbol)
  #     CSV.parse(:foo)
  #
  def self.parse: (String str, ?::Hash[Symbol, untyped] options) ?{ (::Array[String?] arg0) -> void } -> ::Array[::Array[String?]]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - CSV.parse_line(string) -> new_array or nil
  #   - CSV.parse_line(io) -> new_array or nil
  #   - CSV.parse_line(string, **options) -> new_array or nil
  #   - CSV.parse_line(io, **options) -> new_array or nil
  #   - CSV.parse_line(string, headers: true, **options) -> csv_row or nil
  #   - CSV.parse_line(io, headers: true, **options) -> csv_row or nil
  # -->
  # Returns the data created by parsing the first line of `string` or `io` using
  # the specified `options`.
  #
  # *   Argument `string` should be a String object; it will be put into a new
  #     StringIO object positioned at the beginning.
  # *   Argument `io` should be an IO object that is:
  #     *   Open for reading; on return, the IO object will be closed.
  #     *   Positioned at the beginning. To position at the end, for appending,
  #         use method CSV.generate. For any other positioning, pass a preset
  #         StringIO object instead.
  #
  # *   Argument `options`: see [Options for
  #     Parsing](#class-CSV-label-Options+for+Parsing)
  #
  #
  # ###### Without Option `headers`
  #
  # Without option `headers`, returns the first row as a new Array.
  #
  # These examples assume prior execution of:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Parse the first line from a String object:
  #     CSV.parse_line(string) # => ["foo", "0"]
  #
  # Parse the first line from a File object:
  #     File.open(path) do |file|
  #       CSV.parse_line(file) # => ["foo", "0"]
  #     end # => ["foo", "0"]
  #
  # Returns `nil` if the argument is an empty String:
  #     CSV.parse_line('') # => nil
  #
  # ###### With Option `headers`
  #
  # With {option `headers`[}](#class-CSV-label-Option+headers), returns the first
  # row as a CSV::Row object.
  #
  # These examples assume prior execution of:
  #     string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #
  # Parse the first line from a String object:
  #     CSV.parse_line(string, headers: true) # => #<CSV::Row "Name":"foo" "Count":"0">
  #
  # Parse the first line from a File object:
  #     File.open(path) do |file|
  #       CSV.parse_line(file, headers: true)
  #     end # => #<CSV::Row "Name":"foo" "Count":"0">
  #
  # ---
  #
  # Raises an exception if the argument is `nil`:
  #     # Raises ArgumentError (Cannot parse nil as CSV):
  #     CSV.parse_line(nil)
  #
  def self.parse_line: (String str, ?::Hash[Symbol, untyped] options) -> ::Array[String?]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv.read -> array or csv_table
  # -->
  # Forms the remaining rows from `self` into:
  # *   A CSV::Table object, if headers are in use.
  # *   An Array of Arrays, otherwise.
  #
  #
  # The data source must be opened for reading.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     csv = CSV.open(path)
  #     csv.read # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     csv = CSV.open(path, headers: true)
  #     csv.read # => #<CSV::Table mode:col_or_row row_count:4>
  #
  # ---
  #
  # Raises an exception if the source is not opened for reading:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.close
  #     # Raises IOError (not opened for reading)
  #     csv.read
  #
  def read: () -> ::Array[::Array[String?]]

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - readline()
  # -->
  #
  def readline: () -> ::Array[String?]?

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - read(source, **options) -> array_of_arrays
  #   - read(source, headers: true, **options) -> csv_table
  # -->
  # Opens the given `source` with the given `options` (see CSV.open), reads the
  # source (see CSV#read), and returns the result, which will be either an Array
  # of Arrays or a CSV::Table.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     path = 't.csv'
  #     File.write(path, string)
  #     CSV.read(path, headers: true) # => #<CSV::Table mode:col_or_row row_count:4>
  #
  def self.read: (String path, ?::Hash[Symbol, untyped] options) -> ::Array[::Array[String?]]

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv << row -> self
  # -->
  # Appends a row to `self`.
  #
  # *   Argument `row` must be an Array object or a CSV::Row object.
  # *   The output stream must be open for writing.
  #
  #
  # ---
  #
  # Append Arrays:
  #     CSV.generate do |csv|
  #       csv << ['foo', 0]
  #       csv << ['bar', 1]
  #       csv << ['baz', 2]
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # Append CSV::Rows:
  #     headers = []
  #     CSV.generate do |csv|
  #       csv << CSV::Row.new(headers, ['foo', 0])
  #       csv << CSV::Row.new(headers, ['bar', 1])
  #       csv << CSV::Row.new(headers, ['baz', 2])
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # Headers in CSV::Row objects are not appended:
  #     headers = ['Name', 'Count']
  #     CSV.generate do |csv|
  #       csv << CSV::Row.new(headers, ['foo', 0])
  #       csv << CSV::Row.new(headers, ['bar', 1])
  #       csv << CSV::Row.new(headers, ['baz', 2])
  #     end # => "foo,0\nbar,1\nbaz,2\n"
  #
  # ---
  #
  # Raises an exception if `row` is not an Array or CSV::Row:
  #     CSV.generate do |csv|
  #       # Raises NoMethodError (undefined method `collect' for :foo:Symbol)
  #       csv << :foo
  #     end
  #
  # Raises an exception if the output stream is not opened for writing:
  #     path = 't.csv'
  #     File.write(path, '')
  #     File.open(path) do |file|
  #       CSV.open(file) do |csv|
  #         # Raises IOError (not opened for writing)
  #         csv << ['foo', 0]
  #       end
  #     end
  #
  def <<: (::Array[untyped] | CSV::Row row) -> void

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - generate(csv_string, **options) {|csv| ... }
  #   - generate(**options) {|csv| ... }
  # -->
  # *   Argument `csv_string`, if given, must be a String object; defaults to a
  #     new empty String.
  # *   Arguments `options`, if given, should be generating options. See [Options
  #     for Generating](#class-CSV-label-Options+for+Generating).
  #
  #
  # ---
  #
  # Creates a new CSV object via `CSV.new(csv_string, **options)`; calls the block
  # with the CSV object, which the block may modify; returns the String generated
  # from the CSV object.
  #
  # Note that a passed String **is** modified by this method. Pass
  # `csv_string`.dup if the String must be preserved.
  #
  # This method has one additional option: `:encoding`, which sets the base
  # Encoding for the output if no no `str` is specified. CSV needs this hint if
  # you plan to output non-ASCII compatible data.
  #
  # ---
  #
  # Add lines:
  #     input_string = "foo,0\nbar,1\nbaz,2\n"
  #     output_string = CSV.generate(input_string) do |csv|
  #       csv << ['bat', 3]
  #       csv << ['bam', 4]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     input_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     output_string.equal?(input_string) # => true # Same string, modified
  #
  # Add lines into new string, preserving old string:
  #     input_string = "foo,0\nbar,1\nbaz,2\n"
  #     output_string = CSV.generate(input_string.dup) do |csv|
  #       csv << ['bat', 3]
  #       csv << ['bam', 4]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
  #     input_string # => "foo,0\nbar,1\nbaz,2\n"
  #     output_string.equal?(input_string) # => false # Different strings
  #
  # Create lines from nothing:
  #     output_string = CSV.generate do |csv|
  #       csv << ['foo', 0]
  #       csv << ['bar', 1]
  #       csv << ['baz', 2]
  #     end
  #     output_string # => "foo,0\nbar,1\nbaz,2\n"
  #
  # ---
  #
  # Raises an exception if `csv_string` is not a String object:
  #     # Raises TypeError (no implicit conversion of Integer into String)
  #     CSV.generate(0)
  #
  def self.generate: (?String str, **untyped options) { (CSV csv) -> void } -> String

  # <!--
  #   rdoc-file=lib/csv.rb
  #   - csv.each -> enumerator
  #   - csv.each {|row| ...}
  # -->
  # Calls the block with each successive row. The data source must be opened for
  # reading.
  #
  # Without headers:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.each do |row|
  #       p row
  #     end
  #
  # Output:
  #     ["foo", "0"]
  #     ["bar", "1"]
  #     ["baz", "2"]
  #
  # With headers:
  #     string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string, headers: true)
  #     csv.each do |row|
  #       p row
  #     end
  #
  # Output:
  #     <CSV::Row "Name":"foo" "Value":"0">
  #     <CSV::Row "Name":"bar" "Value":"1">
  #     <CSV::Row "Name":"baz" "Value":"2">
  #
  # ---
  #
  # Raises an exception if the source is not opened for reading:
  #     string = "foo,0\nbar,1\nbaz,2\n"
  #     csv = CSV.new(string)
  #     csv.close
  #     # Raises IOError (not opened for reading)
  #     csv.each do |row|
  #       p row
  #     end
  #
  def each: () -> Enumerator[untyped, Integer]
          | () { (untyped) -> void } -> Integer
end

# <!-- rdoc-file=lib/csv.rb -->
# Default values for method options.
#
CSV::DEFAULT_OPTIONS: ::Hash[untyped, untyped]

# <!-- rdoc-file=lib/csv/version.rb -->
# The version of the installed library.
#
CSV::VERSION: String

# <!-- rdoc-file=lib/csv/row.rb -->
# A CSV::Row is part Array and part Hash. It retains an order for the fields and
# allows duplicates just as an Array would, but also allows you to access fields
# by name just as you could if they were in a Hash.
#
# All rows returned by CSV will be constructed from this class, if header row
# processing is activated.
#
class CSV::Row < Object
  include Enumerable[Array[String]]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row << [header, value] -> self
  #   - row << hash -> self
  #   - row << value -> self
  # -->
  # Adds a field to `self`; returns `self`:
  #
  # If the argument is a 2-element Array `[header, value]`, a field is added with
  # the given `header` and `value`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << ['NAME', 'Bat']
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" "NAME":"Bat">
  #
  # If the argument is a Hash, each `key-value` pair is added as a field with
  # header `key` and value `value`.
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << {NAME: 'Bat', name: 'Bam'}
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" NAME:"Bat" name:"Bam">
  #
  # Otherwise, the given `value` is added as a field with no header.
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row << 'Bag'
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bag">
  #
  def <<: (untyped arg) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - ==(other)
  # -->
  # Returns `true` if this row contains the same headers and fields in the same
  # order as `other`.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - [](header_or_index, minimum_index = 0)
  # -->
  #
  alias [] field

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row[index] = value -> value
  #   - row[header, offset] = value -> value
  #   - row[header] = value -> value
  # -->
  # Assigns the field value for the given `index` or `header`; returns `value`.
  #
  # ---
  #
  # Assign field value by Integer index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row[0] = 'Bat'
  #     row[1] = 3
  #     row # => #<CSV::Row "Name":"Bat" "Value":3>
  #
  # Counts backward from the last column if `index` is negative:
  #     row[-1] = 4
  #     row[-2] = 'Bam'
  #     row # => #<CSV::Row "Name":"Bam" "Value":4>
  #
  # Extends the row with `nil:nil` if positive `index` is not in the row:
  #     row[4] = 5
  #     row # => #<CSV::Row "Name":"bad" "Value":4 nil:nil nil:nil nil:5>
  #
  # Raises IndexError if negative `index` is too small (too far from zero).
  #
  # ---
  #
  # Assign field value by header (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['Name'] = 'Bat'
  #     row # => #<CSV::Row "Name":"Bat" "Name":"Bar" "Name":"Baz">
  #
  # Assign field value by header, ignoring `offset` leading fields:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['Name', 2] = 4
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":4>
  #
  # Append new field by (new) header:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row['New'] = 6
  #     row# => #<CSV::Row "Name":"foo" "Value":"0" "New":6>
  #
  def []=: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - delete(index) -> [header, value] or nil
  #   - delete(header) -> [header, value] or empty_array
  #   - delete(header, offset) -> [header, value] or empty_array
  # -->
  # Removes a specified field from `self`; returns the 2-element Array `[header,
  # value]` if the field exists.
  #
  # If an Integer argument `index` is given, removes and returns the field at
  # offset `index`, or returns `nil` if the field does not exist:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete(1) # => ["Name", "Bar"]
  #     row.delete(50) # => nil
  #
  # Otherwise, if the single argument `header` is given, removes and returns the
  # first-found field with the given header, of returns a new empty Array if the
  # field does not exist:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete('Name') # => ["Name", "Foo"]
  #     row.delete('NAME') # => []
  #
  # If argument `header` and Integer argument `offset` are given, removes and
  # returns the first-found field with the given header whose `index` is at least
  # as large as `offset`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete('Name', 1) # => ["Name", "Bar"]
  #     row.delete('NAME', 1) # => []
  #
  def delete: (untyped header_or_index, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.delete_if {|header, value| ... } -> self
  # -->
  # Removes fields from `self` as selected by the block; returns `self`.
  #
  # Removes each field for which the block returns a truthy value:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.delete_if {|header, value| value.start_with?('B') } # => true
  #     row # => #<CSV::Row "Name":"Foo">
  #     row.delete_if {|header, value| header.start_with?('B') } # => false
  #
  # If no block is given, returns a new Enumerator:
  #     row.delete_if # => #<Enumerator: #<CSV::Row "Name":"Foo">:delete_if>
  #
  def delete_if: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.dig(index_or_header, *identifiers) -> object
  # -->
  # Finds and returns the object in nested object that is specified by
  # `index_or_header` and `specifiers`.
  #
  # The nested objects may be instances of various classes. See [Dig
  # Methods](https://docs.ruby-lang.org/en/master/doc/dig_methods_rdoc.html).
  #
  # Examples:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.dig(1) # => "0"
  #     row.dig('Value') # => "0"
  #     row.dig(5) # => nil
  #
  def dig: (untyped index_or_header, *untyped indexes) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - each(&block)
  # -->
  # Yields each pair of the row as header and field tuples (much like iterating
  # over a Hash). This method returns the row for chaining.
  #
  # If no block is given, an Enumerator is returned.
  #
  # Support for Enumerable.
  #
  def each: () -> Enumerator[Array[String], self]
          | () { (Array[String]) -> void } -> self

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - each_pair(&block)
  # -->
  #
  alias each_pair each

  def empty?: (*untyped args) { (*untyped) -> untyped } -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - fetch(header)
  #   - fetch(header, default)
  #   - fetch(header) {|row| ... }
  # -->
  # Returns the field value as specified by `header`.
  #
  # ---
  #
  # With the single argument `header`, returns the field value for that header
  # (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name') # => "Foo"
  #
  # Raises exception `KeyError` if the header does not exist.
  #
  # ---
  #
  # With arguments `header` and `default` given, returns the field value for the
  # header (first found) if the header exists, otherwise returns `default`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name', '') # => "Foo"
  #     row.fetch(:nosuch, '') # => ""
  #
  # ---
  #
  # With argument `header` and a block given, returns the field value for the
  # header (first found) if the header exists; otherwise calls the block and
  # returns its return value:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fetch('Name') {|header| fail 'Cannot happen' } # => "Foo"
  #     row.fetch(:nosuch) {|header| "Header '#{header} not found'" } # => "Header 'nosuch not found'"
  #
  def fetch: (untyped header, *untyped varargs) ?{ (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - field(index)
  #   - field(header)
  #   - field(header, offset)
  # -->
  # Returns the field value for the given `index` or `header`.
  #
  # ---
  #
  # Fetch field value by Integer index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field(0) # => "foo"
  #     row.field(1) # => "bar"
  #
  # Counts backward from the last column if `index` is negative:
  #     row.field(-1) # => "0"
  #     row.field(-2) # => "foo"
  #
  # Returns `nil` if `index` is out of range:
  #     row.field(2) # => nil
  #     row.field(-3) # => nil
  #
  # ---
  #
  # Fetch field value by header (first found):
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field('Name') # => "Foo"
  #
  # Fetch field value by header, ignoring `offset` leading fields:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.field('Name', 2) # => "Baz"
  #
  # Returns `nil` if the header does not exist.
  #
  def field: (untyped header_or_index, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - field?(data)
  # -->
  # Returns `true` if `data` matches a field in this row, and `false` otherwise.
  #
  def field?: (untyped data) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.field_row? -> true or false
  # -->
  # Returns `true` if this is a field row, `false` otherwise.
  #
  def field_row?: () -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - self.fields(*specifiers)
  # -->
  # Returns field values per the given `specifiers`, which may be any mixture of:
  # *   Integer index.
  # *   Range of Integer indexes.
  # *   2-element Array containing a header and offset.
  # *   Header.
  # *   Range of headers.
  #
  #
  # For `specifier` in one of the first four cases above, returns the result of
  # `self.field(specifier)`;  see #field.
  #
  # Although there may be any number of `specifiers`, the examples here will
  # illustrate one at a time.
  #
  # When the specifier is an Integer `index`, returns `self.field(index)`L
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fields(1) # => ["Bar"]
  #
  # When the specifier is a Range of Integers `range`, returns
  # `self.field(range)`:
  #     row.fields(1..2) # => ["Bar", "Baz"]
  #
  # When the specifier is a 2-element Array `array`, returns `self.field(array)`L
  #     row.fields('Name', 1) # => ["Foo", "Bar"]
  #
  # When the specifier is a header `header`, returns `self.field(header)`L
  #     row.fields('Name') # => ["Foo"]
  #
  # When the specifier is a Range of headers `range`, forms a new Range
  # `new_range` from the indexes of `range.start` and `range.end`, and returns
  # `self.field(new_range)`:
  #     source = "Name,NAME,name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.fields('Name'..'NAME') # => ["Foo", "Bar"]
  #
  # Returns all fields if no argument given:
  #     row.fields # => ["Foo", "Bar", "Baz"]
  #
  def fields: (*untyped headers_and_or_indices) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.has_key?(header)
  # -->
  # Returns `true` if there is a field with the given `header`, `false` otherwise.
  #
  def has_key?: (untyped header) -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - header?(header)
  # -->
  #
  alias header? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.header_row? -> true or false
  # -->
  # Returns `true` if this is a header row, `false` otherwise.
  #
  def header_row?: () -> bool

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.headers
  # -->
  # Returns the headers for this row:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table.first
  #     row.headers # => ["Name", "Value"]
  #
  def headers: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - include?(header)
  # -->
  #
  alias include? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - index( header )
  #   - index( header, offset )
  # -->
  # This method will return the index of a field with the provided `header`. The
  # `offset` can be used to locate duplicate header names, as described in
  # CSV::Row.field().
  #
  def index: (untyped header, ?untyped minimum_index) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.inspect -> string
  # -->
  # Returns an ASCII-compatible String showing:
  # *   Class CSV::Row.
  # *   Header-value pairs.
  #
  # Example:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.inspect # => "#<CSV::Row \"Name\":\"foo\" \"Value\":\"0\">"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - key?(header)
  # -->
  #
  alias key? has_key?

  def length: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - member?(header)
  # -->
  #
  alias member? has_key?

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.push(*values) ->self
  # -->
  # Appends each of the given `values` to `self` as a field; returns `self`:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.push('Bat', 'Bam')
  #     row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bat" nil:"Bam">
  #
  def push: (*untyped args) -> untyped

  def size: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.to_csv -> csv_string
  # -->
  # Returns the row as a CSV String. Headers are not included:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_csv # => "foo,0\n"
  #
  def to_csv: (**untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - row.to_h -> hash
  # -->
  # Returns the new Hash formed by adding each header-value pair in `self` as a
  # key-value pair in the Hash.
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_h # => {"Name"=>"foo", "Value"=>"0"}
  #
  # Header order is preserved, but repeated headers are ignored:
  #     source = "Name,Name,Name\nFoo,Bar,Baz\n"
  #     table = CSV.parse(source, headers: true)
  #     row = table[0]
  #     row.to_h # => {"Name"=>"Foo"}
  #
  def to_h: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - to_hash()
  # -->
  #
  alias to_hash to_h

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - to_s(**options)
  # -->
  #
  alias to_s to_csv

  # <!--
  #   rdoc-file=lib/csv/row.rb
  #   - values_at(*headers_and_or_indices)
  # -->
  #
  alias values_at fields
end

class CSV::FieldInfo < Struct[untyped]
end

# <!-- rdoc-file=lib/csv.rb -->
# The error thrown when the parser encounters illegal CSV formatting.
#
class CSV::MalformedCSVError < RuntimeError
end

# <!-- rdoc-file=lib/csv/table.rb -->
# A CSV::Table is a two-dimensional data structure for representing CSV
# documents. Tables allow you to work with the data by row or column, manipulate
# the data, and even convert the results back to CSV, if needed.
#
# All tables returned by CSV will be constructed from this class, if header row
# processing is activated.
#
class CSV::Table[out Elem] < Object
  include Enumerable[untyped]
  extend Forwardable

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - new(array_of_rows, headers: nil)
  # -->
  # Constructs a new CSV::Table from `array_of_rows`, which are expected to be
  # CSV::Row objects. All rows are assumed to have the same headers.
  #
  # The optional `headers` parameter can be set to Array of headers. If headers
  # aren't set, headers are fetched from CSV::Row objects. Otherwise, headers()
  # method will return headers being set in headers argument.
  #
  # A CSV::Table object supports the following Array methods through delegation:
  #
  # *   empty?()
  # *   length()
  # *   size()
  #
  def initialize: (untyped array_of_rows, ?headers: untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table << row_or_array -> self
  # -->
  # If `row_or_array` is a CSV::Row object, it is appended to the table:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table << CSV::Row.new(table.headers, ['bat', 3])
  #     table[3] # => #<CSV::Row "Name":"bat" "Value":3>
  #
  # If `row_or_array` is an Array, it is used to create a new CSV::Row object
  # which is then appended to the table:
  #     table << ['bam', 4]
  #     table[4] # => #<CSV::Row "Name":"bam" "Value":4>
  #
  def <<: (untyped row_or_array) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - ==(other)
  # -->
  # Returns `true` if all each row of `self` `==` the corresponding row of
  # `other_table`, otherwise, `false`.
  #
  # The access mode does no affect the result.
  #
  # Equal tables:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     other_table = CSV.parse(source, headers: true)
  #     table == other_table # => true
  #
  # Different row count:
  #     other_table.delete(2)
  #     table == other_table # => false
  #
  # Different last row:
  #     other_table << ['bat', 3]
  #     table == other_table # => false
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table[n] -> row
  #   - table[range] -> array_of_rows
  #   - table[header] -> array_of_fields
  # -->
  # Returns data from the table;  does not modify the table.
  #
  # ---
  #
  # The expression `table[n]`, where `n` is a non-negative Integer, returns the
  # +n+th row of the table, if that row exists, and if the access mode is `:row`
  # or `:col_or_row`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
  #
  # Counts backward from the last row if `n` is negative:
  #     table[-1] # => #<CSV::Row "Name":"baz" "Value":"2">
  #
  # Returns `nil` if `n` is too large or too small:
  #     table[4] # => nil
  #     table[-4] => nil
  #
  # Raises an exception if the access mode is `:row` and `n` is not an
  # [Integer-convertible
  # object](https://docs.ruby-lang.org/en/master/implicit_conversion_rdoc.html#lab
  # el-Integer-Convertible+Objects).
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     # Raises TypeError (no implicit conversion of String into Integer):
  #     table['Name']
  #
  # ---
  #
  # The expression `table[range]`, where `range` is a Range object, returns rows
  # from the table, beginning at row `range.first`, if those rows exist, and if
  # the access mode is `:row` or `:col_or_row`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If there are too few rows, returns all from `range.first` to the end:
  #     rows = table[1..50] # => #<CSV::Row "Name":"bar" "Value":"1">
  #     rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # Special case:  if `range.start == table.size`, returns an empty Array:
  #     table[table.size..50] # => []
  #
  # If `range.end` is negative, calculates the ending index from the end:
  #     rows = table[0..-1]
  #     rows # => [#<CSV::Row "Name":"foo" "Value":"0">, #<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If `range.start` is negative, calculates the starting index from the end:
  #     rows = table[-1..2]
  #     rows # => [#<CSV::Row "Name":"baz" "Value":"2">]
  #
  # If `range.start` is larger than `table.size`, returns `nil`:
  #     table[4..4] # => nil
  #
  # ---
  #
  # The expression `table[header]`, where `header` is a String, returns column
  # values (Array of Strings) if the column exists and if the access mode is
  # `:col` or `:col_or_row`:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table['Name'] # => ["foo", "bar", "baz"]
  #     table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
  #     col = table['Name']
  #     col # => ["foo", "bar", "baz"]
  #
  # Modifying the returned column values does not modify the table:
  #     col[0] = 'bat'
  #     col # => ["bat", "bar", "baz"]
  #     table['Name'] # => ["foo", "bar", "baz"]
  #
  # Returns an Array of `nil` values if there is no such column:
  #     table['Nosuch'] # => [nil, nil, nil]
  #
  def []: (untyped index_or_header) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - []=(index_or_header, value)
  # -->
  # In the default mixed mode, this method assigns rows for index access and
  # columns for header access. You can force the index association by first
  # calling by_col!() or by_row!().
  #
  # Rows may be set to an Array of values (which will inherit the table's
  # headers()) or a CSV::Row.
  #
  # Columns may be set to a single value, which is copied to each row of the
  # column, or an Array of values. Arrays of values are assigned to rows top to
  # bottom in row major order. Excess values are ignored and if the Array does not
  # have a value for each row the extra rows will receive a `nil`.
  #
  # Assigning to an existing column or row clobbers the data. Assigning to new
  # columns creates them at the right end of the table.
  #
  def []=: (untyped index_or_header, untyped value) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_col()
  # -->
  # Returns a duplicate table object, in column mode. This is handy for chaining
  # in a single call without changing the table mode, but be aware that this
  # method can consume a fair amount of memory for bigger data sets.
  #
  # This method returns the duplicate table for chaining. Don't chain destructive
  # methods (like []=()) this way though, since you are working with a duplicate.
  #
  def by_col: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_col!()
  # -->
  # Switches the mode of this table to column mode. All calls to indexing and
  # iteration methods will work with columns until the mode is changed again.
  #
  # This method returns the table and is safe to chain.
  #
  def by_col!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_col_or_row()
  # -->
  # Returns a duplicate table object, in mixed mode. This is handy for chaining in
  # a single call without changing the table mode, but be aware that this method
  # can consume a fair amount of memory for bigger data sets.
  #
  # This method returns the duplicate table for chaining.  Don't chain destructive
  # methods (like []=()) this way though, since you are working with a duplicate.
  #
  def by_col_or_row: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_col_or_row!()
  # -->
  # Switches the mode of this table to mixed mode. All calls to indexing and
  # iteration methods will use the default intelligent indexing system until the
  # mode is changed again. In mixed mode an index is assumed to be a row reference
  # while anything else is assumed to be column access by headers.
  #
  # This method returns the table and is safe to chain.
  #
  def by_col_or_row!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_row()
  # -->
  # Returns a duplicate table object, in row mode.  This is handy for chaining in
  # a single call without changing the table mode, but be aware that this method
  # can consume a fair amount of memory for bigger data sets.
  #
  # This method returns the duplicate table for chaining.  Don't chain destructive
  # methods (like []=()) this way though, since you are working with a duplicate.
  #
  def by_row: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - by_row!()
  # -->
  # Switches the mode of this table to row mode. All calls to indexing and
  # iteration methods will work with rows until the mode is changed again.
  #
  # This method returns the table and is safe to chain.
  #
  def by_row!: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.delete(*indexes) -> deleted_values
  #   - table.delete(*headers) -> deleted_values
  # -->
  # If the access mode is `:row` or `:col_or_row`, and each argument is either an
  # Integer or a Range, returns deleted rows. Otherwise, returns deleted columns
  # data.
  #
  # In either case, the returned values are in the order specified by the
  # arguments.  Arguments may be repeated.
  #
  # ---
  #
  # Returns rows as an Array of CSV::Row objects.
  #
  # One index:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete(0)
  #     deleted_values # => [#<CSV::Row "Name":"foo" "Value":"0">]
  #
  # Two indexes:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete(2, 0)
  #     deleted_values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]
  #
  # ---
  #
  # Returns columns data as column Arrays.
  #
  # One header:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete('Name')
  #     deleted_values # => ["foo", "bar", "baz"]
  #
  # Two headers:
  #     table = CSV.parse(source, headers: true)
  #     deleted_values = table.delete('Value', 'Name')
  #     deleted_values # => [["0", "1", "2"], ["foo", "bar", "baz"]]
  #
  def delete: (*untyped indexes_or_headers) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - delete_if() { |header, self| ... }
  # -->
  # Removes rows or columns for which the block returns a truthy value; returns
  # `self`.
  #
  # Removes rows when the access mode is `:row` or `:col_or_row`; calls the block
  # with each CSV::Row object:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table.size # => 3
  #     table.delete_if {|row| row['Name'].start_with?('b') }
  #     table.size # => 1
  #
  # Removes columns when the access mode is `:col`; calls the block with each
  # column as a 2-element array containing the header and an Array of column
  # fields:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table.headers.size # => 2
  #     table.delete_if {|column_data| column_data[1].include?('2') }
  #     table.headers.size # => 1
  #
  # Returns a new Enumerator if no block is given:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.delete_if # => #<Enumerator: #<CSV::Table mode:col_or_row row_count:4>:delete_if>
  #
  def delete_if: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - dig(index_or_header, *index_or_headers)
  # -->
  # Extracts the nested value specified by the sequence of `index` or `header`
  # objects by calling dig at each step, returning nil if any intermediate step is
  # nil.
  #
  def dig: (untyped index_or_header, *untyped index_or_headers) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - each() { |header, self| ... }
  # -->
  # Calls the block with each row or column; returns `self`.
  #
  # When the access mode is `:row` or `:col_or_row`, calls the block with each
  # CSV::Row object:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.by_row! # => #<CSV::Table mode:row row_count:4>
  #     table.each {|row| p row }
  #
  # Output:
  #     #<CSV::Row "Name":"foo" "Value":"0">
  #     #<CSV::Row "Name":"bar" "Value":"1">
  #     #<CSV::Row "Name":"baz" "Value":"2">
  #
  # When the access mode is `:col`, calls the block with each column as a
  # 2-element array containing the header and an Array of column fields:
  #     table.by_col! # => #<CSV::Table mode:col row_count:4>
  #     table.each {|column_data| p column_data }
  #
  # Output:
  #     ["Name", ["foo", "bar", "baz"]]
  #     ["Value", ["0", "1", "2"]]
  #
  # Returns a new Enumerator if no block is given:
  #     table.each # => #<Enumerator: #<CSV::Table mode:col row_count:4>:each>
  #
  def each: () -> Enumerator[untyped, self]
          | () { (untyped) -> void } -> self
          | () { (*untyped) -> void } -> self

  def empty?: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - headers()
  # -->
  # Returns the headers for the first row of this table (assumed to match all
  # other rows). The headers Array passed to CSV::Table.new is returned for empty
  # tables.
  #
  def headers: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - inspect()
  # -->
  # Shows the mode and size of this table in a US-ASCII String.
  #
  def inspect: () -> String

  def length: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!-- rdoc-file=lib/csv/table.rb -->
  # The current access mode for indexing and iteration.
  #
  def mode: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.push(*rows_or_arrays) -> self
  # -->
  # A shortcut for appending multiple rows. Equivalent to:
  #     rows.each {|row| self << row }
  #
  # Each argument may be either a CSV::Row object or an Array:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     rows = [
  #       CSV::Row.new(table.headers, ['bat', 3]),
  #       ['bam', 4]
  #     ]
  #     table.push(*rows)
  #     table[3..4] # => [#<CSV::Row "Name":"bat" "Value":3>, #<CSV::Row "Name":"bam" "Value":4>]
  #
  def push: (*untyped rows) -> untyped

  def size: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - to_a()
  # -->
  # Returns the table as an Array of Arrays. Headers will be the first row, then
  # all of the field rows will follow.
  #
  def to_a: () -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - to_csv(write_headers: true, **options)
  # -->
  # Returns the table as a complete CSV String. Headers will be listed first, then
  # all of the field rows.
  #
  # This method assumes you want the Table.headers(), unless you explicitly pass
  # `:write_headers => false`.
  #
  def to_csv: (?write_headers: boolish, **untyped) -> untyped

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - to_s(write_headers: true, **options)
  # -->
  #
  alias to_s to_csv

  # <!--
  #   rdoc-file=lib/csv/table.rb
  #   - table.values_at(*indexes) -> array_of_rows
  #   - table.values_at(*headers) -> array_of_columns_data
  # -->
  # If the access mode is `:row` or `:col_or_row`, and each argument is either an
  # Integer or a Range, returns rows. Otherwise, returns columns data.
  #
  # In either case, the returned values are in the order specified by the
  # arguments.  Arguments may be repeated.
  #
  # ---
  #
  # Returns rows as an Array of CSV::Row objects.
  #
  # No argument:
  #     source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
  #     table = CSV.parse(source, headers: true)
  #     table.values_at # => []
  #
  # One index:
  #     values = table.values_at(0)
  #     values # => [#<CSV::Row "Name":"foo" "Value":"0">]
  #
  # Two indexes:
  #     values = table.values_at(2, 0)
  #     values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]
  #
  # One Range:
  #     values = table.values_at(1..2)
  #     values # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # Ranges and indexes:
  #     values = table.values_at(0..1, 1..2, 0, 2)
  #     pp values
  #
  # Output:
  #     [#<CSV::Row "Name":"foo" "Value":"0">,
  #      #<CSV::Row "Name":"bar" "Value":"1">,
  #      #<CSV::Row "Name":"bar" "Value":"1">,
  #      #<CSV::Row "Name":"baz" "Value":"2">,
  #      #<CSV::Row "Name":"foo" "Value":"0">,
  #      #<CSV::Row "Name":"baz" "Value":"2">]
  #
  # ---
  #
  # Returns columns data as row Arrays, each consisting of the specified columns
  # data for that row:
  #     values = table.values_at('Name')
  #     values # => [["foo"], ["bar"], ["baz"]]
  #     values = table.values_at('Value', 'Name')
  #     values # => [["0", "foo"], ["1", "bar"], ["2", "baz"]]
  #
  def values_at: (*untyped indices_or_headers) -> untyped
end

# <!-- rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb -->
# Provides mathematical functions.
#
# Example:
#
#     require "bigdecimal/math"
#
#     include BigMath
#
#     a = BigDecimal((PI(100)/2).to_s)
#     puts sin(a,100) # => 0.99999999999999999999......e0
#
module BigMath
  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - E(numeric) -> BigDecimal
  # -->
  # Computes e (the base of natural logarithms) to the specified number of digits
  # of precision, `numeric`.
  #
  #     BigMath.E(10).to_s
  #     #=> "0.271828182845904523536028752390026306410273e1"
  #
  def self?.E: (Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - PI(numeric) -> BigDecimal
  # -->
  # Computes the value of pi to the specified number of digits of precision,
  # `numeric`.
  #
  #     BigMath.PI(10).to_s
  #     #=> "0.3141592653589793238462643388813853786957412e1"
  #
  def self?.PI: (Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - atan(decimal, numeric) -> BigDecimal
  # -->
  # Computes the arctangent of `decimal` to the specified number of digits of
  # precision, `numeric`.
  #
  # If `decimal` is NaN, returns NaN.
  #
  #     BigMath.atan(BigDecimal('-1'), 16).to_s
  #     #=> "-0.785398163397448309615660845819878471907514682065e0"
  #
  def self?.atan: (BigDecimal x, Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - cos(decimal, numeric) -> BigDecimal
  # -->
  # Computes the cosine of `decimal` to the specified number of digits of
  # precision, `numeric`.
  #
  # If `decimal` is Infinity or NaN, returns NaN.
  #
  #     BigMath.cos(BigMath.PI(4), 16).to_s
  #     #=> "-0.999999999999999999999999999999856613163740061349e0"
  #
  def self?.cos: (BigDecimal x, Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigMath.exp(decimal, numeric)    -> BigDecimal
  # -->
  # Computes the value of e (the base of natural logarithms) raised to the power
  # of `decimal`, to the specified number of digits of precision.
  #
  # If `decimal` is infinity, returns Infinity.
  #
  # If `decimal` is NaN, returns NaN.
  #
  def self?.exp: (BigDecimal, Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigMath.log(decimal, numeric)    -> BigDecimal
  # -->
  # Computes the natural logarithm of `decimal` to the specified number of digits
  # of precision, `numeric`.
  #
  # If `decimal` is zero or negative, raises Math::DomainError.
  #
  # If `decimal` is positive infinity, returns Infinity.
  #
  # If `decimal` is NaN, returns NaN.
  #
  def self?.log: (BigDecimal, Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - sin(decimal, numeric) -> BigDecimal
  # -->
  # Computes the sine of `decimal` to the specified number of digits of precision,
  # `numeric`.
  #
  # If `decimal` is Infinity or NaN, returns NaN.
  #
  #     BigMath.sin(BigMath.PI(5)/4, 5).to_s
  #     #=> "0.70710678118654752440082036563292800375e0"
  #
  def self?.sin: (BigDecimal x, Numeric prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/lib/bigdecimal/math.rb
  #   - sqrt(decimal, numeric) -> BigDecimal
  # -->
  # Computes the square root of `decimal` to the specified number of digits of
  # precision, `numeric`.
  #
  #     BigMath.sqrt(BigDecimal('2'), 16).to_s
  #     #=> "0.1414213562373095048801688724e1"
  #
  def self?.sqrt: (BigDecimal x, Numeric prec) -> BigDecimal
end

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# BigDecimal provides arbitrary-precision floating point decimal arithmetic.
#
# ## Introduction
#
# Ruby provides built-in support for arbitrary precision integer arithmetic.
#
# For example:
#
#     42**13  #=>   1265437718438866624512
#
# BigDecimal provides similar support for very large or very accurate floating
# point numbers.
#
# Decimal arithmetic is also useful for general calculation, because it provides
# the correct answers people expect--whereas normal binary floating point
# arithmetic often introduces subtle errors because of the conversion between
# base 10 and base 2.
#
# For example, try:
#
#     sum = 0
#     10_000.times do
#       sum = sum + 0.0001
#     end
#     print sum #=> 0.9999999999999062
#
# and contrast with the output from:
#
#     require 'bigdecimal'
#
#     sum = BigDecimal("0")
#     10_000.times do
#       sum = sum + BigDecimal("0.0001")
#     end
#     print sum #=> 0.1E1
#
# Similarly:
#
#     (BigDecimal("1.2") - BigDecimal("1.0")) == BigDecimal("0.2") #=> true
#
#     (1.2 - 1.0) == 0.2 #=> false
#
# ## A Note About Precision
#
# For a calculation using a BigDecimal and another `value`, the precision of the
# result depends on the type of `value`:
#
# *   If `value` is a Float, the precision is Float::DIG + 1.
# *   If `value` is a Rational, the precision is larger than Float::DIG + 1.
# *   If `value` is a BigDecimal, the precision is `value`'s precision in the
#     internal representation, which is platform-dependent.
# *   If `value` is other object, the precision is determined by the result of
#     +BigDecimal(value)+.
#
#
# ## Special features of accurate decimal arithmetic
#
# Because BigDecimal is more accurate than normal binary floating point
# arithmetic, it requires some special values.
#
# ### Infinity
#
# BigDecimal sometimes needs to return infinity, for example if you divide a
# value by zero.
#
#     BigDecimal("1.0") / BigDecimal("0.0")  #=> Infinity
#     BigDecimal("-1.0") / BigDecimal("0.0")  #=> -Infinity
#
# You can represent infinite numbers to BigDecimal using the strings
# `'Infinity'`, `'+Infinity'` and `'-Infinity'` (case-sensitive)
#
# ### Not a Number
#
# When a computation results in an undefined value, the special value `NaN` (for
# 'not a number') is returned.
#
# Example:
#
#     BigDecimal("0.0") / BigDecimal("0.0") #=> NaN
#
# You can also create undefined values.
#
# NaN is never considered to be the same as any other value, even NaN itself:
#
#     n = BigDecimal('NaN')
#     n == 0.0 #=> false
#     n == n #=> false
#
# ### Positive and negative zero
#
# If a computation results in a value which is too small to be represented as a
# BigDecimal within the currently specified limits of precision, zero must be
# returned.
#
# If the value which is too small to be represented is negative, a BigDecimal
# value of negative zero is returned.
#
#     BigDecimal("1.0") / BigDecimal("-Infinity") #=> -0.0
#
# If the value is positive, a value of positive zero is returned.
#
#     BigDecimal("1.0") / BigDecimal("Infinity") #=> 0.0
#
# (See BigDecimal.mode for how to specify limits of precision.)
#
# Note that `-0.0` and `0.0` are considered to be the same for the purposes of
# comparison.
#
# Note also that in mathematics, there is no particular concept of negative or
# positive zero; true mathematical zero has no sign.
#
# ## bigdecimal/util
#
# When you require `bigdecimal/util`, the #to_d method will be available on
# BigDecimal and the native Integer, Float, Rational, and String classes:
#
#     require 'bigdecimal/util'
#
#     42.to_d         # => 0.42e2
#     0.5.to_d        # => 0.5e0
#     (2/3r).to_d(3)  # => 0.667e0
#     "0.5".to_d      # => 0.5e0
#
# ## License
#
# Copyright (C) 2002 by Shigeo Kobayashi <shigeo@tinyforest.gr.jp>.
#
# BigDecimal is released under the Ruby and 2-clause BSD licenses. See
# LICENSE.txt for details.
#
# Maintained by mrkn <mrkn@mrkn.jp> and ruby-core members.
#
# Documented by zzak <zachary@zacharyscott.net>, mathew <meta@pobox.com>, and
# many other contributors.
#
class BigDecimal < Numeric
  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - _load(p1)
  # -->
  # Internal method used to provide marshalling support. See the Marshal module.
  #
  def self._load: (String) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.double_fig -> integer
  # -->
  # Returns the number of digits a Float object is allowed to have; the result is
  # system-dependent:
  #
  #     BigDecimal.double_fig # => 16
  #
  def self.double_fig: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - interpret_loosely(p1)
  # -->
  #
  def self.interpret_loosely: (string) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.limit(digits)
  # -->
  # Limit the number of significant digits in newly created BigDecimal numbers to
  # the specified value. Rounding is performed as necessary, as specified by
  # BigDecimal.mode.
  #
  # A limit of 0, the default, means no upper limit.
  #
  # The limit specified by this method takes less priority over any limit
  # specified to instance methods such as ceil, floor, truncate, or round.
  #
  def self.limit: (?Integer? digits) -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.mode(mode, setting = nil) -> integer
  # -->
  # Returns an integer representing the mode settings for exception handling and
  # rounding.
  #
  # These modes control exception handling:
  #
  # *   BigDecimal::EXCEPTION_NaN.
  # *   BigDecimal::EXCEPTION_INFINITY.
  # *   BigDecimal::EXCEPTION_UNDERFLOW.
  # *   BigDecimal::EXCEPTION_OVERFLOW.
  # *   BigDecimal::EXCEPTION_ZERODIVIDE.
  # *   BigDecimal::EXCEPTION_ALL.
  #
  #
  # Values for `setting` for exception handling:
  #
  # *   `true`: sets the given `mode` to `true`.
  # *   `false`: sets the given `mode` to `false`.
  # *   `nil`: does not modify the mode settings.
  #
  #
  # You can use method BigDecimal.save_exception_mode to temporarily change, and
  # then automatically restore, exception modes.
  #
  # For clarity, some examples below begin by setting all exception modes to
  # `false`.
  #
  # This mode controls the way rounding is to be performed:
  #
  # *   BigDecimal::ROUND_MODE
  #
  #
  # You can use method BigDecimal.save_rounding_mode to temporarily change, and
  # then automatically restore, the rounding mode.
  #
  # **NaNs**
  #
  # Mode BigDecimal::EXCEPTION_NaN controls behavior when a BigDecimal NaN is
  # created.
  #
  # Settings:
  #
  # *   `false` (default): Returns `BigDecimal('NaN')`.
  # *   `true`: Raises FloatDomainError.
  #
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
  #     BigDecimal('NaN')                                 # => NaN
  #     BigDecimal.mode(BigDecimal::EXCEPTION_NaN, true)  # => 2
  #     BigDecimal('NaN') # Raises FloatDomainError
  #
  # **Infinities**
  #
  # Mode BigDecimal::EXCEPTION_INFINITY controls behavior when a BigDecimal
  # Infinity or -Infinity is created. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
  #     BigDecimal('Infinity')                                # => Infinity
  #     BigDecimal('-Infinity')                               # => -Infinity
  #     BigDecimal.mode(BigDecimal::EXCEPTION_INFINITY, true) # => 1
  #     BigDecimal('Infinity')  # Raises FloatDomainError
  #     BigDecimal('-Infinity') # Raises FloatDomainError
  #
  # **Underflow**
  #
  # Mode BigDecimal::EXCEPTION_UNDERFLOW controls behavior when a BigDecimal
  # underflow occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('0')` or `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)      # => 0
  #     def flow_under
  #       x = BigDecimal('0.1')
  #       100.times { x *= x }
  #     end
  #     flow_under                                             # => 100
  #     BigDecimal.mode(BigDecimal::EXCEPTION_UNDERFLOW, true) # => 4
  #     flow_under # Raises FloatDomainError
  #
  # **Overflow**
  #
  # Mode BigDecimal::EXCEPTION_OVERFLOW controls behavior when a BigDecimal
  # overflow occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
  #     def flow_over
  #       x = BigDecimal('10')
  #       100.times { x *= x }
  #     end
  #     flow_over                                             # => 100
  #     BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, true) # => 1
  #     flow_over # Raises FloatDomainError
  #
  # **Zero Division**
  #
  # Mode BigDecimal::EXCEPTION_ZERODIVIDE controls behavior when a zero-division
  # occurs. Settings:
  #
  # *   `false` (default): Returns `BigDecimal('Infinity')` or
  #     `BigDecimal('-Infinity')`.
  # *   `true`: Raises FloatDomainError.
  #
  #
  # Examples:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)       # => 0
  #     one = BigDecimal('1')
  #     zero = BigDecimal('0')
  #     one / zero                                              # => Infinity
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ZERODIVIDE, true) # => 16
  #     one / zero # Raises FloatDomainError
  #
  # **All Exceptions**
  #
  # Mode BigDecimal::EXCEPTION_ALL controls all of the above:
  #
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
  #     BigDecimal.mode(BigDecimal::EXCEPTION_ALL, true)  # => 23
  #
  # **Rounding**
  #
  # Mode BigDecimal::ROUND_MODE controls the way rounding is to be performed; its
  # `setting` values are:
  #
  # *   `ROUND_UP`: Round away from zero. Aliased as `:up`.
  # *   `ROUND_DOWN`: Round toward zero. Aliased as `:down` and `:truncate`.
  # *   `ROUND_HALF_UP`: Round toward the nearest neighbor; if the neighbors are
  #     equidistant, round away from zero. Aliased as `:half_up` and `:default`.
  # *   `ROUND_HALF_DOWN`: Round toward the nearest neighbor; if the neighbors are
  #     equidistant, round toward zero. Aliased as `:half_down`.
  # *   `ROUND_HALF_EVEN` (Banker's rounding): Round toward the nearest neighbor;
  #     if the neighbors are equidistant, round toward the even neighbor. Aliased
  #     as `:half_even` and `:banker`.
  # *   `ROUND_CEILING`: Round toward positive infinity. Aliased as `:ceiling` and
  #     `:ceil`.
  # *   `ROUND_FLOOR`: Round toward negative infinity. Aliased as `:floor:`.
  #
  def self.mode: (Integer mode, ?Integer? value) -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_exception_mode { ... }
  # -->
  # Execute the provided block, but preserve the exception mode
  #
  #     BigDecimal.save_exception_mode do
  #       BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, false)
  #       BigDecimal.mode(BigDecimal::EXCEPTION_NaN, false)
  #
  #       BigDecimal(BigDecimal('Infinity'))
  #       BigDecimal(BigDecimal('-Infinity'))
  #       BigDecimal(BigDecimal('NaN'))
  #     end
  #
  # For use with the BigDecimal::EXCEPTION_*
  #
  # See BigDecimal.mode
  #
  def self.save_exception_mode: () { (?nil) -> void } -> void

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_limit { ... }
  # -->
  # Execute the provided block, but preserve the precision limit
  #
  #     BigDecimal.limit(100)
  #     puts BigDecimal.limit
  #     BigDecimal.save_limit do
  #         BigDecimal.limit(200)
  #         puts BigDecimal.limit
  #     end
  #     puts BigDecimal.limit
  #
  def self.save_limit: () { (?nil) -> void } -> void

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal.save_rounding_mode { ... }
  # -->
  # Execute the provided block, but preserve the rounding mode
  #
  #     BigDecimal.save_rounding_mode do
  #       BigDecimal.mode(BigDecimal::ROUND_MODE, :up)
  #       puts BigDecimal.mode(BigDecimal::ROUND_MODE)
  #     end
  #
  # For use with the BigDecimal::ROUND_*
  #
  # See BigDecimal.mode
  #
  def self.save_rounding_mode: () { (?nil) -> void } -> void

  public

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - a % b
  #   - a.modulo(b)
  # -->
  # Returns the modulus from dividing by b.
  #
  # See BigDecimal#divmod.
  #
  def %: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - *(p1)
  # -->
  #
  def *: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self ** other -> bigdecimal
  # -->
  # Returns the BigDecimal value of `self` raised to power `other`:
  #
  #     b = BigDecimal('3.14')
  #     b ** 2              # => 0.98596e1
  #     b ** 2.0            # => 0.98596e1
  #     b ** Rational(2, 1) # => 0.98596e1
  #
  # Related: BigDecimal#power.
  #
  def **: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self + value -> bigdecimal
  # -->
  # Returns the BigDecimal sum of `self` and `value`:
  #
  #     b = BigDecimal('111111.111') # => 0.111111111e6
  #     b + 2                        # => 0.111113111e6
  #     b + 2.0                      # => 0.111113111e6
  #     b + Rational(2, 1)           # => 0.111113111e6
  #     b + Complex(2, 0)            # => (0.111113111e6+0i)
  #
  # See the [Note About
  # Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).
  #
  def +: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - +big_decimal -> self
  # -->
  # Returns `self`:
  #
  #     +BigDecimal(5)  # => 0.5e1
  #     +BigDecimal(-5) # => -0.5e1
  #
  def +@: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self - value -> bigdecimal
  # -->
  # Returns the BigDecimal difference of `self` and `value`:
  #
  #     b = BigDecimal('333333.333') # => 0.333333333e6
  #     b - 2                        # => 0.333331333e6
  #     b - 2.0                      # => 0.333331333e6
  #     b - Rational(2, 1)           # => 0.333331333e6
  #     b - Complex(2, 0)            # => (0.333331333e6+0i)
  #
  # See the [Note About
  # Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).
  #
  def -: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - -self -> bigdecimal
  # -->
  # Returns the BigDecimal negation of self:
  #
  #     b0 = BigDecimal('1.5')
  #     b1 = -b0 # => -0.15e1
  #     b2 = -b1 # => 0.15e1
  #
  def -@: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - a / b   -> bigdecimal
  # -->
  # Divide by the specified value.
  #
  # The result precision will be the precision of the larger operand, but its
  # minimum is 2*Float::DIG.
  #
  # See BigDecimal#div. See BigDecimal#quo.
  #
  def /: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self < other -> true or false
  # -->
  # Returns `true` if `self` is less than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5') # => 0.15e1
  #     b < 2                 # => true
  #     b < 2.0               # => true
  #     b < Rational(2, 1)    # => true
  #     b < 1.5               # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self <= other -> true or false
  # -->
  # Returns `true` if `self` is less or equal to than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5') # => 0.15e1
  #     b <= 2                # => true
  #     b <= 2.0              # => true
  #     b <= Rational(2, 1)   # => true
  #     b <= 1.5              # => true
  #     b < 1                 # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def <=: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - <=>(p1)
  # -->
  # The comparison operator. a <=> b is 0 if a == b, 1 if a > b, -1 if a < b.
  #
  def <=>: (untyped) -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - ==(p1)
  # -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self > other -> true or false
  # -->
  # Returns `true` if `self` is greater than `other`, `false` otherwise:
  #
  #     b = BigDecimal('1.5')
  #     b > 1              # => true
  #     b > 1.0            # => true
  #     b > Rational(1, 1) # => true
  #     b > 2              # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - self >= other -> true or false
  # -->
  # Returns `true` if `self` is greater than or equal to `other`, `false`
  # otherwise:
  #
  #     b = BigDecimal('1.5')
  #     b >= 1              # => true
  #     b >= 1.0            # => true
  #     b >= Rational(1, 1) # => true
  #     b >= 1.5            # => true
  #     b > 2               # => false
  #
  # Raises an exception if the comparison cannot be made.
  #
  def >=: (Numeric) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - _dump -> string
  # -->
  # Returns a string representing the marshalling of `self`. See module Marshal.
  #
  #     inf = BigDecimal('Infinity') # => Infinity
  #     dumped = inf._dump           # => "9:Infinity"
  #     BigDecimal._load(dumped)     # => Infinity
  #
  def _dump: (?untyped) -> String

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - abs -> bigdecimal
  # -->
  # Returns the BigDecimal absolute value of `self`:
  #
  #     BigDecimal('5').abs  # => 0.5e1
  #     BigDecimal('-3').abs # => 0.3e1
  #
  def abs: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - add(value, ndigits) -> new_bigdecimal
  # -->
  # Returns the BigDecimal sum of `self` and `value` with a precision of `ndigits`
  # decimal digits.
  #
  # When `ndigits` is less than the number of significant digits in the sum, the
  # sum is rounded to that number of digits, according to the current rounding
  # mode; see BigDecimal.mode.
  #
  # Examples:
  #
  #     # Set the rounding mode.
  #     BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
  #     b = BigDecimal('111111.111')
  #     b.add(1, 0)               # => 0.111112111e6
  #     b.add(1, 3)               # => 0.111e6
  #     b.add(1, 6)               # => 0.111112e6
  #     b.add(1, 15)              # => 0.111112111e6
  #     b.add(1.0, 15)            # => 0.111112111e6
  #     b.add(Rational(1, 1), 15) # => 0.111112111e6
  #
  def add: (Numeric value, Integer digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - ceil(n)
  # -->
  # Return the smallest integer greater than or equal to the value, as a
  # BigDecimal.
  #
  #     BigDecimal('3.14159').ceil #=> 4
  #     BigDecimal('-9.1').ceil #=> -9
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').ceil(3) #=> 3.142
  #     BigDecimal('13345.234').ceil(-2) #=> 13400.0
  #
  def ceil: () -> Integer
          | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - clone()
  # -->
  #
  def clone: () -> self

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - coerce(p1)
  # -->
  # The coerce method provides support for Ruby type coercion. It is not enabled
  # by default.
  #
  # This means that binary operations like + * / or - can often be performed on a
  # BigDecimal and an object of another type, if the other object can be coerced
  # into a BigDecimal value.
  #
  # e.g.
  #     a = BigDecimal("1.0")
  #     b = a / 2.0 #=> 0.5
  #
  # Note that coercing a String to a BigDecimal is not supported by default; it
  # requires a special compile-time option when building Ruby.
  #
  def coerce: (Numeric) -> [ BigDecimal, BigDecimal ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - div(value)  -> integer
  #   - div(value, digits)  -> bigdecimal or integer
  # -->
  # Divide by the specified value.
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to that number of digits, according to
  #     BigDecimal.mode.
  #
  #     If digits is 0, the result is the same as for the / operator or #quo.
  #
  #     If digits is not specified, the result is an integer, by analogy with
  #     Float#div; see also BigDecimal#divmod.
  #
  #
  # See BigDecimal#/. See BigDecimal#quo.
  #
  # Examples:
  #
  #     a = BigDecimal("4")
  #     b = BigDecimal("3")
  #
  #     a.div(b, 3)  # => 0.133e1
  #
  #     a.div(b, 0)  # => 0.1333333333333333333e1
  #     a / b        # => 0.1333333333333333333e1
  #     a.quo(b)     # => 0.1333333333333333333e1
  #
  #     a.div(b)     # => 1
  #
  def div: (Numeric value) -> Integer
         | (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - divmod(value)
  # -->
  # Divides by the specified value, and returns the quotient and modulus as
  # BigDecimal numbers. The quotient is rounded towards negative infinity.
  #
  # For example:
  #
  #     require 'bigdecimal'
  #
  #     a = BigDecimal("42")
  #     b = BigDecimal("9")
  #
  #     q, m = a.divmod(b)
  #
  #     c = q * b + m
  #
  #     a == c  #=> true
  #
  # The quotient q is (a/b).floor, and the modulus is the amount that must be
  # added to q * b to get a.
  #
  def divmod: (Numeric) -> [ BigDecimal, BigDecimal ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - dup()
  # -->
  #
  def dup: () -> self

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Tests for value equality; returns true if the values are equal.
  #
  # The == and === operators and the eql? method have the same implementation for
  # BigDecimal.
  #
  # Values may be coerced to perform the comparison:
  #
  #     BigDecimal('1.0') == 1.0  #=> true
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - exponent()
  # -->
  # Returns the exponent of the BigDecimal number, as an Integer.
  #
  # If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of
  # digits with no leading zeros, then n is the exponent.
  #
  def exponent: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - finite?()
  # -->
  # Returns True if the value is finite (not NaN or infinite).
  #
  def finite?: () -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - fix()
  # -->
  # Return the integer part of the number, as a BigDecimal.
  #
  def fix: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - floor(n)
  # -->
  # Return the largest integer less than or equal to the value, as a BigDecimal.
  #
  #     BigDecimal('3.14159').floor #=> 3
  #     BigDecimal('-9.1').floor #=> -10
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').floor(3) #=> 3.141
  #     BigDecimal('13345.234').floor(-2) #=> 13300.0
  #
  def floor: () -> Integer
           | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - frac()
  # -->
  # Return the fractional part of the number, as a BigDecimal.
  #
  def frac: () -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - hash -> integer
  # -->
  # Returns the integer hash value for `self`.
  #
  # Two instances of BigDecimal have the same hash value if and only if they have
  # equal:
  #
  # *   Sign.
  # *   Fractional part.
  # *   Exponent.
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - infinite?()
  # -->
  # Returns nil, -1, or +1 depending on whether the value is finite, -Infinity, or
  # +Infinity.
  #
  def infinite?: () -> Integer?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - inspect()
  # -->
  # Returns a string representation of self.
  #
  #     BigDecimal("1234.5678").inspect
  #       #=> "0.12345678e4"
  #
  def inspect: () -> String

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Returns the modulus from dividing by b.
  #
  # See BigDecimal#divmod.
  #
  def modulo: (Numeric b) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - mult(other, ndigits) -> bigdecimal
  # -->
  # Returns the BigDecimal product of `self` and `value` with a precision of
  # `ndigits` decimal digits.
  #
  # When `ndigits` is less than the number of significant digits in the sum, the
  # sum is rounded to that number of digits, according to the current rounding
  # mode; see BigDecimal.mode.
  #
  # Examples:
  #
  #     # Set the rounding mode.
  #     BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
  #     b = BigDecimal('555555.555')
  #     b.mult(3, 0)              # => 0.1666666665e7
  #     b.mult(3, 3)              # => 0.167e7
  #     b.mult(3, 6)              # => 0.166667e7
  #     b.mult(3, 15)             # => 0.1666666665e7
  #     b.mult(3.0, 0)            # => 0.1666666665e7
  #     b.mult(Rational(3, 1), 0) # => 0.1666666665e7
  #     b.mult(Complex(3, 0), 0)  # => (0.1666666665e7+0.0i)
  #
  def mult: (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - nan?()
  # -->
  # Returns True if the value is Not a Number.
  #
  def nan?: () -> bool

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - nonzero?()
  # -->
  # Returns self if the value is non-zero, nil otherwise.
  #
  def nonzero?: () -> self?

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - power(n)
  #   - power(n, prec)
  # -->
  # Returns the value raised to the power of n.
  #
  # Note that n must be an Integer.
  #
  # Also available as the operator **.
  #
  def power: (Numeric n, int prec) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - precs -> array
  # -->
  # Returns an Array of two Integer values that represent platform-dependent
  # internal storage properties.
  #
  # This method is deprecated and will be removed in the future. Instead, use
  # BigDecimal#n_significant_digits for obtaining the number of significant digits
  # in scientific notation, and BigDecimal#precision for obtaining the number of
  # digits in decimal notation.
  #
  def precs: () -> [ Integer, Integer ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - quo(value)  -> bigdecimal
  #   - quo(value, digits)  -> bigdecimal
  # -->
  # Divide by the specified value.
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to the given number of digits, according to the
  #     rounding mode indicated by BigDecimal.mode.
  #
  #     If digits is 0 or omitted, the result is the same as for the / operator.
  #
  #
  # See BigDecimal#/. See BigDecimal#div.
  #
  def quo: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - remainder(value)
  # -->
  # Returns the remainder from dividing by the value.
  #
  # x.remainder(y) means x-y*(x/y).truncate
  #
  def remainder: (Numeric) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - round(n, mode)
  # -->
  # Round to the nearest integer (by default), returning the result as a
  # BigDecimal if n is specified, or as an Integer if it isn't.
  #
  #     BigDecimal('3.14159').round #=> 3
  #     BigDecimal('8.7').round #=> 9
  #     BigDecimal('-9.9').round #=> -10
  #
  #     BigDecimal('3.14159').round(2).class.name #=> "BigDecimal"
  #     BigDecimal('3.14159').round.class.name #=> "Integer"
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result, and return value will be an Integer.
  #
  #     BigDecimal('3.14159').round(3) #=> 3.142
  #     BigDecimal('13345.234').round(-2) #=> 13300
  #
  # The value of the optional mode argument can be used to determine how rounding
  # is performed; see BigDecimal.mode.
  #
  def round: () -> Integer
           | (Numeric n, ?Integer mode) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sign()
  # -->
  # Returns the sign of the value.
  #
  # Returns a positive value if > 0, a negative value if < 0, and a zero if == 0.
  #
  # The specific value returned indicates the type and sign of the BigDecimal, as
  # follows:
  #
  # BigDecimal::SIGN_NaN
  # :   value is Not a Number
  # BigDecimal::SIGN_POSITIVE_ZERO
  # :   value is +0
  # BigDecimal::SIGN_NEGATIVE_ZERO
  # :   value is -0
  # BigDecimal::SIGN_POSITIVE_INFINITE
  # :   value is +Infinity
  # BigDecimal::SIGN_NEGATIVE_INFINITE
  # :   value is -Infinity
  # BigDecimal::SIGN_POSITIVE_FINITE
  # :   value is positive
  # BigDecimal::SIGN_NEGATIVE_FINITE
  # :   value is negative
  #
  def sign: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - split()
  # -->
  # Splits a BigDecimal number into four parts, returned as an array of values.
  #
  # The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if
  # the BigDecimal is Not a Number.
  #
  # The second value is a string representing the significant digits of the
  # BigDecimal, with no leading zeros.
  #
  # The third value is the base used for arithmetic (currently always 10) as an
  # Integer.
  #
  # The fourth value is an Integer exponent.
  #
  # If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the
  # string of significant digits with no leading zeros, and n is the exponent.
  #
  # From these values, you can translate a BigDecimal to a float as follows:
  #
  #     sign, significant_digits, base, exponent = a.split
  #     f = sign * "0.#{significant_digits}".to_f * (base ** exponent)
  #
  # (Note that the to_f method is provided as a more convenient way to translate a
  # BigDecimal to a Float.)
  #
  def split: () -> [ Integer, String, Integer, Integer ]

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sqrt(n)
  # -->
  # Returns the square root of the value.
  #
  # Result has at least n significant digits.
  #
  def sqrt: (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - sub(value, digits)  -> bigdecimal
  # -->
  # Subtract the specified value.
  #
  # e.g.
  #     c = a.sub(b,n)
  #
  # digits
  # :   If specified and less than the number of significant digits of the result,
  #     the result is rounded to that number of digits, according to
  #     BigDecimal.mode.
  #
  def sub: (Numeric value, int digits) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_f()
  # -->
  # Returns a new Float object having approximately the same value as the
  # BigDecimal number. Normal accuracy limits and built-in errors of binary Float
  # arithmetic apply.
  #
  def to_f: () -> Float

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_i()
  # -->
  # Returns the value as an Integer.
  #
  # If the BigDecimal is infinity or NaN, raises FloatDomainError.
  #
  def to_i: () -> Integer

  # <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
  # Returns the value as an Integer.
  #
  # If the BigDecimal is infinity or NaN, raises FloatDomainError.
  #
  def to_int: () -> Integer

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_r()
  # -->
  # Converts a BigDecimal to a Rational.
  #
  def to_r: () -> Rational

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - to_s(s)
  # -->
  # Converts the value to a string.
  #
  # The default format looks like  0.xxxxEnn.
  #
  # The optional parameter s consists of either an integer; or an optional '+' or
  # ' ', followed by an optional number, followed by an optional 'E' or 'F'.
  #
  # If there is a '+' at the start of s, positive values are returned with a
  # leading '+'.
  #
  # A space at the start of s returns positive values with a leading space.
  #
  # If s contains a number, a space is inserted after each group of that many
  # fractional digits.
  #
  # If s ends with an 'E', engineering notation (0.xxxxEnn) is used.
  #
  # If s ends with an 'F', conventional floating point notation is used.
  #
  # Examples:
  #
  #     BigDecimal('-123.45678901234567890').to_s('5F')
  #       #=> '-123.45678 90123 45678 9'
  #
  #     BigDecimal('123.45678901234567890').to_s('+8F')
  #       #=> '+123.45678901 23456789'
  #
  #     BigDecimal('123.45678901234567890').to_s(' F')
  #       #=> ' 123.4567890123456789'
  #
  def to_s: (?String | int s) -> String

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - truncate(n)
  # -->
  # Truncate to the nearest integer (by default), returning the result as a
  # BigDecimal.
  #
  #     BigDecimal('3.14159').truncate #=> 3
  #     BigDecimal('8.7').truncate #=> 8
  #     BigDecimal('-9.9').truncate #=> -9
  #
  # If n is specified and positive, the fractional part of the result has no more
  # than that many digits.
  #
  # If n is specified and negative, at least that many digits to the left of the
  # decimal point will be 0 in the result.
  #
  #     BigDecimal('3.14159').truncate(3) #=> 3.141
  #     BigDecimal('13345.234').truncate(-2) #=> 13300.0
  #
  def truncate: () -> Integer
              | (int n) -> BigDecimal

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - zero?()
  # -->
  # Returns True if the value is zero.
  #
  def zero?: () -> bool

  private

  def initialize_copy: (self) -> self
end

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Base value used in internal calculations.  On a 32 bit system, BASE is 10000,
# indicating that calculation is done in groups of 4 digits. (If it were larger,
# BASE**2 wouldn't fit in 32 bits, so you couldn't guarantee that two groups
# could always be multiplied together without overflow.)
#
BigDecimal::BASE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines whether overflow, underflow or zero divide result in an exception
# being thrown. See BigDecimal.mode.
#
BigDecimal::EXCEPTION_ALL: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is infinity.  See
# BigDecimal.mode.
#
BigDecimal::EXCEPTION_INFINITY: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is not a number
# (NaN). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_NaN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is an overflow (a
# result too large to be represented). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_OVERFLOW: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when the result of a computation is an underflow (a
# result too small to be represented). See BigDecimal.mode.
#
BigDecimal::EXCEPTION_UNDERFLOW: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when a division by zero is performed. See
# BigDecimal.mode.
#
BigDecimal::EXCEPTION_ZERODIVIDE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Special value constants
#
BigDecimal::INFINITY: BigDecimal

BigDecimal::NAN: BigDecimal

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards +Infinity. See BigDecimal.mode.
#
BigDecimal::ROUND_CEILING: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that values should be rounded towards zero. See BigDecimal.mode.
#
BigDecimal::ROUND_DOWN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards -Infinity. See BigDecimal.mode.
#
BigDecimal::ROUND_FLOOR: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that digits >= 6 should be rounded up, others rounded down. See
# BigDecimal.mode.
#
BigDecimal::ROUND_HALF_DOWN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Round towards the even neighbor. See BigDecimal.mode.
#
BigDecimal::ROUND_HALF_EVEN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that digits >= 5 should be rounded up, others rounded down. See
# BigDecimal.mode.
#
BigDecimal::ROUND_HALF_UP: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Determines what happens when a result must be rounded in order to fit in the
# appropriate number of significant digits. See BigDecimal.mode.
#
BigDecimal::ROUND_MODE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that values should be rounded away from zero. See BigDecimal.mode.
#
BigDecimal::ROUND_UP: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is negative and finite. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_FINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is negative and infinite. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_INFINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is -0. See BigDecimal.sign.
#
BigDecimal::SIGN_NEGATIVE_ZERO: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is not a number. See BigDecimal.sign.
#
BigDecimal::SIGN_NaN: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is positive and finite. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_FINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is positive and infinite. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_INFINITE: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# Indicates that a value is +0. See BigDecimal.sign.
#
BigDecimal::SIGN_POSITIVE_ZERO: Integer

# <!-- rdoc-file=ext/bigdecimal/bigdecimal.c -->
# The version of bigdecimal library
#
BigDecimal::VERSION: String

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=ext/bigdecimal/bigdecimal.c
  #   - BigDecimal(value, exception: true) -> bigdecimal
  #   - BigDecimal(value, ndigits, exception: true) -> bigdecimal
  # -->
  # Returns the \BigDecimal converted from +value+
  #     with a precision of +ndigits+ decimal digits.
  #
  #     When +ndigits+ is less than the number of significant digits
  #     in the value, the result is rounded to that number of digits,
  #     according to the current rounding mode; see BigDecimal.mode.
  #
  # Returns `value` converted to a BigDecimal, depending on the type of `value`:
  #
  # *   Integer, Float, Rational, Complex, or BigDecimal: converted directly:
  #
  #         # Integer, Complex, or BigDecimal value does not require ndigits; ignored if given.
  #         BigDecimal(2)                     # => 0.2e1
  #         BigDecimal(Complex(2, 0))         # => 0.2e1
  #         BigDecimal(BigDecimal(2))         # => 0.2e1
  #         # Float or Rational value requires ndigits.
  #         BigDecimal(2.0, 0)                # => 0.2e1
  #         BigDecimal(Rational(2, 1), 0)     # => 0.2e1
  #
  # *   String: converted by parsing if it contains an integer or floating-point
  #     literal; leading and trailing whitespace is ignored:
  #
  #         # String does not require ndigits; ignored if given.
  #         BigDecimal('2')     # => 0.2e1
  #         BigDecimal('2.0')   # => 0.2e1
  #         BigDecimal('0.2e1') # => 0.2e1
  #         BigDecimal(' 2.0 ') # => 0.2e1
  #
  # *   Other type that responds to method `:to_str`: first converted to a string,
  #     then converted to a BigDecimal, as above.
  #
  # *   Other type:
  #
  #     *   Raises an exception if keyword argument `exception` is `true`.
  #     *   Returns `nil` if keyword argument `exception` is `true`.
  #
  #
  #
  # Raises an exception if `value` evaluates to a Float and `digits` is larger
  # than Float::DIG + 1.
  #
  def self?.BigDecimal: (real | string | BigDecimal initial, ?int digits, ?exception: bool) -> BigDecimal
end

class ERB
  # <!--
  #   rdoc-file=lib/erb.rb
  #   - version()
  # -->
  # Returns revision information for the erb.rb module.
  #
  def self.version: () -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - new(str, safe_level=NOT_GIVEN, legacy_trim_mode=NOT_GIVEN, legacy_eoutvar=NOT_GIVEN, trim_mode: nil, eoutvar: '_erbout')
  # -->
  # Constructs a new ERB object with the template specified in *str*.
  #
  # An ERB object works by building a chunk of Ruby code that will output the
  # completed template when run.
  #
  # If *trim_mode* is passed a String containing one or more of the following
  # modifiers, ERB will adjust its code generation as listed:
  #
  #     %  enables Ruby code processing for lines beginning with %
  #     <> omit newline for lines starting with <% and ending in %>
  #     >  omit newline for lines ending in %>
  #     -  omit blank lines ending in -%>
  #
  # *eoutvar* can be used to set the name of the variable ERB will build up its
  # output in.  This is useful when you need to run multiple ERB templates through
  # the same binding and/or when you want to control where output ends up.  Pass
  # the name of the variable to be used inside a String.
  #
  # ### Example
  #
  #     require "erb"
  #
  #     # build data class
  #     class Listings
  #       PRODUCT = { :name => "Chicken Fried Steak",
  #                   :desc => "A well messages pattie, breaded and fried.",
  #                   :cost => 9.95 }
  #
  #       attr_reader :product, :price
  #
  #       def initialize( product = "", price = "" )
  #         @product = product
  #         @price = price
  #       end
  #
  #       def build
  #         b = binding
  #         # create and run templates, filling member data variables
  #         ERB.new(<<-'END_PRODUCT'.gsub(/^\s+/, ""), trim_mode: "", eoutvar: "@product").result b
  #           <%= PRODUCT[:name] %>
  #           <%= PRODUCT[:desc] %>
  #         END_PRODUCT
  #         ERB.new(<<-'END_PRICE'.gsub(/^\s+/, ""), trim_mode: "", eoutvar: "@price").result b
  #           <%= PRODUCT[:name] %> -- <%= PRODUCT[:cost] %>
  #           <%= PRODUCT[:desc] %>
  #         END_PRICE
  #       end
  #     end
  #
  #     # setup template data
  #     listings = Listings.new
  #     listings.build
  #
  #     puts listings.product + "\n" + listings.price
  #
  # *Generates*
  #
  #     Chicken Fried Steak
  #     A well messages pattie, breaded and fried.
  #
  #     Chicken Fried Steak -- 9.95
  #     A well messages pattie, breaded and fried.
  #
  def initialize: (String, ?eoutvar: String, ?trim_mode: Integer | String | NilClass) -> untyped

  # <!-- rdoc-file=lib/erb.rb -->
  # The Ruby code generated by ERB
  #
  def src: () -> String

  # <!-- rdoc-file=lib/erb.rb -->
  # The encoding to eval
  #
  def encoding: () -> Encoding

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *filename* argument passed to Kernel#eval when the ERB code is
  # run
  #
  def filename: () -> (String | NilClass)

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *filename* argument passed to Kernel#eval when the ERB code is
  # run
  #
  def filename=: (String | NilClass) -> untyped

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *lineno* argument passed to Kernel#eval when the ERB code is run
  #
  def lineno: () -> Integer

  # <!-- rdoc-file=lib/erb.rb -->
  # The optional *lineno* argument passed to Kernel#eval when the ERB code is run
  #
  def lineno=: (Integer) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - location=((filename, lineno))
  # -->
  # Sets optional filename and line number that will be used in ERB code
  # evaluation and error reporting. See also #filename= and #lineno=
  #
  #     erb = ERB.new('<%= some_x %>')
  #     erb.render
  #     # undefined local variable or method `some_x'
  #     #   from (erb):1
  #
  #     erb.location = ['file.erb', 3]
  #     # All subsequent error reporting would use new location
  #     erb.render
  #     # undefined local variable or method `some_x'
  #     #   from file.erb:4
  #
  def location=: (Array[String | Integer]) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - run(b=new_toplevel)
  # -->
  # Generate results and print them. (see ERB#result)
  #
  def run: (?Binding) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - result(b=new_toplevel)
  # -->
  # Executes the generated ERB code to produce a completed template, returning the
  # results of that code.  (See ERB::new for details on how this process can be
  # affected by *safe_level*.)
  #
  # *b* accepts a Binding object which is used to set the context of code
  # evaluation.
  #
  def result: (?Binding) -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - result_with_hash(hash)
  # -->
  # Render a template on a new toplevel binding with local variables specified by
  # a Hash object.
  #
  def result_with_hash: (Hash[untyped, untyped]) -> String

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_method(mod, methodname, fname='(ERB)')
  # -->
  # Define *methodname* as instance method of *mod* from compiled Ruby source.
  #
  # example:
  #     filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.def_method(MyClass, 'render(arg1, arg2)', filename)
  #     print MyClass.new.render('foo', 123)
  #
  def def_method: (Module, String, ?String) -> untyped

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_module(methodname='erb')
  # -->
  # Create unnamed module, define *methodname* as instance method of it, and
  # return it.
  #
  # example:
  #     filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.filename = filename
  #     MyModule = erb.def_module('render(arg1, arg2)')
  #     class MyClass
  #       include MyModule
  #     end
  #
  def def_module: (?String) -> Module

  # <!--
  #   rdoc-file=lib/erb.rb
  #   - def_class(superklass=Object, methodname='result')
  # -->
  # Define unnamed class which has *methodname* as instance method, and return it.
  #
  # example:
  #     class MyClass_
  #       def initialize(arg1, arg2)
  #         @arg1 = arg1;  @arg2 = arg2
  #       end
  #     end
  #     filename = 'example.rhtml'  # @arg1 and @arg2 are used in example.rhtml
  #     erb = ERB.new(File.read(filename))
  #     erb.filename = filename
  #     MyClass = erb.def_class(MyClass_, 'render()')
  #     print MyClass.new('foo', 123).render()
  #
  def def_class: (?Class, ?String) -> Class
end

# <!-- rdoc-file=lib/optparse.rb -->
# ## OptionParser
#
# ### New to OptionParser?
#
# See the [Tutorial](./doc/optparse/tutorial_rdoc.html).
#
# ### Introduction
#
# OptionParser is a class for command-line option analysis.  It is much more
# advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
# solution.
#
# ### Features
#
# 1.  The argument specification and the code to handle it are written in the
#     same place.
# 2.  It can output an option summary; you don't need to maintain this string
#     separately.
# 3.  Optional and mandatory arguments are specified very gracefully.
# 4.  Arguments can be automatically converted to a specified class.
# 5.  Arguments can be restricted to a certain set.
#
#
# All of these features are demonstrated in the examples below.  See
# #make_switch for full documentation.
#
# ### Minimal example
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.banner = "Usage: example.rb [options]"
#
#       parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
#         options[:verbose] = v
#       end
#     end.parse!
#
#     p options
#     p ARGV
#
# ### Generating Help
#
# OptionParser can be used to automatically generate help for the commands you
# write:
#
#     require 'optparse'
#
#     Options = Struct.new(:name)
#
#     class Parser
#       def self.parse(options)
#         args = Options.new("world")
#
#         opt_parser = OptionParser.new do |parser|
#           parser.banner = "Usage: example.rb [options]"
#
#           parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
#             args.name = n
#           end
#
#           parser.on("-h", "--help", "Prints this help") do
#             puts parser
#             exit
#           end
#         end
#
#         opt_parser.parse!(options)
#         return args
#       end
#     end
#     options = Parser.parse %w[--help]
#
#     #=>
#        # Usage: example.rb [options]
#        #     -n, --name=NAME                  Name to say hello to
#        #     -h, --help                       Prints this help
#
# ### Required Arguments
#
# For options that require an argument, option specification strings may include
# an option name in all caps. If an option is used without the required
# argument, an exception will be raised.
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.on("-r", "--require LIBRARY",
#                 "Require the LIBRARY before executing your script") do |lib|
#         puts "You required #{lib}!"
#       end
#     end.parse!
#
# Used:
#
#     $ ruby optparse-test.rb -r
#     optparse-test.rb:9:in `<main>': missing argument: -r (OptionParser::MissingArgument)
#     $ ruby optparse-test.rb -r my-library
#     You required my-library!
#
# ### Type Coercion
#
# OptionParser supports the ability to coerce command line arguments into
# objects for us.
#
# OptionParser comes with a few ready-to-use kinds of  type coercion. They are:
#
# *   Date  -- Anything accepted by `Date.parse`
# *   DateTime -- Anything accepted by `DateTime.parse`
# *   Time -- Anything accepted by `Time.httpdate` or `Time.parse`
# *   URI  -- Anything accepted by `URI.parse`
# *   Shellwords -- Anything accepted by `Shellwords.shellwords`
# *   String -- Any non-empty string
# *   Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
# *   Float -- Any float. (e.g. 10, 3.14, -100E+13)
# *   Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
# *   DecimalInteger -- Like `Integer`, but no octal format.
# *   OctalInteger -- Like `Integer`, but no decimal format.
# *   DecimalNumeric -- Decimal integer or float.
# *   TrueClass --  Accepts '+, yes, true, -, no, false' and defaults as `true`
# *   FalseClass -- Same as `TrueClass`, but defaults to `false`
# *   Array -- Strings separated by ',' (e.g. 1,2,3)
# *   Regexp -- Regular expressions. Also includes options.
#
#
# We can also add our own coercions, which we will cover below.
#
# #### Using Built-in Conversions
#
# As an example, the built-in `Time` conversion is used. The other built-in
# conversions behave in the same way. OptionParser will attempt to parse the
# argument as a `Time`. If it succeeds, that time will be passed to the handler
# block. Otherwise, an exception will be raised.
#
#     require 'optparse'
#     require 'optparse/time'
#     OptionParser.new do |parser|
#       parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
#         p time
#       end
#     end.parse!
#
# Used:
#
#     $ ruby optparse-test.rb  -t nonsense
#     ... invalid argument: -t nonsense (OptionParser::InvalidArgument)
#     $ ruby optparse-test.rb  -t 10-11-12
#     2010-11-12 00:00:00 -0500
#     $ ruby optparse-test.rb  -t 9:30
#     2014-08-13 09:30:00 -0400
#
# #### Creating Custom Conversions
#
# The `accept` method on OptionParser may be used to create converters. It
# specifies which conversion block to call whenever a class is specified. The
# example below uses it to fetch a `User` object before the `on` handler
# receives it.
#
#     require 'optparse'
#
#     User = Struct.new(:id, :name)
#
#     def find_user id
#       not_found = ->{ raise "No User Found for id #{id}" }
#       [ User.new(1, "Sam"),
#         User.new(2, "Gandalf") ].find(not_found) do |u|
#         u.id == id
#       end
#     end
#
#     op = OptionParser.new
#     op.accept(User) do |user_id|
#       find_user user_id.to_i
#     end
#
#     op.on("--user ID", User) do |user|
#       puts user
#     end
#
#     op.parse!
#
# Used:
#
#     $ ruby optparse-test.rb --user 1
#     #<struct User id=1, name="Sam">
#     $ ruby optparse-test.rb --user 2
#     #<struct User id=2, name="Gandalf">
#     $ ruby optparse-test.rb --user 3
#     optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)
#
# ### Store options to a Hash
#
# The `into` option of `order`, `parse` and so on methods stores command line
# options into a Hash.
#
#     require 'optparse'
#
#     options = {}
#     OptionParser.new do |parser|
#       parser.on('-a')
#       parser.on('-b NUM', Integer)
#       parser.on('-v', '--verbose')
#     end.parse!(into: options)
#
#     p options
#
# Used:
#
#     $ ruby optparse-test.rb -a
#     {:a=>true}
#     $ ruby optparse-test.rb -a -v
#     {:a=>true, :verbose=>true}
#     $ ruby optparse-test.rb -a -b 100
#     {:a=>true, :b=>100}
#
# ### Complete example
#
# The following example is a complete Ruby program.  You can run it and see the
# effect of specifying various options.  This is probably the best way to learn
# the features of `optparse`.
#
#     require 'optparse'
#     require 'optparse/time'
#     require 'ostruct'
#     require 'pp'
#
#     class OptparseExample
#       Version = '1.0.0'
#
#       CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
#       CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }
#
#       class ScriptOptions
#         attr_accessor :library, :inplace, :encoding, :transfer_type,
#                       :verbose, :extension, :delay, :time, :record_separator,
#                       :list
#
#         def initialize
#           self.library = []
#           self.inplace = false
#           self.encoding = "utf8"
#           self.transfer_type = :auto
#           self.verbose = false
#         end
#
#         def define_options(parser)
#           parser.banner = "Usage: example.rb [options]"
#           parser.separator ""
#           parser.separator "Specific options:"
#
#           # add additional options
#           perform_inplace_option(parser)
#           delay_execution_option(parser)
#           execute_at_time_option(parser)
#           specify_record_separator_option(parser)
#           list_example_option(parser)
#           specify_encoding_option(parser)
#           optional_option_argument_with_keyword_completion_option(parser)
#           boolean_verbose_option(parser)
#
#           parser.separator ""
#           parser.separator "Common options:"
#           # No argument, shows at tail.  This will print an options summary.
#           # Try it and see!
#           parser.on_tail("-h", "--help", "Show this message") do
#             puts parser
#             exit
#           end
#           # Another typical switch to print the version.
#           parser.on_tail("--version", "Show version") do
#             puts Version
#             exit
#           end
#         end
#
#         def perform_inplace_option(parser)
#           # Specifies an optional option argument
#           parser.on("-i", "--inplace [EXTENSION]",
#                     "Edit ARGV files in place",
#                     "(make backup if EXTENSION supplied)") do |ext|
#             self.inplace = true
#             self.extension = ext || ''
#             self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
#           end
#         end
#
#         def delay_execution_option(parser)
#           # Cast 'delay' argument to a Float.
#           parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
#             self.delay = n
#           end
#         end
#
#         def execute_at_time_option(parser)
#           # Cast 'time' argument to a Time object.
#           parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
#             self.time = time
#           end
#         end
#
#         def specify_record_separator_option(parser)
#           # Cast to octal integer.
#           parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
#                     "Specify record separator (default \\0)") do |rs|
#             self.record_separator = rs
#           end
#         end
#
#         def list_example_option(parser)
#           # List of arguments.
#           parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
#             self.list = list
#           end
#         end
#
#         def specify_encoding_option(parser)
#           # Keyword completion.  We are specifying a specific set of arguments (CODES
#           # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
#           # the shortest unambiguous text.
#           code_list = (CODE_ALIASES.keys + CODES).join(', ')
#           parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
#                     "(#{code_list})") do |encoding|
#             self.encoding = encoding
#           end
#         end
#
#         def optional_option_argument_with_keyword_completion_option(parser)
#           # Optional '--type' option argument with keyword completion.
#           parser.on("--type [TYPE]", [:text, :binary, :auto],
#                     "Select transfer type (text, binary, auto)") do |t|
#             self.transfer_type = t
#           end
#         end
#
#         def boolean_verbose_option(parser)
#           # Boolean switch.
#           parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
#             self.verbose = v
#           end
#         end
#       end
#
#       #
#       # Return a structure describing the options.
#       #
#       def parse(args)
#         # The options specified on the command line will be collected in
#         # *options*.
#
#         @options = ScriptOptions.new
#         @args = OptionParser.new do |parser|
#           @options.define_options(parser)
#           parser.parse!(args)
#         end
#         @options
#       end
#
#       attr_reader :parser, :options
#     end  # class OptparseExample
#
#     example = OptparseExample.new
#     options = example.parse(ARGV)
#     pp options # example.options
#     pp ARGV
#
# ### Shell Completion
#
# For modern shells (e.g. bash, zsh, etc.), you can use shell completion for
# command line options.
#
# ### Further documentation
#
# The above examples, along with the accompanying
# [Tutorial](./doc/optparse/tutorial_rdoc.html), should be enough to learn how
# to use this class. If you have any questions, file a ticket at
# http://bugs.ruby-lang.org.
#
class OptionParser
  interface _Pattern
    def match: (untyped other) -> boolish
  end

  interface _Intoable
    def []=: (Symbol, untyped) -> untyped
  end

  interface _LtLtString
    def <<: (String) -> untyped
  end

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(*args, &blk)
  # -->
  # See #accept.
  #
  def self.accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args)
  # -->
  # See #getopts.
  #
  def self.getopts: (*String options) -> Hash[String, untyped]
                  | (Array[String] args, *String options) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inc(arg, default = nil)
  # -->
  # Returns an incremented value of `default` according to `arg`.
  #
  def self.inc: (untyped arg, ?_ToI default) -> Integer?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(*args, &blk)
  # -->
  # See #reject.
  #
  def self.reject: (Class t) -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - terminate(arg = nil)
  # -->
  #
  def self.terminate: (?String arg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - top()
  # -->
  #
  def self.top: () -> OptionParser::List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - with(*args, &block)
  # -->
  # Initializes a new instance and evaluates the optional block in context of the
  # instance. Arguments `args` are passed to #new, see there for description of
  # parameters.
  #
  # This method is **deprecated**, its behavior corresponds to the older #new
  # method.
  #
  def self.with: (?String banner, ?Integer width, ?String indent) ?{ (instance opts) -> void } -> instance

  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - abort(mesg = $!)
  # -->
  #
  def abort: (?_ToS mesg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(*args, &blk)
  # -->
  # Directs to accept specified class `t`. The argument string is passed to the
  # block in which it should be converted to the desired class.
  #
  # `t`
  # :   Argument class specifier, any object including Class.
  # `pat`
  # :   Pattern for argument, defaults to `t` if it responds to match.
  #
  #
  #     accept(t, pat, &block)
  #
  def accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  def add_officious: () -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - additional_message(typ, opt)
  # -->
  # Returns additional info.
  #
  def additional_message: (untyped typ, untyped opt) -> String?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Heading banner preceding summary.
  #
  attr_accessor banner: String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - base()
  # -->
  # Subject of #on_tail.
  #
  def base: () -> List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(word)
  # -->
  #
  def candidate: (String word) -> Array[untyped]

  def compsys: (untyped to, ?untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_head_option(*opts, &block)
  # -->
  #
  alias def_head_option define_head

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_option(*opts, &block)
  # -->
  #
  alias def_option define

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - def_tail_option(*opts, &block)
  # -->
  #
  alias def_tail_option define_tail

  # <!-- rdoc-file=lib/optparse.rb -->
  # Strings to be parsed in default.
  #
  attr_accessor default_argv: Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  def define: (*String params) ?{ (*untyped) -> untyped } -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
            | (*String params, Proc | Method handler) -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define_head(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  def define_head: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - define_tail(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  def define_tail: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - environment(env = File.basename($0, '.*'))
  # -->
  # Parses environment variable `env` or its uppercase with splitting like a
  # shell.
  #
  # `env` defaults to the basename of the program.
  #
  def environment: (?String env) -> Array[String]?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args)
  # -->
  # Wrapper method for getopts.rb.
  #
  #     params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
  #     # params["a"] = true   # -a
  #     # params["b"] = "1"    # -b1
  #     # params["foo"] = "1"  # --foo
  #     # params["bar"] = "x"  # --bar x
  #     # params["zot"] = "z"  # --zot Z
  #
  def getopts: (*String options) -> Hash[String, untyped]
             | (Array[String] args, *String options) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - help()
  # -->
  # Returns option summary string.
  #
  def help: () -> String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inc(*args)
  # -->
  #
  def inc: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - load(filename = nil)
  # -->
  # Loads options from file names as `filename`. Does nothing when the file is not
  # present. Returns whether successfully loaded.
  #
  # `filename` defaults to basename of the program without suffix in a directory
  # ~/.options, then the basename with '.options' suffix under XDG and Haiku
  # standard places.
  #
  def load: (?String filename) -> bool

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - make_switch(params, block = nil)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  def make_switch: (Array[untyped] opts, ?Proc block) -> [ untyped, untyped, untyped, untyped, untyped ]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new() { |self| ... }
  # -->
  # Pushes a new List.
  #
  def new: () -> self
         | [T] () { (self) -> T } -> T

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  def on: (*String params) ?{ (*untyped) -> untyped } -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
        | (*String params, Proc | Method handler) -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on_head(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  # The new option is added at the head of the summary.
  #
  def on_head: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - on_tail(*params, &block)
  # -->
  # Creates an option from the given parameters `params`. See [Parameters for New
  # Options](./doc/optparse/option_params_rdoc.html).
  #
  # The block, if given, is the handler for the created option. When the option is
  # encountered during command-line parsing, the block is called with the argument
  # given for the option, if any. See [Option
  # Handlers](./option_params_rdoc.html#label-Option+Handlers).
  #
  # The new option is added at the tail of the summary.
  #
  def on_tail: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order(*argv, into: nil, &nonopt)
  # -->
  # Parses command line arguments `argv` in order. When a block is given, each
  # non-option argument is yielded. When optional `into` keyword argument is
  # provided, the parsed option values are stored there via `[]=` method (so it
  # can be Hash, or OpenStruct, or other similar object).
  #
  # Returns the rest of `argv` left unparsed.
  #
  def order: (*String argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]
           | (Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order!(argv = default_argv, into: nil, &nonopt)
  # -->
  # Same as #order, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def order!: (?Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(*argv, into: nil)
  # -->
  # Parses command line arguments `argv` in order when environment variable
  # POSIXLY_CORRECT is set, and in permutation mode otherwise. When optional
  # `into` keyword argument is provided, the parsed option values are stored there
  # via `[]=` method (so it can be Hash, or OpenStruct, or other similar object).
  #
  def parse: (*String argv, ?into: _Intoable) -> Array[String]
           | (Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse!(argv = default_argv, into: nil)
  # -->
  # Same as #parse, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def parse!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute(*argv, into: nil)
  # -->
  # Parses command line arguments `argv` in permutation mode and returns list of
  # non-option arguments. When optional `into` keyword argument is provided, the
  # parsed option values are stored there via `[]=` method (so it can be Hash, or
  # OpenStruct, or other similar object).
  #
  def permute: (*String argv, ?into: _Intoable) -> Array[String]
             | (Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute!(argv = default_argv, into: nil)
  # -->
  # Same as #permute, but removes switches destructively. Non-option arguments
  # remain in `argv`.
  #
  def permute!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  # <!-- rdoc-file=lib/optparse.rb -->
  # Program name to be emitted in error message and default banner, defaults to
  # $0.
  #
  attr_accessor program_name: String

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(*args, &blk)
  # -->
  # Directs to reject specified class argument.
  #
  # `t`
  # :   Argument class specifier, any object including Class.
  #
  #
  #     reject(t)
  #
  def reject: (Class t) -> void

  # <!-- rdoc-file=lib/optparse.rb -->
  # Release code
  #
  def release: () -> untyped

  def release=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - remove()
  # -->
  # Removes the last List.
  #
  def remove: () -> List?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Whether to require that options match exactly (disallows providing abbreviated
  # long option as short option).
  #
  attr_accessor require_exact: boolish

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - separator(string)
  # -->
  # Add separator in summary.
  #
  def separator: (String string) -> void

  # Heading banner preceding summary.
  #
  alias set_banner banner=

  # Program name to be emitted in error message and default banner, defaults to
  # $0.
  #
  alias set_program_name program_name=

  # <!-- rdoc-file=lib/optparse.rb -->
  # Indentation for summary. Must be String (or have + String method).
  #
  alias set_summary_indent summary_indent=

  # <!-- rdoc-file=lib/optparse.rb -->
  # Width for option list portion of summary. Must be Numeric.
  #
  alias set_summary_width summary_width=

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)
  # -->
  # Puts option summary into `to` and returns `to`. Yields each line if a block is
  # given.
  #
  # `to`
  # :   Output destination, which must have method <<. Defaults to [].
  # `width`
  # :   Width of left side, defaults to @summary_width.
  # `max`
  # :   Maximum length allowed for left side, defaults to `width` - 1.
  # `indent`
  # :   Indentation, defaults to @summary_indent.
  #
  def summarize: (?_LtLtString to, ?Integer width, ?Integer max, ?String indent) ?{ (String line) -> void } -> _LtLtString

  # <!-- rdoc-file=lib/optparse.rb -->
  # Indentation for summary. Must be String (or have + String method).
  #
  attr_accessor summary_indent: String

  # <!-- rdoc-file=lib/optparse.rb -->
  # Width for option list portion of summary. Must be Numeric.
  #
  attr_accessor summary_width: Integer

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - terminate(arg = nil)
  # -->
  # Terminates option parsing. Optional parameter `arg` is a string pushed back to
  # be the first non-option argument.
  #
  def terminate: (?String arg) -> bot

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_a()
  # -->
  # Returns option summary list.
  #
  def to_a: () -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_s()
  # -->
  #
  alias to_s help

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - top()
  # -->
  # Subject of #on / #on_head, #accept / #reject
  #
  def top: () -> List

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - ver()
  # -->
  # Returns version string from program_name, version and release.
  #
  def ver: () -> String?

  # <!-- rdoc-file=lib/optparse.rb -->
  # Version
  #
  attr_accessor version: String?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - warn(mesg = $!)
  # -->
  #
  def warn: (?_ToS mesg) -> void

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(typ, opt, icase = false, *pat)
  # -->
  # Completes shortened long style option switch and returns pair of canonical
  # switch and switch descriptor OptionParser::Switch.
  #
  # `typ`
  # :   Searching table.
  # `opt`
  # :   Searching key.
  # `icase`
  # :   Search case insensitive if true.
  # `pat`
  # :   Optional pattern for completion.
  #
  def complete: (untyped typ, untyped opt, ?untyped icase, *untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(banner = nil, width = 32, indent = ' ' * 4) { |self| ... }
  # -->
  # Initializes the instance and yields itself if called with a block.
  #
  # `banner`
  # :   Banner message.
  # `width`
  # :   Summary width.
  # `indent`
  # :   Summary indent.
  #
  def initialize: (?String banner, ?Integer width, ?String indent) ?{ (OptionParser) -> void } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - notwice(obj, prv, msg)
  # -->
  # Checks if an argument is given twice, in which case an ArgumentError is
  # raised. Called from OptionParser#switch only.
  #
  # `obj`
  # :   New argument.
  # `prv`
  # :   Previously specified argument.
  # `msg`
  # :   Exception message.
  #
  def notwice: (untyped obj, untyped prv, untyped msg) -> untyped

  def parse_in_order: (?untyped argv, ?untyped setter) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - search(id, key) { |k| ... }
  # -->
  # Searches `key` in @stack for `id` hash and returns or yields the result.
  #
  def search: (untyped id, untyped key) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - visit(id, *args, &block)
  # -->
  # Traverses @stack, sending each element method `id` with `args` and `block`.
  #
  def visit: (untyped id, *untyped args) { (*untyped) -> untyped } -> untyped
end

OptionParser::ArgumentStyle: Hash[untyped, untyped]

OptionParser::COMPSYS_HEADER: String

# <!-- rdoc-file=lib/optparse.rb -->
# Decimal integer format, to be converted to Integer.
#
OptionParser::DecimalInteger: Regexp

# <!-- rdoc-file=lib/optparse.rb -->
# Decimal integer/float number format, to be converted to Integer for integer
# format, Float for float format.
#
OptionParser::DecimalNumeric: Regexp

OptionParser::DefaultList: OptionParser::List

OptionParser::NO_ARGUMENT: Symbol

OptionParser::NoArgument: [ :NONE, nil ]

OptionParser::OPTIONAL_ARGUMENT: Symbol

# <!-- rdoc-file=lib/optparse.rb -->
# Ruby/C like octal/hexadecimal/binary integer format, to be converted to
# Integer.
#
OptionParser::OctalInteger: Regexp

OptionParser::Officious: Hash[untyped, untyped]

OptionParser::OptionalArgument: Array[untyped]

OptionParser::REQUIRED_ARGUMENT: Symbol

OptionParser::RequiredArgument: Array[untyped]

OptionParser::SPLAT_PROC: Proc

OptionParser::Version: String

# <!-- rdoc-file=lib/optparse.rb -->
# Acceptable argument classes. Now contains DecimalInteger, OctalInteger and
# DecimalNumeric. See Acceptable argument classes (in source code).
#
module OptionParser::Acceptables
end

OptionParser::Acceptables::DecimalInteger: Regexp

OptionParser::Acceptables::DecimalNumeric: Regexp

OptionParser::Acceptables::OctalInteger: Regexp

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when the given argument word can't be completed uniquely.
#
class OptionParser::AmbiguousArgument < OptionParser::InvalidArgument
end

OptionParser::AmbiguousArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when ambiguously completable string is encountered.
#
class OptionParser::AmbiguousOption < OptionParser::ParseError
end

OptionParser::AmbiguousOption::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Extends command line arguments array (ARGV) to parse itself.
#
module OptionParser::Arguable
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - extend_object(obj)
  # -->
  # Initializes instance variable.
  #
  def self.extend_object: (untyped obj) -> untyped

  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - getopts(*args)
  # -->
  # Substitution of getopts is possible as follows. Also see OptionParser#getopts.
  #
  #     def getopts(*args)
  #       ($OPT = ARGV.getopts(*args)).each do |opt, val|
  #         eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"
  #       end
  #     rescue OptionParser::ParseError
  #     end
  #
  def getopts: (*String args) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - options() { |optparse| ... }
  # -->
  # Actual OptionParser object, automatically created if nonexistent.
  #
  # If called with a block, yields the OptionParser object and returns the result
  # of the block. If an OptionParser::ParseError exception occurs in the block, it
  # is rescued, a error message printed to STDERR and `nil` returned.
  #
  def options: () -> OptionParser
             | [T] () { (OptionParser) -> T } -> T?

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - options=(opt)
  # -->
  # Sets OptionParser object, when `opt` is `false` or `nil`, methods
  # OptionParser::Arguable#options and OptionParser::Arguable#options= are
  # undefined. Thus, there is no ways to access the OptionParser object via the
  # receiver object.
  #
  def options=: (OptionParser? opt) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - order!(&blk)
  # -->
  # Parses `self` destructively in order and returns `self` containing the rest
  # arguments left unparsed.
  #
  def order!: () ?{ (String) -> void } -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse!()
  # -->
  # Parses `self` destructively and returns `self` containing the rest arguments
  # left unparsed.
  #
  def parse!: () -> Array[String]

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - permute!()
  # -->
  # Parses `self` destructively in permutation mode and returns `self` containing
  # the rest arguments left unparsed.
  #
  def permute!: () -> Array[String]
end

# <!-- rdoc-file=lib/optparse.rb -->
# Hash with completion search feature. See OptionParser::Completion.
#
class OptionParser::CompletingHash < Hash[untyped, untyped]
  include OptionParser::Completion

  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - match(key)
  # -->
  # Completion for hash key.
  #
  def match: (untyped key) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Keyword completion module.  This allows partial arguments to be specified and
# resolved against a list of acceptable values.
#
module OptionParser::Completion
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(key, icase = false, pat = nil, &block)
  # -->
  #
  def self.candidate: (untyped key, ?untyped icase, ?untyped pat) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - regexp(key, icase)
  # -->
  #
  def self.regexp: (untyped key, untyped icase) -> untyped

  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - candidate(key, icase = false, pat = nil)
  # -->
  #
  def candidate: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(key, icase = false, pat = nil) { |key, *sw| ... }
  # -->
  #
  def complete: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - convert(opt = nil, val = nil, *)
  # -->
  #
  def convert: (?untyped opt, ?untyped val, *untyped) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when the given argument does not match required format.
#
class OptionParser::InvalidArgument < OptionParser::ParseError
end

OptionParser::InvalidArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when switch is undefined.
#
class OptionParser::InvalidOption < OptionParser::ParseError
end

OptionParser::InvalidOption::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Simple option list providing mapping from short and/or long option string to
# OptionParser::Switch and mapping from acceptable argument to matching pattern
# and converter pair. Also provides summary feature.
#
class OptionParser::List
  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - accept(t, pat = /.*/m, &block)
  # -->
  # See OptionParser.accept.
  #
  def accept: (untyped t, ?untyped pat) { (*untyped) -> untyped } -> untyped

  def add_banner: (untyped to) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - append(*args)
  # -->
  # Appends `switch` at the tail of the list, and associates short, long and
  # negated long options. Arguments are:
  #
  # `switch`
  # :   OptionParser::Switch instance to be inserted.
  # `short_opts`
  # :   List of short style options.
  # `long_opts`
  # :   List of long style options.
  # `nolong_opts`
  # :   List of long style options with "no-" prefix.
  #
  #
  #     append(switch, short_opts, long_opts, nolong_opts)
  #
  def append: (*untyped args) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from acceptable argument types to pattern and converter pairs.
  #
  def atype: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - complete(id, opt, icase = false, *pat, &block)
  # -->
  # Searches list `id` for `opt` and the optional patterns for completion `pat`.
  # If `icase` is true, the search is case insensitive. The result is returned or
  # yielded if a block is given. If it isn't found, nil is returned.
  #
  def complete: (untyped id, untyped opt, ?untyped icase, *untyped pat) { (*untyped) -> untyped } -> untyped

  def compsys: (*untyped args) { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - each_option(&block)
  # -->
  # Iterates over each option, passing the option to the `block`.
  #
  def each_option: () { (*untyped) -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - get_candidates(id) { |__send__(id).keys| ... }
  # -->
  #
  def get_candidates: (untyped id) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # List of all switches and summary string.
  #
  def list: () -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from long style option switches to actual switch objects.
  #
  def long: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - prepend(*args)
  # -->
  # Inserts `switch` at the head of the list, and associates short, long and
  # negated long options. Arguments are:
  #
  # `switch`
  # :   OptionParser::Switch instance to be inserted.
  # `short_opts`
  # :   List of short style options.
  # `long_opts`
  # :   List of long style options.
  # `nolong_opts`
  # :   List of long style options with "no-" prefix.
  #
  #
  #     prepend(switch, short_opts, long_opts, nolong_opts)
  #
  def prepend: (*untyped args) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - reject(t)
  # -->
  # See OptionParser.reject.
  #
  def reject: (untyped t) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - search(id, key) { |val| ... }
  # -->
  # Searches `key` in `id` list. The result is returned or yielded if a block is
  # given. If it isn't found, nil is returned.
  #
  def search: (untyped id, untyped key) -> untyped

  # <!-- rdoc-file=lib/optparse.rb -->
  # Map from short style option switches to actual switch objects.
  #
  def short: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(*args, &block)
  # -->
  # Creates the summary table, passing each line to the `block` (without newline).
  # The arguments `args` are passed along to the summarize method which is called
  # on every option.
  #
  def summarize: (*untyped args) { (*untyped) -> untyped } -> untyped

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new()
  # -->
  # Just initializes all instance variables.
  #
  def initialize: () -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - update(sw, sopts, lopts, nsw = nil, nlopts = nil)
  # -->
  # Adds `sw` according to `sopts`, `lopts` and `nlopts`.
  #
  # `sw`
  # :   OptionParser::Switch instance to be added.
  # `sopts`
  # :   Short style option list.
  # `lopts`
  # :   Long style option list.
  # `nlopts`
  # :   Negated long style options list.
  #
  def update: (untyped sw, untyped sopts, untyped lopts, ?untyped nsw, ?untyped nlopts) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when a switch with mandatory argument has no argument.
#
class OptionParser::MissingArgument < OptionParser::ParseError
end

OptionParser::MissingArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Raises when there is an argument for a switch which takes no argument.
#
class OptionParser::NeedlessArgument < OptionParser::ParseError
end

OptionParser::NeedlessArgument::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Map from option/keyword string to object with completion.
#
class OptionParser::OptionMap < Hash[untyped, untyped]
  include OptionParser::Completion
end

# <!-- rdoc-file=lib/optparse.rb -->
# Base class of exceptions from OptionParser.
#
class OptionParser::ParseError < RuntimeError
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - filter_backtrace(array)
  # -->
  #
  def self.filter_backtrace: (untyped array) -> untyped

  public

  def additional: () -> untyped

  def additional=: (untyped) -> untyped

  def args: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - inspect()
  # -->
  #
  def inspect: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - message()
  # -->
  # Default stringizing method to emit standard error message.
  #
  def message: () -> String

  # <!-- rdoc-file=lib/optparse.rb -->
  #
  def reason: () -> untyped

  def reason=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - recover(argv)
  # -->
  # Pushes back erred argument(s) to `argv`.
  #
  def recover: (untyped argv) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - set_backtrace(array)
  # -->
  #
  def set_backtrace: (untyped array) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - set_option(opt, eq)
  # -->
  #
  def set_option: (untyped opt, untyped eq) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - to_s()
  # -->
  #
  alias to_s message

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(*args, additional: nil)
  # -->
  #
  def initialize: (*untyped args, ?additional: untyped) -> void
end

# <!-- rdoc-file=lib/optparse.rb -->
# Reason which caused the error.
#
OptionParser::ParseError::Reason: String

# <!-- rdoc-file=lib/optparse.rb -->
# Individual switch class.  Not important to the user.
#
# Defined within Switch are several Switch-derived classes: NoArgument,
# RequiredArgument, etc.
#
class OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - guess(arg)
  # -->
  # Guesses argument style from `arg`.  Returns corresponding OptionParser::Switch
  # class (OptionalArgument, etc.).
  #
  def self.guess: (untyped arg) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - incompatible_argument_styles(arg, t)
  # -->
  #
  def self.incompatible_argument_styles: (untyped arg, untyped t) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - pattern()
  # -->
  #
  def self.pattern: () -> untyped

  public

  def add_banner: (untyped to) -> untyped

  def arg: () -> untyped

  def block: () -> untyped

  def compsys: (untyped sdone, untyped ldone) -> untyped

  def conv: () -> untyped

  def desc: () -> untyped

  def long: () -> untyped

  def match_nonswitch?: (untyped str) -> untyped

  def pattern: () -> untyped

  def short: () -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - summarize(sdone = {}, ldone = {}, width = 1, max = width - 1, indent = "") { |indent| ... }
  # -->
  # Produces the summary text. Each line of the summary is yielded to the block
  # (without newline).
  #
  # `sdone`
  # :   Already summarized short style options keyed hash.
  # `ldone`
  # :   Already summarized long style options keyed hash.
  # `width`
  # :   Width of left side (option part). In other words, the right side
  #     (description part) starts after `width` columns.
  # `max`
  # :   Maximum width of left side -> the options are filled within `max` columns.
  # `indent`
  # :   Prefix string indents all summarized lines.
  #
  def summarize: (?untyped sdone, ?untyped ldone, ?untyped width, ?untyped max, ?untyped indent) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - switch_name()
  # -->
  # Main name of the switch.
  #
  def switch_name: () -> untyped

  private

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - conv_arg(arg, val = [])
  # -->
  # Parses argument, converts and returns `arg`, `block` and result of conversion.
  # Yields at semi-error condition instead of raising an exception.
  #
  def conv_arg: (untyped arg, ?untyped val) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - new(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long), block = nil, &_block)
  # -->
  #
  def initialize: (?untyped pattern, ?untyped conv, ?untyped short, ?untyped long, ?untyped arg, ?untyped desc, ?untyped block) { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse_arg(arg) { |InvalidArgument, arg| ... }
  # -->
  # Parses `arg` and returns rest of `arg` and matched portion to the argument
  # pattern. Yields when the pattern doesn't match substring.
  #
  def parse_arg: (untyped arg) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes no arguments.
#
class OptionParser::Switch::NoArgument < OptionParser::Switch
  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - incompatible_argument_styles(*)
  # -->
  #
  def self.incompatible_argument_styles: (*untyped) -> untyped

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - pattern()
  # -->
  #
  def self.pattern: () -> untyped

  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv) { |NeedlessArgument, arg| ... }
  # -->
  # Raises an exception if any arguments given.
  #
  def parse: (untyped arg, untyped argv) -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that can omit argument.
#
class OptionParser::Switch::OptionalArgument < OptionParser::Switch
  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv, &error)
  # -->
  # Parses argument if given, or uses default value.
  #
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes an argument, which does not begin with '-'.
#
class OptionParser::Switch::PlacedArgument < OptionParser::Switch
  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv, &error)
  # -->
  # Returns nil if argument is not present or begins with '-'.
  #
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

# <!-- rdoc-file=lib/optparse.rb -->
# Switch that takes an argument.
#
class OptionParser::Switch::RequiredArgument < OptionParser::Switch
  public

  # <!--
  #   rdoc-file=lib/optparse.rb
  #   - parse(arg, argv)
  # -->
  # Raises an exception if argument is not present.
  #
  def parse: (untyped arg, untyped argv) -> untyped
end

# <!-- rdoc-file=lib/rubygems/user_interaction.rb -->
# Gem::StreamUI implements a simple stream based user interface.
#
class Gem::StreamUI
end

# <!-- rdoc-file=lib/rubygems/installer.rb -->
# The installer installs the files contained in the .gem into the Gem.home.
#
# Gem::Installer does the work of putting files in all the right places on the
# filesystem including unpacking the gem into its gem dir, installing the
# gemspec in the specifications dir, storing the cached gem in the cache dir,
# and installing either wrappers or symlinks for executables.
#
# The installer invokes pre and post install hooks.  Hooks can be added either
# through a rubygems_plugin.rb file in an installed gem or via a
# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
# file.  See Gem.pre_install and Gem.post_install for details.
#
class Gem::Installer
end

%a{annotate:rdoc:skip}
module Gem
  class Version
    include Comparable

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - correct?(version)
    # -->
    # True if the `version` string matches RubyGems' requirements.
    #
    def self.correct?: (_ToS version) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - create(input)
    # -->
    # Factory method to create a Version object. Input may be a Version or a String.
    # Intended to simplify client code.
    #
    #     ver1 = Version.create('1.3.17')   # -> (Version object)
    #     ver2 = Version.create(ver1)       # -> (ver1)
    #     ver3 = Version.create(nil)        # -> nil
    #
    def self.create: (_ToS | Version input) -> instance
                   | (nil input) -> nil

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - new(version)
    # -->
    # Constructs a Version from the `version` string.  A version string is a series
    # of digits or ASCII letters separated by dots.
    #
    def initialize: (_ToS version) -> void

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - <=>(other)
    # -->
    # Compares this version with `other` returning -1, 0, or 1 if the other version
    # is larger, the same, or smaller than this one. Attempts to compare to
    # something that's not a `Gem::Version` return `nil`.
    #
    def <=>: (untyped other) -> Integer?

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - approximate_recommendation()
    # -->
    # A recommended version for use with a ~> Requirement.
    #
    def approximate_recommendation: () -> String

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - bump()
    # -->
    # Return a new version object where the next to the last revision number is one
    # greater (e.g., 5.3.1 => 5.4).
    #
    # Pre-release (alpha) parts, e.g, 5.3.1.b.2 => 5.4, are ignored.
    #
    def bump: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - canonical_segments()
    # -->
    #
    def canonical_segments: () -> Array[Integer | String]

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - eql?(other)
    # -->
    # A Version is only eql? to another version if it's specified to the same
    # precision. Version "1.0" is not the same as version "1".
    #
    def eql?: (untyped other) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - marshal_dump()
    # -->
    # Dump only the raw version string, not the complete object. It's a string for
    # backwards (RubyGems 1.3.5 and earlier) compatibility.
    #
    def marshal_dump: () -> Array[String]

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - marshal_load(array)
    # -->
    # Load custom marshal format. It's a string for backwards (RubyGems 1.3.5 and
    # earlier) compatibility.
    #
    def marshal_load: (Array[String] array) -> void

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - prerelease?()
    # -->
    # A version is considered a prerelease if it contains a letter.
    #
    def prerelease?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - release()
    # -->
    # The release for this version (e.g. 1.2.0.a -> 1.2.0). Non-prerelease versions
    # return themselves.
    #
    def release: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - version()
    # -->
    # A string representation of this Version.
    #
    def version: () -> String

    # <!--
    #   rdoc-file=lib/rubygems/version.rb
    #   - to_s()
    # -->
    #
    alias to_s version
  end
end

# <!-- rdoc-file=lib/rubygems.rb -->
# RubyGems is the Ruby standard for publishing and managing third party
# libraries.
#
# For user documentation, see:
#
# *   `gem help` and `gem help [command]`
# *   [RubyGems User Guide](https://guides.rubygems.org/)
# *   [Frequently Asked Questions](https://guides.rubygems.org/faqs)
#
#
# For gem developer documentation see:
#
# *   [Creating Gems](https://guides.rubygems.org/make-your-own-gem)
# *   Gem::Specification
# *   Gem::Version for version dependency notes
#
#
# Further RubyGems documentation can be found at:
#
# *   [RubyGems Guides](https://guides.rubygems.org)
# *   [RubyGems API](https://www.rubydoc.info/github/rubygems/rubygems) (also
#     available from `gem server`)
#
#
# ## RubyGems Plugins
#
# RubyGems will load plugins in the latest version of each installed gem or
# $LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
# placed at the root of your gem's #require_path.  Plugins are installed at a
# special location and loaded on boot.
#
# For an example plugin, see the [Graph gem](https://github.com/seattlerb/graph)
# which adds a `gem graph` command.
#
# ## RubyGems Defaults, Packaging
#
# RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
# RubyGems or implementing Ruby you can change RubyGems' defaults.
#
# For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
# override any defaults from lib/rubygems/defaults.rb.
#
# If you need RubyGems to perform extra work on install or uninstall, your
# defaults override file can set pre/post install and uninstall hooks. See
# Gem::pre_install, Gem::pre_uninstall, Gem::post_install, Gem::post_uninstall.
#
# ## Bugs
#
# You can submit bugs to the [RubyGems bug
# tracker](https://github.com/rubygems/rubygems/issues) on GitHub
#
# ## Credits
#
# RubyGems is currently maintained by Eric Hodel.
#
# RubyGems was originally developed at RubyConf 2003 by:
#
# *   Rich Kilmer  -- rich(at)infoether.com
# *   Chad Fowler  -- chad(at)chadfowler.com
# *   David Black  -- dblack(at)wobblini.net
# *   Paul Brannan -- paul(at)atdesk.com
# *   Jim Weirich   -- jim(at)weirichhouse.org
#
#
# Contributors:
#
# *   Gavin Sinclair     -- gsinclair(at)soyabean.com.au
# *   George Marrows     -- george.marrows(at)ntlworld.com
# *   Dick Davies        -- rasputnik(at)hellooperator.net
# *   Mauricio Fernandez -- batsman.geo(at)yahoo.com
# *   Simon Strandgaard  -- neoneye(at)adslhome.dk
# *   Dave Glasser       -- glasser(at)mit.edu
# *   Paul Duncan        -- pabs(at)pablotron.org
# *   Ville Aine         -- vaine(at)cs.helsinki.fi
# *   Eric Hodel         -- drbrain(at)segment7.net
# *   Daniel Berger      -- djberg96(at)gmail.com
# *   Phil Hagelberg     -- technomancy(at)gmail.com
# *   Ryan Davis         -- ryand-ruby(at)zenspider.com
# *   Evan Phoenix       -- evan(at)fallingsnow.net
# *   Steve Klabnik      -- steve(at)steveklabnik.com
#
#
# (If your name is missing, PLEASE let us know!)
#
# ## License
#
# See [LICENSE.txt](rdoc-ref:lib/rubygems/LICENSE.txt) for permissions.
#
# Thanks!
#
# -The RubyGems Team
#
module Gem
  interface _HashLike[K, V]
    def each_pair: () { ([ K, V ]) -> untyped } -> self
  end

  DEFAULT_HOST: String

  GEM_DEP_FILES: Array[String]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # When https://bugs.ruby-lang.org/issues/17259 is available, there is no need to
  # override Kernel#warn
  #
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES: bool

  LOADED_SPECS_MUTEX: Thread::Mutex

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Location of Marshal quick gemspecs on remote repositories
  #
  MARSHAL_SPEC_DIR: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Exception classes used in a Gem.read_binary `rescue` statement
  #
  READ_BINARY_ERRORS: Array[Class]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Subdirectories in a gem repository for default gems
  #
  REPOSITORY_DEFAULT_GEM_SUBDIRECTORIES: Array[String]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Subdirectories in a gem repository
  #
  REPOSITORY_SUBDIRECTORIES: Array[String]

  RUBYGEMS_DIR: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Taint support is deprecated in Ruby 2.7. This allows switching ".untaint" to
  # ".tap(&Gem::UNTAINT)", to avoid deprecation warnings in Ruby 2.7.
  #
  UNTAINT: Proc

  VERSION: String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # An Array of Regexps that match windows Ruby platforms.
  #
  WIN_PATTERNS: Array[Regexp]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Exception classes used in Gem.write_binary `rescue` statement
  #
  WRITE_BINARY_ERRORS: Array[Class]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - activated_gem_paths()
  # -->
  # The number of paths in the `$LOAD_PATH` from activated gems. Used to
  # prioritize `-I` and `[ENV]('RUBYLIB`)` entries during `require`.
  #
  def self.activated_gem_paths: () -> Integer

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - add_to_load_path(*paths)
  # -->
  # Add a list of paths to the $LOAD_PATH at the proper place.
  #
  def self.add_to_load_path: (*String paths) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - bin_path(name, exec_name = nil, *requirements)
  # -->
  # Find the full path to the executable for gem `name`.  If the `exec_name` is
  # not given, an exception will be raised, otherwise the specified executable's
  # path is returned.  `requirements` allows you to specify specific gem versions.
  #
  def self.bin_path: (String name, String exec_name, ?Array[Requirement] requirements) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - binary_mode()
  # -->
  # The mode needed to read a file as straight binary.
  #
  def self.binary_mode: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - bindir(install_dir=Gem.dir)
  # -->
  # The path where gem executables are to be installed.
  #
  def self.bindir: (?String install_dir) -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - cache_home()
  # -->
  # The path to standard location of the user's cache directory.
  #
  def self.cache_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - clear_default_specs()
  # -->
  # Clear default gem related variables. It is for test
  #
  def self.clear_default_specs: () -> void

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - clear_paths()
  # -->
  # Reset the `dir` and `path` values.  The next time `dir` or `path` is
  # requested, the values will be calculated from scratch.  This is mainly used by
  # the unit tests to provide test isolation.
  #
  def self.clear_paths: () -> void

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - config_file()
  # -->
  # The path to standard location of the user's .gemrc file.
  #
  def self.config_file: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - config_home()
  # -->
  # The path to standard location of the user's configuration directory.
  #
  def self.config_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - configuration()
  # -->
  # The standard configuration object for gems.
  #
  def self.configuration: () -> ConfigFile

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - configuration=(config)
  # -->
  # Use the given configuration object (which implements the ConfigFile protocol)
  # as the standard configuration object.
  #
  def self.configuration=: (ConfigFile config) -> ConfigFile

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - data_home()
  # -->
  # The path to standard location of the user's data directory.
  #
  def self.data_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - datadir(gem_name)
  # -->
  # The path to the data directory specified by the gem name.  If the package is
  # not available as a gem, return nil.
  #
  def self.datadir: (String gem_name) -> String?

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_bindir()
  # -->
  # The default directory for binaries
  #
  def self.default_bindir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_cert_path()
  # -->
  # The default signing certificate chain path
  #
  def self.default_cert_path: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_dir()
  # -->
  # Default home directory path to be used if an alternate value is not specified
  # in the environment
  #
  def self.default_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_exec_format()
  # -->
  # Deduce Ruby's --program-prefix and --program-suffix from its install name
  #
  def self.default_exec_format: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_ext_dir_for(base_dir)
  # -->
  # Returns binary extensions dir for specified RubyGems base dir or nil if such
  # directory cannot be determined.
  #
  # By default, the binary extensions are located side by side with their Ruby
  # counterparts, therefore nil is returned
  #
  def self.default_ext_dir_for: (String base_dir) -> String?

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_key_path()
  # -->
  # The default signing key path
  #
  def self.default_key_path: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_path()
  # -->
  # Default gem load path
  #
  def self.default_path: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_rubygems_dirs()
  # -->
  # Paths where RubyGems' .rb files and bin files are installed
  #
  def self.default_rubygems_dirs: () -> Array[String]?

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_sources()
  # -->
  # An Array of the default sources that come with RubyGems
  #
  def self.default_sources: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_spec_cache_dir()
  # -->
  # Default spec directory path to be used if an alternate value is not specified
  # in the environment
  #
  def self.default_spec_cache_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - default_specifications_dir()
  # -->
  # Path to specification files of default gems.
  #
  def self.default_specifications_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - deflate(data)
  # -->
  # A Zlib::Deflate.deflate wrapper
  #
  def self.deflate: (String data) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - dir()
  # -->
  # The path where gems are to be installed.
  #
  def self.dir: () -> String

  # <!-- rdoc-file=lib/rubygems.rb -->
  # RubyGems distributors (like operating system package managers) can disable
  # RubyGems update by setting this to error message printed to end-users on gem
  # update --system instead of actual update.
  #
  def self.disable_system_update_message: () -> String?

  # <!-- rdoc-file=lib/rubygems.rb -->
  # RubyGems distributors (like operating system package managers) can disable
  # RubyGems update by setting this to error message printed to end-users on gem
  # update --system instead of actual update.
  #
  def self.disable_system_update_message=: (String?) -> String?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - done_installing(&hook)
  # -->
  # Adds a post-installs hook that will be passed a Gem::DependencyInstaller and a
  # list of installed specifications when Gem::DependencyInstaller#install is
  # complete
  #
  def self.done_installing: () { (DependencyInstaller, Array[Specification]) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::DependencyInstaller installs a set of
  # gems
  #
  def self.done_installing_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ensure_default_gem_subdirectories(dir = Gem.dir, mode = nil)
  # -->
  # Quietly ensure the Gem directory `dir` contains all the proper subdirectories
  # for handling default gems.  If we can't create a directory due to a permission
  # problem, then we will silently continue.
  #
  # If `mode` is given, missing directories are created with this mode.
  #
  # World-writable directories will never be created.
  #
  def self.ensure_default_gem_subdirectories: (?String dir, ?Integer | String mode) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ensure_gem_subdirectories(dir = Gem.dir, mode = nil)
  # -->
  # Quietly ensure the Gem directory `dir` contains all the proper subdirectories.
  #  If we can't create a directory due to a permission problem, then we will
  # silently continue.
  #
  # If `mode` is given, missing directories are created with this mode.
  #
  # World-writable directories will never be created.
  #
  def self.ensure_gem_subdirectories: (?String dir, ?Integer | String mode) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - env_requirement(gem_name)
  # -->
  #
  def self.env_requirement: (String gem_name) -> Requirement

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - find_config_file()
  # -->
  # Finds the user's config file
  #
  def self.find_config_file: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_files(glob, check_load_path=true)
  # -->
  # Returns a list of paths matching `glob` that can be used by a gem to pick up
  # features from other gems.  For example:
  #
  #     Gem.find_files('rdoc/discover').each do |path| load path end
  #
  # if `check_load_path` is true (the default), then find_files also searches
  # $LOAD_PATH for files as well as gems.
  #
  # Note that find_files will return all files even if they are from different
  # versions of the same gem.  See also find_latest_files
  #
  def self.find_files: (String glob, ?boolish check_load_path) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_latest_files(glob, check_load_path=true)
  # -->
  # Returns a list of paths matching `glob` from the latest gems that can be used
  # by a gem to pick up features from other gems.  For example:
  #
  #     Gem.find_latest_files('rdoc/discover').each do |path| load path end
  #
  # if `check_load_path` is true (the default), then find_latest_files also
  # searches $LOAD_PATH for files as well as gems.
  #
  # Unlike find_files, find_latest_files will return only files from the latest
  # version of a gem.
  #
  def self.find_latest_files: (String glob, ?boolish check_load_path) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - find_unresolved_default_spec(path)
  # -->
  # Find a Gem::Specification of default gem from `path`
  #
  def self.find_unresolved_default_spec: (String path) -> Specification?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - finish_resolve(request_set=Gem::RequestSet.new)
  # -->
  #
  def self.finish_resolve: (?RequestSet request_set) -> void

  # <!-- rdoc-file=lib/rubygems.rb -->
  # GemDependencyAPI object, which is set when .use_gemdeps is called. This
  # contains all the information from the Gemfile.
  #
  def self.gemdeps: () -> RequestSet::GemDependencyAPI?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - host()
  # -->
  # Get the default RubyGems API host. This is normally `https://rubygems.org`.
  #
  def self.host: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - host=(host)
  # -->
  # Set the default RubyGems API host.
  #
  def self.host=: (String host) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - install(name, version = Gem::Requirement.default, *options)
  # -->
  # Top level install helper method. Allows you to install gems interactively:
  #
  #     % irb
  #     >> Gem.install "minitest"
  #     Fetching: minitest-5.14.0.gem (100%)
  #     => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]
  #
  def self.install: (String name, ?Gem::Requirement version, *DependencyInstaller::options options) -> Array[Specification]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - java_platform?()
  # -->
  # Is this a java platform?
  #
  def self.java_platform?: () -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_rubygems_version()
  # -->
  # Returns the latest release version of RubyGems.
  #
  def self.latest_rubygems_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_spec_for(name)
  # -->
  # Returns the latest release-version specification for the gem `name`.
  #
  def self.latest_spec_for: (String name) -> Specification?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - latest_version_for(name)
  # -->
  # Returns the version of the latest release-version of gem `name`
  #
  def self.latest_version_for: (String name) -> Version?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_env_plugins()
  # -->
  # Find all 'rubygems_plugin' files in $LOAD_PATH and load them
  #
  def self.load_env_plugins: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_path_insert_index()
  # -->
  # The index to insert activated gem paths into the $LOAD_PATH. The activated
  # gem's paths are inserted before site lib directory by default.
  #
  def self.load_path_insert_index: () -> Integer

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_plugins()
  # -->
  # Find rubygems plugin files in the standard location and load them
  #
  def self.load_plugins: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - load_yaml()
  # -->
  # Loads YAML, preferring Psych
  #
  def self.load_yaml: () -> bool?

  # <!-- rdoc-file=lib/rubygems.rb -->
  # Hash of loaded Gem::Specification keyed by name
  #
  def self.loaded_specs: () -> Hash[String, BasicSpecification]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - location_of_caller(depth = 1)
  # -->
  # The file name and line number of the caller of the caller of this method.
  #
  # `depth` is how many layers up the call stack it should go.
  #
  # e.g.,
  #
  # def a; Gem.location_of_caller; end a #=> ["x.rb", 2]  # (it'll vary depending
  # on file name and line number)
  #
  # def b; c; end def c; Gem.location_of_caller(2); end b #=> ["x.rb", 6]  #
  # (it'll vary depending on file name and line number)
  #
  def self.location_of_caller: (?Integer depth) -> [ String, Integer ]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - marshal_version()
  # -->
  # The version of the Marshal format for your Ruby.
  #
  def self.marshal_version: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - needs() { |rs| ... }
  # -->
  #
  def self.needs: () { (RequestSet) -> void } -> void

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - operating_system_defaults()
  # -->
  # Default options for gem commands for Ruby packagers.
  #
  # The options here should be structured as an array of string "gem" command
  # names as keys and a string of the default options as values.
  #
  # Example:
  #
  # def self.operating_system_defaults
  #     {
  #         'install' => '--no-rdoc --no-ri --env-shebang',
  #         'update' => '--no-rdoc --no-ri --env-shebang'
  #     }
  #
  # end
  #
  def self.operating_system_defaults: () -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - path()
  # -->
  #
  def self.path: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - path_separator()
  # -->
  # How String Gem paths should be split.  Overridable for esoteric platforms.
  #
  def self.path_separator: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - paths()
  # -->
  # Retrieve the PathSupport object that RubyGems uses to lookup files.
  #
  def self.paths: () -> PathSupport

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - paths=(env)
  # -->
  # Initialize the filesystem paths to use from `env`. `env` is a hash-like object
  # (typically ENV) that is queried for 'GEM_HOME', 'GEM_PATH', and
  # 'GEM_SPEC_CACHE' Keys for the `env` hash should be Strings, and values of the
  # hash should be Strings or `nil`.
  #
  def self.paths=: (_HashLike[String, String?] env) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - platform_defaults()
  # -->
  # Default options for gem commands for Ruby implementers.
  #
  # The options here should be structured as an array of string "gem" command
  # names as keys and a string of the default options as values.
  #
  # Example:
  #
  # def self.platform_defaults
  #     {
  #         'install' => '--no-rdoc --no-ri --env-shebang',
  #         'update' => '--no-rdoc --no-ri --env-shebang'
  #     }
  #
  # end
  #
  def self.platform_defaults: () -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - platforms()
  # -->
  # Array of platforms this RubyGems supports.
  #
  def self.platforms: () -> Array[String | Platform]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - platforms=(platforms)
  # -->
  # Set array of platforms this RubyGems supports (primarily for testing).
  #
  def self.platforms=: (Array[String | Platform] platforms) -> Array[String | Platform]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugin_suffix_pattern()
  # -->
  # Glob pattern for require-able plugin suffixes.
  #
  def self.plugin_suffix_pattern: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugin_suffix_regexp()
  # -->
  # Regexp for require-able plugin suffixes.
  #
  def self.plugin_suffix_regexp: () -> Regexp

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - plugindir(install_dir=Gem.dir)
  # -->
  # The path were rubygems plugins are to be installed.
  #
  def self.plugindir: (?String install_dir) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_build(&hook)
  # -->
  # Adds a post-build hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called.  The hook is called after the gem has been
  # extracted and extensions have been built but before the executables or gemspec
  # has been written.  If the hook returns `false` then the gem's files will be
  # removed and the install will be aborted.
  #
  def self.post_build: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Installer#install extracts files and
  # builds extensions
  #
  def self.post_build_hooks: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_install(&hook)
  # -->
  # Adds a post-install hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called
  #
  def self.post_install: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Installer#install completes
  # installation
  #
  def self.post_install_hooks: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_reset(&hook)
  # -->
  # Adds a hook that will get run after Gem::Specification.reset is run.
  #
  def self.post_reset: () { () -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Specification.reset is run.
  #
  def self.post_reset_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - post_uninstall(&hook)
  # -->
  # Adds a post-uninstall hook that will be passed a Gem::Uninstaller instance and
  # the spec that was uninstalled when Gem::Uninstaller#uninstall is called
  #
  def self.post_uninstall: () { (Uninstaller) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run after Gem::Uninstaller#uninstall completes
  # installation
  #
  def self.post_uninstall_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_install(&hook)
  # -->
  # Adds a pre-install hook that will be passed an Gem::Installer instance when
  # Gem::Installer#install is called.  If the hook returns `false` then the
  # install will be aborted.
  #
  def self.pre_install: () { (Installer) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Installer#install does any work
  #
  def self.pre_install_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_reset(&hook)
  # -->
  # Adds a hook that will get run before Gem::Specification.reset is run.
  #
  def self.pre_reset: () { () -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Specification.reset is run.
  #
  def self.pre_reset_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - pre_uninstall(&hook)
  # -->
  # Adds a pre-uninstall hook that will be passed an Gem::Uninstaller instance and
  # the spec that will be uninstalled when Gem::Uninstaller#uninstall is called
  #
  def self.pre_uninstall: () { (Uninstaller) -> untyped } -> Array[Proc]

  # <!-- rdoc-file=lib/rubygems.rb -->
  # The list of hooks to be run before Gem::Uninstaller#uninstall does any work
  #
  def self.pre_uninstall_hooks: () -> Array[Proc?]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - prefix()
  # -->
  # The directory prefix this RubyGems was installed at. If your prefix is in a
  # standard location (ie, rubygems is installed where you'd expect it to be),
  # then prefix returns nil.
  #
  def self.prefix: () -> String?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - read_binary(path)
  # -->
  # Safely read a file in binary mode on all platforms.
  #
  def self.read_binary: (String path) -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - refresh()
  # -->
  # Refresh available gems from disk.
  #
  def self.refresh: () -> Array[Proc]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - register_default_spec(spec)
  # -->
  # Register a Gem::Specification for default gem.
  #
  # Two formats for the specification are supported:
  #
  # *   MRI 2.0 style, where spec.files contains unprefixed require names. The
  #     spec's filenames will be registered as-is.
  # *   New style, where spec.files contains files prefixed with paths from
  #     spec.require_paths. The prefixes are stripped before registering the
  #     spec's filenames. Unprefixed files are omitted.
  #
  def self.register_default_spec: (Specification spec) -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby()
  # -->
  # The path to the running Ruby interpreter.
  #
  def self.ruby: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby_api_version()
  # -->
  # Returns a String containing the API compatibility version of Ruby
  #
  def self.ruby_api_version: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - ruby_engine()
  # -->
  #
  def self.ruby_engine: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ruby_version()
  # -->
  # A Gem::Version for the currently running Ruby.
  #
  def self.ruby_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - rubygems_version()
  # -->
  # A Gem::Version for the currently running RubyGems
  #
  def self.rubygems_version: () -> Version

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - source_date_epoch()
  # -->
  # Returns the value of Gem.source_date_epoch_string, as a Time object.
  #
  # This is used throughout RubyGems for enabling reproducible builds.
  #
  def self.source_date_epoch: () -> Time

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - source_date_epoch_string()
  # -->
  # If the SOURCE_DATE_EPOCH environment variable is set, returns it's value.
  # Otherwise, returns the time that `Gem.source_date_epoch_string` was first
  # called in the same format as SOURCE_DATE_EPOCH.
  #
  # NOTE(@duckinator): The implementation is a tad weird because we want to:
  #     1. Make builds reproducible by default, by having this function always
  #        return the same result during a given run.
  #     2. Allow changing ENV['SOURCE_DATE_EPOCH'] at runtime, since multiple
  #        tests that set this variable will be run in a single process.
  #
  # If you simplify this function and a lot of tests fail, that is likely due to
  # #2 above.
  #
  # Details on SOURCE_DATE_EPOCH:
  # https://reproducible-builds.org/specs/source-date-epoch/
  #
  def self.source_date_epoch_string: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - sources()
  # -->
  # Returns an Array of sources to fetch remote gems from. Uses default_sources if
  # the sources list is empty.
  #
  def self.sources: () -> SourceList

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - sources=(new_sources)
  # -->
  # Need to be able to set the sources without calling Gem.sources.replace since
  # that would cause an infinite loop.
  #
  # DOC: This comment is not documentation about the method itself, it's more of a
  # code comment about the implementation.
  #
  def self.sources=: (SourceList? new_sources) -> SourceList?

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - spec_cache_dir()
  # -->
  #
  def self.spec_cache_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffix_pattern()
  # -->
  # Glob pattern for require-able path suffixes.
  #
  def self.suffix_pattern: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffix_regexp()
  # -->
  # Regexp for require-able path suffixes.
  #
  def self.suffix_regexp: () -> Regexp

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - suffixes()
  # -->
  # Suffixes for require-able paths.
  #
  def self.suffixes: () -> Array[String]

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - time(msg, width = 0, display = Gem.configuration.verbose) { || ... }
  # -->
  # Prints the amount of time the supplied block takes to run using the debug UI
  # output.
  #
  def self.time: [T] (String msg, ?Integer width, ?boolish display) { () -> T } -> T

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - try_activate(path)
  # -->
  # Try to activate a gem containing `path`. Returns true if activation succeeded
  # or wasn't needed because it was already activated. Returns false if it can't
  # find the path in a gem.
  #
  def self.try_activate: (String path) -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - ui()
  # -->
  # Lazily loads DefaultUserInteraction and returns the default UI.
  #
  def self.ui: () -> StreamUI

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - use_gemdeps(path = nil)
  # -->
  # Looks for a gem dependency file at `path` and activates the gems in the file
  # if found.  If the file is not found an ArgumentError is raised.
  #
  # If `path` is not given the RUBYGEMS_GEMDEPS environment variable is used, but
  # if no file is found no exception is raised.
  #
  # If '-' is given for `path` RubyGems searches up from the current working
  # directory for gem dependency files (gem.deps.rb, Gemfile, Isolate) and
  # activates the gems in the first one found.
  #
  # You can run this automatically when rubygems starts.  To enable, set the
  # `RUBYGEMS_GEMDEPS` environment variable to either the path of your gem
  # dependencies file or "-" to auto-discover in parent directories.
  #
  # NOTE: Enabling automatic discovery on multiuser systems can lead to execution
  # of arbitrary code when used from directories outside your control.
  #
  def self.use_gemdeps: (?String path) -> void

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - use_paths(home, *paths)
  # -->
  # Use the `home` and `paths` values for Gem.dir and Gem.path.  Used mainly by
  # the unit tests to provide environment isolation.
  #
  def self.use_paths: (String home, *String paths) -> Hash[String, String]

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - user_dir()
  # -->
  # Path for gems in the user's home directory
  #
  def self.user_dir: () -> String

  # <!--
  #   rdoc-file=lib/rubygems/defaults.rb
  #   - user_home()
  # -->
  # The home directory for the user.
  #
  def self.user_home: () -> String

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - win_platform?()
  # -->
  # Is this a windows platform?
  #
  def self.win_platform?: () -> bool

  # <!--
  #   rdoc-file=lib/rubygems.rb
  #   - write_binary(path, data)
  # -->
  # Safely write a file in binary mode on all platforms.
  #
  def self.write_binary: (String path, String data) -> Integer
end

# <!-- rdoc-file=lib/rubygems/dependency_installer.rb -->
# Installs a gem along with all its dependencies from local and remote gems.
#
class Gem::DependencyInstaller
  type options = Hash[Symbol, untyped]
end

# <!-- rdoc-file=lib/rubygems/request_set.rb -->
# A RequestSet groups a request to activate a set of dependencies.
#
#     nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
#     pg = Gem::Dependency.new 'pg', '~> 0.14'
#
#     set = Gem::RequestSet.new nokogiri, pg
#
#     requests = set.resolve
#
#     p requests.map { |r| r.full_name }
#     #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
#
class Gem::RequestSet
end

# <!-- rdoc-file=lib/rubygems/request_set/gem_dependency_api.rb -->
# A semi-compatible DSL for the Bundler Gemfile and Isolate gem dependencies
# files.
#
# To work with both the Bundler Gemfile and Isolate formats this implementation
# takes some liberties to allow compatibility with each, most notably in
# #source.
#
# A basic gem dependencies file will look like the following:
#
#     source 'https://rubygems.org'
#
#     gem 'rails', '3.2.14a
#     gem 'devise', '~> 2.1', '>= 2.1.3'
#     gem 'cancan'
#     gem 'airbrake'
#     gem 'pg'
#
# RubyGems recommends saving this as gem.deps.rb over Gemfile or Isolate.
#
# To install the gems in this Gemfile use `gem install -g` to install it and
# create a lockfile.  The lockfile will ensure that when you make changes to
# your gem dependencies file a minimum amount of change is made to the
# dependencies of your gems.
#
# RubyGems can activate all the gems in your dependencies file at startup using
# the RUBYGEMS_GEMDEPS environment variable or through Gem.use_gemdeps. See
# Gem.use_gemdeps for details and warnings.
#
# See `gem help install` and `gem help gem_dependencies` for further details.
#
class Gem::RequestSet::GemDependencyAPI
end

# <!-- rdoc-file=lib/rubygems/source_list.rb -->
# The SourceList represents the sources rubygems has been configured to use. A
# source may be created from an array of sources:
#
#     Gem::SourceList.from %w[https://rubygems.example https://internal.example]
#
# Or by adding them:
#
#     sources = Gem::SourceList.new
#     sources << 'https://rubygems.example'
#
# The most common way to get a SourceList is Gem.sources.
#
class Gem::SourceList
end

# <!-- rdoc-file=lib/rubygems/platform.rb -->
# Available list of platforms for targeting Gem installations.
#
# See `gem help platform` for information on platform matching.
#
class Gem::Platform
end

# <!-- rdoc-file=lib/rubygems/config_file.rb -->
# Gem::ConfigFile RubyGems options and gem command options from gemrc.
#
# gemrc is a YAML file that uses strings to match gem command arguments and
# symbols to match RubyGems options.
#
# Gem command arguments use a String key that matches the command name and allow
# you to specify default arguments:
#
#     install: --no-rdoc --no-ri
#     update: --no-rdoc --no-ri
#
# You can use `gem:` to set default arguments for all commands.
#
# RubyGems options use symbol keys.  Valid options are:
#
# `:backtrace`
# :   See #backtrace
# `:sources`
# :   Sets Gem::sources
# `:verbose`
# :   See #verbose
# `:concurrent_downloads`
# :   See #concurrent_downloads
#
#
# gemrc files may exist in various locations and are read and merged in the
# following order:
#
# *   system wide (/etc/gemrc)
# *   per user (~/.gemrc)
# *   per environment (gemrc files listed in the GEMRC environment variable)
#
class Gem::ConfigFile
end

# <!-- rdoc-file=lib/rubygems/basic_specification.rb -->
# BasicSpecification is an abstract class which implements some common code used
# by both Specification and StubSpecification.
#
class Gem::BasicSpecification
end

# <!-- rdoc-file=lib/rubygems/specification.rb -->
# The Specification class contains the information for a gem.  Typically defined
# in a .gemspec file or a Rakefile, and looks like this:
#
#     Gem::Specification.new do |s|
#       s.name        = 'example'
#       s.version     = '0.1.0'
#       s.licenses    = ['MIT']
#       s.summary     = "This is an example!"
#       s.description = "Much longer explanation of the example!"
#       s.authors     = ["Ruby Coder"]
#       s.email       = 'rubycoder@example.com'
#       s.files       = ["lib/example.rb"]
#       s.homepage    = 'https://rubygems.org/gems/example'
#       s.metadata    = { "source_code_uri" => "https://github.com/example/example" }
#     end
#
# Starting in RubyGems 2.0, a Specification can hold arbitrary metadata.  See
# #metadata for restrictions on the format and size of metadata items you may
# add to a specification.
#
class Gem::Specification < Gem::BasicSpecification
end

%a{annotate:rdoc:skip}
module Gem
  # <!-- rdoc-file=lib/rubygems/requirement.rb -->
  # A Requirement is a set of one or more version restrictions. It supports a few
  # (`=, !=, >, <, >=, <=, ~>`) different restriction operators.
  #
  # See Gem::Version for a description on how versions and requirements work
  # together in RubyGems.
  #
  class Requirement
    type operator = "=" | "!=" | ">" | "<" | ">=" | "<=" | "~>"

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # Raised when a bad requirement is encountered
    #
    class BadRequirementError < ArgumentError
    end

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # The default requirement matches any version
    #
    DefaultPrereleaseRequirement: [ operator, Gem::Version ]

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # The default requirement matches any non-prerelease version
    #
    DefaultRequirement: [ operator, Gem::Version ]

    # <!-- rdoc-file=lib/rubygems/requirement.rb -->
    # A regular expression that matches a requirement
    #
    PATTERN: Regexp

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - create(*inputs)
    # -->
    # Factory method to create a Gem::Requirement object.  Input may be a Version, a
    # String, or nil.  Intended to simplify client code.
    #
    # If the input is "weird", the default version requirement is returned.
    #
    def self.create: (*String | Gem::Version | Gem::Requirement | nil inputs) -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - default()
    # -->
    #
    def self.default: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - default_prerelease()
    # -->
    #
    def self.default_prerelease: () -> instance

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - parse(obj)
    # -->
    # Parse `obj`, returning an `[op, version]` pair. `obj` can be a String or a
    # Gem::Version.
    #
    # If `obj` is a String, it can be either a full requirement specification, like
    # `">= 1.2"`, or a simple version number, like `"1.2"`.
    #
    #     parse("> 1.0")                 # => [">", Gem::Version.new("1.0")]
    #     parse("1.0")                   # => ["=", Gem::Version.new("1.0")]
    #     parse(Gem::Version.new("1.0")) # => ["=,  Gem::Version.new("1.0")]
    #
    def self.parse: (String | Gem::Version obj) -> [ operator, Gem::Version ]

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - new(*requirements)
    # -->
    # Constructs a requirement from `requirements`. Requirements can be Strings,
    # Gem::Versions, or Arrays of those. `nil` and duplicate requirements are
    # ignored. An empty set of `requirements` is the same as `">= 0"`.
    #
    def initialize: (*String | Gem::Version requirements) -> void

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - concat(new)
    # -->
    # Concatenates the `new` requirements onto this requirement.
    #
    def concat: (Array[String | Gem::Version] new) -> void

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - exact?()
    # -->
    # true if the requirement is for only an exact version
    #
    def exact?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - none?()
    # -->
    # true if this gem has no requirements.
    #
    def none?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - prerelease?()
    # -->
    # A requirement is a prerelease if any of the versions inside of it are
    # prereleases
    #
    def prerelease?: () -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - satisfied_by?(version)
    # -->
    # True if `version` satisfies this Requirement.
    #
    def satisfied_by?: (Gem::Version version) -> bool

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - ===(version)
    # -->
    #
    alias === satisfied_by?

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - =~(version)
    # -->
    #
    alias =~ satisfied_by?

    # <!--
    #   rdoc-file=lib/rubygems/requirement.rb
    #   - specific?()
    # -->
    # True if the requirement will not always match the latest version.
    #
    def specific?: () -> bool
  end
end

# <!-- rdoc-file=lib/rubygems/path_support.rb -->
# Gem::PathSupport facilitates the GEM_HOME and GEM_PATH environment settings to
# the rest of RubyGems.
#
class Gem::PathSupport
end

# <!-- rdoc-file=lib/rubygems/uninstaller.rb -->
# An Uninstaller.
#
# The uninstaller fires pre and post uninstall hooks.  Hooks can be added either
# through a rubygems_plugin.rb file in an installed gem or via a
# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
# file.  See Gem.pre_uninstall and Gem.post_uninstall for details.
#
class Gem::Uninstaller
end

module Net
  class Protocol
    VERSION: String
  end

  class ProtocolError < StandardError
  end

  class ProtoSyntaxError < ProtocolError
  end

  class ProtoFatalError < ProtocolError
  end

  class ProtoUnknownError < ProtocolError
  end

  class ProtoServerError < ProtocolError
  end

  class ProtoAuthError < ProtocolError
  end

  class ProtoCommandError < ProtocolError
  end

  class ProtoRetriableError < ProtocolError
  end

  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # <!-- rdoc-file=lib/net/http.rb -->
  # ## An HTTP client API for Ruby.
  #
  # Net::HTTP provides a rich library which can be used to build HTTP user-agents.
  #  For more details about HTTP see
  # [RFC2616](http://www.ietf.org/rfc/rfc2616.txt).
  #
  # Net::HTTP is designed to work closely with URI.  URI::HTTP#host,
  # URI::HTTP#port and URI::HTTP#request_uri are designed to work with Net::HTTP.
  #
  # If you are only performing a few GET requests you should try OpenURI.
  #
  # ## Simple Examples
  #
  # All examples assume you have loaded Net::HTTP with:
  #
  #     require 'net/http'
  #
  # This will also require 'uri' so you don't need to require it separately.
  #
  # The Net::HTTP methods in the following section do not persist connections.
  # They are not recommended if you are performing many HTTP requests.
  #
  # ### GET
  #
  #     Net::HTTP.get('example.com', '/index.html') # => String
  #
  # ### GET by URI
  #
  #     uri = URI('http://example.com/index.html?count=10')
  #     Net::HTTP.get(uri) # => String
  #
  # ### GET with Dynamic Parameters
  #
  #     uri = URI('http://example.com/index.html')
  #     params = { :limit => 10, :page => 3 }
  #     uri.query = URI.encode_www_form(params)
  #
  #     res = Net::HTTP.get_response(uri)
  #     puts res.body if res.is_a?(Net::HTTPSuccess)
  #
  # ### POST
  #
  #     uri = URI('http://www.example.com/search.cgi')
  #     res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
  #     puts res.body
  #
  # ### POST with Multiple Values
  #
  #     uri = URI('http://www.example.com/search.cgi')
  #     res = Net::HTTP.post_form(uri, 'q' => ['ruby', 'perl'], 'max' => '50')
  #     puts res.body
  #
  # ## How to use Net::HTTP
  #
  # The following example code can be used as the basis of an HTTP user-agent
  # which can perform a variety of request types using persistent connections.
  #
  #     uri = URI('http://example.com/some_path?query=string')
  #
  #     Net::HTTP.start(uri.host, uri.port) do |http|
  #       request = Net::HTTP::Get.new uri
  #
  #       response = http.request request # Net::HTTPResponse object
  #     end
  #
  # Net::HTTP::start immediately creates a connection to an HTTP server which is
  # kept open for the duration of the block.  The connection will remain open for
  # multiple requests in the block if the server indicates it supports persistent
  # connections.
  #
  # If you wish to re-use a connection across multiple HTTP requests without
  # automatically closing it you can use ::new and then call #start and #finish
  # manually.
  #
  # The request types Net::HTTP supports are listed below in the section "HTTP
  # Request Classes".
  #
  # For all the Net::HTTP request objects and shortcut request methods you may
  # supply either a String for the request path or a URI from which Net::HTTP will
  # extract the request path.
  #
  # ### Response Data
  #
  #     uri = URI('http://example.com/index.html')
  #     res = Net::HTTP.get_response(uri)
  #
  #     # Headers
  #     res['Set-Cookie']            # => String
  #     res.get_fields('set-cookie') # => Array
  #     res.to_hash['set-cookie']    # => Array
  #     puts "Headers: #{res.to_hash.inspect}"
  #
  #     # Status
  #     puts res.code       # => '200'
  #     puts res.message    # => 'OK'
  #     puts res.class.name # => 'HTTPOK'
  #
  #     # Body
  #     puts res.body if res.response_body_permitted?
  #
  # ### Following Redirection
  #
  # Each Net::HTTPResponse object belongs to a class for its response code.
  #
  # For example, all 2XX responses are instances of a Net::HTTPSuccess subclass, a
  # 3XX response is an instance of a Net::HTTPRedirection subclass and a 200
  # response is an instance of the Net::HTTPOK class.  For details of response
  # classes, see the section "HTTP Response Classes" below.
  #
  # Using a case statement you can handle various types of responses properly:
  #
  #     def fetch(uri_str, limit = 10)
  #       # You should choose a better exception.
  #       raise ArgumentError, 'too many HTTP redirects' if limit == 0
  #
  #       response = Net::HTTP.get_response(URI(uri_str))
  #
  #       case response
  #       when Net::HTTPSuccess then
  #         response
  #       when Net::HTTPRedirection then
  #         location = response['location']
  #         warn "redirected to #{location}"
  #         fetch(location, limit - 1)
  #       else
  #         response.value
  #       end
  #     end
  #
  #     print fetch('http://www.ruby-lang.org')
  #
  # ### POST
  #
  # A POST can be made using the Net::HTTP::Post request class.  This example
  # creates a URL encoded POST body:
  #
  #     uri = URI('http://www.example.com/todo.cgi')
  #     req = Net::HTTP::Post.new(uri)
  #     req.set_form_data('from' => '2005-01-01', 'to' => '2005-03-31')
  #
  #     res = Net::HTTP.start(uri.hostname, uri.port) do |http|
  #       http.request(req)
  #     end
  #
  #     case res
  #     when Net::HTTPSuccess, Net::HTTPRedirection
  #       # OK
  #     else
  #       res.value
  #     end
  #
  # To send multipart/form-data use Net::HTTPHeader#set_form:
  #
  #     req = Net::HTTP::Post.new(uri)
  #     req.set_form([['upload', File.open('foo.bar')]], 'multipart/form-data')
  #
  # Other requests that can contain a body such as PUT can be created in the same
  # way using the corresponding request class (Net::HTTP::Put).
  #
  # ### Setting Headers
  #
  # The following example performs a conditional GET using the If-Modified-Since
  # header.  If the files has not been modified since the time in the header a Not
  # Modified response will be returned.  See RFC 2616 section 9.3 for further
  # details.
  #
  #     uri = URI('http://example.com/cached_response')
  #     file = File.stat 'cached_response'
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req['If-Modified-Since'] = file.mtime.rfc2822
  #
  #     res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  #       http.request(req)
  #     }
  #
  #     open 'cached_response', 'w' do |io|
  #       io.write res.body
  #     end if res.is_a?(Net::HTTPSuccess)
  #
  # ### Basic Authentication
  #
  # Basic authentication is performed according to
  # [RFC2617](http://www.ietf.org/rfc/rfc2617.txt).
  #
  #     uri = URI('http://example.com/index.html?key=value')
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req.basic_auth 'user', 'pass'
  #
  #     res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  #       http.request(req)
  #     }
  #     puts res.body
  #
  # ### Streaming Response Bodies
  #
  # By default Net::HTTP reads an entire response into memory.  If you are
  # handling large files or wish to implement a progress bar you can instead
  # stream the body directly to an IO.
  #
  #     uri = URI('http://example.com/large_file')
  #
  #     Net::HTTP.start(uri.host, uri.port) do |http|
  #       request = Net::HTTP::Get.new uri
  #
  #       http.request request do |response|
  #         open 'large_file', 'w' do |io|
  #           response.read_body do |chunk|
  #             io.write chunk
  #           end
  #         end
  #       end
  #     end
  #
  # ### HTTPS
  #
  # HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=.
  #
  #     uri = URI('https://secure.example.com/some_path?query=string')
  #
  #     Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
  #       request = Net::HTTP::Get.new uri
  #       response = http.request request # Net::HTTPResponse object
  #     end
  #
  # Or if you simply want to make a GET request, you may pass in an URI object
  # that has an HTTPS URL. Net::HTTP automatically turns on TLS verification if
  # the URI object has a 'https' URI scheme.
  #
  #     uri = URI('https://example.com/')
  #     Net::HTTP.get(uri) # => String
  #
  # In previous versions of Ruby you would need to require 'net/https' to use
  # HTTPS. This is no longer true.
  #
  # ### Proxies
  #
  # Net::HTTP will automatically create a proxy from the `http_proxy` environment
  # variable if it is present.  To disable use of `http_proxy`, pass `nil` for the
  # proxy address.
  #
  # You may also create a custom proxy:
  #
  #     proxy_addr = 'your.proxy.host'
  #     proxy_port = 8080
  #
  #     Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
  #       # always proxy via your.proxy.addr:8080
  #     }
  #
  # See Net::HTTP.new for further details and examples such as proxies that
  # require a username and password.
  #
  # ### Compression
  #
  # Net::HTTP automatically adds Accept-Encoding for compression of response
  # bodies and automatically decompresses gzip and deflate responses unless a
  # Range header was sent.
  #
  # Compression can be disabled through the Accept-Encoding: identity header.
  #
  # ## HTTP Request Classes
  #
  # Here is the HTTP request class hierarchy.
  #
  # *   Net::HTTPRequest
  #     *   Net::HTTP::Get
  #     *   Net::HTTP::Head
  #     *   Net::HTTP::Post
  #     *   Net::HTTP::Patch
  #     *   Net::HTTP::Put
  #     *   Net::HTTP::Proppatch
  #     *   Net::HTTP::Lock
  #     *   Net::HTTP::Unlock
  #     *   Net::HTTP::Options
  #     *   Net::HTTP::Propfind
  #     *   Net::HTTP::Delete
  #     *   Net::HTTP::Move
  #     *   Net::HTTP::Copy
  #     *   Net::HTTP::Mkcol
  #     *   Net::HTTP::Trace
  #
  #
  #
  # ## HTTP Response Classes
  #
  # Here is HTTP response class hierarchy.  All classes are defined in Net module
  # and are subclasses of Net::HTTPResponse.
  #
  # HTTPUnknownResponse
  # :   For unhandled HTTP extensions
  # HTTPInformation
  # :   1xx
  # HTTPContinue
  # :   100
  # HTTPSwitchProtocol
  # :   101
  # HTTPProcessing
  # :   102
  # HTTPEarlyHints
  # :   103
  # HTTPSuccess
  # :   2xx
  # HTTPOK
  # :   200
  # HTTPCreated
  # :   201
  # HTTPAccepted
  # :   202
  # HTTPNonAuthoritativeInformation
  # :   203
  # HTTPNoContent
  # :   204
  # HTTPResetContent
  # :   205
  # HTTPPartialContent
  # :   206
  # HTTPMultiStatus
  # :   207
  # HTTPAlreadyReported
  # :   208
  # HTTPIMUsed
  # :   226
  # HTTPRedirection
  # :   3xx
  # HTTPMultipleChoices
  # :   300
  # HTTPMovedPermanently
  # :   301
  # HTTPFound
  # :   302
  # HTTPSeeOther
  # :   303
  # HTTPNotModified
  # :   304
  # HTTPUseProxy
  # :   305
  # HTTPTemporaryRedirect
  # :   307
  # HTTPPermanentRedirect
  # :   308
  # HTTPClientError
  # :   4xx
  # HTTPBadRequest
  # :   400
  # HTTPUnauthorized
  # :   401
  # HTTPPaymentRequired
  # :   402
  # HTTPForbidden
  # :   403
  # HTTPNotFound
  # :   404
  # HTTPMethodNotAllowed
  # :   405
  # HTTPNotAcceptable
  # :   406
  # HTTPProxyAuthenticationRequired
  # :   407
  # HTTPRequestTimeOut
  # :   408
  # HTTPConflict
  # :   409
  # HTTPGone
  # :   410
  # HTTPLengthRequired
  # :   411
  # HTTPPreconditionFailed
  # :   412
  # HTTPRequestEntityTooLarge
  # :   413
  # HTTPRequestURITooLong
  # :   414
  # HTTPUnsupportedMediaType
  # :   415
  # HTTPRequestedRangeNotSatisfiable
  # :   416
  # HTTPExpectationFailed
  # :   417
  # HTTPMisdirectedRequest
  # :   421
  # HTTPUnprocessableEntity
  # :   422
  # HTTPLocked
  # :   423
  # HTTPFailedDependency
  # :   424
  # HTTPUpgradeRequired
  # :   426
  # HTTPPreconditionRequired
  # :   428
  # HTTPTooManyRequests
  # :   429
  # HTTPRequestHeaderFieldsTooLarge
  # :   431
  # HTTPUnavailableForLegalReasons
  # :   451
  # HTTPServerError
  # :   5xx
  # HTTPInternalServerError
  # :   500
  # HTTPNotImplemented
  # :   501
  # HTTPBadGateway
  # :   502
  # HTTPServiceUnavailable
  # :   503
  # HTTPGatewayTimeOut
  # :   504
  # HTTPVersionNotSupported
  # :   505
  # HTTPVariantAlsoNegotiates
  # :   506
  # HTTPInsufficientStorage
  # :   507
  # HTTPLoopDetected
  # :   508
  # HTTPNotExtended
  # :   510
  # HTTPNetworkAuthenticationRequired
  # :   511
  #
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTP < Protocol
    # :stopdoc:
    VERSION: String

    Revision: untyped

    HTTPVersion: String

    HAVE_ZLIB: bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2()
    # -->
    # Turns on net/http 1.2 (Ruby 1.8) features. Defaults to ON in Ruby 1.8 or
    # later.
    #
    def self.version_1_2: () -> ::TrueClass

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2?()
    # -->
    # Returns true if net/http is in version 1.2 mode. Defaults to true.
    #
    def self.version_1_2?: () -> ::TrueClass

    def self.version_1_1?: () -> ::FalseClass

    alias self.is_version_1_1? self.version_1_1?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - is_version_1_2?()
    # -->
    #
    alias self.is_version_1_2? self.version_1_2?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get_print(uri_or_host, path_or_headers = nil, port = nil)
    # -->
    # Gets the body text from the target and outputs it to $stdout.  The target can
    # either be specified as (`uri`, `headers`), or as (`host`, `path`, `port` =
    # 80); so:
    #
    #     Net::HTTP.get_print URI('http://www.example.com/index.html')
    #
    # or:
    #
    #     Net::HTTP.get_print 'www.example.com', '/index.html'
    #
    # you can also specify request headers:
    #
    #     Net::HTTP.get_print URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' }
    #
    def self.get_print: (URI::Generic uri, ?Hash[String, untyped] header) -> void
                      | (String host, String path, ?Integer port) -> void

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get(uri_or_host, path_or_headers = nil, port = nil)
    # -->
    # Sends a GET request to the target and returns the HTTP response as a string.
    # The target can either be specified as (`uri`, `headers`), or as (`host`,
    # `path`, `port` = 80); so:
    #
    #     print Net::HTTP.get(URI('http://www.example.com/index.html'))
    #
    # or:
    #
    #     print Net::HTTP.get('www.example.com', '/index.html')
    #
    # you can also specify request headers:
    #
    #     Net::HTTP.get(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })
    #
    def self.get: (URI::Generic uri, ?Hash[String, untyped] header) -> String
                | (String host, String path, ?Integer port) -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get_response(uri_or_host, path_or_headers = nil, port = nil, &block)
    # -->
    # Sends a GET request to the target and returns the HTTP response as a
    # Net::HTTPResponse object.  The target can either be specified as (`uri`,
    # `headers`), or as (`host`, `path`, `port` = 80); so:
    #
    #     res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))
    #     print res.body
    #
    # or:
    #
    #     res = Net::HTTP.get_response('www.example.com', '/index.html')
    #     print res.body
    #
    # you can also specify request headers:
    #
    #     Net::HTTP.get_response(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })
    #
    def self.get_response: (URI::Generic uri, ?Hash[String, untyped] header) ?{ (Net::HTTPResponse) -> void } -> Net::HTTPResponse
                         | (String host, String path, ?Integer port) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(url, data, header = nil)
    # -->
    # Posts data to the specified URI object.
    #
    # Example:
    #
    #     require 'net/http'
    #     require 'uri'
    #
    #     Net::HTTP.post URI('http://www.example.com/api/search'),
    #                    { "q" => "ruby", "max" => "50" }.to_json,
    #                    "Content-Type" => "application/json"
    #
    def self.post: (URI::Generic url, String data, ?Hash[String, untyped] header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post_form(url, params)
    # -->
    # Posts HTML form data to the specified URI object. The form data must be
    # provided as a Hash mapping from String to String. Example:
    #
    #     { "cmd" => "search", "q" => "ruby", "max" => "50" }
    #
    # This method also does Basic Authentication if and only if `url`.user exists.
    # But userinfo for authentication is deprecated (RFC3986). So this feature will
    # be removed.
    #
    # Example:
    #
    #     require 'net/http'
    #
    #     Net::HTTP.post_form URI('http://www.example.com/search.cgi'),
    #                         { "q" => "ruby", "max" => "50" }
    #
    def self.post_form: (URI::Generic url, Hash[String, untyped] params) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - default_port()
    # -->
    # The default port to use for HTTP requests; defaults to 80.
    #
    def self.default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - http_default_port()
    # -->
    # The default port to use for HTTP requests; defaults to 80.
    #
    def self.http_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - https_default_port()
    # -->
    # The default port to use for HTTPS requests; defaults to 443.
    #
    def self.https_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - HTTP.start(address, port, p_addr, p_port, p_user, p_pass, &block)
    #   - HTTP.start(address, port=nil, p_addr=:ENV, p_port=nil, p_user=nil, p_pass=nil, opt, &block)
    # -->
    # Creates a new Net::HTTP object, then additionally opens the TCP connection and
    # HTTP session.
    #
    # Arguments are the following:
    # *address*
    # :   hostname or IP address of the server
    # *port*
    # :   port of the server
    # *p_addr*
    # :   address of proxy
    # *p_port*
    # :   port of proxy
    # *p_user*
    # :   user of proxy
    # *p_pass*
    # :   pass of proxy
    # *opt*
    # :   optional hash
    #
    #
    # *opt* sets following values by its accessor. The keys are ipaddr, ca_file,
    # ca_path, cert, cert_store, ciphers, keep_alive_timeout,
    # close_on_empty_response, key, open_timeout, read_timeout, write_timeout,
    # ssl_timeout, ssl_version, use_ssl, verify_callback, verify_depth and
    # verify_mode. If you set :use_ssl as true, you can use https and default value
    # of verify_mode is set as OpenSSL::SSL::VERIFY_PEER.
    #
    # If the optional block is given, the newly created Net::HTTP object is passed
    # to it and closed when the block finishes.  In this case, the return value of
    # this method is the return value of the block.  If no block is given, the
    # return value of this method is the newly created Net::HTTP object itself, and
    # the caller is responsible for closing it upon completion using the finish()
    # method.
    #
    def self.start: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) -> Net::HTTP
                  | [T] (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) { (Net::HTTP) -> T } -> T

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - newobj(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
    # -->
    #
    alias self.newobj self.new

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - new(address, port = nil)
    # -->
    # Creates a new Net::HTTP object for the specified server address, without
    # opening the TCP connection or initializing the HTTP session. The `address`
    # should be a DNS hostname or IP address.
    #
    def self.new: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?untyped? p_no_proxy) -> Net::HTTP

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - set_debug_output(output)
    # -->
    # **WARNING** This method opens a serious security hole. Never use this method
    # in production code.
    #
    # Sets an output stream for debugging.
    #
    #     http = Net::HTTP.new(hostname)
    #     http.set_debug_output $stderr
    #     http.start { .... }
    #
    def set_debug_output: (IO output) -> void

    # <!-- rdoc-file=lib/net/http.rb -->
    # The DNS host name or IP address to connect to.
    #
    attr_reader address: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # The port number to connect to.
    #
    attr_reader port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # The local host used to establish the connection.
    #
    attr_accessor local_host: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # The local port used to establish the connection.
    #
    attr_accessor local_port: Integer

    attr_writer proxy_from_env: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr()
    # -->
    # The IP address to connect to/used to connect to
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr=(addr)
    # -->
    # Set the IP address to connect to
    #
    attr_accessor ipaddr: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for the connection to open. Any number may be used,
    # including Floats for fractional seconds. If the HTTP object cannot open a
    # connection in this many seconds, it raises a Net::OpenTimeout exception. The
    # default value is 60 seconds.
    #
    attr_accessor open_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for one block to be read (via one read(2) call). Any
    # number may be used, including Floats for fractional seconds. If the HTTP
    # object cannot read data in this many seconds, it raises a Net::ReadTimeout
    # exception. The default value is 60 seconds.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - read_timeout=(sec)
    # -->
    # Setter for the read_timeout attribute.
    #
    attr_accessor read_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for one block to be written (via one write(2) call).
    # Any number may be used, including Floats for fractional seconds. If the HTTP
    # object cannot write data in this many seconds, it raises a Net::WriteTimeout
    # exception. The default value is 60 seconds. Net::WriteTimeout is not raised on
    # Windows.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - write_timeout=(sec)
    # -->
    # Setter for the write_timeout attribute.
    #
    attr_accessor write_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - max_retries=(retries)
    # -->
    # Maximum number of times to retry an idempotent request in case of
    # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET, Errno::ECONNABORTED,
    # Errno::EPIPE, OpenSSL::SSL::SSLError, Timeout::Error. Should be a non-negative
    # integer number. Zero means no retries. The default value is 1.
    #
    attr_accessor max_retries: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Seconds to wait for 100 Continue response. If the HTTP object does not receive
    # a response in this many seconds it sends the request body. The default value
    # is `nil`.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - continue_timeout=(sec)
    # -->
    # Setter for the continue_timeout attribute.
    #
    attr_accessor continue_timeout: Float | Integer | nil

    # <!-- rdoc-file=lib/net/http.rb -->
    # Seconds to reuse the connection of the previous request. If the idle time is
    # less than this Keep-Alive Timeout, Net::HTTP reuses the TCP/IP socket used by
    # the previous communication. The default value is 2 seconds.
    #
    attr_accessor keep_alive_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - started?()
    # -->
    # Returns true if the HTTP session has been started.
    #
    def started?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - active?()
    # -->
    #
    alias active? started?

    attr_accessor close_on_empty_response: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl?()
    # -->
    # Returns true if SSL/TLS is being used with HTTP.
    #
    def use_ssl?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl=(flag)
    # -->
    # Turn on/off SSL. This flag must be set before starting session. If you change
    # use_ssl value after session started, a Net::HTTP object raises IOError.
    #
    def use_ssl=: (boolish flag) -> void

    SSL_IVNAMES: Array[untyped]

    SSL_ATTRIBUTES: Array[Symbol]

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets path of a CA certification file in PEM format.
    #
    # The file can contain several CA certificates.
    #
    attr_accessor ca_file: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets path of a CA certification directory containing certifications in PEM
    # format.
    #
    attr_accessor ca_path: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets an OpenSSL::X509::Certificate object as client certificate. (This method
    # is appeared in Michal Rokos's OpenSSL extension).
    #
    attr_accessor cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the X509::Store to verify peer certificate.
    #
    attr_accessor cert_store: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=
    #
    attr_accessor ciphers: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the extra X509 certificates to be added to the certificate chain. See
    # OpenSSL::SSL::SSLContext#extra_chain_cert=
    #
    attr_accessor extra_chain_cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object. (This method is
    # appeared in Michal Rokos's OpenSSL extension.)
    #
    attr_accessor key: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the SSL timeout seconds.
    #
    attr_accessor ssl_timeout: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=
    #
    attr_accessor ssl_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the minimum SSL version.  See OpenSSL::SSL::SSLContext#min_version=
    #
    attr_accessor min_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the maximum SSL version.  See OpenSSL::SSL::SSLContext#max_version=
    #
    attr_accessor max_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the verify callback for the server certification verification.
    #
    attr_accessor verify_callback: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the maximum depth for the certificate chain verification.
    #
    attr_accessor verify_depth: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the flags for server the certification verification at beginning of
    # SSL/TLS session.
    #
    # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
    #
    attr_accessor verify_mode: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets to check the server certificate is valid for the hostname. See
    # OpenSSL::SSL::SSLContext#verify_hostname=
    #
    attr_accessor verify_hostname: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - peer_cert()
    # -->
    # Returns the X.509 certificates the server presented.
    #
    def peer_cert: () -> (nil | untyped)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - start() { |http| ... }
    # -->
    # Opens a TCP connection and HTTP session.
    #
    # When this method is called with a block, it passes the Net::HTTP object to the
    # block, and closes the TCP connection and HTTP session after the block has been
    # executed.
    #
    # When called with a block, it returns the return value of the block; otherwise,
    # it returns self.
    #
    def start: [T] () { (Net::HTTP) -> T } -> T
             | () -> Net::HTTP

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - finish()
    # -->
    # Finishes the HTTP session and closes the TCP connection. Raises IOError if the
    # session has not been started.
    #
    def finish: () -> void

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Proxy(p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil)
    # -->
    # Creates an HTTP proxy class which behaves like Net::HTTP, but performs all
    # access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    def self.Proxy: (?Symbol | String p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass) -> untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_class?()
    # -->
    # returns true if self is a class which was created by HTTP::Proxy.
    #
    def self.proxy_class?: () -> bool

    # <!-- rdoc-file=lib/net/http.rb -->
    # Address of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Port number of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # User name for accessing proxy. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # User password for accessing proxy. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy?()
    # -->
    # True if requests for this connection will be proxied
    #
    def proxy?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_from_env?()
    # -->
    # True if the proxy for this connection is determined from the environment
    #
    def proxy_from_env?: () -> bool

    def proxy_uri: () -> (nil | URI::Generic)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyaddr()
    # -->
    #
    alias proxyaddr proxy_address

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyport()
    # -->
    #
    alias proxyport proxy_port

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get(path, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Retrieves data from `path` on the connected-to host which may be an absolute
    # path String or a URI to extract the path from.
    #
    # `initheader` must be a Hash like { 'Accept' => '**/**', ... }, and it defaults
    # to an empty hash. If `initheader` doesn't have the key 'accept-encoding', then
    # a value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used, so that gzip
    # compression is used in preference to deflate compression, which is used in
    # preference to no compression. Ruby doesn't have libraries to support the
    # compress (Lempel-Ziv) compression, so that is not supported.  The intent of
    # this is to reduce bandwidth by default.   If this routine sets up compression,
    # then it does the decompression also, removing the header as well to prevent
    # confusion.  Otherwise it leaves the body as it found it.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # If called with a block, yields each fragment of the entity body in turn as a
    # string as it is read from the socket.  Note that in this case, the returned
    # response object will **not** contain a (meaningful) body.
    #
    # `dest` argument is obsolete. It still works but you must not use it.
    #
    # This method never raises an exception.
    #
    #     response = http.get('/index.html')
    #
    #     # using block
    #     File.open('result.txt', 'w') {|f|
    #       http.get('/~foo/') do |str|
    #         f.write str
    #       end
    #     }
    #
    def get: (String path, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head(path, initheader = nil)
    # -->
    # Gets only the header from `path` on the connected-to host. `header` is a Hash
    # like { 'Accept' => '**/**', ... }.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # This method never raises an exception.
    #
    #     response = nil
    #     Net::HTTP.start('some.www.server', 80) {|http|
    #       response = http.head('/index.html')
    #     }
    #     p response['content-type']
    #
    def head: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(path, data, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Posts `data` (must be a String) to `path`. `header` must be a Hash like {
    # 'Accept' => '**/**', ... }.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # If called with a block, yields each fragment of the entity body in turn as a
    # string as it is read from the socket.  Note that in this case, the returned
    # response object will **not** contain a (meaningful) body.
    #
    # `dest` argument is obsolete. It still works but you must not use it.
    #
    # This method never raises exception.
    #
    #     response = http.post('/cgi-bin/search.rb', 'query=foo')
    #
    #     # using block
    #     File.open('result.txt', 'w') {|f|
    #       http.post('/cgi-bin/search.rb', 'query=foo') do |str|
    #         f.write str
    #       end
    #     }
    #
    # You should set Content-Type: header field for POST. If no Content-Type: field
    # given, this method uses "application/x-www-form-urlencoded" by default.
    #
    def post: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - patch(path, data, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Sends a PATCH request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def patch: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    def put: (String path, String data, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proppatch(path, body, initheader = nil)
    # -->
    # Sends a PROPPATCH request to the `path` and gets a response, as an
    # HTTPResponse object.
    #
    def proppatch: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - lock(path, body, initheader = nil)
    # -->
    # Sends a LOCK request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def lock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - unlock(path, body, initheader = nil)
    # -->
    # Sends a UNLOCK request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def unlock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - options(path, initheader = nil)
    # -->
    # Sends a OPTIONS request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def options: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - propfind(path, body = nil, initheader = {'Depth' => '0'})
    # -->
    # Sends a PROPFIND request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def propfind: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - delete(path, initheader = {'Depth' => 'Infinity'})
    # -->
    # Sends a DELETE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def delete: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - move(path, initheader = nil)
    # -->
    # Sends a MOVE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def move: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - copy(path, initheader = nil)
    # -->
    # Sends a COPY request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def copy: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - mkcol(path, body = nil, initheader = nil)
    # -->
    # Sends a MKCOL request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def mkcol: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - trace(path, initheader = nil)
    # -->
    # Sends a TRACE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def trace: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_get(path, initheader = nil) { |response| ... }
    # -->
    # Sends a GET request to the `path`. Returns the response as a Net::HTTPResponse
    # object.
    #
    # When called with a block, passes an HTTPResponse object to the block. The body
    # of the response will not have been read yet; the block can process it using
    # HTTPResponse#read_body, if desired.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.request_get('/index.html')
    #     # The entity body is already read in this case.
    #     p response['content-type']
    #     puts response.body
    #
    #     # Using a block
    #     http.request_get('/index.html') {|response|
    #       p response['content-type']
    #       response.read_body do |str|   # read body now
    #         print str
    #       end
    #     }
    #
    def request_get: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_head(path, initheader = nil, &block)
    # -->
    # Sends a HEAD request to the `path` and returns the response as a
    # Net::HTTPResponse object.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.request_head('/index.html')
    #     p response['content-type']
    #
    def request_head: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_post(path, data, initheader = nil) { |response| ... }
    # -->
    # Sends a POST request to the `path`.
    #
    # Returns the response as a Net::HTTPResponse object.
    #
    # When called with a block, the block is passed an HTTPResponse object.  The
    # body of that response will not have been read yet; the block can process it
    # using HTTPResponse#read_body, if desired.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     # example
    #     response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
    #     p response.status
    #     puts response.body          # body is already read in this case
    #
    #     # using block
    #     http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
    #       p response.status
    #       p response['content-type']
    #       response.read_body do |str|   # read body now
    #         print str
    #       end
    #     }
    #
    def request_post: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    def request_put: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get2(path, initheader = nil)
    # -->
    #
    alias get2 request_get

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head2(path, initheader = nil, &block)
    # -->
    #
    alias head2 request_head

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post2(path, data, initheader = nil)
    # -->
    #
    alias post2 request_post

    alias put2 request_put

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - send_request(name, path, data = nil, header = nil)
    # -->
    # Sends an HTTP request to the HTTP server. Also sends a DATA string if `data`
    # is given.
    #
    # Returns a Net::HTTPResponse object.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.send_request('GET', '/index.html')
    #     puts response.body
    #
    def send_request: (String name, String path, ?String? data, ?Hash[String, untyped]? header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request(req, body = nil) { |response| ... }
    # -->
    # Sends an HTTPRequest object `req` to the HTTP server.
    #
    # If `req` is a Net::HTTP::Post or Net::HTTP::Put request containing data, the
    # data is also sent. Providing data for a Net::HTTP::Head or Net::HTTP::Get
    # request results in an ArgumentError.
    #
    # Returns an HTTPResponse object.
    #
    # When called with a block, passes an HTTPResponse object to the block. The body
    # of the response will not have been read yet; the block can process it using
    # HTTPResponse#read_body, if desired.
    #
    # This method never raises Net::* exceptions.
    #
    def request: (Net::HTTPRequest req, ?String? body) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse
  end

  # <!-- rdoc-file=lib/net/http/generic_request.rb -->
  # HTTPGenericRequest is the parent of the Net::HTTPRequest class. Do not use
  # this directly; use a subclass of Net::HTTPRequest.
  #
  # Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.
  #
  class HTTPGenericRequest
    include Net::HTTPHeader

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - new(m, reqbody, resbody, uri_or_path, initheader = nil)
    # -->
    #
    def initialize: (String m, boolish reqbody, boolish resbody, URI::Generic | String uri_or_path, ?Hash[String, untyped] initheader) -> Net::HTTP

    attr_reader method: String

    attr_reader path: String

    attr_reader uri: URI::Generic

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Automatically set to false if the user sets the Accept-Encoding header. This
    # indicates they wish to handle Content-encoding in responses themselves.
    #
    attr_reader decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def []=: (untyped key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - request_body_permitted?()
    # -->
    #
    def request_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - response_body_permitted?()
    # -->
    #
    def response_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_exist?()
    # -->
    #
    def body_exist?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body=(str)
    # -->
    #
    attr_accessor body: String?

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_stream=(input)
    # -->
    #
    attr_accessor body_stream: untyped
  end

  # <!-- rdoc-file=lib/net/http/header.rb -->
  # The HTTPHeader module defines methods for reading and writing HTTP headers.
  #
  # It is used as a mixin by other classes, to provide hash-like access to HTTP
  # header values. Unlike raw hash access, HTTPHeader provides access via
  # case-insensitive keys. It also provides methods for accessing commonly-used
  # HTTP header values in more convenient formats.
  #
  module HTTPHeader
    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - initialize_http_header(initheader)
    # -->
    #
    def initialize_http_header: (Hash[untyped, untyped] initheader) -> void

    def size: () -> Integer

    alias length size

    type key = String | Symbol

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - [](key)
    # -->
    # Returns the header field corresponding to the case-insensitive key. For
    # example, a key of "Content-Type" might return "text/html"
    #
    def []: (key key) -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - []=(key, val)
    # -->
    # Sets the header field corresponding to the case-insensitive key.
    #
    def []=: (key key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - add_field(key, val)
    # -->
    # Ruby 1.8.3
    # :   Adds a value to a named header field, instead of replacing its value.
    #     Second argument `val` must be a String. See also #[]=, #[] and
    #     #get_fields.
    #
    #         request.add_field 'X-My-Header', 'a'
    #         p request['X-My-Header']              #=> "a"
    #         p request.get_fields('X-My-Header')   #=> ["a"]
    #         request.add_field 'X-My-Header', 'b'
    #         p request['X-My-Header']              #=> "a, b"
    #         p request.get_fields('X-My-Header')   #=> ["a", "b"]
    #         request.add_field 'X-My-Header', 'c'
    #         p request['X-My-Header']              #=> "a, b, c"
    #         p request.get_fields('X-My-Header')   #=> ["a", "b", "c"]
    #
    def add_field: (key key, untyped val) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_field(key, val)
    # -->
    #
    def set_field: (key key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - append_field_value(ary, val)
    # -->
    #
    def append_field_value: (untyped ary, untyped val) -> void

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - get_fields(key)
    # -->
    # Ruby 1.8.3
    # :   Returns an array of header field strings corresponding to the
    #     case-insensitive `key`.  This method allows you to get duplicated header
    #     fields without any processing.  See also #[].
    #
    #         p response.get_fields('Set-Cookie')
    #           #=> ["session=al98axx; expires=Fri, 31-Dec-1999 23:58:23",
    #                "query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"]
    #         p response['Set-Cookie']
    #           #=> "session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"
    #
    def get_fields: (key key) -> (nil | Array[String])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - fetch(key, *args) { |key| ... }
    # -->
    # Returns the header field corresponding to the case-insensitive key. Returns
    # the default value `args`, or the result of the block, or raises an IndexError
    # if there's no header field named `key` See Hash#fetch
    #
    def fetch: (key key) -> String
             | (key key, untyped) -> untyped
             | (key key) { (String) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_header() { |key| ... }
    # -->
    # Iterates through the header names and values, passing in the name and value to
    # the code block supplied.
    #
    # Returns an enumerator if no block is given.
    #
    # Example:
    #
    #     response.header.each_header {|key,value| puts "#{key} = #{value}" }
    #
    def each_header: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                   | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each()
    # -->
    #
    alias each each_header

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_name() { |key| ... }
    # -->
    # Iterates through the header names in the header, passing each header name to
    # the code block.
    #
    # Returns an enumerator if no block is given.
    #
    def each_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                 | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_key()
    # -->
    #
    alias each_key each_name

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized_name() { |key| ... }
    # -->
    # Iterates through the header names in the header, passing capitalized header
    # names to the code block.
    #
    # Note that header names are capitalized systematically; capitalization may not
    # match that used by the remote HTTP server in its response.
    #
    # Returns an enumerator if no block is given.
    #
    def each_capitalized_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                             | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_value() { |value| ... }
    # -->
    # Iterates through header values, passing each value to the code block.
    #
    # Returns an enumerator if no block is given.
    #
    def each_value: () { (String) -> untyped } -> Hash[String, Array[String]]
                  | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - delete(key)
    # -->
    # Removes a header field, specified by case-insensitive key.
    #
    def delete: (key key) -> (Array[String] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - key?(key)
    # -->
    # true if `key` header exists.
    #
    def key?: (key key) -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - to_hash()
    # -->
    # Returns a Hash consisting of header names and array of values. e.g.
    # {"cache-control" => ["private"],
    #     "content-type" => ["text/html"],
    #     "date" => ["Wed, 22 Jun 2005 22:11:50 GMT"]}
    #
    def to_hash: () -> Hash[String, Array[String]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized() { |capitalize(k), join(', ')| ... }
    # -->
    # As for #each_header, except the keys are provided in capitalized form.
    #
    # Note that header names are capitalized systematically; capitalization may not
    # match that used by the remote HTTP server in its response.
    #
    # Returns an enumerator if no block is given.
    #
    def each_capitalized: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                        | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - canonical_each()
    # -->
    #
    alias canonical_each each_capitalized

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - capitalize(name)
    # -->
    #
    def capitalize: (key name) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range()
    # -->
    # Returns an Array of Range objects which represent the Range: HTTP header
    # field, or `nil` if there is no such header.
    #
    def range: () -> (nil | Array[Range[Integer]])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_range(r, e = nil)
    # -->
    # Sets the HTTP Range: header. Accepts either a Range object as a single
    # argument, or a beginning index and a length from that index. Example:
    #
    #     req.range = (0..1023)
    #     req.set_range 0, 1023
    #
    def set_range: (Range[Integer] | Numeric r, ?Integer? e) -> Range[Integer]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range=(r, e = nil)
    # -->
    #
    alias range= set_range

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length()
    # -->
    # Returns an Integer object which represents the HTTP Content-Length: header
    # field, or `nil` if that field was not provided.
    #
    def content_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length=(len)
    # -->
    #
    def content_length=: (Integer len) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - chunked?()
    # -->
    # Returns "true" if the "transfer-encoding" header is present and set to
    # "chunked".  This is an HTTP/1.1 feature, allowing the content to be sent in
    # "chunks" without at the outset stating the entire content length.
    #
    def chunked?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_range()
    # -->
    # Returns a Range object which represents the value of the Content-Range: header
    # field. For a partial entity body, this indicates where this fragment fits
    # inside the full entity body, as range of byte offsets.
    #
    def content_range: () -> (Range[Integer] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range_length()
    # -->
    # The length of the range represented in Content-Range: header.
    #
    def range_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type()
    # -->
    # Returns a content type string such as "text/html". This method returns nil if
    # Content-Type: header field does not exist.
    #
    def content_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - main_type()
    # -->
    # Returns a content type string such as "text". This method returns nil if
    # Content-Type: header field does not exist.
    #
    def main_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - sub_type()
    # -->
    # Returns a content type string such as "html". This method returns nil if
    # Content-Type: header field does not exist or sub-type is not given (e.g.
    # "Content-Type: text").
    #
    def sub_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - type_params()
    # -->
    # Any parameters specified for the content type, returned as a Hash. For
    # example, a header of Content-Type: text/html; charset=EUC-JP would result in
    # type_params returning {'charset' => 'EUC-JP'}
    #
    def type_params: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_content_type(type, params = {})
    # -->
    # Sets the content type in an HTTP header. The `type` should be a full HTTP
    # content type, e.g. "text/html". The `params` are an optional Hash of
    # parameters to add after the content type, e.g. {'charset' => 'iso-8859-1'}
    #
    def set_content_type: (key `type`, ?Hash[untyped, untyped] params) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type=(type, params = {})
    # -->
    #
    alias content_type= set_content_type

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form_data(params, sep = '&')
    # -->
    # Set header fields and a body from HTML form data. `params` should be an Array
    # of Arrays or a Hash containing HTML form data. Optional argument `sep` means
    # data record separator.
    #
    # Values are URL encoded as necessary and the content-type is set to
    # application/x-www-form-urlencoded
    #
    # Example:
    #     http.form_data = {"q" => "ruby", "lang" => "en"}
    #     http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
    #     http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
    #
    def set_form_data: (Hash[untyped, untyped] params, ?String sep) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - form_data=(params, sep = '&')
    # -->
    #
    alias form_data= set_form_data

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form(params, enctype='application/x-www-form-urlencoded', formopt={})
    # -->
    # Set an HTML form data set.
    # `params`
    # :   The form data to set, which should be an enumerable. See below for more
    #     details.
    # `enctype`
    # :   The content type to use to encode the form submission, which should be
    #     application/x-www-form-urlencoded or multipart/form-data.
    # `formopt`
    # :   An options hash, supporting the following options:
    #     :boundary
    # :       The boundary of the multipart message. If not given, a random boundary
    #         will be used.
    #     :charset
    # :       The charset of the form submission. All field names and values of
    #         non-file fields should be encoded with this charset.
    #
    #
    #
    # Each item of params should respond to `each` and yield 2-3 arguments, or an
    # array of 2-3 elements. The arguments yielded should be:
    #     * The name of the field.
    #     * The value of the field, it should be a String or a File or IO-like.
    #     * An options hash, supporting the following options, only
    #       used for file uploads:
    #       :filename :: The name of the file to use.
    #       :content_type :: The content type of the uploaded file.
    #
    # Each item is a file field or a normal field. If `value` is a File object or
    # the `opt` hash has a :filename key, the item is treated as a file field.
    #
    # If Transfer-Encoding is set as chunked, this sends the request using chunked
    # encoding. Because chunked encoding is HTTP/1.1 feature, you should confirm
    # that the server supports HTTP/1.1 before using chunked encoding.
    #
    # Example:
    #     req.set_form([["q", "ruby"], ["lang", "en"]])
    #
    #     req.set_form({"f"=>File.open('/path/to/filename')},
    #                  "multipart/form-data",
    #                  charset: "UTF-8",
    #     )
    #
    #     req.set_form([["f",
    #                    File.open('/path/to/filename.bar'),
    #                    {filename: "other-filename.foo"}
    #                  ]],
    #                  "multipart/form-data",
    #     )
    #
    # See also RFC 2388, RFC 2616, HTML 4.01, and HTML5
    #
    def set_form: (Hash[untyped, untyped] params, ?String enctype, ?Hash[untyped, untyped] formopt) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_auth(account, password)
    # -->
    # Set the Authorization: header for "Basic" authorization.
    #
    def basic_auth: (String account, String password) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - proxy_basic_auth(account, password)
    # -->
    # Set Proxy-Authorization: header for "Basic" authorization.
    #
    def proxy_basic_auth: (String account, String password) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_encode(account, password)
    # -->
    #
    def basic_encode: (String account, String password) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_close?()
    # -->
    #
    def connection_close?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_keep_alive?()
    # -->
    #
    def connection_keep_alive?: () -> bool
  end

  # <!-- rdoc-file=lib/net/http/request.rb -->
  # HTTP request class. This class wraps together the request header and the
  # request path. You cannot use this class directly. Instead, you should use one
  # of its subclasses: Net::HTTP::Get, Net::HTTP::Post, Net::HTTP::Head.
  #
  class HTTPRequest < HTTPGenericRequest
    # <!--
    #   rdoc-file=lib/net/http/request.rb
    #   - new(path, initheader = nil)
    # -->
    # Creates an HTTP request object for `path`.
    #
    # `initheader` are the default headers to use.  Net::HTTP adds Accept-Encoding
    # to enable compression of the response body unless Accept-Encoding or Range are
    # supplied in `initheader`.
    #
    def initialize: (String path, ?Hash[String, untyped] initheader) -> void
                  | (URI::Generic uri, ?Hash[String, untyped] initheader) -> void
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
  # usage examples.
  #
  class HTTP::Get < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
  # usage examples.
  #
  class HTTP::Head < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
  # usage examples.
  #
  class HTTP::Post < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
  # usage examples.
  #
  class HTTP::Put < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
  # usage examples.
  #
  class HTTP::Delete < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Options < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Trace < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Patch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Propfind < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Proppatch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Mkcol < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Copy < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Move < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Lock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # See Net::HTTPGenericRequest for attributes and methods.
  #
  class HTTP::Unlock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # HTTP response class.
  #
  # This class wraps together the response header and the response body (the
  # entity requested).
  #
  # It mixes in the HTTPHeader module, which provides access to response header
  # values both via hash-like methods and via individual readers.
  #
  # Note that each possible HTTP response code defines its own HTTPResponse
  # subclass. All classes are defined under the Net module. Indentation indicates
  # inheritance.  For a list of the classes see Net::HTTP.
  #
  # Correspondence `HTTP code => class` is stored in CODE_TO_OBJ constant:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound
  #
  class HTTPResponse
    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body_permitted?()
    # -->
    # true if the response has a body.
    #
    def self.body_permitted?: () -> bool

    public

    include Net::HTTPHeader

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP version supported by the server.
    #
    attr_reader http_version: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result code string. For example, '302'.  You can also determine the
    # response type by examining which response subclass the response object is an
    # instance of.
    #
    attr_reader code: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    attr_reader message: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    alias msg message

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The URI used to fetch this response.  The response URI is only available if a
    # URI was used to create the request.
    #
    attr_reader uri: URI::Generic | nil

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # Set to true automatically when the request did not contain an Accept-Encoding
    # header from the user.
    #
    attr_accessor decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def code_type: () -> untyped

    def error!: () -> untyped

    def error_type: () -> (Net::HTTPError | Net::HTTPServerException | Net::HTTPRetriableError | Net::HTTPFatalError)

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - value()
    # -->
    # Raises an HTTP error if the response is not 2xx (success).
    #
    def value: () -> (nil | untyped)

    def uri=: (URI::Generic uri) -> void

    interface _Dest
      def <<: (String) -> void
    end

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - read_body(dest = nil, &block)
    # -->
    # Gets the entity body returned by the remote HTTP server.
    #
    # If a block is given, the body is passed to the block, and the body is provided
    # in fragments, as it is read in from the socket.
    #
    # If `dest` argument is given, response is read into that variable, with
    # `dest#<<` method (it could be String or IO, or any other object responding to
    # `<<`).
    #
    # Calling this method a second or subsequent time for the same HTTPResponse
    # object will return the value already read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.read_body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.read_body.object_id   # 538149362
    #       p res.read_body.object_id   # 538149362
    #     }
    #
    #     # using iterator
    #     http.request_get('/index.html') {|res|
    #       res.read_body do |segment|
    #         print segment
    #       end
    #     }
    #
    def read_body: () -> String
                 | (_Dest dest) -> String
                 | () { (String) -> void } -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body()
    # -->
    # Returns the full entity body.
    #
    # Calling this method a second or subsequent time will return the string already
    # read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.body.object_id   # 538149362
    #       p res.body.object_id   # 538149362
    #     }
    #
    def body: () -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body=(value)
    # -->
    # Because it may be necessary to modify the body, Eg, decompression this method
    # facilitates that.
    #
    def body=: (untyped value) -> void

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - entity()
    # -->
    #
    alias entity body
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  #
  class HTTPUnknownResponse < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  class HTTPInformation < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  class HTTPSuccess < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  class HTTPRedirection < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPRetriableError
  end

  class HTTPClientError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: untyped
  end

  class HTTPServerError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPFatalError
  end

  class HTTPContinue < HTTPInformation
    HAS_BODY: bool
  end

  class HTTPSwitchProtocol < HTTPInformation
    HAS_BODY: bool
  end

  class HTTPProcessing < HTTPInformation
    HAS_BODY: bool
  end

  class HTTPEarlyHints < HTTPInformation
    HAS_BODY: bool
  end

  class HTTPOK < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPCreated < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPAccepted < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPNonAuthoritativeInformation < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPNoContent < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPResetContent < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPPartialContent < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPMultiStatus < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPAlreadyReported < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPIMUsed < HTTPSuccess
    HAS_BODY: bool
  end

  class HTTPMultipleChoices < HTTPRedirection
    HAS_BODY: bool
  end

  HTTPMultipleChoice: HTTPMultipleChoices

  class HTTPMovedPermanently < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPFound < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPSeeOther < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPNotModified < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPUseProxy < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # 306 Switch Proxy - no longer unused
  #
  class HTTPTemporaryRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPPermanentRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  class HTTPBadRequest < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPUnauthorized < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPPaymentRequired < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPForbidden < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPNotFound < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPMethodNotAllowed < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPNotAcceptable < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPProxyAuthenticationRequired < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPRequestTimeout < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPConflict < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPGone < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPLengthRequired < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPPreconditionFailed < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPPayloadTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPURITooLong < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPUnsupportedMediaType < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPRangeNotSatisfiable < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPExpectationFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # 418 I'm a teapot - RFC 2324; a joke RFC 420 Enhance Your Calm - Twitter
  #
  class HTTPMisdirectedRequest < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPUnprocessableEntity < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPLocked < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPFailedDependency < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # 425 Unordered Collection - existed only in draft
  #
  class HTTPUpgradeRequired < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPPreconditionRequired < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPTooManyRequests < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPRequestHeaderFieldsTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  class HTTPUnavailableForLegalReasons < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # 444 No Response - Nginx 449 Retry With - Microsoft 450 Blocked by Windows
  # Parental Controls - Microsoft 499 Client Closed Request - Nginx
  #
  class HTTPInternalServerError < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPNotImplemented < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPBadGateway < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPServiceUnavailable < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPGatewayTimeout < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPVersionNotSupported < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPVariantAlsoNegotiates < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPInsufficientStorage < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPLoopDetected < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # 509 Bandwidth Limit Exceeded - Apache bw/limited extension
  #
  class HTTPNotExtended < HTTPServerError
    HAS_BODY: bool
  end

  class HTTPNetworkAuthenticationRequired < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # HTTP response class.
  #
  # This class wraps together the response header and the response body (the
  # entity requested).
  #
  # It mixes in the HTTPHeader module, which provides access to response header
  # values both via hash-like methods and via individual readers.
  #
  # Note that each possible HTTP response code defines its own HTTPResponse
  # subclass. All classes are defined under the Net module. Indentation indicates
  # inheritance.  For a list of the classes see Net::HTTP.
  #
  # Correspondence `HTTP code => class` is stored in CODE_TO_OBJ constant:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound
  #
  class HTTPResponse
    CODE_CLASS_TO_OBJ: Hash[untyped, untyped]

    CODE_TO_OBJ: Hash[untyped, untyped]
  end

  HTTP::STATUS_CODES: Hash[Integer, String]

  # <!-- rdoc-file=lib/net/http/exceptions.rb -->
  # Net::HTTP exception class. You cannot use Net::HTTPExceptions directly;
  # instead, you must use its subclasses.
  #
  module HTTPExceptions
    def initialize: (untyped msg, untyped res) -> untyped

    attr_reader response: untyped

    alias data response
  end

  class HTTPError < ProtocolError
    include Net::HTTPExceptions
  end

  class HTTPRetriableError < ProtoRetriableError
    include Net::HTTPExceptions
  end

  class HTTPServerException < ProtoServerError
    # We cannot use the name "HTTPServerError", it is the name of the response.
    include Net::HTTPExceptions
  end

  class HTTPFatalError < ProtoFatalError
    include Net::HTTPExceptions
  end
end

%a{annotate:rdoc:skip}
class Time
  interface _TimeLike
    def year: () -> Integer

    def mon: () -> Integer

    def day: () -> Integer
  end

  # <!--
  #   rdoc-file=lib/time.rb
  #   - zone_offset(zone, year=self.now.year)
  # -->
  # Return the number of seconds the specified time zone differs from UTC.
  #
  # Numeric time zones that include minutes, such as `-10:00` or `+1330` will
  # work, as will simpler hour-only time zones like `-10` or `+13`.
  #
  # Textual time zones listed in ZoneOffset are also supported.
  #
  # If the time zone does not match any of the above, `zone_offset` will check if
  # the local time zone (both with and without potential Daylight Saving Time
  # changes being in effect) matches `zone`. Specifying a value for `year` will
  # change the year used to find the local time zone.
  #
  # If `zone_offset` is unable to determine the offset, nil will be returned.
  #
  #     require 'time'
  #
  #     Time.zone_offset("EST") #=> -18000
  #
  # You must require 'time' to use this method.
  #
  def self.zone_offset: (String zone, ?Integer year) -> Integer

  # <!--
  #   rdoc-file=lib/time.rb
  #   - parse(date, now=self.now) { |year| ... }
  # -->
  # Takes a string representation of a Time and attempts to parse it using a
  # heuristic.
  #
  # This method **does not** function as a validator.  If the input string does
  # not match valid formats strictly, you may get a cryptic result.  Should
  # consider to use `Time.strptime` instead of this method as possible.
  #
  #     require 'time'
  #
  #     Time.parse("2010-10-31") #=> 2010-10-31 00:00:00 -0500
  #
  # Any missing pieces of the date are inferred based on the current date.
  #
  #     require 'time'
  #
  #     # assuming the current date is "2011-10-31"
  #     Time.parse("12:00") #=> 2011-10-31 12:00:00 -0500
  #
  # We can change the date used to infer our missing elements by passing a second
  # object that responds to #mon, #day and #year, such as Date, Time or DateTime.
  # We can also use our own object.
  #
  #     require 'time'
  #
  #     class MyDate
  #       attr_reader :mon, :day, :year
  #
  #       def initialize(mon, day, year)
  #         @mon, @day, @year = mon, day, year
  #       end
  #     end
  #
  #     d  = Date.parse("2010-10-28")
  #     t  = Time.parse("2010-10-29")
  #     dt = DateTime.parse("2010-10-30")
  #     md = MyDate.new(10,31,2010)
  #
  #     Time.parse("12:00", d)  #=> 2010-10-28 12:00:00 -0500
  #     Time.parse("12:00", t)  #=> 2010-10-29 12:00:00 -0500
  #     Time.parse("12:00", dt) #=> 2010-10-30 12:00:00 -0500
  #     Time.parse("12:00", md) #=> 2010-10-31 12:00:00 -0500
  #
  # If a block is given, the year described in `date` is converted by the block.
  # This is specifically designed for handling two digit years. For example, if
  # you wanted to treat all two digit years prior to 70 as the year 2000+ you
  # could write this:
  #
  #     require 'time'
  #
  #     Time.parse("01-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
  #     #=> 2001-10-31 00:00:00 -0500
  #     Time.parse("70-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
  #     #=> 1970-10-31 00:00:00 -0500
  #
  # If the upper components of the given time are broken or missing, they are
  # supplied with those of `now`.  For the lower components, the minimum values (1
  # or 0) are assumed if broken or missing.  For example:
  #
  #     require 'time'
  #
  #     # Suppose it is "Thu Nov 29 14:33:20 2001" now and
  #     # your time zone is EST which is GMT-5.
  #     now = Time.parse("Thu Nov 29 14:33:20 2001")
  #     Time.parse("16:30", now)     #=> 2001-11-29 16:30:00 -0500
  #     Time.parse("7/23", now)      #=> 2001-07-23 00:00:00 -0500
  #     Time.parse("Aug 31", now)    #=> 2001-08-31 00:00:00 -0500
  #     Time.parse("Aug 2000", now)  #=> 2000-08-01 00:00:00 -0500
  #
  # Since there are numerous conflicts among locally defined time zone
  # abbreviations all over the world, this method is not intended to understand
  # all of them.  For example, the abbreviation "CST" is used variously as:
  #
  #     -06:00 in America/Chicago,
  #     -05:00 in America/Havana,
  #     +08:00 in Asia/Harbin,
  #     +09:30 in Australia/Darwin,
  #     +10:30 in Australia/Adelaide,
  #     etc.
  #
  # Based on this fact, this method only understands the time zone abbreviations
  # described in RFC 822 and the system time zone, in the order named. (i.e. a
  # definition in RFC 822 overrides the system time zone definition.)  The system
  # time zone is taken from `Time.local(year, 1, 1).zone` and `Time.local(year, 7,
  # 1).zone`. If the extracted time zone abbreviation does not match any of them,
  # it is ignored and the given time is regarded as a local time.
  #
  # ArgumentError is raised if Date._parse cannot extract information from `date`
  # or if the Time class cannot represent specified date.
  #
  # This method can be used as a fail-safe for other parsing methods as:
  #
  #     Time.rfc2822(date) rescue Time.parse(date)
  #     Time.httpdate(date) rescue Time.parse(date)
  #     Time.xmlschema(date) rescue Time.parse(date)
  #
  # A failure of Time.parse should be checked, though.
  #
  # You must require 'time' to use this method.
  #
  def self.parse: (String date, ?_TimeLike now) ?{ (Integer) -> Integer } -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - strptime(date, format, now=self.now) { |year| ... }
  # -->
  # Works similar to `parse` except that instead of using a heuristic to detect
  # the format of the input string, you provide a second argument that describes
  # the format of the string.
  #
  # If a block is given, the year described in `date` is converted by the block.
  # For example:
  #
  #     Time.strptime(...) {|y| y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}
  #
  # Below is a list of the formatting options:
  #
  # %a
  # :   The abbreviated weekday name ("Sun")
  # %A
  # :   The  full  weekday  name ("Sunday")
  # %b
  # :   The abbreviated month name ("Jan")
  # %B
  # :   The  full  month  name ("January")
  # %c
  # :   The preferred local date and time representation
  # %C
  # :   Century (20 in 2009)
  # %d
  # :   Day of the month (01..31)
  # %D
  # :   Date (%m/%d/%y)
  # %e
  # :   Day of the month, blank-padded ( 1..31)
  # %F
  # :   Equivalent to %Y-%m-%d (the ISO 8601 date format)
  # %g
  # :   The last two digits of the commercial year
  # %G
  # :   The week-based year according to ISO-8601 (week 1 starts on Monday and
  #     includes January 4)
  # %h
  # :   Equivalent to %b
  # %H
  # :   Hour of the day, 24-hour clock (00..23)
  # %I
  # :   Hour of the day, 12-hour clock (01..12)
  # %j
  # :   Day of the year (001..366)
  # %k
  # :   hour, 24-hour clock, blank-padded ( 0..23)
  # %l
  # :   hour, 12-hour clock, blank-padded ( 0..12)
  # %L
  # :   Millisecond of the second (000..999)
  # %m
  # :   Month of the year (01..12)
  # %M
  # :   Minute of the hour (00..59)
  # %n
  # :   Newline (n)
  # %N
  # :   Fractional seconds digits
  # %p
  # :   Meridian indicator ("AM" or "PM")
  # %P
  # :   Meridian indicator ("am" or "pm")
  # %r
  # :   time, 12-hour (same as %I:%M:%S %p)
  # %R
  # :   time, 24-hour (%H:%M)
  # %s
  # :   Number of seconds since 1970-01-01 00:00:00 UTC.
  # %S
  # :   Second of the minute (00..60)
  # %t
  # :   Tab character (t)
  # %T
  # :   time, 24-hour (%H:%M:%S)
  # %u
  # :   Day of the week as a decimal, Monday being 1. (1..7)
  # %U
  # :   Week number of the current year, starting with the first Sunday as the
  #     first day of the first week (00..53)
  # %v
  # :   VMS date (%e-%b-%Y)
  # %V
  # :   Week number of year according to ISO 8601 (01..53)
  # %W
  # :   Week  number  of the current year, starting with the first Monday as the
  #     first day of the first week (00..53)
  # %w
  # :   Day of the week (Sunday is 0, 0..6)
  # %x
  # :   Preferred representation for the date alone, no time
  # %X
  # :   Preferred representation for the time alone, no date
  # %y
  # :   Year without a century (00..99)
  # %Y
  # :   Year which may include century, if provided
  # %z
  # :   Time zone as  hour offset from UTC (e.g. +0900)
  # %Z
  # :   Time zone name
  # %%
  # :   Literal "%" character
  # %+
  # :   date(1) (%a %b %e %H:%M:%S %Z %Y)
  #
  #
  #     require 'time'
  #
  #     Time.strptime("2000-10-31", "%Y-%m-%d") #=> 2000-10-31 00:00:00 -0500
  #
  # You must require 'time' to use this method.
  #
  def self.strptime: (String date, String format, ?_TimeLike now) ?{ (Integer) -> Integer } -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc2822(date)
  # -->
  # Parses `date` as date-time defined by RFC 2822 and converts it to a Time
  # object.  The format is identical to the date format defined by RFC 822 and
  # updated by RFC 1123.
  #
  # ArgumentError is raised if `date` is not compliant with RFC 2822 or if the
  # Time class cannot represent specified date.
  #
  # See #rfc2822 for more information on this format.
  #
  #     require 'time'
  #
  #     Time.rfc2822("Wed, 05 Oct 2011 22:26:12 -0400")
  #     #=> 2010-10-05 22:26:12 -0400
  #
  # You must require 'time' to use this method.
  #
  def self.rfc2822: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc822(date)
  # -->
  #
  alias self.rfc822 self.rfc2822

  # <!--
  #   rdoc-file=lib/time.rb
  #   - httpdate(date)
  # -->
  # Parses `date` as an HTTP-date defined by RFC 2616 and converts it to a Time
  # object.
  #
  # ArgumentError is raised if `date` is not compliant with RFC 2616 or if the
  # Time class cannot represent specified date.
  #
  # See #httpdate for more information on this format.
  #
  #     require 'time'
  #
  #     Time.httpdate("Thu, 06 Oct 2011 02:26:12 GMT")
  #     #=> 2011-10-06 02:26:12 UTC
  #
  # You must require 'time' to use this method.
  #
  def self.httpdate: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - xmlschema(time)
  # -->
  # Parses `time` as a dateTime defined by the XML Schema and converts it to a
  # Time object.  The format is a restricted version of the format defined by ISO
  # 8601.
  #
  # ArgumentError is raised if `time` is not compliant with the format or if the
  # Time class cannot represent the specified time.
  #
  # See #xmlschema for more information on this format.
  #
  #     require 'time'
  #
  #     Time.xmlschema("2011-10-05T22:26:12-04:00")
  #     #=> 2011-10-05 22:26:12-04:00
  #
  # You must require 'time' to use this method.
  #
  def self.xmlschema: (String date) -> Time

  # <!--
  #   rdoc-file=lib/time.rb
  #   - iso8601(time)
  # -->
  #
  alias self.iso8601 self.xmlschema

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc2822()
  # -->
  # Returns a string which represents the time as date-time defined by RFC 2822:
  #
  #     day-of-week, DD month-name CCYY hh:mm:ss zone
  #
  # where zone is [+-]hhmm.
  #
  # If `self` is a UTC time, -0000 is used as zone.
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.rfc2822  # => "Wed, 05 Oct 2011 22:26:12 -0400"
  #
  # You must require 'time' to use this method.
  #
  def rfc2822: () -> String

  # <!--
  #   rdoc-file=lib/time.rb
  #   - rfc822()
  # -->
  #
  alias rfc822 rfc2822

  # <!--
  #   rdoc-file=lib/time.rb
  #   - httpdate()
  # -->
  # Returns a string which represents the time as RFC 1123 date of HTTP-date
  # defined by RFC 2616:
  #
  #     day-of-week, DD month-name CCYY hh:mm:ss GMT
  #
  # Note that the result is always UTC (GMT).
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.httpdate # => "Thu, 06 Oct 2011 02:26:12 GMT"
  #
  # You must require 'time' to use this method.
  #
  def httpdate: () -> String

  # <!--
  #   rdoc-file=lib/time.rb
  #   - xmlschema(fraction_digits=0)
  # -->
  # Returns a string which represents the time as a dateTime defined by XML
  # Schema:
  #
  #     CCYY-MM-DDThh:mm:ssTZD
  #     CCYY-MM-DDThh:mm:ss.sssTZD
  #
  # where TZD is Z or [+-]hh:mm.
  #
  # If self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.
  #
  # `fractional_digits` specifies a number of digits to use for fractional
  # seconds.  Its default value is 0.
  #
  #     require 'time'
  #
  #     t = Time.now
  #     t.iso8601  # => "2011-10-05T22:26:12-04:00"
  #
  # You must require 'time' to use this method.
  #
  def xmlschema: (?Integer fraction_digits) -> String

  # <!--
  #   rdoc-file=lib/time.rb
  #   - iso8601(fraction_digits=0)
  # -->
  #
  alias iso8601 xmlschema
end

# <!-- rdoc-file=ext/openssl/ossl.c -->
# OpenSSL provides SSL, TLS and general purpose cryptography.  It wraps the
# [OpenSSL](https://www.openssl.org/) library.
#
# # Examples
#
# All examples assume you have loaded OpenSSL with:
#
#     require 'openssl'
#
# These examples build atop each other.  For example the key created in the next
# is used in throughout these examples.
#
# ## Keys
#
# ### Creating a Key
#
# This example creates a 2048 bit RSA keypair and writes it to the current
# directory.
#
#     key = OpenSSL::PKey::RSA.new 2048
#
#     open 'private_key.pem', 'w' do |io| io.write key.to_pem end
#     open 'public_key.pem', 'w' do |io| io.write key.public_key.to_pem end
#
# ### Exporting a Key
#
# Keys saved to disk without encryption are not secure as anyone who gets ahold
# of the key may use it unless it is encrypted.  In order to securely export a
# key you may export it with a pass phrase.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     pass_phrase = 'my secure pass phrase goes here'
#
#     key_secure = key.export cipher, pass_phrase
#
#     open 'private.secure.pem', 'w' do |io|
#       io.write key_secure
#     end
#
# OpenSSL::Cipher.ciphers returns a list of available ciphers.
#
# ### Loading a Key
#
# A key can also be loaded from a file.
#
#     key2 = OpenSSL::PKey.read File.read 'private_key.pem'
#     key2.public? # => true
#     key2.private? # => true
#
# or
#
#     key3 = OpenSSL::PKey.read File.read 'public_key.pem'
#     key3.public? # => true
#     key3.private? # => false
#
# ### Loading an Encrypted Key
#
# OpenSSL will prompt you for your pass phrase when loading an encrypted key. If
# you will not be able to type in the pass phrase you may provide it when
# loading the key:
#
#     key4_pem = File.read 'private.secure.pem'
#     pass_phrase = 'my secure pass phrase goes here'
#     key4 = OpenSSL::PKey.read key4_pem, pass_phrase
#
# ## RSA Encryption
#
# RSA provides encryption and decryption using the public and private keys. You
# can use a variety of padding methods depending upon the intended use of
# encrypted data.
#
# ### Encryption & Decryption
#
# Asymmetric public/private key encryption is slow and victim to attack in cases
# where it is used without padding or directly to encrypt larger chunks of data.
# Typical use cases for RSA encryption involve "wrapping" a symmetric key with
# the public key of the recipient who would "unwrap" that symmetric key again
# using their private key. The following illustrates a simplified example of
# such a key transport scheme. It shouldn't be used in practice, though,
# standardized protocols should always be preferred.
#
#     wrapped_key = key.public_encrypt key
#
# A symmetric key encrypted with the public key can only be decrypted with the
# corresponding private key of the recipient.
#
#     original_key = key.private_decrypt wrapped_key
#
# By default PKCS#1 padding will be used, but it is also possible to use other
# forms of padding, see PKey::RSA for further details.
#
# ### Signatures
#
# Using "private_encrypt" to encrypt some data with the private key is
# equivalent to applying a digital signature to the data. A verifying party may
# validate the signature by comparing the result of decrypting the signature
# with "public_decrypt" to the original data. However, OpenSSL::PKey already has
# methods "sign" and "verify" that handle digital signatures in a standardized
# way - "private_encrypt" and "public_decrypt" shouldn't be used in practice.
#
# To sign a document, a cryptographically secure hash of the document is
# computed first, which is then signed using the private key.
#
#     signature = key.sign 'SHA256', document
#
# To validate the signature, again a hash of the document is computed and the
# signature is decrypted using the public key. The result is then compared to
# the hash just computed, if they are equal the signature was valid.
#
#     if key.verify 'SHA256', signature, document
#       puts 'Valid'
#     else
#       puts 'Invalid'
#     end
#
# ## PBKDF2 Password-based Encryption
#
# If supported by the underlying OpenSSL version used, Password-based Encryption
# should use the features of PKCS5. If not supported or if required by legacy
# applications, the older, less secure methods specified in RFC 2898 are also
# supported (see below).
#
# PKCS5 supports PBKDF2 as it was specified in PKCS#5
# [v2.0](http://www.rsa.com/rsalabs/node.asp?id=2127). It still uses a password,
# a salt, and additionally a number of iterations that will slow the key
# derivation process down. The slower this is, the more work it requires being
# able to brute-force the resulting key.
#
# ### Encryption
#
# The strategy is to first instantiate a Cipher for encryption, and then to
# generate a random IV plus a key derived from the password using PBKDF2. PKCS
# #5 v2.0 recommends at least 8 bytes for the salt, the number of iterations
# largely depends on the hardware being used.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     cipher.encrypt
#     iv = cipher.random_iv
#
#     pwd = 'some hopefully not to easily guessable password'
#     salt = OpenSSL::Random.random_bytes 16
#     iter = 20000
#     key_len = cipher.key_len
#     digest = OpenSSL::Digest.new('SHA256')
#
#     key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
#     cipher.key = key
#
#     Now encrypt the data:
#
#     encrypted = cipher.update document
#     encrypted << cipher.final
#
# ### Decryption
#
# Use the same steps as before to derive the symmetric AES key, this time
# setting the Cipher up for decryption.
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#     cipher.decrypt
#     cipher.iv = iv # the one generated with #random_iv
#
#     pwd = 'some hopefully not to easily guessable password'
#     salt = ... # the one generated above
#     iter = 20000
#     key_len = cipher.key_len
#     digest = OpenSSL::Digest.new('SHA256')
#
#     key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
#     cipher.key = key
#
#     Now decrypt the data:
#
#     decrypted = cipher.update encrypted
#     decrypted << cipher.final
#
# ## PKCS #5 Password-based Encryption
#
# PKCS #5 is a password-based encryption standard documented at
# [RFC2898](http://www.ietf.org/rfc/rfc2898.txt).  It allows a short password or
# passphrase to be used to create a secure encryption key. If possible, PBKDF2
# as described above should be used if the circumstances allow it.
#
# PKCS #5 uses a Cipher, a pass phrase and a salt to generate an encryption key.
#
#     pass_phrase = 'my secure pass phrase goes here'
#     salt = '8 octets'
#
# ### Encryption
#
# First set up the cipher for encryption
#
#     encryptor = OpenSSL::Cipher.new 'aes-256-cbc'
#     encryptor.encrypt
#     encryptor.pkcs5_keyivgen pass_phrase, salt
#
# Then pass the data you want to encrypt through
#
#     encrypted = encryptor.update 'top secret document'
#     encrypted << encryptor.final
#
# ### Decryption
#
# Use a new Cipher instance set up for decryption
#
#     decryptor = OpenSSL::Cipher.new 'aes-256-cbc'
#     decryptor.decrypt
#     decryptor.pkcs5_keyivgen pass_phrase, salt
#
# Then pass the data you want to decrypt through
#
#     plain = decryptor.update encrypted
#     plain << decryptor.final
#
# ## X509 Certificates
#
# ### Creating a Certificate
#
# This example creates a self-signed certificate using an RSA key and a SHA1
# signature.
#
#     key = OpenSSL::PKey::RSA.new 2048
#     name = OpenSSL::X509::Name.parse '/CN=nobody/DC=example'
#
#     cert = OpenSSL::X509::Certificate.new
#     cert.version = 2
#     cert.serial = 0
#     cert.not_before = Time.now
#     cert.not_after = Time.now + 3600
#
#     cert.public_key = key.public_key
#     cert.subject = name
#
# ### Certificate Extensions
#
# You can add extensions to the certificate with OpenSSL::SSL::ExtensionFactory
# to indicate the purpose of the certificate.
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new nil, cert
#
#     cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:FALSE', true)
#
#     cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')
#
#     cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
# The list of supported extensions (and in some cases their possible values) can
# be derived from the "objects.h" file in the OpenSSL source code.
#
# ### Signing a Certificate
#
# To sign a certificate set the issuer and use OpenSSL::X509::Certificate#sign
# with a digest algorithm.  This creates a self-signed cert because we're using
# the same name and key to sign the certificate as was used to create the
# certificate.
#
#     cert.issuer = name
#     cert.sign key, OpenSSL::Digest.new('SHA1')
#
#     open 'certificate.pem', 'w' do |io| io.write cert.to_pem end
#
# ### Loading a Certificate
#
# Like a key, a cert can also be loaded from a file.
#
#     cert2 = OpenSSL::X509::Certificate.new File.read 'certificate.pem'
#
# ### Verifying a Certificate
#
# Certificate#verify will return true when a certificate was signed with the
# given public key.
#
#     raise 'certificate can not be verified' unless cert2.verify key
#
# ## Certificate Authority
#
# A certificate authority (CA) is a trusted third party that allows you to
# verify the ownership of unknown certificates.  The CA issues key signatures
# that indicate it trusts the user of that key.  A user encountering the key can
# verify the signature by using the CA's public key.
#
# ### CA Key
#
# CA keys are valuable, so we encrypt and save it to disk and make sure it is
# not readable by other users.
#
#     ca_key = OpenSSL::PKey::RSA.new 2048
#     pass_phrase = 'my secure pass phrase goes here'
#
#     cipher = OpenSSL::Cipher.new 'aes-256-cbc'
#
#     open 'ca_key.pem', 'w', 0400 do |io|
#       io.write ca_key.export(cipher, pass_phrase)
#     end
#
# ### CA Certificate
#
# A CA certificate is created the same way we created a certificate above, but
# with different extensions.
#
#     ca_name = OpenSSL::X509::Name.parse '/CN=ca/DC=example'
#
#     ca_cert = OpenSSL::X509::Certificate.new
#     ca_cert.serial = 0
#     ca_cert.version = 2
#     ca_cert.not_before = Time.now
#     ca_cert.not_after = Time.now + 86400
#
#     ca_cert.public_key = ca_key.public_key
#     ca_cert.subject = ca_name
#     ca_cert.issuer = ca_name
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new
#     extension_factory.subject_certificate = ca_cert
#     extension_factory.issuer_certificate = ca_cert
#
#     ca_cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
# This extension indicates the CA's key may be used as a CA.
#
#     ca_cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:TRUE', true)
#
# This extension indicates the CA's key may be used to verify signatures on both
# certificates and certificate revocations.
#
#     ca_cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'cRLSign,keyCertSign', true)
#
# Root CA certificates are self-signed.
#
#     ca_cert.sign ca_key, OpenSSL::Digest.new('SHA1')
#
# The CA certificate is saved to disk so it may be distributed to all the users
# of the keys this CA will sign.
#
#     open 'ca_cert.pem', 'w' do |io|
#       io.write ca_cert.to_pem
#     end
#
# ### Certificate Signing Request
#
# The CA signs keys through a Certificate Signing Request (CSR).  The CSR
# contains the information necessary to identify the key.
#
#     csr = OpenSSL::X509::Request.new
#     csr.version = 0
#     csr.subject = name
#     csr.public_key = key.public_key
#     csr.sign key, OpenSSL::Digest.new('SHA1')
#
# A CSR is saved to disk and sent to the CA for signing.
#
#     open 'csr.pem', 'w' do |io|
#       io.write csr.to_pem
#     end
#
# ### Creating a Certificate from a CSR
#
# Upon receiving a CSR the CA will verify it before signing it.  A minimal
# verification would be to check the CSR's signature.
#
#     csr = OpenSSL::X509::Request.new File.read 'csr.pem'
#
#     raise 'CSR can not be verified' unless csr.verify csr.public_key
#
# After verification a certificate is created, marked for various usages, signed
# with the CA key and returned to the requester.
#
#     csr_cert = OpenSSL::X509::Certificate.new
#     csr_cert.serial = 0
#     csr_cert.version = 2
#     csr_cert.not_before = Time.now
#     csr_cert.not_after = Time.now + 600
#
#     csr_cert.subject = csr.subject
#     csr_cert.public_key = csr.public_key
#     csr_cert.issuer = ca_cert.subject
#
#     extension_factory = OpenSSL::X509::ExtensionFactory.new
#     extension_factory.subject_certificate = csr_cert
#     extension_factory.issuer_certificate = ca_cert
#
#     csr_cert.add_extension \
#       extension_factory.create_extension('basicConstraints', 'CA:FALSE')
#
#     csr_cert.add_extension \
#       extension_factory.create_extension(
#         'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')
#
#     csr_cert.add_extension \
#       extension_factory.create_extension('subjectKeyIdentifier', 'hash')
#
#     csr_cert.sign ca_key, OpenSSL::Digest.new('SHA1')
#
#     open 'csr_cert.pem', 'w' do |io|
#       io.write csr_cert.to_pem
#     end
#
# ## SSL and TLS Connections
#
# Using our created key and certificate we can create an SSL or TLS connection.
# An SSLContext is used to set up an SSL session.
#
#     context = OpenSSL::SSL::SSLContext.new
#
# ### SSL Server
#
# An SSL server requires the certificate and private key to communicate securely
# with its clients:
#
#     context.cert = cert
#     context.key = key
#
# Then create an SSLServer with a TCP server socket and the context.  Use the
# SSLServer like an ordinary TCP server.
#
#     require 'socket'
#
#     tcp_server = TCPServer.new 5000
#     ssl_server = OpenSSL::SSL::SSLServer.new tcp_server, context
#
#     loop do
#       ssl_connection = ssl_server.accept
#
#       data = ssl_connection.gets
#
#       response = "I got #{data.dump}"
#       puts response
#
#       ssl_connection.puts "I got #{data.dump}"
#       ssl_connection.close
#     end
#
# ### SSL client
#
# An SSL client is created with a TCP socket and the context. SSLSocket#connect
# must be called to initiate the SSL handshake and start encryption.  A key and
# certificate are not required for the client socket.
#
# Note that SSLSocket#close doesn't close the underlying socket by default. Set
# SSLSocket#sync_close to true if you want.
#
#     require 'socket'
#
#     tcp_socket = TCPSocket.new 'localhost', 5000
#     ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
#     ssl_client.sync_close = true
#     ssl_client.connect
#
#     ssl_client.puts "hello server!"
#     puts ssl_client.gets
#
#     ssl_client.close # shutdown the TLS connection and close tcp_socket
#
# ### Peer Verification
#
# An unverified SSL connection does not provide much security.  For enhanced
# security the client or server can verify the certificate of its peer.
#
# The client can be modified to verify the server's certificate against the
# certificate authority's certificate:
#
#     context.ca_file = 'ca_cert.pem'
#     context.verify_mode = OpenSSL::SSL::VERIFY_PEER
#
#     require 'socket'
#
#     tcp_socket = TCPSocket.new 'localhost', 5000
#     ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
#     ssl_client.connect
#
#     ssl_client.puts "hello server!"
#     puts ssl_client.gets
#
# If the server certificate is invalid or `context.ca_file` is not set when
# verifying peers an OpenSSL::SSL::SSLError will be raised.
#
module OpenSSL
  # <!--
  #   rdoc-file=ext/openssl/lib/openssl/digest.rb
  #   - Digest(name)
  # -->
  # Returns a Digest subclass by *name*
  #
  #     require 'openssl'
  #
  #     OpenSSL::Digest("MD5")
  #     # => OpenSSL::Digest::MD5
  #
  #     Digest("Foo")
  #     # => NameError: wrong constant name Foo
  #
  def self.Digest: (String name) -> singleton(Digest)

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.debug -> true | false
  # -->
  #
  def self.debug: () -> bool

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.debug = boolean -> boolean
  # -->
  # Turns on or off debug mode. With debug mode, all errors added to the OpenSSL
  # error queue will be printed to stderr.
  #
  def self.debug=: [U] (boolish) -> U

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.errors -> [String...]
  # -->
  # See any remaining errors held in queue.
  #
  # Any errors you see here are probably due to a bug in Ruby's OpenSSL
  # implementation.
  #
  def self.errors: () -> Array[String]

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fips_mode -> true | false
  # -->
  #
  def self.fips_mode: () -> bool

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fips_mode = boolean -> boolean
  # -->
  # Turns FIPS mode on or off. Turning on FIPS mode will obviously only have an
  # effect for FIPS-capable installations of the OpenSSL library. Trying to do so
  # otherwise will result in an error.
  #
  # ### Examples
  #     OpenSSL.fips_mode = true   # turn FIPS mode on
  #     OpenSSL.fips_mode = false  # and off again
  #
  def self.fips_mode=: [U] (boolish) -> U

  # <!--
  #   rdoc-file=ext/openssl/ossl.c
  #   - OpenSSL.fixed_length_secure_compare(string, string) -> boolean
  # -->
  # Constant time memory comparison for fixed length strings, such as results of
  # HMAC calculations.
  #
  # Returns `true` if the strings are identical, `false` if they are of the same
  # length but not identical. If the length is different, `ArgumentError` is
  # raised.
  #
  def self.fixed_length_secure_compare: (String, String) -> bool

  # <!--
  #   rdoc-file=ext/openssl/lib/openssl.rb
  #   - OpenSSL.secure_compare(string, string) -> boolean
  # -->
  # Constant time memory comparison. Inputs are hashed using SHA-256 to mask the
  # length of the secret. Returns `true` if the strings are identical, `false`
  # otherwise.
  #
  def self.secure_compare: (String a, String b) -> bool

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Boolean indicating whether OpenSSL is FIPS-capable or not
  #
  OPENSSL_FIPS: bool

  OPENSSL_LIBRARY_VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Version of OpenSSL the ruby OpenSSL extension was built with
  #
  OPENSSL_VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Version number of OpenSSL the ruby OpenSSL extension was built with (base 16)
  #
  OPENSSL_VERSION_NUMBER: Integer

  VERSION: String

  # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
  # Abstract Syntax Notation One (or ASN.1) is a notation syntax to describe data
  # structures and is defined in ITU-T X.680. ASN.1 itself does not mandate any
  # encoding or parsing rules, but usually ASN.1 data structures are encoded using
  # the Distinguished Encoding Rules (DER) or less often the Basic Encoding Rules
  # (BER) described in ITU-T X.690. DER and BER encodings are binary
  # Tag-Length-Value (TLV) encodings that are quite concise compared to other
  # popular data description formats such as XML, JSON etc. ASN.1 data structures
  # are very common in cryptographic applications, e.g. X.509 public key
  # certificates or certificate revocation lists (CRLs) are all defined in ASN.1
  # and DER-encoded. ASN.1, DER and BER are the building blocks of applied
  # cryptography. The ASN1 module provides the necessary classes that allow
  # generation of ASN.1 data structures and the methods to encode them using a DER
  # encoding. The decode method allows parsing arbitrary BER-/DER-encoded data to
  # a Ruby object that can then be modified and re-encoded at will.
  #
  # ## ASN.1 class hierarchy
  #
  # The base class representing ASN.1 structures is ASN1Data. ASN1Data offers
  # attributes to read and set the *tag*, the *tag_class* and finally the *value*
  # of a particular ASN.1 item. Upon parsing, any tagged values (implicit or
  # explicit) will be represented by ASN1Data instances because their "real type"
  # can only be determined using out-of-band information from the ASN.1 type
  # declaration. Since this information is normally known when encoding a type,
  # all sub-classes of ASN1Data offer an additional attribute *tagging* that
  # allows to encode a value implicitly (`:IMPLICIT`) or explicitly (`:EXPLICIT`).
  #
  # ### Constructive
  #
  # Constructive is, as its name implies, the base class for all constructed
  # encodings, i.e. those that consist of several values, opposed to "primitive"
  # encodings with just one single value. The value of an Constructive is always
  # an Array.
  #
  # #### ASN1::Set and ASN1::Sequence
  #
  # The most common constructive encodings are SETs and SEQUENCEs, which is why
  # there are two sub-classes of Constructive representing each of them.
  #
  # ### Primitive
  #
  # This is the super class of all primitive values. Primitive itself is not used
  # when parsing ASN.1 data, all values are either instances of a corresponding
  # sub-class of Primitive or they are instances of ASN1Data if the value was
  # tagged implicitly or explicitly. Please cf. Primitive documentation for
  # details on sub-classes and their respective mappings of ASN.1 data types to
  # Ruby objects.
  #
  # ## Possible values for *tagging*
  #
  # When constructing an ASN1Data object the ASN.1 type definition may require
  # certain elements to be either implicitly or explicitly tagged. This can be
  # achieved by setting the *tagging* attribute manually for sub-classes of
  # ASN1Data. Use the symbol `:IMPLICIT` for implicit tagging and `:EXPLICIT` if
  # the element requires explicit tagging.
  #
  # ## Possible values for *tag_class*
  #
  # It is possible to create arbitrary ASN1Data objects that also support a
  # PRIVATE or APPLICATION tag class. Possible values for the *tag_class*
  # attribute are:
  # *   `:UNIVERSAL` (the default for untagged values)
  # *   `:CONTEXT_SPECIFIC` (the default for tagged values)
  # *   `:APPLICATION`
  # *   `:PRIVATE`
  #
  #
  # ## Tag constants
  #
  # There is a constant defined for each universal tag:
  # *   OpenSSL::ASN1::EOC (0)
  # *   OpenSSL::ASN1::BOOLEAN (1)
  # *   OpenSSL::ASN1::INTEGER (2)
  # *   OpenSSL::ASN1::BIT_STRING (3)
  # *   OpenSSL::ASN1::OCTET_STRING (4)
  # *   OpenSSL::ASN1::NULL (5)
  # *   OpenSSL::ASN1::OBJECT (6)
  # *   OpenSSL::ASN1::ENUMERATED (10)
  # *   OpenSSL::ASN1::UTF8STRING (12)
  # *   OpenSSL::ASN1::SEQUENCE (16)
  # *   OpenSSL::ASN1::SET (17)
  # *   OpenSSL::ASN1::NUMERICSTRING (18)
  # *   OpenSSL::ASN1::PRINTABLESTRING (19)
  # *   OpenSSL::ASN1::T61STRING (20)
  # *   OpenSSL::ASN1::VIDEOTEXSTRING (21)
  # *   OpenSSL::ASN1::IA5STRING (22)
  # *   OpenSSL::ASN1::UTCTIME (23)
  # *   OpenSSL::ASN1::GENERALIZEDTIME (24)
  # *   OpenSSL::ASN1::GRAPHICSTRING (25)
  # *   OpenSSL::ASN1::ISO64STRING (26)
  # *   OpenSSL::ASN1::GENERALSTRING (27)
  # *   OpenSSL::ASN1::UNIVERSALSTRING (28)
  # *   OpenSSL::ASN1::BMPSTRING (30)
  #
  #
  # ## UNIVERSAL_TAG_NAME constant
  #
  # An Array that stores the name of a given tag number. These names are the same
  # as the name of the tag constant that is additionally defined, e.g.
  # +[UNIVERSAL_TAG_NAME](2) = "INTEGER"+ and +OpenSSL::ASN1::INTEGER = 2+.
  #
  # ## Example usage
  #
  # ### Decoding and viewing a DER-encoded file
  #     require 'openssl'
  #     require 'pp'
  #     der = File.binread('data.der')
  #     asn1 = OpenSSL::ASN1.decode(der)
  #     pp der
  #
  # ### Creating an ASN.1 structure and DER-encoding it
  #     require 'openssl'
  #     version = OpenSSL::ASN1::Integer.new(1)
  #     # Explicitly 0-tagged implies context-specific tag class
  #     serial = OpenSSL::ASN1::Integer.new(12345, 0, :EXPLICIT, :CONTEXT_SPECIFIC)
  #     name = OpenSSL::ASN1::PrintableString.new('Data 1')
  #     sequence = OpenSSL::ASN1::Sequence.new( [ version, serial, name ] )
  #     der = sequence.to_der
  #
  module ASN1
    type tagging = :IMPLICIT | :EXPLICIT

    type tag_class = :UNIVERSAL | :CONTEXT_SPECIFIC | :APPLICATION | :PRIVATE

    def self.BMPString: (String value, ?bn tag, ?tagging tagging) -> BMPString

    def self.BitString: (String value, ?bn tag, ?tagging tagging) -> BitString

    def self.Boolean: (boolish value, ?bn tag, ?tagging tagging) -> Boolean

    def self.EndOfContent: () -> EndOfContent

    def self.Enumerated: (bn value, ?bn tag, ?tagging tagging) -> Enumerated

    def self.GeneralString: (String value, ?bn tag, ?tagging tagging) -> GeneralString

    def self.GeneralizedTime: (::Time value, ?bn tag, ?tagging tagging) -> GeneralizedTime

    def self.GraphicString: (String value, ?bn tag, ?tagging tagging) -> GraphicString

    def self.IA5String: (String value, ?bn tag, ?tagging tagging) -> IA5String

    def self.ISO64String: (String value, ?bn tag, ?tagging tagging) -> ISO64String

    def self.Integer: (bn value, ?bn tag, ?tagging tagging) -> Integer

    def self.Null: (nil) -> Null

    def self.NumericString: (String value, ?bn tag, ?tagging tagging) -> NumericString

    def self.ObjectId: (String value, ?bn tag, ?tagging tagging) -> ObjectId

    def self.OctetString: (String value, ?bn tag, ?tagging tagging) -> OctetString

    def self.PrintableString: (String value, ?bn tag, ?tagging tagging) -> PrintableString

    def self.Sequence: (Array[ASN1Data] value, ?bn tag, ?tagging tagging) -> Sequence

    def self.Set: (Array[ASN1Data] value, ?bn tag, ?tagging tagging) -> Set

    def self.T61String: (String value, ?bn tag, ?tagging tagging) -> T61String

    def self.UTCTime: (::Time value, ?bn tag, ?tagging tagging) -> UTCTime

    def self.UTF8String: (String value, ?bn tag, ?tagging tagging) -> UTF8String

    def self.UniversalString: (String value, ?bn tag, ?tagging tagging) -> UniversalString

    def self.VideotexString: (String value, ?bn tag, ?tagging tagging) -> VideotexString

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.decode(der) -> ASN1Data
    # -->
    # Decodes a BER- or DER-encoded value and creates an ASN1Data instance. *der*
    # may be a String or any object that features a `.to_der` method transforming it
    # into a BER-/DER-encoded String+
    #
    # ## Example
    #     der = File.binread('asn1data')
    #     asn1 = OpenSSL::ASN1.decode(der)
    #
    def self.decode: (String | _ToDer der) -> ASN1Data

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.decode_all(der) -> Array of ASN1Data
    # -->
    # Similar to #decode with the difference that #decode expects one distinct value
    # represented in *der*. #decode_all on the contrary decodes a sequence of
    # sequential BER/DER values lined up in *der* and returns them as an array.
    #
    # ## Example
    #     ders = File.binread('asn1data_seq')
    #     asn1_ary = OpenSSL::ASN1.decode_all(ders)
    #
    def self.decode_all: (String | _ToDer der) -> Array[ASN1Data]

    # <!--
    #   rdoc-file=ext/openssl/ossl_asn1.c
    #   - OpenSSL::ASN1.traverse(asn1) -> nil
    # -->
    # If a block is given, it prints out each of the elements encountered. Block
    # parameters are (in that order):
    # *   depth: The recursion depth, plus one with each constructed value being
    #     encountered (Integer)
    # *   offset: Current byte offset (Integer)
    # *   header length: Combined length in bytes of the Tag and Length headers.
    #     (Integer)
    # *   length: The overall remaining length of the entire data (Integer)
    # *   constructed: Whether this value is constructed or not (Boolean)
    # *   tag_class: Current tag class (Symbol)
    # *   tag: The current tag number (Integer)
    #
    #
    # ## Example
    #     der = File.binread('asn1data.der')
    #     OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length, constructed, tag_class, tag|
    #       puts "Depth: #{depth} Offset: #{offset} Length: #{length}"
    #       puts "Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class} Constructed: #{constructed}"
    #     end
    #
    def self.traverse: (String | _ToDer der) { (::Integer, ::Integer, ::Integer, ::Integer, bool, tag_class, ::Integer) -> void } -> void

    BIT_STRING: Integer

    BMPSTRING: Integer

    BOOLEAN: Integer

    CHARACTER_STRING: Integer

    EMBEDDED_PDV: Integer

    ENUMERATED: Integer

    EOC: Integer

    EXTERNAL: Integer

    GENERALIZEDTIME: Integer

    GENERALSTRING: Integer

    GRAPHICSTRING: Integer

    IA5STRING: Integer

    INTEGER: Integer

    ISO64STRING: Integer

    NULL: Integer

    NUMERICSTRING: Integer

    OBJECT: Integer

    OBJECT_DESCRIPTOR: Integer

    OCTET_STRING: Integer

    PRINTABLESTRING: Integer

    REAL: Integer

    RELATIVE_OID: Integer

    SEQUENCE: Integer

    SET: Integer

    T61STRING: Integer

    UNIVERSALSTRING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Array storing tag names at the tag's index.
    #
    UNIVERSAL_TAG_NAME: Array[untyped]

    UTCTIME: Integer

    UTF8STRING: Integer

    VIDEOTEXSTRING: Integer

    interface _ToDer
      def to_der: () -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The top-level class representing any ASN.1 object. When parsed by ASN1.decode,
    # tagged values are always represented by an instance of ASN1Data.
    #
    # ## The role of ASN1Data for parsing tagged values
    #
    # When encoding an ASN.1 type it is inherently clear what original type (e.g.
    # INTEGER, OCTET STRING etc.) this value has, regardless of its tagging. But
    # opposed to the time an ASN.1 type is to be encoded, when parsing them it is
    # not possible to deduce the "real type" of tagged values. This is why tagged
    # values are generally parsed into ASN1Data instances, but with a different
    # outcome for implicit and explicit tagging.
    #
    # ### Example of a parsed implicitly tagged value
    #
    # An implicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
    # *   *tag* equal to 1
    # *   *tag_class* equal to `:CONTEXT_SPECIFIC`
    # *   *value* equal to a String that carries the raw encoding of the INTEGER.
    #
    # This implies that a subsequent decoding step is required to completely decode
    # implicitly tagged values.
    #
    # ### Example of a parsed explicitly tagged value
    #
    # An explicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
    # *   *tag* equal to 1
    # *   *tag_class* equal to `:CONTEXT_SPECIFIC`
    # *   *value* equal to an Array with one single element, an instance of
    #     OpenSSL::ASN1::Integer, i.e. the inner element is the non-tagged primitive
    #     value, and the tagging is represented in the outer ASN1Data
    #
    #
    # ## Example - Decoding an implicitly tagged INTEGER
    #     int = OpenSSL::ASN1::Integer.new(1, 0, :IMPLICIT) # implicit 0-tagged
    #     seq = OpenSSL::ASN1::Sequence.new( [int] )
    #     der = seq.to_der
    #     asn1 = OpenSSL::ASN1.decode(der)
    #     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #     #              @indefinite_length=false,
    #     #              @tag=16,
    #     #              @tag_class=:UNIVERSAL,
    #     #              @tagging=nil,
    #     #              @value=
    #     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #     #                   @indefinite_length=false,
    #     #                   @tag=0,
    #     #                   @tag_class=:CONTEXT_SPECIFIC,
    #     #                   @value="\x01">]>
    #     raw_int = asn1.value[0]
    #     # manually rewrite tag and tag class to make it an UNIVERSAL value
    #     raw_int.tag = OpenSSL::ASN1::INTEGER
    #     raw_int.tag_class = :UNIVERSAL
    #     int2 = OpenSSL::ASN1.decode(raw_int)
    #     puts int2.value # => 1
    #
    # ## Example - Decoding an explicitly tagged INTEGER
    #     int = OpenSSL::ASN1::Integer.new(1, 0, :EXPLICIT) # explicit 0-tagged
    #     seq = OpenSSL::ASN1::Sequence.new( [int] )
    #     der = seq.to_der
    #     asn1 = OpenSSL::ASN1.decode(der)
    #     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #     #              @indefinite_length=false,
    #     #              @tag=16,
    #     #              @tag_class=:UNIVERSAL,
    #     #              @tagging=nil,
    #     #              @value=
    #     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #     #                   @indefinite_length=false,
    #     #                   @tag=0,
    #     #                   @tag_class=:CONTEXT_SPECIFIC,
    #     #                   @value=
    #     #                     [#<OpenSSL::ASN1::Integer:0x85bf308
    #     #                        @indefinite_length=false,
    #     #                        @tag=2,
    #     #                        @tag_class=:UNIVERSAL
    #     #                        @tagging=nil,
    #     #                        @value=1>]>]>
    #     int2 = asn1.value[0].value[0]
    #     puts int2.value # => 1
    #
    class ASN1Data
      public

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      def indefinite_length: () -> bool

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      def indefinite_length=: [U] (boolish) -> U

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      alias infinite_length indefinite_length

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Never `nil`. A boolean value indicating whether the encoding uses indefinite
      # length (in the case of parsing) or whether an indefinite length form shall be
      # used (in the encoding case). In DER, every value uses definite length form.
      # But in scenarios where large amounts of data need to be transferred it might
      # be desirable to have some kind of streaming support available. For example,
      # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
      # time. This is possible in BER by setting the length bytes of an encoding to
      # zero and by this indicating that the following value will be sent in chunks.
      # Indefinite length encodings are always constructed. The end of such a stream
      # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
      # SEQUENCEs may use an indefinite length encoding, but also primitive types such
      # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
      # ITU-T X.690).
      #
      alias infinite_length= indefinite_length=

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # An Integer representing the tag number of this ASN1Data. Never `nil`.
      #
      def tag: () -> bn

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # An Integer representing the tag number of this ASN1Data. Never `nil`.
      #
      def tag=: (::Integer) -> ::Integer
              | (BN) -> BN

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # A Symbol representing the tag class of this ASN1Data. Never `nil`. See
      # ASN1Data for possible values.
      #
      def tag_class: () -> tag_class

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # A Symbol representing the tag class of this ASN1Data. Never `nil`. See
      # ASN1Data for possible values.
      #
      def tag_class=: (tag_class) -> tag_class

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # Encodes this ASN1Data into a DER-encoded String value. The result is
      # DER-encoded except for the possibility of indefinite length forms. Indefinite
      # length forms are not allowed in strict DER, so strictly speaking the result of
      # such an encoding would be a BER-encoding.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Carries the value of a ASN.1 type. Please confer Constructive and Primitive
      # for the mappings between ASN.1 data types and Ruby classes.
      #
      def value: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # Carries the value of a ASN.1 type. Please confer Constructive and Primitive
      # for the mappings between ASN.1 data types and Ruby classes.
      #
      def value=: (untyped) -> untyped

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::ASN1Data.new(value, tag, tag_class) => ASN1Data
      # -->
      # *value*: Please have a look at Constructive and Primitive to see how Ruby
      # types are mapped to ASN.1 types and vice versa.
      #
      # *tag*: An Integer indicating the tag number.
      #
      # *tag_class*: A Symbol indicating the tag class. Please cf. ASN1 for possible
      # values.
      #
      # ## Example
      #     asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # => Same as OpenSSL::ASN1::Integer.new(42)
      #     tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly 0-tagged INTEGER
      #
      def initialize: (untyped value, ::Integer tag, tag_class tag_class) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Generic error class for all errors raised in ASN1 and any of the classes
    # defined in it.
    #
    class ASN1Error < OpenSSL::OpenSSLError
    end

    class BMPString < OpenSSL::ASN1::Primitive
    end

    class BitString < OpenSSL::ASN1::Primitive
      public

      def unused_bits: () -> ::Integer

      def unused_bits=: (::Integer) -> ::Integer

      def value: () -> String

      def value=: (String) -> String
    end

    class Boolean < OpenSSL::ASN1::Primitive
      def value: () -> bool

      def value=: [U] (boolish) -> U
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The parent class for all constructed encodings. The *value* attribute of a
    # Constructive is always an Array. Attributes are the same as for ASN1Data, with
    # the addition of *tagging*.
    #
    # ## SET and SEQUENCE
    #
    # Most constructed encodings come in the form of a SET or a SEQUENCE. These
    # encodings are represented by one of the two sub-classes of Constructive:
    # *   OpenSSL::ASN1::Set
    # *   OpenSSL::ASN1::Sequence
    #
    # Please note that tagged sequences and sets are still parsed as instances of
    # ASN1Data. Find further details on tagged values there.
    #
    # ### Example - constructing a SEQUENCE
    #     int = OpenSSL::ASN1::Integer.new(1)
    #     str = OpenSSL::ASN1::PrintableString.new('abc')
    #     sequence = OpenSSL::ASN1::Sequence.new( [ int, str ] )
    #
    # ### Example - constructing a SET
    #     int = OpenSSL::ASN1::Integer.new(1)
    #     str = OpenSSL::ASN1::PrintableString.new('abc')
    #     set = OpenSSL::ASN1::Set.new( [ int, str ] )
    #
    class Constructive < OpenSSL::ASN1::ASN1Data
      include Enumerable[ASN1Data]

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1_ary.each { |asn1| block } => asn1_ary
      # -->
      # Calls the given block once for each element in self, passing that element as
      # parameter *asn1*. If no block is given, an enumerator is returned instead.
      #
      # ## Example
      #     asn1_ary.each do |asn1|
      #       puts asn1
      #     end
      #
      def each: () ?{ (ASN1Data) -> void } -> self

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging: () -> tagging?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging=: (tagging) -> tagging

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # See ASN1Data#to_der for details.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::Primitive.new(value [, tag, tagging, tag_class ]) => Primitive
      # -->
      # *value*: is mandatory.
      #
      # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
      # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
      #
      # *tagging*: may be used as an encoding hint to encode a value either explicitly
      # or implicitly, see ASN1 for possible values.
      #
      # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
      # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
      # used as the default. For possible values please cf. ASN1.
      #
      # ## Example
      #     int = OpenSSL::ASN1::Integer.new(42)
      #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
      #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
      #
      def initialize: (Array[ASN1Data]) -> void
    end

    class EndOfContent < OpenSSL::ASN1::ASN1Data
      public

      def to_der: () -> String

      private

      def initialize: () -> void
    end

    class Enumerated < OpenSSL::ASN1::Primitive
      def value: () -> ::Integer

      def value=: (::Integer) -> ::Integer
    end

    class GeneralString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class GeneralizedTime < OpenSSL::ASN1::Primitive
      def value: () -> Time

      def value=: (Time) -> Time
    end

    class GraphicString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class IA5String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class ISO64String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class Integer < OpenSSL::ASN1::Primitive
      def value: () -> ::Integer

      def value=: (::Integer) -> ::Integer
    end

    class Null < OpenSSL::ASN1::Primitive
      def value: () -> nil

      def value=: (nil) -> nil
    end

    class NumericString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # Represents the primitive object id for OpenSSL::ASN1
    #
    class ObjectId < OpenSSL::ASN1::Primitive
      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::ObjectId.register(object_id, short_name, long_name)
      # -->
      # This adds a new ObjectId to the internal tables. Where *object_id* is the
      # numerical form, *short_name* is the short name, and *long_name* is the long
      # name.
      #
      # Returns `true` if successful. Raises an OpenSSL::ASN1::ASN1Error if it fails.
      #
      def self.register: (String object_id, String short_name, String ong_name) -> bool

      def value: () -> String

      def value=: (String) -> String

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid == other_oid => true or false
      # -->
      # Returns `true` if *other_oid* is the same as *oid*
      #
      def ==: (ObjectId other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.ln -> string
      #   - oid.long_name -> string
      # -->
      # The long name of the ObjectId, as defined in <openssl/objects.h>.
      #
      def ln: () -> String?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # The long name of the ObjectId, as defined in <openssl/objects.h>.
      #
      alias long_name ln

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.oid -> string
      # -->
      # Returns a String representing the Object Identifier in the dot notation, e.g.
      # "1.2.3.4.5"
      #
      def oid: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # The short name of the ObjectId, as defined in <openssl/objects.h>.
      #
      alias short_name sn

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - oid.sn -> string
      #   - oid.short_name -> string
      # -->
      # The short name of the ObjectId, as defined in <openssl/objects.h>.
      #
      def sn: () -> String?
    end

    class OctetString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
    # The parent class for all primitive encodings. Attributes are the same as for
    # ASN1Data, with the addition of *tagging*. Primitive values can never be
    # encoded with indefinite length form, thus it is not possible to set the
    # *indefinite_length* attribute for Primitive and its sub-classes.
    #
    # ## Primitive sub-classes and their mapping to Ruby classes
    # *   OpenSSL::ASN1::EndOfContent    <=> *value* is always `nil`
    # *   OpenSSL::ASN1::Boolean         <=> *value* is `true` or `false`
    # *   OpenSSL::ASN1::Integer         <=> *value* is an OpenSSL::BN
    # *   OpenSSL::ASN1::BitString       <=> *value* is a String
    # *   OpenSSL::ASN1::OctetString     <=> *value* is a String
    # *   OpenSSL::ASN1::Null            <=> *value* is always `nil`
    # *   OpenSSL::ASN1::Object          <=> *value* is a String
    # *   OpenSSL::ASN1::Enumerated      <=> *value* is an OpenSSL::BN
    # *   OpenSSL::ASN1::UTF8String      <=> *value* is a String
    # *   OpenSSL::ASN1::NumericString   <=> *value* is a String
    # *   OpenSSL::ASN1::PrintableString <=> *value* is a String
    # *   OpenSSL::ASN1::T61String       <=> *value* is a String
    # *   OpenSSL::ASN1::VideotexString  <=> *value* is a String
    # *   OpenSSL::ASN1::IA5String       <=> *value* is a String
    # *   OpenSSL::ASN1::UTCTime         <=> *value* is a Time
    # *   OpenSSL::ASN1::GeneralizedTime <=> *value* is a Time
    # *   OpenSSL::ASN1::GraphicString   <=> *value* is a String
    # *   OpenSSL::ASN1::ISO64String     <=> *value* is a String
    # *   OpenSSL::ASN1::GeneralString   <=> *value* is a String
    # *   OpenSSL::ASN1::UniversalString <=> *value* is a String
    # *   OpenSSL::ASN1::BMPString       <=> *value* is a String
    #
    #
    # ## OpenSSL::ASN1::BitString
    #
    # ### Additional attributes
    # *unused_bits*: if the underlying BIT STRING's length is a multiple of 8 then
    # *unused_bits* is 0. Otherwise *unused_bits* indicates the number of bits that
    # are to be ignored in the final octet of the BitString's *value*.
    #
    # ## OpenSSL::ASN1::ObjectId
    #
    # NOTE: While OpenSSL::ASN1::ObjectId.new will allocate a new ObjectId, it is
    # not typically allocated this way, but rather that are received from parsed
    # ASN1 encodings.
    #
    # ### Additional attributes
    # *   *sn*: the short name as defined in <openssl/objects.h>.
    # *   *ln*: the long name as defined in <openssl/objects.h>.
    # *   *oid*: the object identifier as a String, e.g. "1.2.3.4.5"
    # *   *short_name*: alias for *sn*.
    # *   *long_name*: alias for *ln*.
    #
    #
    # ## Examples
    # With the Exception of OpenSSL::ASN1::EndOfContent, each Primitive class
    # constructor takes at least one parameter, the *value*.
    #
    # ### Creating EndOfContent
    #     eoc = OpenSSL::ASN1::EndOfContent.new
    #
    # ### Creating any other Primitive
    #     prim = <class>.new(value) # <class> being one of the sub-classes except EndOfContent
    #     prim_zero_tagged_implicit = <class>.new(value, 0, :IMPLICIT)
    #     prim_zero_tagged_explicit = <class>.new(value, 0, :EXPLICIT)
    #
    class Primitive < OpenSSL::ASN1::ASN1Data
      public

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging: () -> tagging?

      # <!-- rdoc-file=ext/openssl/ossl_asn1.c -->
      # May be used as a hint for encoding a value either implicitly or explicitly by
      # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
      # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
      #
      def tagging=: (tagging) -> tagging

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - asn1.to_der => DER-encoded String
      # -->
      # See ASN1Data#to_der for details.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_asn1.c
      #   - OpenSSL::ASN1::Primitive.new(value [, tag, tagging, tag_class ]) => Primitive
      # -->
      # *value*: is mandatory.
      #
      # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
      # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
      #
      # *tagging*: may be used as an encoding hint to encode a value either explicitly
      # or implicitly, see ASN1 for possible values.
      #
      # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
      # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
      # used as the default. For possible values please cf. ASN1.
      #
      # ## Example
      #     int = OpenSSL::ASN1::Integer.new(42)
      #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
      #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
      #
      def initialize: (untyped value, ?Integer tag, ?tagging tagging) -> void
    end

    class PrintableString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class Sequence < OpenSSL::ASN1::Constructive
      def value: () -> Array[ASN1Data]

      def value=: (Array[ASN1Data]) -> Array[ASN1Data]
    end

    class Set < OpenSSL::ASN1::Constructive
    end

    class T61String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class UTCTime < OpenSSL::ASN1::Primitive
      def value: () -> Time

      def value=: (Time) -> Time
    end

    class UTF8String < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class UniversalString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end

    class VideotexString < OpenSSL::ASN1::Primitive
      def value: () -> String

      def value=: (String) -> String
    end
  end

  type bn = BN | ::Integer

  class BN
    include Comparable

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.generate_prime(bits, [, safe [, add [, rem]]]) => bn
    # -->
    # Generates a random prime number of bit length *bits*. If *safe* is set to
    # `true`, generates a safe prime. If *add* is specified, generates a prime that
    # fulfills condition `p % add = rem`.
    #
    # ### Parameters
    # *   *bits* - integer
    # *   *safe* - boolean
    # *   *add* - BN
    # *   *rem* - BN
    #
    def self.generate_prime: (::Integer bits, ?boolish safe, ?bn add, ?bn rem) -> instance

    def self.pseudo_rand: (*untyped) -> untyped

    def self.pseudo_rand_range: (untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.rand(bits [, fill [, odd]]) -> aBN
    # -->
    # Generates a cryptographically strong pseudo-random number of `bits`.
    #
    # See also the man page BN_rand(3).
    #
    def self.rand: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - BN.rand_range(range) -> aBN
    # -->
    # Generates a cryptographically strong pseudo-random number in the range
    # 0...`range`.
    #
    # See also the man page BN_rand_range(3).
    #
    def self.rand_range: (untyped) -> untyped

    public

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn % bn2 => aBN
    # -->
    #
    def %: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn * bn2 => aBN
    # -->
    #
    def *: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn ** bn2 => aBN
    # -->
    #
    def **: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn + bn2 => aBN
    # -->
    #
    def +: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - +bn -> aBN
    # -->
    #
    def +@: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn - bn2 => aBN
    # -->
    #
    def -: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - -bn -> aBN
    # -->
    #
    def -@: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn1 / bn2 => [result, remainder]
    # -->
    # Division of OpenSSL::BN instances
    #
    def /: (int) -> [ instance, instance ]

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn << bits -> aBN
    # -->
    #
    def <<: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - <=>(p1)
    # -->
    #
    alias <=> cmp

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn == obj => true or false
    # -->
    # Returns `true` only if *obj* has the same value as *bn*. Contrast this with
    # OpenSSL::BN#eql?, which requires obj to be OpenSSL::BN.
    #
    def ==: (untyped) -> bool

    # <!-- rdoc-file=ext/openssl/ossl_bn.c -->
    # Returns `true` only if *obj* has the same value as *bn*. Contrast this with
    # OpenSSL::BN#eql?, which requires obj to be OpenSSL::BN.
    #
    alias === ==

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn >> bits -> aBN
    # -->
    #
    def >>: (int) -> int

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.bit_set?(bit) => true | false
    # -->
    # Tests bit *bit* in *bn* and returns `true` if set, `false` if not set.
    #
    def bit_set?: (int) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.clear_bit!(bit) -> self
    # -->
    #
    def clear_bit!: (int) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.cmp(bn2) => integer
    # -->
    #
    def cmp: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - coerce(p1)
    # -->
    #
    def coerce: (::Integer) -> Array[Integer]
              | (BN) -> Array[BN]

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - copy(p1)
    # -->
    #
    def copy: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.eql?(obj) => true or false
    # -->
    # Returns `true` only if *obj* is a `OpenSSL::BN` with the same value as *bn*.
    # Contrast this with OpenSSL::BN#==, which performs type conversions.
    #
    def eql?: (untyped other) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.gcd(bn2) => aBN
    # -->
    #
    def gcd: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.hash => Integer
    # -->
    # Returns a hash code for this object.
    #
    # See also Object#hash.
    #
    def hash: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.lshift!(bits) -> self
    # -->
    #
    def lshift!: (int bits) -> self

    def mask_bits!: (int) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_add(bn1, bn2) -> aBN
    # -->
    #
    def mod_add: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_exp(bn1, bn2) -> aBN
    # -->
    #
    def mod_exp: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_inverse(bn2) => aBN
    # -->
    #
    def mod_inverse: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_mul(bn1, bn2) -> aBN
    # -->
    #
    def mod_mul: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_sqr(bn2) => aBN
    # -->
    #
    def mod_sqr: (int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.mod_sub(bn1, bn2) -> aBN
    # -->
    #
    def mod_sub: (int, int) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.negative? => true | false
    # -->
    #
    def negative?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.num_bits => integer
    # -->
    #
    def num_bits: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.num_bytes => integer
    # -->
    #
    def num_bytes: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.odd? => true | false
    # -->
    #
    def odd?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.one? => true | false
    # -->
    #
    def one?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/bn.rb
    #   - pretty_print(q)
    # -->
    #
    def pretty_print: (untyped q) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.prime? => true | false
    #   - bn.prime?(checks) => true | false
    # -->
    # Performs a Miller-Rabin probabilistic primality test for `bn`.
    #
    # **`checks` parameter is deprecated in version 3.0.** It has no effect.
    #
    def prime?: (?int checks) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.prime_fasttest? => true | false
    #   - bn.prime_fasttest?(checks) => true | false
    #   - bn.prime_fasttest?(checks, trial_div) => true | false
    # -->
    # Performs a Miller-Rabin probabilistic primality test for `bn`.
    #
    # **Deprecated in version 3.0.** Use #prime? instead.
    #
    # `checks` and `trial_div` parameters no longer have any effect.
    #
    def prime_fasttest?: (?int checks, ?int trial_div) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.rshift!(bits) -> self
    # -->
    #
    def rshift!: (int bits) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.set_bit!(bit) -> self
    # -->
    #
    def set_bit!: (int bit) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.sqr => aBN
    # -->
    #
    def sqr: () -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - to_bn()
    # -->
    #
    def to_bn: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.to_i => integer
    # -->
    #
    def to_i: () -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - to_int()
    # -->
    #
    alias to_int to_i

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.to_s(base = 10) -> string
    # -->
    # Returns the string representation of the bignum.
    #
    # BN.new can parse the encoded string to convert back into an OpenSSL::BN.
    #
    # `base`
    # :   The format. Must be one of the following:
    #     *   `0`  - MPI format. See the man page BN_bn2mpi(3) for details.
    #     *   `2`  - Variable-length and big-endian binary encoding. The sign of the
    #         bignum is ignored.
    #     *   `10` - Decimal number representation, with a leading '-' for a
    #         negative bignum.
    #     *   `16` - Hexadeciaml number representation, with a leading '-' for a
    #         negative bignum.
    #
    def to_s: () -> String
            | (0) -> String
            | (2) -> String
            | (10) -> String
            | (16) -> String
            | (int base) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.ucmp(bn2) => integer
    # -->
    #
    def ucmp: (int bn2) -> ::Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - bn.zero? => true | false
    # -->
    #
    def zero?: () -> bool

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - OpenSSL::BN.new(bn) -> aBN
    #   - OpenSSL::BN.new(integer) -> aBN
    #   - OpenSSL::BN.new(string, base = 10) -> aBN
    # -->
    # Construct a new OpenSSL BIGNUM object.
    #
    # If `bn` is an Integer or OpenSSL::BN, a new instance of OpenSSL::BN
    # representing the same value is returned. See also Integer#to_bn for the
    # short-hand.
    #
    # If a String is given, the content will be parsed according to `base`.
    #
    # `string`
    # :   The string to be parsed.
    # `base`
    # :   The format. Must be one of the following:
    #     *   `0`  - MPI format. See the man page BN_mpi2bn(3) for details.
    #     *   `2`  - Variable-length and big-endian binary encoding of a positive
    #         number.
    #     *   `10` - Decimal number representation, with a leading '-' for a
    #         negative number.
    #     *   `16` - Hexadeciaml number representation, with a leading '-' for a
    #         negative number.
    #
    def initialize: (instance) -> void
                  | (int) -> void
                  | (string) -> void
                  | (string, 0 | 2 | 10 | 16) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_bn.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance other) -> instance
  end

  # <!-- rdoc-file=ext/openssl/ossl_bn.c -->
  # Generic Error for all of OpenSSL::BN (big num)
  #
  class BNError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
  # OpenSSL IO buffering mix-in module.
  #
  # This module allows an OpenSSL::SSL::SSLSocket to behave like an IO.
  #
  # You typically won't use this module directly, you can see it implemented in
  # OpenSSL::SSL::SSLSocket.
  #
  module Buffering
    include Enumerable[untyped]

    public

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - <<(s)
    # -->
    # Writes *s* to the stream.  *s* will be converted to a String using `.to_s`
    # method.
    #
    def <<: (String s) -> self

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - close()
    # -->
    # Closes the SSLSocket and flushes any unwritten data.
    #
    def close: () -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each(eol=$/) { |line| ... }
    # -->
    # Executes the block for every line in the stream where lines are separated by
    # *eol*.
    #
    # See also #gets
    #
    def each: (?String eol) ?{ (String) -> void } -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each_byte() { |byte| ... }
    # -->
    # Calls the given block once for each byte in the stream.
    #
    def each_byte: () ?{ (Integer) -> void } -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - each_line(eol=$/)
    # -->
    #
    alias each_line each

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - eof()
    # -->
    #
    alias eof eof?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - eof?()
    # -->
    # Returns true if the stream is at file which means there is no more data to be
    # read.
    #
    def eof?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - flush()
    # -->
    # Flushes buffered data to the SSLSocket.
    #
    def flush: () -> self

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - getc()
    # -->
    # Reads one character from the stream.  Returns nil if called at end of file.
    #
    def getc: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - gets(eol=$/, limit=nil)
    # -->
    # Reads the next "line" from the stream.  Lines are separated by *eol*.  If
    # *limit* is provided the result will not be longer than the given number of
    # bytes.
    #
    # *eol* may be a String or Regexp.
    #
    # Unlike IO#gets the line read will not be assigned to +$_+.
    #
    # Unlike IO#gets the separator must be provided if a limit is provided.
    #
    def gets: (?String | Regexp eol, ?Integer limit) -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - print(*args)
    # -->
    # Writes *args* to the stream.
    #
    # See IO#print for full details.
    #
    def print: (*untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - printf(s, *args)
    # -->
    # Formats and writes to the stream converting parameters under control of the
    # format string.
    #
    # See Kernel#sprintf for format string details.
    #
    def printf: (String format_string, *untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - puts(*args)
    # -->
    # Writes *args* to the stream along with a record separator.
    #
    # See IO#puts for full details.
    #
    def puts: (*untyped args) -> nil

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - read(size=nil, buf=nil)
    # -->
    # Reads *size* bytes from the stream.  If *buf* is provided it must reference a
    # string which will receive the data.
    #
    # See IO#read for full details.
    #
    def read: (?Integer? size, ?String buf) -> String?

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - read_nonblock(maxlen, buf=nil, exception: true)
    # -->
    # Reads at most *maxlen* bytes in the non-blocking manner.
    #
    # When no data can be read without blocking it raises OpenSSL::SSL::SSLError
    # extended by IO::WaitReadable or IO::WaitWritable.
    #
    # IO::WaitReadable means SSL needs to read internally so read_nonblock should be
    # called again when the underlying IO is readable.
    #
    # IO::WaitWritable means SSL needs to write internally so read_nonblock should
    # be called again after the underlying IO is writable.
    #
    # OpenSSL::Buffering#read_nonblock needs two rescue clause as follows:
    #
    #     # emulates blocking read (readpartial).
    #     begin
    #       result = ssl.read_nonblock(maxlen)
    #     rescue IO::WaitReadable
    #       IO.select([io])
    #       retry
    #     rescue IO::WaitWritable
    #       IO.select(nil, [io])
    #       retry
    #     end
    #
    # Note that one reason that read_nonblock writes to the underlying IO is when
    # the peer requests a new TLS/SSL handshake.  See openssl the FAQ for more
    # details.  http://www.openssl.org/support/faq.html
    #
    # By specifying a keyword argument *exception* to `false`, you can indicate that
    # read_nonblock should not raise an IO::Wait*able exception, but return the
    # symbol `:wait_writable` or `:wait_readable` instead. At EOF, it will return
    # `nil` instead of raising EOFError.
    #
    def read_nonblock: (Integer maxlen, ?String buf, ?exception: true) -> String
                     | (Integer maxlen, ?String buf, exception: false) -> (String | :wait_writable | :wait_readable | nil)

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readchar()
    # -->
    # Reads a one-character string from the stream.  Raises an EOFError at end of
    # file.
    #
    def readchar: () -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readline(eol=$/)
    # -->
    # Reads a line from the stream which is separated by *eol*.
    #
    # Raises EOFError if at end of file.
    #
    def readline: (?String eol) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readlines(eol=$/)
    # -->
    # Reads lines from the stream which are separated by *eol*.
    #
    # See also #gets
    #
    def readlines: (?String eol) -> ::Array[String]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - readpartial(maxlen, buf=nil)
    # -->
    # Reads at most *maxlen* bytes from the stream.  If *buf* is provided it must
    # reference a string which will receive the data.
    #
    # See IO#readpartial for full details.
    #
    def readpartial: (Integer maxlen, ?String buf) -> String

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # The "sync mode" of the SSLSocket.
    #
    # See IO#sync for full details.
    #
    def sync: () -> bool

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # The "sync mode" of the SSLSocket.
    #
    # See IO#sync for full details.
    #
    def sync=: (boolish) -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - ungetc(c)
    # -->
    # Pushes character *c* back onto the stream such that a subsequent buffered
    # character read will return it.
    #
    # Unlike IO#getc multiple bytes may be pushed back onto the stream.
    #
    # Has no effect on unbuffered reads (such as #sysread).
    #
    def ungetc: (String c) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - write(*s)
    # -->
    # Writes *s* to the stream.  If the argument is not a String it will be
    # converted using `.to_s` method.  Returns the number of bytes written.
    #
    def write: (*_ToS s) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - write_nonblock(s, exception: true)
    # -->
    # Writes *s* in the non-blocking manner.
    #
    # If there is buffered data, it is flushed first.  This may block.
    #
    # write_nonblock returns number of bytes written to the SSL connection.
    #
    # When no data can be written without blocking it raises OpenSSL::SSL::SSLError
    # extended by IO::WaitReadable or IO::WaitWritable.
    #
    # IO::WaitReadable means SSL needs to read internally so write_nonblock should
    # be called again after the underlying IO is readable.
    #
    # IO::WaitWritable means SSL needs to write internally so write_nonblock should
    # be called again after underlying IO is writable.
    #
    # So OpenSSL::Buffering#write_nonblock needs two rescue clause as follows.
    #
    #     # emulates blocking write.
    #     begin
    #       result = ssl.write_nonblock(str)
    #     rescue IO::WaitReadable
    #       IO.select([io])
    #       retry
    #     rescue IO::WaitWritable
    #       IO.select(nil, [io])
    #       retry
    #     end
    #
    # Note that one reason that write_nonblock reads from the underlying IO is when
    # the peer requests a new TLS/SSL handshake.  See the openssl FAQ for more
    # details.  http://www.openssl.org/support/faq.html
    #
    # By specifying a keyword argument *exception* to `false`, you can indicate that
    # write_nonblock should not raise an IO::Wait*able exception, but return the
    # symbol `:wait_writable` or `:wait_readable` instead.
    #
    def write_nonblock: (_ToS s, ?exception: true) -> Integer
                      | (_ToS s, exception: false) -> (Integer | :wait_writable | :wait_readable | nil)

    private

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - consume_rbuff(size=nil)
    # -->
    # Consumes *size* bytes from the buffer
    #
    def consume_rbuff: (?untyped size) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - do_write(s)
    # -->
    # Writes *s* to the buffer.  When the buffer is full or #sync is true the buffer
    # is flushed to the underlying socket.
    #
    def do_write: (untyped s) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
    #   - fill_rbuff()
    # -->
    # Fills the buffer from the underlying SSLSocket
    #
    def fill_rbuff: () -> untyped

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # Default size to read from or write to the SSLSocket for buffer operations.
    #
    BLOCK_SIZE: Integer

    # <!-- rdoc-file=ext/openssl/lib/openssl/buffering.rb -->
    # A buffer which will retain binary encoding.
    #
    class Buffer < String
      BINARY: Encoding

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
      #   - <<(string)
      # -->
      #
      def <<: (String string) -> self

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/buffering.rb
      #   - concat(string)
      # -->
      #
      alias concat <<
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_cipher.c -->
  # Provides symmetric algorithms for encryption and decryption. The algorithms
  # that are available depend on the particular version of OpenSSL that is
  # installed.
  #
  # ### Listing all supported algorithms
  #
  # A list of supported algorithms can be obtained by
  #
  #     puts OpenSSL::Cipher.ciphers
  #
  # ### Instantiating a Cipher
  #
  # There are several ways to create a Cipher instance. Generally, a Cipher
  # algorithm is categorized by its name, the key length in bits and the cipher
  # mode to be used. The most generic way to create a Cipher is the following
  #
  #     cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')
  #
  # That is, a string consisting of the hyphenated concatenation of the individual
  # components name, key length and mode. Either all uppercase or all lowercase
  # strings may be used, for example:
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-cbc')
  #
  # ### Choosing either encryption or decryption mode
  #
  # Encryption and decryption are often very similar operations for symmetric
  # algorithms, this is reflected by not having to choose different classes for
  # either operation, both can be done using the same class. Still, after
  # obtaining a Cipher instance, we need to tell the instance what it is that we
  # intend to do with it, so we need to call either
  #
  #     cipher.encrypt
  #
  # or
  #
  #     cipher.decrypt
  #
  # on the Cipher instance. This should be the first call after creating the
  # instance, otherwise configuration that has already been set could get lost in
  # the process.
  #
  # ### Choosing a key
  #
  # Symmetric encryption requires a key that is the same for the encrypting and
  # for the decrypting party and after initial key establishment should be kept as
  # private information. There are a lot of ways to create insecure keys, the most
  # notable is to simply take a password as the key without processing the
  # password further. A simple and secure way to create a key for a particular
  # Cipher is
  #
  #     cipher = OpenSSL::Cipher.new('aes-256-cfb')
  #     cipher.encrypt
  #     key = cipher.random_key # also sets the generated key on the Cipher
  #
  # If you absolutely need to use passwords as encryption keys, you should use
  # Password-Based Key Derivation Function 2 (PBKDF2) by generating the key with
  # the help of the functionality provided by OpenSSL::PKCS5.pbkdf2_hmac_sha1 or
  # OpenSSL::PKCS5.pbkdf2_hmac.
  #
  # Although there is Cipher#pkcs5_keyivgen, its use is deprecated and it should
  # only be used in legacy applications because it does not use the newer PKCS#5
  # v2 algorithms.
  #
  # ### Choosing an IV
  #
  # The cipher modes CBC, CFB, OFB and CTR all need an "initialization vector", or
  # short, IV. ECB mode is the only mode that does not require an IV, but there is
  # almost no legitimate use case for this mode because of the fact that it does
  # not sufficiently hide plaintext patterns. Therefore
  #
  # **You should never use ECB mode unless you are absolutely sure that you
  # absolutely need it**
  #
  # Because of this, you will end up with a mode that explicitly requires an IV in
  # any case. Although the IV can be seen as public information, i.e. it may be
  # transmitted in public once generated, it should still stay unpredictable to
  # prevent certain kinds of attacks. Therefore, ideally
  #
  # **Always create a secure random IV for every encryption of your Cipher**
  #
  # A new, random IV should be created for every encryption of data. Think of the
  # IV as a nonce (number used once) - it's public but random and unpredictable. A
  # secure random IV can be created as follows
  #
  #     cipher = ...
  #     cipher.encrypt
  #     key = cipher.random_key
  #     iv = cipher.random_iv # also sets the generated IV on the Cipher
  #
  # Although the key is generally a random value, too, it is a bad choice as an
  # IV. There are elaborate ways how an attacker can take advantage of such an IV.
  # As a general rule of thumb, exposing the key directly or indirectly should be
  # avoided at all cost and exceptions only be made with good reason.
  #
  # ### Calling Cipher#final
  #
  # ECB (which should not be used) and CBC are both block-based modes. This means
  # that unlike for the other streaming-based modes, they operate on fixed-size
  # blocks of data, and therefore they require a "finalization" step to produce or
  # correctly decrypt the last block of data by appropriately handling some form
  # of padding. Therefore it is essential to add the output of
  # OpenSSL::Cipher#final to your encryption/decryption buffer or you will end up
  # with decryption errors or truncated data.
  #
  # Although this is not really necessary for streaming-mode ciphers, it is still
  # recommended to apply the same pattern of adding the output of Cipher#final
  # there as well - it also enables you to switch between modes more easily in the
  # future.
  #
  # ### Encrypting and decrypting some data
  #
  #     data = "Very, very confidential data"
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-cbc')
  #     cipher.encrypt
  #     key = cipher.random_key
  #     iv = cipher.random_iv
  #
  #     encrypted = cipher.update(data) + cipher.final
  #     ...
  #     decipher = OpenSSL::Cipher.new('aes-128-cbc')
  #     decipher.decrypt
  #     decipher.key = key
  #     decipher.iv = iv
  #
  #     plain = decipher.update(encrypted) + decipher.final
  #
  #     puts data == plain #=> true
  #
  # ### Authenticated Encryption and Associated Data (AEAD)
  #
  # If the OpenSSL version used supports it, an Authenticated Encryption mode
  # (such as GCM or CCM) should always be preferred over any unauthenticated mode.
  # Currently, OpenSSL supports AE only in combination with Associated Data (AEAD)
  # where additional associated data is included in the encryption process to
  # compute a tag at the end of the encryption. This tag will also be used in the
  # decryption process and by verifying its validity, the authenticity of a given
  # ciphertext is established.
  #
  # This is superior to unauthenticated modes in that it allows to detect if
  # somebody effectively changed the ciphertext after it had been encrypted. This
  # prevents malicious modifications of the ciphertext that could otherwise be
  # exploited to modify ciphertexts in ways beneficial to potential attackers.
  #
  # An associated data is used where there is additional information, such as
  # headers or some metadata, that must be also authenticated but not necessarily
  # need to be encrypted. If no associated data is needed for encryption and later
  # decryption, the OpenSSL library still requires a value to be set - "" may be
  # used in case none is available.
  #
  # An example using the GCM (Galois/Counter Mode). You have 16 bytes *key*, 12
  # bytes (96 bits) *nonce* and the associated data *auth_data*. Be sure not to
  # reuse the *key* and *nonce* pair. Reusing an nonce ruins the security
  # guarantees of GCM mode.
  #
  #     cipher = OpenSSL::Cipher.new('aes-128-gcm').encrypt
  #     cipher.key = key
  #     cipher.iv = nonce
  #     cipher.auth_data = auth_data
  #
  #     encrypted = cipher.update(data) + cipher.final
  #     tag = cipher.auth_tag # produces 16 bytes tag by default
  #
  # Now you are the receiver. You know the *key* and have received *nonce*,
  # *auth_data*, *encrypted* and *tag* through an untrusted network. Note that GCM
  # accepts an arbitrary length tag between 1 and 16 bytes. You may additionally
  # need to check that the received tag has the correct length, or you allow
  # attackers to forge a valid single byte tag for the tampered ciphertext with a
  # probability of 1/256.
  #
  #     raise "tag is truncated!" unless tag.bytesize == 16
  #     decipher = OpenSSL::Cipher.new('aes-128-gcm').decrypt
  #     decipher.key = key
  #     decipher.iv = nonce
  #     decipher.auth_tag = tag
  #     decipher.auth_data = auth_data
  #
  #     decrypted = decipher.update(encrypted) + decipher.final
  #
  #     puts data == decrypted #=> true
  #
  class Cipher
    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - OpenSSL::Cipher.ciphers -> array[string...]
    # -->
    # Returns the names of all available ciphers in an array.
    #
    def self.ciphers: () -> Array[String]

    public

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_data = string -> string
    # -->
    # Sets the cipher's additional authenticated data. This field must be set when
    # using AEAD cipher modes such as GCM or CCM. If no associated data shall be
    # used, this method must **still** be called with a value of "". The contents of
    # this field should be non-sensitive data which will be added to the ciphertext
    # to generate the authentication tag which validates the contents of the
    # ciphertext.
    #
    # The AAD must be set prior to encryption or decryption. In encryption mode, it
    # must be set after calling Cipher#encrypt and setting Cipher#key= and
    # Cipher#iv=. When decrypting, the authenticated data must be set after key, iv
    # and especially **after** the authentication tag has been set. I.e. set it only
    # after calling Cipher#decrypt, Cipher#key=, Cipher#iv= and Cipher#auth_tag=
    # first.
    #
    def auth_data=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag(tag_len = 16) -> String
    # -->
    # Gets the authentication tag generated by Authenticated Encryption Cipher modes
    # (GCM for example). This tag may be stored along with the ciphertext, then set
    # on the decryption cipher to authenticate the contents of the ciphertext
    # against changes. If the optional integer parameter *tag_len* is given, the
    # returned tag will be *tag_len* bytes long. If the parameter is omitted, the
    # default length of 16 bytes or the length previously set by #auth_tag_len= will
    # be used. For maximum security, the longest possible should be chosen.
    #
    # The tag may only be retrieved after calling Cipher#final.
    #
    def auth_tag: (?Integer tag_len) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag = string -> string
    # -->
    # Sets the authentication tag to verify the integrity of the ciphertext. This
    # can be called only when the cipher supports AE. The tag must be set after
    # calling Cipher#decrypt, Cipher#key= and Cipher#iv=, but before calling
    # Cipher#final. After all decryption is performed, the tag is verified
    # automatically in the call to Cipher#final.
    #
    # For OCB mode, the tag length must be supplied with #auth_tag_len= beforehand.
    #
    def auth_tag=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.auth_tag_len = Integer -> Integer
    # -->
    # Sets the length of the authentication tag to be generated or to be given for
    # AEAD ciphers that requires it as in input parameter. Note that not all AEAD
    # ciphers support this method.
    #
    # In OCB mode, the length must be supplied both when encrypting and when
    # decrypting, and must be before specifying an IV.
    #
    def auth_tag_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.authenticated? -> true | false
    # -->
    # Indicated whether this Cipher instance uses an Authenticated Encryption mode.
    #
    def authenticated?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.block_size -> integer
    # -->
    # Returns the size in bytes of the blocks on which this Cipher operates on.
    #
    def block_size: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.decrypt -> self
    # -->
    # Initializes the Cipher for decryption.
    #
    # Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
    # following methods:
    #
    #     #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
    # :
    #
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).
    #
    def decrypt: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.encrypt -> self
    # -->
    # Initializes the Cipher for encryption.
    #
    # Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
    # following methods:
    #
    #     #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
    # :
    #
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).
    #
    def encrypt: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.final -> string
    # -->
    # Returns the remaining data held in the cipher object. Further calls to
    # Cipher#update or Cipher#final will return garbage. This call should always be
    # made as the last call of an encryption or decryption operation, after having
    # fed the entire plaintext or ciphertext to the Cipher instance.
    #
    # If an authenticated cipher was used, a CipherError is raised if the tag could
    # not be authenticated successfully. Only call this method after setting the
    # authentication tag and passing the entire contents of the ciphertext into the
    # cipher.
    #
    def final: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv = string -> string
    # -->
    # Sets the cipher IV. Please note that since you should never be using ECB mode,
    # an IV is always explicitly required and should be set prior to encryption. The
    # IV itself can be safely transmitted in public, but it should be unpredictable
    # to prevent certain kinds of attacks. You may use Cipher#random_iv to create a
    # secure random IV.
    #
    # Only call this method after calling Cipher#encrypt or Cipher#decrypt.
    #
    def iv=: (String iv) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv_len -> integer
    # -->
    # Returns the expected length in bytes for an IV for this Cipher.
    #
    def iv_len: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.iv_len = integer -> integer
    # -->
    # Sets the IV/nonce length of the Cipher. Normally block ciphers don't allow
    # changing the IV length, but some make use of IV for 'nonce'. You may need this
    # for interoperability with other applications.
    #
    def iv_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key = string -> string
    # -->
    # Sets the cipher key. To generate a key, you should either use a secure random
    # byte string or, if the key is to be derived from a password, you should rely
    # on PBKDF2 functionality provided by OpenSSL::PKCS5. To generate a secure
    # random-based key, Cipher#random_key may be used.
    #
    # Only call this method after calling Cipher#encrypt or Cipher#decrypt.
    #
    def key=: (String key) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key_len -> integer
    # -->
    # Returns the key length in bytes of the Cipher.
    #
    def key_len: () -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.key_len = integer -> integer
    # -->
    # Sets the key length of the cipher.  If the cipher is a fixed length cipher
    # then attempting to set the key length to any value other than the fixed value
    # is an error.
    #
    # Under normal circumstances you do not need to call this method (and probably
    # shouldn't).
    #
    # See EVP_CIPHER_CTX_set_key_length for further information.
    #
    def key_len=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.name -> string
    # -->
    # Returns the name of the cipher which may differ slightly from the original
    # name provided.
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.padding = integer -> integer
    # -->
    # Enables or disables padding. By default encryption operations are padded using
    # standard block padding and the padding is checked and removed when decrypting.
    # If the pad parameter is zero then no padding is performed, the total amount of
    # data encrypted or decrypted must then be a multiple of the block size or an
    # error will occur.
    #
    # See EVP_CIPHER_CTX_set_padding for further information.
    #
    def padding=: (Integer) -> Integer

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.pkcs5_keyivgen(pass, salt = nil, iterations = 2048, digest = "MD5") -> nil
    # -->
    # Generates and sets the key/IV based on a password.
    #
    # **WARNING**: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,
    # or DES with MD5 or SHA1. Using anything else (like AES) will generate the
    # key/iv using an OpenSSL specific method. This method is deprecated and should
    # no longer be used. Use a PKCS5 v2 key generation method from OpenSSL::PKCS5
    # instead.
    #
    # ### Parameters
    # *   *salt* must be an 8 byte string if provided.
    # *   *iterations* is an integer with a default of 2048.
    # *   *digest* is a Digest object that defaults to 'MD5'
    #
    #
    # A minimum of 1000 iterations is recommended.
    #
    def pkcs5_keyivgen: (String pass, ?String salt, ?Integer iterations, ?String digest) -> void

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/cipher.rb
    #   - cipher.random_iv -> iv
    # -->
    # Generate a random IV with OpenSSL::Random.random_bytes and sets it to the
    # cipher, and returns it.
    #
    # You must call #encrypt or #decrypt before calling this method.
    #
    def random_iv: () -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/cipher.rb
    #   - cipher.random_key -> key
    # -->
    # Generate a random key with OpenSSL::Random.random_bytes and sets it to the
    # cipher, and returns it.
    #
    # You must call #encrypt or #decrypt before calling this method.
    #
    def random_key: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.reset -> self
    # -->
    # Fully resets the internal state of the Cipher. By using this, the same Cipher
    # instance may be used several times for encryption or decryption tasks.
    #
    # Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).
    #
    def reset: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - cipher.update(data [, buffer]) -> string or buffer
    # -->
    # Encrypts data in a streaming fashion. Hand consecutive blocks of data to the
    # #update method in order to encrypt it. Returns the encrypted data chunk. When
    # done, the output of Cipher#final should be additionally added to the result.
    #
    # If *buffer* is given, the encryption/decryption result will be written to it.
    # *buffer* will be resized automatically.
    #
    def update: (String data, ?String buffer) -> String

    private

    def ciphers: () -> Array[String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - Cipher.new(string) -> cipher
    # -->
    # The string must contain a valid cipher name like "aes-256-cbc".
    #
    # A list of cipher names is available by calling OpenSSL::Cipher.ciphers.
    #
    def initialize: (String cipher_name) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_cipher.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (untyped) -> untyped

    class AES < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class AES128 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class AES192 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class AES256 < OpenSSL::Cipher
      private

      def initialize: (?_ToS mode) -> void
    end

    class BF < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class CAST5 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    # <!-- rdoc-file=ext/openssl/lib/openssl/cipher.rb -->
    # Deprecated.
    #
    # This class is only provided for backwards compatibility. Use OpenSSL::Cipher.
    #
    class Cipher < OpenSSL::Cipher
    end

    class CipherError < OpenSSL::OpenSSLError
    end

    class DES < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class IDEA < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC2 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC4 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end

    class RC5 < OpenSSL::Cipher
      private

      def initialize: (*_ToS args) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_config.c -->
  # Configuration for the openssl library.
  #
  # Many system's installation of openssl library will depend on your system
  # configuration. See the value of OpenSSL::Config::DEFAULT_CONFIG_FILE for the
  # location of the file for your host.
  #
  # See also http://www.openssl.org/docs/apps/config.html
  #
  class Config
    include Enumerable[[ String, String, String ]]

    def self.load: (?_ToS filename) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.parse(string) -> OpenSSL::Config
    # -->
    # Parses a given *string* as a blob that contains configuration for OpenSSL.
    #
    def self.parse: (String string) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.parse_config(io) -> hash
    # -->
    # Parses the configuration data read from *io* and returns the whole content as
    # a Hash.
    #
    def self.parse_config: (IO io) -> Hash[String, Hash[String, String]]

    public

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config[section] -> hash
    # -->
    # Gets all key-value pairs in a specific *section* from the current
    # configuration.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can get a hash of the specific section like so:
    #
    #     config['default']
    #       #=> {"foo"=>"bar"}
    #
    def []: (String section) -> Hash[String, String]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/config.rb
    #   - []=(section, pairs)
    # -->
    # *Deprecated in v2.2.0*. This method will be removed in a future release.
    #
    # Sets a specific *section* name with a Hash *pairs*.
    #
    # Given the following configuration being created:
    #
    #     config = OpenSSL::Config.new
    #       #=> #<OpenSSL::Config sections=[]>
    #     config['default'] = {"foo"=>"bar","baz"=>"buz"}
    #       #=> {"foo"=>"bar", "baz"=>"buz"}
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #       #   baz=buz
    #
    # It's important to note that this will essentially merge any of the keys in
    # *pairs* with the existing *section*. For example:
    #
    #     config['default']
    #       #=> {"foo"=>"bar", "baz"=>"buz"}
    #     config['default'] = {"foo" => "changed"}
    #       #=> {"foo"=>"changed"}
    #     config['default']
    #       #=> {"foo"=>"changed", "baz"=>"buz"}
    #
    def []=: (String section, _Each[[ String, String ]] pairs) -> _Each[[ String, String ]]

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/config.rb
    #   - add_value(section, key, value)
    # -->
    # *Deprecated in v2.2.0*. This method will be removed in a future release.
    #
    # Set the target *key* with a given *value* under a specific *section*.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can set the value of *foo* under the *default* section to a new value:
    #
    #     config.add_value('default', 'foo', 'buzz')
    #       #=> "buzz"
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=buzz
    #
    def add_value: (String section, untyped key, untyped value) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.each { |section, key, value| }
    # -->
    # Retrieves the section and its pairs for the current configuration.
    #
    #     config.each do |section, key, value|
    #       # ...
    #     end
    #
    def each: () { ([ String, String, String ] args0) -> void } -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.get_value(section, key) -> string
    # -->
    # Gets the value of *key* from the given *section*.
    #
    # Given the following configurating file being loaded:
    #
    #     config = OpenSSL::Config.load('foo.cnf')
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #
    # You can get a specific value from the config if you know the *section* and
    # *key* like so:
    #
    #     config.get_value('default','foo')
    #       #=> "bar"
    #
    def get_value: (String section, String key) -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.inspect -> string
    # -->
    # String representation of this configuration object, including the class name
    # and its sections.
    #
    def inspect: () -> String

    def section: (String name) -> Hash[String, String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.sections -> array of string
    # -->
    # Get the names of all sections in the current configuration.
    #
    def sections: () -> Array[String]

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - config.to_s -> string
    # -->
    # Gets the parsable form of the current configuration.
    #
    # Given the following configuration being created:
    #
    #     config = OpenSSL::Config.new
    #       #=> #<OpenSSL::Config sections=[]>
    #     config['default'] = {"foo"=>"bar","baz"=>"buz"}
    #       #=> {"foo"=>"bar", "baz"=>"buz"}
    #     puts config.to_s
    #       #=> [ default ]
    #       #   foo=bar
    #       #   baz=buz
    #
    # You can parse get the serialized configuration using #to_s and then parse it
    # later:
    #
    #     serialized_config = config.to_s
    #     # much later...
    #     new_config = OpenSSL::Config.parse(serialized_config)
    #       #=> #<OpenSSL::Config sections=["default"]>
    #     puts new_config
    #       #=> [ default ]
    #           foo=bar
    #           baz=buz
    #
    def to_s: () -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - Config.new(filename) -> OpenSSL::Config
    # -->
    # Creates an instance of OpenSSL::Config from the content of the file specified
    # by *filename*.
    #
    # This can be used in contexts like OpenSSL::X509::ExtensionFactory.config=
    #
    # This can raise IO exceptions based on the access, or availability of the file.
    # A ConfigError exception may be raised depending on the validity of the data
    # being configured.
    #
    def initialize: (?_ToS filename) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_config.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance other) -> void

    # <!-- rdoc-file=ext/openssl/ossl_config.c -->
    # The default system configuration file for OpenSSL.
    #
    DEFAULT_CONFIG_FILE: String
  end

  # <!-- rdoc-file=ext/openssl/ossl_config.c -->
  # General error for openssl library configuration files. Including formatting,
  # parsing errors, etc.
  #
  class ConfigError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
  # OpenSSL::Digest allows you to compute message digests (sometimes
  # interchangeably called "hashes") of arbitrary data that are cryptographically
  # secure, i.e. a Digest implements a secure one-way function.
  #
  # One-way functions offer some useful properties. E.g. given two distinct inputs
  # the probability that both yield the same output is highly unlikely. Combined
  # with the fact that every message digest algorithm has a fixed-length output of
  # just a few bytes, digests are often used to create unique identifiers for
  # arbitrary data. A common example is the creation of a unique id for binary
  # documents that are stored in a database.
  #
  # Another useful characteristic of one-way functions (and thus the name) is that
  # given a digest there is no indication about the original data that produced
  # it, i.e. the only way to identify the original input is to "brute-force"
  # through every possible combination of inputs.
  #
  # These characteristics make one-way functions also ideal companions for public
  # key signature algorithms: instead of signing an entire document, first a hash
  # of the document is produced with a considerably faster message digest
  # algorithm and only the few bytes of its output need to be signed using the
  # slower public key algorithm. To validate the integrity of a signed document,
  # it suffices to re-compute the hash and verify that it is equal to that in the
  # signature.
  #
  # You can get a list of all digest algorithms supported on your system by
  # running this command in your terminal:
  #
  #     openssl list -digest-algorithms
  #
  # Among the OpenSSL 1.1.1 supported message digest algorithms are:
  # *   SHA224, SHA256, SHA384, SHA512, SHA512-224 and SHA512-256
  # *   SHA3-224, SHA3-256, SHA3-384 and SHA3-512
  # *   BLAKE2s256 and BLAKE2b512
  #
  #
  # Each of these algorithms can be instantiated using the name:
  #
  #     digest = OpenSSL::Digest.new('SHA256')
  #
  # "Breaking" a message digest algorithm means defying its one-way function
  # characteristics, i.e. producing a collision or finding a way to get to the
  # original data by means that are more efficient than brute-forcing etc. Most of
  # the supported digest algorithms can be considered broken in this sense, even
  # the very popular MD5 and SHA1 algorithms. Should security be your highest
  # concern, then you should probably rely on SHA224, SHA256, SHA384 or SHA512.
  #
  # ### Hashing a file
  #
  #     data = File.binread('document')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     digest = sha256.digest(data)
  #
  # ### Hashing several pieces of data at once
  #
  #     data1 = File.binread('file1')
  #     data2 = File.binread('file2')
  #     data3 = File.binread('file3')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     sha256 << data1
  #     sha256 << data2
  #     sha256 << data3
  #     digest = sha256.digest
  #
  # ### Reuse a Digest instance
  #
  #     data1 = File.binread('file1')
  #     sha256 = OpenSSL::Digest.new('SHA256')
  #     digest1 = sha256.digest(data1)
  #
  #     data2 = File.binread('file2')
  #     sha256.reset
  #     digest2 = sha256.digest(data2)
  #
  class Digest
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/digest.rb
    #   - digest(name, data)
    # -->
    # Return the hash value computed with *name* Digest. *name* is either the long
    # name or short name of a supported digest algorithm.
    #
    # ### Examples
    #
    #     OpenSSL::Digest.digest("SHA256", "abc")
    #
    # which is equivalent to:
    #
    #     OpenSSL::Digest.digest('SHA256', "abc")
    #
    def self.digest: (String name, String data) -> String

    public

    # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
    # Not every message digest can be computed in one single pass. If a message
    # digest is to be computed from several subsequent sources, then each may be
    # passed individually to the Digest instance.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA256')
    #     digest.update('First input')
    #     digest << 'Second input' # equivalent to digest.update('Second input')
    #     result = digest.digest
    #
    alias << update

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.block_length -> integer
    # -->
    # Returns the block length of the digest algorithm, i.e. the length in bytes of
    # an individual block. Most modern algorithms partition a message to be digested
    # into a sequence of fix-sized blocks that are processed consecutively.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA1')
    #     puts digest.block_length # => 64
    #
    def block_length: () -> Integer

    def digest: (?String data) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.digest_length -> integer
    # -->
    # Returns the output size of the digest, i.e. the length in bytes of the final
    # message digest result.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA1')
    #     puts digest.digest_length # => 20
    #
    def digest_length: () -> Integer

    def hexdigest: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.name -> string
    # -->
    # Returns the sn of this Digest algorithm.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA512')
    #     puts digest.name # => SHA512
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.reset -> self
    # -->
    # Resets the Digest in the sense that any Digest#update that has been performed
    # is abandoned and the Digest is set to its initial state again.
    #
    def reset: () -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.update(string) -> aString
    # -->
    # Not every message digest can be computed in one single pass. If a message
    # digest is to be computed from several subsequent sources, then each may be
    # passed individually to the Digest instance.
    #
    # ### Example
    #     digest = OpenSSL::Digest.new('SHA256')
    #     digest.update('First input')
    #     digest << 'Second input' # equivalent to digest.update('Second input')
    #     result = digest.digest
    #
    def update: (String data) -> self

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - digest.finish -> aString
    # -->
    #
    def finish: (*untyped) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - Digest.new(string [, data]) -> Digest
    # -->
    # Creates a Digest instance based on *string*, which is either the ln (long
    # name) or sn (short name) of a supported digest algorithm.
    #
    # If *data* (a String) is given, it is used as the initial input to the Digest
    # instance, i.e.
    #
    #     digest = OpenSSL::Digest.new('sha256', 'digestdata')
    #
    # is equivalent to
    #
    #     digest = OpenSSL::Digest.new('sha256')
    #     digest.update('digestdata')
    #
    def initialize: (String name, ?String data) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_digest.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void

    class Digest < OpenSSL::Digest
    end

    # <!-- rdoc-file=ext/openssl/ossl_digest.c -->
    # Generic Exception class that is raised if an error occurs during a Digest
    # operation.
    #
    class DigestError < OpenSSL::OpenSSLError
    end

    class MD4 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class MD5 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class RIPEMD160 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA1 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA224 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA256 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA384 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end

    class SHA512 < OpenSSL::Digest
      def self.digest: (String data) -> String

      def self.hexdigest: (String data) -> String

      private

      def initialize: (?String data) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_engine.c -->
  # This class is the access to openssl's ENGINE cryptographic module
  # implementation.
  #
  # See also, https://www.openssl.org/docs/crypto/engine.html
  #
  class Engine
    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.by_id(name) -> engine
    # -->
    # Fetches the engine as specified by the *id* String.
    #
    #     OpenSSL::Engine.by_id("openssl")
    #      => #<OpenSSL::Engine id="openssl" name="Software engine support">
    #
    # See OpenSSL::Engine.engines for the currently loaded engines.
    #
    def self.by_id: (String name) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.cleanup
    # -->
    # It is only necessary to run cleanup when engines are loaded via
    # OpenSSL::Engine.load. However, running cleanup before exit is recommended.
    #
    # Note that this is needed and works only in OpenSSL < 1.1.0.
    #
    def self.cleanup: () -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.engines -> [engine, ...]
    # -->
    # Returns an array of currently loaded engines.
    #
    def self.engines: () -> Array[instance]

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - OpenSSL::Engine.load(name = nil)
    # -->
    # This method loads engines. If *name* is nil, then all builtin engines are
    # loaded. Otherwise, the given *name*, as a String,  is loaded if available to
    # your runtime, and returns true. If *name* is not found, then nil is returned.
    #
    def self.load: (?String name) -> (true | nil)

    public

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.cipher(name) -> OpenSSL::Cipher
    # -->
    # Returns a new instance of OpenSSL::Cipher by *name*, if it is available in
    # this engine.
    #
    # An EngineError will be raised if the cipher is unavailable.
    #
    #     e = OpenSSL::Engine.by_id("openssl")
    #      => #<OpenSSL::Engine id="openssl" name="Software engine support">
    #     e.cipher("RC4")
    #      => #<OpenSSL::Cipher:0x007fc5cacc3048>
    #
    def cipher: (String cipher) -> Cipher

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.cmds -> [["name", "description", "flags"], ...]
    # -->
    # Returns an array of command definitions for the current engine
    #
    def cmds: () -> Array[[ String, String, String ]]

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.ctrl_cmd(command, value = nil) -> engine
    # -->
    # Sends the given *command* to this engine.
    #
    # Raises an EngineError if the command fails.
    #
    def ctrl_cmd: (String cmd, ?String value) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.digest(name) -> OpenSSL::Digest
    # -->
    # Returns a new instance of OpenSSL::Digest by *name*.
    #
    # Will raise an EngineError if the digest is unavailable.
    #
    #     e = OpenSSL::Engine.by_id("openssl")
    #       #=> #<OpenSSL::Engine id="openssl" name="Software engine support">
    #     e.digest("SHA1")
    #       #=> #<OpenSSL::Digest: da39a3ee5e6b4b0d3255bfef95601890afd80709>
    #     e.digest("zomg")
    #       #=> OpenSSL::Engine::EngineError: no such digest `zomg'
    #
    def digest: (String digest) -> Digest

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.finish -> nil
    # -->
    # Releases all internal structural references for this engine.
    #
    # May raise an EngineError if the engine is unavailable
    #
    def finish: () -> nil

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.id -> string
    # -->
    # Gets the id for this engine.
    #
    #     OpenSSL::Engine.load
    #     OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    #     OpenSSL::Engine.engines.first.id
    #       #=> "rsax"
    #
    def id: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.inspect -> string
    # -->
    # Pretty prints this engine.
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.load_private_key(id = nil, data = nil) -> OpenSSL::PKey
    # -->
    # Loads the given private key identified by *id* and *data*.
    #
    # An EngineError is raised of the OpenSSL::PKey is unavailable.
    #
    def load_private_key: (?String id, ?String data) -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.load_public_key(id = nil, data = nil) -> OpenSSL::PKey
    # -->
    # Loads the given public key identified by *id* and *data*.
    #
    # An EngineError is raised of the OpenSSL::PKey is unavailable.
    #
    def load_public_key: (?String id, ?String data) -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.name -> string
    # -->
    # Get the descriptive name for this engine.
    #
    #     OpenSSL::Engine.load
    #     OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    #     OpenSSL::Engine.engines.first.name
    #       #=> "RSAX engine support"
    #
    def name: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_engine.c
    #   - engine.set_default(flag)
    # -->
    # Set the defaults for this engine with the given *flag*.
    #
    # These flags are used to control combinations of algorithm methods.
    #
    # *flag* can be one of the following, other flags are available depending on
    # your OS.
    #
    # All flags
    # :   0xFFFF
    # No flags
    # :   0x0000
    #
    #
    # See also <openssl/engine.h>
    #
    def set_default: (Integer flag) -> bool

    METHOD_ALL: Integer

    METHOD_CIPHERS: Integer

    METHOD_DH: Integer

    METHOD_DIGESTS: Integer

    METHOD_DSA: Integer

    METHOD_NONE: Integer

    METHOD_RAND: Integer

    METHOD_RSA: Integer

    # <!-- rdoc-file=ext/openssl/ossl_engine.c -->
    # This is the generic exception for OpenSSL::Engine related errors
    #
    class EngineError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
  # This module contains configuration information about the SSL extension, for
  # example if socket support is enabled, or the host name TLS extension is
  # enabled.  Constants in this module will always be defined, but contain `true`
  # or `false` values depending on the configuration of your OpenSSL installation.
  #
  module ExtConfig
    HAVE_TLSEXT_HOST_NAME: bool

    OPENSSL_NO_SOCK: bool
  end

  # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
  # OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
  # It is a type of message authentication code (MAC) involving a hash function in
  # combination with a key. HMAC can be used to verify the integrity of a message
  # as well as the authenticity.
  #
  # OpenSSL::HMAC has a similar interface to OpenSSL::Digest.
  #
  # ### HMAC-SHA256 using one-shot interface
  #
  #     key = "key"
  #     data = "message-to-be-authenticated"
  #     mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
  #     #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"
  #
  # ### HMAC-SHA256 using incremental interface
  #
  #     data1 = File.binread("file1")
  #     data2 = File.binread("file2")
  #     key = "key"
  #     hmac = OpenSSL::HMAC.new(key, 'SHA256')
  #     hmac << data1
  #     hmac << data2
  #     mac = hmac.digest
  #
  class HMAC
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - HMAC.digest(digest, key, data) -> aString
    # -->
    # Returns the authentication code as a binary string. The *digest* parameter
    # specifies the digest algorithm to use. This may be a String representing the
    # algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.digest('SHA1', key, data)
    #     #=> "\xDE|\x9B\x85\xB8\xB7\x8A\xA6\xBC\x8Az6\xF7\n\x90p\x1C\x9D\xB4\xD9"
    #
    def self.digest: (String | Digest algo, String key, String data) -> String

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - HMAC.hexdigest(digest, key, data) -> aString
    # -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    def self.hexdigest: (String | Digest algo, String key, String data) -> String

    public

    # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
    # Returns *hmac* updated with the message to be authenticated. Can be called
    # repeatedly with chunks of the message.
    #
    # ### Example
    #
    #     first_chunk = 'The quick brown fox jumps '
    #     second_chunk = 'over the lazy dog'
    #
    #     instance.update(first_chunk)
    #     #=> 5b9a8038a65d571076d97fe783989e52278a492a
    #     instance.update(second_chunk)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #
    alias << update

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/hmac.rb
    #   - ==(other)
    # -->
    # Securely compare with another HMAC instance in constant time.
    #
    def ==: (instance other) -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.digest -> string
    # -->
    # Returns the authentication code an instance represents as a binary string.
    #
    # ### Example
    #     instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance.digest
    #     #=> "\xF4+\xB0\xEE\xB0\x18\xEB\xBDE\x97\xAEr\x13q\x1E\xC6\a`\x84?"
    #
    def digest: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.hexdigest -> string
    # -->
    # Returns the authentication code an instance represents as a hex-encoded
    # string.
    #
    def hexdigest: () -> String

    # <!-- rdoc-file=ext/openssl/lib/openssl/hmac.rb -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    alias inspect hexdigest

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.reset -> self
    # -->
    # Returns *hmac* as it was when it was first initialized, with all processed
    # data cleared from it.
    #
    # ### Example
    #
    #     data = "The quick brown fox jumps over the lazy dog"
    #     instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #
    #     instance.update(data)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #     instance.reset
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #
    def reset: () -> self

    # <!-- rdoc-file=ext/openssl/lib/openssl/hmac.rb -->
    # Returns the authentication code as a hex-encoded string. The *digest*
    # parameter specifies the digest algorithm to use. This may be a String
    # representing the algorithm name or an instance of OpenSSL::Digest.
    #
    # ### Example
    #     key = 'key'
    #     data = 'The quick brown fox jumps over the lazy dog'
    #
    #     hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #     #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
    #
    alias to_s hexdigest

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - hmac.update(string) -> self
    # -->
    # Returns *hmac* updated with the message to be authenticated. Can be called
    # repeatedly with chunks of the message.
    #
    # ### Example
    #
    #     first_chunk = 'The quick brown fox jumps '
    #     second_chunk = 'over the lazy dog'
    #
    #     instance.update(first_chunk)
    #     #=> 5b9a8038a65d571076d97fe783989e52278a492a
    #     instance.update(second_chunk)
    #     #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    #
    def update: (String data) -> self

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - HMAC.new(key, digest) -> hmac
    # -->
    # Returns an instance of OpenSSL::HMAC set with the key and digest algorithm to
    # be used. The instance represents the initial state of the message
    # authentication code before any data has been processed. To process data with
    # it, use the instance method #update with your data as an argument.
    #
    # ### Example
    #
    #     key = 'key'
    #     instance = OpenSSL::HMAC.new(key, 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance.class
    #     #=> OpenSSL::HMAC
    #
    # ### A note about comparisons
    #
    # Two instances can be securely compared with #== in constant time:
    #
    #         other_instance = OpenSSL::HMAC.new('key', 'SHA1')
    #     #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    #     instance == other_instance
    #     #=> true
    #
    def initialize: (String key, String | Digest digest) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_hmac.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void
  end

  # <!-- rdoc-file=ext/openssl/ossl_hmac.c -->
  # Document-class: OpenSSL::HMAC
  #
  # OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
  # It is a type of message authentication code (MAC) involving a hash function in
  # combination with a key. HMAC can be used to verify the integrity of a message
  # as well as the authenticity.
  #
  # OpenSSL::HMAC has a similar interface to OpenSSL::Digest.
  #
  # ### HMAC-SHA256 using one-shot interface
  #
  #     key = "key"
  #     data = "message-to-be-authenticated"
  #     mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
  #     #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"
  #
  # ### HMAC-SHA256 using incremental interface
  #
  #     data1 = File.binread("file1")
  #     data2 = File.binread("file2")
  #     key = "key"
  #     hmac = OpenSSL::HMAC.new(key, 'SHA256')
  #     hmac << data1
  #     hmac << data2
  #     mac = hmac.digest
  #
  class HMACError < OpenSSL::OpenSSLError
  end

  # <!-- rdoc-file=ext/openssl/ossl_kdf.c -->
  # Provides functionality of various KDFs (key derivation function).
  #
  # KDF is typically used for securely deriving arbitrary length symmetric keys to
  # be used with an OpenSSL::Cipher from passwords. Another use case is for
  # storing passwords: Due to the ability to tweak the effort of computation by
  # increasing the iteration count, computation can be slowed down artificially in
  # order to render possible attacks infeasible.
  #
  # Currently, OpenSSL::KDF provides implementations for the following KDF:
  #
  # *   PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination
  #     with HMAC
  # *   scrypt
  # *   HKDF
  #
  #
  # ## Examples
  # ### Generating a 128 bit key for a Cipher (e.g. AES)
  #     pass = "secret"
  #     salt = OpenSSL::Random.random_bytes(16)
  #     iter = 20_000
  #     key_len = 16
  #     key = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
  #                                    length: key_len, hash: "sha1")
  #
  # ### Storing Passwords
  #     pass = "secret"
  #     # store this with the generated value
  #     salt = OpenSSL::Random.random_bytes(16)
  #     iter = 20_000
  #     hash = OpenSSL::Digest.new('SHA256')
  #     len = hash.digest_length
  #     # the final value to be stored
  #     value = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
  #                                      length: len, hash: hash)
  #
  # ## Important Note on Checking Passwords
  # When comparing passwords provided by the user with previously stored values, a
  # common mistake made is comparing the two values using "==". Typically, "=="
  # short-circuits on evaluation, and is therefore vulnerable to timing attacks.
  # The proper way is to use a method that always takes the same amount of time
  # when comparing two values, thus not leaking any information to potential
  # attackers. To do this, use `OpenSSL.fixed_length_secure_compare`.
  #
  module KDF
    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.hkdf(ikm, salt:, info:, length:, hash:) -> String
    # -->
    # HMAC-based Extract-and-Expand Key Derivation Function (HKDF) as specified in
    # [RFC 5869](https://tools.ietf.org/html/rfc5869).
    #
    # New in OpenSSL 1.1.0.
    #
    # ### Parameters
    # *ikm*
    # :   The input keying material.
    # *salt*
    # :   The salt.
    # *info*
    # :   The context and application specific information.
    # *length*
    # :   The output length in octets. Must be <= `255 * HashLen`, where HashLen is
    #     the length of the hash function output in octets.
    # *hash*
    # :   The hash function.
    #
    #
    # ### Example
    #     # The values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1
    #     ikm = ["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*")
    #     salt = ["000102030405060708090a0b0c"].pack("H*")
    #     info = ["f0f1f2f3f4f5f6f7f8f9"].pack("H*")
    #     p OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: 42, hash: "SHA256").unpack1("H*")
    #     # => "3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"
    #
    def self.hkdf: (String ikm, salt: String, info: String, length: Integer, hash: String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.pbkdf2_hmac(pass, salt:, iterations:, length:, hash:) -> aString
    # -->
    # PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with
    # HMAC. Takes *pass*, *salt* and *iterations*, and then derives a key of
    # *length* bytes.
    #
    # For more information about PBKDF2, see RFC 2898 Section 5.2
    # (https://tools.ietf.org/html/rfc2898#section-5.2).
    #
    # ### Parameters
    # pass
    # :   The passphrase.
    # salt
    # :   The salt. Salts prevent attacks based on dictionaries of common passwords
    #     and attacks based on rainbow tables. It is a public value that can be
    #     safely stored along with the password (e.g. if the derived value is used
    #     for password storage).
    # iterations
    # :   The iteration count. This provides the ability to tune the algorithm. It
    #     is better to use the highest count possible for the maximum resistance to
    #     brute-force attacks.
    # length
    # :   The desired length of the derived key in octets.
    # hash
    # :   The hash algorithm used with HMAC for the PRF. May be a String
    #     representing the algorithm name, or an instance of OpenSSL::Digest.
    #
    def self.pbkdf2_hmac: (String pass, salt: String, iterations: Integer, length: Integer, hash: String | Digest) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_kdf.c
    #   - KDF.scrypt(pass, salt:, N:, r:, p:, length:) -> aString
    # -->
    # Derives a key from *pass* using given parameters with the scrypt
    # password-based key derivation function. The result can be used for password
    # storage.
    #
    # scrypt is designed to be memory-hard and more secure against brute-force
    # attacks using custom hardwares than alternative KDFs such as PBKDF2 or bcrypt.
    #
    # The keyword arguments *N*, *r* and *p* can be used to tune scrypt. RFC 7914
    # (published on 2016-08, https://tools.ietf.org/html/rfc7914#section-2) states
    # that using values r=8 and p=1 appears to yield good results.
    #
    # See RFC 7914 (https://tools.ietf.org/html/rfc7914) for more information.
    #
    # ### Parameters
    # pass
    # :   Passphrase.
    # salt
    # :   Salt.
    # N
    # :   CPU/memory cost parameter. This must be a power of 2.
    # r
    # :   Block size parameter.
    # p
    # :   Parallelization parameter.
    # length
    # :   Length in octets of the derived key.
    #
    #
    # ### Example
    #     pass = "password"
    #     salt = SecureRandom.random_bytes(16)
    #     dk = OpenSSL::KDF.scrypt(pass, salt: salt, N: 2**14, r: 8, p: 1, length: 32)
    #     p dk #=> "\xDA\xE4\xE2...\x7F\xA1\x01T"
    #
    def self.scrypt: (String pass, salt: String, N: Integer, r: Integer, p: Integer, length: Integer) -> String

    private

    def hkdf: (*untyped) -> untyped

    def pbkdf2_hmac: (*untyped) -> untyped

    def scrypt: (*untyped) -> untyped

    # <!-- rdoc-file=ext/openssl/ossl_kdf.c -->
    # Generic exception class raised if an error occurs in OpenSSL::KDF module.
    #
    class KDFError < OpenSSL::OpenSSLError
    end
  end

  module Marshal
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
    #   - included(base)
    # -->
    #
    def self.included: (untyped base) -> untyped

    public

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
    #   - _dump(_level)
    # -->
    #
    def _dump: (untyped _level) -> untyped

    module ClassMethods
      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/marshal.rb
      #   - _load(string)
      # -->
      #
      def _load: (untyped string) -> untyped
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
  # OpenSSL::Netscape is a namespace for SPKI (Simple Public Key Infrastructure)
  # which implements Signed Public Key and Challenge. See [RFC
  # 2692](http://tools.ietf.org/html/rfc2692) and [RFC
  # 2693](http://tools.ietf.org/html/rfc2692) for details.
  #
  module Netscape
    # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
    # A Simple Public Key Infrastructure implementation (pronounced "spooky"). The
    # structure is defined as
    #     PublicKeyAndChallenge ::= SEQUENCE {
    #       spki SubjectPublicKeyInfo,
    #       challenge IA5STRING
    #     }
    #
    #     SignedPublicKeyAndChallenge ::= SEQUENCE {
    #       publicKeyAndChallenge PublicKeyAndChallenge,
    #       signatureAlgorithm AlgorithmIdentifier,
    #       signature BIT STRING
    #     }
    #
    # where the definitions of SubjectPublicKeyInfo and AlgorithmIdentifier can be
    # found in RFC5280. SPKI is typically used in browsers for generating a
    # public/private key pair and a subsequent certificate request, using the HTML
    # <keygen> element.
    #
    # ## Examples
    #
    # ### Creating an SPKI
    #     key = OpenSSL::PKey::RSA.new 2048
    #     spki = OpenSSL::Netscape::SPKI.new
    #     spki.challenge = "RandomChallenge"
    #     spki.public_key = key.public_key
    #     spki.sign(key, OpenSSL::Digest.new('SHA256'))
    #     #send a request containing this to a server generating a certificate
    #
    # ### Verifying an SPKI request
    #     request = #...
    #     spki = OpenSSL::Netscape::SPKI.new request
    #     unless spki.verify(spki.public_key)
    #       # signature is invalid
    #     end
    #     #proceed
    #
    class SPKI
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.challenge => string
      # -->
      # Returns the challenge string associated with this SPKI.
      #
      def challenge: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.challenge = str => string
      # -->
      # ### Parameters
      # *   *str* - the challenge string to be set for this instance
      #
      #
      # Sets the challenge to be associated with the SPKI. May be used by the server,
      # e.g. to prevent replay.
      #
      def challenge=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.public_key => pkey
      # -->
      # Returns the public key associated with the SPKI, an instance of OpenSSL::PKey.
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.public_key = pub => pkey
      # -->
      # ### Parameters
      # *   *pub* - the public key to be set for this instance
      #
      #
      # Sets the public key to be associated with the SPKI, an instance of
      # OpenSSL::PKey. This should be the public key corresponding to the private key
      # used for signing the SPKI.
      #
      def public_key=: (PKey::PKey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.sign(key, digest) => spki
      # -->
      # ### Parameters
      # *   *key* - the private key to be used for signing this instance
      # *   *digest* - the digest to be used for signing this instance
      #
      #
      # To sign an SPKI, the private key corresponding to the public key set for this
      # instance should be used, in addition to a digest algorithm in the form of an
      # OpenSSL::Digest. The private key should be an instance of OpenSSL::PKey.
      #
      def sign: (PKey::PKey key, Digest digest) -> instance

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_der => DER-encoded string
      # -->
      # Returns the DER encoding of this SPKI.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_pem => PEM-encoded string
      # -->
      # Returns the PEM encoding of this SPKI.
      #
      def to_pem: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
      # Returns the PEM encoding of this SPKI.
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.to_text => string
      # -->
      # Returns a textual representation of this SPKI, useful for debugging purposes.
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - spki.verify(key) => boolean
      # -->
      # ### Parameters
      # *   *key* - the public key to be used for verifying the SPKI signature
      #
      #
      # Returns `true` if the signature is valid, `false` otherwise. To verify an
      # SPKI, the public key contained within the SPKI should be used.
      #
      def verify: (PKey::PKey key) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ns_spki.c
      #   - SPKI.new([request]) => spki
      # -->
      # ### Parameters
      # *   *request* - optional raw request, either in PEM or DER format.
      #
      def initialize: (?String request) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ns_spki.c -->
    # Generic Exception class that is raised if an error occurs during an operation
    # on an instance of OpenSSL::Netscape::SPKI.
    #
    class SPKIError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
  # OpenSSL::OCSP implements Online Certificate Status Protocol requests and
  # responses.
  #
  # Creating and sending an OCSP request requires a subject certificate that
  # contains an OCSP URL in an authorityInfoAccess extension and the issuer
  # certificate for the subject certificate.  First, load the issuer and subject
  # certificates:
  #
  #     subject = OpenSSL::X509::Certificate.new subject_pem
  #     issuer  = OpenSSL::X509::Certificate.new issuer_pem
  #
  # To create the request we need to create a certificate ID for the subject
  # certificate so the CA knows which certificate we are asking about:
  #
  #     digest = OpenSSL::Digest.new('SHA1')
  #     certificate_id =
  #       OpenSSL::OCSP::CertificateId.new subject, issuer, digest
  #
  # Then create a request and add the certificate ID to it:
  #
  #     request = OpenSSL::OCSP::Request.new
  #     request.add_certid certificate_id
  #
  # Adding a nonce to the request protects against replay attacks but not all CA
  # process the nonce.
  #
  #     request.add_nonce
  #
  # To submit the request to the CA for verification we need to extract the OCSP
  # URI from the subject certificate:
  #
  #     ocsp_uris = subject.ocsp_uris
  #
  #     require 'uri'
  #
  #     ocsp_uri = URI ocsp_uris[0]
  #
  # To submit the request we'll POST the request to the OCSP URI (per RFC 2560).
  # Note that we only handle HTTP requests and don't handle any redirects in this
  # example, so this is insufficient for serious use.
  #
  #     require 'net/http'
  #
  #     http_response =
  #       Net::HTTP.start ocsp_uri.hostname, ocsp.port do |http|
  #         http.post ocsp_uri.path, request.to_der,
  #                   'content-type' => 'application/ocsp-request'
  #     end
  #
  #     response = OpenSSL::OCSP::Response.new http_response.body
  #     response_basic = response.basic
  #
  # First we check if the response has a valid signature.  Without a valid
  # signature we cannot trust it.  If you get a failure here you may be missing a
  # system certificate store or may be missing the intermediate certificates.
  #
  #     store = OpenSSL::X509::Store.new
  #     store.set_default_paths
  #
  #     unless response_basic.verify [], store then
  #       raise 'response is not signed by a trusted certificate'
  #     end
  #
  # The response contains the status information (success/fail).  We can display
  # the status as a string:
  #
  #     puts response.status_string #=> successful
  #
  # Next we need to know the response details to determine if the response matches
  # our request.  First we check the nonce.  Again, not all CAs support a nonce.
  # See Request#check_nonce for the meanings of the return values.
  #
  #     p request.check_nonce basic_response #=> value from -1 to 3
  #
  # Then extract the status information for the certificate from the basic
  # response.
  #
  #     single_response = basic_response.find_response(certificate_id)
  #
  #     unless single_response
  #       raise 'basic_response does not have the status for the certificate'
  #     end
  #
  # Then check the validity. A status issued in the future must be rejected.
  #
  #     unless single_response.check_validity
  #       raise 'this_update is in the future or next_update time has passed'
  #     end
  #
  #     case single_response.cert_status
  #     when OpenSSL::OCSP::V_CERTSTATUS_GOOD
  #       puts 'certificate is still valid'
  #     when OpenSSL::OCSP::V_CERTSTATUS_REVOKED
  #       puts "certificate has been revoked at #{single_response.revocation_time}"
  #     when OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN
  #       puts 'responder doesn't know about the certificate'
  #     end
  #
  module OCSP
    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # (This flag is not used by OpenSSL 1.0.1g)
    #
    NOCASIGN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not include certificates in the response
    #
    NOCERTS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify the certificate chain on the response
    #
    NOCHAIN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not make additional signing certificate checks
    #
    NOCHECKS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # (This flag is not used by OpenSSL 1.0.1g)
    #
    NODELEGATED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not check trust
    #
    NOEXPLICIT: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not search certificates contained in the response for a signer
    #
    NOINTERN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not check the signature on the response
    #
    NOSIGS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not include producedAt time in response
    #
    NOTIME: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify the response at all
    #
    NOVERIFY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Identify the response by signing the certificate key ID
    #
    RESPID_KEY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Internal error in issuer
    #
    RESPONSE_STATUS_INTERNALERROR: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Illegal confirmation request
    #
    RESPONSE_STATUS_MALFORMEDREQUEST: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # You must sign the request and resubmit
    #
    RESPONSE_STATUS_SIGREQUIRED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Response has valid confirmations
    #
    RESPONSE_STATUS_SUCCESSFUL: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Try again later
    #
    RESPONSE_STATUS_TRYLATER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Your request is unauthorized.
    #
    RESPONSE_STATUS_UNAUTHORIZED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate subject's name or other information changed
    #
    REVOKED_STATUS_AFFILIATIONCHANGED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # This CA certificate was revoked due to a key compromise
    #
    REVOKED_STATUS_CACOMPROMISE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate is on hold
    #
    REVOKED_STATUS_CERTIFICATEHOLD: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate is no longer needed
    #
    REVOKED_STATUS_CESSATIONOFOPERATION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked due to a key compromise
    #
    REVOKED_STATUS_KEYCOMPROMISE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked for an unknown reason
    #
    REVOKED_STATUS_NOSTATUS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was previously on hold and should now be removed from the CRL
    #
    REVOKED_STATUS_REMOVEFROMCRL: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was superseded by a new certificate
    #
    REVOKED_STATUS_SUPERSEDED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The certificate was revoked for an unspecified reason
    #
    REVOKED_STATUS_UNSPECIFIED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Do not verify additional certificates
    #
    TRUSTOTHER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the certificate is not revoked but does not necessarily mean the
    # certificate was issued or that this response is within the certificate's
    # validity interval
    #
    V_CERTSTATUS_GOOD: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the certificate has been revoked either permanently or temporarily
    # (on hold).
    #
    V_CERTSTATUS_REVOKED: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # Indicates the responder does not know about the certificate being requested.
    #
    V_CERTSTATUS_UNKNOWN: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The responder ID is based on the public key.
    #
    V_RESPID_KEY: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # The responder ID is based on the key name.
    #
    V_RESPID_NAME: Integer

    type ocsp_status = Integer

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::BasicResponse contains the status of a certificate check
    # which is created from an OpenSSL::OCSP::Request.  A BasicResponse is more
    # detailed than a Response.
    #
    class BasicResponse
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.add_nonce(nonce = nil)
      # -->
      # Adds *nonce* to this response.  If no nonce was provided a random nonce will
      # be added.
      #
      def add_nonce: (?String nonce) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.add_status(certificate_id, status, reason, revocation_time, this_update, next_update, extensions) -> basic_response
      # -->
      # Adds a certificate status for *certificate_id*. *status* is the status, and
      # must be one of these:
      #
      # *   OpenSSL::OCSP::V_CERTSTATUS_GOOD
      # *   OpenSSL::OCSP::V_CERTSTATUS_REVOKED
      # *   OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN
      #
      #
      # *reason* and *revocation_time* can be given only when *status* is
      # OpenSSL::OCSP::V_CERTSTATUS_REVOKED. *reason* describes the reason for the
      # revocation, and must be one of OpenSSL::OCSP::REVOKED_STATUS_* constants.
      # *revocation_time* is the time when the certificate is revoked.
      #
      # *this_update* and *next_update* indicate the time at which the status is
      # verified to be correct and the time at or before which newer information will
      # be available, respectively. *next_update* is optional.
      #
      # *extensions* is an Array of OpenSSL::X509::Extension to be included in the
      # SingleResponse. This is also optional.
      #
      # Note that the times, *revocation_time*, *this_update* and *next_update* can be
      # specified in either of Integer or Time object. If they are Integer, it is
      # treated as the relative seconds from the current time.
      #
      def add_status: (CertificateId certificate_id, ocsp_status status, Integer? reason, Integer? revocation_time, ?Integer | Time this_update, ?Integer | Time next_update, ?Array[X509::Extension] extensions) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.copy_nonce(request) -> Integer
      # -->
      # Copies the nonce from *request* into this response.  Returns 1 on success and
      # 0 on failure.
      #
      def copy_nonce: (Request request) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.find_response(certificate_id) -> SingleResponse | nil
      # -->
      # Returns a SingleResponse whose CertId matches with *certificate_id*, or `nil`
      # if this BasicResponse does not contain it.
      #
      def find_response: (CertificateId certificate_id) -> SingleResponse?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.responses -> Array of SingleResponse
      # -->
      # Returns an Array of SingleResponse for this BasicResponse.
      #
      def responses: () -> Array[SingleResponse]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.sign(cert, key, certs = nil, flags = 0, digest = nil) -> self
      # -->
      # Signs this OCSP response using the *cert*, *key* and optional *digest*. This
      # behaves in the similar way as OpenSSL::OCSP::Request#sign.
      #
      # *flags* can include:
      # OpenSSL::OCSP::NOCERTS
      # :   don't include certificates
      # OpenSSL::OCSP::NOTIME
      # :   don't set producedAt
      # OpenSSL::OCSP::RESPID_KEY
      # :   use signer's public key hash as responderID
      #
      def sign: (X509::Certificate cert, PKey::PKey key, ?Array[X509::Certificate] certs, ?Integer flags, ?Digest digest) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.status -> statuses
      # -->
      # Returns an Array of statuses for this response.  Each status contains a
      # CertificateId, the status (0 for good, 1 for revoked, 2 for unknown), the
      # reason for the status, the revocation time, the time of this update, the time
      # for the next update and a list of OpenSSL::X509::Extension.
      #
      # This should be superseded by BasicResponse#responses and #find_response that
      # return SingleResponse.
      #
      def status: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.to_der -> String
      # -->
      # Encodes this basic response into a DER-encoded string.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - basic_response.verify(certificates, store, flags = 0) -> true or false
      # -->
      # Verifies the signature of the response using the given *certificates* and
      # *store*. This works in the similar way as OpenSSL::OCSP::Request#verify.
      #
      def verify: (Array[X509::Certificate] certs, X509::Store store, ?Integer flags) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::BasicResponse.new(der_string = nil) -> basic_response
      # -->
      # Creates a new BasicResponse. If *der_string* is given, decodes *der_string* as
      # DER.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::CertificateId identifies a certificate to the CA so that a
    # status check can be performed.
    #
    class CertificateId
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.cmp(other) -> true or false
      # -->
      # Compares this certificate id with *other* and returns `true` if they are the
      # same.
      #
      def cmp: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.cmp_issuer(other) -> true or false
      # -->
      # Compares this certificate id's issuer with *other* and returns `true` if they
      # are the same.
      #
      def cmp_issuer: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.hash_algorithm -> String
      # -->
      # Returns the ln (long name) of the hash algorithm used to generate the
      # issuerNameHash and the issuerKeyHash values.
      #
      def hash_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.issuer_key_hash -> String
      # -->
      # Returns the issuerKeyHash of this certificate ID, the hash of the issuer's
      # public key.
      #
      def issuer_key_hash: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.issuer_name_hash -> String
      # -->
      # Returns the issuerNameHash of this certificate ID, the hash of the issuer's
      # distinguished name calculated with the hashAlgorithm.
      #
      def issuer_name_hash: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.serial -> Integer
      # -->
      # Returns the serial number of the certificate for which status is being
      # requested.
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - certificate_id.to_der -> String
      # -->
      # Encodes this certificate identifier into a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::CertificateId.new(subject, issuer, digest = nil) -> certificate_id
      #   - OpenSSL::OCSP::CertificateId.new(der_string)                    -> certificate_id
      #   - OpenSSL::OCSP::CertificateId.new(obj)                           -> certificate_id
      # -->
      # Creates a new OpenSSL::OCSP::CertificateId for the given *subject* and
      # *issuer* X509 certificates.  The *digest* is a digest algorithm that is used
      # to compute the hash values. This defaults to SHA-1.
      #
      # If only one argument is given, decodes it as DER representation of a
      # certificate ID or generates certificate ID from the object that responds to
      # the to_der method.
      #
      def initialize: (String | ASN1::_ToDer der) -> void
                    | (X509::Certificate subject, X509::Certificate issuer, ?Digest digest) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # OCSP error class.
    #
    class OCSPError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::Request contains the certificate information for determining
    # if a certificate has been revoked or not.  A Request can be created for a
    # certificate or from a DER-encoded request created elsewhere.
    #
    class Request
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.add_certid(certificate_id) -> request
      # -->
      # Adds *certificate_id* to the request.
      #
      def add_certid: (CertificateId certificate_id) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.add_nonce(nonce = nil) -> request
      # -->
      # Adds a *nonce* to the OCSP request.  If no nonce is given a random one will be
      # generated.
      #
      # The nonce is used to prevent replay attacks but some servers do not support
      # it.
      #
      def add_nonce: (?String nonce) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.certid -> [certificate_id, ...]
      # -->
      # Returns all certificate IDs in this request.
      #
      def certid: () -> Array[CertificateId]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.check_nonce(response) -> result
      # -->
      # Checks the nonce validity for this request and *response*.
      #
      # The return value is one of the following:
      #
      # -1
      # :   nonce in request only.
      # 0
      # :   nonces both present and not equal.
      # 1
      # :   nonces present and equal.
      # 2
      # :   nonces both absent.
      # 3
      # :   nonce present in response only.
      #
      #
      # For most responses, clients can check *result* > 0.  If a responder doesn't
      # handle nonces `result.nonzero?` may be necessary.  A result of `0` is always
      # an error.
      #
      def check_nonce: (Response response) -> (-1 | 0 | 1 | 2 | 3)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.sign(cert, key, certs = nil, flags = 0, digest = nil) -> self
      # -->
      # Signs this OCSP request using *cert*, *key* and optional *digest*. If *digest*
      # is not specified, SHA-1 is used. *certs* is an optional Array of additional
      # certificates which are included in the request in addition to the signer
      # certificate. Note that if *certs* is `nil` or not given, flag
      # OpenSSL::OCSP::NOCERTS is enabled. Pass an empty array to include only the
      # signer certificate.
      #
      # *flags* is a bitwise OR of the following constants:
      #
      # OpenSSL::OCSP::NOCERTS
      # :   Don't include any certificates in the request. *certs* will be ignored.
      #
      def sign: (X509::Certificate cert, PKey::PKey key, ?Array[X509::Certificate] certs, ?Integer flags, ?Digest digest) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.signed? -> true or false
      # -->
      # Returns `true` if the request is signed, `false` otherwise. Note that the
      # validity of the signature is **not** checked. Use #verify to verify that.
      #
      def signed?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - to_der()
      # -->
      # Returns this request as a DER-encoded string
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - request.verify(certificates, store, flags = 0) -> true or false
      # -->
      # Verifies this request using the given *certificates* and *store*.
      # *certificates* is an array of OpenSSL::X509::Certificate, *store* is an
      # OpenSSL::X509::Store.
      #
      # Note that `false` is returned if the request does not have a signature. Use
      # #signed? to check whether the request is signed or not.
      #
      def verify: (Array[X509::Certificate] certs, X509::Store store, ?Integer flags) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Request.new              -> request
      #   - OpenSSL::OCSP::Request.new(request_der) -> request
      # -->
      # Creates a new OpenSSL::OCSP::Request.  The request may be created empty or
      # from a *request_der* string.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::Response contains the status of a certificate check which is
    # created from an OpenSSL::OCSP::Request.
    #
    class Response
      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Response.create(status, basic_response = nil) -> response
      # -->
      # Creates an OpenSSL::OCSP::Response from *status* and *basic_response*.
      #
      def self.create: (Integer status, ?BasicResponse response) -> instance

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.basic
      # -->
      # Returns a BasicResponse for this response
      #
      def basic: () -> BasicResponse?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.status -> Integer
      # -->
      # Returns the status of the response.
      #
      def status: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.status_string -> String
      # -->
      # Returns a status string for the response.
      #
      def status_string: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - response.to_der -> String
      # -->
      # Returns this response as a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::Response.new               -> response
      #   - OpenSSL::OCSP::Response.new(response_der) -> response
      # -->
      # Creates a new OpenSSL::OCSP::Response.  The response may be created empty or
      # from a *response_der* string.
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ocsp.c -->
    # An OpenSSL::OCSP::SingleResponse represents an OCSP SingleResponse structure,
    # which contains the basic information of the status of the certificate.
    #
    class SingleResponse
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.cert_status -> Integer
      # -->
      # Returns the status of the certificate identified by the certid. The return
      # value may be one of these constant:
      #
      # *   V_CERTSTATUS_GOOD
      # *   V_CERTSTATUS_REVOKED
      # *   V_CERTSTATUS_UNKNOWN
      #
      #
      # When the status is V_CERTSTATUS_REVOKED, the time at which the certificate was
      # revoked can be retrieved by #revocation_time.
      #
      def cert_status: () -> ocsp_status

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.certid -> CertificateId
      # -->
      # Returns the CertificateId for which this SingleResponse is.
      #
      def certid: () -> CertificateId

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.check_validity(nsec = 0, maxsec = -1) -> true | false
      # -->
      # Checks the validity of thisUpdate and nextUpdate fields of this
      # SingleResponse. This checks the current time is within the range thisUpdate to
      # nextUpdate.
      #
      # It is possible that the OCSP request takes a few seconds or the time is not
      # accurate. To avoid rejecting a valid response, this method allows the times to
      # be within *nsec* seconds of the current time.
      #
      # Some responders don't set the nextUpdate field. This may cause a very old
      # response to be considered valid. The *maxsec* parameter can be used to limit
      # the age of responses.
      #
      def check_validity: (?Integer nsec, ?Integer maxsec) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.extensions -> Array of X509::Extension
      # -->
      #
      def extensions: () -> Array[X509::Certificate]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.next_update -> Time | nil
      # -->
      #
      def next_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.revocation_reason -> Integer | nil
      # -->
      #
      def revocation_reason: () -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.revocation_time -> Time | nil
      # -->
      #
      def revocation_time: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.this_update -> Time
      # -->
      #
      def this_update: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - single_response.to_der -> String
      # -->
      # Encodes this SingleResponse into a DER-encoded string.
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - OpenSSL::OCSP::SingleResponse.new(der_string) -> SingleResponse
      # -->
      # Creates a new SingleResponse from *der_string*.
      #
      def initialize: (String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ocsp.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl.c -->
  # Generic error, common for all classes under OpenSSL module
  #
  class OpenSSLError < StandardError
  end

  # <!-- rdoc-file=ext/openssl/ossl_pkcs12.c -->
  # Defines a file format commonly used to store private keys with accompanying
  # public key certificates, protected with a password-based symmetric key.
  #
  class PKCS12
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - PKCS12.create(pass, name, key, cert [, ca, [, key_pbe [, cert_pbe [, key_iter [, mac_iter [, keytype]]]]]])
    # -->
    # ### Parameters
    # *   *pass* - string
    # *   *name* - A string describing the key.
    # *   *key* - Any PKey.
    # *   *cert* - A X509::Certificate.
    #     *   The public_key portion of the certificate must contain a valid public
    #         key.
    #     *   The not_before and not_after fields must be filled in.
    #
    # *   *ca* - An optional array of X509::Certificate's.
    # *   *key_pbe* - string
    # *   *cert_pbe* - string
    # *   *key_iter* - integer
    # *   *mac_iter* - integer
    # *   *keytype* - An integer representing an MSIE specific extension.
    #
    #
    # Any optional arguments may be supplied as `nil` to preserve the OpenSSL
    # defaults.
    #
    # See the OpenSSL documentation for PKCS12_create().
    #
    def self.create: (String pass, String name, PKey::PKey key, X509::Certificate cert, ?Array[X509::Certificate]? ca, ?String? key_pbe, ?String? cert_pbe, ?Integer? key_iter, ?Integer? mac_iter, ?Integer? keytype) -> instance

    public

    def ca_certs: () -> Array[X509::Certificate]?

    def certificate: () -> X509::Certificate

    def key: () -> PKey::PKey

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - to_der()
    # -->
    #
    def to_der: () -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - PKCS12.new -> pkcs12
    #   - PKCS12.new(str) -> pkcs12
    #   - PKCS12.new(str, pass) -> pkcs12
    # -->
    # ### Parameters
    # *   *str* - Must be a DER encoded PKCS12 string.
    # *   *pass* - string
    #
    def initialize: (?String der, ?String pass) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs12.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> void

    class PKCS12Error < OpenSSL::OpenSSLError
    end
  end

  module PKCS5
    def self.pbkdf2_hmac: (String pass, String salt, Integer iter, Integer keylen, String | Digest digest) -> String

    def self.pbkdf2_hmac_sha1: (String pass, String salt, Integer iter, Integer keylen) -> String

    private

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/pkcs5.rb
    #   - pbkdf2_hmac(pass, salt, iter, keylen, digest)
    # -->
    # OpenSSL::PKCS5.pbkdf2_hmac has been renamed to OpenSSL::KDF.pbkdf2_hmac. This
    # method is provided for backwards compatibility.
    #
    def pbkdf2_hmac: (untyped pass, untyped salt, untyped iter, untyped keylen, untyped digest) -> untyped

    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/pkcs5.rb
    #   - pbkdf2_hmac_sha1(pass, salt, iter, keylen)
    # -->
    #
    def pbkdf2_hmac_sha1: (untyped pass, untyped salt, untyped iter, untyped keylen) -> untyped
  end

  class PKCS7
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.encrypt(certs, data, [, cipher [, flags]]) => pkcs7
    # -->
    #
    def self.encrypt: (X509::Certificate certs, String data, ?Cipher cipher, ?Integer flags) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.read_smime(string) => pkcs7
    # -->
    #
    def self.read_smime: (String) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.sign(cert, key, data, [, certs [, flags]]) => pkcs7
    # -->
    #
    def self.sign: (X509::Certificate certs, PKey::PKey key, String data, ?OpenSSL::Cipher cipher, ?Integer flags) -> instance

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.write_smime(pkcs7 [, data [, flags]]) => string
    # -->
    #
    def self.write_smime: (instance pkcs7, ?String data, ?Integer flags) -> String

    public

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_certificate(p1)
    # -->
    #
    def add_certificate: (X509::Certificate cert) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_crl(p1)
    # -->
    #
    def add_crl: (X509::CRL crl) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_data(p1)
    # -->
    #
    def add_data: (String data) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_recipient(p1)
    # -->
    #
    def add_recipient: (RecipientInfo recipient) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - add_signer(p1)
    # -->
    #
    def add_signer: (SignerInfo signer) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - certificates()
    # -->
    #
    def certificates: () -> Array[X509::Certificate]?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - certificates=(p1)
    # -->
    #
    def certificates=: (Array[X509::Certificate]) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - cipher=(p1)
    # -->
    #
    def cipher=: (Cipher cipher) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - crls()
    # -->
    #
    def crls: () -> Array[X509::CRL]?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - crls=(p1)
    # -->
    #
    def crls=: (Array[X509::CRL]) -> self

    def data: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - data=(p1)
    # -->
    #
    alias data= add_data

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - decrypt(p1, p2 = v2, p3 = v3)
    # -->
    #
    def decrypt: (PKey::PKey p1, ?PKey::PKey p2, ?PKey::PKey p3) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached()
    # -->
    #
    def detached: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached=(p1)
    # -->
    #
    def detached=: [U] (boolish) -> U

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - detached?()
    # -->
    #
    def detached?: () -> bool

    def error_string: () -> String?

    def error_string=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - recipients()
    # -->
    #
    def recipients: () -> Array[RecipientInfo]

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - signers()
    # -->
    #
    def signers: () -> Array[SignerInfo]

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_der()
    # -->
    #
    def to_der: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_pem()
    # -->
    #
    def to_pem: () -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - to_s()
    # -->
    #
    alias to_s to_pem

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - pkcs7.type => string or nil
    # -->
    #
    def type: () -> String?

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - pkcs7.type = type => type
    # -->
    #
    def type=: (String) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - verify(p1, p2, p3 = v3, p4 = v4)
    # -->
    #
    def verify: (PKey::PKey p1, PKey::PKey p2, ?PKey::PKey p3, ?PKey::PKey p4) -> bool

    private

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - PKCS7.new => pkcs7
    #   - PKCS7.new(string) => pkcs7
    # -->
    # Many methods in this class aren't documented.
    #
    def initialize: (?String der) -> void

    # <!--
    #   rdoc-file=ext/openssl/ossl_pkcs7.c
    #   - initialize_copy(p1)
    # -->
    #
    def initialize_copy: (instance) -> untyped

    BINARY: Integer

    DETACHED: Integer

    NOATTR: Integer

    NOCERTS: Integer

    NOCHAIN: Integer

    NOINTERN: Integer

    NOSIGS: Integer

    NOSMIMECAP: Integer

    NOVERIFY: Integer

    TEXT: Integer

    class PKCS7Error < OpenSSL::OpenSSLError
    end

    class RecipientInfo
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - enc_key()
      # -->
      #
      def enc_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - new(p1)
      # -->
      #
      def initialize: (X509::Certificate certificate) -> void
    end

    class SignerInfo
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - signed_time()
      # -->
      #
      def signed_time: () -> Time?

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkcs7.c
      #   - new(p1, p2, p3)
      # -->
      #
      def initialize: (X509::Certificate certificate, PKey::PKey key, Digest digest) -> void
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
  # ## Asymmetric Public Key Algorithms
  #
  # Asymmetric public key algorithms solve the problem of establishing and sharing
  # secret keys to en-/decrypt messages. The key in such an algorithm consists of
  # two parts: a public key that may be distributed to others and a private key
  # that needs to remain secret.
  #
  # Messages encrypted with a public key can only be decrypted by recipients that
  # are in possession of the associated private key. Since public key algorithms
  # are considerably slower than symmetric key algorithms (cf. OpenSSL::Cipher)
  # they are often used to establish a symmetric key shared between two parties
  # that are in possession of each other's public key.
  #
  # Asymmetric algorithms offer a lot of nice features that are used in a lot of
  # different areas. A very common application is the creation and validation of
  # digital signatures. To sign a document, the signatory generally uses a message
  # digest algorithm (cf. OpenSSL::Digest) to compute a digest of the document
  # that is then encrypted (i.e. signed) using the private key. Anyone in
  # possession of the public key may then verify the signature by computing the
  # message digest of the original document on their own, decrypting the signature
  # using the signatory's public key and comparing the result to the message
  # digest they previously computed. The signature is valid if and only if the
  # decrypted signature is equal to this message digest.
  #
  # The PKey module offers support for three popular public/private key
  # algorithms:
  # *   RSA (OpenSSL::PKey::RSA)
  # *   DSA (OpenSSL::PKey::DSA)
  # *   Elliptic Curve Cryptography (OpenSSL::PKey::EC)
  #
  # Each of these implementations is in fact a sub-class of the abstract PKey
  # class which offers the interface for supporting digital signatures in the form
  # of PKey#sign and PKey#verify.
  #
  # ## Diffie-Hellman Key Exchange
  #
  # Finally PKey also features OpenSSL::PKey::DH, an implementation of the
  # Diffie-Hellman key exchange protocol based on discrete logarithms in finite
  # fields, the same basis that DSA is built on. The Diffie-Hellman protocol can
  # be used to exchange (symmetric) keys over insecure channels without needing
  # any prior joint knowledge between the participating parties. As the security
  # of DH demands relatively long "public keys" (i.e. the part that is overtly
  # transmitted between participants) DH tends to be quite slow. If security or
  # speed is your primary concern, OpenSSL::PKey::EC offers another implementation
  # of the Diffie-Hellman protocol.
  #
  module PKey
    # <!--
    #   rdoc-file=ext/openssl/ossl_pkey.c
    #   - OpenSSL::PKey.read(string [, pwd ]) -> PKey
    #   - OpenSSL::PKey.read(io [, pwd ]) -> PKey
    # -->
    # Reads a DER or PEM encoded string from *string* or *io* and returns an
    # instance of the appropriate PKey class.
    #
    # ### Parameters
    # *   *string* is a DER- or PEM-encoded string containing an arbitrary private
    #     or public key.
    # *   *io* is an instance of IO containing a DER- or PEM-encoded arbitrary
    #     private or public key.
    # *   *pwd* is an optional password in case *string* or *io* is an encrypted PEM
    #     resource.
    #
    def self?.read: (String | IO pem, ?String password) -> PKey

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
    # An implementation of the Diffie-Hellman key exchange protocol based on
    # discrete logarithms in finite fields, the same basis that DSA is built on.
    #
    # ### Accessor methods for the Diffie-Hellman parameters
    # DH#p
    # :   The prime (an OpenSSL::BN) of the Diffie-Hellman parameters.
    # DH#g
    # :   The generator (an OpenSSL::BN) g of the Diffie-Hellman parameters.
    # DH#pub_key
    # :   The per-session public key (an OpenSSL::BN) matching the private key. This
    #     needs to be passed to DH#compute_key.
    # DH#priv_key
    # :   The per-session private key, an OpenSSL::BN.
    #
    #
    # ### Example of a key exchange
    #     # you may send the parameters (der) and own public key (pub1) publicly
    #     # to the participating party
    #     dh1 = OpenSSL::PKey::DH.new(2048)
    #     der = dh1.to_der
    #     pub1 = dh1.pub_key
    #
    #     # the other party generates its per-session key pair
    #     dhparams = OpenSSL::PKey::DH.new(der)
    #     dh2 = OpenSSL::PKey.generate_key(dhparams)
    #     pub2 = dh2.pub_key
    #
    #     symm_key1 = dh1.compute_key(pub2)
    #     symm_key2 = dh2.compute_key(pub1)
    #     puts symm_key1 == symm_key2 # => true
    #
    class DH < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - DH.generate(size, generator = 2) -> dh
      # -->
      # Creates a new DH instance from scratch by generating random parameters and a
      # key pair.
      #
      # See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      # `generator`
      # :   The generator.
      #
      def self.generate: (Integer size, ?Integer generator) -> instance

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.compute_key(pub_bn) -> string
      # -->
      # Returns a String containing a shared secret computed from the other party's
      # public value.
      #
      # This method is provided for backwards compatibility, and calls #derive
      # internally.
      #
      # ### Parameters
      # *   *pub_bn* is a OpenSSL::BN, **not** the DH instance returned by
      #     DH#public_key as that contains the DH parameters only.
      #
      def compute_key: (bn pub_bn) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.export -> aString
      #   - dh.to_pem -> aString
      #   - dh.to_s -> aString
      # -->
      # Encodes this DH to its PEM encoding. Note that any existing per-session
      # public/private keys will **not** get encoded, just the Diffie-Hellman
      # parameters will be encoded.
      #
      def export: () -> String

      def g: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.generate_key! -> self
      # -->
      # Generates a private and public key unless a private key already exists. If
      # this DH instance was generated from public DH parameters (e.g. by encoding the
      # result of DH#public_key), then this method needs to be called first in order
      # to generate the per-session keys before performing the actual key exchange.
      #
      # **Deprecated in version 3.0**. This method is incompatible with OpenSSL 3.0.0
      # or later.
      #
      # See also OpenSSL::PKey.generate_key.
      #
      # Example:
      #     # DEPRECATED USAGE: This will not work on OpenSSL 3.0 or later
      #     dh0 = OpenSSL::PKey::DH.new(2048)
      #     dh = dh0.public_key # #public_key only copies the DH parameters (contrary to the name)
      #     dh.generate_key!
      #     puts dh.private? # => true
      #     puts dh0.pub_key == dh.pub_key #=> false
      #
      #     # With OpenSSL::PKey.generate_key
      #     dh0 = OpenSSL::PKey::DH.new(2048)
      #     dh = OpenSSL::PKey.generate_key(dh0)
      #     puts dh0.pub_key == dh.pub_key #=> false
      #
      def generate_key!: () -> self

      def p: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.params -> hash
      # -->
      # Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
      # LEAK OUT!!! Don't use :-)) (I's up to you)
      #
      def params: () -> Hash[String, BN]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.params_ok? -> true | false
      # -->
      # Validates the Diffie-Hellman parameters associated with this instance. It
      # checks whether a safe prime and a suitable generator are used. If this is not
      # the case, `false` is returned.
      #
      # See also the man page EVP_PKEY_param_check(3).
      #
      def params_ok?: () -> bool

      def priv_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.private? -> true | false
      # -->
      # Indicates whether this DH instance has a private key associated with it or
      # not. The private key may be retrieved with DH#priv_key.
      #
      def private?: () -> bool

      def pub_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.public? -> true | false
      # -->
      # Indicates whether this DH instance has a public key associated with it or not.
      # The public key may be retrieved with DH#pub_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dh.public_key -> dhnew
      # -->
      # Returns a new DH instance that carries just the DH parameters.
      #
      # Contrary to the method name, the returned DH object contains only parameters
      # and not the public key.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of re-generating the key pair while keeping the parameters,
      # check OpenSSL::PKey.generate_key.
      #
      # Example:
      #     # OpenSSL::PKey::DH.generate by default generates a random key pair
      #     dh1 = OpenSSL::PKey::DH.generate(2048)
      #     p dh1.priv_key #=> #<OpenSSL::BN 1288347...>
      #     dhcopy = dh1.public_key
      #     p dhcopy.priv_key #=> nil
      #
      def public_key: () -> instance

      def q: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.set_key(pub_key, priv_key) -> self
      # -->
      # Sets *pub_key* and *priv_key* for the DH instance. *priv_key* may be `nil`.
      #
      def set_key: (bn pub_key, bn? priv_key) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.set_pqg(p, q, g) -> self
      # -->
      # Sets *p*, *q*, *g* to the DH instance.
      #
      def set_pqg: (bn p, bn q, bn g) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.to_der -> aString
      # -->
      # Encodes this DH to its DER encoding. Note that any existing per-session
      # public/private keys will **not** get encoded, just the Diffie-Hellman
      # parameters will be encoded.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
      # Encodes this DH to its PEM encoding. Note that any existing per-session
      # public/private keys will **not** get encoded, just the Diffie-Hellman
      # parameters will be encoded.
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
      # Encodes this DH to its PEM encoding. Note that any existing per-session
      # public/private keys will **not** get encoded, just the Diffie-Hellman
      # parameters will be encoded.
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - dh.to_text -> aString
      # -->
      # Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
      # OUT!!! Don't use :-)) (I's up to you)
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - DH.new -> dh
      #   - DH.new(string) -> dh
      #   - DH.new(size [, generator]) -> dh
      # -->
      # Creates a new instance of OpenSSL::PKey::DH.
      #
      # If called without arguments, an empty instance without any parameter or key
      # components is created. Use #set_pqg to manually set the parameters afterwards
      # (and optionally #set_key to set private and public key components).
      #
      # If a String is given, tries to parse it as a DER- or PEM- encoded parameters.
      # See also OpenSSL::PKey.read which can parse keys of any kinds.
      #
      # The DH.new(size [, generator]) form is an alias of DH.generate.
      #
      # `string`
      # :   A String that contains the DER or PEM encoded key.
      # `size`
      # :   See DH.generate.
      # `generator`
      # :   See DH.generate.
      #
      #
      # Examples:
      #     # Creating an instance from scratch
      #     # Note that this is deprecated and will not work on OpenSSL 3.0 or later.
      #     dh = OpenSSL::PKey::DH.new
      #     dh.set_pqg(bn_p, nil, bn_g)
      #
      #     # Generating a parameters and a key pair
      #     dh = OpenSSL::PKey::DH.new(2048) # An alias of OpenSSL::PKey::DH.generate(2048)
      #
      #     # Reading DH parameters
      #     dh_params = OpenSSL::PKey::DH.new(File.read('parameters.pem')) # loads parameters only
      #     dh = OpenSSL::PKey.generate_key(dh_params) # generates a key pair
      #
      def initialize: (Integer size, ?Integer generator) -> void
                    | (String pem) -> void
                    | () -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dh.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dh.c -->
    # Generic exception that is raised if an operation on a DH PKey fails
    # unexpectedly or in case an instantiation of an instance of DH fails due to
    # non-conformant input data.
    #
    class DHError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
    # DSA, the Digital Signature Algorithm, is specified in NIST's FIPS 186-3. It is
    # an asymmetric public key algorithm that may be used similar to e.g. RSA.
    #
    class DSA < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - DSA.generate(size) -> dsa
      # -->
      # Creates a new DSA instance by generating a private/public key pair from
      # scratch.
      #
      # See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      #
      def self.generate: (Integer size) -> instance

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.export([cipher, password]) -> aString
      #   - dsa.to_pem([cipher, password]) -> aString
      #   - dsa.to_s([cipher, password]) -> aString
      # -->
      # Encodes this DSA to its PEM encoding.
      #
      # ### Parameters
      # *   *cipher* is an OpenSSL::Cipher.
      # *   *password* is a string containing your password.
      #
      #
      # ### Examples
      #     DSA.to_pem -> aString
      #     DSA.to_pem(cipher, 'mypassword') -> aString
      #
      def export: (String cipher, String password) -> String
                | () -> String

      def g: () -> BN

      def p: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.params -> hash
      # -->
      # Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
      # LEAK OUT!!! Don't use :-)) (I's up to you)
      #
      def params: () -> Hash[String, BN]

      def priv_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.private? -> true | false
      # -->
      # Indicates whether this DSA instance has a private key associated with it or
      # not. The private key may be retrieved with DSA#private_key.
      #
      def private?: () -> bool

      def pub_key: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.public? -> true | false
      # -->
      # Indicates whether this DSA instance has a public key associated with it or
      # not. The public key may be retrieved with DSA#public_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.public_key -> dsanew
      # -->
      # Returns a new DSA instance that carries just the DSA parameters and the public
      # key.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of serializing the public key, to PEM or DER encoding of X.509
      # SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.
      #
      def public_key: () -> instance

      def q: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.set_key(pub_key, priv_key) -> self
      # -->
      # Sets *pub_key* and *priv_key* for the DSA instance. *priv_key* may be `nil`.
      #
      def set_key: (bn pub_key, bn? priv_key) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.set_pqg(p, q, g) -> self
      # -->
      # Sets *p*, *q*, *g* to the DSA instance.
      #
      def set_pqg: (bn p, bn q, bn g) -> self

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.syssign(string) -> string
      # -->
      # Computes and returns the DSA signature of `string`, where `string` is expected
      # to be an already-computed message digest of the original input data. The
      # signature is issued using the private key of this DSA instance.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      # `string`
      # :   A message digest of the original input data to be signed.
      #
      #
      # Example:
      #     dsa = OpenSSL::PKey::DSA.new(2048)
      #     doc = "Sign me"
      #     digest = OpenSSL::Digest.digest('SHA1', doc)
      #
      #     # With legacy #syssign and #sysverify:
      #     sig = dsa.syssign(digest)
      #     p dsa.sysverify(digest, sig) #=> true
      #
      #     # With #sign_raw and #verify_raw:
      #     sig = dsa.sign_raw(nil, digest)
      #     p dsa.verify_raw(nil, sig, digest) #=> true
      #
      def syssign: (String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - dsa.sysverify(digest, sig) -> true | false
      # -->
      # Verifies whether the signature is valid given the message digest input. It
      # does so by validating `sig` using the public key of this DSA instance.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      # `digest`
      # :   A message digest of the original input data to be signed.
      # `sig`
      # :   A DSA signature value.
      #
      def sysverify: (String digest, String data) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.to_der -> aString
      # -->
      # Encodes this DSA to its DER encoding.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
      # Encodes this DSA to its PEM encoding.
      #
      # ### Parameters
      # *   *cipher* is an OpenSSL::Cipher.
      # *   *password* is a string containing your password.
      #
      #
      # ### Examples
      #     DSA.to_pem -> aString
      #     DSA.to_pem(cipher, 'mypassword') -> aString
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
      # Encodes this DSA to its PEM encoding.
      #
      # ### Parameters
      # *   *cipher* is an OpenSSL::Cipher.
      # *   *password* is a string containing your password.
      #
      #
      # ### Examples
      #     DSA.to_pem -> aString
      #     DSA.to_pem(cipher, 'mypassword') -> aString
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - dsa.to_text -> aString
      # -->
      # Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
      # OUT!!! Don't use :-)) (I's up to you)
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - DSA.new -> dsa
      #   - DSA.new(string [, pass]) -> dsa
      #   - DSA.new(size) -> dsa
      # -->
      # Creates a new DSA instance by reading an existing key from *string*.
      #
      # If called without arguments, creates a new instance with no key components
      # set. They can be set individually by #set_pqg and #set_key.
      #
      # If called with a String, tries to parse as DER or PEM encoding of a DSA key.
      # See also OpenSSL::PKey.read which can parse keys of any kinds.
      #
      # If called with a number, generates random parameters and a key pair. This form
      # works as an alias of DSA.generate.
      #
      # `string`
      # :   A String that contains a DER or PEM encoded key.
      # `pass`
      # :   A String that contains an optional password.
      # `size`
      # :   See DSA.generate.
      #
      #
      # Examples:
      #     p OpenSSL::PKey::DSA.new(1024)
      #     #=> #<OpenSSL::PKey::DSA:0x000055a8d6025bf0 oid=DSA>
      #
      #     p OpenSSL::PKey::DSA.new(File.read('dsa.pem'))
      #     #=> #<OpenSSL::PKey::DSA:0x000055555d6b8110 oid=DSA>
      #
      #     p OpenSSL::PKey::DSA.new(File.read('dsa.pem'), 'mypassword')
      #     #=> #<OpenSSL::PKey::DSA:0x0000556f973c40b8 oid=DSA>
      #
      def initialize: (String pem, ?String pass) -> void
                    | (?Integer size) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_dsa.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_dsa.c -->
    # Generic exception that is raised if an operation on a DSA PKey fails
    # unexpectedly or in case an instantiation of an instance of DSA fails due to
    # non-conformant input data.
    #
    class DSAError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
    # OpenSSL::PKey::EC provides access to Elliptic Curve Digital Signature
    # Algorithm (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH).
    #
    # ### Key exchange
    #     ec1 = OpenSSL::PKey::EC.generate("prime256v1")
    #     ec2 = OpenSSL::PKey::EC.generate("prime256v1")
    #     # ec1 and ec2 have own private key respectively
    #     shared_key1 = ec1.dh_compute_key(ec2.public_key)
    #     shared_key2 = ec2.dh_compute_key(ec1.public_key)
    #
    #     p shared_key1 == shared_key2 #=> true
    #
    class EC < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - EC.builtin_curves => [[sn, comment], ...]
      # -->
      # Obtains a list of all predefined curves by the OpenSSL. Curve names are
      # returned as sn.
      #
      # See the OpenSSL documentation for EC_get_builtin_curves().
      #
      def self.builtin_curves: () -> Array[[ String, String ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - EC.generate(ec_group) -> ec
      #   - EC.generate(string) -> ec
      # -->
      # Creates a new EC instance with a new random private and public key.
      #
      def self.generate: (String | Group pem_or_der_or_group_or_curve_name) -> instance

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.check_key   => true
      # -->
      # Raises an exception if the key is invalid.
      #
      # See also the man page EVP_PKEY_public_check(3).
      #
      def check_key: () -> true

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - ec.dh_compute_key(pubkey) -> string
      # -->
      # Derives a shared secret by ECDH. *pubkey* must be an instance of
      # OpenSSL::PKey::EC::Point and must belong to the same group.
      #
      # This method is provided for backwards compatibility, and calls #derive
      # internally.
      #
      def dh_compute_key: (Point public_key) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - key.dsa_sign_asn1(data) -> String
      # -->
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      def dsa_sign_asn1: (String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - key.dsa_verify_asn1(data, sig) -> true | false
      # -->
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw instead.
      #
      def dsa_verify_asn1: (String digest, String signature) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.export([cipher, pass_phrase]) => String
      #   - key.to_pem([cipher, pass_phrase]) => String
      # -->
      # Outputs the EC key in PEM encoding.  If *cipher* and *pass_phrase* are given
      # they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
      # instance. Note that encryption will only be effective for a private key,
      # public keys will always be encoded in plain text.
      #
      def export: (String cipher, String password) -> String
                | () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Generates a new random private and public key.
      #
      # See also the OpenSSL documentation for EC_KEY_generate_key()
      #
      # ### Example
      #     ec = OpenSSL::PKey::EC.new("prime256v1")
      #     p ec.private_key # => nil
      #     ec.generate_key!
      #     p ec.private_key # => #<OpenSSL::BN XXXXXX>
      #
      alias generate_key generate_key!

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.generate_key!   => self
      # -->
      # Generates a new random private and public key.
      #
      # See also the OpenSSL documentation for EC_KEY_generate_key()
      #
      # ### Example
      #     ec = OpenSSL::PKey::EC.new("prime256v1")
      #     p ec.private_key # => nil
      #     ec.generate_key!
      #     p ec.private_key # => #<OpenSSL::BN XXXXXX>
      #
      def generate_key!: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.group   => group
      # -->
      # Returns the EC::Group that the key is associated with. Modifying the returned
      # group does not affect *key*.
      #
      def group: () -> Group?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.group = group
      # -->
      # Sets the EC::Group for the key. The group structure is internally copied so
      # modification to *group* after assigning to a key has no effect on the key.
      #
      def group=: (Group) -> Group

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private? => true or false
      # -->
      # Returns whether this EC instance has a private key. The private key (BN) can
      # be retrieved with EC#private_key.
      #
      def private?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private_key   => OpenSSL::BN
      # -->
      # See the OpenSSL documentation for EC_KEY_get0_private_key()
      #
      def private_key: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.private_key = openssl_bn
      # -->
      # See the OpenSSL documentation for EC_KEY_set_private_key()
      #
      def private_key=: (bn priv_key) -> self

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Returns whether this EC instance has a private key. The private key (BN) can
      # be retrieved with EC#private_key.
      #
      alias private_key? private?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public? => true or false
      # -->
      # Returns whether this EC instance has a public key. The public key (EC::Point)
      # can be retrieved with EC#public_key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public_key   => OpenSSL::PKey::EC::Point
      # -->
      # See the OpenSSL documentation for EC_KEY_get0_public_key()
      #
      def public_key: () -> Point?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.public_key = ec_point
      # -->
      # See the OpenSSL documentation for EC_KEY_set_public_key()
      #
      def public_key=: (bn priv_key) -> self

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Returns whether this EC instance has a public key. The public key (EC::Point)
      # can be retrieved with EC#public_key.
      #
      alias public_key? public?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.to_der   => String
      # -->
      # See the OpenSSL documentation for i2d_ECPrivateKey_bio()
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
      # Outputs the EC key in PEM encoding.  If *cipher* and *pass_phrase* are given
      # they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
      # instance. Note that encryption will only be effective for a private key,
      # public keys will always be encoded in plain text.
      #
      alias to_pem export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - key.to_text   => String
      # -->
      # See the OpenSSL documentation for EC_KEY_print()
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - OpenSSL::PKey::EC.new
      #   - OpenSSL::PKey::EC.new(ec_key)
      #   - OpenSSL::PKey::EC.new(ec_group)
      #   - OpenSSL::PKey::EC.new("secp112r1")
      #   - OpenSSL::PKey::EC.new(pem_string [, pwd])
      #   - OpenSSL::PKey::EC.new(der_string)
      # -->
      # Creates a new EC object from given arguments.
      #
      def initialize: () -> void
                    | (instance ec_key) -> void
                    | (Group group) -> void
                    | (String pem_or_der_or_curve, ?String pass) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_ec.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      EXPLICIT_CURVE: Integer

      NAMED_CURVE: Integer

      type ec_method = :GFp_simple | :GFp_mont | :GFp_nist | :GF2m_simple

      type point_conversion_format = :compressed | :uncompressed | :hybrid

      class Group
        public

        # <!-- rdoc-file=ext/openssl/ossl_pkey_ec.c -->
        # Returns `true` if the two groups use the same curve and have the same
        # parameters, `false` otherwise.
        #
        alias == eql?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.asn1_flag -> Integer
        # -->
        # Returns the flags set on the group.
        #
        # See also #asn1_flag=.
        #
        def asn1_flag: () -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.asn1_flag = flags
        # -->
        # Sets flags on the group. The flag value is used to determine how to encode the
        # group: encode explicit parameters or named curve using an OID.
        #
        # The flag value can be either of:
        #
        # *   EC::NAMED_CURVE
        # *   EC::EXPLICIT_CURVE
        #
        #
        # See the OpenSSL documentation for EC_GROUP_set_asn1_flag().
        #
        def asn1_flag=: (Integer) -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.get_cofactor   => cofactor_bn
        # -->
        # Returns the cofactor of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get_cofactor()
        #
        def cofactor: () -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.curve_name  => String
        # -->
        # Returns the curve name (sn).
        #
        # See the OpenSSL documentation for EC_GROUP_get_curve_name()
        #
        def curve_name: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.degree   => integer
        # -->
        # See the OpenSSL documentation for EC_GROUP_get_degree()
        #
        def degree: () -> Integer

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group1.eql?(group2)   => true | false
        #   - group1 == group2   => true | false
        # -->
        # Returns `true` if the two groups use the same curve and have the same
        # parameters, `false` otherwise.
        #
        def eql?: (instance other) -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.generator   => ec_point
        # -->
        # Returns the generator of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get0_generator()
        #
        def generator: () -> Point?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.get_order   => order_bn
        # -->
        # Returns the order of the group.
        #
        # See the OpenSSL documentation for EC_GROUP_get_order()
        #
        def order: () -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.point_conversion_form -> Symbol
        # -->
        # Returns the form how EC::Point data is encoded as ASN.1.
        #
        # See also #point_conversion_form=.
        #
        def point_conversion_form: () -> point_conversion_format

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.point_conversion_form = form
        # -->
        # Sets the form how EC::Point data is encoded as ASN.1 as defined in X9.62.
        #
        # *format* can be one of these:
        #
        # `:compressed`
        # :   Encoded as z||x, where z is an octet indicating which solution of the
        #     equation y is. z will be 0x02 or 0x03.
        # `:uncompressed`
        # :   Encoded as z||x||y, where z is an octet 0x04.
        # `:hybrid`
        # :   Encodes as z||x||y, where z is an octet indicating which solution of the
        #     equation y is. z will be 0x06 or 0x07.
        #
        #
        # See the OpenSSL documentation for EC_GROUP_set_point_conversion_form()
        #
        def point_conversion_form=: (point_conversion_format format) -> point_conversion_format

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.seed   => String or nil
        # -->
        # See the OpenSSL documentation for EC_GROUP_get0_seed()
        #
        def seed: () -> String?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.seed = seed  => seed
        # -->
        # See the OpenSSL documentation for EC_GROUP_set_seed()
        #
        def seed=: (String seed) -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.set_generator(generator, order, cofactor)   => self
        # -->
        # Sets the curve parameters. *generator* must be an instance of EC::Point that
        # is on the curve. *order* and *cofactor* are integers.
        #
        # See the OpenSSL documentation for EC_GROUP_set_generator()
        #
        def set_generator: (Point generator, Integer order, Integer cofactor) -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_der   => String
        # -->
        # See the OpenSSL documentation for i2d_ECPKParameters_bio()
        #
        def to_der: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_pem   => String
        # -->
        # See the OpenSSL documentation for PEM_write_bio_ECPKParameters()
        #
        def to_pem: () -> String

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - group.to_text   => String
        # -->
        # See the OpenSSL documentation for ECPKParameters_print()
        #
        def to_text: () -> String

        private

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - OpenSSL::PKey::EC::Group.new(ec_group)
        #   - OpenSSL::PKey::EC::Group.new(pem_or_der_encoded)
        #   - OpenSSL::PKey::EC::Group.new(:GFp, bignum_p, bignum_a, bignum_b)
        #   - OpenSSL::PKey::EC::Group.new(:GF2m, bignum_p, bignum_a, bignum_b)
        # -->
        # Creates a new EC::Group object.
        #
        # If the first argument is :GFp or :GF2m, creates a new curve with given
        # parameters.
        #
        def initialize: (instance group) -> void
                      | (String pem_or_der_encoded) -> void
                      | (ec_method ec_method) -> void
                      | (:GFp | :GF2m ec_method, Integer bignum_p, Integer bignum_a, Integer bignum_b) -> void

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - initialize_copy(p1)
        # -->
        #
        def initialize_copy: (instance) -> void

        class Error < OpenSSL::OpenSSLError
        end
      end

      class Point
        public

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - ==(p1)
        # -->
        #
        alias == eql?

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.add(point) => point
        # -->
        # Performs elliptic curve point addition.
        #
        def add: (instance point) -> instance

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point1.eql?(point2) => true | false
        #   - point1 == point2 => true | false
        # -->
        #
        def eql?: (instance other) -> bool

        def group: () -> Group

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.infinity? => true | false
        # -->
        #
        def infinity?: () -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.invert! => self
        # -->
        #
        def invert!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.make_affine! => self
        # -->
        # This method is deprecated and should not be used. This is a no-op.
        #
        def make_affine!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.mul(bn1 [, bn2]) => point
        #   - point.mul(bns, points [, bn2]) => point
        # -->
        # Performs elliptic curve point multiplication.
        #
        # The first form calculates `bn1 * point + bn2 * G`, where `G` is the generator
        # of the group of *point*. *bn2* may be omitted, and in that case, the result is
        # just `bn1 * point`.
        #
        # The second form calculates `bns[0] * point + bns[1] * points[0] + ... +
        # bns[-1] * points[-1] + bn2 * G`. *bn2* may be omitted. *bns* must be an array
        # of OpenSSL::BN. *points* must be an array of OpenSSL::PKey::EC::Point. Please
        # note that `points[0]` is not multiplied by `bns[0]`, but `bns[1]`.
        #
        def mul: (bn bn1, ?bn bn2) -> instance
               | (Array[bn] bns, Array[instance], ?bn bn2) -> instance

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.on_curve? => true | false
        # -->
        #
        def on_curve?: () -> bool

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.set_to_infinity! => self
        # -->
        #
        def set_to_infinity!: () -> self

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
        #   - point.to_bn([conversion_form]) -> OpenSSL::BN
        # -->
        # Returns the octet string representation of the EC point as an instance of
        # OpenSSL::BN.
        #
        # If *conversion_form* is not given, the *point_conversion_form* attribute set
        # to the group is used.
        #
        # See #to_octet_string for more information.
        #
        def to_bn: (?point_conversion_format conversion_form) -> BN

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - point.to_octet_string(conversion_form) -> String
        # -->
        # Returns the octet string representation of the elliptic curve point.
        #
        # *conversion_form* specifies how the point is converted. Possible values are:
        #
        # *   `:compressed`
        # *   `:uncompressed`
        # *   `:hybrid`
        #
        def to_octet_string: (point_conversion_format) -> String

        private

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - OpenSSL::PKey::EC::Point.new(point)
        #   - OpenSSL::PKey::EC::Point.new(group [, encoded_point])
        # -->
        # Creates a new instance of OpenSSL::PKey::EC::Point. If the only argument is an
        # instance of EC::Point, a copy is returned. Otherwise, creates a point that
        # belongs to *group*.
        #
        # *encoded_point* is the octet string representation of the point. This must be
        # either a String or an OpenSSL::BN.
        #
        def initialize: (instance point) -> void
                      | (Group group, ?String | BN encoded_point) -> void

        # <!--
        #   rdoc-file=ext/openssl/ossl_pkey_ec.c
        #   - initialize_copy(p1)
        # -->
        #
        def initialize_copy: (instance) -> void

        class Error < OpenSSL::OpenSSLError
        end
      end
    end

    class ECError < OpenSSL::PKey::PKeyError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
    # An abstract class that bundles signature creation (PKey#sign) and validation
    # (PKey#verify) that is common to all implementations except OpenSSL::PKey::DH
    # *   OpenSSL::PKey::RSA
    # *   OpenSSL::PKey::DSA
    # *   OpenSSL::PKey::EC
    #
    class PKey
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.inspect -> string
      # -->
      # Returns a string describing the PKey object.
      #
      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.oid -> string
      # -->
      # Returns the short name of the OID associated with *pkey*.
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.private_to_der                   -> string
      #   - pkey.private_to_der(cipher, password) -> string
      # -->
      # Serializes the private key to DER-encoded PKCS #8 format. If called without
      # arguments, unencrypted PKCS #8 PrivateKeyInfo format is used. If called with a
      # cipher name and a password, PKCS #8 EncryptedPrivateKeyInfo format with PBES2
      # encryption scheme is used.
      #
      def private_to_der: (String cipher, String password) -> String
                        | () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.private_to_pem                   -> string
      #   - pkey.private_to_pem(cipher, password) -> string
      # -->
      # Serializes the private key to PEM-encoded PKCS #8 format. See #private_to_der
      # for more details.
      #
      def private_to_pem: (String cipher, String password) -> String
                        | () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.public_to_der -> string
      # -->
      # Serializes the public key to DER-encoded X.509 SubjectPublicKeyInfo format.
      #
      def public_to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.public_to_pem -> string
      # -->
      # Serializes the public key to PEM-encoded X.509 SubjectPublicKeyInfo format.
      #
      def public_to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.sign(digest, data [, options]) -> string
      # -->
      # Hashes and signs the `data` using a message digest algorithm `digest` and a
      # private key `pkey`.
      #
      # See #verify for the verification operation.
      #
      # See also the man page EVP_DigestSign(3).
      #
      # `digest`
      # :   A String that represents the message digest algorithm name, or `nil` if
      #     the PKey type requires no digest algorithm. For backwards compatibility,
      #     this can be an instance of OpenSSL::Digest. Its state will not affect the
      #     signature.
      # `data`
      # :   A String. The data to be hashed and signed.
      # `options`
      # :   A Hash that contains algorithm specific control operations to OpenSSL. See
      #     OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details. `options`
      #     parameter was added in version 3.0.
      #
      #
      # Example:
      #     data = "Sign me!"
      #     pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
      #     signopts = { rsa_padding_mode: "pss" }
      #     signature = pkey.sign("SHA256", data, signopts)
      #
      #     # Creates a copy of the RSA key pkey, but without the private components
      #     pub_key = pkey.public_key
      #     puts pub_key.verify("SHA256", signature, data, signopts) # => true
      #
      def sign: (Digest digest, String data) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - pkey.verify(digest, signature, data [, options]) -> true or false
      # -->
      # Verifies the `signature` for the `data` using a message digest algorithm
      # `digest` and a public key `pkey`.
      #
      # Returns `true` if the signature is successfully verified, `false` otherwise.
      # The caller must check the return value.
      #
      # See #sign for the signing operation and an example.
      #
      # See also the man page EVP_DigestVerify(3).
      #
      # `digest`
      # :   See #sign.
      # `signature`
      # :   A String containing the signature to be verified.
      # `data`
      # :   See #sign.
      # `options`
      # :   See #sign. `options` parameter was added in version 3.0.
      #
      def verify: (Digest digest, String signature, String data) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey.c
      #   - PKeyClass.new -> self
      # -->
      # Because PKey is an abstract class, actually calling this method explicitly
      # will raise a NotImplementedError.
      #
      def initialize: () -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey.c -->
    # Raised when errors occur during PKey#sign or PKey#verify.
    #
    class PKeyError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
    # RSA is an asymmetric public key algorithm that has been formalized in RFC
    # 3447. It is in widespread use in public key infrastructures (PKI) where
    # certificates (cf. OpenSSL::X509::Certificate) often are issued on the basis of
    # a public/private RSA key pair. RSA is used in a wide field of applications
    # such as secure (symmetric) key exchange, e.g. when establishing a secure
    # TLS/SSL connection. It is also used in various digital signature schemes.
    #
    class RSA < OpenSSL::PKey::PKey
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - RSA.generate(size, exponent = 65537) -> RSA
      # -->
      # Generates an RSA keypair.
      #
      # See also OpenSSL::PKey.generate_key.
      #
      # `size`
      # :   The desired key size in bits.
      # `exponent`
      # :   An odd Integer, normally 3, 17, or 65537.
      #
      def self.generate: (Integer size, ?Integer exponent) -> instance

      public

      def d: () -> BN?

      def dmp1: () -> BN?

      def dmq1: () -> BN?

      def e: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.export([cipher, pass_phrase]) => PEM-format String
      #   - rsa.to_pem([cipher, pass_phrase]) => PEM-format String
      #   - rsa.to_s([cipher, pass_phrase]) => PEM-format String
      # -->
      # Outputs this keypair in PEM encoding.  If *cipher* and *pass_phrase* are given
      # they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
      # instance.
      #
      def export: (String cipher, String password) -> String
                | () -> String

      def iqmp: () -> BN?

      def n: () -> BN?

      def p: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.params => hash
      # -->
      # THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!
      #
      # Stores all parameters of key to the hash.  The hash has keys 'n', 'e', 'd',
      # 'p', 'q', 'dmp1', 'dmq1', 'iqmp'.
      #
      # Don't use :-)) (It's up to you)
      #
      def params: () -> Hash[String, BN]

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.private? => true | false
      # -->
      # Does this keypair contain a private key?
      #
      def private?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.private_decrypt(string)          -> String
      #   - rsa.private_decrypt(string, padding) -> String
      # -->
      # Decrypt `string`, which has been encrypted with the public key, with the
      # private key. `padding` defaults to PKCS1_PADDING.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
      # PKey::PKey#decrypt instead.
      #
      def private_decrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.private_encrypt(string)          -> String
      #   - rsa.private_encrypt(string, padding) -> String
      # -->
      # Encrypt `string` with the private key.  `padding` defaults to PKCS1_PADDING.
      # The encrypted string output can be decrypted using #public_decrypt.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.
      #
      def private_encrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.public? => true
      # -->
      # The return value is always `true` since every private key is also a public
      # key.
      #
      def public?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_decrypt(string)          -> String
      #   - rsa.public_decrypt(string, padding) -> String
      # -->
      # Decrypt `string`, which has been encrypted with the private key, with the
      # public key.  `padding` defaults to PKCS1_PADDING.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
      # PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.
      #
      def public_decrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_encrypt(string)          -> String
      #   - rsa.public_encrypt(string, padding) -> String
      # -->
      # Encrypt `string` with the public key.  `padding` defaults to PKCS1_PADDING.
      # The encrypted string output can be decrypted using #private_decrypt.
      #
      # **Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
      # PKey::PKey#decrypt instead.
      #
      def public_encrypt: (String data, ?Integer padding) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/pkey.rb
      #   - rsa.public_key -> rsanew
      # -->
      # Returns a new RSA instance that carries just the public key components.
      #
      # This method is provided for backwards compatibility. In most cases, there is
      # no need to call this method.
      #
      # For the purpose of serializing the public key, to PEM or DER encoding of X.509
      # SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.
      #
      def public_key: () -> instance

      def q: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_crt_params(dmp1, dmq1, iqmp) -> self
      # -->
      # Sets *dmp1*, *dmq1*, *iqmp* for the RSA instance. They are calculated by `d
      # mod (p - 1)`, `d mod (q - 1)` and `q^(-1) mod p` respectively.
      #
      def set_crt_params: (bn dmp1, bn dmq1, bn iqmp) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_factors(p, q) -> self
      # -->
      # Sets *p*, *q* for the RSA instance.
      #
      def set_factors: (bn p, bn q) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.set_key(n, e, d) -> self
      # -->
      # Sets *n*, *e*, *d* for the RSA instance.
      #
      def set_key: (bn n, bn e, bn d) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.sign_pss(digest, data, salt_length:, mgf1_hash:) -> String
      # -->
      # Signs *data* using the Probabilistic Signature Scheme (RSA-PSS) and returns
      # the calculated signature.
      #
      # RSAError will be raised if an error occurs.
      #
      # See #verify_pss for the verification operation.
      #
      # ### Parameters
      # *digest*
      # :   A String containing the message digest algorithm name.
      # *data*
      # :   A String. The data to be signed.
      # *salt_length*
      # :   The length in octets of the salt. Two special values are reserved:
      #     `:digest` means the digest length, and `:max` means the maximum possible
      #     length for the combination of the private key and the selected message
      #     digest algorithm.
      # *mgf1_hash*
      # :   The hash algorithm used in MGF1 (the currently supported mask generation
      #     function (MGF)).
      #
      #
      # ### Example
      #     data = "Sign me!"
      #     pkey = OpenSSL::PKey::RSA.new(2048)
      #     signature = pkey.sign_pss("SHA256", data, salt_length: :max, mgf1_hash: "SHA256")
      #     pub_key = OpenSSL::PKey.read(pkey.public_to_der)
      #     puts pub_key.verify_pss("SHA256", signature, data,
      #                             salt_length: :auto, mgf1_hash: "SHA256") # => true
      #
      def sign_pss: (String digest, String data, salt_length: :digest | :max | Integer, mgf1_hash: String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.to_der => DER-format String
      # -->
      # Outputs this keypair in DER encoding.
      #
      def to_der: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
      # Outputs this keypair in PEM encoding.  If *cipher* and *pass_phrase* are given
      # they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
      # instance.
      #
      alias to_pem export

      # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
      # Outputs this keypair in PEM encoding.  If *cipher* and *pass_phrase* are given
      # they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
      # instance.
      #
      alias to_s export

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.to_text => String
      # -->
      # THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!
      #
      # Dumps all parameters of a keypair to a String
      #
      # Don't use :-)) (It's up to you)
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - rsa.verify_pss(digest, signature, data, salt_length:, mgf1_hash:) -> true | false
      # -->
      # Verifies *data* using the Probabilistic Signature Scheme (RSA-PSS).
      #
      # The return value is `true` if the signature is valid, `false` otherwise.
      # RSAError will be raised if an error occurs.
      #
      # See #sign_pss for the signing operation and an example code.
      #
      # ### Parameters
      # *digest*
      # :   A String containing the message digest algorithm name.
      # *data*
      # :   A String. The data to be signed.
      # *salt_length*
      # :   The length in octets of the salt. Two special values are reserved:
      #     `:digest` means the digest length, and `:auto` means automatically
      #     determining the length based on the signature.
      # *mgf1_hash*
      # :   The hash algorithm used in MGF1.
      #
      def verify_pss: (String digest, String signature, String data, salt_length: :auto | :digest | Integer, mgf1_hash: String) -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - RSA.new -> rsa
      #   - RSA.new(encoded_key [, passphrase]) -> rsa
      #   - RSA.new(encoded_key) { passphrase } -> rsa
      #   - RSA.new(size [, exponent]) -> rsa
      # -->
      # Generates or loads an RSA keypair.
      #
      # If called without arguments, creates a new instance with no key components
      # set. They can be set individually by #set_key, #set_factors, and
      # #set_crt_params.
      #
      # If called with a String, tries to parse as DER or PEM encoding of an RSA key.
      # Note that, if *passphrase* is not specified but the key is encrypted with a
      # passphrase, OpenSSL will prompt for it. See also OpenSSL::PKey.read which can
      # parse keys of any kinds.
      #
      # If called with a number, generates a new key pair. This form works as an alias
      # of RSA.generate.
      #
      # Examples:
      #     OpenSSL::PKey::RSA.new 2048
      #     OpenSSL::PKey::RSA.new File.read 'rsa.pem'
      #     OpenSSL::PKey::RSA.new File.read('rsa.pem'), 'my pass phrase'
      #
      def initialize: () -> void
                    | (Integer key_size) -> void
                    | (String encoded_key, ?String pass_phrase) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_pkey_rsa.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      NO_PADDING: Integer

      PKCS1_OAEP_PADDING: Integer

      PKCS1_PADDING: Integer

      SSLV23_PADDING: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_pkey_rsa.c -->
    # Generic exception that is raised if an operation on an RSA PKey fails
    # unexpectedly or in case an instantiation of an instance of RSA fails due to
    # non-conformant input data.
    #
    class RSAError < OpenSSL::PKey::PKeyError
    end
  end

  module Random
    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - load_random_file(filename) -> true
    # -->
    # Reads bytes from *filename* and adds them to the PRNG.
    #
    def self.load_random_file: (String filename) -> true

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - add(str, entropy) -> self
    # -->
    # Mixes the bytes from *str* into the Pseudo Random Number Generator(PRNG)
    # state.
    #
    # Thus, if the data from *str* are unpredictable to an adversary, this increases
    # the uncertainty about the state and makes the PRNG output less predictable.
    #
    # The *entropy* argument is (the lower bound of) an estimate of how much
    # randomness is contained in *str*, measured in bytes.
    #
    # ### Example
    #
    #     pid = $$
    #     now = Time.now
    #     ary = [now.to_i, now.nsec, 1000, pid]
    #     OpenSSL::Random.add(ary.join, 0.0)
    #     OpenSSL::Random.seed(ary.join)
    #
    def self.random_add: (String str, Numeric entropy) -> self

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - random_bytes(length) -> string
    # -->
    # Generates a String with *length* number of cryptographically strong
    # pseudo-random bytes.
    #
    # ### Example
    #
    #     OpenSSL::Random.random_bytes(12)
    #     #=> "..."
    #
    def self.random_bytes: (Integer length) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - seed(str) -> str
    # -->
    # ::seed is equivalent to ::add where *entropy* is length of *str*.
    #
    def self.seed: (String seed) -> String

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - status? => true | false
    # -->
    # Return `true` if the PRNG has been seeded with enough data, `false` otherwise.
    #
    def self.status?: () -> bool

    # <!--
    #   rdoc-file=ext/openssl/ossl_rand.c
    #   - write_random_file(filename) -> true
    # -->
    # Writes a number of random generated bytes (currently 1024) to *filename* which
    # can be used to initialize the PRNG by calling ::load_random_file in a later
    # session.
    #
    def self.write_random_file: (String filename) -> true

    class RandomError < OpenSSL::OpenSSLError
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
  # Use SSLContext to set up the parameters for a TLS (former SSL) connection.
  # Both client and server TLS connections are supported, SSLSocket and SSLServer
  # may be used in conjunction with an instance of SSLContext to set up
  # connections.
  #
  module SSL
    # <!--
    #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
    #   - verify_certificate_identity(cert, hostname)
    # -->
    #
    def self.verify_certificate_identity: (X509::Certificate cert, String hostname) -> bool

    def self.verify_hostname: (String hostname, String san) -> bool

    def self.verify_wildcard: (String domain_component, String san_component) -> bool

    OP_ALL: Integer

    OP_ALLOW_NO_DHE_KEX: Integer

    OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: Integer

    OP_CIPHER_SERVER_PREFERENCE: Integer

    OP_CRYPTOPRO_TLSEXT_BUG: Integer

    OP_DONT_INSERT_EMPTY_FRAGMENTS: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1k and 1.0.2.
    #
    OP_EPHEMERAL_RSA: Integer

    OP_LEGACY_SERVER_CONNECT: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_MICROSOFT_BIG_SSLV3_BUFFER: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_MICROSOFT_SESS_ID_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 0.9.7h and 0.9.8b.
    #
    OP_MSIE_SSLV2_RSA_PADDING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_CA_DN_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_CHALLENGE_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 0.9.8q and 1.0.0c.
    #
    OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: Integer

    OP_NO_COMPRESSION: Integer

    OP_NO_ENCRYPT_THEN_MAC: Integer

    OP_NO_RENEGOTIATION: Integer

    OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_NO_SSLv2: Integer

    OP_NO_SSLv3: Integer

    OP_NO_TICKET: Integer

    OP_NO_TLSv1: Integer

    OP_NO_TLSv1_1: Integer

    OP_NO_TLSv1_2: Integer

    OP_NO_TLSv1_3: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1.
    #
    OP_PKCS1_CHECK_1: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1.
    #
    OP_PKCS1_CHECK_2: Integer

    OP_SAFARI_ECDHE_ECDSA_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SINGLE_DH_USE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SINGLE_ECDH_USE: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_SSLEAY_080_CLIENT_DH_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.0.1h and 1.0.2.
    #
    OP_SSLREF2_REUSE_CERT_TYPE_BUG: Integer

    OP_TLSEXT_PADDING: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_TLS_BLOCK_PADDING_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Deprecated in OpenSSL 1.1.0.
    #
    OP_TLS_D5_BUG: Integer

    OP_TLS_ROLLBACK_BUG: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # SSL 2.0
    #
    SSL2_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # SSL 3.0
    #
    SSL3_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.1
    #
    TLS1_1_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.2
    #
    TLS1_2_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.3
    #
    TLS1_3_VERSION: Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # TLS 1.0
    #
    TLS1_VERSION: Integer

    VERIFY_CLIENT_ONCE: Integer

    VERIFY_FAIL_IF_NO_PEER_CERT: Integer

    VERIFY_NONE: Integer

    VERIFY_PEER: Integer

    type tls_version = Symbol | Integer

    type verify_mode = Integer

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # An SSLContext is used to set various options regarding certificates,
    # algorithms, verification, session caching, etc.  The SSLContext is used to
    # create an SSLSocket.
    #
    # All attributes must be set before creating an SSLSocket as the SSLContext will
    # be frozen afterward.
    #
    class SSLContext
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.add_certificate(certificate, pkey [, extra_certs]) -> self
      # -->
      # Adds a certificate to the context. *pkey* must be a corresponding private key
      # with *certificate*.
      #
      # Multiple certificates with different public key type can be added by repeated
      # calls of this method, and OpenSSL will choose the most appropriate certificate
      # during the handshake.
      #
      # #cert=, #key=, and #extra_chain_cert= are old accessor methods for setting
      # certificate and internally call this method.
      #
      # ### Parameters
      # *certificate*
      # :   A certificate. An instance of OpenSSL::X509::Certificate.
      # *pkey*
      # :   The private key for *certificate*. An instance of OpenSSL::PKey::PKey.
      # *extra_certs*
      # :   Optional. An array of OpenSSL::X509::Certificate. When sending a
      #     certificate chain, the certificates specified by this are sent following
      #     *certificate*, in the order in the array.
      #
      #
      # ### Example
      #     rsa_cert = OpenSSL::X509::Certificate.new(...)
      #     rsa_pkey = OpenSSL::PKey.read(...)
      #     ca_intermediate_cert = OpenSSL::X509::Certificate.new(...)
      #     ctx.add_certificate(rsa_cert, rsa_pkey, [ca_intermediate_cert])
      #
      #     ecdsa_cert = ...
      #     ecdsa_pkey = ...
      #     another_ca_cert = ...
      #     ctx.add_certificate(ecdsa_cert, ecdsa_pkey, [another_ca_cert])
      #
      def add_certificate: (X509::Certificate certificate, PKey::PKey pkey, ?Array[X509::Certificate] extra_certs) -> self

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Application-Layer Protocol Negotiation.
      # Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
      # not set explicitly, the ALPN extension will not be included in the handshake.
      #
      # ### Example
      #
      #     ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      #
      def alpn_protocols: () -> Array[String]?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Application-Layer Protocol Negotiation.
      # Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
      # not set explicitly, the ALPN extension will not be included in the handshake.
      #
      # ### Example
      #
      #     ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      #
      def alpn_protocols=: (Array[String]) -> Array[String]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the server side when the server needs to select a
      # protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
      # higher. The callback must return a protocol of those advertised by the client.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the ALPN extension on the server - any protocols advertised by the client will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.alpn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def alpn_select_cb: () -> (^(Array[String]) -> String? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the server side when the server needs to select a
      # protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
      # higher. The callback must return a protocol of those advertised by the client.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the ALPN extension on the server - any protocols advertised by the client will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.alpn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def alpn_select_cb=: (^(Array[String]) -> String? alpn_select_callback) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a file containing a PEM-format CA certificate
      #
      def ca_file: () -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a file containing a PEM-format CA certificate
      #
      def ca_file=: (String ca_file) -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a directory containing CA certificates in PEM format.
      #
      # Files are looked up by subject's X509 name's hash value.
      #
      def ca_path: () -> String?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # The path to a directory containing CA certificates in PEM format.
      #
      # Files are looked up by subject's X509 name's hash value.
      #
      def ca_path=: (String ca_path) -> String

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context certificate
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def cert: () -> X509::Certificate?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context certificate
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def cert=: (X509::Certificate cert) -> X509::Certificate

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An OpenSSL::X509::Store used for certificate verification.
      #
      def cert_store: () -> X509::Store?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An OpenSSL::X509::Store used for certificate verification.
      #
      def cert_store=: (X509::Store store) -> X509::Store

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ciphers => [[name, version, bits, alg_bits], ...]
      # -->
      # The list of cipher suites configured for this context.
      #
      def ciphers: () -> Array[[ String, String, Integer, Integer ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ciphers = "cipher1:cipher2:..."
      #   - ctx.ciphers = [name, ...]
      #   - ctx.ciphers = [[name, version, bits, alg_bits], ...]
      # -->
      # Sets the list of available cipher suites for this context.  Note in a server
      # context some ciphers require the appropriate certificates.  For example, an
      # RSA cipher suite can only be chosen when an RSA certificate is available.
      #
      def ciphers=: (Array[[ String, String, Integer, Integer ]] ciphers) -> void
                  | (Array[String] ciphers) -> void
                  | (String colon_sep_ciphers) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A certificate or Array of certificates that will be sent to the client.
      #
      def client_ca: () -> (Array[X509::Certificate] | X509::Certificate)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A certificate or Array of certificates that will be sent to the client.
      #
      def client_ca=: (Array[X509::Certificate] | X509::Certificate client_ca) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a client certificate is requested by a server and no
      # certificate has been set.
      #
      # The callback is invoked with a Session and must return an Array containing an
      # OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
      # returned the handshake is suspended.
      #
      def client_cert_cb: () -> (^(Session) -> [ X509::Certificate, PKey::PKey ]? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a client certificate is requested by a server and no
      # certificate has been set.
      #
      # The callback is invoked with a Session and must return an Array containing an
      # OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
      # returned the handshake is suspended.
      #
      def client_cert_cb=: (^(Session) -> [ X509::Certificate, PKey::PKey ]? client_cert_cb) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.ecdh_curves = curve_list -> curve_list
      # -->
      # Sets the list of "supported elliptic curves" for this context.
      #
      # For a TLS client, the list is directly used in the Supported Elliptic Curves
      # Extension. For a server, the list is used by OpenSSL to determine the set of
      # shared curves. OpenSSL will pick the most appropriate one from it.
      #
      # ### Example
      #     ctx1 = OpenSSL::SSL::SSLContext.new
      #     ctx1.ecdh_curves = "X25519:P-256:P-224"
      #     svr = OpenSSL::SSL::SSLServer.new(tcp_svr, ctx1)
      #     Thread.new { svr.accept }
      #
      #     ctx2 = OpenSSL::SSL::SSLContext.new
      #     ctx2.ecdh_curves = "P-256"
      #     cli = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx2)
      #     cli.connect
      #
      #     p cli.tmp_key.group.curve_name
      #     # => "prime256v1" (is an alias for NIST P-256)
      #
      def ecdh_curves=: (String ecdh_curves) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.enable_fallback_scsv() => nil
      # -->
      # Activate TLS_FALLBACK_SCSV for this context. See RFC 7507.
      #
      def enable_fallback_scsv: () -> nil

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Array of extra X509 certificates to be added to the certificate chain.
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def extra_chain_cert: () -> Array[X509::Certificate]?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Array of extra X509 certificates to be added to the certificate chain.
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def extra_chain_cert=: (Array[X509::Certificate] extra_certs) -> Array[X509::Certificate]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.flush_sessions(time) -> self
      # -->
      # Removes sessions in the internal cache that have expired at *time*.
      #
      def flush_sessions: (Time time) -> self

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # This method is called automatically when a new SSLSocket is created. However,
      # it is not thread-safe and must be called before creating SSLSocket objects in
      # a multi-threaded program.
      #
      alias freeze setup

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context private key
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def key: () -> PKey::PKey?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Context private key
      #
      # The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
      # recommended to use #add_certificate instead.
      #
      def key=: (PKey::PKey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
      #   - ctx.max_version = :TLS1_2
      #   - ctx.max_version = nil
      # -->
      # Sets the upper bound of the supported SSL/TLS protocol version. See
      # #min_version= for the possible values.
      #
      def max_version=: (tls_version version) -> tls_version

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.min_version = OpenSSL::SSL::TLS1_2_VERSION
      #   - ctx.min_version = :TLS1_2
      #   - ctx.min_version = nil
      # -->
      # Sets the lower bound on the supported SSL/TLS protocol version. The version
      # may be specified by an integer constant named OpenSSL::SSL::*_VERSION, a
      # Symbol, or `nil` which means "any version".
      #
      # Be careful that you don't overwrite OpenSSL::SSL::OP_NO_{SSL,TLS}v* options by
      # #options= once you have called #min_version= or #max_version=.
      #
      # ### Example
      #     ctx = OpenSSL::SSL::SSLContext.new
      #     ctx.min_version = OpenSSL::SSL::TLS1_1_VERSION
      #     ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
      #
      #     sock = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx)
      #     sock.connect # Initiates a connection using either TLS 1.1 or TLS 1.2
      #
      def min_version=: (tls_version version) -> tls_version

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Next Protocol Negotiation. Supported in
      # OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
      # explicitly, the NPN extension will not be sent by the server in the handshake.
      #
      # ### Example
      #
      #     ctx.npn_protocols = ["http/1.1", "spdy/2"]
      #
      def npn_protocols: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # An Enumerable of Strings. Each String represents a protocol to be advertised
      # as the list of supported protocols for Next Protocol Negotiation. Supported in
      # OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
      # explicitly, the NPN extension will not be sent by the server in the handshake.
      #
      # ### Example
      #
      #     ctx.npn_protocols = ["http/1.1", "spdy/2"]
      #
      def npn_protocols=: (untyped) -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the client side when the client needs to select a
      # protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
      # higher. The client MUST select a protocol of those advertised by the server.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the NPN extension on the client - any protocols advertised by the server will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.npn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def npn_select_cb: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on the client side when the client needs to select a
      # protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
      # higher. The client MUST select a protocol of those advertised by the server.
      # If none is acceptable, raising an error in the callback will cause the
      # handshake to fail. Not setting this callback explicitly means not supporting
      # the NPN extension on the client - any protocols advertised by the server will
      # be ignored.
      #
      # ### Example
      #
      #     ctx.npn_select_cb = lambda do |protocols|
      #       # inspect the protocols and select one
      #       protocols.first
      #     end
      #
      def npn_select_cb=: (untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - options()
      # -->
      # Gets various OpenSSL options.
      #
      def options: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - options=(p1)
      # -->
      # Sets various OpenSSL options.
      #
      def options=: (Integer ssl_options) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked whenever a new handshake is initiated on an established
      # connection. May be used to disable renegotiation entirely.
      #
      # The callback is invoked with the active SSLSocket. The callback's return value
      # is ignored. A normal return indicates "approval" of the renegotiation and will
      # continue the process. To forbid renegotiation and to cancel the process, raise
      # an exception within the callback.
      #
      # ### Disable client renegotiation
      #
      # When running a server, it is often desirable to disable client renegotiation
      # entirely. You may use a callback as follows to implement this feature:
      #
      #     ctx.renegotiation_cb = lambda do |ssl|
      #       raise RuntimeError, "Client renegotiation disabled"
      #     end
      #
      def renegotiation_cb: () -> (^(SSLSocket) -> void | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked whenever a new handshake is initiated on an established
      # connection. May be used to disable renegotiation entirely.
      #
      # The callback is invoked with the active SSLSocket. The callback's return value
      # is ignored. A normal return indicates "approval" of the renegotiation and will
      # continue the process. To forbid renegotiation and to cancel the process, raise
      # an exception within the callback.
      #
      # ### Disable client renegotiation
      #
      # When running a server, it is often desirable to disable client renegotiation
      # entirely. You may use a callback as follows to implement this feature:
      #
      #     ctx.renegotiation_cb = lambda do |ssl|
      #       raise RuntimeError, "Client renegotiation disabled"
      #     end
      #
      def renegotiation_cb=: (^(SSLSocket) -> void) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.security_level -> Integer
      # -->
      # Returns the security level for the context.
      #
      # See also OpenSSL::SSL::SSLContext#security_level=.
      #
      def security_level: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.security_level = integer
      # -->
      # Sets the security level for the context. OpenSSL limits parameters according
      # to the level. The "parameters" include: ciphersuites, curves, key sizes,
      # certificate signature algorithms, protocol version and so on. For example,
      # level 1 rejects parameters offering below 80 bits of security, such as
      # ciphersuites using MD5 for the MAC or RSA keys shorter than 1024 bits.
      #
      # Note that attempts to set such parameters with insufficient security are also
      # blocked. You need to lower the level first.
      #
      # This feature is not supported in OpenSSL < 1.1.0, and setting the level to
      # other than 0 will raise NotImplementedError. Level 0 means everything is
      # permitted, the same behavior as previous versions of OpenSSL.
      #
      # See the manpage of SSL_CTX_set_security_level(3) for details.
      #
      def security_level=: (Integer sec_level) -> Integer

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked at connect time to distinguish between multiple server
      # names.
      #
      # The callback is invoked with an SSLSocket and a server name.  The callback
      # must return an SSLContext for the server name or nil.
      #
      def servername_cb: () -> (^(SSLSocket, String) -> SSLContext? | nil)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked at connect time to distinguish between multiple server
      # names.
      #
      # The callback is invoked with an SSLSocket and a server name.  The callback
      # must return an SSLContext for the server name or nil.
      #
      def servername_cb=: (^(SSLSocket, String) -> SSLContext?) -> ^(SSLSocket, String) -> SSLContext?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_add(session) -> true | false
      # -->
      # Adds *session* to the session cache.
      #
      def session_add: (Session) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_mode -> Integer
      # -->
      # The current session cache mode.
      #
      def session_cache_mode: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_mode=(integer) -> Integer
      # -->
      # Sets the SSL session cache mode.  Bitwise-or together the desired
      # SESSION_CACHE_* constants to set.  See SSL_CTX_set_session_cache_mode(3) for
      # details.
      #
      def session_cache_mode=: (Integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_size -> Integer
      # -->
      # Returns the current session cache size.  Zero is used to represent an
      # unlimited cache size.
      #
      def session_cache_size: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_size=(integer) -> Integer
      # -->
      # Sets the session cache size.  Returns the previously valid session cache size.
      #  Zero is used to represent an unlimited session cache size.
      #
      def session_cache_size=: (Integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_cache_stats -> Hash
      # -->
      # Returns a Hash containing the following keys:
      #
      # :accept
      # :   Number of started SSL/TLS handshakes in server mode
      # :accept_good
      # :   Number of established SSL/TLS sessions in server mode
      # :accept_renegotiate
      # :   Number of start renegotiations in server mode
      # :cache_full
      # :   Number of sessions that were removed due to cache overflow
      # :cache_hits
      # :   Number of successfully reused connections
      # :cache_misses
      # :   Number of sessions proposed by clients that were not found in the cache
      # :cache_num
      # :   Number of sessions in the internal session cache
      # :cb_hits
      # :   Number of sessions retrieved from the external cache in server mode
      # :connect
      # :   Number of started SSL/TLS handshakes in client mode
      # :connect_good
      # :   Number of established SSL/TLS sessions in client mode
      # :connect_renegotiate
      # :   Number of start renegotiations in client mode
      # :timeouts
      # :   Number of sessions proposed by clients that were found in the cache but
      #     had expired due to timeouts
      #
      def session_cache_stats: () -> Hash[Symbol, Integer]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on a server when a session is proposed by the client but
      # the session could not be found in the server's internal cache.
      #
      # The callback is invoked with the SSLSocket and session id.  The callback may
      # return a Session from an external cache.
      #
      def session_get_cb: () -> (^(SSLSocket, Integer) -> Session? | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked on a server when a session is proposed by the client but
      # the session could not be found in the server's internal cache.
      #
      # The callback is invoked with the SSLSocket and session id.  The callback may
      # return a Session from an external cache.
      #
      def session_get_cb=: (^(SSLSocket, Integer) -> Session?) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Sets the context in which a session can be reused.  This allows sessions for
      # multiple applications to be distinguished, for example, by name.
      #
      def session_id_context: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Sets the context in which a session can be reused.  This allows sessions for
      # multiple applications to be distinguished, for example, by name.
      #
      def session_id_context=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a new session was negotiated.
      #
      # The callback is invoked with an SSLSocket.  If `false` is returned the session
      # will be removed from the internal cache.
      #
      def session_new_cb: () -> (^(SSLSocket) -> untyped | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a new session was negotiated.
      #
      # The callback is invoked with an SSLSocket.  If `false` is returned the session
      # will be removed from the internal cache.
      #
      def session_new_cb=: (^(SSLSocket) -> untyped) -> ^(SSLSocket) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.session_remove(session) -> true | false
      # -->
      # Removes *session* from the session cache.
      #
      def session_remove: (Session session) -> bool

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a session is removed from the internal cache.
      #
      # The callback is invoked with an SSLContext and a Session.
      #
      # IMPORTANT NOTE: It is currently not possible to use this safely in a
      # multi-threaded application. The callback is called inside a global lock and it
      # can randomly cause deadlock on Ruby thread switching.
      #
      def session_remove_cb: () -> (^(SSLContext, Session) -> void | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback invoked when a session is removed from the internal cache.
      #
      # The callback is invoked with an SSLContext and a Session.
      #
      # IMPORTANT NOTE: It is currently not possible to use this safely in a
      # multi-threaded application. The callback is called inside a global lock and it
      # can randomly cause deadlock on Ruby thread switching.
      #
      def session_remove_cb=: (^(SSLContext, Session) -> void) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.set_params(params = {}) -> params
      # -->
      # Sets saner defaults optimized for the use with HTTP-like protocols.
      #
      # If a Hash *params* is given, the parameters are overridden with it. The keys
      # in *params* must be assignment methods on SSLContext.
      #
      # If the verify_mode is not VERIFY_NONE and ca_file, ca_path and cert_store are
      # not set then the system default certificate store is used.
      #
      def set_params: (?untyped params) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.setup => Qtrue # first time
      #   - ctx.setup => nil # thereafter
      # -->
      # This method is called automatically when a new SSLSocket is created. However,
      # it is not thread-safe and must be called before creating SSLSocket objects in
      # a multi-threaded program.
      #
      def setup: () -> untyped

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      alias ssl_timeout timeout

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      alias ssl_timeout= timeout=

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ctx.ssl_version = :TLSv1
      #   - ctx.ssl_version = "SSLv23"
      # -->
      # Sets the SSL/TLS protocol version for the context. This forces connections to
      # use only the specified protocol version. This is deprecated and only provided
      # for backwards compatibility. Use #min_version= and #max_version= instead.
      #
      # ### History
      # As the name hints, this used to call the SSL_CTX_set_ssl_version() function
      # which sets the SSL method used for connections created from the context. As of
      # Ruby/OpenSSL 2.1, this accessor method is implemented to call #min_version=
      # and #max_version= instead.
      #
      def ssl_version=: (tls_version meth) -> tls_version

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      def timeout: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Maximum session lifetime in seconds.
      #
      def timeout=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked when DH parameters are required for ephemeral DH key
      # exchange.
      #
      # The callback is invoked with the SSLSocket, a flag indicating the use of an
      # export cipher and the keylength required.
      #
      # The callback must return an OpenSSL::PKey::DH instance of the correct key
      # length.
      #
      # **Deprecated in version 3.0.** Use #tmp_dh= instead.
      #
      def tmp_dh_callback: () -> (^(Session, Integer, Integer) -> PKey::DH | nil)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # A callback invoked when DH parameters are required for ephemeral DH key
      # exchange.
      #
      # The callback is invoked with the SSLSocket, a flag indicating the use of an
      # export cipher and the keylength required.
      #
      # The callback must return an OpenSSL::PKey::DH instance of the correct key
      # length.
      #
      # **Deprecated in version 3.0.** Use #tmp_dh= instead.
      #
      def tmp_dh_callback=: (^(Session, Integer, Integer) -> PKey::DH) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback for additional certificate verification.  The callback is invoked
      # for each certificate in the chain.
      #
      # The callback is invoked with two values.  *preverify_ok* indicates indicates
      # if the verification was passed (`true`) or not (`false`). *store_context* is
      # an OpenSSL::X509::StoreContext containing the context used for certificate
      # verification.
      #
      # If the callback returns `false`, the chain verification is immediately stopped
      # and a bad_certificate alert is then sent.
      #
      def verify_callback: () -> (^(bool, X509::StoreContext) -> untyped | nil)

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # A callback for additional certificate verification.  The callback is invoked
      # for each certificate in the chain.
      #
      # The callback is invoked with two values.  *preverify_ok* indicates indicates
      # if the verification was passed (`true`) or not (`false`). *store_context* is
      # an OpenSSL::X509::StoreContext containing the context used for certificate
      # verification.
      #
      # If the callback returns `false`, the chain verification is immediately stopped
      # and a bad_certificate alert is then sent.
      #
      def verify_callback=: (^(bool, X509::StoreContext) -> untyped) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Number of CA certificates to walk when verifying a certificate chain.
      #
      def verify_depth: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Number of CA certificates to walk when verifying a certificate chain.
      #
      def verify_depth=: (Integer) -> Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Whether to check the server certificate is valid for the hostname.
      #
      # In order to make this work, verify_mode must be set to VERIFY_PEER and the
      # server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      #
      def verify_hostname: () -> bool?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Whether to check the server certificate is valid for the hostname.
      #
      # In order to make this work, verify_mode must be set to VERIFY_PEER and the
      # server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      #
      def verify_hostname=: [U] (boolish) -> U

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Session verification mode.
      #
      # Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
      # VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL
      #
      # The default mode is VERIFY_NONE, which does not perform any verification at
      # all.
      #
      # See SSL_CTX_set_verify(3) for details.
      #
      def verify_mode: () -> verify_mode?

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Session verification mode.
      #
      # Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
      # VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL
      #
      # The default mode is VERIFY_NONE, which does not perform any verification at
      # all.
      #
      # See SSL_CTX_set_verify(3) for details.
      #
      def verify_mode=: (verify_mode) -> verify_mode

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - SSLContext.new           -> ctx
      #   - SSLContext.new(:TLSv1)   -> ctx
      #   - SSLContext.new("SSLv23") -> ctx
      # -->
      # Creates a new SSL context.
      #
      # If an argument is given, #ssl_version= is called with the value. Note that
      # this form is deprecated. New applications should use #min_version= and
      # #max_version= as necessary.
      #
      def initialize: (?tls_version version) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ctx.set_minmax_proto_version(min, max) -> nil
      # -->
      # Sets the minimum and maximum supported protocol versions. See #min_version=
      # and #max_version=.
      #
      def set_minmax_proto_version: (untyped, untyped) -> untyped

      DEFAULT_CERT_STORE: X509::Store

      DEFAULT_PARAMS: Hash[Symbol, untyped]

      DEFAULT_TMP_DH_CALLBACK: Proc

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The list of available SSL/TLS methods. This constant is only provided for
      # backwards compatibility.
      #
      METHODS: Array[Symbol]

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Both client and server sessions are added to the session cache
      #
      SESSION_CACHE_BOTH: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Client sessions are added to the session cache
      #
      SESSION_CACHE_CLIENT: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Normally the session cache is checked for expired sessions every 255
      # connections.  Since this may lead to a delay that cannot be controlled, the
      # automatic flushing may be disabled and #flush_sessions can be called
      # explicitly.
      #
      SESSION_CACHE_NO_AUTO_CLEAR: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Enables both SESSION_CACHE_NO_INTERNAL_LOOKUP and
      # SESSION_CACHE_NO_INTERNAL_STORE.
      #
      SESSION_CACHE_NO_INTERNAL: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Always perform external lookups of sessions even if they are in the internal
      # cache.
      #
      # This flag has no effect on clients
      #
      SESSION_CACHE_NO_INTERNAL_LOOKUP: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Never automatically store sessions in the internal store.
      #
      SESSION_CACHE_NO_INTERNAL_STORE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # No session caching for client or server
      #
      SESSION_CACHE_OFF: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
      # Server sessions are added to the session cache
      #
      SESSION_CACHE_SERVER: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ssl.c -->
    # Generic error class raised by SSLSocket and SSLContext.
    #
    class SSLError < OpenSSL::OpenSSLError
    end

    class SSLErrorWaitReadable < OpenSSL::SSL::SSLError
      include IO::WaitReadable
    end

    class SSLErrorWaitWritable < OpenSSL::SSL::SSLError
      include IO::WaitWritable
    end

    # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
    # SSLServer represents a TCP/IP server socket with Secure Sockets Layer.
    #
    class SSLServer
      include OpenSSL::SSL::SocketForwarder

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - accept()
      # -->
      # Works similar to TCPServer#accept.
      #
      def accept: () -> SSLSocket

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - close()
      # -->
      # See IO#close for details.
      #
      def close: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - listen(backlog=Socket::SOMAXCONN)
      # -->
      # See TCPServer#listen for details.
      #
      def listen: (Integer backlog) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - shutdown(how=Socket::SHUT_RDWR)
      # -->
      # See BasicSocket#shutdown for details.
      #
      def shutdown: (Symbol | String | Integer how) -> void

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # When true then #accept works exactly the same as TCPServer#accept
      #
      def start_immediately: () -> bool

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # When true then #accept works exactly the same as TCPServer#accept
      #
      def start_immediately=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - to_io()
      # -->
      # Returns the TCPServer passed to the SSLServer when initialized.
      #
      def to_io: () -> (TCPServer | UNIXServer)

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - new(svr, ctx)
      # -->
      # Creates a new instance of SSLServer.
      # *   *srv* is an instance of TCPServer.
      # *   *ctx* is an instance of OpenSSL::SSL::SSLContext.
      #
      def initialize: (TCPServer | UNIXServer svr, untyped ctx) -> void
    end

    class SSLSocket
      include OpenSSL::SSL::SocketForwarder

      include OpenSSL::Buffering

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - open(remote_host, remote_port, local_host=nil, local_port=nil, context: nil)
      # -->
      # Creates a new instance of SSLSocket. *remote*host_ and *remote*port_ are used
      # to open TCPSocket. If *local*host_ and *local*port_ are specified, then those
      # parameters are used on the local end to establish the connection. If *context*
      # is provided, the SSL Sockets initial params will be taken from the context.
      #
      # ### Examples
      #
      #     sock = OpenSSL::SSL::SSLSocket.open('localhost', 443)
      #     sock.connect # Initiates a connection to localhost:443
      #
      # with SSLContext:
      #
      #     ctx = OpenSSL::SSL::SSLContext.new
      #     sock = OpenSSL::SSL::SSLSocket.open('localhost', 443, context: ctx)
      #     sock.connect # Initiates a connection to localhost:443 with SSLContext
      #
      def self.open: (untyped remote_host, untyped remote_port, ?untyped local_host, ?untyped local_port, ?context: untyped) -> untyped

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.accept => self
      # -->
      # Waits for a SSL/TLS client to initiate a handshake.
      #
      def accept: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.accept_nonblock([options]) => self
      # -->
      # Initiates the SSL/TLS handshake as a server in non-blocking manner.
      #
      #     # emulates blocking accept
      #     begin
      #       ssl.accept_nonblock
      #     rescue IO::WaitReadable
      #       IO.select([s2])
      #       retry
      #     rescue IO::WaitWritable
      #       IO.select(nil, [s2])
      #       retry
      #     end
      #
      # By specifying a keyword argument *exception* to `false`, you can indicate that
      # accept_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
      # exception, but return the symbol `:wait_readable` or `:wait_writable` instead.
      #
      def accept_nonblock: (?exception: true) -> self
                         | (exception: false) -> (self | :wait_readable | :wait_writable)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.alpn_protocol => String | nil
      # -->
      # Returns the ALPN protocol string that was finally selected by the server
      # during the handshake.
      #
      def alpn_protocol: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.cert => cert or nil
      # -->
      # The X509 certificate for this socket endpoint.
      #
      def cert: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.cipher -> nil or [name, version, bits, alg_bits]
      # -->
      # Returns the cipher suite actually used in the current session, or nil if no
      # session has been established.
      #
      def cipher: () -> [ String, String, Integer, Integer ]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.client_ca => [x509name, ...]
      # -->
      # Returns the list of client CAs. Please note that in contrast to
      # SSLContext#client_ca= no array of X509::Certificate is returned but X509::Name
      # instances of the CA's subject distinguished name.
      #
      # In server mode, returns the list set by SSLContext#client_ca=. In client mode,
      # returns the list of client CAs sent from the server.
      #
      def client_ca: () -> (Array[X509::Name] | Array[X509::Certificate] | X509::Certificate)

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.connect => self
      # -->
      # Initiates an SSL/TLS handshake with a server.
      #
      def connect: () -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.connect_nonblock([options]) => self
      # -->
      # Initiates the SSL/TLS handshake as a client in non-blocking manner.
      #
      #     # emulates blocking connect
      #     begin
      #       ssl.connect_nonblock
      #     rescue IO::WaitReadable
      #       IO.select([s2])
      #       retry
      #     rescue IO::WaitWritable
      #       IO.select(nil, [s2])
      #       retry
      #     end
      #
      # By specifying a keyword argument *exception* to `false`, you can indicate that
      # connect_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
      # exception, but return the symbol `:wait_readable` or `:wait_writable` instead.
      #
      def connect_nonblock: (?exception: true) -> self
                          | (exception: false) -> (self | :wait_readable | :wait_writable)

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The SSLContext object used in this connection.
      #
      def context: () -> SSLContext

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.finished_message => "finished message"
      # -->
      # Returns the last **Finished** message sent
      #
      def finished_message: () -> String?

      def hostname: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.hostname = hostname -> hostname
      # -->
      # Sets the server hostname used for SNI. This needs to be set before
      # SSLSocket#connect.
      #
      def hostname=: (String) -> String

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The underlying IO object.
      #
      def io: () -> BasicSocket

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.npn_protocol => String | nil
      # -->
      # Returns the protocol string that was finally selected by the client during the
      # handshake.
      #
      def npn_protocol: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_cert => cert or nil
      # -->
      # The X509 certificate for this socket's peer.
      #
      def peer_cert: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_cert_chain => [cert, ...] or nil
      # -->
      # The X509 certificate chain for this socket's peer.
      #
      def peer_cert_chain: () -> Array[X509::Certificate]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.peer_finished_message => "peer finished message"
      # -->
      # Returns the last **Finished** message received
      #
      def peer_finished_message: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.pending => Integer
      # -->
      # The number of bytes that are immediately available for reading.
      #
      def pending: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.post_connection_check(hostname) -> true
      # -->
      # Perform hostname verification following RFC 6125.
      #
      # This method MUST be called after calling #connect to ensure that the hostname
      # of a remote peer has been verified.
      #
      def post_connection_check: (String hostname) -> true

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.session -> aSession
      # -->
      # Returns the SSLSession object currently used, or nil if the session is not
      # established.
      #
      def session: () -> Session?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.session = session -> session
      # -->
      # Sets the Session to be used when the connection is established.
      #
      def session=: (Session) -> Session

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.session_reused? -> true | false
      # -->
      # Returns `true` if a reused session was negotiated during the handshake.
      #
      def session_reused?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.ssl_version => String
      # -->
      # Returns a String representing the SSL/TLS version that was negotiated for the
      # connection, for example "TLSv1.2".
      #
      def ssl_version: () -> tls_version

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.state => string
      # -->
      # A description of the current connection state. This is for diagnostic purposes
      # only.
      #
      def state: () -> String

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # Whether to close the underlying socket as well, when the SSL/TLS connection is
      # shut down. This defaults to `false`.
      #
      def sync_close: () -> bool

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # Whether to close the underlying socket as well, when the SSL/TLS connection is
      # shut down. This defaults to `false`.
      #
      def sync_close=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - ssl.sysclose => nil
      # -->
      # Sends "close notify" to the peer and tries to shut down the SSL connection
      # gracefully.
      #
      # If sync_close is set to `true`, the underlying IO is also closed.
      #
      def sysclose: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.sysread(length) => string
      #   - ssl.sysread(length, buffer) => buffer
      # -->
      # Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
      # provided the data will be written into it.
      #
      def sysread: (Integer length, ?String buffer) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.syswrite(string) => Integer
      # -->
      # Writes *string* to the SSL connection.
      #
      def syswrite: (String data) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.tmp_key => PKey or nil
      # -->
      # Returns the ephemeral key used in case of forward secrecy cipher.
      #
      def tmp_key: () -> PKey::PKey?

      # <!-- rdoc-file=ext/openssl/lib/openssl/ssl.rb -->
      # The underlying IO object.
      #
      alias to_io io

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.verify_result => Integer
      # -->
      # Returns the result of the peer certificates verification.  See verify(1) for
      # error values and descriptions.
      #
      # If no peer certificate was presented X509_V_OK is returned.
      #
      def verify_result: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - client_cert_cb()
      # -->
      #
      def client_cert_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - SSLSocket.new(io) => aSSLSocket
      #   - SSLSocket.new(io, ctx) => aSSLSocket
      # -->
      # Creates a new SSL socket from *io* which must be a real IO object (not an
      # IO-like object that responds to read/write).
      #
      # If *ctx* is provided the SSL Sockets initial params will be taken from the
      # context.
      #
      # The OpenSSL::Buffering module provides additional IO methods.
      #
      # This method will freeze the SSLContext if one is provided; however, session
      # management is still allowed in the frozen SSLContext.
      #
      def initialize: (*untyped) -> void

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - session_get_cb()
      # -->
      #
      def session_get_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - session_new_cb()
      # -->
      #
      def session_new_cb: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.stop => nil
      # -->
      # Sends "close notify" to the peer and tries to shut down the SSL connection
      # gracefully.
      #
      def stop: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.sysread_nonblock(length) => string
      #   - ssl.sysread_nonblock(length, buffer) => buffer
      #   - ssl.sysread_nonblock(length[, buffer [, opts]) => buffer
      # -->
      # A non-blocking version of #sysread.  Raises an SSLError if reading would
      # block.  If "exception: false" is passed, this method returns a symbol of
      # :wait_readable, :wait_writable, or nil, rather than raising an exception.
      #
      # Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
      # provided the data will be written into it.
      #
      def sysread_nonblock: (*untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl.c
      #   - ssl.syswrite_nonblock(string) => Integer
      # -->
      # Writes *string* to the SSL connection in a non-blocking manner.  Raises an
      # SSLError if writing would block.
      #
      def syswrite_nonblock: (*untyped) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - tmp_dh_callback()
      # -->
      #
      def tmp_dh_callback: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - tmp_ecdh_callback()
      # -->
      #
      def tmp_ecdh_callback: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - using_anon_cipher?()
      # -->
      #
      def using_anon_cipher?: () -> untyped
    end

    class Session
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session1 == session2 -> boolean
      # -->
      # Returns `true` if the two Session is the same, `false` if not.
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.id -> String
      # -->
      # Returns the Session ID.
      #
      def id: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.time -> Time
      # -->
      # Returns the time at which the session was established.
      #
      def time: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.time = time
      #   - session.time = integer
      # -->
      # Sets start time of the session. Time resolution is in seconds.
      #
      def time=: (Time | Integer start_time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.timeout -> Integer
      # -->
      # Returns the timeout value set for the session, in seconds from the established
      # time.
      #
      def timeout: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.timeout = integer
      # -->
      # Sets how long until the session expires in seconds.
      #
      def timeout=: (Integer timeout) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_der -> String
      # -->
      # Returns an ASN1 encoded String that contains the Session object.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_pem -> String
      # -->
      # Returns a PEM encoded String that contains the Session object.
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - session.to_text -> String
      # -->
      # Shows everything in the Session object. This is for diagnostic purposes.
      #
      def to_text: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - Session.new(ssl_socket) -> Session
      #   - Session.new(string) -> Session
      # -->
      # Creates a new Session object from an instance of SSLSocket or DER/PEM encoded
      # String.
      #
      def initialize: (SSLSocket | String sock_or_str) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_ssl_session.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      class SessionError < OpenSSL::OpenSSLError
      end
    end

    module SocketForwarder
      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - addr()
      # -->
      #
      def addr: () -> Addrinfo?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - closed?()
      # -->
      #
      def closed?: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - do_not_reverse_lookup=(flag)
      # -->
      #
      def do_not_reverse_lookup=: (boolish flag) -> boolish

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - fcntl(*args)
      # -->
      #
      def fcntl: (*untyped args) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - fileno()
      # -->
      # The file descriptor for the socket.
      #
      def fileno: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - getsockopt(level, optname)
      # -->
      #
      def getsockopt: (Symbol | Integer level, Symbol | Integer optname) -> (Integer | boolish | String)

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - peeraddr()
      # -->
      #
      def peeraddr: () -> untyped

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/ssl.rb
      #   - setsockopt(level, optname, optval)
      # -->
      #
      def setsockopt: (untyped level, untyped optname, untyped optval) -> untyped
    end
  end

  # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
  # Provides classes and methods to request, create and validate
  # [RFC3161-compliant](http://www.ietf.org/rfc/rfc3161.txt) timestamps. Request
  # may be used to either create requests from scratch or to parse existing
  # requests that again can be used to request timestamps from a timestamp server,
  # e.g. via the net/http. The resulting timestamp response may be parsed using
  # Response.
  #
  # Please note that Response is read-only and immutable. To create a Response, an
  # instance of Factory as well as a valid Request are needed.
  #
  # ### Create a Response:
  #     #Assumes ts.p12 is a PKCS#12-compatible file with a private key
  #     #and a certificate that has an extended key usage of 'timeStamping'
  #     p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
  #     md = OpenSSL::Digest.new('SHA1')
  #     hash = md.digest(data) #some binary data to be timestamped
  #     req = OpenSSL::Timestamp::Request.new
  #     req.algorithm = 'SHA1'
  #     req.message_imprint = hash
  #     req.policy_id = "1.2.3.4.5"
  #     req.nonce = 42
  #     fac = OpenSSL::Timestamp::Factory.new
  #     fac.gen_time = Time.now
  #     fac.serial_number = 1
  #     timestamp = fac.create_timestamp(p12.key, p12.certificate, req)
  #
  # ### Verify a timestamp response:
  #     #Assume we have a timestamp token in a file called ts.der
  #     ts = OpenSSL::Timestamp::Response.new(File.binread('ts.der'))
  #     #Assume we have the Request for this token in a file called req.der
  #     req = OpenSSL::Timestamp::Request.new(File.binread('req.der'))
  #     # Assume the associated root CA certificate is contained in a
  #     # DER-encoded file named root.cer
  #     root = OpenSSL::X509::Certificate.new(File.binread('root.cer'))
  #     # get the necessary intermediate certificates, available in
  #     # DER-encoded form in inter1.cer and inter2.cer
  #     inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
  #     inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
  #     ts.verify(req, root, inter1, inter2) -> ts or raises an exception if validation fails
  #
  module Timestamp
    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Used to generate a Response from scratch.
    #
    # Please bear in mind that the implementation will always apply and prefer the
    # policy object identifier given in the request over the default policy id
    # specified in the Factory. As a consequence, `default_policy_id` will only be
    # applied if no Request#policy_id was given. But this also means that one needs
    # to check the policy identifier in the request manually before creating the
    # Response, e.g. to check whether it complies to a specific set of acceptable
    # policies.
    #
    # There exists also the possibility to add certificates (instances of
    # OpenSSL::X509::Certificate) besides the timestamping certificate that will be
    # included in the resulting timestamp token if Request#cert_requested? is
    # `true`. Ideally, one would also include any intermediate certificates (the
    # root certificate can be left out - in order to trust it any verifying party
    # will have to be in its possession anyway). This simplifies validation of the
    # timestamp since these intermediate certificates are "already there" and need
    # not be passed as external parameters to Response#verify anymore, thus
    # minimizing external resources needed for verification.
    #
    # ### Example: Inclusion of (untrusted) intermediate certificates
    #
    # Assume we received a timestamp request that has set Request#policy_id to `nil`
    # and Request#cert_requested? to true. The raw request bytes are stored in a
    # variable called `req_raw`. We'd still like to integrate the necessary
    # intermediate certificates (in `inter1.cer` and `inter2.cer`) to simplify
    # validation of the resulting Response. `ts.p12` is a PKCS#12-compatible file
    # including the private key and the timestamping certificate.
    #
    #     req = OpenSSL::Timestamp::Request.new(raw_bytes)
    #     p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
    #     inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
    #     inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
    #     fac = OpenSSL::Timestamp::Factory.new
    #     fac.gen_time = Time.now
    #     fac.serial_number = 1
    #     fac.allowed_digests = ["sha256", "sha384", "sha512"]
    #     #needed because the Request contained no policy identifier
    #     fac.default_policy_id = '1.2.3.4.5'
    #     fac.additional_certificates = [ inter1, inter2 ]
    #     timestamp = fac.create_timestamp(p12.key, p12.certificate, req)
    #
    # ## Attributes
    #
    # ### default_policy_id
    #
    # Request#policy_id will always be preferred over this if present in the
    # Request, only if Request#policy_id is nil default_policy will be used. If none
    # of both is present, a TimestampError will be raised when trying to create a
    # Response.
    #
    # call-seq:
    #     factory.default_policy_id = "string" -> string
    #     factory.default_policy_id            -> string or nil
    #
    # ### serial_number
    #
    # Sets or retrieves the serial number to be used for timestamp creation. Must be
    # present for timestamp creation.
    #
    # call-seq:
    #     factory.serial_number = number -> number
    #     factory.serial_number          -> number or nil
    #
    # ### gen_time
    #
    # Sets or retrieves the Time value to be used in the Response. Must be present
    # for timestamp creation.
    #
    # call-seq:
    #     factory.gen_time = Time -> Time
    #     factory.gen_time        -> Time or nil
    #
    # ### additional_certs
    #
    # Sets or retrieves additional certificates apart from the timestamp certificate
    # (e.g. intermediate certificates) to be added to the Response. Must be an Array
    # of OpenSSL::X509::Certificate.
    #
    # call-seq:
    #     factory.additional_certs = [cert1, cert2] -> [ cert1, cert2 ]
    #     factory.additional_certs                  -> array or nil
    #
    # ### allowed_digests
    #
    # Sets or retrieves the digest algorithms that the factory is allowed create
    # timestamps for. Known vulnerable or weak algorithms should not be allowed
    # where possible. Must be an Array of String or OpenSSL::Digest subclass
    # instances.
    #
    # call-seq:
    #     factory.allowed_digests = ["sha1", OpenSSL::Digest.new('SHA256').new] -> [ "sha1", OpenSSL::Digest) ]
    #     factory.allowed_digests                                               -> array or nil
    #
    class Factory
      public

      def additional_certs: () -> Array[X509::Certificate]?

      def additional_certs=: (Array[X509::Certificate]? certs) -> Array[X509::Certificate]?

      def allowed_digests: () -> Array[String | Digest]?

      def allowed_digests=: (Array[String | Digest]) -> Array[String | Digest]

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - factory.create_timestamp(key, certificate, request) -> Response
      # -->
      # Creates a Response with the help of an OpenSSL::PKey, an
      # OpenSSL::X509::Certificate and a Request.
      #
      # Mandatory parameters for timestamp creation that need to be set in the
      # Request:
      #
      # *   Request#algorithm
      # *   Request#message_imprint
      #
      #
      # Mandatory parameters that need to be set in the Factory:
      # *   Factory#serial_number
      # *   Factory#gen_time
      # *   Factory#allowed_digests
      #
      #
      # In addition one of either Request#policy_id or Factory#default_policy_id must
      # be set.
      #
      # Raises a TimestampError if creation fails, though successfully created error
      # responses may be returned.
      #
      def create_timestamp: (PKey::PKey key, X509::Certificate cert, Request request) -> Response

      def default_policy_id: () -> String?

      def default_policy_id=: (String) -> String

      def gen_time: () -> Time?

      def gen_time=: (Time) -> Time

      def serial_number: () -> Integer?

      def serial_number=: (Integer) -> Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Allows to create timestamp requests or parse existing ones. A Request is also
    # needed for creating timestamps from scratch with Factory. When created from
    # scratch, some default values are set:
    # *   version is set to `1`
    # *   cert_requested is set to `true`
    # *   algorithm, message_imprint, policy_id, and nonce are set to `false`
    #
    class Request
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.algorithm    -> string
      # -->
      # Returns the 'short name' of the object identifier that represents the
      # algorithm that was used to create the message imprint digest.
      #
      def algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.algorithm = "string"    -> string
      # -->
      # Allows to set the object identifier  or the 'short name' of the algorithm that
      # was used to create the message imprint digest.
      #
      # ### Example:
      #     request.algorithm = "SHA1"
      #
      def algorithm=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.cert_requested = boolean -> true or false
      # -->
      # Specify whether the response shall contain the timestamp authority's
      # certificate or not. The default value is `true`.
      #
      def cert_requested=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.cert_requested?  -> true or false
      # -->
      # Indicates whether the response shall contain the timestamp authority's
      # certificate or not.
      #
      def cert_requested?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.message_imprint    -> string or nil
      # -->
      # Returns the message imprint (digest) of the data to be timestamped.
      #
      def message_imprint: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.message_imprint = "string"    -> string
      # -->
      # Set the message imprint digest.
      #
      def message_imprint=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.nonce    -> BN or nil
      # -->
      # Returns the nonce (number used once) that the server shall include in its
      # response.
      #
      def nonce: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.nonce = number    -> BN
      # -->
      # Sets the nonce (number used once) that the server shall include in its
      # response. If the nonce is set, the server must return the same nonce value in
      # a valid Response.
      #
      def nonce=: (bn nonce) -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.policy_id    -> string or nil
      # -->
      # Returns the 'short name' of the object identifier that represents the
      # timestamp policy under which the server shall create the timestamp.
      #
      def policy_id: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.policy_id = "string"   -> string
      # -->
      # Allows to set the object identifier that represents the timestamp policy under
      # which the server shall create the timestamp. This may be left `nil`, implying
      # that the timestamp server will issue the timestamp using some default policy.
      #
      # ### Example:
      #     request.policy_id = "1.2.3.4.5"
      #
      def policy_id=: (String policy_id) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.to_der    -> DER-encoded string
      # -->
      # DER-encodes this Request.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.version -> Integer
      # -->
      # Returns the version of this request. `1` is the default value.
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - request.version = number    -> Integer
      # -->
      # Sets the version number for this Request. This should be `1` for compliant
      # servers.
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::Request.new(file)    -> request
      #   - OpenSSL::Timestamp::Request.new(string)  -> request
      #   - OpenSSL::Timestamp::Request.new          -> empty request
      # -->
      # When creating a Request with the `File` or `string` parameter, the
      # corresponding `File` or `string` must be DER-encoded.
      #
      def initialize: (?File | String request_der) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Immutable and read-only representation of a timestamp response returned from a
    # timestamp server after receiving an associated Request. Allows access to
    # specific information about the response but also allows to verify the
    # Response.
    #
    class Response
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.failure_info -> nil or symbol
      # -->
      # In cases no timestamp token has been created, this field contains further info
      # about the reason why response creation failed. The method returns either nil
      # (the request was successful and a timestamp token was created) or one of the
      # following:
      # *   :BAD_ALG - Indicates that the timestamp server rejects the message imprint
      #     algorithm used in the Request
      # *   :BAD_REQUEST - Indicates that the timestamp server was not able to process
      #     the Request properly
      # *   :BAD_DATA_FORMAT - Indicates that the timestamp server was not able to
      #     parse certain data in the Request
      # *   :TIME_NOT_AVAILABLE - Indicates that the server could not access its time
      #     source
      # *   :UNACCEPTED_POLICY - Indicates that the requested policy identifier is not
      #     recognized or supported by the timestamp server
      # *   :UNACCEPTED_EXTENSIION - Indicates that an extension in the Request is not
      #     supported by the timestamp server
      # *   :ADD_INFO_NOT_AVAILABLE -Indicates that additional information requested
      #     is either not understood or currently not available
      # *   :SYSTEM_FAILURE - Timestamp creation failed due to an internal error that
      #     occurred on the timestamp server
      #
      def failure_info: () -> Symbol?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.status -> BN (never nil)
      # -->
      # Returns one of GRANTED, GRANTED_WITH_MODS, REJECTION, WAITING,
      # REVOCATION_WARNING or REVOCATION_NOTIFICATION. A timestamp token has been
      # created only in case `status` is equal to GRANTED or GRANTED_WITH_MODS.
      #
      def status: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.status_text -> Array of strings or nil
      # -->
      # In cases of failure this field may contain an array of strings further
      # describing the origin of the failure.
      #
      def status_text: () -> Array[String]?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.to_der -> string
      # -->
      # Returns the Response in DER-encoded form.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.token -> nil or OpenSSL::PKCS7
      # -->
      # If a timestamp token is present, this returns it in the form of a
      # OpenSSL::PKCS7.
      #
      def token: () -> PKCS7?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.token_info -> nil or OpenSSL::Timestamp::TokenInfo
      # -->
      # Get the response's token info if present.
      #
      def token_info: () -> TokenInfo?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.tsa_certificate -> OpenSSL::X509::Certificate or nil
      # -->
      # If the Request specified to request the TSA certificate
      # (Request#cert_requested = true), then this field contains the certificate of
      # the timestamp authority.
      #
      def tsa_certificate: () -> X509::Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - response.verify(Request, root_store) -> Response
      #   - response.verify(Request, root_store, [intermediate_cert]) -> Response
      # -->
      # Verifies a timestamp token by checking the signature, validating the
      # certificate chain implied by tsa_certificate and by checking conformance to a
      # given Request. Mandatory parameters are the Request associated to this
      # Response, and an OpenSSL::X509::Store of trusted roots.
      #
      # Intermediate certificates can optionally be supplied for creating the
      # certificate chain. These intermediate certificates must all be instances of
      # OpenSSL::X509::Certificate.
      #
      # If validation fails, several kinds of exceptions can be raised:
      # *   TypeError if types don't fit
      # *   TimestampError if something is wrong with the timestamp token itself, if
      #     it is not conformant to the Request, or if validation of the timestamp
      #     certificate chain fails.
      #
      def verify: (Request request, X509::Store store, ?X509::Certificate intermediate_cert) -> instance

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::Response.new(file)    -> response
      #   - OpenSSL::Timestamp::Response.new(string)  -> response
      # -->
      # Creates a Response from a `File` or `string` parameter, the corresponding
      # `File` or `string` must be DER-encoded. Please note that Response is an
      # immutable read-only class. If you'd like to create timestamps please refer to
      # Factory instead.
      #
      def initialize: (File | String response_der) -> void

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a successful response. Equal to `0`.
      #
      GRANTED: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a successful response that probably contains modifications from the
      # initial request. Equal to `1`.
      #
      GRANTED_WITH_MODS: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Equal to `2`.
      #
      REJECTION: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. A certificate has been
      # revoked. Equal to `5`.
      #
      REVOCATION_NOTIFICATION: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Revocation of a
      # certificate is imminent. Equal to `4`.
      #
      REVOCATION_WARNING: Integer

      # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
      # Indicates a failure. No timestamp token was created. Equal to `3`.
      #
      WAITING: Integer
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Generic exception class of the Timestamp module.
    #
    class TimestampError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_ts.c -->
    # Immutable and read-only representation of a timestamp token info from a
    # Response.
    #
    class TokenInfo
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.algorithm -> string or nil
      # -->
      # Returns the 'short name' of the object identifier representing the algorithm
      # that was used to derive the message imprint digest. For valid timestamps, this
      # is the same value that was already given in the Request. If status is GRANTED
      # or GRANTED_WITH_MODS, this is never `nil`.
      #
      # ### Example:
      #     algo = token_info.algorithm
      #     puts algo                -> "SHA1"
      #
      def algorithm: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.gen_time -> Time
      # -->
      # Returns time when this timestamp token was created. If status is GRANTED or
      # GRANTED_WITH_MODS, this is never `nil`.
      #
      def gen_time: () -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.msg_imprint -> string.
      # -->
      # Returns the message imprint digest. For valid timestamps, this is the same
      # value that was already given in the Request. If status is GRANTED or
      # GRANTED_WITH_MODS, this is never `nil`.
      #
      # ### Example:
      #     mi = token_info.msg_imprint
      #     puts mi                -> "DEADBEEF"
      #
      def message_imprint: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.nonce -> BN or nil
      # -->
      # If the timestamp token is valid then this field contains the same nonce that
      # was passed to the timestamp server in the initial Request.
      #
      def nonce: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.ordering -> true, falses or nil
      # -->
      # If the ordering field is missing, or if the ordering field is present and set
      # to false, then the genTime field only indicates the time at which the
      # time-stamp token has been created by the TSA.  In such a case, the ordering of
      # time-stamp tokens issued by the same TSA or different TSAs is only possible
      # when the difference between the genTime of the first time-stamp token and the
      # genTime of the second time-stamp token is greater than the sum of the
      # accuracies of the genTime for each time-stamp token.
      #
      # If the ordering field is present and set to true, every time-stamp token from
      # the same TSA can always be ordered based on the genTime field, regardless of
      # the genTime accuracy.
      #
      def ordering: () -> bool?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.policy_id -> string or nil
      # -->
      # Returns the timestamp policy object identifier of the policy this timestamp
      # was created under. If status is GRANTED or GRANTED_WITH_MODS, this is never
      # `nil`.
      #
      # ### Example:
      #     id = token_info.policy_id
      #     puts id                 -> "1.2.3.4.5"
      #
      def policy_id: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.serial_number -> BN or nil
      # -->
      # Returns serial number of the timestamp token. This value shall never be the
      # same for two timestamp tokens issued by a dedicated timestamp authority. If
      # status is GRANTED or GRANTED_WITH_MODS, this is never `nil`.
      #
      def serial_number: () -> BN?

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.to_der -> string
      # -->
      # Returns the TokenInfo in DER-encoded form.
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - token_info.version -> Integer or nil
      # -->
      # Returns the version number of the token info. With compliant servers, this
      # value should be `1` if present. If status is GRANTED or GRANTED_WITH_MODS.
      #
      def version: () -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_ts.c
      #   - OpenSSL::Timestamp::TokenInfo.new(file)    -> token-info
      #   - OpenSSL::Timestamp::TokenInfo.new(string)  -> token-info
      # -->
      # Creates a TokenInfo from a `File` or `string` parameter, the corresponding
      # `File` or `string` must be DER-encoded. Please note that TokenInfo is an
      # immutable read-only class. If you'd like to create timestamps please refer to
      # Factory instead.
      #
      def initialize: (File | String token_der) -> void
    end
  end

  module X509
    DEFAULT_CERT_AREA: String

    DEFAULT_CERT_DIR: String

    DEFAULT_CERT_DIR_ENV: String

    DEFAULT_CERT_FILE: String

    DEFAULT_CERT_FILE_ENV: String

    DEFAULT_PRIVATE_DIR: String

    PURPOSE_ANY: Integer

    PURPOSE_CRL_SIGN: Integer

    PURPOSE_NS_SSL_SERVER: Integer

    PURPOSE_OCSP_HELPER: Integer

    PURPOSE_SMIME_ENCRYPT: Integer

    PURPOSE_SMIME_SIGN: Integer

    PURPOSE_SSL_CLIENT: Integer

    PURPOSE_SSL_SERVER: Integer

    PURPOSE_TIMESTAMP_SIGN: Integer

    TRUST_COMPAT: Integer

    TRUST_EMAIL: Integer

    TRUST_OBJECT_SIGN: Integer

    TRUST_OCSP_REQUEST: Integer

    TRUST_OCSP_SIGN: Integer

    TRUST_SSL_CLIENT: Integer

    TRUST_SSL_SERVER: Integer

    TRUST_TSA: Integer

    V_ERR_AKID_ISSUER_SERIAL_MISMATCH: Integer

    V_ERR_AKID_SKID_MISMATCH: Integer

    V_ERR_APPLICATION_VERIFICATION: Integer

    V_ERR_CA_KEY_TOO_SMALL: Integer

    V_ERR_CA_MD_TOO_WEAK: Integer

    V_ERR_CERT_CHAIN_TOO_LONG: Integer

    V_ERR_CERT_HAS_EXPIRED: Integer

    V_ERR_CERT_NOT_YET_VALID: Integer

    V_ERR_CERT_REJECTED: Integer

    V_ERR_CERT_REVOKED: Integer

    V_ERR_CERT_SIGNATURE_FAILURE: Integer

    V_ERR_CERT_UNTRUSTED: Integer

    V_ERR_CRL_HAS_EXPIRED: Integer

    V_ERR_CRL_NOT_YET_VALID: Integer

    V_ERR_CRL_PATH_VALIDATION_ERROR: Integer

    V_ERR_CRL_SIGNATURE_FAILURE: Integer

    V_ERR_DANE_NO_MATCH: Integer

    V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: Integer

    V_ERR_DIFFERENT_CRL_SCOPE: Integer

    V_ERR_EE_KEY_TOO_SMALL: Integer

    V_ERR_EMAIL_MISMATCH: Integer

    V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: Integer

    V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: Integer

    V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: Integer

    V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: Integer

    V_ERR_EXCLUDED_VIOLATION: Integer

    V_ERR_HOSTNAME_MISMATCH: Integer

    V_ERR_INVALID_CA: Integer

    V_ERR_INVALID_CALL: Integer

    V_ERR_INVALID_EXTENSION: Integer

    V_ERR_INVALID_NON_CA: Integer

    V_ERR_INVALID_POLICY_EXTENSION: Integer

    V_ERR_INVALID_PURPOSE: Integer

    V_ERR_IP_ADDRESS_MISMATCH: Integer

    V_ERR_KEYUSAGE_NO_CERTSIGN: Integer

    V_ERR_KEYUSAGE_NO_CRL_SIGN: Integer

    V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: Integer

    V_ERR_NO_EXPLICIT_POLICY: Integer

    V_ERR_NO_VALID_SCTS: Integer

    V_ERR_OCSP_CERT_UNKNOWN: Integer

    V_ERR_OCSP_VERIFY_FAILED: Integer

    V_ERR_OCSP_VERIFY_NEEDED: Integer

    V_ERR_OUT_OF_MEM: Integer

    V_ERR_PATH_LENGTH_EXCEEDED: Integer

    V_ERR_PATH_LOOP: Integer

    V_ERR_PERMITTED_VIOLATION: Integer

    V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: Integer

    V_ERR_PROXY_PATH_LENGTH_EXCEEDED: Integer

    V_ERR_PROXY_SUBJECT_NAME_VIOLATION: Integer

    V_ERR_SELF_SIGNED_CERT_IN_CHAIN: Integer

    V_ERR_STORE_LOOKUP: Integer

    V_ERR_SUBJECT_ISSUER_MISMATCH: Integer

    V_ERR_SUBTREE_MINMAX: Integer

    V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: Integer

    V_ERR_SUITE_B_INVALID_ALGORITHM: Integer

    V_ERR_SUITE_B_INVALID_CURVE: Integer

    V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: Integer

    V_ERR_SUITE_B_INVALID_VERSION: Integer

    V_ERR_SUITE_B_LOS_NOT_ALLOWED: Integer

    V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: Integer

    V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: Integer

    V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: Integer

    V_ERR_UNABLE_TO_GET_CRL: Integer

    V_ERR_UNABLE_TO_GET_CRL_ISSUER: Integer

    V_ERR_UNABLE_TO_GET_ISSUER_CERT: Integer

    V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: Integer

    V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: Integer

    V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: Integer

    V_ERR_UNHANDLED_CRITICAL_EXTENSION: Integer

    V_ERR_UNNESTED_RESOURCE: Integer

    V_ERR_UNSPECIFIED: Integer

    V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: Integer

    V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: Integer

    V_ERR_UNSUPPORTED_EXTENSION_FEATURE: Integer

    V_ERR_UNSUPPORTED_NAME_SYNTAX: Integer

    V_FLAG_ALLOW_PROXY_CERTS: Integer

    V_FLAG_CHECK_SS_SIGNATURE: Integer

    V_FLAG_CRL_CHECK: Integer

    V_FLAG_CRL_CHECK_ALL: Integer

    V_FLAG_EXPLICIT_POLICY: Integer

    V_FLAG_EXTENDED_CRL_SUPPORT: Integer

    V_FLAG_IGNORE_CRITICAL: Integer

    V_FLAG_INHIBIT_ANY: Integer

    V_FLAG_INHIBIT_MAP: Integer

    V_FLAG_NOTIFY_POLICY: Integer

    V_FLAG_NO_ALT_CHAINS: Integer

    V_FLAG_NO_CHECK_TIME: Integer

    V_FLAG_PARTIAL_CHAIN: Integer

    V_FLAG_POLICY_CHECK: Integer

    V_FLAG_SUITEB_128_LOS: Integer

    V_FLAG_SUITEB_128_LOS_ONLY: Integer

    V_FLAG_SUITEB_192_LOS: Integer

    V_FLAG_TRUSTED_FIRST: Integer

    V_FLAG_USE_CHECK_TIME: Integer

    V_FLAG_USE_DELTAS: Integer

    V_FLAG_X509_STRICT: Integer

    V_OK: Integer

    class Attribute
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.oid => string
      # -->
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.oid = string => string
      # -->
      #
      def oid=: (String) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.to_der => string
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.value => asn1
      # -->
      #
      def value: () -> ASN1::Set

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - attr.value = asn1 => asn1
      # -->
      #
      def value=: (ASN1::ASN1Data) -> ASN1::Set

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - Attribute.new(oid [, value]) => attr
      # -->
      #
      def initialize: (String der) -> void
                    | (String oid, ASN1::ASN1Data value) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509attr.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class AttributeError < OpenSSL::OpenSSLError
    end

    class CRL
      include OpenSSL::X509::Extension::AuthorityKeyIdentifier

      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - add_extension(p1)
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - add_revoked(p1)
      # -->
      #
      def add_revoked: (Revoked revoked) -> Revoked

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - extensions()
      # -->
      # Gets X509v3 extensions as array of X509Ext objects
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - extensions=(p1)
      # -->
      # Sets X509_EXTENSIONs
      #
      def extensions=: (Array[Extension] extensions) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - issuer()
      # -->
      #
      def issuer: () -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - issuer=(p1)
      # -->
      #
      def issuer=: (X509::Name issuer) -> X509::Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - last_update()
      # -->
      #
      def last_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - last_update=(p1)
      # -->
      #
      def last_update=: (Time last_update) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - next_update()
      # -->
      #
      def next_update: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - next_update=(p1)
      # -->
      #
      def next_update=: (Time next_update) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - revoked()
      # -->
      #
      def revoked: () -> Array[Revoked]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - revoked=(p1)
      # -->
      #
      def revoked=: (Array[Revoked]) -> Array[Revoked]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - sign(p1, p2)
      # -->
      #
      def sign: (PKey::PKey key, Digest digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - signature_algorithm()
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_pem()
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - to_text()
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - verify(p1)
      # -->
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - version()
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - version=(p1)
      # -->
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - new(p1 = v1)
      # -->
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509crl.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class CRLError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509cert.c -->
    # Implementation of an X.509 certificate as specified in RFC 5280. Provides
    # access to a certificate's attributes and allows certificates to be read from a
    # string, but also supports the creation of new certificates from scratch.
    #
    # ### Reading a certificate from a file
    #
    # Certificate is capable of handling DER-encoded certificates and certificates
    # encoded in OpenSSL's PEM format.
    #
    #     raw = File.binread "cert.cer" # DER- or PEM-encoded
    #     certificate = OpenSSL::X509::Certificate.new raw
    #
    # ### Saving a certificate to a file
    #
    # A certificate may be encoded in DER format
    #
    #     cert = ...
    #     File.open("cert.cer", "wb") { |f| f.print cert.to_der }
    #
    # or in PEM format
    #
    #     cert = ...
    #     File.open("cert.pem", "wb") { |f| f.print cert.to_pem }
    #
    # X.509 certificates are associated with a private/public key pair, typically a
    # RSA, DSA or ECC key (see also OpenSSL::PKey::RSA, OpenSSL::PKey::DSA and
    # OpenSSL::PKey::EC), the public key itself is stored within the certificate and
    # can be accessed in form of an OpenSSL::PKey. Certificates are typically used
    # to be able to associate some form of identity with a key pair, for example web
    # servers serving pages over HTTPs use certificates to authenticate themselves
    # to the user.
    #
    # The public key infrastructure (PKI) model relies on trusted certificate
    # authorities ("root CAs") that issue these certificates, so that end users need
    # to base their trust just on a selected few authorities that themselves again
    # vouch for subordinate CAs issuing their certificates to end users.
    #
    # The OpenSSL::X509 module provides the tools to set up an independent PKI,
    # similar to scenarios where the 'openssl' command line tool is used for issuing
    # certificates in a private PKI.
    #
    # ### Creating a root CA certificate and an end-entity certificate
    #
    # First, we need to create a "self-signed" root certificate. To do so, we need
    # to generate a key first. Please note that the choice of "1" as a serial number
    # is considered a security flaw for real certificates. Secure choices are
    # integers in the two-digit byte range and ideally not sequential but secure
    # random numbers, steps omitted here to keep the example concise.
    #
    #     root_key = OpenSSL::PKey::RSA.new 2048 # the CA's public/private key
    #     root_ca = OpenSSL::X509::Certificate.new
    #     root_ca.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
    #     root_ca.serial = 1
    #     root_ca.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby CA"
    #     root_ca.issuer = root_ca.subject # root CA's are "self-signed"
    #     root_ca.public_key = root_key.public_key
    #     root_ca.not_before = Time.now
    #     root_ca.not_after = root_ca.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    #     ef = OpenSSL::X509::ExtensionFactory.new
    #     ef.subject_certificate = root_ca
    #     ef.issuer_certificate = root_ca
    #     root_ca.add_extension(ef.create_extension("basicConstraints","CA:TRUE",true))
    #     root_ca.add_extension(ef.create_extension("keyUsage","keyCertSign, cRLSign", true))
    #     root_ca.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    #     root_ca.add_extension(ef.create_extension("authorityKeyIdentifier","keyid:always",false))
    #     root_ca.sign(root_key, OpenSSL::Digest.new('SHA256'))
    #
    # The next step is to create the end-entity certificate using the root CA
    # certificate.
    #
    #     key = OpenSSL::PKey::RSA.new 2048
    #     cert = OpenSSL::X509::Certificate.new
    #     cert.version = 2
    #     cert.serial = 2
    #     cert.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby certificate"
    #     cert.issuer = root_ca.subject # root CA is the issuer
    #     cert.public_key = key.public_key
    #     cert.not_before = Time.now
    #     cert.not_after = cert.not_before + 1 * 365 * 24 * 60 * 60 # 1 years validity
    #     ef = OpenSSL::X509::ExtensionFactory.new
    #     ef.subject_certificate = cert
    #     ef.issuer_certificate = root_ca
    #     cert.add_extension(ef.create_extension("keyUsage","digitalSignature", true))
    #     cert.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    #     cert.sign(root_key, OpenSSL::Digest.new('SHA256'))
    #
    class Certificate
      include OpenSSL::X509::Extension::AuthorityInfoAccess

      include OpenSSL::X509::Extension::CRLDistributionPoints

      include OpenSSL::X509::Extension::AuthorityKeyIdentifier

      include OpenSSL::X509::Extension::SubjectKeyIdentifier

      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert1 == cert2 -> true | false
      # -->
      # Compares the two certificates. Note that this takes into account all fields,
      # not just the issuer name and the serial number.
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.add_extension(extension) => extension
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.check_private_key(key) -> true | false
      # -->
      # Returns `true` if *key* is the corresponding private key to the Subject Public
      # Key Information, `false` otherwise.
      #
      def check_private_key: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.extensions => [extension...]
      # -->
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.extensions = [ext...] => [ext...]
      # -->
      #
      def extensions=: (Array[Extension]) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - inspect()
      # -->
      #
      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.issuer => name
      # -->
      #
      def issuer: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.issuer = name => name
      # -->
      #
      def issuer=: (Name) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_after => time
      # -->
      #
      def not_after: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_after = time => time
      # -->
      #
      def not_after=: (Time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_before => time
      # -->
      #
      def not_before: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.not_before = time => time
      # -->
      #
      def not_before=: (Time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - pretty_print(q)
      # -->
      #
      def pretty_print: (untyped q) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.public_key => key
      # -->
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.public_key = key
      # -->
      #
      def public_key=: (PKey::PKey pkey) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.serial => integer
      # -->
      #
      def serial: () -> BN

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.serial = integer => integer
      # -->
      #
      def serial=: (bn serial) -> bn

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.sign(key, digest) => self
      # -->
      #
      def sign: (PKey::PKey key, String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.signature_algorithm => string
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.subject => name
      # -->
      #
      def subject: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.subject = name => name
      # -->
      #
      def subject=: (Name) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_der => string
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_pem => string
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.to_text => string
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.verify(key) => true | false
      # -->
      # Verifies the signature of the certificate, with the public key *key*. *key*
      # must be an instance of OpenSSL::PKey.
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.version => integer
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - cert.version = integer => integer
      # -->
      #
      def version=: (Integer) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - Certificate.new => cert
      #   - Certificate.new(string) => cert
      # -->
      #
      def initialize: (?String pem) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509cert.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class CertificateError < OpenSSL::OpenSSLError
    end

    class Extension
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - critical=(p1)
      # -->
      #
      def critical=: [U] (boolish) -> U

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - critical?()
      # -->
      #
      def critical?: () -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - oid()
      # -->
      #
      def oid: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - oid=(p1)
      # -->
      #
      def oid=: (String oid) -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_a()
      # -->
      #
      def to_a: () -> [ String, String, bool ]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_h()
      # -->
      #
      def to_h: () -> Hash[String, untyped]

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - to_s()
      # -->
      #
      def to_s: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value()
      # -->
      #
      def value: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value=(p1)
      # -->
      #
      def value=: (String | ASN1::_ToDer data) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - value_der()
      # -->
      #
      def value_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - OpenSSL::X509::Extension.new(der)
      #   - OpenSSL::X509::Extension.new(oid, value)
      #   - OpenSSL::X509::Extension.new(oid, value, critical)
      # -->
      # Creates an X509 extension.
      #
      # The extension may be created from *der* data or from an extension *oid* and
      # *value*.  The *oid* may be either an OID or an extension name.  If *critical*
      # is `true` the extension is marked critical.
      #
      def initialize: (String der) -> void
                    | (String oid, String value, ?boolish critical) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      module AuthorityInfoAccess
        include OpenSSL::X509::Extension::Helpers

        public

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - ca_issuer_uris()
        # -->
        # Get the information and services for the issuer from the certificate's
        # authority information access extension exteension, as described in RFC5280
        # Section 4.2.2.1.
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def ca_issuer_uris: () -> Array[String]?

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - ocsp_uris()
        # -->
        # Get the URIs for OCSP from the certificate's authority information access
        # extension exteension, as described in RFC5280 Section 4.2.2.1.
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def ocsp_uris: () -> Array[String]?

        private

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - parse_aia_asn1()
        # -->
        #
        def parse_aia_asn1: () -> untyped
      end

      module AuthorityKeyIdentifier
        include OpenSSL::X509::Extension::Helpers

        public

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - authority_key_identifier()
        # -->
        # Get the issuing certificate's key identifier from the authorityKeyIdentifier
        # extension, as described in RFC5280 Section 4.2.1.1
        #
        # Returns the binary String keyIdentifier or nil or raises ASN1::ASN1Error.
        #
        def authority_key_identifier: () -> String?
      end

      module CRLDistributionPoints
        include OpenSSL::X509::Extension::Helpers

        public

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - crl_uris()
        # -->
        # Get the distributionPoint fullName URI from the certificate's CRL distribution
        # points extension, as described in RFC5280 Section 4.2.1.13
        #
        # Returns an array of strings or nil or raises ASN1::ASN1Error.
        #
        def crl_uris: () -> Array[String]?
      end

      module Helpers
        public

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - find_extension(oid)
        # -->
        #
        def find_extension: (String oid) -> Extension?
      end

      module SubjectKeyIdentifier
        include OpenSSL::X509::Extension::Helpers

        public

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - subject_key_identifier()
        # -->
        # Get the subject's key identifier from the subjectKeyIdentifier exteension, as
        # described in RFC5280 Section 4.2.1.2.
        #
        # Returns the binary String key identifier or nil or raises ASN1::ASN1Error.
        #
        def subject_key_identifier: () -> String?
      end
    end

    class ExtensionError < OpenSSL::OpenSSLError
    end

    class ExtensionFactory
      public

      def config: () -> Config?

      def config=: (Config config) -> Config

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - ef.create_ext(ln_or_sn, "value", critical = false) -> X509::Extension
      #   - ef.create_ext(ln_or_sn, "critical,value")          -> X509::Extension
      # -->
      # Creates a new X509::Extension with passed values. See also x509v3_config(5).
      #
      def create_ext: (String oid, String value, ?boolish critical) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_array(ary)
      # -->
      #
      def create_ext_from_array: ([ String, String ] | [ String, String, boolish ] ary) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_hash(hash)
      # -->
      #
      def create_ext_from_hash: (Hash[String, String | boolish] hash) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_ext_from_string(str)
      # -->
      #
      def create_ext_from_string: (String str) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - create_extension(*arg)
      # -->
      #
      def create_extension: (String oid, String value, ?boolish critical) -> Extension

      def crl: () -> CRL?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - crl=(p1)
      # -->
      #
      def crl=: (CRL crl) -> CRL

      def issuer_certificate: () -> Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - issuer_certificate=(p1)
      # -->
      #
      def issuer_certificate=: (Certificate cert) -> Certificate

      def subject_certificate: () -> Certificate?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - subject_certificate=(p1)
      # -->
      #
      def subject_certificate=: (Certificate cert) -> Certificate

      def subject_request: () -> Request?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - subject_request=(p1)
      # -->
      #
      def subject_request=: (Request request) -> Request

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509ext.c
      #   - new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)
      # -->
      #
      def initialize: (?Certificate? issuer_cert, ?Certificate? subject_cert, ?Request? request, ?CRL? crl) -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
    # An X.509 name represents a hostname, email address or other entity associated
    # with a public key.
    #
    # You can create a Name by parsing a distinguished name String or by supplying
    # the distinguished name as an Array.
    #
    #     name = OpenSSL::X509::Name.parse_rfc2253 'DC=example,CN=nobody'
    #
    #     name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]
    #
    class Name
      type distinguished_name = [ String, String ]

      type template = Hash[String, Integer]

      include OpenSSL::Marshal

      include Comparable

      extend OpenSSL::Marshal::ClassMethods

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      #
      alias self.parse self.parse_openssl

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      # Parses the string representation of a distinguished name. Two different forms
      # are supported:
      #
      # *   OpenSSL format (`X509_NAME_oneline()`) used by `#to_s`. For example:
      #     `/DC=com/DC=example/CN=nobody`
      # *   OpenSSL format (`X509_NAME_print()`) used by
      #     `#to_s(OpenSSL::X509::Name::COMPAT)`. For example: `DC=com, DC=example,
      #     CN=nobody`
      #
      #
      # Neither of them is standardized and has quirks and inconsistencies in handling
      # of escaped characters or multi-valued RDNs.
      #
      # Use of this method is discouraged in new applications. See Name.parse_rfc2253
      # and #to_utf8 for the alternative.
      #
      def self.parse_openssl: (String str, ?template template) -> instance

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)
      # -->
      # Parses the UTF-8 string representation of a distinguished name, according to
      # RFC 2253.
      #
      # See also #to_utf8 for the opposite operation.
      #
      def self.parse_rfc2253: (String str, ?template template) -> instance

      public

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # Compares this Name with *other* and returns `0` if they are the same and `-1`
      # or `+1` if they are greater or less than each other respectively. Returns
      # `nil` if they are not comparable (i.e. different types).
      #
      alias <=> cmp

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.add_entry(oid, value [, type], loc: -1, set: 0) => self
      # -->
      # Adds a new entry with the given *oid* and *value* to this name.  The *oid* is
      # an object identifier defined in ASN.1.  Some common OIDs are:
      #
      # C
      # :   Country Name
      # CN
      # :   Common Name
      # DC
      # :   Domain Component
      # O
      # :   Organization Name
      # OU
      # :   Organizational Unit Name
      # ST
      # :   State or Province Name
      #
      #
      # The optional keyword parameters *loc* and *set* specify where to insert the
      # new attribute. Refer to the manpage of X509_NAME_add_entry(3) for details.
      # *loc* defaults to -1 and *set* defaults to 0. This appends a single-valued RDN
      # to the end.
      #
      def add_entry: (String oid, String value, ?loc: Integer, ?set: Integer) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.cmp(other) -> -1 | 0 | 1 | nil
      #   - name <=> other  -> -1 | 0 | 1 | nil
      # -->
      # Compares this Name with *other* and returns `0` if they are the same and `-1`
      # or `+1` if they are greater or less than each other respectively. Returns
      # `nil` if they are not comparable (i.e. different types).
      #
      def cmp: (untyped other) -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.eql?(other) -> true | false
      # -->
      # Returns true if *name* and *other* refer to the same hash key.
      #
      def eql?: (instance other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.hash => integer
      # -->
      # The hash value returned is suitable for use as a certificate's filename in a
      # CA path.
      #
      def hash: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.hash_old => integer
      # -->
      # Returns an MD5 based hash used in OpenSSL 0.9.X.
      #
      def hash_old: () -> Integer

      def inspect: () -> String

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - pretty_print(q)
      # -->
      #
      def pretty_print: (untyped q) -> untyped

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_a => [[name, data, type], ...]
      # -->
      # Returns an Array representation of the distinguished name suitable for passing
      # to ::new
      #
      def to_a: () -> Array[[ String, String, Integer ]]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_der => string
      # -->
      # Converts the name to DER encoding
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_s         -> string
      #   - name.to_s(format) -> string
      # -->
      # Returns a String representation of the Distinguished Name. *format* is one of:
      #
      # *   OpenSSL::X509::Name::COMPAT
      # *   OpenSSL::X509::Name::RFC2253
      # *   OpenSSL::X509::Name::ONELINE
      # *   OpenSSL::X509::Name::MULTILINE
      #
      #
      # If *format* is omitted, the largely broken and traditional OpenSSL format
      # (`X509_NAME_oneline()` format) is chosen.
      #
      # **Use of this method is discouraged.** None of the formats other than
      # OpenSSL::X509::Name::RFC2253 is standardized and may show an inconsistent
      # behavior through OpenSSL versions.
      #
      # It is recommended to use #to_utf8 instead, which is equivalent to calling
      # `name.to_s(OpenSSL::X509::Name::RFC2253).force_encoding("UTF-8")`.
      #
      def to_s: (?format format) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - name.to_utf8 -> string
      # -->
      # Returns an UTF-8 representation of the distinguished name, as specified in
      # [RFC 2253](https://www.ietf.org/rfc/rfc2253.txt).
      #
      def to_utf8: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - X509::Name.new                               => name
      #   - X509::Name.new(der)                          => name
      #   - X509::Name.new(distinguished_name)           => name
      #   - X509::Name.new(distinguished_name, template) => name
      # -->
      # Creates a new Name.
      #
      # A name may be created from a DER encoded string *der*, an Array representing a
      # *distinguished_name* or a *distinguished_name* along with a *template*.
      #
      #     name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]
      #
      #     name = OpenSSL::X509::Name.new name.to_der
      #
      # See add_entry for a description of the *distinguished_name* Array's contents
      #
      def initialize: (distinguished_name name, template template) -> void
                    | (Array[distinguished_name] names) -> void
                    | (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509name.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Breaks the name returned into multiple lines if longer than 80 characters.
      #
      COMPAT: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # The default object type for name entries.
      #
      DEFAULT_OBJECT_TYPE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns a multiline format.
      #
      MULTILINE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # The default object type template for name entries.
      #
      OBJECT_TYPE_TEMPLATE: template

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns a more readable format than RFC2253.
      #
      ONELINE: Integer

      # <!-- rdoc-file=ext/openssl/ossl_x509name.c -->
      # A flag for #to_s.
      #
      # Returns an RFC2253 format name.
      #
      RFC2253: Integer

      type format = Integer

      module RFC2253DN
        def self.expand_hexstring: (untyped str) -> untyped

        def self.expand_pair: (untyped str) -> untyped

        def self.expand_value: (untyped str1, untyped str2, untyped str3) -> untyped

        def self.scan: (untyped dn) -> untyped

        private

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_hexstring(str)
        # -->
        #
        def expand_hexstring: (untyped str) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_pair(str)
        # -->
        #
        def expand_pair: (untyped str) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - expand_value(str1, str2, str3)
        # -->
        #
        def expand_value: (untyped str1, untyped str2, untyped str3) -> untyped

        # <!--
        #   rdoc-file=ext/openssl/lib/openssl/x509.rb
        #   - scan(dn)
        # -->
        #
        def scan: (String dn) -> Array[distinguished_name]

        AttributeType: Regexp

        AttributeValue: Regexp

        HexChar: Regexp

        HexPair: Regexp

        HexString: Regexp

        Pair: Regexp

        QuoteChar: Regexp

        Special: String

        StringChar: Regexp

        TypeAndValue: Regexp
      end
    end

    class NameError < OpenSSL::OpenSSLError
    end

    class Request
      include OpenSSL::Marshal

      extend OpenSSL::Marshal::ClassMethods

      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (untyped other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - add_attribute(p1)
      # -->
      #
      def add_attribute: (Attribute attribute) -> Attribute

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - attributes()
      # -->
      #
      def attributes: () -> Array[Attribute]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - attributes=(p1)
      # -->
      #
      def attributes=: (Array[Attribute] attributes) -> Array[Attribute]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - public_key()
      # -->
      #
      def public_key: () -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - public_key=(p1)
      # -->
      #
      def public_key=: (PKey::PKey public_key) -> PKey::PKey

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - sign(p1, p2)
      # -->
      #
      def sign: (PKey::PKey key, Digest | String digest) -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - signature_algorithm()
      # -->
      #
      def signature_algorithm: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - subject()
      # -->
      #
      def subject: () -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - subject=(p1)
      # -->
      #
      def subject=: (Name subject) -> Name

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_pem()
      # -->
      #
      def to_pem: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_s()
      # -->
      #
      alias to_s to_pem

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - to_text()
      # -->
      #
      def to_text: () -> String

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - verify(p1)
      # -->
      # Checks that cert signature is made with PRIVversion of this PUBLIC 'key'
      #
      def verify: (PKey::PKey key) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - version()
      # -->
      #
      def version: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - version=(p1)
      # -->
      #
      def version=: (Integer version) -> Integer

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - new(p1 = v1)
      # -->
      #
      def initialize: (?String der) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509req.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class RequestError < OpenSSL::OpenSSLError
    end

    class Revoked
      public

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - ==(other)
      # -->
      #
      def ==: (untyped other) -> bool

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - add_extension(p1)
      # -->
      #
      def add_extension: (Extension ext) -> Extension

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - extensions()
      # -->
      # Gets X509v3 extensions as array of X509Ext objects
      #
      def extensions: () -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - extensions=(p1)
      # -->
      # Sets X509_EXTENSIONs
      #
      def extensions=: (Array[Extension] extensions) -> Array[Extension]

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - serial()
      # -->
      #
      def serial: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - serial=(p1)
      # -->
      #
      def serial=: (Integer integer) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - time()
      # -->
      #
      def time: () -> Time?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - time=(p1)
      # -->
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - to_der()
      # -->
      #
      def to_der: () -> String

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - new(*args)
      # -->
      #
      def initialize: (*untyped) -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509revoked.c
      #   - initialize_copy(p1)
      # -->
      #
      def initialize_copy: (instance) -> void
    end

    class RevokedError < OpenSSL::OpenSSLError
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
    # The X509 certificate store holds trusted CA certificates used to verify peer
    # certificates.
    #
    # The easiest way to create a useful certificate store is:
    #
    #     cert_store = OpenSSL::X509::Store.new
    #     cert_store.set_default_paths
    #
    # This will use your system's built-in certificates.
    #
    # If your system does not have a default set of certificates you can obtain a
    # set extracted from Mozilla CA certificate store by cURL maintainers here:
    # https://curl.haxx.se/docs/caextract.html (You may wish to use the
    # firefox-db2pem.sh script to extract the certificates from a local install to
    # avoid man-in-the-middle attacks.)
    #
    # After downloading or generating a cacert.pem from the above link you can
    # create a certificate store from the pem file like this:
    #
    #     cert_store = OpenSSL::X509::Store.new
    #     cert_store.add_file 'cacert.pem'
    #
    # The certificate store can be used with an SSLSocket like this:
    #
    #     ssl_context = OpenSSL::SSL::SSLContext.new
    #     ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
    #     ssl_context.cert_store = cert_store
    #
    #     tcp_socket = TCPSocket.open 'example.com', 443
    #
    #     ssl_socket = OpenSSL::SSL::SSLSocket.new tcp_socket, ssl_context
    #
    class Store
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_cert(cert) -> self
      # -->
      # Adds the OpenSSL::X509::Certificate *cert* to the certificate store.
      #
      # See also the man page X509_STORE_add_cert(3).
      #
      def add_cert: (Certificate certificate) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_crl(crl) -> self
      # -->
      # Adds the OpenSSL::X509::CRL *crl* to the store.
      #
      # See also the man page X509_STORE_add_crl(3).
      #
      def add_crl: (CRL crl) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_file(file) -> self
      # -->
      # Adds the certificates in *file* to the certificate store. *file* is the path
      # to the file, and the file contains one or more certificates in PEM format
      # concatenated together.
      #
      # See also the man page X509_LOOKUP_file(3).
      #
      def add_file: (String file) -> self

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.add_path(path) -> self
      # -->
      # Adds *path* as the hash dir to be looked up by the store.
      #
      # See also the man page X509_LOOKUP_hash_dir(3).
      #
      def add_path: (String path) -> self

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The certificate chain constructed by the last call of #verify.
      #
      # See also StoreContext#chain.
      #
      def chain: () -> Array[Certificate]?

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The error code set by the last call of #verify.
      #
      # See also StoreContext#error.
      #
      def error: () -> Integer?

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The description for the error code set by the last call of #verify.
      #
      # See also StoreContext#error_string.
      #
      def error_string: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.flags = flags
      # -->
      # Sets the default flags used by certificate chain verification performed with
      # the Store.
      #
      # *flags* consists of zero or more of the constants defined in OpenSSL::X509
      # with name V_FLAG_* or'ed together.
      #
      # OpenSSL::X509::StoreContext#flags= can be used to change the flags for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_flags(3).
      #
      def flags=: (Integer flags) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.purpose = purpose
      # -->
      # Sets the store's default verification purpose. If specified, the verifications
      # on the store will check every certificate's extensions are consistent with the
      # purpose. The purpose is specified by constants:
      #
      # *   X509::PURPOSE_SSL_CLIENT
      # *   X509::PURPOSE_SSL_SERVER
      # *   X509::PURPOSE_NS_SSL_SERVER
      # *   X509::PURPOSE_SMIME_SIGN
      # *   X509::PURPOSE_SMIME_ENCRYPT
      # *   X509::PURPOSE_CRL_SIGN
      # *   X509::PURPOSE_ANY
      # *   X509::PURPOSE_OCSP_HELPER
      # *   X509::PURPOSE_TIMESTAMP_SIGN
      #
      #
      # OpenSSL::X509::StoreContext#purpose= can be used to change the value for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_purpose(3).
      #
      def purpose=: (Integer purpose) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.set_default_paths
      # -->
      # Configures *store* to look up CA certificates from the system default
      # certificate store as needed basis. The location of the store can usually be
      # determined by:
      #
      # *   OpenSSL::X509::DEFAULT_CERT_FILE
      # *   OpenSSL::X509::DEFAULT_CERT_DIR
      #
      #
      # See also the man page X509_STORE_set_default_paths(3).
      #
      def set_default_paths: () -> nil

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.time = time
      # -->
      # Sets the time to be used in the certificate verifications with the store. By
      # default, if not specified, the current system time is used.
      #
      # OpenSSL::X509::StoreContext#time= can be used to change the value for a single
      # verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_time(3).
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.trust = trust
      # -->
      # Sets the default trust settings used by the certificate verification with the
      # store.
      #
      # OpenSSL::X509::StoreContext#trust= can be used to change the value for a
      # single verification operation.
      #
      # See also the man page X509_VERIFY_PARAM_set_trust(3).
      #
      def trust=: (Integer trust) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - store.verify(cert, chain = nil) -> true | false
      # -->
      # Performs a certificate verification on the OpenSSL::X509::Certificate *cert*.
      #
      # *chain* can be an array of OpenSSL::X509::Certificate that is used to
      # construct the certificate chain.
      #
      # If a block is given, it overrides the callback set by #verify_callback=.
      #
      # After finishing the verification, the error information can be retrieved by
      # #error, #error_string, and the resulting complete certificate chain can be
      # retrieved by #chain.
      #
      def verify: (Certificate certificate, ?Array[Certificate] chain) ?{ (bool preverify_ok, StoreContext store_ctx) -> boolish } -> boolish

      # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
      # The callback for additional certificate verification. It is invoked for each
      # certificate in the chain and can be used to implement custom certificate
      # verification conditions.
      #
      # The callback is invoked with two values, a boolean that indicates if the
      # pre-verification by OpenSSL has succeeded or not, and the StoreContext in use.
      #
      # The callback can use StoreContext#error= to change the error code as needed.
      # The callback must return either true or false.
      #
      # NOTE: any exception raised within the callback will be ignored.
      #
      # See also the man page X509_STORE_CTX_set_verify_cb(3).
      #
      def verify_callback: () -> (^(bool preverify_ok, StoreContext store_ctx) -> boolish | nil)

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - verify_callback=(p1)
      # -->
      # General callback for OpenSSL verify
      #
      def verify_callback=: [U] (^(bool preverify_ok, StoreContext store_ctx) -> boolish) -> U

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - X509::Store.new => store
      # -->
      # Creates a new X509::Store.
      #
      def initialize: () -> void
    end

    # <!-- rdoc-file=ext/openssl/ossl_x509store.c -->
    # A StoreContext is used while validating a single certificate and holds the
    # status involved.
    #
    class StoreContext
      public

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.chain -> nil | Array of X509::Certificate
      # -->
      # Returns the verified chain.
      #
      # See also the man page X509_STORE_CTX_set0_verified_chain(3).
      #
      def chain: () -> Array[Certificate]?

      # <!--
      #   rdoc-file=ext/openssl/lib/openssl/x509.rb
      #   - cleanup()
      # -->
      #
      def cleanup: () -> void

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.current_cert -> X509::Certificate
      # -->
      # Returns the certificate which caused the error.
      #
      # See also the man page X509_STORE_CTX_get_current_cert(3).
      #
      def current_cert: () -> Certificate

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.current_crl -> X509::CRL
      # -->
      # Returns the CRL which caused the error.
      #
      # See also the man page X509_STORE_CTX_get_current_crl(3).
      #
      def current_crl: () -> CRL

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error -> Integer
      # -->
      # Returns the error code of *stctx*. This is typically called after #verify is
      # done, or from the verification callback set to
      # OpenSSL::X509::Store#verify_callback=.
      #
      # See also the man page X509_STORE_CTX_get_error(3).
      #
      def error: () -> Integer?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error = error_code
      # -->
      # Sets the error code of *stctx*. This is used by the verification callback set
      # to OpenSSL::X509::Store#verify_callback=.
      #
      # See also the man page X509_STORE_CTX_set_error(3).
      #
      def error=: (Integer error) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error_depth -> Integer
      # -->
      # Returns the depth of the chain. This is used in combination with #error.
      #
      # See also the man page X509_STORE_CTX_get_error_depth(3).
      #
      def error_depth: () -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.error_string -> String
      # -->
      # Returns the human readable error string corresponding to the error code
      # retrieved by #error.
      #
      # See also the man page X509_verify_cert_error_string(3).
      #
      def error_string: () -> String?

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.flags = flags
      # -->
      # Sets the verification flags to the context. This overrides the default value
      # set by Store#flags=.
      #
      # See also the man page X509_VERIFY_PARAM_set_flags(3).
      #
      def flags=: (Integer flags) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.purpose = purpose
      # -->
      # Sets the purpose of the context. This overrides the default value set by
      # Store#purpose=.
      #
      # See also the man page X509_VERIFY_PARAM_set_purpose(3).
      #
      def purpose=: (Integer purpose) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.time = time
      # -->
      # Sets the time used in the verification. If not set, the current time is used.
      #
      # See also the man page X509_VERIFY_PARAM_set_time(3).
      #
      def time=: (Time time) -> Time

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.trust = trust
      # -->
      # Sets the trust settings of the context. This overrides the default value set
      # by Store#trust=.
      #
      # See also the man page X509_VERIFY_PARAM_set_trust(3).
      #
      def trust=: (Integer trust) -> Integer

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - stctx.verify -> true | false
      # -->
      # Performs the certificate verification using the parameters set to *stctx*.
      #
      # See also the man page X509_verify_cert(3).
      #
      def verify: () -> bool

      private

      # <!--
      #   rdoc-file=ext/openssl/ossl_x509store.c
      #   - StoreContext.new(store, cert = nil, untrusted = nil)
      # -->
      # Sets up a StoreContext for a verification of the X.509 certificate *cert*.
      #
      def initialize: (Store store, ?Certificate cert, ?Array[Certificate] chain) -> void
    end

    class StoreError < OpenSSL::OpenSSLError
    end
  end
end

# <!-- rdoc-file=ext/digest/digest.c -->
# This module provides a framework for message digest libraries.
#
# You may want to look at OpenSSL::Digest as it supports more algorithms.
#
# A cryptographic hash function is a procedure that takes data and returns a
# fixed bit string: the hash value, also known as *digest*. Hash functions are
# also called one-way functions, it is easy to compute a digest from a message,
# but it is infeasible to generate a message from a digest.
#
# ## Examples
#
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::SHA256.digest 'message'       #=> "\xABS\n\x13\xE4Y..."
#
#     sha256 = Digest::SHA256.new
#     sha256.digest 'message'               #=> "\xABS\n\x13\xE4Y..."
#
#     # Other encoding formats
#     Digest::SHA256.hexdigest 'message'    #=> "ab530a13e459..."
#     Digest::SHA256.base64digest 'message' #=> "q1MKE+RZFJgr..."
#
#     # Compute digest by chunks
#     md5 = Digest::MD5.new
#     md5.update 'message1'
#     md5 << 'message2'                     # << is an alias for update
#
#     md5.hexdigest                         #=> "94af09c09bb9..."
#
#     # Compute digest for a file
#     sha256 = Digest::SHA256.file 'testfile'
#     sha256.hexdigest
#
# Additionally digests can be encoded in "bubble babble" format as a sequence of
# consonants and vowels which is more recognizable and comparable than a
# hexadecimal digest.
#
#     require 'digest/bubblebabble'
#
#     Digest::SHA256.bubblebabble 'message' #=> "xopoh-fedac-fenyh-..."
#
# See the bubble babble specification at
# http://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt
# .
#
# ## Digest algorithms
#
# Different digest algorithms (or hash functions) are available:
#
# MD5
# :   See RFC 1321 The MD5 Message-Digest Algorithm
# RIPEMD-160
# :   As Digest::RMD160. See
#     http://homes.esat.kuleuven.be/~bosselae/ripemd160.html.
# SHA1
# :   See FIPS 180 Secure Hash Standard.
# SHA2 family
# :   See FIPS 180 Secure Hash Standard which defines the following algorithms:
#     *   SHA512
#     *   SHA384
#     *   SHA256
#
#
#
# The latest versions of the FIPS publications can be found here:
# http://csrc.nist.gov/publications/PubsFIPS.html.
#
module Digest
  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - Digest.bubblebabble(string) -> bubblebabble_string
  # -->
  # Returns a BubbleBabble encoded version of a given *string*.
  #
  def self.bubblebabble: (String) -> String

  def self.const_missing: (Symbol name) -> singleton(::Digest::Base)

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest.hexencode(string) -> hexencoded_string
  # -->
  # Generates a hex-encoded version of a given *string*.
  #
  def self.hexencode: (String) -> String

  private

  def bubblebabble: (String) -> String

  def hexencode: (String) -> String
end

# <!-- rdoc-file=ext/digest/lib/digest.rb -->
# A mutex for Digest().
#
Digest::REQUIRE_MUTEX: Thread::Mutex

# <!-- rdoc-file=ext/digest/digest.c -->
# This module provides instance methods for a digest implementation object to
# calculate message digest values.
#
module Digest::Instance
  public

  # <!-- rdoc-file=ext/digest/digest.c -->
  # Updates the digest using a given *string* and returns self.
  #
  # The update() method and the left-shift operator are overridden by each
  # implementation subclass. (One should be an alias for the other)
  #
  def <<: (String) -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj == another_digest_obj -> boolean
  #   - digest_obj == string -> boolean
  # -->
  # If a string is given, checks whether it is equal to the hex-encoded hash value
  # of the digest object.  If another digest instance is given, checks whether
  # they have the same hash value.  Otherwise returns false.
  #
  def ==: (::Digest::Instance | String) -> bool

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest(str = nil)
  # -->
  # If none is given, returns the resulting hash value of the digest in a base64
  # encoded form, keeping the digest's state.
  #
  # If a `string` is given, returns the hash value for the given `string` in a
  # base64 encoded form, resetting the digest to the initial state before and
  # after the process.
  #
  # In either case, the return value is properly padded with '=' and contains no
  # line feeds.
  #
  def base64digest: (?String? str) -> String

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest!()
  # -->
  # Returns the resulting hash value and resets the digest to the initial state.
  #
  def base64digest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.block_length -> integer
  # -->
  # Returns the block length of the digest.
  #
  # This method is overridden by each implementation subclass.
  #
  def block_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - digest_obj.bubblebabble -> hash_string
  # -->
  # Returns the resulting hash value in a Bubblebabble encoded form.
  #
  def bubblebabble: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest -> string
  #   - digest_obj.digest(string) -> string
  # -->
  # If none is given, returns the resulting hash value of the digest, keeping the
  # digest's state.
  #
  # If a *string* is given, returns the hash value for the given *string*,
  # resetting the digest to the initial state before and after the process.
  #
  def digest: (?String) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest! -> string
  # -->
  # Returns the resulting hash value and resets the digest to the initial state.
  #
  def digest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.digest_length -> integer
  # -->
  # Returns the length of the hash value of the digest.
  #
  # This method should be overridden by each implementation subclass. If not,
  # digest_obj.digest().length() is returned.
  #
  def digest_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - file(name)
  # -->
  # Updates the digest with the contents of a given file *name* and returns self.
  #
  def file: (String name) -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.hexdigest -> string
  #   - digest_obj.hexdigest(string) -> string
  # -->
  # If none is given, returns the resulting hash value of the digest in a
  # hex-encoded form, keeping the digest's state.
  #
  # If a *string* is given, returns the hash value for the given *string* in a
  # hex-encoded form, resetting the digest to the initial state before and after
  # the process.
  #
  def hexdigest: (?String) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.hexdigest! -> string
  # -->
  # Returns the resulting hash value in a hex-encoded form and resets the digest
  # to the initial state.
  #
  def hexdigest!: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.inspect -> string
  # -->
  # Creates a printable version of the digest object.
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.length -> integer
  #   - digest_obj.size -> integer
  # -->
  # Returns digest_obj.digest_length().
  #
  def length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.new -> another_digest_obj
  # -->
  # Returns a new, initialized copy of the digest object.  Equivalent to
  # digest_obj.clone().reset().
  #
  def new: () -> ::Digest::Base

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.reset -> digest_obj
  # -->
  # Resets the digest to the initial state and returns self.
  #
  # This method is overridden by each implementation subclass.
  #
  def reset: () -> self

  # <!-- rdoc-file=ext/digest/digest.c -->
  # Returns digest_obj.digest_length().
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.to_s -> string
  # -->
  # Returns digest_obj.hexdigest().
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.update(string) -> digest_obj
  #   - digest_obj << string -> digest_obj
  # -->
  # Updates the digest using a given *string* and returns self.
  #
  # The update() method and the left-shift operator are overridden by each
  # implementation subclass. (One should be an alias for the other)
  #
  def update: (String) -> self

  private

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_obj.instance_eval { finish } -> digest_obj
  # -->
  # Finishes the digest and returns the resulting hash value.
  #
  # This method is overridden by each implementation subclass and often made
  # private, because some of those subclasses may leave internal data
  # uninitialized.  Do not call this method from outside.  Use #digest!() instead,
  # which ensures that internal data be reset for security reasons.
  #
  def finish: () -> self
end

# <!-- rdoc-file=ext/digest/digest.c -->
# This module stands as a base class for digest implementation classes.
#
class Digest::Class
  include ::Digest::Instance

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - base64digest(str, *args)
  # -->
  # Returns the base64 encoded hash value of a given *string*.  The return value
  # is properly padded with '=' and contains no line feeds.
  #
  def self.base64digest: (String str, *untyped) -> String

  # <!--
  #   rdoc-file=ext/digest/bubblebabble/bubblebabble.c
  #   - Digest::Class.bubblebabble(string, ...) -> hash_string
  # -->
  # Returns the BubbleBabble encoded hash value of a given *string*.
  #
  def self.bubblebabble: (String, *untyped) -> String

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest::Class.digest(string, *parameters) -> hash_string
  # -->
  # Returns the hash value of a given *string*.  This is equivalent to
  # Digest::Class.new(*parameters).digest(string), where extra *parameters*, if
  # any, are passed through to the constructor and the *string* is passed to
  # #digest().
  #
  def self.digest: (String, *untyped) -> String

  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - file(name, *args)
  # -->
  # Creates a digest object and reads a given file, *name*. Optional arguments are
  # passed to the constructor of the digest class.
  #
  #     p Digest::SHA256.file("X11R6.8.2-src.tar.bz2").hexdigest
  #     # => "f02e3c85572dc9ad7cb77c2a638e3be24cc1b5bea9fdbb0b0299c9668475c534"
  #
  def self.file: (String name, *untyped) -> ::Digest::Class

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - Digest::Class.hexdigest(string[, ...]) -> hash_string
  # -->
  # Returns the hex-encoded hash value of a given *string*.  This is almost
  # equivalent to Digest.hexencode(Digest::Class.new(*parameters).digest(string)).
  #
  def self.hexdigest: (String, *untyped) -> String

  private

  def initialize: () -> self
end

# <!-- rdoc-file=ext/digest/digest.c -->
# This abstract class provides a common interface to message digest
# implementation classes written in C.
#
# ## Write a Digest subclass in C
# Digest::Base provides a common interface to message digest classes written in
# C. These classes must provide a struct of type rb_digest_metadata_t:
#     typedef int (*rb_digest_hash_init_func_t)(void *);
#     typedef void (*rb_digest_hash_update_func_t)(void *, unsigned char *, size_t);
#     typedef int (*rb_digest_hash_finish_func_t)(void *, unsigned char *);
#
#     typedef struct {
#       int api_version;
#       size_t digest_len;
#       size_t block_len;
#       size_t ctx_size;
#       rb_digest_hash_init_func_t init_func;
#       rb_digest_hash_update_func_t update_func;
#       rb_digest_hash_finish_func_t finish_func;
#     } rb_digest_metadata_t;
#
# This structure must be set as an instance variable named `metadata` (without
# the +@+ in front of the name). By example:
#      static const rb_digest_metadata_t sha1 = {
#         RUBY_DIGEST_API_VERSION,
#         SHA1_DIGEST_LENGTH,
#         SHA1_BLOCK_LENGTH,
#         sizeof(SHA1_CTX),
#         (rb_digest_hash_init_func_t)SHA1_Init,
#         (rb_digest_hash_update_func_t)SHA1_Update,
#         (rb_digest_hash_finish_func_t)SHA1_Finish,
#     };
#
#     rb_ivar_set(cDigest_SHA1, rb_intern("metadata"),
#                 Data_Wrap_Struct(0, 0, 0, (void *)&sha1));
#
class Digest::Base < Digest::Class
  public

  # <!-- rdoc-file=ext/digest/digest.c -->
  # Update the digest using given *string* and return `self`.
  #
  def <<: (String) -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.block_length -> Integer
  # -->
  # Return the block length of the digest in bytes.
  #
  def block_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.digest_length -> Integer
  # -->
  # Return the length of the hash value in bytes.
  #
  def digest_length: () -> Integer

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.reset -> digest_base
  # -->
  # Reset the digest to its initial state and return `self`.
  #
  def reset: () -> self

  # <!--
  #   rdoc-file=ext/digest/digest.c
  #   - digest_base.update(string) -> digest_base
  #   - digest_base << string -> digest_base
  # -->
  # Update the digest using given *string* and return `self`.
  #
  def update: (String) -> self

  private

  def finish: () -> String

  def initialize_copy: (::Digest::Base) -> self
end

# <!-- rdoc-file=ext/digest/sha1/sha1init.c -->
# A class for calculating message digests using the SHA-1 Secure Hash Algorithm
# by NIST (the US' National Institute of Standards and Technology), described in
# FIPS PUB 180-1.
#
# See Digest::Instance for digest API.
#
# SHA-1 calculates a digest of 160 bits (20 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::SHA1.hexdigest 'abc'      #=> "a9993e36..."
#
#     # Compute digest by chunks
#     sha1 = Digest::SHA1.new               # =>#<Digest::SHA1>
#     sha1.update "ab"
#     sha1 << "c"                           # alias for #update
#     sha1.hexdigest                        # => "a9993e36..."
#
#     # Use the same object to compute another digest
#     sha1.reset
#     sha1 << "message"
#     sha1.hexdigest                        # => "6f9b9af3..."
#
class Digest::SHA1 < Digest::Base
end

# <!-- rdoc-file=ext/digest/md5/md5init.c -->
# A class for calculating message digests using the MD5 Message-Digest Algorithm
# by RSA Data Security, Inc., described in RFC1321.
#
# MD5 calculates a digest of 128 bits (16 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::MD5.hexdigest 'abc'      #=> "90015098..."
#
#     # Compute digest by chunks
#     md5 = Digest::MD5.new               # =>#<Digest::MD5>
#     md5.update "ab"
#     md5 << "c"                           # alias for #update
#     md5.hexdigest                        # => "90015098..."
#
#     # Use the same object to compute another digest
#     md5.reset
#     md5 << "message"
#     md5.hexdigest                        # => "78e73102..."
#
class Digest::MD5 < Digest::Base
end

# <!-- rdoc-file=ext/digest/rmd160/rmd160init.c -->
# A class for calculating message digests using RIPEMD-160 cryptographic hash
# function, designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.
#
# RMD160 calculates a digest of 160 bits (20 bytes).
#
# ## Examples
#     require 'digest'
#
#     # Compute a complete digest
#     Digest::RMD160.hexdigest 'abc'      #=> "8eb208f7..."
#
#     # Compute digest by chunks
#     rmd160 = Digest::RMD160.new               # =>#<Digest::RMD160>
#     rmd160.update "ab"
#     rmd160 << "c"                           # alias for #update
#     rmd160.hexdigest                        # => "8eb208f7..."
#
#     # Use the same object to compute another digest
#     rmd160.reset
#     rmd160 << "message"
#     rmd160.hexdigest                        # => "1dddbe1b..."
#
class Digest::RMD160 < Digest::Base
end

class Digest::SHA256 < Digest::Base
end

class Digest::SHA384 < Digest::Base
end

class Digest::SHA512 < Digest::Base
end

%a{annotate:rdoc:skip}
class Object
  # <!--
  #   rdoc-file=ext/digest/lib/digest.rb
  #   - Digest(name) -> digest_subclass
  # -->
  # Returns a Digest subclass by `name` in a thread-safe manner even when
  # on-demand loading is involved.
  #
  #     require 'digest'
  #
  #     Digest("MD5")
  #     # => Digest::MD5
  #
  #     Digest(:SHA256)
  #     # => Digest::SHA256
  #
  #     Digest(:Foo)
  #     # => LoadError: library not found for class Digest::Foo -- digest/foo
  #
  def Digest: (String | Symbol name) -> singleton(::Digest::Base)
end

# <!-- rdoc-file=lib/fileutils.rb -->
# # fileutils.rb
#
# Copyright (c) 2000-2007 Minero Aoki
#
# This program is free software. You can distribute/modify this program under
# the same terms of ruby.
#
# ## module FileUtils
#
# Namespace for several file utility methods for copying, moving, removing, etc.
#
# ### Module Functions
#
#     require 'fileutils'
#
#     FileUtils.cd(dir, **options)
#     FileUtils.cd(dir, **options) {|dir| block }
#     FileUtils.pwd()
#     FileUtils.mkdir(dir, **options)
#     FileUtils.mkdir(list, **options)
#     FileUtils.mkdir_p(dir, **options)
#     FileUtils.mkdir_p(list, **options)
#     FileUtils.rmdir(dir, **options)
#     FileUtils.rmdir(list, **options)
#     FileUtils.ln(target, link, **options)
#     FileUtils.ln(targets, dir, **options)
#     FileUtils.ln_s(target, link, **options)
#     FileUtils.ln_s(targets, dir, **options)
#     FileUtils.ln_sf(target, link, **options)
#     FileUtils.cp(src, dest, **options)
#     FileUtils.cp(list, dir, **options)
#     FileUtils.cp_r(src, dest, **options)
#     FileUtils.cp_r(list, dir, **options)
#     FileUtils.mv(src, dest, **options)
#     FileUtils.mv(list, dir, **options)
#     FileUtils.rm(list, **options)
#     FileUtils.rm_r(list, **options)
#     FileUtils.rm_rf(list, **options)
#     FileUtils.install(src, dest, **options)
#     FileUtils.chmod(mode, list, **options)
#     FileUtils.chmod_R(mode, list, **options)
#     FileUtils.chown(user, group, list, **options)
#     FileUtils.chown_R(user, group, list, **options)
#     FileUtils.touch(list, **options)
#
# Possible `options` are:
#
# `:force`
# :   forced operation (rewrite files if exist, remove directories if not empty,
#     etc.);
# `:verbose`
# :   print command to be run, in bash syntax, before performing it;
# `:preserve`
# :   preserve object's group, user and modification time on copying;
# `:noop`
# :   no changes are made (usable in combination with `:verbose` which will
#     print the command to run)
#
#
# Each method documents the options that it honours. See also ::commands,
# ::options and ::options_of methods to introspect which command have which
# options.
#
# All methods that have the concept of a "source" file or directory can take
# either one file or a list of files in that argument.  See the method
# documentation for examples.
#
# There are some `low level' methods, which do not accept keyword arguments:
#
#     FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
#     FileUtils.copy_file(src, dest, preserve = false, dereference = true)
#     FileUtils.copy_stream(srcstream, deststream)
#     FileUtils.remove_entry(path, force = false)
#     FileUtils.remove_entry_secure(path, force = false)
#     FileUtils.remove_file(path, force = false)
#     FileUtils.compare_file(path_a, path_b)
#     FileUtils.compare_stream(stream_a, stream_b)
#     FileUtils.uptodate?(file, cmp_list)
#
# ## module FileUtils::Verbose
#
# This module has all methods of FileUtils module, but it outputs messages
# before acting.  This equates to passing the `:verbose` flag to methods in
# FileUtils.
#
# ## module FileUtils::NoWrite
#
# This module has all methods of FileUtils module, but never changes
# files/directories.  This equates to passing the `:noop` flag to methods in
# FileUtils.
#
# ## module FileUtils::DryRun
#
# This module has all methods of FileUtils module, but never changes
# files/directories.  This equates to passing the `:noop` and `:verbose` flags
# to methods in FileUtils.
#
module FileUtils
  VERSION: String

  type mode = Integer | String

  type path = string | _ToPath

  type pathlist = path | Array[path]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cd(dir, verbose: nil) { |dir| ... }
  # -->
  # Changes the current directory to the directory `dir`.
  #
  # If this method is called with block, resumes to the previous working directory
  # after the block execution has finished.
  #
  #     FileUtils.cd('/')  # change directory
  #
  #     FileUtils.cd('/', verbose: true)   # change directory and report it
  #
  #     FileUtils.cd('/') do  # change directory
  #       # ...               # do something
  #     end                   # return to original directory
  #
  def self?.cd: (path dir, ?verbose: boolish) -> void
              | [X] (path dir, ?verbose: boolish) { (String) -> X } -> X

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chdir(dir, verbose: nil)
  # -->
  #
  alias self.chdir self.cd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chdir(dir, verbose: nil)
  # -->
  #
  alias chdir cd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chmod(mode, list, noop: nil, verbose: nil)
  # -->
  # Changes permission bits on the named files (in `list`) to the bit pattern
  # represented by `mode`.
  #
  # `mode` is the symbolic and absolute mode can be used.
  #
  # Absolute mode is
  #     FileUtils.chmod 0755, 'somecommand'
  #     FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)
  #     FileUtils.chmod 0755, '/usr/bin/ruby', verbose: true
  #
  # Symbolic mode is
  #     FileUtils.chmod "u=wrx,go=rx", 'somecommand'
  #     FileUtils.chmod "u=wr,go=rr", %w(my.rb your.rb his.rb her.rb)
  #     FileUtils.chmod "u=wrx,go=rx", '/usr/bin/ruby', verbose: true
  #
  # "a"
  # :   is user, group, other mask.
  # "u"
  # :   is user's mask.
  # "g"
  # :   is group's mask.
  # "o"
  # :   is other's mask.
  # "w"
  # :   is write permission.
  # "r"
  # :   is read permission.
  # "x"
  # :   is execute permission.
  # "X"
  # :   is execute permission for directories only, must be used in conjunction
  #     with "+"
  # "s"
  # :   is uid, gid.
  # "t"
  # :   is sticky bit.
  # "+"
  # :   is added to a class given the specified mode.
  # "-"
  # :   Is removed from a given class given mode.
  # "="
  # :   Is the exact nature of the class will be given a specified mode.
  #
  def self?.chmod: (mode mode, pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  # -->
  # Changes permission bits on the named files (in `list`) to the bit pattern
  # represented by `mode`.
  #
  #     FileUtils.chmod_R 0700, "/tmp/app.#{$$}"
  #     FileUtils.chmod_R "u=wrx", "/tmp/app.#{$$}"
  #
  def self?.chmod_R: (mode mode, pathlist list, ?noop: boolish, ?verbose: boolish, ?force: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chown(user, group, list, noop: nil, verbose: nil)
  # -->
  # Changes owner and group on the named files (in `list`) to the user `user` and
  # the group `group`.  `user` and `group` may be an ID (Integer/String) or a name
  # (String). If `user` or `group` is nil, this method does not change the
  # attribute.
  #
  #     FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'
  #     FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), verbose: true
  #
  def self?.chown: (String? user, String? group, pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  # -->
  # Changes owner and group on the named files (in `list`) to the user `user` and
  # the group `group` recursively. `user` and `group` may be an ID
  # (Integer/String) or a name (String).  If `user` or `group` is nil, this method
  # does not change the attribute.
  #
  #     FileUtils.chown_R 'www', 'www', '/var/www/htdocs'
  #     FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', verbose: true
  #
  def self?.chown_R: (String? user, String? group, pathlist list, ?noop: boolish, ?verbose: boolish, ?force: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - collect_method(opt)
  # -->
  # Returns an Array of methods names which have the option `opt`.
  #
  #     p FileUtils.collect_method(:preserve) #=> ["cp", "cp_r", "copy", "install"]
  #
  def self.collect_method: (Symbol opt) -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - commands()
  # -->
  # Returns an Array of names of high-level methods that accept any keyword
  # arguments.
  #
  #     p FileUtils.commands  #=> ["chmod", "cp", "cp_r", "install", ...]
  #
  def self.commands: () -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - compare_file(a, b)
  # -->
  # Returns true if the contents of a file `a` and a file `b` are identical.
  #
  #     FileUtils.compare_file('somefile', 'somefile')       #=> true
  #     FileUtils.compare_file('/dev/null', '/dev/urandom')  #=> false
  #
  def self?.compare_file: (path a, path b) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cmp(a, b)
  # -->
  #
  alias self.cmp self.compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cmp(a, b)
  # -->
  #
  alias cmp compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - identical?(a, b)
  # -->
  #
  alias self.identical? self.compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - identical?(a, b)
  # -->
  #
  alias identical? compare_file

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - compare_stream(a, b)
  # -->
  # Returns true if the contents of a stream `a` and `b` are identical.
  #
  def self?.compare_stream: (IO a, IO b) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  # -->
  # Copies a file system entry `src` to `dest`. If `src` is a directory, this
  # method copies its contents recursively. This method preserves file types, c.f.
  # symlink, directory... (FIFO, device files and etc. are not supported yet)
  #
  # Both of `src` and `dest` must be a path name. `src` must exist, `dest` must
  # not exist.
  #
  # If `preserve` is true, this method preserves owner, group, and modified time.
  # Permissions are copied regardless `preserve`.
  #
  # If `dereference_root` is true, this method dereference tree root.
  #
  # If `remove_destination` is true, this method removes each destination file
  # before copy.
  #
  def self?.copy_entry: (path src, path dest, ?boolish preserve, ?boolish dereference_root, ?boolish remove_destination) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_file(src, dest, preserve = false, dereference = true)
  # -->
  # Copies file contents of `src` to `dest`. Both of `src` and `dest` must be a
  # path name.
  #
  def self?.copy_file: (path src, path dest, ?boolish preserve, ?boolish dereference) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy_stream(src, dest)
  # -->
  # Copies stream `src` to `dest`. `src` must respond to #read(n) and `dest` must
  # respond to #write(str).
  #
  def self?.copy_stream: (_Reader src, _Writer dest) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  # Copies a file content `src` to `dest`.  If `dest` is a directory, copies `src`
  # to `dest/src`.
  #
  # If `src` is a list of files, then `dest` must be a directory.
  #
  #     FileUtils.cp 'eval.c', 'eval.c.org'
  #     FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'
  #     FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', verbose: true
  #     FileUtils.cp 'symlink', 'dest'   # copy content, "dest" is not a symlink
  #
  def self?.cp: (pathlist src, path dest, ?preserve: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.copy self.cp

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - copy(src, dest, preserve: nil, noop: nil, verbose: nil)
  # -->
  #
  alias copy cp

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp_lr(src, dest, noop: nil, verbose: nil, dereference_root: true, remove_destination: false)
  # -->
  # Hard link `src` to `dest`. If `src` is a directory, this method links all its
  # contents recursively. If `dest` is a directory, links `src` to `dest/src`.
  #
  # `src` can be a list of files.
  #
  # If `dereference_root` is true, this method dereference tree root.
  #
  # If `remove_destination` is true, this method removes each destination file
  # before copy.
  #
  #     FileUtils.rm_r site_ruby + '/mylib', force: true
  #     FileUtils.cp_lr 'lib/', site_ruby + '/mylib'
  #
  #     # Examples of linking several files to target directory.
  #     FileUtils.cp_lr %w(mail.rb field.rb debug/), site_ruby + '/tmail'
  #     FileUtils.cp_lr Dir.glob('*.rb'), '/home/aamine/lib/ruby', noop: true, verbose: true
  #
  #     # If you want to link all contents of a directory instead of the
  #     # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,
  #     # use the following code.
  #     FileUtils.cp_lr 'src/.', 'dest'  # cp_lr('src', 'dest') makes dest/src, but this doesn't.
  #
  def self?.cp_lr: (pathlist src, path dest, ?noop: boolish, ?verbose: boolish, ?dereference_root: boolish, ?remove_destination: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - cp_r(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)
  # -->
  # Copies `src` to `dest`. If `src` is a directory, this method copies all its
  # contents recursively. If `dest` is a directory, copies `src` to `dest/src`.
  #
  # `src` can be a list of files.
  #
  # If `dereference_root` is true, this method dereference tree root.
  #
  # If `remove_destination` is true, this method removes each destination file
  # before copy.
  #
  #     # Installing Ruby library "mylib" under the site_ruby
  #     FileUtils.rm_r site_ruby + '/mylib', force: true
  #     FileUtils.cp_r 'lib/', site_ruby + '/mylib'
  #
  #     # Examples of copying several files to target directory.
  #     FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'
  #     FileUtils.cp_r Dir.glob('*.rb'), '/home/foo/lib/ruby', noop: true, verbose: true
  #
  #     # If you want to copy all contents of a directory instead of the
  #     # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,
  #     # use following code.
  #     FileUtils.cp_r 'src/.', 'dest'     # cp_r('src', 'dest') makes dest/src,
  #                                        # but this doesn't.
  #
  def self?.cp_r: (pathlist src, path dest, ?preserve: boolish, ?noop: boolish, ?verbose: boolish, ?dereference_root: boolish, ?remove_destination: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - have_option?(mid, opt)
  # -->
  # Returns true if the method `mid` have an option `opt`.
  #
  #     p FileUtils.have_option?(:cp, :noop)     #=> true
  #     p FileUtils.have_option?(:rm, :force)    #=> true
  #     p FileUtils.have_option?(:rm, :preserve) #=> false
  #
  def self.have_option?: (Symbol mid, Symbol opt) -> bool

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)
  # -->
  # If `src` is not same as `dest`, copies it and changes the permission mode to
  # `mode`.  If `dest` is a directory, destination is `dest`/`src`. This method
  # removes destination before copy.
  #
  #     FileUtils.install 'ruby', '/usr/local/bin/ruby', mode: 0755, verbose: true
  #     FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', verbose: true
  #
  def self?.install: (path src, path dest, ?mode: mode?, ?owner: String?, ?group: String?, ?preserve: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link_entry(src, dest, dereference_root = false, remove_destination = false)
  # -->
  # Hard links a file system entry `src` to `dest`. If `src` is a directory, this
  # method links its contents recursively.
  #
  # Both of `src` and `dest` must be a path name. `src` must exist, `dest` must
  # not exist.
  #
  # If `dereference_root` is true, this method dereferences the tree root.
  #
  # If `remove_destination` is true, this method removes each destination file
  # before copy.
  #
  def self?.link_entry: (path src, path dest, ?boolish dereference_root, ?boolish remove_destination) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - FileUtils.ln(target, link, force: nil, noop: nil, verbose: nil)
  #   - FileUtils.ln(target,  dir, force: nil, noop: nil, verbose: nil)
  #   - FileUtils.ln(targets, dir, force: nil, noop: nil, verbose: nil)
  # -->
  # In the first form, creates a hard link `link` which points to `target`. If
  # `link` already exists, raises Errno::EEXIST. But if the `force` option is set,
  # overwrites `link`.
  #
  #     FileUtils.ln 'gcc', 'cc', verbose: true
  #     FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'
  #
  # In the second form, creates a link `dir/target` pointing to `target`. In the
  # third form, creates several hard links in the directory `dir`, pointing to
  # each item in `targets`. If `dir` is not a directory, raises Errno::ENOTDIR.
  #
  #     FileUtils.cd '/sbin'
  #     FileUtils.ln %w(cp mv mkdir), '/bin'   # Now /sbin/cp and /bin/cp are linked.
  #
  def self?.ln: (pathlist src, path dest, ?force: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.link self.ln

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - link(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias link ln

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - FileUtils.ln_s(target, link, force: nil, noop: nil, verbose: nil)
  #   - FileUtils.ln_s(target,  dir, force: nil, noop: nil, verbose: nil)
  #   - FileUtils.ln_s(targets, dir, force: nil, noop: nil, verbose: nil)
  # -->
  # In the first form, creates a symbolic link `link` which points to `target`. If
  # `link` already exists, raises Errno::EEXIST. But if the `force` option is set,
  # overwrites `link`.
  #
  #     FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'
  #     FileUtils.ln_s 'verylongsourcefilename.c', 'c', force: true
  #
  # In the second form, creates a link `dir/target` pointing to `target`. In the
  # third form, creates several symbolic links in the directory `dir`, pointing to
  # each item in `targets`. If `dir` is not a directory, raises Errno::ENOTDIR.
  #
  #     FileUtils.ln_s Dir.glob('/bin/*.rb'), '/home/foo/bin'
  #
  def self?.ln_s: (pathlist src, path dest, ?force: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - symlink(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.symlink self.ln_s

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - symlink(src, dest, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias symlink ln_s

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - FileUtils.ln_sf(*args)
  # -->
  # Same as
  #
  #     FileUtils.ln_s(*args, force: true)
  #
  def self?.ln_sf: (pathlist src, path dest, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkdir(list, mode: nil, noop: nil, verbose: nil)
  # -->
  # Creates one or more directories.
  #
  #     FileUtils.mkdir 'test'
  #     FileUtils.mkdir %w(tmp data)
  #     FileUtils.mkdir 'notexist', noop: true  # Does not really create.
  #     FileUtils.mkdir 'tmp', mode: 0700
  #
  def self?.mkdir: (pathlist list, ?mode: Integer?, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  # -->
  # Creates a directory and all its parent directories. For example,
  #
  #     FileUtils.mkdir_p '/usr/local/lib/ruby'
  #
  # causes to make following directories, if they do not exist.
  #
  # *   /usr
  # *   /usr/local
  # *   /usr/local/lib
  # *   /usr/local/lib/ruby
  #
  #
  # You can pass several directories at a time in a list.
  #
  def self?.mkdir_p: (pathlist list, ?mode: mode?, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - makedirs(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.makedirs self.mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - makedirs(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias makedirs mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkpath(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.mkpath self.mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mkpath(list, mode: nil, noop: nil, verbose: nil)
  # -->
  #
  alias mkpath mkdir_p

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  # Moves file(s) `src` to `dest`.  If `file` and `dest` exist on the different
  # disk partition, the file is copied then the original file is removed.
  #
  #     FileUtils.mv 'badname.rb', 'goodname.rb'
  #     FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', force: true  # no error
  #
  #     FileUtils.mv %w(junk.txt dust.txt), '/home/foo/.trash/'
  #     FileUtils.mv Dir.glob('test*.rb'), 'test', noop: true, verbose: true
  #
  def self?.mv: (pathlist src, path dest, ?force: boolish, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - move(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias self.move self.mv

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - move(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias move mv

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - options()
  # -->
  # Returns an Array of option names.
  #
  #     p FileUtils.options  #=> ["noop", "force", "verbose", "preserve", "mode"]
  #
  def self.options: () -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - options_of(mid)
  # -->
  # Returns an Array of option names of the method `mid`.
  #
  #     p FileUtils.options_of(:rm)  #=> ["noop", "verbose", "force"]
  #
  def self.options_of: (Symbol mid) -> Array[String]

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - pwd()
  # -->
  # Returns the name of the current directory.
  #
  def self?.pwd: () -> String

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - getwd()
  # -->
  #
  alias self.getwd self.pwd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - getwd()
  # -->
  #
  alias getwd pwd

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_dir(path, force = false)
  # -->
  # Removes a directory `dir` and its contents recursively. This method ignores
  # StandardError if `force` is true.
  #
  def self?.remove_dir: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_entry(path, force = false)
  # -->
  # This method removes a file system entry `path`. `path` might be a regular
  # file, a directory, or something. If `path` is a directory, remove it
  # recursively.
  #
  # See also remove_entry_secure.
  #
  def self?.remove_entry: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_entry_secure(path, force = false)
  # -->
  # This method removes a file system entry `path`.  `path` shall be a regular
  # file, a directory, or something.  If `path` is a directory, remove it
  # recursively.  This method is required to avoid TOCTTOU
  # (time-of-check-to-time-of-use) local security vulnerability of rm_r. #rm_r
  # causes security hole when:
  #
  # *   Parent directory is world writable (including /tmp).
  # *   Removing directory tree includes world writable directory.
  # *   The system has symbolic link.
  #
  #
  # To avoid this security hole, this method applies special preprocess. If `path`
  # is a directory, this method chown(2) and chmod(2) all removing directories.
  # This requires the current process is the owner of the removing whole directory
  # tree, or is the super user (root).
  #
  # WARNING: You must ensure that **ALL** parent directories cannot be moved by
  # other untrusted users.  For example, parent directories should not be owned by
  # untrusted users, and should not be world writable except when the sticky bit
  # set.
  #
  # WARNING: Only the owner of the removing directory tree, or Unix super user
  # (root) should invoke this method.  Otherwise this method does not work.
  #
  # For details of this security vulnerability, see Perl's case:
  #
  # *   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448
  # *   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452
  #
  #
  # For fileutils.rb, this vulnerability is reported in [ruby-dev:26100].
  #
  def self?.remove_entry_secure: (path path, ?boolish force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove_file(path, force = false)
  # -->
  # Removes a file `path`. This method ignores StandardError if `force` is true.
  #
  def self?.remove_file: (path path, ?void force) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm(list, force: nil, noop: nil, verbose: nil)
  # -->
  # Remove file(s) specified in `list`.  This method cannot remove directories.
  # All StandardErrors are ignored when the :force option is set.
  #
  #     FileUtils.rm %w( junk.txt dust.txt )
  #     FileUtils.rm Dir.glob('*.so')
  #     FileUtils.rm 'NotExistFile', force: true   # never raises exception
  #
  def self?.rm: (pathlist list, ?force: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove(list, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias self.remove self.rm

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - remove(list, force: nil, noop: nil, verbose: nil)
  # -->
  #
  alias remove rm

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_f(list, noop: nil, verbose: nil)
  # -->
  # Equivalent to
  #
  #     FileUtils.rm(list, force: true)
  #
  def self?.rm_f: (pathlist list, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - safe_unlink(list, noop: nil, verbose: nil)
  # -->
  #
  alias self.safe_unlink self.rm_f

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - safe_unlink(list, noop: nil, verbose: nil)
  # -->
  #
  alias safe_unlink rm_f

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  # -->
  # remove files `list`[0] `list`[1]... If `list`[n] is a directory, removes its
  # all contents recursively. This method ignores StandardError when :force option
  # is set.
  #
  #     FileUtils.rm_r Dir.glob('/tmp/*')
  #     FileUtils.rm_r 'some_dir', force: true
  #
  # WARNING: This method causes local vulnerability if one of parent directories
  # or removing directory tree are world writable (including /tmp, whose
  # permission is 1777), and the current process has strong privilege such as Unix
  # super user (root), and the system has symbolic link.  For secure removing,
  # read the documentation of remove_entry_secure carefully, and set :secure
  # option to true. Default is `secure: false`.
  #
  # NOTE: This method calls remove_entry_secure if :secure option is set. See also
  # remove_entry_secure.
  #
  def self?.rm_r: (pathlist list, ?force: boolish, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rm_rf(list, noop: nil, verbose: nil, secure: nil)
  # -->
  # Equivalent to
  #
  #     FileUtils.rm_r(list, force: true)
  #
  # WARNING: This method causes local vulnerability. Read the documentation of
  # rm_r first.
  #
  def self?.rm_rf: (pathlist list, ?noop: boolish, ?verbose: boolish, ?secure: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmtree(list, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias self.rmtree self.rm_rf

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmtree(list, noop: nil, verbose: nil, secure: nil)
  # -->
  #
  alias rmtree rm_rf

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - rmdir(list, parents: nil, noop: nil, verbose: nil)
  # -->
  # Removes one or more directories.
  #
  #     FileUtils.rmdir 'somedir'
  #     FileUtils.rmdir %w(somedir anydir otherdir)
  #     # Does not really remove directory; outputs message.
  #     FileUtils.rmdir 'somedir', verbose: true, noop: true
  #
  def self?.rmdir: (pathlist list, ?parents: boolish, ?noop: boolish, ?verbose: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  # -->
  # Updates modification time (mtime) and access time (atime) of file(s) in
  # `list`.  Files are created if they don't exist.
  #
  #     FileUtils.touch 'timestamp'
  #     FileUtils.touch Dir.glob('*.c');  system 'make'
  #
  def self?.touch: (pathlist list, ?noop: boolish, ?verbose: boolish, ?mtime: (Time | Numeric)?, ?nocreate: boolish) -> void

  # <!--
  #   rdoc-file=lib/fileutils.rb
  #   - uptodate?(new, old_list)
  # -->
  # Returns true if `new` is newer than all `old_list`. Non-existent files are
  # older than any file.
  #
  #     FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \
  #         system 'make hello.o'
  #
  def self?.uptodate?: (path new, pathlist old_list) -> bool
end

# <!-- rdoc-file=ext/nkf/nkf.c -->
# NKF - Ruby extension for Network Kanji Filter
#
# ## Description
#
# This is a Ruby Extension version of nkf (Network Kanji Filter). It converts
# the first argument and returns converted result. Conversion details are
# specified by flags as the first argument.
#
# **Nkf** is a yet another kanji code converter among networks, hosts and
# terminals. It converts input kanji code to designated kanji code such as
# ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 or UTF-16.
#
# One of the most unique faculty of **nkf** is the guess of the input kanji
# encodings. It currently recognizes ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 and
# UTF-16. So users needn't set the input kanji code explicitly.
#
# By default, X0201 kana is converted into X0208 kana. For X0201 kana, SO/SI,
# SSO and ESC-(-I methods are supported. For automatic code detection, nkf
# assumes no X0201 kana in Shift_JIS. To accept X0201 in Shift_JIS, use **-X**,
# **-x** or **-S**.
#
# ## Flags
#
# ### -b -u
#
# Output is buffered (DEFAULT), Output is unbuffered.
#
# ### -j -s -e -w -w16 -w32
#
# Output code is ISO-2022-JP (7bit JIS), Shift_JIS, EUC-JP, UTF-8N, UTF-16BE,
# UTF-32BE. Without this option and compile option, ISO-2022-JP is assumed.
#
# ### -J -S -E -W -W16 -W32
#
# Input assumption is JIS 7 bit, Shift_JIS, EUC-JP, UTF-8, UTF-16, UTF-32.
#
# #### -J
#
# Assume  JIS input. It also accepts EUC-JP. This is the default. This flag does
# not exclude Shift_JIS.
#
# #### -S
#
# Assume Shift_JIS and X0201 kana input. It also accepts JIS. EUC-JP is
# recognized as X0201 kana. Without **-x** flag, X0201 kana (halfwidth kana) is
# converted into X0208.
#
# #### -E
#
# Assume EUC-JP input. It also accepts JIS. Same as -J.
#
# ### -t
#
# No conversion.
#
# ### -i_
#
# Output sequence to designate JIS-kanji. (DEFAULT B)
#
# ### -o_
#
# Output sequence to designate ASCII. (DEFAULT B)
#
# ### -r
#
# {de/en}crypt ROT13/47
#
# ### -[h](123) --hiragana --katakana --katakana-hiragana
#
# -h1 --hiragana
# :   Katakana to Hiragana conversion.
#
# -h2 --katakana
# :   Hiragana to Katakana conversion.
#
# -h3 --katakana-hiragana
# :   Katakana to Hiragana and Hiragana to Katakana conversion.
#
#
# ### -T
#
# Text mode output (MS-DOS)
#
# ### -l
#
# ISO8859-1 (Latin-1) support
#
# ### -f[`m` [- `n`]]
#
# Folding on `m` length with `n` margin in a line. Without this option, fold
# length is 60 and fold margin is 10.
#
# ### -F
#
# New line preserving line folding.
#
# ### -[Z](0-3)
#
# Convert X0208 alphabet (Fullwidth Alphabets) to ASCII.
#
# -Z -Z0
# :   Convert X0208 alphabet to ASCII.
#
# -Z1
# :   Converts X0208 kankaku to single ASCII space.
#
# -Z2
# :   Converts X0208 kankaku to double ASCII spaces.
#
# -Z3
# :   Replacing Fullwidth >, <, ", & into '&gt;', '&lt;', '&quot;', '&amp;' as
#     in HTML.
#
#
# ### -X -x
#
# Assume X0201 kana in MS-Kanji. With **-X** or without this option, X0201 is
# converted into X0208 Kana. With **-x**, try to preserve X0208 kana and do not
# convert X0201 kana to X0208. In JIS output, ESC-(-I is used. In EUC output,
# SSO is used.
#
# ### -[B](0-2)
#
# Assume broken JIS-Kanji input, which lost ESC. Useful when your site is using
# old B-News Nihongo patch.
#
# -B1
# :   allows any char after ESC-( or ESC-$.
#
# -B2
# :   forces ASCII after NL.
#
#
# ### -I
#
# Replacing non iso-2022-jp char into a geta character (substitute character in
# Japanese).
#
# ### -d -c
#
# Delete r in line feed, Add r in line feed.
#
# ### -[m](BQN0)
#
# MIME ISO-2022-JP/ISO8859-1 decode. (DEFAULT) To see ISO8859-1 (Latin-1) -l is
# necessary.
#
# -mB
# :   Decode MIME base64 encoded stream. Remove header or other part before
#
# conversion.
#
# -mQ
# :   Decode MIME quoted stream. '_' in quoted stream is converted to space.
#
# -mN
# :   Non-strict decoding.
#
# It allows line break in the middle of the base64 encoding.
#
# -m0
# :   No MIME decode.
#
#
# ### -M
#
# MIME encode. Header style. All ASCII code and control characters are intact.
# Kanji conversion is performed before encoding, so this cannot be used as a
# picture encoder.
#
# -MB
# :   MIME encode Base64 stream.
#
# -MQ
# :   Perform quoted encoding.
#
#
# ### -l
#
# Input and output code is ISO8859-1 (Latin-1) and ISO-2022-JP. **-s**, **-e**
# and **-x** are not compatible with this option.
#
# ### -[L](uwm)
#
# new line mode Without this option, nkf doesn't convert line breaks.
#
# -Lu
# :   unix (LF)
#
# -Lw
# :   windows (CRLF)
#
# -Lm
# :   mac (CR)
#
#
# ### --fj --unix --mac --msdos --windows
#
# convert for these system
#
# ### --jis --euc --sjis --mime --base64
#
# convert for named code
#
# ### --jis-input --euc-input --sjis-input --mime-input --base64-input
#
# assume input system
#
# ### --ic=`input codeset` --oc=`output codeset`
#
# Set the input or output codeset. NKF supports following codesets and those
# codeset name are case insensitive.
#
# ISO-2022-JP
# :   a.k.a. RFC1468, 7bit JIS, JUNET
#
# EUC-JP (eucJP-nkf)
# :   a.k.a. AT&T JIS, Japanese EUC, UJIS
#
# eucJP-ascii
# :   a.k.a. x-eucjp-open-19970715-ascii
#
# eucJP-ms
# :   a.k.a. x-eucjp-open-19970715-ms
#
# CP51932
# :   Microsoft Version of EUC-JP.
#
# Shift_JIS
# :   SJIS, MS-Kanji
#
# Windows-31J
# :   a.k.a. CP932
#
# UTF-8
# :   same as UTF-8N
#
# UTF-8N
# :   UTF-8 without BOM
#
# UTF-8-BOM
# :   UTF-8 with BOM
#
# UTF-16
# :   same as UTF-16BE
#
# UTF-16BE
# :   UTF-16 Big Endian without BOM
#
# UTF-16BE-BOM
# :   UTF-16 Big Endian with BOM
#
# UTF-16LE
# :   UTF-16 Little Endian without BOM
#
# UTF-16LE-BOM
# :   UTF-16 Little Endian with BOM
#
# UTF-32
# :   same as UTF-32BE
#
# UTF-32BE
# :   UTF-32 Big Endian without BOM
#
# UTF-32BE-BOM
# :   UTF-32 Big Endian with BOM
#
# UTF-32LE
# :   UTF-32 Little Endian without BOM
#
# UTF-32LE-BOM
# :   UTF-32 Little Endian with BOM
#
# UTF8-MAC
# :   NKDed UTF-8, a.k.a. UTF8-NFD (input only)
#
#
# ### --fb-{skip, html, xml, perl, java, subchar}
#
# Specify the way that nkf handles unassigned characters. Without this option,
# --fb-skip is assumed.
#
# ### --prefix= `escape character` `target character` ..
#
# When nkf converts to Shift_JIS, nkf adds a specified escape character to
# specified 2nd byte of Shift_JIS characters. 1st byte of argument is the escape
# character and following bytes are target characters.
#
# ### --no-cp932ext
#
# Handle the characters extended in CP932 as unassigned characters.
#
# ## --no-best-fit-chars
#
# When Unicode to Encoded byte conversion, don't convert characters which is not
# round trip safe. When Unicode to Unicode conversion, with this and -x option,
# nkf can be used as UTF converter. (In other words, without this and -x option,
# nkf doesn't save some characters)
#
# When nkf convert string which related to path, you should use this option.
#
# ### --cap-input
#
# Decode hex encoded characters.
#
# ### --url-input
#
# Unescape percent escaped characters.
#
# ### --
#
# Ignore rest of -option.
#
module NKF
  # <!--
  #   rdoc-file=ext/nkf/nkf.c
  #   - NKF.guess(str)  => encoding
  # -->
  # Returns guessed encoding of *str* by nkf routine.
  #
  def self.guess: (String str) -> Encoding

  # <!--
  #   rdoc-file=ext/nkf/nkf.c
  #   - NKF.nkf(opt, str)   => string
  # -->
  # Convert *str* and return converted result. Conversion details are specified by
  # *opt* as String.
  #
  #     require 'nkf'
  #     output = NKF.nkf("-s", input)
  #
  def self.nkf: (String opt, String str) -> String
end

NKF::ASCII: Encoding

NKF::AUTO: nil

NKF::BINARY: Encoding

NKF::EUC: Encoding

NKF::JIS: Encoding

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Release date of nkf
#
NKF::NKF_RELEASE_DATE: String

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Version of nkf
#
NKF::NKF_VERSION: String

NKF::NOCONV: nil

NKF::SJIS: Encoding

NKF::UNKNOWN: nil

NKF::UTF16: Encoding

NKF::UTF32: Encoding

NKF::UTF8: Encoding

# <!-- rdoc-file=ext/nkf/nkf.c -->
# Full version string of nkf
#
NKF::VERSION: String

# <!-- rdoc-file=lib/mutex_m.rb -->
# # mutex_m.rb
#
# When 'mutex_m' is required, any object that extends or includes Mutex_m will
# be treated like a Mutex.
#
# Start by requiring the standard library Mutex_m:
#
#     require "mutex_m.rb"
#
# From here you can extend an object with Mutex instance methods:
#
#     obj = Object.new
#     obj.extend Mutex_m
#
# Or mixin Mutex_m into your module to your class inherit Mutex instance methods
# --- remember to call super() in your class initialize method.
#
#     class Foo
#       include Mutex_m
#       def initialize
#         # ...
#         super()
#       end
#       # ...
#     end
#     obj = Foo.new
#     # this obj can be handled like Mutex
#
module Mutex_m
  def self.append_features: (Module cl) -> untyped

  def self.define_aliases: (Module cl) -> untyped

  def self.extend_object: (Object obj) -> untyped

  public

  def mu_extended: () -> untyped

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_lock()
  # -->
  # See Thread::Mutex#lock
  #
  def mu_lock: () -> Thread::Mutex

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_locked?()
  # -->
  # See Thread::Mutex#locked?
  #
  def mu_locked?: () -> bool

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_synchronize(&block)
  # -->
  # See Thread::Mutex#synchronize
  #
  def mu_synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_try_lock()
  # -->
  # See Thread::Mutex#try_lock
  #
  def mu_try_lock: () -> bool

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - mu_unlock()
  # -->
  # See Thread::Mutex#unlock
  #
  def mu_unlock: () -> Thread::Mutex

  # <!--
  #   rdoc-file=lib/mutex_m.rb
  #   - sleep(timeout = nil)
  # -->
  # See Thread::Mutex#sleep
  #
  def sleep: (?Numeric timeout) -> Integer?

  alias locked? mu_locked?

  alias lock mu_lock

  alias unlock mu_unlock

  alias try_lock mu_try_lock

  alias synchronize mu_synchronize

  private

  def initialize: (*untyped args) -> untyped

  def mu_initialize: () -> untyped
end

Mutex_m::VERSION: String

%a{annotate:rdoc:skip}
class Dir
  # <!--
  #   rdoc-file=lib/tmpdir.rb
  #   - tmpdir()
  # -->
  # Returns the operating system's temporary file path.
  #
  def self.tmpdir: () -> String

  # <!--
  #   rdoc-file=lib/tmpdir.rb
  #   - mktmpdir(prefix_suffix=nil, *rest, **options) { |dup| ... }
  # -->
  # Dir.mktmpdir creates a temporary directory.
  #
  # The directory is created with 0700 permission. Application should not change
  # the permission to make the temporary directory accessible from other users.
  #
  # The prefix and suffix of the name of the directory is specified by the
  # optional first argument, *prefix_suffix*.
  # *   If it is not specified or nil, "d" is used as the prefix and no suffix is
  #     used.
  # *   If it is a string, it is used as the prefix and no suffix is used.
  # *   If it is an array, first element is used as the prefix and second element
  #     is used as a suffix.
  #
  #
  #     Dir.mktmpdir {|dir| dir is ".../d..." }
  #     Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }
  #     Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }
  #
  # The directory is created under Dir.tmpdir or the optional second argument
  # *tmpdir* if non-nil value is given.
  #
  #     Dir.mktmpdir {|dir| dir is "#{Dir.tmpdir}/d..." }
  #     Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }
  #
  # If a block is given, it is yielded with the path of the directory. The
  # directory and its contents are removed using FileUtils.remove_entry before
  # Dir.mktmpdir returns. The value of the block is returned.
  #
  #     Dir.mktmpdir {|dir|
  #       # use the directory...
  #       open("#{dir}/foo", "w") { something using the file }
  #     }
  #
  # If a block is not given, The path of the directory is returned. In this case,
  # Dir.mktmpdir doesn't remove the directory.
  #
  #     dir = Dir.mktmpdir
  #     begin
  #       # use the directory...
  #       open("#{dir}/foo", "w") { something using the file }
  #     ensure
  #       # remove the directory.
  #       FileUtils.remove_entry dir
  #     end
  #
  def self.mktmpdir: (?String | [ String, String ] | nil, ?String?, ?max_try: Integer?) -> String
                   | [X] (?String | [ String, String ] | nil, ?String?, ?max_try: Integer?) { (String) -> X } -> X
end

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv is a thread-aware DNS resolver library written in Ruby.  Resolv can
# handle multiple DNS requests concurrently without blocking the entire Ruby
# interpreter.
#
# See also resolv-replace.rb to replace the libc resolver with Resolv.
#
# Resolv can look up various DNS resources using the DNS module directly.
#
# Examples:
#
#     p Resolv.getaddress "www.ruby-lang.org"
#     p Resolv.getname "210.251.121.214"
#
#     Resolv::DNS.open do |dns|
#       ress = dns.getresources "www.ruby-lang.org", Resolv::DNS::Resource::IN::A
#       p ress.map(&:address)
#       ress = dns.getresources "ruby-lang.org", Resolv::DNS::Resource::IN::MX
#       p ress.map { |r| [r.exchange.to_s, r.preference] }
#     end
#
# ## Bugs
#
# *   NIS is not supported.
# *   /etc/nsswitch.conf is not supported.
#
%a{annotate:rdoc:source:from=lib/resolv.rb}
class Resolv
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name, &block)
  # -->
  # Iterates over all IP addresses for `name`.
  #
  def self.each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address, &proc)
  # -->
  # Iterates over all hostnames for `address`.
  #
  def self.each_name: (String address) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Looks up the first IP address for `name`.
  #
  def self.getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Looks up all IP address for `name`.
  #
  def self.getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Looks up the hostname of `address`.
  #
  def self.getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Looks up all hostnames for `address`.
  #
  def self.getnames: (String address) -> Array[String]

  public

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name) { |name| ... }
  # -->
  # Iterates over all IP addresses for `name`.
  #
  def each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address) { |name| ... }
  # -->
  # Iterates over all hostnames for `address`.
  #
  def each_name: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Looks up the first IP address for `name`.
  #
  def getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Looks up all IP address for `name`.
  #
  def getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Looks up the hostname of `address`.
  #
  def getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Looks up all hostnames for `address`.
  #
  def getnames: (String address) -> Array[String]

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(resolvers=[Hosts.new, DNS.new])
  # -->
  # Creates a new Resolv using `resolvers`.
  #
  def initialize: (?Resolv::Hosts | Resolv::DNS resolvers) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Address Regexp to use for matching IP addresses.
#
Resolv::AddressRegex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Default resolver to use for Resolv class methods.
#
Resolv::DefaultResolver: Resolv

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::DNS is a DNS stub resolver.
#
# Information taken from the following places:
#
# *   STD0013
# *   RFC 1035
# *   ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters
# *   etc.
#
class Resolv::DNS
  type ip_address = Resolv::IPv4 | Resolv::IPv6

  type dns_name = Name | String

  def self.allocate_request_id: (String host, Integer port) -> Integer

  def self.bind_random_port: (UDPSocket udpsock, ?String bind_host) -> void

  def self.free_request_id: (String host, Integer port, Integer id) -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - open(*args) { |dns| ... }
  # -->
  # Creates a new DNS resolver.  See Resolv::DNS.new for argument details.
  #
  # Yields the created DNS resolver to the block, if given, otherwise returns it.
  #
  def self.open: (*untyped args) -> instance
               | (*untyped args) { (instance) -> void } -> void

  def self.random: (Integer arg) -> (Integer | Float)

  public

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - close()
  # -->
  # Closes the DNS resolver.
  #
  def close: () -> untyped

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name) { |address| ... }
  # -->
  # Iterates over all IP addresses for `name` retrieved from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def each_address: (dns_name name) { (ip_address) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address) { |name| ... }
  # -->
  # Iterates over all hostnames for `address` retrieved from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
  # will be Resolv::DNS::Name instances.
  #
  def each_name: (ip_address | dns_name address) { (Resolv::DNS::Name) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_resource(name, typeclass, &proc)
  # -->
  # Iterates over all `typeclass` DNS resources for `name`.  See #getresource for
  # argument details.
  #
  def each_resource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  def extract_resources: (Resolv::DNS::Message msg, dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - fetch_resource(name, typeclass) { |reply, reply_name| ... }
  # -->
  #
  def fetch_resource: (Resolv::DNS::Name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Message, Resolv::DNS::Name) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Gets the IP address of `name` from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved address will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def getaddress: (dns_name name) -> ip_address

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Gets all IP addresses for `name` from the DNS resolver.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def getaddresses: (dns_name name) -> Array[ip_address]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Gets the hostname for `address` from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved name
  # will be a Resolv::DNS::Name.
  #
  def getname: (ip_address | dns_name address) -> Resolv::DNS::Name

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Gets all hostnames for `address` from the DNS resolver.
  #
  # `address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
  # will be Resolv::DNS::Name instances.
  #
  def getnames: (ip_address | dns_name address) -> Array[Resolv::DNS::Name]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getresource(name, typeclass)
  # -->
  # Look up the `typeclass` DNS resource of `name`.
  #
  # `name` must be a Resolv::DNS::Name or a String.
  #
  # `typeclass` should be one of the following:
  #
  # *   Resolv::DNS::Resource::IN::A
  # *   Resolv::DNS::Resource::IN::AAAA
  # *   Resolv::DNS::Resource::IN::ANY
  # *   Resolv::DNS::Resource::IN::CNAME
  # *   Resolv::DNS::Resource::IN::HINFO
  # *   Resolv::DNS::Resource::IN::MINFO
  # *   Resolv::DNS::Resource::IN::MX
  # *   Resolv::DNS::Resource::IN::NS
  # *   Resolv::DNS::Resource::IN::PTR
  # *   Resolv::DNS::Resource::IN::SOA
  # *   Resolv::DNS::Resource::IN::TXT
  # *   Resolv::DNS::Resource::IN::WKS
  #
  #
  # Returned resource is represented as a Resolv::DNS::Resource instance, i.e.
  # Resolv::DNS::Resource::IN::A.
  #
  def getresource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Resolv::DNS::Resource

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getresources(name, typeclass)
  # -->
  # Looks up all `typeclass` DNS resources for `name`.  See #getresource for
  # argument details.
  #
  def getresources: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Array[Resolv::DNS::Resource]

  def lazy_initialize: () -> untyped

  def make_tcp_requester: (String host, Integer port) -> Requester::TCP

  def make_udp_requester: () -> (Requester::ConnectedUDP | Requester::UnconnectedUDP)

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - timeouts=(values)
  # -->
  # Sets the resolver timeouts.  This may be a single positive number or an array
  # of positive numbers representing timeouts in seconds. If an array is
  # specified, a DNS request will retry and wait for each successive interval in
  # the array until a successful response is received.  Specifying `nil` reverts
  # to the default timeouts:
  # 5, second = 5 * 2 / nameserver_count, 2 * second, 4 * second
  # :   Example:
  #
  #         dns.timeouts = 3
  #
  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(config_info=nil)
  # -->
  # Creates a new DNS resolver.
  #
  # `config_info` can be:
  #
  # nil
  # :   Uses /etc/resolv.conf.
  # String
  # :   Path to a file using /etc/resolv.conf's format.
  # Hash
  # :   Must contain :nameserver, :search and :ndots keys.
  #
  # :nameserver_port can be used to specify port number of nameserver address.
  #
  # The value of :nameserver should be an address string or an array of address
  # strings.
  # *   :nameserver => '8.8.8.8'
  # *   :nameserver => ['8.8.8.8', '8.8.4.4']
  #
  #
  # The value of :nameserver_port should be an array of pair of nameserver address
  # and port number.
  # *   :nameserver_port => [['8.8.8.8', 53], ['8.8.4.4', 53]]
  #
  #
  # Example:
  #
  #     Resolv::DNS.new(:nameserver => ['210.251.121.21'],
  #                     :search => ['ruby-lang.org'],
  #                     :ndots => 1)
  #
  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped

  def use_ipv6?: () -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Default DNS Port
#
Resolv::DNS::Port: Integer

Resolv::DNS::RequestID: Hash[untyped, untyped]

Resolv::DNS::RequestIDMutex: Thread::Mutex

# <!-- rdoc-file=lib/resolv.rb -->
# Default DNS UDP packet size
#
Resolv::DNS::UDPSize: Integer

class Resolv::DNS::Config
  def self.default_config_hash: (?String filename) -> Hash[Symbol, untyped]

  def self.parse_resolv_conf: (String filename) -> Hash[Symbol, untyped]

  public

  def generate_candidates: (String name) -> Array[Resolv::DNS::Name]

  def generate_timeouts: () -> Array[Integer | Float]

  def lazy_initialize: () -> void

  def nameserver_port: () -> Array[[ String, Integer ]]

  def resolv: (String name) { (Resolv::DNS::Name, Integer, String, Integer) -> void } -> void

  def single?: () -> [ String, Integer ]?

  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

Resolv::DNS::Config::InitialTimeout: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates no such domain was found.
#
class Resolv::DNS::Config::NXDomain < Resolv::ResolvError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates some other unhandled resolver error was encountered.
#
class Resolv::DNS::Config::OtherResolvError < Resolv::ResolvError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates that the DNS response was unable to be decoded.
#
class Resolv::DNS::DecodeError < StandardError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates that the DNS request was unable to be encoded.
#
class Resolv::DNS::EncodeError < StandardError
end

module Resolv::DNS::Label
  def self.split: (untyped arg) -> untyped
end

class Resolv::DNS::Label::Str
  public

  def eql?: (Resolv::DNS::Label::Str other) -> bool

  def downcase: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def string: () -> String

  def to_s: () -> String

  private

  def initialize: (String string) -> untyped
end

class Resolv::DNS::Message
  def self.decode: (String m) -> instance

  public

  def ==: (instance other) -> bool

  def aa: () -> Integer

  def aa=: (Integer) -> void

  def add_additional: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_answer: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_authority: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_question: (String name, singleton(Resolv::DNS::Query) typeclass) -> void

  def additional: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def answer: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def authority: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def each_additional: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_answer: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_authority: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_question: () { (Resolv::DNS::Name, singleton(Resolv::DNS::Query)) -> void } -> void

  def each_resource: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def encode: () -> String

  def id: () -> Integer

  def id=: (Integer) -> void

  def opcode: () -> Integer

  def opcode=: (Integer) -> void

  def qr: () -> Integer

  def qr=: (Integer) -> void

  def question: () -> Array[[ Resolv::DNS::Name, singleton(Resolv::DNS::Resource) ]]

  def ra: () -> Integer

  def ra=: (Integer) -> void

  def rcode: () -> Integer

  def rcode=: (Integer) -> void

  def rd: () -> Integer

  def rd=: (Integer) -> void

  def tc: () -> Integer

  def tc=: (Integer) -> void

  private

  def initialize: (?Integer id) -> untyped
end

class Resolv::DNS::Message::MessageDecoder
  public

  def get_bytes: (?Integer len) -> String

  def get_label: () -> Resolv::DNS::Label::Str

  def get_labels: () -> Array[Resolv::DNS::Label::Str]

  def get_length16: () { (Integer) -> Integer } -> Integer

  def get_name: () -> Resolv::DNS::Name

  def get_question: () -> Resolv::DNS::Query

  def get_rr: () -> [ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]

  def get_string: () -> String

  def get_string_list: () -> Array[String]

  def get_unpack: (String template) -> Array[untyped]

  def inspect: () -> String

  private

  def initialize: (String data) { (instance) -> void } -> untyped
end

class Resolv::DNS::Message::MessageEncoder
  public

  def put_bytes: (string d) -> void

  def put_label: (_ToS d) -> void

  def put_labels: (Array[_ToS] d) -> void

  def put_length16: () { () -> void } -> void

  def put_name: (Resolv::DNS::Name d) -> void

  def put_pack: (String template, *untyped d) -> void

  def put_string: (String d) -> void

  def put_string_list: (_Each[String] ds) -> void

  def to_s: () -> untyped

  private

  def initialize: () -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A representation of a DNS name.
#
class Resolv::DNS::Name
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new DNS name from `arg`.  `arg` can be:
  #
  # Name
  # :   returns `arg`.
  # String
  # :   Creates a new Name.
  #
  def self.create: (Resolv::DNS::dns_name arg) -> untyped

  public

  def ==: (instance other) -> bool

  def []: (Integer i) -> Resolv::DNS::Label::Str?

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - absolute?()
  # -->
  # True if this name is absolute.
  #
  def absolute?: () -> bool

  alias eql? ==

  def hash: () -> Integer

  def inspect: () -> String

  def length: () -> Integer

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - subdomain_of?(other)
  # -->
  # Returns true if `other` is a subdomain.
  #
  # Example:
  #
  #     domain = Resolv::DNS::Name.create("y.z")
  #     p Resolv::DNS::Name.create("w.x.y.z").subdomain_of?(domain) #=> true
  #     p Resolv::DNS::Name.create("x.y.z").subdomain_of?(domain) #=> true
  #     p Resolv::DNS::Name.create("y.z").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("z").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("x.y.z.").subdomain_of?(domain) #=> false
  #     p Resolv::DNS::Name.create("w.z").subdomain_of?(domain) #=> false
  #
  def subdomain_of?: (instance other) -> bool

  def to_a: () -> Array[Resolv::DNS::Label::Str]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_s()
  # -->
  # returns the domain name as a string.
  #
  # The domain name doesn't have a trailing dot even if the name object is
  # absolute.
  #
  # Example:
  #
  #     p Resolv::DNS::Name.create("x.y.z.").to_s #=> "x.y.z"
  #     p Resolv::DNS::Name.create("x.y.z").to_s #=> "x.y.z"
  #
  def to_s: () -> untyped

  private

  def initialize: (Array[Resolv::DNS::Label::Str] labels, ?bool absolute) -> untyped
end

module Resolv::DNS::OpCode
end

Resolv::DNS::OpCode::IQuery: Integer

Resolv::DNS::OpCode::Notify: Integer

Resolv::DNS::OpCode::Query: Integer

Resolv::DNS::OpCode::Status: Integer

Resolv::DNS::OpCode::Update: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# A DNS query abstract class.
#
class Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void
end

module Resolv::DNS::RCode
end

Resolv::DNS::RCode::BADALG: Integer

Resolv::DNS::RCode::BADKEY: Integer

Resolv::DNS::RCode::BADMODE: Integer

Resolv::DNS::RCode::BADNAME: Integer

Resolv::DNS::RCode::BADSIG: Integer

Resolv::DNS::RCode::BADTIME: Integer

Resolv::DNS::RCode::BADVERS: Integer

Resolv::DNS::RCode::FormErr: Integer

Resolv::DNS::RCode::NXDomain: Integer

Resolv::DNS::RCode::NXRRSet: Integer

Resolv::DNS::RCode::NoError: Integer

Resolv::DNS::RCode::NotAuth: Integer

Resolv::DNS::RCode::NotImp: Integer

Resolv::DNS::RCode::NotZone: Integer

Resolv::DNS::RCode::Refused: Integer

Resolv::DNS::RCode::ServFail: Integer

Resolv::DNS::RCode::YXDomain: Integer

Resolv::DNS::RCode::YXRRSet: Integer

class Resolv::DNS::Requester
  public

  def close: () -> void

  def request: (Resolv::DNS::Requester::Sender sender, Numeric tout) -> [ Resolv::DNS::Message, String ]

  def sender_for: (String addr, Resolv::DNS::Message msg) -> Resolv::DNS::Requester::Sender

  private

  def initialize: () -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP < Resolv::DNS::Requester
  public

  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP::Sender < Resolv::DNS::Requester::Sender
  public

  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::MDNSOneShot < Resolv::DNS::Requester::UnconnectedUDP
  public

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a problem with the DNS request.
#
class Resolv::DNS::Requester::RequestError < StandardError
end

class Resolv::DNS::Requester::Sender
  private

  def initialize: (Resolv::DNS::Message msg, String data, Socket sock) -> untyped
end

class Resolv::DNS::Requester::TCP < Resolv::DNS::Requester
  public

  def close: () -> untyped

  def recv_reply: (Array[TCPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::TCP::Sender < Resolv::DNS::Requester::Sender
  public

  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::UnconnectedUDP < Resolv::DNS::Requester
  public

  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (*[ String, Integer ] nameserver_port) -> untyped
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender < Resolv::DNS::Requester::Sender
  public

  def data: () -> String

  def send: () -> void

  private

  def initialize: (Resolv::DNS::Message msg, String data, UDPSocket sock, String host, Integer port) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A DNS resource abstract class.
#
class Resolv::DNS::Resource < Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def self.get_class: (Integer type_value, Integer class_value) -> self

  public

  def eql?: (Resolv::DNS::Resource other) -> bool

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  alias == eql?

  def hash: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Remaining Time To Live for this Resource.
  #
  def ttl: () -> Integer
end

Resolv::DNS::Resource::ClassHash: Hash[[ Integer, Integer ], singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassInsensitiveTypes: Array[singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassValue: Integer?

# <!-- rdoc-file=lib/resolv.rb -->
# A Query type requesting any RR.
#
class Resolv::DNS::Resource::ANY < Resolv::DNS::Query
end

Resolv::DNS::Resource::ANY::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# The canonical name for an alias.
#
class Resolv::DNS::Resource::CNAME < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::CNAME::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Domain Name resource abstract class.
#
class Resolv::DNS::Resource::DomainName < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The name of this DomainName.
  #
  def name: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(name)
  # -->
  # Creates a new DomainName from `name`.
  #
  def initialize: (String name) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A generic resource abstract class.
#
class Resolv::DNS::Resource::Generic < Resolv::DNS::Resource
  def self.create: (Integer type_value, Integer class_value) -> instance

  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # Data for this generic resource.
  #
  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(data)
  # -->
  # Creates a new generic resource.
  #
  def initialize: (String data) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Host Information resource.
#
class Resolv::DNS::Resource::HINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # CPU architecture for this resource.
  #
  def cpu: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Operating system for this resource.
  #
  def os: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(cpu, os)
  # -->
  # Creates a new HINFO running `os` on `cpu`.
  #
  def initialize: (String cpu, String os) -> untyped
end

Resolv::DNS::Resource::HINFO::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# module IN contains ARPA Internet specific RRs.
#
module Resolv::DNS::Resource::IN
end

Resolv::DNS::Resource::IN::ClassValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# IPv4 Address resource
#
class Resolv::DNS::Resource::IN::A < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # The Resolv::IPv4 address for this A.
  #
  def address: () -> Resolv::IPv4

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address)
  # -->
  # Creates a new A for `address`.
  #
  def initialize: (String | Resolv::IPv4 address) -> untyped
end

Resolv::DNS::Resource::IN::A::ClassValue: Integer

Resolv::DNS::Resource::IN::A::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# An IPv6 address record.
#
class Resolv::DNS::Resource::IN::AAAA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # The Resolv::IPv6 address for this AAAA.
  #
  def address: () -> Resolv::IPv6

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address)
  # -->
  # Creates a new AAAA for `address`.
  #
  def initialize: (String | Resolv::IPv6 address) -> untyped
end

Resolv::DNS::Resource::IN::AAAA::ClassValue: Integer

Resolv::DNS::Resource::IN::AAAA::TypeValue: Integer

class Resolv::DNS::Resource::IN::ANY < Resolv::DNS::Resource::ANY
end

Resolv::DNS::Resource::IN::ANY::ClassValue: Integer

Resolv::DNS::Resource::IN::ANY::TypeValue: Integer

class Resolv::DNS::Resource::IN::CNAME < Resolv::DNS::Resource::CNAME
end

Resolv::DNS::Resource::IN::CNAME::ClassValue: Integer

Resolv::DNS::Resource::IN::CNAME::TypeValue: Integer

class Resolv::DNS::Resource::IN::HINFO < Resolv::DNS::Resource::HINFO
end

Resolv::DNS::Resource::IN::HINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::HINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::LOC < Resolv::DNS::Resource::LOC
end

Resolv::DNS::Resource::IN::LOC::ClassValue: Integer

Resolv::DNS::Resource::IN::LOC::TypeValue: Integer

class Resolv::DNS::Resource::IN::MINFO < Resolv::DNS::Resource::MINFO
end

Resolv::DNS::Resource::IN::MINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::MINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::MX < Resolv::DNS::Resource::MX
end

Resolv::DNS::Resource::IN::MX::ClassValue: Integer

Resolv::DNS::Resource::IN::MX::TypeValue: Integer

class Resolv::DNS::Resource::IN::NS < Resolv::DNS::Resource::NS
end

Resolv::DNS::Resource::IN::NS::ClassValue: Integer

Resolv::DNS::Resource::IN::NS::TypeValue: Integer

class Resolv::DNS::Resource::IN::PTR < Resolv::DNS::Resource::PTR
end

Resolv::DNS::Resource::IN::PTR::ClassValue: Integer

Resolv::DNS::Resource::IN::PTR::TypeValue: Integer

class Resolv::DNS::Resource::IN::SOA < Resolv::DNS::Resource::SOA
end

Resolv::DNS::Resource::IN::SOA::ClassValue: Integer

Resolv::DNS::Resource::IN::SOA::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# SRV resource record defined in RFC 2782
#
# These records identify the hostname and port that a service is available at.
#
class Resolv::DNS::Resource::IN::SRV < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The port on this target host of this service.
  #
  # The range is 0-65535.
  #
  def port: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The priority of this target host.
  #
  # A client MUST attempt to contact the target host with the lowest-numbered
  # priority it can reach; target hosts with the same priority SHOULD be tried in
  # an order defined by the weight field. The range is 0-65535.  Note that it is
  # not widely implemented and should be set to zero.
  #
  def priority: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The domain name of the target host.
  #
  # A target of "." means that the service is decidedly not available at this
  # domain.
  #
  def target: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # A server selection mechanism.
  #
  # The weight field specifies a relative weight for entries with the same
  # priority. Larger weights SHOULD be given a proportionately higher probability
  # of being selected. The range of this number is 0-65535.  Domain administrators
  # SHOULD use Weight 0 when there isn't any server selection to do, to make the
  # RR easier to read for humans (less noisy). Note that it is not widely
  # implemented and should be set to zero.
  #
  def weight: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(priority, weight, port, target)
  # -->
  # Create a SRV resource record.
  #
  # See the documentation for #priority, #weight, #port and #target for
  # `priority`, `weight`, +port and `target` respectively.
  #
  def initialize: (Integer priority, Integer weight, Integer port, String target) -> untyped
end

Resolv::DNS::Resource::IN::SRV::ClassValue: Integer

Resolv::DNS::Resource::IN::SRV::TypeValue: Integer

class Resolv::DNS::Resource::IN::TXT < Resolv::DNS::Resource::TXT
end

Resolv::DNS::Resource::IN::TXT::ClassValue: Integer

Resolv::DNS::Resource::IN::TXT::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Well Known Service resource.
#
class Resolv::DNS::Resource::IN::WKS < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # The host these services run on.
  #
  def address: () -> Resolv::IPv4

  # <!-- rdoc-file=lib/resolv.rb -->
  # A bit map of enabled services on this host.
  #
  # If protocol is 6 (TCP) then the 26th bit corresponds to the SMTP service (port
  # 25).  If this bit is set, then an SMTP server should be listening on TCP port
  # 25; if zero, SMTP service is not supported.
  #
  def bitmap: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # IP protocol number for these services.
  #
  def protocol: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(address, protocol, bitmap)
  # -->
  #
  def initialize: (String | Resolv::IPv4 address, Integer protocol, Integer bitmap) -> untyped
end

Resolv::DNS::Resource::IN::WKS::ClassValue: Integer

Resolv::DNS::Resource::IN::WKS::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Location resource
#
class Resolv::DNS::Resource::LOC < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # The altitude of the LOC above a reference sphere whose surface sits 100km
  # below the WGS84 spheroid in centimeters as an unsigned 32bit integer
  #
  def altitude: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The horizontal precision using ssize type values in meters using scientific
  # notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m
  #
  def hprecision: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The latitude for this LOC where 2**31 is the equator in thousandths of an arc
  # second as an unsigned 32bit integer
  #
  def latitude: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The longitude for this LOC where 2**31 is the prime meridian in thousandths of
  # an arc second as an unsigned 32bit integer
  #
  def longitude: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The spherical size of this LOC in meters using scientific notation as 2
  # integers of XeY
  #
  def ssize: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Returns the version value for this LOC record which should always be 00
  #
  def version: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The vertical precision using ssize type values in meters using scientific
  # notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m
  #
  def vprecision: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(version, ssize, hprecision, vprecision, latitude, longitude, altitude)
  # -->
  #
  def initialize: (Integer version, Integer ssize, Integer hprecision, Integer vprecision, Integer latitude, Integer longitude, Integer altitude) -> untyped
end

Resolv::DNS::Resource::LOC::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Mailing list or mailbox information.
#
class Resolv::DNS::Resource::MINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!-- rdoc-file=lib/resolv.rb -->
  # Mailbox to use for error messages related to the mail list or mailbox.
  #
  def emailbx: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Domain name responsible for this mail list or mailbox.
  #
  def rmailbx: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(rmailbx, emailbx)
  # -->
  #
  def initialize: (String rmailbx, String emailbx) -> untyped
end

Resolv::DNS::Resource::MINFO::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Mail Exchanger resource.
#
class Resolv::DNS::Resource::MX < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # The host of this MX.
  #
  def exchange: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The preference for this MX.
  #
  def preference: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(preference, exchange)
  # -->
  # Creates a new MX record with `preference`, accepting mail at `exchange`.
  #
  def initialize: (Integer preference, String exchange) -> untyped
end

Resolv::DNS::Resource::MX::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# An authoritative name server.
#
class Resolv::DNS::Resource::NS < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::NS::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# A Pointer to another DNS name.
#
class Resolv::DNS::Resource::PTR < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::PTR::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Start Of Authority resource.
#
class Resolv::DNS::Resource::SOA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Time in seconds that a secondary name server is to use the data before
  # refreshing from the primary name server.
  #
  def expire: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The minimum number of seconds to be used for TTL values in RRs.
  #
  def minimum: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # Name of the host where the master zone file for this zone resides.
  #
  def mname: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # How often, in seconds, a secondary name server is to check for updates from
  # the primary name server.
  #
  def refresh: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # How often, in seconds, a secondary name server is to retry after a failure to
  # check for a refresh.
  #
  def retry: () -> Integer

  # <!-- rdoc-file=lib/resolv.rb -->
  # The person responsible for this domain name.
  #
  def rname: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The version number of the zone file.
  #
  def serial: () -> Integer

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(mname, rname, serial, refresh, retry_, expire, minimum)
  # -->
  # Creates a new SOA record.  See the attr documentation for the details of each
  # argument.
  #
  def initialize: (String mname, String rname, Integer serial, Integer refresh, Integer retry_, Integer expire, Integer minimum) -> untyped
end

Resolv::DNS::Resource::SOA::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Unstructured text resource.
#
class Resolv::DNS::Resource::TXT < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  public

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - data()
  # -->
  # Returns the concatenated string from `strings`.
  #
  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  # <!-- rdoc-file=lib/resolv.rb -->
  # Returns an Array of Strings for this TXT record.
  #
  def strings: () -> Array[String]

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(first_string, *rest_strings)
  # -->
  #
  def initialize: (String first_string, *String rest_strings) -> untyped
end

Resolv::DNS::Resource::TXT::TypeValue: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::Hosts is a hostname resolver that uses the system hosts file.
#
class Resolv::Hosts
  public

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name, &proc)
  # -->
  # Iterates over all IP addresses for `name` retrieved from the hosts file.
  #
  def each_address: (String name) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_name(address, &proc)
  # -->
  # Iterates over all hostnames for `address` retrieved from the hosts file.
  #
  def each_name: (String address) { (String) -> void } -> void

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddress(name)
  # -->
  # Gets the IP address of `name` from the hosts file.
  #
  def getaddress: (String name) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getaddresses(name)
  # -->
  # Gets all IP addresses for `name` from the hosts file.
  #
  def getaddresses: (String name) -> Array[String]

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getname(address)
  # -->
  # Gets the hostname of `address` from the hosts file.
  #
  def getname: (String address) -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - getnames(address)
  # -->
  # Gets all hostnames for `address` from the hosts file.
  #
  def getnames: (String address) -> Array[String]

  def lazy_initialize: () -> void

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(filename = DefaultFileName)
  # -->
  # Creates a new Resolv::Hosts, using `filename` for its data source.
  #
  def initialize: (?String filename) -> untyped
end

Resolv::Hosts::DefaultFileName: String

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::DNS IPv4 address.
#
class Resolv::IPv4
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  #
  def self.create: (String | instance arg) -> instance

  public

  def ==: (instance other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw IPv4 address as a String.
  #
  def address: () -> String

  def eql?: (instance other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_name()
  # -->
  # Turns this IPv4 address into a Resolv::DNS::Name.
  #
  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (String address) -> untyped
end

Resolv::IPv4::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Regular expression IPv4 addresses must match.
#
Resolv::IPv4::Regex256: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::DNS IPv6 address.
#
class Resolv::IPv6
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new IPv6 address from `arg` which may be:
  #
  # IPv6
  # :   returns `arg`.
  # String
  # :   `arg` must match one of the IPv6::Regex* constants
  #
  def self.create: (String | instance arg) -> instance

  public

  def ==: (instance other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw IPv6 address as a String.
  #
  def address: () -> String

  def eql?: (instance other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - to_name()
  # -->
  # Turns this IPv6 address into a Resolv::DNS::Name.
  #
  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (untyped address) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# A composite IPv6 address Regexp.
#
Resolv::IPv6::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv4 mapped IPv6 address format a:b:c:d:e:f:w.x.y.z
#
Resolv::IPv6::Regex_6Hex4Dec: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv6 address format a:b:c:d:e:f:g:h
#
Resolv::IPv6::Regex_8Hex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# IPv6 link local address format fe80:b:c:d:e:f:g:h%em1
#
Resolv::IPv6::Regex_8HexLinkLocal: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv6 address format a::b
#
Resolv::IPv6::Regex_CompressedHex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv4 mapped IPv6 address format a::b:w.x.y.z
#
Resolv::IPv6::Regex_CompressedHex4Dec: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Compressed IPv6 link local address format fe80::b%em1
#
Resolv::IPv6::Regex_CompressedHexLinkLocal: Regexp

module Resolv::LOC
end

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Alt
#
class Resolv::LOC::Alt
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Alt from `arg` which may be:
  #
  # LOC::Alt
  # :   returns `arg`.
  # String
  # :   `arg` must match the LOC::Alt::Regex constant
  #
  def self.create: (Resolv::LOC::Alt | String arg) -> instance

  public

  def eql?: (Resolv::LOC::Alt other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw altitude
  #
  def altitude: () -> Integer

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(altitude)
  # -->
  #
  def initialize: (Integer altitude) -> untyped
end

Resolv::LOC::Alt::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Coord
#
class Resolv::LOC::Coord
  type orientation = "lat" | "lon"

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Coord from `arg` which may be:
  #
  # LOC::Coord
  # :   returns `arg`.
  # String
  # :   `arg` must match the LOC::Coord::Regex constant
  #
  def self.create: (Resolv::LOC::Coord | String arg) -> instance

  public

  def eql?: (Resolv::LOC::Coord other) -> bool

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw coordinates
  #
  def coordinates: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The orientation of the hemisphere as 'lat' or 'lon'
  #
  def orientation: () -> orientation

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(coordinates,orientation)
  # -->
  #
  def initialize: (String coordinates, orientation orientation) -> untyped
end

Resolv::LOC::Coord::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# A Resolv::LOC::Size
#
class Resolv::LOC::Size
  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - create(arg)
  # -->
  # Creates a new LOC::Size from `arg` which may be:
  #
  # LOC::Size
  # :   returns `arg`.
  # String
  # :   `arg` must match the LOC::Size::Regex constant
  #
  def self.create: (Resolv::LOC::Size | String arg) -> instance

  public

  def eql?: (Resolv::LOC::Size other) -> bool

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  # <!-- rdoc-file=lib/resolv.rb -->
  # The raw size
  #
  def scalar: () -> String

  def to_s: () -> String

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(scalar)
  # -->
  #
  def initialize: (String scalar) -> untyped
end

Resolv::LOC::Size::Regex: Regexp

# <!-- rdoc-file=lib/resolv.rb -->
# Resolv::MDNS is a one-shot Multicast DNS (mDNS) resolver.  It blindly makes
# queries to the mDNS addresses without understanding anything about multicast
# ports.
#
# Information taken form the following places:
#
# *   RFC 6762
#
class Resolv::MDNS < Resolv::DNS
  public

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - each_address(name)
  # -->
  # Iterates over all IP addresses for `name` retrieved from the mDNS resolver,
  # provided name ends with "local".  If the name does not end in "local" no
  # records will be returned.
  #
  # `name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
  # Resolv::IPv4 or Resolv::IPv6
  #
  def each_address: (Resolv::DNS::dns_name name) -> Resolv::DNS::ip_address

  def make_udp_requester: () -> (Resolv::DNS::Requester::ConnectedUDP | Resolv::DNS::Requester::UnconnectedUDP)

  private

  # <!--
  #   rdoc-file=lib/resolv.rb
  #   - new(config_info=nil)
  # -->
  # Creates a new one-shot Multicast DNS (mDNS) resolver.
  #
  # `config_info` can be:
  #
  # nil
  # :   Uses the default mDNS addresses
  #
  # Hash
  # :   Must contain :nameserver or :nameserver_port like Resolv::DNS#initialize.
  #
  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

# <!-- rdoc-file=lib/resolv.rb -->
# Default IPv4 mDNS address
#
Resolv::MDNS::AddressV4: String

# <!-- rdoc-file=lib/resolv.rb -->
# Default IPv6 mDNS address
#
Resolv::MDNS::AddressV6: String

# <!-- rdoc-file=lib/resolv.rb -->
# Default mDNS addresses
#
Resolv::MDNS::Addresses: Array[untyped]

# <!-- rdoc-file=lib/resolv.rb -->
# Default mDNS Port
#
Resolv::MDNS::Port: Integer

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a failure to resolve a name or address.
#
class Resolv::ResolvError < StandardError
end

# <!-- rdoc-file=lib/resolv.rb -->
# Indicates a timeout resolving a name or address.
#
class Resolv::ResolvTimeout < Timeout::Error
end

# <!-- rdoc-file=ext/zlib/zlib.c -->
# This module provides access to the [zlib library](http://zlib.net). Zlib is
# designed to be a portable, free, general-purpose, legally unencumbered -- that
# is, not covered by any patents -- lossless data-compression library for use on
# virtually any computer hardware and operating system.
#
# The zlib compression library provides in-memory compression and decompression
# functions, including integrity checks of the uncompressed data.
#
# The zlib compressed data format is described in RFC 1950, which is a wrapper
# around a deflate stream which is described in RFC 1951.
#
# The library also supports reading and writing files in gzip (.gz) format with
# an interface similar to that of IO. The gzip format is described in RFC 1952
# which is also a wrapper around a deflate stream.
#
# The zlib format was designed to be compact and fast for use in memory and on
# communications channels. The gzip format was designed for single-file
# compression on file systems, has a larger header than zlib to maintain
# directory information, and uses a different, slower check method than zlib.
#
# See your system's zlib.h for further information about zlib
#
# ## Sample usage
#
# Using the wrapper to compress strings with default parameters is quite simple:
#
#     require "zlib"
#
#     data_to_compress = File.read("don_quixote.txt")
#
#     puts "Input size: #{data_to_compress.size}"
#     #=> Input size: 2347740
#
#     data_compressed = Zlib::Deflate.deflate(data_to_compress)
#
#     puts "Compressed size: #{data_compressed.size}"
#     #=> Compressed size: 887238
#
#     uncompressed_data = Zlib::Inflate.inflate(data_compressed)
#
#     puts "Uncompressed data is: #{uncompressed_data}"
#     #=> Uncompressed data is: The Project Gutenberg EBook of Don Quixote...
#
# ## Class tree
#
# *   Zlib::Deflate
# *   Zlib::Inflate
# *   Zlib::ZStream
# *   Zlib::Error
#     *   Zlib::StreamEnd
#     *   Zlib::NeedDict
#     *   Zlib::DataError
#     *   Zlib::StreamError
#     *   Zlib::MemError
#     *   Zlib::BufError
#     *   Zlib::VersionError
#     *   Zlib::InProgressError
#
#
#
# (if you have GZIP_SUPPORT)
# *   Zlib::GzipReader
# *   Zlib::GzipWriter
# *   Zlib::GzipFile
# *   Zlib::GzipFile::Error
#     *   Zlib::GzipFile::LengthError
#     *   Zlib::GzipFile::CRCError
#     *   Zlib::GzipFile::NoFooter
#
module Zlib
  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.adler32(string, adler)
  # -->
  # Calculates Adler-32 checksum for `string`, and returns updated value of
  # `adler`. If `string` is omitted, it returns the Adler-32 initial value. If
  # `adler` is omitted, it assumes that the initial value is given to `adler`. If
  # `string` is an IO instance, reads from the IO until the IO returns nil and
  # returns Adler-32 of all read data.
  #
  # Example usage:
  #
  #     require "zlib"
  #
  #     data = "foo"
  #     puts "Adler32 checksum: #{Zlib.adler32(data).to_s(16)}"
  #     #=> Adler32 checksum: 2820145
  #
  def self.adler32: () -> Integer
                  | (String) -> Integer
                  | (String, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.adler32_combine(adler1, adler2, len2)
  # -->
  # Combine two Adler-32 check values in to one.  `alder1` is the first Adler-32
  # value, `adler2` is the second Adler-32 value.  `len2` is the length of the
  # string used to generate `adler2`.
  #
  def self.adler32_combine: (Integer, Integer, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.crc32(string, crc)
  # -->
  # Calculates CRC checksum for `string`, and returns updated value of `crc`. If
  # `string` is omitted, it returns the CRC initial value. If `crc` is omitted, it
  # assumes that the initial value is given to `crc`. If `string` is an IO
  # instance, reads from the IO until the IO returns nil and returns CRC checksum
  # of all read data.
  #
  # FIXME: expression.
  #
  def self.crc32: () -> Integer
                | (String) -> Integer
                | (String, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.crc32_combine(crc1, crc2, len2)
  # -->
  # Combine two CRC-32 check values in to one.  `crc1` is the first CRC-32 value,
  # `crc2` is the second CRC-32 value.  `len2` is the length of the string used to
  # generate `crc2`.
  #
  def self.crc32_combine: (Integer, Integer, Integer) -> Integer

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - crc_table()
  # -->
  # Returns the table for calculating CRC checksum as an array.
  #
  def self.crc_table: () -> Array[Integer]

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.deflate(string[, level])
  #   - Zlib::Deflate.deflate(string[, level])
  # -->
  # Compresses the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
  # Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, or an
  # integer from 0 to 9.
  #
  # This method is almost equivalent to the following code:
  #
  #     def deflate(string, level)
  #       z = Zlib::Deflate.new(level)
  #       dst = z.deflate(string, Zlib::FINISH)
  #       z.close
  #       dst
  #     end
  #
  # See also Zlib.inflate
  #
  def self.deflate: (String) -> String
                  | (String, Integer) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.gunzip(src) -> String
  # -->
  # Decode the given gzipped `string`.
  #
  # This method is almost equivalent to the following code:
  #
  #     def gunzip(string)
  #       sio = StringIO.new(string)
  #       gz = Zlib::GzipReader.new(sio, encoding: Encoding::ASCII_8BIT)
  #       gz.read
  #     ensure
  #       gz&.close
  #     end
  #
  # See also Zlib.gzip
  #
  def self.gunzip: (String) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.gzip(src, level: nil, strategy: nil) -> String
  # -->
  # Gzip the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
  # Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION (default),
  # or an integer from 0 to 9.
  #
  # This method is almost equivalent to the following code:
  #
  #     def gzip(string, level: nil, strategy: nil)
  #       sio = StringIO.new
  #       sio.binmode
  #       gz = Zlib::GzipWriter.new(sio, level, strategy)
  #       gz.write(string)
  #       gz.close
  #       sio.string
  #     end
  #
  # See also Zlib.gunzip
  #
  def self.gzip: (String) -> String
               | (String, level: Integer) -> String
               | (String, strategy: Integer) -> String
               | (String, level: Integer, strategy: Integer) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - Zlib.inflate(string)
  #   - Zlib::Inflate.inflate(string)
  # -->
  # Decompresses `string`. Raises a Zlib::NeedDict exception if a preset
  # dictionary is needed for decompression.
  #
  # This method is almost equivalent to the following code:
  #
  #     def inflate(string)
  #       zstream = Zlib::Inflate.new
  #       buf = zstream.inflate(string)
  #       zstream.finish
  #       zstream.close
  #       buf
  #     end
  #
  # See also Zlib.deflate
  #
  def self.inflate: (String) -> String

  # <!--
  #   rdoc-file=ext/zlib/zlib.c
  #   - zlib_version()
  # -->
  # Returns the string which represents the version of zlib library.
  #
  def self.zlib_version: () -> String
end

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents text data as guessed by deflate.
#
# NOTE: The underlying constant Z_ASCII was deprecated in favor of Z_TEXT in
# zlib 1.2.2.  New applications should not use this constant.
#
# See Zlib::Deflate#data_type.
#
Zlib::ASCII: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Slowest compression level, but with the best space savings.
#
Zlib::BEST_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Fastest compression level, but with the lowest space savings.
#
Zlib::BEST_SPEED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents binary data as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::BINARY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Default compression level which is a good trade-off between space and time
#
Zlib::DEFAULT_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Default deflate strategy which is used for normal data.
#
Zlib::DEFAULT_STRATEGY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The default memory level for allocating zlib deflate compression state.
#
Zlib::DEF_MEM_LEVEL: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy for data produced by a filter (or predictor). The effect of
# FILTERED is to force more Huffman codes and less string matching; it is
# somewhat intermediate between DEFAULT_STRATEGY and HUFFMAN_ONLY. Filtered data
# consists mostly of small values with a somewhat random distribution.
#
Zlib::FILTERED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Processes all pending input and flushes pending output.
#
Zlib::FINISH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy which prevents the use of dynamic Huffman codes, allowing for
# a simpler decoder for specialized applications.
#
Zlib::FIXED: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Flushes all output as with SYNC_FLUSH, and the compression state is reset so
# that decompression can restart from this point if previous compressed data has
# been damaged or if random access is desired. Like SYNC_FLUSH, using FULL_FLUSH
# too often can seriously degrade compression.
#
Zlib::FULL_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate strategy which uses Huffman codes only (no string matching).
#
Zlib::HUFFMAN_ONLY: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The maximum memory level for allocating zlib deflate compression state.
#
Zlib::MAX_MEM_LEVEL: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The maximum size of the zlib history buffer.  Note that zlib allows larger
# values to enable different inflate modes.  See Zlib::Inflate.new for details.
#
Zlib::MAX_WBITS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# No compression, passes through data untouched.  Use this for appending
# pre-compressed data to a deflate stream.
#
Zlib::NO_COMPRESSION: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# NO_FLUSH is the default flush method and allows deflate to decide how much
# data to accumulate before producing output in order to maximize compression.
#
Zlib::NO_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Amiga hosts
#
Zlib::OS_AMIGA: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Atari hosts
#
Zlib::OS_ATARI: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The OS code of current host
#
Zlib::OS_CODE: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for CP/M hosts
#
Zlib::OS_CPM: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Mac OS hosts
#
Zlib::OS_MACOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for MSDOS hosts
#
Zlib::OS_MSDOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for OS2 hosts
#
Zlib::OS_OS2: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for QDOS hosts
#
Zlib::OS_QDOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for RISC OS hosts
#
Zlib::OS_RISCOS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for TOPS-20 hosts
#
Zlib::OS_TOPS20: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for UNIX hosts
#
Zlib::OS_UNIX: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for unknown hosts
#
Zlib::OS_UNKNOWN: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for VM OS hosts
#
Zlib::OS_VMCMS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for VMS hosts
#
Zlib::OS_VMS: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Win32 hosts
#
Zlib::OS_WIN32: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# OS code for Z-System hosts
#
Zlib::OS_ZSYSTEM: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Deflate compression strategy designed to be almost as fast as HUFFMAN_ONLY,
# but give better compression for PNG image data.
#
Zlib::RLE: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The SYNC_FLUSH method flushes all pending output to the output buffer and the
# output is aligned on a byte boundary. Flushing may degrade compression so it
# should be used only when necessary, such as at a request or response boundary
# for a network stream.
#
Zlib::SYNC_FLUSH: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents text data as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::TEXT: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# Represents an unknown data type as guessed by deflate.
#
# See Zlib::Deflate#data_type.
#
Zlib::UNKNOWN: Integer

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The Ruby/zlib version string.
#
Zlib::VERSION: String

# <!-- rdoc-file=ext/zlib/zlib.c -->
# The string which represents the version of zlib.h
#
Zlib::ZLIB_VERSION: String

%a{annotate:rdoc:skip}
module TSort[Node]
  interface _Sortable[Node]
    # #tsort_each_node is used to iterate for all nodes over a graph.
    #
    def tsort_each_node: () { (Node) -> void } -> void

    # #tsort_each_child is used to iterate for child nodes of node.
    #
    def tsort_each_child: (Node) { (Node) -> void } -> void
  end

  interface _EachNode[Node]
    def call: () { (Node) -> void } -> void
  end

  interface _EachChild[Node]
    def call: (Node) { (Node) -> void } -> void
  end
end

%a{annotate:rdoc:skip}
module TSort[Node]
  class Cyclic < StandardError
  end
end

# <!-- rdoc-file=lib/tsort.rb -->
# TSort implements topological sorting using Tarjan's algorithm for strongly
# connected components.
#
# TSort is designed to be able to be used with any object which can be
# interpreted as a directed graph.
#
# TSort requires two methods to interpret an object as a graph, tsort_each_node
# and tsort_each_child.
#
# *   tsort_each_node is used to iterate for all nodes over a graph.
# *   tsort_each_child is used to iterate for child nodes of a given node.
#
#
# The equality of nodes are defined by eql? and hash since TSort uses Hash
# internally.
#
# ## A Simple Example
#
# The following example demonstrates how to mix the TSort module into an
# existing class (in this case, Hash). Here, we're treating each key in the hash
# as a node in the graph, and so we simply alias the required #tsort_each_node
# method to Hash's #each_key method. For each key in the hash, the associated
# value is an array of the node's child nodes. This choice in turn leads to our
# implementation of the required #tsort_each_child method, which fetches the
# array of child nodes and then iterates over that array using the user-supplied
# block.
#
#     require 'tsort'
#
#     class Hash
#       include TSort
#       alias tsort_each_node each_key
#       def tsort_each_child(node, &block)
#         fetch(node).each(&block)
#       end
#     end
#
#     {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
#     #=> [3, 2, 1, 4]
#
#     {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
#     #=> [[4], [2, 3], [1]]
#
# ## A More Realistic Example
#
# A very simple `make' like tool can be implemented as follows:
#
#     require 'tsort'
#
#     class Make
#       def initialize
#         @dep = {}
#         @dep.default = []
#       end
#
#       def rule(outputs, inputs=[], &block)
#         triple = [outputs, inputs, block]
#         outputs.each {|f| @dep[f] = [triple]}
#         @dep[triple] = inputs
#       end
#
#       def build(target)
#         each_strongly_connected_component_from(target) {|ns|
#           if ns.length != 1
#             fs = ns.delete_if {|n| Array === n}
#             raise TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
#           end
#           n = ns.first
#           if Array === n
#             outputs, inputs, block = n
#             inputs_time = inputs.map {|f| File.mtime f}.max
#             begin
#               outputs_time = outputs.map {|f| File.mtime f}.min
#             rescue Errno::ENOENT
#               outputs_time = nil
#             end
#             if outputs_time == nil ||
#                inputs_time != nil && outputs_time <= inputs_time
#               sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
#               block.call
#             end
#           end
#         }
#       end
#
#       def tsort_each_child(node, &block)
#         @dep[node].each(&block)
#       end
#       include TSort
#     end
#
#     def command(arg)
#       print arg, "\n"
#       system arg
#     end
#
#     m = Make.new
#     m.rule(%w[t1]) { command 'date > t1' }
#     m.rule(%w[t2]) { command 'date > t2' }
#     m.rule(%w[t3]) { command 'date > t3' }
#     m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
#     m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
#     m.build('t5')
#
# ## Bugs
#
# *   'tsort.rb' is wrong name because this library uses Tarjan's algorithm for
#     strongly connected components. Although 'strongly_connected_components.rb'
#     is correct but too long.
#
#
# ## References
#
#     1.  Tarjan, "Depth First Search and Linear Graph Algorithms",
#
#
# *SIAM Journal on Computing*, Vol. 1, No. 2, pp. 146-160, June 1972.
#
module TSort[Node] : TSort::_Sortable[Node]
  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component(each_node, each_child) { |nodes| ... }
  # -->
  # The iterator version of the TSort.strongly_connected_components method.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #     #   [3]
  #     #   [1]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def self.each_strongly_connected_component: [T] (_EachNode[T] each_node, _EachChild[T] each_child) { (Array[T]) -> void } -> void
                                            | [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Enumerator[Array[T], void]
                                            | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) { (Array[T]) -> void } -> void
                                            | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Enumerator[Array[T], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component_from(node, each_child, id_map={}, stack=[]) { |nodes| ... }
  # -->
  # Iterates over strongly connected components in a graph. The graph is
  # represented by *node* and *each_child*.
  #
  # *node* is the first node. *each_child* should have `call` method which takes a
  # node argument and yields for each child node.
  #
  # Return value is unspecified.
  #
  # #TSort.each_strongly_connected_component_from is a class method and it doesn't
  # need a class to represent a graph which includes TSort.
  #
  #     graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_child = lambda {|n, &b| graph[n].each(&b) }
  #     TSort.each_strongly_connected_component_from(1, each_child) {|scc|
  #       p scc
  #     }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def self.each_strongly_connected_component_from: [T] (T node, _EachChild[T] each_child, ?untyped id_map, ?untyped stack) { (Array[T]) -> void } -> void
                                                 | [T] (T node, _EachChild[T] each_child, ?untyped id_map, ?untyped stack) -> Enumerator[Array[T], void]
                                                 | [T] (T node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack) { (Array[T]) -> void } -> void
                                                 | [T] (T node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack) -> Enumerator[Array[T], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - strongly_connected_components(each_node, each_child)
  # -->
  # Returns strongly connected components as an array of arrays of nodes. The
  # array is sorted from children to parents. Each elements of the array
  # represents a strongly connected component.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.strongly_connected_components(each_node, each_child)
  #     #=> [[4], [2], [3], [1]]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.strongly_connected_components(each_node, each_child)
  #     #=> [[4], [2, 3], [1]]
  #
  def self.strongly_connected_components: [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Array[Array[T]]
                                        | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Array[Array[T]]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort(each_node, each_child)
  # -->
  # Returns a topologically sorted array of nodes. The array is sorted from
  # children to parents, i.e. the first element has no child and the last node has
  # no parent.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  # If there is a cycle, TSort::Cyclic is raised.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]
  #
  #     g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     p TSort.tsort(each_node, each_child) # raises TSort::Cyclic
  #
  def self.tsort: [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Array[T]
                | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Array[T]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort_each(each_node, each_child) { |node| ... }
  # -->
  # The iterator version of the TSort.tsort method.
  #
  # The graph is represented by *each_node* and *each_child*. *each_node* should
  # have `call` method which yields for each node in the graph. *each_child*
  # should have `call` method which takes a node argument and yields for each
  # child node.
  #
  #     g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
  #     each_node = lambda {|&b| g.each_key(&b) }
  #     each_child = lambda {|n, &b| g[n].each(&b) }
  #     TSort.tsort_each(each_node, each_child) {|n| p n }
  #     #=> 4
  #     #   2
  #     #   3
  #     #   1
  #
  def self.tsort_each: [T] (_EachNode[T] each_node, _EachChild[T] each_child) { (T) -> void } -> void
                     | [T] (_EachNode[T] each_node, _EachChild[T] each_child) -> Enumerator[T, void]
                     | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) { (T) -> void } -> void
                     | [T] (^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child) -> Enumerator[T, void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component() { |nodes| ... }
  # -->
  # The iterator version of the #strongly_connected_components method.
  # *`obj*.each_strongly_connected_component` is similar to
  # *`obj*.strongly_connected_components.each`, but modification of *obj* during
  # the iteration may lead to unexpected results.
  #
  # #each_strongly_connected_component returns `nil`.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.each_strongly_connected_component {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #     #   [3]
  #     #   [1]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     graph.each_strongly_connected_component {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #     #   [1]
  #
  def each_strongly_connected_component: () { (Array[Node]) -> void } -> void
                                       | () -> Enumerator[Array[Node], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - each_strongly_connected_component_from(node, id_map={}, stack=[]) { |nodes| ... }
  # -->
  # Iterates over strongly connected component in the subgraph reachable from
  # *node*.
  #
  # Return value is unspecified.
  #
  # #each_strongly_connected_component_from doesn't call #tsort_each_node.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.each_strongly_connected_component_from(2) {|scc| p scc }
  #     #=> [4]
  #     #   [2]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     graph.each_strongly_connected_component_from(2) {|scc| p scc }
  #     #=> [4]
  #     #   [2, 3]
  #
  def each_strongly_connected_component_from: (Node, ?untyped id_map, ?untyped stack) { (Array[Node]) -> void } -> void
                                            | (Node, ?untyped id_map, ?untyped stack) -> Enumerator[Array[Node], void]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - strongly_connected_components()
  # -->
  # Returns strongly connected components as an array of arrays of nodes. The
  # array is sorted from children to parents. Each elements of the array
  # represents a strongly connected component.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     p graph.strongly_connected_components #=> [[4], [2], [3], [1]]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     p graph.strongly_connected_components #=> [[4], [2, 3], [1]]
  #
  def strongly_connected_components: () -> Array[Array[Node]]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort()
  # -->
  # Returns a topologically sorted array of nodes. The array is sorted from
  # children to parents, i.e. the first element has no child and the last node has
  # no parent.
  #
  # If there is a cycle, TSort::Cyclic is raised.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     p graph.tsort #=> [4, 2, 3, 1]
  #
  #     graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
  #     p graph.tsort # raises TSort::Cyclic
  #
  def tsort: () -> Array[Node]

  # <!--
  #   rdoc-file=lib/tsort.rb
  #   - tsort_each() { |node| ... }
  # -->
  # The iterator version of the #tsort method. *`obj*.tsort_each` is similar to
  # *`obj*.tsort.each`, but modification of *obj* during the iteration may lead to
  # unexpected results.
  #
  # #tsort_each returns `nil`. If there is a cycle, TSort::Cyclic is raised.
  #
  #     class G
  #       include TSort
  #       def initialize(g)
  #         @g = g
  #       end
  #       def tsort_each_child(n, &b) @g[n].each(&b) end
  #       def tsort_each_node(&b) @g.each_key(&b) end
  #     end
  #
  #     graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
  #     graph.tsort_each {|n| p n }
  #     #=> 4
  #     #   2
  #     #   3
  #     #   1
  #
  def tsort_each: () { (Node) -> void } -> void
                | () -> Enumerator[Node, void]
end

# <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
# Use the Monitor class when you want to have a lock object for blocks with
# mutual exclusion.
#
#     require 'monitor'
#
#     lock = Monitor.new
#     lock.synchronize do
#       # exclusive access
#     end
#
class Monitor
  public

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - enter()
  # -->
  #
  def enter: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - exit()
  # -->
  #
  def exit: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_check_owner()
  # -->
  #
  def mon_check_owner: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_enter()
  # -->
  #
  alias mon_enter enter

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_exit()
  # -->
  #
  alias mon_exit exit

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_locked?()
  # -->
  #
  def mon_locked?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - mon_owned?()
  # -->
  #
  def mon_owned?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_synchronize()
  # -->
  #
  alias mon_synchronize synchronize

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_try_enter()
  # -->
  #
  alias mon_try_enter try_enter

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new_cond()
  # -->
  #
  def new_cond: () -> ::MonitorMixin::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - synchronize()
  # -->
  #
  def synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - try_enter()
  # -->
  #
  def try_enter: () -> bool

  # <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
  # for compatibility
  #
  alias try_mon_enter try_enter

  # <!--
  #   rdoc-file=ext/monitor/monitor.c
  #   - wait_for_cond(p1, p2)
  # -->
  #
  def wait_for_cond: (::MonitorMixin::ConditionVariable, Numeric? timeout) -> untyped
end

module MonitorMixin
  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - extend_object(obj)
  # -->
  #
  def self.extend_object: (untyped obj) -> untyped

  public

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_enter()
  # -->
  # Enters exclusive section.
  #
  def mon_enter: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_exit()
  # -->
  # Leaves exclusive section.
  #
  def mon_exit: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_locked?()
  # -->
  # Returns true if this monitor is locked by any thread
  #
  def mon_locked?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_owned?()
  # -->
  # Returns true if this monitor is locked by current thread.
  #
  def mon_owned?: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_synchronize(&b)
  # -->
  # Enters exclusive section and executes the block.  Leaves the exclusive section
  # automatically when the block exits.  See example under `MonitorMixin`.
  #
  def mon_synchronize: [T] () { () -> T } -> T

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_try_enter()
  # -->
  # Attempts to enter exclusive section.  Returns `false` if lock fails.
  #
  def mon_try_enter: () -> bool

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new_cond()
  # -->
  # Creates a new MonitorMixin::ConditionVariable associated with the Monitor
  # object.
  #
  def new_cond: () -> ::MonitorMixin::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - synchronize(&b)
  # -->
  #
  alias synchronize mon_synchronize

  # <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
  # For backward compatibility
  #
  alias try_mon_enter mon_try_enter

  private

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new(...)
  # -->
  # Use `extend MonitorMixin` or `include MonitorMixin` instead of this
  # constructor.  Have look at the examples above to understand how to use this
  # module.
  #
  def initialize: (*untyped) { (*untyped) -> untyped } -> void

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_check_owner()
  # -->
  #
  def mon_check_owner: () -> nil

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - mon_initialize()
  # -->
  # Initializes the MonitorMixin after being included in a class or when an object
  # has been extended with the MonitorMixin
  #
  def mon_initialize: () -> untyped
end

# <!-- rdoc-file=ext/monitor/lib/monitor.rb -->
# FIXME: This isn't documented in Nutshell.
#
# Since MonitorMixin.new_cond returns a ConditionVariable, and the example above
# calls while_wait and signal, this class should be documented.
#
class MonitorMixin::ConditionVariable
  public

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - broadcast()
  # -->
  # Wakes up all threads waiting for this lock.
  #
  def broadcast: () -> Thread::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - signal()
  # -->
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal: () -> Thread::ConditionVariable

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait(timeout = nil)
  # -->
  # Releases the lock held in the associated monitor and waits; reacquires the
  # lock on wakeup.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed,
  # even if no other thread doesn't signal.
  #
  def wait: (?Numeric? timeout) -> untyped

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait_until()
  # -->
  # Calls wait repeatedly until the given block yields a truthy value.
  #
  def wait_until: () { () -> boolish } -> untyped

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - wait_while()
  # -->
  # Calls wait repeatedly while the given block yields a truthy value.
  #
  def wait_while: () { () -> boolish } -> untyped

  private

  # <!--
  #   rdoc-file=ext/monitor/lib/monitor.rb
  #   - new(monitor)
  # -->
  #
  def initialize: (Monitor monitor) -> void
end

# <!-- rdoc-file=ext/coverage/coverage.c -->
# Coverage provides coverage measurement feature for Ruby. This feature is
# experimental, so these APIs may be changed in future.
#
# Caveat: Currently, only process-global coverage measurement is supported. You
# cannot measure per-thread covearge.
#
# # Usage
#
# 1.  require "coverage"
# 2.  do Coverage.start
# 3.  require or load Ruby source file
# 4.  Coverage.result will return a hash that contains filename as key and
#     coverage array as value. A coverage array gives, for each line, the number
#     of line execution by the interpreter. A `nil` value means coverage is
#     disabled for this line (lines like `else` and `end`).
#
#
# # Examples
#
#     [foo.rb]
#     s = 0
#     10.times do |x|
#       s += x
#     end
#
#     if s == 45
#       p :ok
#     else
#       p :ng
#     end
#     [EOF]
#
#     require "coverage"
#     Coverage.start
#     require "foo.rb"
#     p Coverage.result  #=> {"foo.rb"=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}
#
# ## Lines Coverage
#
# If a coverage mode is not explicitly specified when starting coverage, lines
# coverage is what will run. It reports the number of line executions for each
# line.
#
#     require "coverage"
#     Coverage.start(lines: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}}
#
# The value of the lines coverage result is an array containing how many times
# each line was executed. Order in this array is important. For example, the
# first item in this array, at index 0, reports how many times line 1 of this
# file was executed while coverage was run (which, in this example, is one
# time).
#
# A `nil` value means coverage is disabled for this line (lines like `else` and
# `end`).
#
# ## Oneshot Lines Coverage
#
# Oneshot lines coverage tracks and reports on the executed lines while coverage
# is running. It will not report how many times a line was executed, only that
# it was executed.
#
#     require "coverage"
#     Coverage.start(oneshot_lines: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:oneshot_lines=>[1, 2, 3, 6, 7]}}
#
# The value of the oneshot lines coverage result is an array containing the line
# numbers that were executed.
#
# ## Branches Coverage
#
# Branches coverage reports how many times each branch within each conditional
# was executed.
#
#     require "coverage"
#     Coverage.start(branches: true)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}}}
#
# Each entry within the branches hash is a conditional, the value of which is
# another hash where each entry is a branch in that conditional. The values are
# the number of times the method was executed, and the keys are identifying
# information about the branch.
#
# The information that makes up each key identifying branches or conditionals is
# the following, from left to right:
#
# 1.  A label for the type of branch or conditional.
# 2.  A unique identifier.
# 3.  The starting line number it appears on in the file.
# 4.  The starting column number it appears on in the file.
# 5.  The ending line number it appears on in the file.
# 6.  The ending column number it appears on in the file.
#
#
# ## Methods Coverage
#
# Methods coverage reports how many times each method was executed.
#
#     [foo_method.rb]
#     class Greeter
#       def greet
#         "welcome!"
#       end
#     end
#
#     def hello
#       "Hi"
#     end
#
#     hello()
#     Greeter.new.greet()
#     [EOF]
#
#     require "coverage"
#     Coverage.start(methods: true)
#     require "foo_method.rb"
#     p Coverage.result #=> {"foo_method.rb"=>{:methods=>{[Object, :hello, 7, 0, 9, 3]=>1, [Greeter, :greet, 2, 2, 4, 5]=>1}}}
#
# Each entry within the methods hash represents a method. The values in this
# hash are the number of times the method was executed, and the keys are
# identifying information about the method.
#
# The information that makes up each key identifying a method is the following,
# from left to right:
#
# 1.  The class.
# 2.  The method name.
# 3.  The starting line number the method appears on in the file.
# 4.  The starting column number the method appears on in the file.
# 5.  The ending line number the method appears on in the file.
# 6.  The ending column number the method appears on in the file.
#
#
# ## All Coverage Modes
#
# You can also run all modes of coverage simultaneously with this shortcut. Note
# that running all coverage modes does not run both lines and oneshot lines.
# Those modes cannot be run simultaneously. Lines coverage is run in this case,
# because you can still use it to determine whether or not a line was executed.
#
#     require "coverage"
#     Coverage.start(:all)
#     require "foo.rb"
#     p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil], :branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}, :methods=>{}}}
#
module Coverage
  # <!--
  #   rdoc-file=ext/coverage/lib/coverage.rb
  #   - line_stub(file)
  # -->
  #
  def self.line_stub: () -> Array[Integer?]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.peek_result  => hash
  # -->
  # Returns a hash that contains filename as key and coverage array as value. This
  # is the same as `Coverage.result(stop: false, clear: false)`.
  #
  #     {
  #       "file.rb" => [1, 2, nil],
  #       ...
  #     }
  #
  def self.peek_result: () -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.result(stop: true, clear: true)  => hash
  # -->
  # Returns a hash that contains filename as key and coverage array as value. If
  # `clear` is true, it clears the counters to zero. If `stop` is true, it
  # disables coverage measurement.
  #
  def self.result: (?stop: boolish, ?clear: boolish) -> Hash[String, untyped]

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.running?  => bool
  # -->
  # Returns true if coverage stats are currently being collected (after
  # Coverage.start call, but before Coverage.result call)
  #
  def self.running?: () -> bool

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.start                                              => nil
  #   - Coverage.start(:all)                                        => nil
  #   - Coverage.start(lines: bool, branches: bool, methods: bool)  => nil
  #   - Coverage.start(oneshot_lines: true)                         => nil
  # -->
  # Enables the coverage measurement. See the documentation of Coverage class in
  # detail. This is equivalent to Coverage.setup and Coverage.resume.
  #
  def self.start: (?lines: boolish, ?branches: boolish, ?methods: boolish, ?oneshot_lines: boolish) -> nil

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.resume  => nil
  # -->
  # Start/resume the coverage measurement.
  #
  # Caveat: Currently, only process-global coverage measurement is supported. You
  # cannot measure per-thread covearge. If your process has multiple thread, using
  # Coverage.resume/suspend to capture code coverage executed from only a limited
  # code block, may yield misleading results.
  #
  def self.resume: () -> nil

  # <!--
  #   rdoc-file=ext/coverage/coverage.c
  #   - Coverage.suspend  => nil
  # -->
  # Suspend the coverage measurement. You can use Coverage.resume to restart the
  # measurement.
  #
  def self.suspend: () -> nil
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
# IPv6 are supported.
#
# ## Example
#
#     require 'ipaddr'
#
#     ipaddr1 = IPAddr.new "3ffe:505:2::1"
#
#     p ipaddr1                   #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>
#
#     p ipaddr1.to_s              #=> "3ffe:505:2::1"
#
#     ipaddr2 = ipaddr1.mask(48)  #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>
#
#     p ipaddr2.to_s              #=> "3ffe:505:2::"
#
#     ipaddr3 = IPAddr.new "192.168.2.0/24"
#
#     p ipaddr3                   #=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>
#
class IPAddr
  include Comparable

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - new_ntoh(addr)
  # -->
  # Creates a new ipaddr containing the given network byte ordered string form of
  # an IP address.
  #
  def self.new_ntoh: (String addr) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ntop(addr)
  # -->
  # Convert a network byte ordered string form of an IP address into human
  # readable form.
  #
  def self.ntop: (String addr) -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - new(addr = '::', family = Socket::AF_UNSPEC)
  # -->
  # Creates a new ipaddr object either from a human readable IP address
  # representation in string, or from a packed in_addr value followed by an
  # address family.
  #
  # In the former case, the following are the valid formats that will be
  # recognized: "address", "address/prefixlen" and "address/mask", where IPv6
  # address may be enclosed in square brackets (`[' and `]').  If a prefixlen or a
  # mask is specified, it returns a masked IP address.  Although the address
  # family is determined automatically from a specified string, you can specify
  # one explicitly by the optional second argument.
  #
  # Otherwise an IP address is generated from a packed in_addr value and an
  # address family.
  #
  # The IPAddr class defines many methods and operators, and some of those, such
  # as &, |, include? and ==, accept a string, or a packed in_addr value instead
  # of an IPAddr object.
  #
  def initialize: (?String addr, ?untyped family) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - &(other)
  # -->
  # Returns a new ipaddr built by bitwise AND.
  #
  def &: (untyped other) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - <<(num)
  # -->
  # Returns a new ipaddr built by bitwise left shift.
  #
  def <<: (Integer num) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - <=>(other)
  # -->
  # Compares the ipaddr with another.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ==(other)
  # -->
  # Returns true if two ipaddrs are equal.
  #
  def ==: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ===(other)
  # -->
  #
  alias === include?

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - >>(num)
  # -->
  # Returns a new ipaddr built by bitwise right-shift.
  #
  def >>: (Integer num) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - eql?(other)
  # -->
  # Checks equality used by Hash.
  #
  def eql?: (untyped other) -> bool

  # <!-- rdoc-file=lib/ipaddr.rb -->
  # Returns the address family of this IP address.
  #
  attr_reader family: Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - hash()
  # -->
  # Returns a hash value used by Hash, Set, and Array classes
  #
  def hash: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - hton()
  # -->
  # Returns a network byte ordered string form of the IP address.
  #
  def hton: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - include?(other)
  # -->
  # Returns true if the given ipaddr is in the range.
  #
  # e.g.:
  #     require 'ipaddr'
  #     net1 = IPAddr.new("192.168.2.0/24")
  #     net2 = IPAddr.new("192.168.2.100")
  #     net3 = IPAddr.new("192.168.3.0")
  #     net4 = IPAddr.new("192.168.2.0/16")
  #     p net1.include?(net2)     #=> true
  #     p net1.include?(net3)     #=> false
  #     p net1.include?(net4)     #=> false
  #     p net4.include?(net1)     #=> true
  #
  def include?: (untyped other) -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - inspect()
  # -->
  # Returns a string containing a human-readable representation of the ipaddr.
  # ("#<IPAddr: family:address/mask>")
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ip6_arpa()
  # -->
  # Returns a string for DNS reverse lookup compatible with RFC3172.
  #
  def ip6_arpa: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ip6_int()
  # -->
  # Returns a string for DNS reverse lookup compatible with RFC1886.
  #
  def ip6_int: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4?()
  # -->
  # Returns true if the ipaddr is an IPv4 address.
  #
  def ipv4?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_compat()
  # -->
  # Returns a new ipaddr built by converting the native IPv4 address into an
  # IPv4-compatible IPv6 address.
  #
  def ipv4_compat: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_compat?()
  # -->
  # Returns true if the ipaddr is an IPv4-compatible IPv6 address.
  #
  def ipv4_compat?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_mapped()
  # -->
  # Returns a new ipaddr built by converting the native IPv4 address into an
  # IPv4-mapped IPv6 address.
  #
  def ipv4_mapped: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv4_mapped?()
  # -->
  # Returns true if the ipaddr is an IPv4-mapped IPv6 address.
  #
  def ipv4_mapped?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ipv6?()
  # -->
  # Returns true if the ipaddr is an IPv6 address.
  #
  def ipv6?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - link_local?()
  # -->
  # Returns true if the ipaddr is a link-local address.  IPv4 addresses in
  # 169.254.0.0/16 reserved by RFC 3927 and Link-Local IPv6 Unicast Addresses in
  # fe80::/10 reserved by RFC 4291 are considered link-local.
  #
  def link_local?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - loopback?()
  # -->
  # Returns true if the ipaddr is a loopback address.
  #
  def loopback?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - mask(prefixlen)
  # -->
  # Returns a new ipaddr built by masking IP address with the given
  # prefixlen/netmask. (e.g. 8, 64, "255.255.255.0", etc.)
  #
  def mask: (String | Integer prefixlen) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - native()
  # -->
  # Returns a new ipaddr built by converting the IPv6 address into a native IPv4
  # address.  If the IP address is not an IPv4-mapped or IPv4-compatible IPv6
  # address, returns self.
  #
  def native: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - prefix()
  # -->
  # Returns the prefix length in bits for the ipaddr.
  #
  def prefix: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - prefix=(prefix)
  # -->
  # Sets the prefix length in bits
  #
  def prefix=: (Integer prefix) -> self

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - private?()
  # -->
  # Returns true if the ipaddr is a private address.  IPv4 addresses in
  # 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 as defined in RFC 1918 and IPv6
  # Unique Local Addresses in fc00::/7 as defined in RFC 4193 are considered
  # private.
  #
  def private?: () -> bool

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - reverse()
  # -->
  # Returns a string for DNS reverse lookup.  It returns a string in RFC3172 form
  # for an IPv6 address.
  #
  def reverse: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - succ()
  # -->
  # Returns the successor to the ipaddr.
  #
  def succ: () -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_i()
  # -->
  # Returns the integer representation of the ipaddr.
  #
  def to_i: () -> Integer

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_range()
  # -->
  # Creates a Range object for the network address.
  #
  def to_range: () -> Range[IPAddr]

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_s()
  # -->
  # Returns a string containing the IP address representation.
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - to_string()
  # -->
  # Returns a string containing the IP address representation in canonical form.
  #
  def to_string: () -> String

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - |(other)
  # -->
  # Returns a new ipaddr built by bitwise OR.
  #
  def |: (untyped other) -> IPAddr

  # <!--
  #   rdoc-file=lib/ipaddr.rb
  #   - ~()
  # -->
  # Returns a new ipaddr built by bitwise negation.
  #
  def ~: () -> IPAddr
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Generic IPAddr related error. Exceptions raised in this class should inherit
# from Error.
#
class IPAddr::Error < ArgumentError
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the provided IP address is an invalid address.
#
class IPAddr::InvalidAddressError < IPAddr::Error
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the address family is invalid such as an address with an
# unsupported family, an address with an inconsistent family, or an address
# who's family cannot be determined.
#
class IPAddr::AddressFamilyError < IPAddr::Error
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# Raised when the address is an invalid length.
#
class IPAddr::InvalidPrefixError < IPAddr::InvalidAddressError
end

# <!-- rdoc-file=lib/ipaddr.rb -->
# 32 bit mask for IPv4
#
IPAddr::IN4MASK: Integer

# <!-- rdoc-file=lib/ipaddr.rb -->
# Format string for IPv6
#
IPAddr::IN6FORMAT: String

# <!-- rdoc-file=lib/ipaddr.rb -->
# 128 bit mask for IPv6
#
IPAddr::IN6MASK: Integer

# <!-- rdoc-file=lib/logger/severity.rb -->
# Logging severity.
#
module Logger::Severity
  # <!-- rdoc-file=lib/logger/severity.rb -->
  # Low-level information, mostly for developers.
  #
  DEBUG: 0

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # Generic (useful) information about system operation.
  #
  INFO: 1

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # A warning.
  #
  WARN: 2

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # A handleable error condition.
  #
  ERROR: 3

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # An unhandleable error that results in a program crash.
  #
  FATAL: 4

  # <!-- rdoc-file=lib/logger/severity.rb -->
  # An unknown message that should always be logged.
  #
  UNKNOWN: 5
end

# <!-- rdoc-file=lib/logger.rb -->
# ## Description
#
# The Logger class provides a simple but sophisticated logging utility that you
# can use to output messages.
#
# The messages have associated levels, such as `INFO` or `ERROR` that indicate
# their importance.  You can then give the Logger a level, and only messages at
# that level or higher will be printed.
#
# The levels are:
#
# `UNKNOWN`
# :   An unknown message that should always be logged.
# `FATAL`
# :   An unhandleable error that results in a program crash.
# `ERROR`
# :   A handleable error condition.
# `WARN`
# :   A warning.
# `INFO`
# :   Generic (useful) information about system operation.
# `DEBUG`
# :   Low-level information for developers.
#
#
# For instance, in a production system, you may have your Logger set to `INFO`
# or even `WARN`. When you are developing the system, however, you probably want
# to know about the program's internal state, and would set the Logger to
# `DEBUG`.
#
# **Note**: Logger does not escape or sanitize any messages passed to it.
# Developers should be aware of when potentially malicious data (user-input) is
# passed to Logger, and manually escape the untrusted data:
#
#     logger.info("User-input: #{input.dump}")
#     logger.info("User-input: %p" % input)
#
# You can use #formatter= for escaping all data.
#
#     original_formatter = Logger::Formatter.new
#     logger.formatter = proc { |severity, datetime, progname, msg|
#       original_formatter.call(severity, datetime, progname, msg.dump)
#     }
#     logger.info(input)
#
# ### Example
#
# This creates a Logger that outputs to the standard output stream, with a level
# of `WARN`:
#
#     require 'logger'
#
#     logger = Logger.new(STDOUT)
#     logger.level = Logger::WARN
#
#     logger.debug("Created logger")
#     logger.info("Program started")
#     logger.warn("Nothing to do!")
#
#     path = "a_non_existent_file"
#
#     begin
#       File.foreach(path) do |line|
#         unless line =~ /^(\w+) = (.*)$/
#           logger.error("Line in wrong format: #{line.chomp}")
#         end
#       end
#     rescue => err
#       logger.fatal("Caught exception; exiting")
#       logger.fatal(err)
#     end
#
# Because the Logger's level is set to `WARN`, only the warning, error, and
# fatal messages are recorded.  The debug and info messages are silently
# discarded.
#
# ### Features
#
# There are several interesting features that Logger provides, like auto-rolling
# of log files, setting the format of log messages, and specifying a program
# name in conjunction with the message.  The next section shows you how to
# achieve these things.
#
# ## HOWTOs
#
# ### How to create a logger
#
# The options below give you various choices, in more or less increasing
# complexity.
#
# 1.  Create a logger which logs messages to STDERR/STDOUT.
#
#         logger = Logger.new(STDERR)
#         logger = Logger.new(STDOUT)
#
# 2.  Create a logger for the file which has the specified name.
#
#         logger = Logger.new('logfile.log')
#
# 3.  Create a logger for the specified file.
#
#         file = File.open('foo.log', File::WRONLY | File::APPEND)
#         # To create new logfile, add File::CREAT like:
#         # file = File.open('foo.log', File::WRONLY | File::APPEND | File::CREAT)
#         logger = Logger.new(file)
#
# 4.  Create a logger which ages the logfile once it reaches a certain size.
#     Leave 10 "old" log files where each file is about 1,024,000 bytes.
#
#         logger = Logger.new('foo.log', 10, 1024000)
#
# 5.  Create a logger which ages the logfile daily/weekly/monthly.
#
#         logger = Logger.new('foo.log', 'daily')
#         logger = Logger.new('foo.log', 'weekly')
#         logger = Logger.new('foo.log', 'monthly')
#
#
# ### How to log a message
#
# Notice the different methods (`fatal`, `error`, `info`) being used to log
# messages of various levels?  Other methods in this family are `warn` and
# `debug`.  `add` is used below to log a message of an arbitrary (perhaps
# dynamic) level.
#
# 1.  Message in a block.
#
#         logger.fatal { "Argument 'foo' not given." }
#
# 2.  Message as a string.
#
#         logger.error "Argument #{@foo} mismatch."
#
# 3.  With progname.
#
#         logger.info('initialize') { "Initializing..." }
#
# 4.  With severity.
#
#         logger.add(Logger::FATAL) { 'Fatal error!' }
#
#
# The block form allows you to create potentially complex log messages, but to
# delay their evaluation until and unless the message is logged.  For example,
# if we have the following:
#
#     logger.debug { "This is a " + potentially + " expensive operation" }
#
# If the logger's level is `INFO` or higher, no debug messages will be logged,
# and the entire block will not even be evaluated.  Compare to this:
#
#     logger.debug("This is a " + potentially + " expensive operation")
#
# Here, the string concatenation is done every time, even if the log level is
# not set to show the debug message.
#
# ### How to close a logger
#
#     logger.close
#
# ### Setting severity threshold
#
# 1.  Original interface.
#
#         logger.sev_threshold = Logger::WARN
#
# 2.  Log4r (somewhat) compatible interface.
#
#         logger.level = Logger::INFO
#
#         # DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN
#
# 3.  Symbol or String (case insensitive)
#
#         logger.level = :info
#         logger.level = 'INFO'
#
#         # :debug < :info < :warn < :error < :fatal < :unknown
#
# 4.  Constructor
#
#         Logger.new(logdev, level: Logger::INFO)
#         Logger.new(logdev, level: :info)
#         Logger.new(logdev, level: 'INFO')
#
#
# ## Format
#
# Log messages are rendered in the output stream in a certain format by default.
#  The default format and a sample are shown below:
#
# Log format:
#     SeverityID, [DateTime #pid] SeverityLabel -- ProgName: message
#
# Log sample:
#     I, [1999-03-03T02:34:24.895701 #19074]  INFO -- Main: info.
#
# You may change the date and time format via #datetime_format=.
#
#     logger.datetime_format = '%Y-%m-%d %H:%M:%S'
#           # e.g. "2004-01-03 00:54:26"
#
# or via the constructor.
#
#     Logger.new(logdev, datetime_format: '%Y-%m-%d %H:%M:%S')
#
# Or, you may change the overall format via the #formatter= method.
#
#     logger.formatter = proc do |severity, datetime, progname, msg|
#       "#{datetime}: #{msg}\n"
#     end
#     # e.g. "2005-09-22 08:51:08 +0900: hello world"
#
# or via the constructor.
#
#     Logger.new(logdev, formatter: proc {|severity, datetime, progname, msg|
#       "#{datetime}: #{msg}\n"
#     })
#
# <!-- rdoc-file=lib/logger/errors.rb -->
# not used after 1.2.7. just for compat.
#
class Logger
  interface _WriteCloser
    def write: (_ToS) -> untyped

    def close: () -> untyped
  end
  type logdev = _WriteCloser | String

  include Logger::Severity

  public

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - <<(msg)
  # -->
  # Dump given message to the log device without any formatting.  If no log device
  # exists, return `nil`.
  #
  def <<: (untyped msg) -> (untyped | nil)

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - Logger#add(severity, message = nil, progname = nil) { ... }
  # -->
  # ### Args
  #
  # `severity`
  # :   Severity.  Constants are defined in Logger namespace: `DEBUG`, `INFO`,
  #     `WARN`, `ERROR`, `FATAL`, or `UNKNOWN`.
  # `message`
  # :   The log message.  A String or Exception.
  # `progname`
  # :   Program name string.  Can be omitted.  Treated as a message if no
  #     `message` and `block` are given.
  # `block`
  # :   Can be omitted.  Called to get a message string if `message` is nil.
  #
  #
  # ### Return
  #
  # When the given severity is not high enough (for this particular logger), log
  # no message, and return `true`.
  #
  # ### Description
  #
  # Log a message if the given severity is high enough.  This is the generic
  # logging method.  Users will be more inclined to use #debug, #info, #warn,
  # #error, and #fatal.
  #
  # **Message format**: `message` can be any object, but it has to be converted to
  # a String in order to log it.  Generally, `inspect` is used if the given object
  # is not a String. A special case is an `Exception` object, which will be
  # printed in detail, including message, class, and backtrace.  See #msg2str for
  # the implementation if required.
  #
  # ### Bugs
  #
  # *   Logfile is not locked.
  # *   Append open does not need to lock file.
  # *   If the OS supports multi I/O, records possibly may be mixed.
  #
  def add: (Integer severity, ?untyped message, ?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - close()
  # -->
  # Close the logging device.
  #
  def close: () -> untyped

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - datetime_format()
  # -->
  # Returns the date format being used.  See #datetime_format=
  #
  def datetime_format: () -> String?

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - datetime_format=(datetime_format)
  # -->
  # Set date-time format.
  #
  # `datetime_format`
  # :   A string suitable for passing to `strftime`.
  #
  def datetime_format=: (String datetime_format) -> String
                      | (nil datetime_format) -> nil

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug(progname = nil, &block)
  # -->
  # Log a `DEBUG` message.
  #
  # See #info for more information.
  #
  def debug: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug!()
  # -->
  # Sets the severity to DEBUG.
  #
  def debug!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - debug?()
  # -->
  # Returns `true` if and only if the current severity level allows for the
  # printing of `DEBUG` messages.
  #
  def debug?: () -> bool

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error(progname = nil, &block)
  # -->
  # Log an `ERROR` message.
  #
  # See #info for more information.
  #
  def error: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error!()
  # -->
  # Sets the severity to ERROR.
  #
  def error!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - error?()
  # -->
  # Returns `true` if and only if the current severity level allows for the
  # printing of `ERROR` messages.
  #
  def error?: () -> bool

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal(progname = nil, &block)
  # -->
  # Log a `FATAL` message.
  #
  # See #info for more information.
  #
  def fatal: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal!()
  # -->
  # Sets the severity to FATAL.
  #
  def fatal!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - fatal?()
  # -->
  # Returns `true` if and only if the current severity level allows for the
  # printing of `FATAL` messages.
  #
  def fatal?: () -> bool

  # <!-- rdoc-file=lib/logger.rb -->
  # Logging formatter, as a `Proc` that will take four arguments and return the
  # formatted message. The arguments are:
  #
  # `severity`
  # :   The Severity of the log message.
  # `time`
  # :   A Time instance representing when the message was logged.
  # `progname`
  # :   The #progname configured, or passed to the logger method.
  # `msg`
  # :   The *Object* the user passed to the log message; not necessarily a String.
  #
  #
  # The block should return an Object that can be written to the logging device
  # via `write`.  The default formatter is used when no formatter is set.
  #
  def formatter: () -> (_Formatter | nil)

  # <!-- rdoc-file=lib/logger.rb -->
  # Logging formatter, as a `Proc` that will take four arguments and return the
  # formatted message. The arguments are:
  #
  # `severity`
  # :   The Severity of the log message.
  # `time`
  # :   A Time instance representing when the message was logged.
  # `progname`
  # :   The #progname configured, or passed to the logger method.
  # `msg`
  # :   The *Object* the user passed to the log message; not necessarily a String.
  #
  #
  # The block should return an Object that can be written to the logging device
  # via `write`.  The default formatter is used when no formatter is set.
  #
  def formatter=: (_Formatter) -> _Formatter
                | (nil) -> nil

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info(message)
  #   - info(progname, &block)
  # -->
  # Log an `INFO` message.
  #
  # `message`
  # :   The message to log; does not need to be a String.
  # `progname`
  # :   In the block form, this is the #progname to use in the log message.  The
  #     default can be set with #progname=.
  # `block`
  # :   Evaluates to the message to log.  This is not evaluated unless the
  #     logger's level is sufficient to log the message.  This allows you to
  #     create potentially expensive logging messages that are only called when
  #     the logger is configured to show them.
  #
  #
  # ### Examples
  #
  #     logger.info("MainApp") { "Received connection from #{ip}" }
  #     # ...
  #     logger.info "Waiting for input from user"
  #     # ...
  #     logger.info { "User typed #{input}" }
  #
  # You'll probably stick to the second form above, unless you want to provide a
  # program name (which you can do with #progname= as well).
  #
  # ### Return
  #
  # See #add.
  #
  def info: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info!()
  # -->
  # Sets the severity to INFO.
  #
  def info!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - info?()
  # -->
  # Returns `true` if and only if the current severity level allows for the
  # printing of `INFO` messages.
  #
  def info?: () -> bool

  # <!-- rdoc-file=lib/logger.rb -->
  # Logging severity threshold (e.g. `Logger::INFO`).
  #
  def level: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - level=(severity)
  # -->
  # Set logging severity threshold.
  #
  # `severity`
  # :   The Severity of the log message.
  #
  def level=: (Integer | String severity) -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - log(severity, message = nil, progname = nil)
  # -->
  #
  alias log add

  # <!-- rdoc-file=lib/logger.rb -->
  # Program name to include in log messages.
  #
  def progname: () -> untyped

  # <!-- rdoc-file=lib/logger.rb -->
  # Program name to include in log messages.
  #
  def progname=: (untyped) -> untyped

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - Logger#reopen
  #   - Logger#reopen(logdev)
  # -->
  # ### Args
  #
  # `logdev`
  # :   The log device.  This is a filename (String) or IO object (typically
  #     `STDOUT`, `STDERR`, or an open file).  reopen the same filename if it is
  #     `nil`, do nothing for IO.  Default is `nil`.
  #
  #
  # ### Description
  #
  # Reopen a log device.
  #
  def reopen: () -> self
            | (logdev?) -> self

  # <!-- rdoc-file=lib/logger.rb -->
  # Logging severity threshold (e.g. `Logger::INFO`).
  #
  alias sev_threshold level

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - sev_threshold=(severity)
  # -->
  #
  alias sev_threshold= level=

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - unknown(progname = nil, &block)
  # -->
  # Log an `UNKNOWN` message.  This will be printed no matter what the logger's
  # level is.
  #
  # See #info for more information.
  #
  def unknown: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn(progname = nil, &block)
  # -->
  # Log a `WARN` message.
  #
  # See #info for more information.
  #
  def warn: (?untyped progname) ?{ () -> untyped } -> true

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn!()
  # -->
  # Sets the severity to WARN.
  #
  def warn!: () -> Integer

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - warn?()
  # -->
  # Returns `true` if and only if the current severity level allows for the
  # printing of `WARN` messages.
  #
  def warn?: () -> bool

  private

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - format_message(severity, datetime, progname, msg)
  # -->
  #
  def format_message: (String severity, Time datetime, untyped progname, untyped msg) -> _ToS

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - format_severity(severity)
  # -->
  #
  def format_severity: (Integer severity) -> String

  # <!--
  #   rdoc-file=lib/logger.rb
  #   - Logger.new(logdev, shift_age = 0, shift_size = 1048576)
  #   - Logger.new(logdev, shift_age = 'weekly')
  #   - Logger.new(logdev, level: :info)
  #   - Logger.new(logdev, progname: 'progname')
  #   - Logger.new(logdev, formatter: formatter)
  #   - Logger.new(logdev, datetime_format: '%Y-%m-%d %H:%M:%S')
  # -->
  # ### Args
  #
  # `logdev`
  # :   The log device.  This is a filename (String), IO object (typically
  #     `STDOUT`, `STDERR`, or an open file), `nil` (it writes nothing) or
  #     `File::NULL` (same as `nil`).
  # `shift_age`
  # :   Number of old log files to keep, **or** frequency of rotation (`daily`,
  #     `weekly` or `monthly`). Default value is 0, which disables log file
  #     rotation.
  # `shift_size`
  # :   Maximum logfile size in bytes (only applies when `shift_age` is a positive
  #     Integer). Defaults to `1048576` (1MB).
  # `level`
  # :   Logging severity threshold. Default values is Logger::DEBUG.
  # `progname`
  # :   Program name to include in log messages. Default value is nil.
  # `formatter`
  # :   Logging formatter. Default values is an instance of Logger::Formatter.
  # `datetime_format`
  # :   Date and time format. Default value is '%Y-%m-%d %H:%M:%S'.
  # `binmode`
  # :   Use binary mode on the log device. Default value is false.
  # `shift_period_suffix`
  # :   The log file suffix format for `daily`, `weekly` or `monthly` rotation.
  #     Default is '%Y%m%d'.
  #
  #
  # ### Description
  #
  # Create an instance.
  #
  def initialize: (logdev logdev, ?Numeric | String shift_age, ?Integer shift_size, ?shift_period_suffix: String, ?binmode: boolish, ?datetime_format: String, ?formatter: _Formatter, ?progname: String, ?level: Integer) -> void
end

Logger::ProgName: String

# <!-- rdoc-file=lib/logger.rb -->
# Severity label for logging (max 5 chars).
#
Logger::SEV_LABEL: Array[String]

Logger::VERSION: String

module Logger::Period
  # <!--
  #   rdoc-file=lib/logger/period.rb
  #   - next_rotate_time(now, shift_age)
  # -->
  #
  def self?.next_rotate_time: (Time now, String shift_age) -> untyped

  # <!--
  #   rdoc-file=lib/logger/period.rb
  #   - previous_period_end(now, shift_age)
  # -->
  #
  def self?.previous_period_end: (Time now, String shift_age) -> untyped

  SiD: Integer
end

%a{annotate:rdoc:skip}
class Logger
  # <!-- rdoc-file=lib/logger/log_device.rb -->
  # Device used for logging messages.
  #
  class LogDevice
    include MonitorMixin

    include Period

    attr_reader dev: _WriteCloser
    attr_reader filename: String?

    public

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - close()
    # -->
    #
    def close: () -> nil

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - reopen(log = nil)
    # -->
    #
    def reopen: (?logdev log) -> self

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - write(message)
    # -->
    #
    def write: (untyped message) -> untyped

    private

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - add_log_header(file)
    # -->
    #
    def add_log_header: (IO file) -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - check_shift_log()
    # -->
    #
    def check_shift_log: () -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - create_logfile(filename)
    # -->
    #
    def create_logfile: (String filename) -> File

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - new(log = nil, shift_age: nil, shift_size: nil, shift_period_suffix: nil, binmode: false)
    # -->
    #
    def initialize: (?untyped logdev, ?binmode: boolish, ?shift_period_suffix: String, ?shift_size: Integer, ?shift_age: Numeric | String) -> void

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - lock_shift_log() { || ... }
    # -->
    #
    def lock_shift_log: () { () -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - open_logfile(filename)
    # -->
    #
    def open_logfile: (String filename) -> File

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - set_dev(log)
    # -->
    #
    def set_dev: (logdev log) -> untyped

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - shift_log_age()
    # -->
    #
    def shift_log_age: () -> true

    # <!--
    #   rdoc-file=lib/logger/log_device.rb
    #   - shift_log_period(period_end)
    # -->
    #
    def shift_log_period: (Time period_end) -> true
  end
end

%a{annotate:rdoc:skip}
class Logger
  # <!-- rdoc-file=lib/logger/formatter.rb -->
  # Default formatter for log messages.
  #
  class Formatter
    public

    attr_accessor datetime_format: String?

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - call(severity, time, progname, msg)
    # -->
    #
    def call: (String severity, Time time, untyped progname, untyped msg) -> String

    private

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - format_datetime(time)
    # -->
    #
    def format_datetime: (Time time) -> untyped

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - new()
    # -->
    #
    def initialize: () -> void

    # <!--
    #   rdoc-file=lib/logger/formatter.rb
    #   - msg2str(msg)
    # -->
    #
    def msg2str: (String | Exception | untyped msg) -> String
  end

  interface _Formatter
    def call: (String severity, Time time, untyped progname, untyped msg) -> _ToS
  end
end

Logger::Formatter::Format: String

# <!-- rdoc-file=lib/pstore.rb -->
# PStore implements a file based persistence mechanism based on a Hash.  User
# code can store hierarchies of Ruby objects (values) into the data store file
# by name (keys).  An object hierarchy may be just a single object.  User code
# may later read values back from the data store or even update data, as needed.
#
# The transactional behavior ensures that any changes succeed or fail together.
# This can be used to ensure that the data store is not left in a transitory
# state, where some values were updated but others were not.
#
# Behind the scenes, Ruby objects are stored to the data store file with
# Marshal.  That carries the usual limitations.  Proc objects cannot be
# marshalled, for example.
#
# ## Usage example:
#
#     require "pstore"
#
#     # a mock wiki object...
#     class WikiPage
#       def initialize( page_name, author, contents )
#         @page_name = page_name
#         @revisions = Array.new
#
#         add_revision(author, contents)
#       end
#
#       attr_reader :page_name
#
#       def add_revision( author, contents )
#         @revisions << { :created  => Time.now,
#                         :author   => author,
#                         :contents => contents }
#       end
#
#       def wiki_page_references
#         [@page_name] + @revisions.last[:contents].scan(/\b(?:[A-Z]+[a-z]+){2,}/)
#       end
#
#       # ...
#     end
#
#     # create a new page...
#     home_page = WikiPage.new( "HomePage", "James Edward Gray II",
#                               "A page about the JoysOfDocumentation..." )
#
#     # then we want to update page data and the index together, or not at all...
#     wiki = PStore.new("wiki_pages.pstore")
#     wiki.transaction do  # begin transaction; do all of this or none of it
#       # store page...
#       wiki[home_page.page_name] = home_page
#       # ensure that an index has been created...
#       wiki[:wiki_index] ||= Array.new
#       # update wiki index...
#       wiki[:wiki_index].push(*home_page.wiki_page_references)
#     end                   # commit changes to wiki data store file
#
#     ### Some time later... ###
#
#     # read wiki data...
#     wiki.transaction(true) do  # begin read-only transaction, no changes allowed
#       wiki.roots.each do |data_root_name|
#         p data_root_name
#         p wiki[data_root_name]
#       end
#     end
#
# ## Transaction modes
#
# By default, file integrity is only ensured as long as the operating system
# (and the underlying hardware) doesn't raise any unexpected I/O errors. If an
# I/O error occurs while PStore is writing to its file, then the file will
# become corrupted.
#
# You can prevent this by setting *pstore.ultra_safe = true*. However, this
# results in a minor performance loss, and only works on platforms that support
# atomic file renames. Please consult the documentation for `ultra_safe` for
# details.
#
# Needless to say, if you're storing valuable data with PStore, then you should
# backup the PStore files from time to time.
#
class PStore
  public

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - [](name)
  # -->
  # Retrieves a value from the PStore file data, by *name*.  The hierarchy of Ruby
  # objects stored under that root *name* will be returned.
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def []: (untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - []=(name, value)
  # -->
  # Stores an individual Ruby object or a hierarchy of Ruby objects in the data
  # store file under the root *name*.  Assigning to a *name* already in the data
  # store clobbers the old data.
  #
  # ## Example:
  #
  #     require "pstore"
  #
  #     store = PStore.new("data_file.pstore")
  #     store.transaction do  # begin transaction
  #       # load some data into the store...
  #       store[:single_object] = "My data..."
  #       store[:obj_hierarchy] = { "Kev Jackson" => ["rational.rb", "pstore.rb"],
  #                                 "James Gray"  => ["erb.rb", "pstore.rb"] }
  #     end                   # commit changes to data store file
  #
  # **WARNING**:  This method is only valid in a PStore#transaction and it cannot
  # be read-only.  It will raise PStore::Error if called at any other time.
  #
  def []=: (untyped name, untyped value) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - abort()
  # -->
  # Ends the current PStore#transaction, discarding any changes to the data store.
  #
  # ## Example:
  #
  #     require "pstore"
  #
  #     store = PStore.new("data_file.pstore")
  #     store.transaction do  # begin transaction
  #       store[:one] = 1     # this change is not applied, see below...
  #       store[:two] = 2     # this change is not applied, see below...
  #
  #       store.abort         # end transaction here, discard all changes
  #
  #       store[:three] = 3   # this change is never reached
  #     end
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def abort: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - commit()
  # -->
  # Ends the current PStore#transaction, committing any changes to the data store
  # immediately.
  #
  # ## Example:
  #
  #     require "pstore"
  #
  #     store = PStore.new("data_file.pstore")
  #     store.transaction do  # begin transaction
  #       # load some data into the store...
  #       store[:one] = 1
  #       store[:two] = 2
  #
  #       store.commit        # end transaction here, committing changes
  #
  #       store[:three] = 3   # this change is never reached
  #     end
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def commit: () -> nil

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - delete(name)
  # -->
  # Removes an object hierarchy from the data store, by *name*.
  #
  # **WARNING**:  This method is only valid in a PStore#transaction and it cannot
  # be read-only.  It will raise PStore::Error if called at any other time.
  #
  def delete: (untyped name) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - fetch(name, default=PStore::Error)
  # -->
  # This method is just like PStore#[], save that you may also provide a *default*
  # value for the object.  In the event the specified *name* is not found in the
  # data store, your *default* will be returned instead.  If you do not specify a
  # default, PStore::Error will be raised if the object is not found.
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def fetch: (untyped name, ?untyped default) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - path()
  # -->
  # Returns the path to the data store file.
  #
  def path: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - root?(name)
  # -->
  # Returns true if the supplied *name* is currently in the data store.
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def root?: (untyped name) -> bool

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - roots()
  # -->
  # Returns the names of all object hierarchies currently in the store.
  #
  # **WARNING**:  This method is only valid in a PStore#transaction.  It will
  # raise PStore::Error if called at any other time.
  #
  def roots: () -> Array[untyped]

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - transaction(read_only = false) { |pstore| ... }
  # -->
  # Opens a new transaction for the data store.  Code executed inside a block
  # passed to this method may read and write data to and from the data store file.
  #
  # At the end of the block, changes are committed to the data store
  # automatically.  You may exit the transaction early with a call to either
  # PStore#commit or PStore#abort.  See those methods for details about how
  # changes are handled.  Raising an uncaught Exception in the block is equivalent
  # to calling PStore#abort.
  #
  # If *read_only* is set to `true`, you will only be allowed to read from the
  # data store during the transaction and any attempts to change the data will
  # raise a PStore::Error.
  #
  # Note that PStore does not support nested transactions.
  #
  def transaction: (?untyped read_only) -> untyped

  # <!-- rdoc-file=lib/pstore.rb -->
  # Whether PStore should do its best to prevent file corruptions, even when under
  # unlikely-to-occur error conditions such as out-of-space conditions and other
  # unusual OS filesystem errors. Setting this flag comes at the price in the form
  # of a performance loss.
  #
  # This flag only has effect on platforms on which file renames are atomic (e.g.
  # all POSIX platforms: Linux, MacOS X, FreeBSD, etc). The default value is
  # false.
  #
  def ultra_safe: () -> untyped

  # <!-- rdoc-file=lib/pstore.rb -->
  # Whether PStore should do its best to prevent file corruptions, even when under
  # unlikely-to-occur error conditions such as out-of-space conditions and other
  # unusual OS filesystem errors. Setting this flag comes at the price in the form
  # of a performance loss.
  #
  # This flag only has effect on platforms on which file renames are atomic (e.g.
  # all POSIX platforms: Linux, MacOS X, FreeBSD, etc). The default value is
  # false.
  #
  def ultra_safe=: (untyped) -> untyped

  private

  def dump: (untyped table) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - empty_marshal_checksum()
  # -->
  #
  def empty_marshal_checksum: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - empty_marshal_data()
  # -->
  #
  def empty_marshal_data: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - in_transaction()
  # -->
  # Raises PStore::Error if the calling code is not in a PStore#transaction.
  #
  def in_transaction: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - in_transaction_wr()
  # -->
  # Raises PStore::Error if the calling code is not in a PStore#transaction or if
  # the code is in a read-only PStore#transaction.
  #
  def in_transaction_wr: () -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - new(file, thread_safe = false)
  # -->
  # To construct a PStore object, pass in the *file* path where you would like the
  # data to be stored.
  #
  # PStore objects are always reentrant. But if *thread_safe* is set to true, then
  # it will become thread-safe at the cost of a minor performance hit.
  #
  def initialize: (untyped file, ?boolish thread_safe) -> untyped

  def load: (untyped content) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - load_data(file, read_only)
  # -->
  # Load the given PStore file. If `read_only` is true, the unmarshalled Hash will
  # be returned. If `read_only` is false, a 3-tuple will be returned: the
  # unmarshalled Hash, a checksum of the data, and the size of the data.
  #
  def load_data: (untyped file, untyped read_only) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - on_windows?()
  # -->
  #
  def on_windows?: () -> bool

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - open_and_lock_file(filename, read_only)
  # -->
  # Open the specified filename (either in read-only mode or in read-write mode)
  # and lock it for reading or writing.
  #
  # The opened File object will be returned. If *read_only* is true, and the file
  # does not exist, then nil will be returned.
  #
  # All exceptions are propagated.
  #
  def open_and_lock_file: (untyped filename, untyped read_only) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data(original_checksum, original_file_size, file)
  # -->
  #
  def save_data: (untyped original_checksum, untyped original_file_size, untyped file) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data_with_atomic_file_rename_strategy(data, file)
  # -->
  #
  def save_data_with_atomic_file_rename_strategy: (untyped data, untyped file) -> untyped

  # <!--
  #   rdoc-file=lib/pstore.rb
  #   - save_data_with_fast_strategy(data, file)
  # -->
  #
  def save_data_with_fast_strategy: (untyped data, untyped file) -> untyped
end

PStore::EMPTY_MARSHAL_CHECKSUM: String

PStore::EMPTY_MARSHAL_DATA: String

PStore::EMPTY_STRING: String

PStore::RDWR_ACCESS: Hash[untyped, untyped]

PStore::RD_ACCESS: Hash[untyped, untyped]

PStore::VERSION: String

PStore::WR_ACCESS: Hash[untyped, untyped]

# <!-- rdoc-file=ext/pathname/pathname.c -->
# Pathname represents the name of a file or directory on the filesystem, but not
# the file itself.
#
# The pathname depends on the Operating System: Unix, Windows, etc. This library
# works with pathnames of local OS, however non-Unix pathnames are supported
# experimentally.
#
# A Pathname can be relative or absolute.  It's not until you try to reference
# the file that it even matters whether the file exists or not.
#
# Pathname is immutable.  It has no method for destructive update.
#
# The goal of this class is to manipulate file path information in a neater way
# than standard Ruby provides.  The examples below demonstrate the difference.
#
# **All** functionality from File, FileTest, and some from Dir and FileUtils is
# included, in an unsurprising way.  It is essentially a facade for all of
# these, and more.
#
# ## Examples
#
# ### Example 1: Using Pathname
#
#     require 'pathname'
#     pn = Pathname.new("/usr/bin/ruby")
#     size = pn.size              # 27662
#     isdir = pn.directory?       # false
#     dir  = pn.dirname           # Pathname:/usr/bin
#     base = pn.basename          # Pathname:ruby
#     dir, base = pn.split        # [Pathname:/usr/bin, Pathname:ruby]
#     data = pn.read
#     pn.open { |f| _ }
#     pn.each_line { |line| _ }
#
# ### Example 2: Using standard Ruby
#
#     pn = "/usr/bin/ruby"
#     size = File.size(pn)        # 27662
#     isdir = File.directory?(pn) # false
#     dir  = File.dirname(pn)     # "/usr/bin"
#     base = File.basename(pn)    # "ruby"
#     dir, base = File.split(pn)  # ["/usr/bin", "ruby"]
#     data = File.read(pn)
#     File.open(pn) { |f| _ }
#     File.foreach(pn) { |line| _ }
#
# ### Example 3: Special features
#
#     p1 = Pathname.new("/usr/lib")   # Pathname:/usr/lib
#     p2 = p1 + "ruby/1.8"            # Pathname:/usr/lib/ruby/1.8
#     p3 = p1.parent                  # Pathname:/usr
#     p4 = p2.relative_path_from(p3)  # Pathname:lib/ruby/1.8
#     pwd = Pathname.pwd              # Pathname:/home/gavin
#     pwd.absolute?                   # true
#     p5 = Pathname.new "."           # Pathname:.
#     p5 = p5 + "music/../articles"   # Pathname:music/../articles
#     p5.cleanpath                    # Pathname:articles
#     p5.realpath                     # Pathname:/home/gavin/articles
#     p5.children                     # [Pathname:/home/gavin/articles/linux, ...]
#
# ## Breakdown of functionality
#
# ### Core methods
#
# These methods are effectively manipulating a String, because that's all a path
# is.  None of these access the file system except for #mountpoint?, #children,
# #each_child, #realdirpath and #realpath.
#
# *   +
# *   #join
# *   #parent
# *   #root?
# *   #absolute?
# *   #relative?
# *   #relative_path_from
# *   #each_filename
# *   #cleanpath
# *   #realpath
# *   #realdirpath
# *   #children
# *   #each_child
# *   #mountpoint?
#
#
# ### File status predicate methods
#
# These methods are a facade for FileTest:
# *   #blockdev?
# *   #chardev?
# *   #directory?
# *   #executable?
# *   #executable_real?
# *   #exist?
# *   #file?
# *   #grpowned?
# *   #owned?
# *   #pipe?
# *   #readable?
# *   #world_readable?
# *   #readable_real?
# *   #setgid?
# *   #setuid?
# *   #size
# *   #size?
# *   #socket?
# *   #sticky?
# *   #symlink?
# *   #writable?
# *   #world_writable?
# *   #writable_real?
# *   #zero?
#
#
# ### File property and manipulation methods
#
# These methods are a facade for File:
# *   #atime
# *   #birthtime
# *   #ctime
# *   #mtime
# *   #chmod(mode)
# *   #lchmod(mode)
# *   #chown(owner, group)
# *   #lchown(owner, group)
# *   #fnmatch(pattern, *args)
# *   #fnmatch?(pattern, *args)
# *   #ftype
# *   #make_link(old)
# *   #open(*args, &block)
# *   #readlink
# *   #rename(to)
# *   #stat
# *   #lstat
# *   #make_symlink(old)
# *   #truncate(length)
# *   #utime(atime, mtime)
# *   #basename(*args)
# *   #dirname
# *   #extname
# *   #expand_path(*args)
# *   #split
#
#
# ### Directory methods
#
# These methods are a facade for Dir:
# *   Pathname.glob(*args)
# *   Pathname.getwd / Pathname.pwd
# *   #rmdir
# *   #entries
# *   #each_entry(&block)
# *   #mkdir(*args)
# *   #opendir(*args)
#
#
# ### IO
#
# These methods are a facade for IO:
# *   #each_line(*args, &block)
# *   #read(*args)
# *   #binread(*args)
# *   #readlines(*args)
# *   #sysopen(*args)
# *   #write(*args)
# *   #binwrite(*args)
#
#
# ### Utilities
#
# These methods are a mixture of Find, FileUtils, and others:
# *   #find(&block)
# *   #mkpath
# *   #rmtree
# *   #unlink / #delete
#
#
# ## Method documentation
#
# As the above section shows, most of the methods in Pathname are facades.  The
# documentation for these methods generally just says, for instance, "See
# FileTest.writable?", as you should be familiar with the original method
# anyway, and its documentation (e.g. through `ri`) will contain more
# information.  In some cases, a brief description will follow.
#
class Pathname
  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - getwd()
  # -->
  # Returns the current working directory as a Pathname.
  #
  #     Pathname.getwd
  #         #=> #<Pathname:/home/zzak/projects/ruby>
  #
  # See Dir.getwd.
  #
  def self.getwd: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - glob(p1, p2 = v2, p3 = v3)
  # -->
  # Returns or yields Pathname objects.
  #
  #     Pathname.glob("lib/i*.rb")
  #         #=> [#<Pathname:lib/ipaddr.rb>, #<Pathname:lib/irb.rb>]
  #
  # See Dir.glob.
  #
  def self.glob: (String | Array[String] pattern, ?Integer flags) -> Array[Pathname]
               | (String | Array[String] pattern, ?Integer flags) { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pwd()
  # -->
  # Returns the current working directory as a Pathname.
  #
  #     Pathname.getwd
  #         #=> #<Pathname:/home/zzak/projects/ruby>
  #
  # See Dir.getwd.
  #
  def self.pwd: () -> Pathname

  public

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - +(other)
  # -->
  # Appends a pathname fragment to `self` to produce a new Pathname object.
  #
  #     p1 = Pathname.new("/usr")      # Pathname:/usr
  #     p2 = p1 + "bin/ruby"           # Pathname:/usr/bin/ruby
  #     p3 = p1 + "/etc/passwd"        # Pathname:/etc/passwd
  #
  #     # / is aliased to +.
  #     p4 = p1 / "bin/ruby"           # Pathname:/usr/bin/ruby
  #     p5 = p1 / "/etc/passwd"        # Pathname:/etc/passwd
  #
  # This method doesn't access the file system; it is pure string manipulation.
  #
  def +: (Pathname | String | _ToStr other) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - /(other)
  # -->
  #
  alias / +

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - <=>(p1)
  # -->
  # Provides a case-sensitive comparison operator for pathnames.
  #
  #     Pathname.new('/usr') <=> Pathname.new('/usr/bin')
  #         #=> -1
  #     Pathname.new('/usr/bin') <=> Pathname.new('/usr/bin')
  #         #=> 0
  #     Pathname.new('/usr/bin') <=> Pathname.new('/USR/BIN')
  #         #=> 1
  #
  # It will return `-1`, `0` or `1` depending on the value of the left argument
  # relative to the right argument. Or it will return `nil` if the arguments are
  # not comparable.
  #
  def <=>: (Pathname other) -> Integer
         | (untyped other) -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - ==(p1)
  # -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def ==: (untyped) -> bool

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def ===: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - absolute?()
  # -->
  # Predicate method for testing whether a path is absolute.
  #
  # It returns `true` if the pathname begins with a slash.
  #
  #     p = Pathname.new('/im/sure')
  #     p.absolute?
  #         #=> true
  #
  #     p = Pathname.new('not/so/sure')
  #     p.absolute?
  #         #=> false
  #
  def absolute?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - ascend() { |self| ... }
  # -->
  # Iterates over and yields a new Pathname object for each element in the given
  # path in ascending order.
  #
  #     Pathname.new('/path/to/some/file.rb').ascend {|v| p v}
  #        #<Pathname:/path/to/some/file.rb>
  #        #<Pathname:/path/to/some>
  #        #<Pathname:/path/to>
  #        #<Pathname:/path>
  #        #<Pathname:/>
  #
  #     Pathname.new('path/to/some/file.rb').ascend {|v| p v}
  #        #<Pathname:path/to/some/file.rb>
  #        #<Pathname:path/to/some>
  #        #<Pathname:path/to>
  #        #<Pathname:path>
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").ascend
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields Pathnames /usr/bin/ruby, /usr/bin, /usr, and /.
  #
  # It doesn't access the filesystem.
  #
  def ascend: () { (Pathname) -> untyped } -> nil
            | () -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.atime     -> time
  # -->
  # Returns the last access time for the file.
  #
  # See File.atime.
  #
  def atime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - basename(p1 = v1)
  # -->
  # Returns the last component of the path.
  #
  # See File.basename.
  #
  def basename: (?String | _ToStr suffix) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.binread([length [, offset]]) -> string
  # -->
  # Returns all the bytes from the file, or the first `N` if specified.
  #
  # See File.binread.
  #
  def binread: (?Integer length, ?Integer offset) -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.binwrite(string, [offset] )   => fixnum
  #   - pathname.binwrite(string, [offset], open_args )   => fixnum
  # -->
  # Writes `contents` to the file, opening it in binary mode.
  #
  # See File.binwrite.
  #
  def binwrite: (String, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?invalid: :replace ?, ?undef: :replace ?, ?replace: String, ?fallback: Hash[String, String] | Proc | Method, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.birthtime -> time
  # -->
  # Returns the birth time for the file. If the platform doesn't have birthtime,
  # raises NotImplementedError.
  #
  # See File.birthtime.
  #
  def birthtime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - blockdev?()
  # -->
  # See FileTest.blockdev?.
  #
  def blockdev?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - chardev?()
  # -->
  # See FileTest.chardev?.
  #
  def chardev?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - children(with_directory=true)
  # -->
  # Returns the children of the directory (files and subdirectories, not
  # recursive) as an array of Pathname objects.
  #
  # By default, the returned pathnames will have enough information to access the
  # files. If you set `with_directory` to `false`, then the returned pathnames
  # will contain the filename only.
  #
  # For example:
  #     pn = Pathname("/usr/lib/ruby/1.8")
  #     pn.children
  #         # -> [ Pathname:/usr/lib/ruby/1.8/English.rb,
  #                Pathname:/usr/lib/ruby/1.8/Env.rb,
  #                Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]
  #     pn.children(false)
  #         # -> [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]
  #
  # Note that the results never contain the entries `.` and `..` in the directory
  # because they are not children.
  #
  def children: (?boolish with_directory) -> Array[Pathname]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.chmod(mode_int)   -> integer
  # -->
  # Changes file permissions.
  #
  # See File.chmod.
  #
  def chmod: (Integer mode_int) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.chown(owner_int, group_int)       -> integer
  # -->
  # Change owner and group of the file.
  #
  # See File.chown.
  #
  def chown: (Integer owner, Integer group) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - cleanpath(consider_symlink=false)
  # -->
  # Returns clean pathname of `self` with consecutive slashes and useless dots
  # removed.  The filesystem is not accessed.
  #
  # If `consider_symlink` is `true`, then a more conservative algorithm is used to
  # avoid breaking symbolic linkages.  This may retain more `..` entries than
  # absolutely necessary, but without accessing the filesystem, this can't be
  # avoided.
  #
  # See Pathname#realpath.
  #
  def cleanpath: (?boolish consider_symlink) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.ctime     -> time
  # -->
  # Returns the last change time, using directory information, not the file
  # itself.
  #
  # See File.ctime.
  #
  def ctime: () -> Time

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Removes a file or directory, using File.unlink if `self` is a file, or
  # Dir.unlink as necessary.
  #
  def delete: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - descend() { |v| ... }
  # -->
  # Iterates over and yields a new Pathname object for each element in the given
  # path in descending order.
  #
  #     Pathname.new('/path/to/some/file.rb').descend {|v| p v}
  #        #<Pathname:/>
  #        #<Pathname:/path>
  #        #<Pathname:/path/to>
  #        #<Pathname:/path/to/some>
  #        #<Pathname:/path/to/some/file.rb>
  #
  #     Pathname.new('path/to/some/file.rb').descend {|v| p v}
  #        #<Pathname:path>
  #        #<Pathname:path/to>
  #        #<Pathname:path/to/some>
  #        #<Pathname:path/to/some/file.rb>
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").descend
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields Pathnames /, /usr, /usr/bin, and /usr/bin/ruby.
  #
  # It doesn't access the filesystem.
  #
  def descend: () { (Pathname) -> untyped } -> nil
             | () -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - directory?()
  # -->
  # See FileTest.directory?.
  #
  def directory?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - dirname()
  # -->
  # Returns all but the last component of the path.
  #
  # See File.dirname.
  #
  def dirname: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - each_child(with_directory=true, &b)
  # -->
  # Iterates over the children of the directory (files and subdirectories, not
  # recursive).
  #
  # It yields Pathname object for each child.
  #
  # By default, the yielded pathnames will have enough information to access the
  # files.
  #
  # If you set `with_directory` to `false`, then the returned pathnames will
  # contain the filename only.
  #
  #     Pathname("/usr/local").each_child {|f| p f }
  #     #=> #<Pathname:/usr/local/share>
  #     #   #<Pathname:/usr/local/bin>
  #     #   #<Pathname:/usr/local/games>
  #     #   #<Pathname:/usr/local/lib>
  #     #   #<Pathname:/usr/local/include>
  #     #   #<Pathname:/usr/local/sbin>
  #     #   #<Pathname:/usr/local/src>
  #     #   #<Pathname:/usr/local/man>
  #
  #     Pathname("/usr/local").each_child(false) {|f| p f }
  #     #=> #<Pathname:share>
  #     #   #<Pathname:bin>
  #     #   #<Pathname:games>
  #     #   #<Pathname:lib>
  #     #   #<Pathname:include>
  #     #   #<Pathname:sbin>
  #     #   #<Pathname:src>
  #     #   #<Pathname:man>
  #
  # Note that the results never contain the entries `.` and `..` in the directory
  # because they are not children.
  #
  # See Pathname#children
  #
  def each_child: (?boolish with_directory) { (Pathname) -> void } -> Array[Pathname]
                | (?boolish with_directory) -> Enumerator[Pathname, Array[Pathname]]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - each_entry()
  # -->
  # Iterates over the entries (files and subdirectories) in the directory,
  # yielding a Pathname object for each entry.
  #
  def each_entry: () { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - each_filename() { |filename| ... }
  # -->
  # Iterates over each component of the path.
  #
  #     Pathname.new("/usr/bin/ruby").each_filename {|filename| ... }
  #       # yields "usr", "bin", and "ruby".
  #
  # Returns an Enumerator if no block was given.
  #
  #     enum = Pathname.new("/usr/bin/ruby").each_filename
  #       # ... do stuff ...
  #     enum.each { |e| ... }
  #       # yields "usr", "bin", and "ruby".
  #
  def each_filename: () { (String) -> untyped } -> nil
                   | () -> Enumerator[String, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.each_line {|line| ... }
  #   - pathname.each_line(sep=$/ [, open_args]) {|line| block }     -> nil
  #   - pathname.each_line(limit [, open_args]) {|line| block }      -> nil
  #   - pathname.each_line(sep, limit [, open_args]) {|line| block } -> nil
  #   - pathname.each_line(...)                                      -> an_enumerator
  # -->
  # Iterates over each line in the file and yields a String object for each.
  #
  def each_line: (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) { (String) -> untyped } -> nil
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) { (String) -> untyped } -> nil
               | (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Enumerator[String, nil]
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Enumerator[String, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - empty?()
  # -->
  # Tests the file is empty.
  #
  # See Dir#empty? and FileTest.empty?.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - entries()
  # -->
  # Return the entries (files and subdirectories) in the directory, each as a
  # Pathname object.
  #
  # The results contains just the names in the directory, without any trailing
  # slashes or recursive look-up.
  #
  #     pp Pathname.new('/usr/local').entries
  #     #=> [#<Pathname:share>,
  #     #    #<Pathname:lib>,
  #     #    #<Pathname:..>,
  #     #    #<Pathname:include>,
  #     #    #<Pathname:etc>,
  #     #    #<Pathname:bin>,
  #     #    #<Pathname:man>,
  #     #    #<Pathname:games>,
  #     #    #<Pathname:.>,
  #     #    #<Pathname:sbin>,
  #     #    #<Pathname:src>]
  #
  # The result may contain the current directory `#<Pathname:.>` and the parent
  # directory `#<Pathname:..>`.
  #
  # If you don't want `.` and `..` and want directories, consider
  # Pathname#children.
  #
  def entries: () -> Array[Pathname]

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Compare this pathname with `other`.  The comparison is string-based. Be aware
  # that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
  # file.
  #
  def eql?: (untyped) -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - executable?()
  # -->
  # See FileTest.executable?.
  #
  def executable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - executable_real?()
  # -->
  # See FileTest.executable_real?.
  #
  def executable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - exist?()
  # -->
  # See FileTest.exist?.
  #
  def exist?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - expand_path(p1 = v1)
  # -->
  # Returns the absolute path for the file.
  #
  # See File.expand_path.
  #
  def expand_path: (?String dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - extname()
  # -->
  # Returns the file's extension.
  #
  # See File.extname.
  #
  def extname: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - file?()
  # -->
  # See FileTest.file?.
  #
  def file?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - find(ignore_error: true) { |pathname| ... }
  # -->
  # Iterates over the directory tree in a depth first manner, yielding a Pathname
  # for each file under "this" directory.
  #
  # Returns an Enumerator if no block is given.
  #
  # Since it is implemented by the standard library module Find, Find.prune can be
  # used to control the traversal.
  #
  # If `self` is `.`, yielded pathnames begin with a filename in the current
  # directory, not `./`.
  #
  # See Find.find
  #
  def find: (?ignore_error: boolish) { (Pathname) -> untyped } -> nil
          | (?ignore_error: boolish) -> Enumerator[Pathname, nil]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.fnmatch(pattern, [flags])        -> true or false
  #   - pathname.fnmatch?(pattern, [flags])       -> true or false
  # -->
  # Return `true` if the receiver matches the given pattern.
  #
  # See File.fnmatch.
  #
  def fnmatch: (String pattern, ?Integer flags) -> bool

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Return `true` if the receiver matches the given pattern.
  #
  # See File.fnmatch.
  #
  alias fnmatch? fnmatch

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.freeze -> obj
  # -->
  # Freezes this Pathname.
  #
  # See Object.freeze.
  #
  def freeze: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.ftype     -> string
  # -->
  # Returns "type" of file ("file", "directory", etc).
  #
  # See File.ftype.
  #
  def ftype: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - glob(p1, p2 = v2)
  # -->
  # Returns or yields Pathname objects.
  #
  #     Pathname("ruby-2.4.2").glob("R*.md")
  #     #=> [#<Pathname:ruby-2.4.2/README.md>, #<Pathname:ruby-2.4.2/README.ja.md>]
  #
  # See Dir.glob. This method uses the `base` keyword argument of Dir.glob.
  #
  def glob: (String | Array[String] pattern, ?Integer flags) -> Array[Pathname]
          | (String | Array[String] pattern, ?Integer flags) { (Pathname) -> untyped } -> nil

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - grpowned?()
  # -->
  # See FileTest.grpowned?.
  #
  def grpowned?: () -> bool

  def hash: () -> Integer

  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - join(*args)
  # -->
  # Joins the given pathnames onto `self` to create a new Pathname object.
  #
  #     path0 = Pathname.new("/usr")                # Pathname:/usr
  #     path0 = path0.join("bin/ruby")              # Pathname:/usr/bin/ruby
  #         # is the same as
  #     path1 = Pathname.new("/usr") + "bin/ruby"   # Pathname:/usr/bin/ruby
  #     path0 == path1
  #         #=> true
  #
  def join: (*String | _ToStr | Pathname args) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.lchmod(mode_int)  -> integer
  # -->
  # Same as Pathname.chmod, but does not follow symbolic links.
  #
  # See File.lchmod.
  #
  def lchmod: (Integer mode) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.lchown(owner_int, group_int)      -> integer
  # -->
  # Same as Pathname.chown, but does not follow symbolic links.
  #
  # See File.lchown.
  #
  def lchown: (Integer owner, Integer group) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - lstat()
  # -->
  # See File.lstat.
  #
  def lstat: () -> ::File::Stat

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.make_link(old)
  # -->
  # Creates a hard link at *pathname*.
  #
  # See File.link.
  #
  def make_link: (String | Pathname | _ToStr old) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.make_symlink(old)
  # -->
  # Creates a symbolic link.
  #
  # See File.symlink.
  #
  def make_symlink: (String | Pathname | _ToStr old) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - mkdir(p1 = v1)
  # -->
  # Create the referenced directory.
  #
  # See Dir.mkdir.
  #
  def mkdir: (?Integer perm) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - mkpath(mode: nil)
  # -->
  # Creates a full path, including any intermediate directories that don't yet
  # exist.
  #
  # See FileUtils.mkpath and FileUtils.mkdir_p
  #
  def mkpath: () -> nil

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - mountpoint?()
  # -->
  # Returns `true` if `self` points to a mountpoint.
  #
  def mountpoint?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.mtime     -> time
  # -->
  # Returns the last modified time of the file.
  #
  # See File.mtime.
  #
  def mtime: () -> Time

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.open()
  #   - pathname.open(mode="r" [, opt])                        -> file
  #   - pathname.open([mode [, perm]] [, opt])                 -> file
  #   - pathname.open(mode="r" [, opt]) {|file| block }        -> obj
  #   - pathname.open([mode [, perm]] [, opt]) {|file| block } -> obj
  # -->
  # Opens the file for reading or writing.
  #
  # See File.open.
  #
  def open: (?string | int mode, ?int perm) -> File
          | [T] (?string | int mode, ?int perm) { (File) -> T } -> T

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - opendir()
  # -->
  # Opens the referenced directory.
  #
  # See Dir.open.
  #
  def opendir: () -> Dir
             | [U] () { (Dir) -> U } -> U

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - owned?()
  # -->
  # See FileTest.owned?.
  #
  def owned?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - parent()
  # -->
  # Returns the parent directory.
  #
  # This is same as `self + '..'`.
  #
  def parent: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pipe?()
  # -->
  # See FileTest.pipe?.
  #
  def pipe?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.read([length [, offset]]) -> string
  #   - pathname.read([length [, offset]], open_args) -> string
  # -->
  # Returns all data from the file, or the first `N` bytes if specified.
  #
  # See File.read.
  #
  def read: (?Integer length, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish) -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readable?()
  # -->
  # See FileTest.readable?.
  #
  def readable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readable_real?()
  # -->
  # See FileTest.readable_real?.
  #
  def readable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.readlines(sep=$/ [, open_args])     -> array
  #   - pathname.readlines(limit [, open_args])      -> array
  #   - pathname.readlines(sep, limit [, open_args]) -> array
  # -->
  # Returns all the lines from the file.
  #
  # See File.readlines.
  #
  def readlines: (?String sep, ?Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Array[String]
               | (Integer limit, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish, ?chomp: boolish) -> Array[String]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - readlink()
  # -->
  # Read symbolic link.
  #
  # See File.readlink.
  #
  def readlink: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - realdirpath(p1 = v1)
  # -->
  # Returns the real (absolute) pathname of `self` in the actual filesystem.
  #
  # Does not contain symlinks or useless dots, `..` and `.`.
  #
  # The last component of the real pathname can be nonexistent.
  #
  def realdirpath: (?string | Pathname base_dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - realpath(p1 = v1)
  # -->
  # Returns the real (absolute) pathname for `self` in the actual filesystem.
  #
  # Does not contain symlinks or useless dots, `..` and `.`.
  #
  # All components of the pathname must exist when this method is called.
  #
  def realpath: (?string | Pathname base_dir) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - relative?()
  # -->
  # The opposite of Pathname#absolute?
  #
  # It returns `false` if the pathname begins with a slash.
  #
  #     p = Pathname.new('/im/sure')
  #     p.relative?
  #         #=> false
  #
  #     p = Pathname.new('not/so/sure')
  #     p.relative?
  #         #=> true
  #
  def relative?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - relative_path_from(base_directory)
  # -->
  # Returns a relative path from the given `base_directory` to the receiver.
  #
  # If `self` is absolute, then `base_directory` must be absolute too.
  #
  # If `self` is relative, then `base_directory` must be relative too.
  #
  # This method doesn't access the filesystem.  It assumes no symlinks.
  #
  # ArgumentError is raised when it cannot find a relative path.
  #
  # Note that this method does not handle situations where the case sensitivity of
  # the filesystem in use differs from the operating system default.
  #
  def relative_path_from: (Pathname | string base_directory) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - rename(p1)
  # -->
  # Rename the file.
  #
  # See File.rename.
  #
  def rename: (Pathname | string new_name) -> 0

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - rmdir()
  # -->
  # Remove the referenced directory.
  #
  # See Dir.rmdir.
  #
  def rmdir: () -> 0

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - rmtree()
  # -->
  # Recursively deletes a directory, including all directories beneath it.
  #
  # See FileUtils.rm_r
  #
  def rmtree: () -> void

  # <!--
  #   rdoc-file=ext/pathname/lib/pathname.rb
  #   - root?()
  # -->
  # Predicate method for root directories.  Returns `true` if the pathname
  # consists of consecutive slashes.
  #
  # It doesn't access the filesystem.  So it may return `false` for some pathnames
  # which points to roots such as `/usr/..`.
  #
  def root?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - setgid?()
  # -->
  # See FileTest.setgid?.
  #
  def setgid?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - setuid?()
  # -->
  # See FileTest.setuid?.
  #
  def setuid?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - size()
  # -->
  # See FileTest.size.
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - size?()
  # -->
  # See FileTest.size?.
  #
  def size?: () -> Integer?

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - socket?()
  # -->
  # See FileTest.socket?.
  #
  def socket?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - split()
  # -->
  # Returns the #dirname and the #basename in an Array.
  #
  # See File.split.
  #
  def split: () -> [ Pathname, Pathname ]

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - stat()
  # -->
  # Returns a File::Stat object.
  #
  # See File.stat.
  #
  def stat: () -> File::Stat

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sticky?()
  # -->
  # See FileTest.sticky?.
  #
  def sticky?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sub(*args)
  # -->
  # Return a pathname which is substituted by String#sub.
  #
  #     path1 = Pathname.new('/usr/bin/perl')
  #     path1.sub('perl', 'ruby')
  #         #=> #<Pathname:/usr/bin/ruby>
  #
  def sub: (Regexp | string pattern, string | Hash[String, String] replacement) -> Pathname
         | (Regexp | string pattern) { (String match) -> string } -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - sub_ext(p1)
  # -->
  # Return a pathname with `repl` added as a suffix to the basename.
  #
  # If self has no extension part, `repl` is appended.
  #
  #     Pathname.new('/usr/bin/shutdown').sub_ext('.rb')
  #         #=> #<Pathname:/usr/bin/shutdown.rb>
  #
  def sub_ext: (string replacement) -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - symlink?()
  # -->
  # See FileTest.symlink?.
  #
  def symlink?: () -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.sysopen([mode, [perm]])  -> fixnum
  # -->
  # See IO.sysopen.
  #
  def sysopen: (?String mode, ?Integer perm) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.taint -> obj
  # -->
  # Returns pathname.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def taint: () -> Pathname

  # <!-- rdoc-file=ext/pathname/pathname.c -->
  # Return the path as a String.
  #
  # to_path is implemented so Pathname objects are usable with File.open, etc.
  #
  def to_path: () -> String

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.to_s             -> string
  #   - pathname.to_path          -> string
  # -->
  # Return the path as a String.
  #
  # to_path is implemented so Pathname objects are usable with File.open, etc.
  #
  alias to_s to_path

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - truncate(p1)
  # -->
  # Truncates the file to `length` bytes.
  #
  # See File.truncate.
  #
  def truncate: (Integer length) -> 0

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - unlink()
  # -->
  # Removes a file or directory, using File.unlink if `self` is a file, or
  # Dir.unlink as necessary.
  #
  def unlink: () -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.untaint -> obj
  # -->
  # Returns pathname.  This method is deprecated and will be removed in Ruby 3.2.
  #
  def untaint: () -> Pathname

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - utime(p1, p2)
  # -->
  # Update the access and modification times of the file.
  #
  # See File.utime.
  #
  def utime: (Integer | Time atime, Integer | Time mtime) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - world_readable?()
  # -->
  # See FileTest.world_readable?.
  #
  def world_readable?: () -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - world_writable?()
  # -->
  # See FileTest.world_writable?.
  #
  def world_writable?: () -> (Integer | nil)

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - writable?()
  # -->
  # See FileTest.writable?.
  #
  def writable?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - writable_real?()
  # -->
  # See FileTest.writable_real?.
  #
  def writable_real?: () -> bool

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - pathname.write(string, [offset] )   => fixnum
  #   - pathname.write(string, [offset], open_args )   => fixnum
  # -->
  # Writes `contents` to the file.
  #
  # See File.write.
  #
  def write: (String content, ?Integer offset, ?mode: Integer | String, ?flags: Integer, ?external_encoding: encoding, ?internal_encoding: encoding, ?encoding: encoding, ?textmode: boolish, ?binmode: boolish, ?autoclose: boolish) -> Integer

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - zero?()
  # -->
  # See FileTest.zero?.
  #
  def zero?: () -> bool

  private

  def add_trailing_separator: (untyped path) -> untyped

  def chop_basename: (untyped path) -> untyped

  def cleanpath_aggressive: () -> untyped

  def cleanpath_conservative: () -> untyped

  def del_trailing_separator: (untyped path) -> untyped

  def has_trailing_separator?: (untyped path) -> untyped

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - new(p1)
  # -->
  # Create a Pathname object from the given String (or String-like object). If
  # `path` contains a NULL character (`\0`), an ArgumentError is raised.
  #
  def initialize: (string | Pathname) -> void

  def plus: (untyped path1, untyped path2) -> untyped

  def prepend_prefix: (untyped prefix, untyped relpath) -> untyped

  def split_names: (untyped path) -> untyped

  SAME_PATHS: Proc

  SEPARATOR_LIST: String

  SEPARATOR_PAT: Regexp

  TO_PATH: Symbol
end

%a{annotate:rdoc:skip}
module Kernel
  private

  # <!--
  #   rdoc-file=ext/pathname/pathname.c
  #   - Pathname(path)  -> pathname
  # -->
  # Creates a new Pathname object from the given string, `path`, and returns
  # pathname object.
  #
  # In order to use this constructor, you must first require the Pathname standard
  # library extension.
  #
  #     require 'pathname'
  #     Pathname("/home/zzak")
  #     #=> #<Pathname:/home/zzak>
  #
  # See also Pathname::new for more information.
  #
  def self?.Pathname: (String | Pathname) -> Pathname
end

# <!-- rdoc-file=lib/cgi.rb -->
# ## Overview
#
# The Common Gateway Interface (CGI) is a simple protocol for passing an HTTP
# request from a web server to a standalone program, and returning the output to
# the web browser.  Basically, a CGI program is called with the parameters of
# the request passed in either in the environment (GET) or via $stdin (POST),
# and everything it prints to $stdout is returned to the client.
#
# This file holds the CGI class.  This class provides functionality for
# retrieving HTTP request parameters, managing cookies, and generating HTML
# output.
#
# The file CGI::Session provides session management functionality; see that
# class for more details.
#
# See http://www.w3.org/CGI/ for more information on the CGI protocol.
#
# ## Introduction
#
# CGI is a large class, providing several categories of methods, many of which
# are mixed in from other modules.  Some of the documentation is in this class,
# some in the modules CGI::QueryExtension and CGI::HtmlExtension.  See
# CGI::Cookie for specific information on handling cookies, and cgi/session.rb
# (CGI::Session) for information on sessions.
#
# For queries, CGI provides methods to get at environmental variables,
# parameters, cookies, and multipart request data.  For responses, CGI provides
# methods for writing output and generating HTML.
#
# Read on for more details.  Examples are provided at the bottom.
#
# ## Queries
#
# The CGI class dynamically mixes in parameter and cookie-parsing functionality,
#  environmental variable access, and support for parsing multipart requests
# (including uploaded files) from the CGI::QueryExtension module.
#
# ### Environmental Variables
#
# The standard CGI environmental variables are available as read-only attributes
# of a CGI object.  The following is a list of these variables:
#
#     AUTH_TYPE               HTTP_HOST          REMOTE_IDENT
#     CONTENT_LENGTH          HTTP_NEGOTIATE     REMOTE_USER
#     CONTENT_TYPE            HTTP_PRAGMA        REQUEST_METHOD
#     GATEWAY_INTERFACE       HTTP_REFERER       SCRIPT_NAME
#     HTTP_ACCEPT             HTTP_USER_AGENT    SERVER_NAME
#     HTTP_ACCEPT_CHARSET     PATH_INFO          SERVER_PORT
#     HTTP_ACCEPT_ENCODING    PATH_TRANSLATED    SERVER_PROTOCOL
#     HTTP_ACCEPT_LANGUAGE    QUERY_STRING       SERVER_SOFTWARE
#     HTTP_CACHE_CONTROL      REMOTE_ADDR
#     HTTP_FROM               REMOTE_HOST
#
# For each of these variables, there is a corresponding attribute with the same
# name, except all lower case and without a preceding HTTP_. `content_length`
# and `server_port` are integers; the rest are strings.
#
# ### Parameters
#
# The method #params() returns a hash of all parameters in the request as
# name/value-list pairs, where the value-list is an Array of one or more values.
#  The CGI object itself also behaves as a hash of parameter names to values,
# but only returns a single value (as a String) for each parameter name.
#
# For instance, suppose the request contains the parameter "favourite_colours"
# with the multiple values "blue" and "green".  The following behavior would
# occur:
#
#     cgi.params["favourite_colours"]  # => ["blue", "green"]
#     cgi["favourite_colours"]         # => "blue"
#
# If a parameter does not exist, the former method will return an empty array,
# the latter an empty string.  The simplest way to test for existence of a
# parameter is by the #has_key? method.
#
# ### Cookies
#
# HTTP Cookies are automatically parsed from the request.  They are available
# from the #cookies() accessor, which returns a hash from cookie name to
# CGI::Cookie object.
#
# ### Multipart requests
#
# If a request's method is POST and its content type is multipart/form-data,
# then it may contain uploaded files.  These are stored by the QueryExtension
# module in the parameters of the request.  The parameter name is the name
# attribute of the file input field, as usual.  However, the value is not a
# string, but an IO object, either an IOString for small files, or a Tempfile
# for larger ones.  This object also has the additional singleton methods:
#
# #local_path()
# :   the path of the uploaded file on the local filesystem
# #original_filename()
# :   the name of the file on the client computer
# #content_type()
# :   the content type of the file
#
#
# ## Responses
#
# The CGI class provides methods for sending header and content output to the
# HTTP client, and mixes in methods for programmatic HTML generation from
# CGI::HtmlExtension and CGI::TagMaker modules.  The precise version of HTML to
# use for HTML generation is specified at object creation time.
#
# ### Writing output
#
# The simplest way to send output to the HTTP client is using the #out() method.
# This takes the HTTP headers as a hash parameter, and the body content via a
# block.  The headers can be generated as a string using the #http_header()
# method.  The output stream can be written directly to using the #print()
# method.
#
# ### Generating HTML
#
# Each HTML element has a corresponding method for generating that element as a
# String.  The name of this method is the same as that of the element, all
# lowercase.  The attributes of the element are passed in as a hash, and the
# body as a no-argument block that evaluates to a String.  The HTML generation
# module knows which elements are always empty, and silently drops any passed-in
# body.  It also knows which elements require matching closing tags and which
# don't.  However, it does not know what attributes are legal for which
# elements.
#
# There are also some additional HTML generation methods mixed in from the
# CGI::HtmlExtension module.  These include individual methods for the different
# types of form inputs, and methods for elements that commonly take particular
# attributes where the attributes can be directly specified as arguments, rather
# than via a hash.
#
# ### Utility HTML escape and other methods like a function.
#
# There are some utility tool defined in cgi/util.rb . And when include, you can
# use utility methods like a function.
#
# ## Examples of use
#
# ### Get form values
#
#     require "cgi"
#     cgi = CGI.new
#     value = cgi['field_name']   # <== value string for 'field_name'
#       # if not 'field_name' included, then return "".
#     fields = cgi.keys            # <== array of field names
#
#     # returns true if form has 'field_name'
#     cgi.has_key?('field_name')
#     cgi.has_key?('field_name')
#     cgi.include?('field_name')
#
# CAUTION! [cgi]('field_name') returned an Array with the old cgi.rb(included in
# Ruby 1.6)
#
# ### Get form values as hash
#
#     require "cgi"
#     cgi = CGI.new
#     params = cgi.params
#
# cgi.params is a hash.
#
#     cgi.params['new_field_name'] = ["value"]  # add new param
#     cgi.params['field_name'] = ["new_value"]  # change value
#     cgi.params.delete('field_name')           # delete param
#     cgi.params.clear                          # delete all params
#
# ### Save form values to file
#
#     require "pstore"
#     db = PStore.new("query.db")
#     db.transaction do
#       db["params"] = cgi.params
#     end
#
# ### Restore form values from file
#
#     require "pstore"
#     db = PStore.new("query.db")
#     db.transaction do
#       cgi.params = db["params"]
#     end
#
# ### Get multipart form values
#
#     require "cgi"
#     cgi = CGI.new
#     value = cgi['field_name']   # <== value string for 'field_name'
#     value.read                  # <== body of value
#     value.local_path            # <== path to local file of value
#     value.original_filename     # <== original filename of value
#     value.content_type          # <== content_type of value
#
# and value has StringIO or Tempfile class methods.
#
# ### Get cookie values
#
#     require "cgi"
#     cgi = CGI.new
#     values = cgi.cookies['name']  # <== array of 'name'
#       # if not 'name' included, then return [].
#     names = cgi.cookies.keys      # <== array of cookie names
#
# and cgi.cookies is a hash.
#
# ### Get cookie objects
#
#     require "cgi"
#     cgi = CGI.new
#     for name, cookie in cgi.cookies
#       cookie.expires = Time.now + 30
#     end
#     cgi.out("cookie" => cgi.cookies) {"string"}
#
#     cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }
#
#     require "cgi"
#     cgi = CGI.new
#     cgi.cookies['name'].expires = Time.now + 30
#     cgi.out("cookie" => cgi.cookies['name']) {"string"}
#
# ### Print http header and html string to $DEFAULT_OUTPUT ($>)
#
#     require "cgi"
#     cgi = CGI.new("html4")  # add HTML generation methods
#     cgi.out do
#       cgi.html do
#         cgi.head do
#           cgi.title { "TITLE" }
#         end +
#         cgi.body do
#           cgi.form("ACTION" => "uri") do
#             cgi.p do
#               cgi.textarea("get_text") +
#               cgi.br +
#               cgi.submit
#             end
#           end +
#           cgi.pre do
#             CGI.escapeHTML(
#               "params: #{cgi.params.inspect}\n" +
#               "cookies: #{cgi.cookies.inspect}\n" +
#               ENV.collect do |key, value|
#                 "#{key} --> #{value}\n"
#               end.join("")
#             )
#           end
#         end
#       end
#     end
#
#     # add HTML generation methods
#     CGI.new("html3")    # html3.2
#     CGI.new("html4")    # html4.01 (Strict)
#     CGI.new("html4Tr")  # html4.01 Transitional
#     CGI.new("html4Fr")  # html4.01 Frameset
#     CGI.new("html5")    # html5
#
# ### Some utility methods
#
#     require 'cgi/util'
#     CGI.escapeHTML('Usage: foo "bar" <baz>')
#
# ### Some utility methods like a function
#
#     require 'cgi/util'
#     include CGI::Util
#     escapeHTML('Usage: foo "bar" <baz>')
#     h('Usage: foo "bar" <baz>') # alias
#
class CGI
  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - CGI.new(tag_maker) { block }
  #   - CGI.new(options_hash = {}) { block }
  # -->
  # Create a new CGI instance.
  #
  # `tag_maker`
  # :   This is the same as using the `options_hash` form with the value `{
  #     :tag_maker => tag_maker }` Note that it is recommended to use the
  #     `options_hash` form, since it also allows you specify the charset you will
  #     accept.
  # `options_hash`
  # :   A Hash that recognizes three options:
  #
  #     `:accept_charset`
  # :       specifies encoding of received query string.  If omitted,
  #         `@@accept_charset` is used.  If the encoding is not valid, a
  #         CGI::InvalidEncoding will be raised.
  #
  #         Example. Suppose `@@accept_charset` is "UTF-8"
  #
  #         when not specified:
  #
  #             cgi=CGI.new      # @accept_charset # => "UTF-8"
  #
  #         when specified as "EUC-JP":
  #
  #             cgi=CGI.new(:accept_charset => "EUC-JP") # => "EUC-JP"
  #
  #     `:tag_maker`
  # :       String that specifies which version of the HTML generation methods to
  #         use.  If not specified, no HTML generation methods will be loaded.
  #
  #         The following values are supported:
  #
  #         "html3"
  # :           HTML 3.x
  #         "html4"
  # :           HTML 4.0
  #         "html4Tr"
  # :           HTML 4.0 Transitional
  #         "html4Fr"
  # :           HTML 4.0 with Framesets
  #         "html5"
  # :           HTML 5
  #
  #
  #     `:max_multipart_length`
  # :       Specifies maximum length of multipart data. Can be an Integer scalar
  #         or a lambda, that will be evaluated when the request is parsed. This
  #         allows more complex logic to be set when determining whether to accept
  #         multipart data (e.g. consult a registered users upload allowance)
  #
  #         Default is 128 * 1024 * 1024 bytes
  #
  #             cgi=CGI.new(:max_multipart_length => 268435456) # simple scalar
  #
  #             cgi=CGI.new(:max_multipart_length => -> {check_filesystem}) # lambda
  #
  #
  # `block`
  # :   If provided, the block is called when an invalid encoding is encountered.
  #     For example:
  #
  #         encoding_errors={}
  #         cgi=CGI.new(:accept_charset=>"EUC-JP") do |name,value|
  #           encoding_errors[name] = value
  #         end
  #
  #
  # Finally, if the CGI object is not created in a standard CGI call environment
  # (that is, it can't locate REQUEST_METHOD in its environment), then it will run
  # in "offline" mode.  In this mode, it reads its parameters from the command
  # line or (failing that) from standard input.  Otherwise, cookies and other
  # parameters are parsed automatically from the standard CGI locations, which
  # varies according to the REQUEST_METHOD.
  #
  def initialize: (?String tag_maker) ?{ (String name, String value) -> void } -> void
                | (Hash[Symbol, untyped] options_hash) ?{ (String name, String value) -> void } -> void

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # Return the accept character set for this CGI instance.
  #
  attr_reader accept_charset: String

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - accept_charset()
  # -->
  # Return the accept character set for all new CGI instances.
  #
  def self.accept_charset: () -> String

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - accept_charset=(accept_charset)
  # -->
  # Set the accept character set for all new CGI instances.
  #
  def self.accept_charset=: (String accept_charset) -> String

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - parse(query)
  # -->
  # Parse an HTTP query string into a hash of key=>value pairs.
  #
  #     params = CGI.parse("query_string")
  #       # {"name1" => ["value1", "value2", ...],
  #       #  "name2" => ["value1", "value2", ...], ... }
  #
  def self.parse: (String query) -> Hash[String, String | Array[String]]

  public

  # <!-- rdoc-file=lib/cgi/core.rb -->
  # This method is an alias for #http_header, when HTML5 tag maker is inactive.
  #
  # NOTE: use #http_header to create HTTP header blocks, this alias is only
  # provided for backwards compatibility.
  #
  # Using #header with the HTML5 tag maker will create a <header> element.
  #
  alias header http_header

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - http_header(content_type_string="text/html")
  #   - http_header(headers_hash)
  # -->
  # Create an HTTP header block as a string.
  #
  # Includes the empty line that ends the header block.
  #
  # `content_type_string`
  # :   If this form is used, this string is the `Content-Type`
  # `headers_hash`
  # :   A Hash of header values. The following header keys are recognized:
  #
  #     type
  # :       The Content-Type header.  Defaults to "text/html"
  #     charset
  # :       The charset of the body, appended to the Content-Type header.
  #     nph
  # :       A boolean value.  If true, prepend protocol string and status code,
  #         and date; and sets default values for "server" and "connection" if not
  #         explicitly set.
  #     status
  # :       The HTTP status code as a String, returned as the Status header.  The
  #         values are:
  #
  #         OK
  # :           200 OK
  #         PARTIAL_CONTENT
  # :           206 Partial Content
  #         MULTIPLE_CHOICES
  # :           300 Multiple Choices
  #         MOVED
  # :           301 Moved Permanently
  #         REDIRECT
  # :           302 Found
  #         NOT_MODIFIED
  # :           304 Not Modified
  #         BAD_REQUEST
  # :           400 Bad Request
  #         AUTH_REQUIRED
  # :           401 Authorization Required
  #         FORBIDDEN
  # :           403 Forbidden
  #         NOT_FOUND
  # :           404 Not Found
  #         METHOD_NOT_ALLOWED
  # :           405 Method Not Allowed
  #         NOT_ACCEPTABLE
  # :           406 Not Acceptable
  #         LENGTH_REQUIRED
  # :           411 Length Required
  #         PRECONDITION_FAILED
  # :           412 Precondition Failed
  #         SERVER_ERROR
  # :           500 Internal Server Error
  #         NOT_IMPLEMENTED
  # :           501 Method Not Implemented
  #         BAD_GATEWAY
  # :           502 Bad Gateway
  #         VARIANT_ALSO_VARIES
  # :           506 Variant Also Negotiates
  #
  #
  #     server
  # :       The server software, returned as the Server header.
  #     connection
  # :       The connection type, returned as the Connection header (for instance,
  #         "close".
  #     length
  # :       The length of the content that will be sent, returned as the
  #         Content-Length header.
  #     language
  # :       The language of the content, returned as the Content-Language header.
  #     expires
  # :       The time on which the current content expires, as a `Time` object,
  #         returned as the Expires header.
  #     cookie
  # :       A cookie or cookies, returned as one or more Set-Cookie headers.  The
  #         value can be the literal string of the cookie; a CGI::Cookie object;
  #         an Array of literal cookie strings or Cookie objects; or a hash all of
  #         whose values are literal cookie strings or Cookie objects.
  #
  #         These cookies are in addition to the cookies held in the
  #         @output_cookies field.
  #
  #
  #     Other headers can also be set; they are appended as key: value.
  #
  #
  # Examples:
  #
  #     http_header
  #       # Content-Type: text/html
  #
  #     http_header("text/plain")
  #       # Content-Type: text/plain
  #
  #     http_header("nph"        => true,
  #                 "status"     => "OK",  # == "200 OK"
  #                   # "status"     => "200 GOOD",
  #                 "server"     => ENV['SERVER_SOFTWARE'],
  #                 "connection" => "close",
  #                 "type"       => "text/html",
  #                 "charset"    => "iso-2022-jp",
  #                   # Content-Type: text/html; charset=iso-2022-jp
  #                 "length"     => 103,
  #                 "language"   => "ja",
  #                 "expires"    => Time.now + 30,
  #                 "cookie"     => [cookie1, cookie2],
  #                 "my_header1" => "my_value",
  #                 "my_header2" => "my_value")
  #
  # This method does not perform charset conversion.
  #
  def http_header: (?String options) -> String
                 | (?Hash[String | Symbol, untyped] header_hash) -> String

  def nph?: () -> boolish

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - cgi.out(content_type_string='text/html')
  #   - cgi.out(headers_hash)
  # -->
  # Print an HTTP header and body to $DEFAULT_OUTPUT ($>)
  #
  # `content_type_string`
  # :   If a string is passed, it is assumed to be the content type.
  # `headers_hash`
  # :   This is a Hash of headers, similar to that used by #http_header.
  # `block`
  # :   A block is required and should evaluate to the body of the response.
  #
  #
  # `Content-Length` is automatically calculated from the size of the String
  # returned by the content block.
  #
  # If `ENV['REQUEST_METHOD'] == "HEAD"`, then only the header is output (the
  # content block is still required, but it is ignored).
  #
  # If the charset is "iso-2022-jp" or "euc-jp" or "shift_jis" then the content is
  # converted to this charset, and the language is set to "ja".
  #
  # Example:
  #
  #     cgi = CGI.new
  #     cgi.out{ "string" }
  #       # Content-Type: text/html
  #       # Content-Length: 6
  #       #
  #       # string
  #
  #     cgi.out("text/plain") { "string" }
  #       # Content-Type: text/plain
  #       # Content-Length: 6
  #       #
  #       # string
  #
  #     cgi.out("nph"        => true,
  #             "status"     => "OK",  # == "200 OK"
  #             "server"     => ENV['SERVER_SOFTWARE'],
  #             "connection" => "close",
  #             "type"       => "text/html",
  #             "charset"    => "iso-2022-jp",
  #               # Content-Type: text/html; charset=iso-2022-jp
  #             "language"   => "ja",
  #             "expires"    => Time.now + (3600 * 24 * 30),
  #             "cookie"     => [cookie1, cookie2],
  #             "my_header1" => "my_value",
  #             "my_header2" => "my_value") { "string" }
  #        # HTTP/1.1 200 OK
  #        # Date: Sun, 15 May 2011 17:35:54 GMT
  #        # Server: Apache 2.2.0
  #        # Connection: close
  #        # Content-Type: text/html; charset=iso-2022-jp
  #        # Content-Length: 6
  #        # Content-Language: ja
  #        # Expires: Tue, 14 Jun 2011 17:35:54 GMT
  #        # Set-Cookie: foo
  #        # Set-Cookie: bar
  #        # my_header1: my_value
  #        # my_header2: my_value
  #        #
  #        # string
  #
  def out: (?String content_type_string) { () -> String } -> void
         | (Hash[String | Symbol, untyped] headers_hash) { () -> String } -> void

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - print(*options)
  # -->
  # Print an argument or list of arguments to the default output stream
  #
  #     cgi = CGI.new
  #     cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
  #
  def print: (*String options) -> void

  private

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - stdinput()
  # -->
  # Synonym for $stdin.
  #
  def stdinput: () -> ::IO

  # <!--
  #   rdoc-file=lib/cgi/core.rb
  #   - stdoutput()
  # -->
  # Synonym for $stdout.
  #
  def stdoutput: () -> ::IO
end

# <!-- rdoc-file=lib/cgi/core.rb -->
# String for carriage return
#
CGI::CR: String

# <!-- rdoc-file=lib/cgi/core.rb -->
# Standard internet newline sequence
#
CGI::EOL: String

# <!-- rdoc-file=lib/cgi/core.rb -->
# HTTP status codes.
#
CGI::HTTP_STATUS: Hash[String, String]

# <!-- rdoc-file=lib/cgi/core.rb -->
# String for linefeed
#
CGI::LF: String

# <!-- rdoc-file=lib/cgi/core.rb -->
# Maximum number of request parameters when multipart
#
CGI::MAX_MULTIPART_COUNT: Integer

# <!-- rdoc-file=lib/cgi/core.rb -->
# Whether processing will be required in binary vs text
#
CGI::NEEDS_BINMODE: bool

# <!-- rdoc-file=lib/cgi/core.rb -->
# Path separators in different environments.
#
CGI::PATH_SEPARATOR: Hash[String, String]

CGI::REVISION: String

CGI::VERSION: String

# <!-- rdoc-file=ext/pty/pty.c -->
# Creates and manages pseudo terminals (PTYs).  See also
# https://en.wikipedia.org/wiki/Pseudo_terminal
#
# PTY allows you to allocate new terminals using ::open or ::spawn a new
# terminal with a specific command.
#
# ## Example
#
# In this example we will change the buffering type in the `factor` command,
# assuming that factor uses stdio for stdout buffering.
#
# If IO.pipe is used instead of PTY.open, this code deadlocks because factor's
# stdout is fully buffered.
#
#     # start by requiring the standard library PTY
#     require 'pty'
#
#     master, slave = PTY.open
#     read, write = IO.pipe
#     pid = spawn("factor", :in=>read, :out=>slave)
#     read.close     # we dont need the read
#     slave.close    # or the slave
#
#     # pipe "42" to the factor command
#     write.puts "42"
#     # output the response from factor
#     p master.gets #=> "42: 2 3 7\n"
#
#     # pipe "144" to factor and print out the response
#     write.puts "144"
#     p master.gets #=> "144: 2 2 2 2 3 3\n"
#     write.close # close the pipe
#
#     # The result of read operation when pty slave is closed is platform
#     # dependent.
#     ret = begin
#             master.gets     # FreeBSD returns nil.
#           rescue Errno::EIO # GNU/Linux raises EIO.
#             nil
#           end
#     p ret #=> nil
#
# ## License
#
# (c) Copyright 1998 by Akinori Ito.
#
# This software may be redistributed freely for this purpose, in full or in
# part, provided that this entire copyright notice is included on any copies of
# this software and applications and derivations thereof.
#
# This software is provided on an "as is" basis, without warranty of any kind,
# either expressed or implied, as to any matter including, but not limited to
# warranty of fitness of purpose, or merchantability, or results obtained from
# use of this software.
#
module PTY
  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.check(pid, raise = false) => Process::Status or nil
  #   - PTY.check(pid, true)          => nil or raises PTY::ChildExited
  # -->
  # Checks the status of the child process specified by `pid`. Returns `nil` if
  # the process is still alive.
  #
  # If the process is not alive, and `raise` was true, a PTY::ChildExited
  # exception will be raised. Otherwise it will return a Process::Status instance.
  #
  # `pid`
  # :   The process id of the process to check
  # `raise`
  # :   If `true` and the process identified by `pid` is no longer alive a
  #     PTY::ChildExited is raised.
  #
  def self.check: (Integer pid, ?boolish raise) -> Process::Status?

  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.spawn(command_line)  { |r, w, pid| ... }
  #   - PTY.spawn(command_line)  => [r, w, pid]
  #   - PTY.spawn(command, arguments, ...)  { |r, w, pid| ... }
  #   - PTY.spawn(command, arguments, ...)  => [r, w, pid]
  # -->
  # Spawns the specified command on a newly allocated pty. You can also use the
  # alias ::getpty.
  #
  # The command's controlling tty is set to the slave device of the pty and its
  # standard input/output/error is redirected to the slave device.
  #
  # `command` and `command_line` are the full commands to run, given a String. Any
  # additional `arguments` will be passed to the command.
  #
  # ### Return values
  #
  # In the non-block form this returns an array of size three, `[r, w, pid]`.
  #
  # In the block form these same values will be yielded to the block:
  #
  # `r`
  # :   A readable IO that contains the command's standard output and standard
  #     error
  # `w`
  # :   A writable IO that is the command's standard input
  # `pid`
  # :   The process identifier for the command.
  #
  alias self.getpty self.spawn

  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.open => [master_io, slave_file]
  #   - PTY.open {|(master_io, slave_file)| ... } => block value
  # -->
  # Allocates a pty (pseudo-terminal).
  #
  # In the block form, yields an array of two elements (`master_io, slave_file`)
  # and the value of the block is returned from `open`.
  #
  # The IO and File are both closed after the block completes if they haven't been
  # already closed.
  #
  #     PTY.open {|master, slave|
  #       p master      #=> #<IO:masterpty:/dev/pts/1>
  #       p slave      #=> #<File:/dev/pts/1>
  #       p slave.path #=> "/dev/pts/1"
  #     }
  #
  # In the non-block form, returns a two element array, `[master_io, slave_file]`.
  #
  #     master, slave = PTY.open
  #     # do something with master for IO, or the slave file
  #
  # The arguments in both forms are:
  #
  # `master_io`
  # :   the master of the pty, as an IO.
  # `slave_file`
  # :   the slave of the pty, as a File.  The path to the terminal device is
  #     available via `slave_file.path`
  #
  #
  # IO#raw! is usable to disable newline conversions:
  #
  #     require 'io/console'
  #     PTY.open {|m, s|
  #       s.raw!
  #       # ...
  #     }
  #
  def self.open: () -> [ IO, File ]
               | [A] () { ([ IO, File ]) -> A } -> A

  # <!--
  #   rdoc-file=ext/pty/pty.c
  #   - PTY.spawn(command_line)  { |r, w, pid| ... }
  #   - PTY.spawn(command_line)  => [r, w, pid]
  #   - PTY.spawn(command, arguments, ...)  { |r, w, pid| ... }
  #   - PTY.spawn(command, arguments, ...)  => [r, w, pid]
  # -->
  # Spawns the specified command on a newly allocated pty. You can also use the
  # alias ::getpty.
  #
  # The command's controlling tty is set to the slave device of the pty and its
  # standard input/output/error is redirected to the slave device.
  #
  # `command` and `command_line` are the full commands to run, given a String. Any
  # additional `arguments` will be passed to the command.
  #
  # ### Return values
  #
  # In the non-block form this returns an array of size three, `[r, w, pid]`.
  #
  # In the block form these same values will be yielded to the block:
  #
  # `r`
  # :   A readable IO that contains the command's standard output and standard
  #     error
  # `w`
  # :   A writable IO that is the command's standard input
  # `pid`
  # :   The process identifier for the command.
  #
  def self.spawn: (*String command) -> [ IO, IO, Integer ]
                | (*String command) { ([ IO, IO, Integer ]) -> void } -> void
end

# <!-- rdoc-file=ext/dbm/dbm.c -->
# ## Introduction
#
# The DBM class provides a wrapper to a Unix-style
# [dbm](https://en.wikipedia.org/wiki/Dbm) or Database Manager library.
#
# Dbm databases do not have tables or columns; they are simple key-value data
# stores, like a Ruby Hash except not resident in RAM. Keys and values must be
# strings.
#
# The exact library used depends on how Ruby was compiled. It could be any of
# the following:
#
# *   The original ndbm library is released in 4.3BSD. It is based on dbm
#     library in Unix Version 7 but has different API to support multiple
#     databases in a process.
# *   [Berkeley DB](https://en.wikipedia.org/wiki/Berkeley_DB) versions 1 thru
#     6, also known as BDB and Sleepycat DB, now owned by Oracle Corporation.
# *   Berkeley DB 1.x, still found in 4.4BSD derivatives (FreeBSD, OpenBSD,
#     etc).
# *   [gdbm](http://www.gnu.org/software/gdbm/), the GNU implementation of dbm.
# *   [qdbm](http://fallabs.com/qdbm/index.html), another open source
#     reimplementation of dbm.
#
#
# All of these dbm implementations have their own Ruby interfaces available,
# which provide richer (but varying) APIs.
#
# ## Cautions
#
# Before you decide to use DBM, there are some issues you should consider:
#
# *   Each implementation of dbm has its own file format. Generally, dbm
#     libraries will not read each other's files. This makes dbm files a bad
#     choice for data exchange.
#
# *   Even running the same OS and the same dbm implementation, the database
#     file format may depend on the CPU architecture. For example, files may not
#     be portable between PowerPC and 386, or between 32 and 64 bit Linux.
#
# *   Different versions of Berkeley DB use different file formats. A change to
#     the OS may therefore break DBM access to existing files.
#
# *   Data size limits vary between implementations. Original Berkeley DB was
#     limited to 2GB of data. Dbm libraries also sometimes limit the total size
#     of a key/value pair, and the total size of all the keys that hash to the
#     same value. These limits can be as little as 512 bytes. That said, gdbm
#     and recent versions of Berkeley DB do away with these limits.
#
#
# Given the above cautions, DBM is not a good choice for long term storage of
# important data. It is probably best used as a fast and easy alternative to a
# Hash for processing large amounts of data.
#
# ## Example
#
#     require 'dbm'
#     db = DBM.open('rfcs', 0666, DBM::WRCREAT)
#     db['822'] = 'Standard for the Format of ARPA Internet Text Messages'
#     db['1123'] = 'Requirements for Internet Hosts - Application and Support'
#     db['3068'] = 'An Anycast Prefix for 6to4 Relay Routers'
#     puts db['822']
#
class DBM
  include Enumerable[[ String, String ]]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - DBM.open(filename[, mode[, flags]]) -> dbm
  #   - DBM.open(filename[, mode[, flags]]) {|dbm| block}
  # -->
  # Open a dbm database and yields it if a block is given. See also `DBM.new`.
  #
  def self.open: (String filename, ?Integer mode, ?Integer flags) -> DBM
               | [T] (String filename, ?Integer mode, ?Integer flags) { (DBM) -> T } -> T

  public

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm[key] -> string value or nil
  # -->
  # Return a value from the database by locating the key string provided.  If the
  # key is not found, returns nil.
  #
  def []: (String) -> String?

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.store(key, value) -> value
  #   - dbm[key] = value
  # -->
  # Stores the specified string value in the database, indexed via the string key
  # provided.
  #
  def []=: (String, String) -> String

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.clear
  # -->
  # Deletes all data from the database.
  #
  def clear: () -> self

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.close
  # -->
  # Closes the database.
  #
  def close: () -> void

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.closed? -> true or false
  # -->
  # Returns true if the database is closed, false otherwise.
  #
  def closed?: () -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.delete(key)
  # -->
  # Deletes an entry from the database.
  #
  def delete: (String) -> void

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.reject! {|key, value| block} -> self
  #   - dbm.delete_if {|key, value| block} -> self
  # -->
  # Deletes all entries for which the code block returns true. Returns self.
  #
  def delete_if: () { (String) -> boolish } -> self

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.each_pair {|key,value| block} -> self
  # -->
  # Calls the block once for each [key, value] pair in the database. Returns self.
  #
  def each: () { ([ String, String ]) -> void } -> self
          | () -> Enumerator[[ String, String ], self]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.each_key {|key| block} -> self
  # -->
  # Calls the block once for each key string in the database. Returns self.
  #
  def each_key: () { (String) -> void } -> self
              | () -> Enumerator[String, self]

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Calls the block once for each [key, value] pair in the database. Returns self.
  #
  def each_pair: () { ([ String, String ]) -> void } -> self
               | () -> Enumerator[[ String, String ], self]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.each_value {|value| block} -> self
  # -->
  # Calls the block once for each value string in the database. Returns self.
  #
  def each_value: () { (String) -> void } -> self
                | () -> Enumerator[String, self]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.empty?
  # -->
  # Returns true if the database is empty, false otherwise.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.fetch(key[, ifnone]) -> value
  # -->
  # Return a value from the database by locating the key string provided.  If the
  # key is not found, returns `ifnone`. If `ifnone` is not given, raises
  # IndexError.
  #
  def fetch: (String key, ?String ifnone) -> String

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Returns true if the database contains the specified key, false otherwise.
  #
  def has_key?: (String) -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.has_value?(value) -> boolean
  #   - dbm.value?(value) -> boolean
  # -->
  # Returns true if the database contains the specified string value, false
  # otherwise.
  #
  def has_value?: () -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.include?(key) -> boolean
  #   - dbm.has_key?(key) -> boolean
  #   - dbm.member?(key) -> boolean
  #   - dbm.key?(key) -> boolean
  # -->
  # Returns true if the database contains the specified key, false otherwise.
  #
  def include?: (String) -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.invert -> hash
  # -->
  # Returns a Hash (not a DBM database) created by using each value in the
  # database as a key, with the corresponding key as its value.
  #
  def invert: () -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.key(value) -> string
  # -->
  # Returns the key for the specified value.
  #
  def key: (String) -> String?

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Returns true if the database contains the specified key, false otherwise.
  #
  def key?: (String) -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.keys -> array
  # -->
  # Returns an array of all the string keys in the database.
  #
  def keys: () -> Array[String]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.length -> integer
  #   - dbm.size -> integer
  # -->
  # Returns the number of entries in the database.
  #
  def length: () -> Integer

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Returns true if the database contains the specified key, false otherwise.
  #
  def member?: (String) -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.reject {|key,value| block} -> Hash
  # -->
  # Converts the contents of the database to an in-memory Hash, then calls
  # Hash#reject with the specified code block, returning a new Hash.
  #
  def reject: () { (String, String) -> boolish } -> Hash[String, String]

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Deletes all entries for which the code block returns true. Returns self.
  #
  def reject!: () { (String, String) -> boolish } -> self

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.replace(obj)
  # -->
  # Replaces the contents of the database with the contents of the specified
  # object. Takes any object which implements the each_pair method, including Hash
  # and DBM objects.
  #
  def replace: (_ReplaceSource) -> ::DBM

  interface _ReplaceSource
    def each_pair: () { ([ String, String ]) -> void } -> void
  end

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.select {|key, value| block} -> array
  # -->
  # Returns a new array consisting of the [key, value] pairs for which the code
  # block returns true.
  #
  def select: () { ([ String, String ]) -> boolish } -> Array[[ String, String ]]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.shift() -> [key, value]
  # -->
  # Removes a [key, value] pair from the database, and returns it. If the database
  # is empty, returns nil. The order in which values are removed/returned is not
  # guaranteed.
  #
  def shift: () -> [ String, String ]?

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Returns the number of entries in the database.
  #
  def size: () -> Integer

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Stores the specified string value in the database, indexed via the string key
  # provided.
  #
  def store: (String, String) -> String

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.to_a -> array
  # -->
  # Converts the contents of the database to an array of [key, value] arrays, and
  # returns it.
  #
  def to_a: () -> Array[[ String, String ]]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.to_hash -> hash
  # -->
  # Converts the contents of the database to an in-memory Hash object, and returns
  # it.
  #
  def to_hash: () -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.update(obj)
  # -->
  # Updates the database with multiple values from the specified object. Takes any
  # object which implements the each_pair method, including Hash and DBM objects.
  #
  def update: (_UpdateSource) -> ::DBM

  interface _UpdateSource
    def each_pair: () { ([ String, String ]) -> void } -> void
  end

  # <!-- rdoc-file=ext/dbm/dbm.c -->
  # Returns true if the database contains the specified string value, false
  # otherwise.
  #
  def value?: (String) -> bool

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.values -> array
  # -->
  # Returns an array of all the string values in the database.
  #
  def values: () -> Array[String]

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - dbm.values_at(key, ...) -> Array
  # -->
  # Returns an array containing the values associated with the given keys.
  #
  def values_at: (*String) -> Array[String]

  private

  # <!--
  #   rdoc-file=ext/dbm/dbm.c
  #   - DBM.new(filename[, mode[, flags]]) -> dbm
  # -->
  # Open a dbm database with the specified name, which can include a directory
  # path. Any file extensions needed will be supplied automatically by the dbm
  # library. For example, Berkeley DB appends '.db', and GNU gdbm uses two
  # physical files with extensions '.dir' and '.pag'.
  #
  # The mode should be an integer, as for Unix chmod.
  #
  # Flags should be one of READER, WRITER, WRCREAT or NEWDB.
  #
  def initialize: (String filename, ?Integer mode, ?Integer flags) -> void
end

# <!-- rdoc-file=ext/dbm/dbm.c -->
# Indicates that dbm_open() should open the database in read/write mode, create
# it if it does not already exist, and delete all contents if it does already
# exist.
#
DBM::NEWDB: Integer

# <!-- rdoc-file=ext/dbm/dbm.c -->
# Indicates that dbm_open() should open the database in read-only mode
#
DBM::READER: Integer

# <!-- rdoc-file=ext/dbm/dbm.c -->
# Identifies ndbm library version.
#
# Examples:
#
# *   "ndbm (4.3BSD)"
# *   "Berkeley DB 4.8.30: (April  9, 2010)"
# *   "Berkeley DB (unknown)" (4.4BSD, maybe)
# *   "GDBM version 1.8.3. 10/15/2002 (built Jul  1 2011 12:32:45)"
# *   "QDBM 1.8.78"
#
DBM::VERSION: String

# <!-- rdoc-file=ext/dbm/dbm.c -->
# Indicates that dbm_open() should open the database in read/write mode, and
# create it if it does not already exist
#
DBM::WRCREAT: Integer

# <!-- rdoc-file=ext/dbm/dbm.c -->
# Indicates that dbm_open() should open the database in read/write mode
#
DBM::WRITER: Integer

interface _ToJson
  def to_json: (?JSON::State state) -> String
end

interface _JsonToWritableIO
  def to_io: () -> _JsonWrite
end

interface _JsonWrite
  def write: (String json) -> void
end

interface _JsonReadableIO
  def to_io: () -> _JsonRead
end

interface _JsonRead
  def read: () -> string
end

type json_options = Hash[Symbol, untyped]

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# The base exception for JSON errors.
#
class JSON::JSONError < StandardError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if a generator or unparser error occurs.
#
class JSON::GeneratorError < JSON::JSONError
end

class JSON::UnparserError < JSON::GeneratorError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if a parser error occurs.
#
class JSON::ParserError < JSON::JSONError
end

# <!-- rdoc-file=ext/json/lib/json/common.rb -->
# This exception is raised if the nesting of parsed data structures is too deep.
#
class JSON::NestingError < JSON::ParserError
end

class JSON::State
end

# <!-- rdoc-file=ext/json/lib/json/ext.rb -->
# This module holds all the modules/classes that implement JSON's functionality
# as C extensions.
#
module JSON::Ext
end

# <!-- rdoc-file=ext/json/generator/generator.c -->
# This is the JSON generator implemented as a C extension. It can be configured
# to be used by setting
#
#     JSON.generator = JSON::Ext::Generator
#
# with the method generator= in JSON.
#
module JSON::Ext::Generator
end

class JSON::Ext::Generator::State
end

# <!-- rdoc-file=ext/json/parser/parser.c -->
# This is the JSON parser implemented as a C extension. It can be configured to
# be used by setting
#
#     JSON.parser = JSON::Ext::Parser
#
# with the method parser= in JSON.
#
class JSON::Ext::Parser
end

module JSON::Pure
end

module JSON::Pure::Generator
end

class JSON::Pure::Generator::State
end

class JSON::Pure::Parser
end

type json_generator = singleton(::JSON::Ext::Generator) | singleton(::JSON::Pure::Generator)
type json_parser = singleton(::JSON::Ext::Parser) | singleton(::JSON::Pure::Parser)
type json_state = singleton(JSON::Ext::Generator::State) | singleton(JSON::Pure::Generator::State)

# <!-- rdoc-file=ext/json/lib/json.rb -->
# # JavaScript Object Notation (JSON)
#
# JSON is a lightweight data-interchange format.
#
# A JSON value is one of the following:
# *   Double-quoted text:  `"foo"`.
# *   Number:  `1`, `1.0`, `2.0e2`.
# *   Boolean:  `true`, `false`.
# *   Null: `null`.
# *   Array: an ordered list of values, enclosed by square brackets:
#         ["foo", 1, 1.0, 2.0e2, true, false, null]
#
# *   Object: a collection of name/value pairs, enclosed by curly braces; each
#     name is double-quoted text; the values may be any JSON values:
#         {"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}
#
#
# A JSON array or object may contain nested arrays, objects, and scalars to any
# depth:
#     {"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}
#     [{"foo": 0, "bar": 1}, ["baz", 2]]
#
# ## Using Module JSON
#
# To make module JSON available in your code, begin with:
#     require 'json'
#
# All examples here assume that this has been done.
#
# ### Parsing JSON
#
# You can parse a String containing JSON data using either of two methods:
# *   `JSON.parse(source, opts)`
# *   `JSON.parse!(source, opts)`
#
#
# where
# *   `source` is a Ruby object.
# *   `opts` is a Hash object containing options that control both input allowed
#     and output formatting.
#
#
# The difference between the two methods is that JSON.parse! omits some checks
# and may not be safe for some `source` data; use it only for data from trusted
# sources. Use the safer method JSON.parse for less trusted sources.
#
# #### Parsing JSON Arrays
#
# When `source` is a JSON array, JSON.parse by default returns a Ruby Array:
#     json = '["foo", 1, 1.0, 2.0e2, true, false, null]'
#     ruby = JSON.parse(json)
#     ruby # => ["foo", 1, 1.0, 200.0, true, false, nil]
#     ruby.class # => Array
#
# The JSON array may contain nested arrays, objects, and scalars to any depth:
#     json = '[{"foo": 0, "bar": 1}, ["baz", 2]]'
#     JSON.parse(json) # => [{"foo"=>0, "bar"=>1}, ["baz", 2]]
#
# #### Parsing JSON Objects
#
# When the source is a JSON object, JSON.parse by default returns a Ruby Hash:
#     json = '{"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}'
#     ruby = JSON.parse(json)
#     ruby # => {"a"=>"foo", "b"=>1, "c"=>1.0, "d"=>200.0, "e"=>true, "f"=>false, "g"=>nil}
#     ruby.class # => Hash
#
# The JSON object may contain nested arrays, objects, and scalars to any depth:
#     json = '{"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}'
#     JSON.parse(json) # => {"foo"=>{"bar"=>1, "baz"=>2}, "bat"=>[0, 1, 2]}
#
# #### Parsing JSON Scalars
#
# When the source is a JSON scalar (not an array or object), JSON.parse returns
# a Ruby scalar.
#
# String:
#     ruby = JSON.parse('"foo"')
#     ruby # => 'foo'
#     ruby.class # => String
#
# Integer:
#     ruby = JSON.parse('1')
#     ruby # => 1
#     ruby.class # => Integer
#
# Float:
#     ruby = JSON.parse('1.0')
#     ruby # => 1.0
#     ruby.class # => Float
#     ruby = JSON.parse('2.0e2')
#     ruby # => 200
#     ruby.class # => Float
#
# Boolean:
#     ruby = JSON.parse('true')
#     ruby # => true
#     ruby.class # => TrueClass
#     ruby = JSON.parse('false')
#     ruby # => false
#     ruby.class # => FalseClass
#
# Null:
#     ruby = JSON.parse('null')
#     ruby # => nil
#     ruby.class # => NilClass
#
# #### Parsing Options
#
# ###### Input Options
#
# Option `max_nesting` (Integer) specifies the maximum nesting depth allowed;
# defaults to `100`; specify `false` to disable depth checking.
#
# With the default, `false`:
#     source = '[0, [1, [2, [3]]]]'
#     ruby = JSON.parse(source)
#     ruby # => [0, [1, [2, [3]]]]
#
# Too deep:
#     # Raises JSON::NestingError (nesting of 2 is too deep):
#     JSON.parse(source, {max_nesting: 1})
#
# Bad value:
#     # Raises TypeError (wrong argument type Symbol (expected Fixnum)):
#     JSON.parse(source, {max_nesting: :foo})
#
# ---
#
# Option `allow_nan` (boolean) specifies whether to allow NaN, Infinity, and
# MinusInfinity in `source`; defaults to `false`.
#
# With the default, `false`:
#     # Raises JSON::ParserError (225: unexpected token at '[NaN]'):
#     JSON.parse('[NaN]')
#     # Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
#     JSON.parse('[Infinity]')
#     # Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
#     JSON.parse('[-Infinity]')
#
# Allow:
#     source = '[NaN, Infinity, -Infinity]'
#     ruby = JSON.parse(source, {allow_nan: true})
#     ruby # => [NaN, Infinity, -Infinity]
#
# ###### Output Options
#
# Option `symbolize_names` (boolean) specifies whether returned Hash keys should
# be Symbols; defaults to `false` (use Strings).
#
# With the default, `false`:
#     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
#     ruby = JSON.parse(source)
#     ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
#
# Use Symbols:
#     ruby = JSON.parse(source, {symbolize_names: true})
#     ruby # => {:a=>"foo", :b=>1.0, :c=>true, :d=>false, :e=>nil}
#
# ---
#
# Option `object_class` (Class) specifies the Ruby class to be used for each
# JSON object; defaults to Hash.
#
# With the default, Hash:
#     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
#     ruby = JSON.parse(source)
#     ruby.class # => Hash
#
# Use class OpenStruct:
#     ruby = JSON.parse(source, {object_class: OpenStruct})
#     ruby # => #<OpenStruct a="foo", b=1.0, c=true, d=false, e=nil>
#
# ---
#
# Option `array_class` (Class) specifies the Ruby class to be used for each JSON
# array; defaults to Array.
#
# With the default, Array:
#     source = '["foo", 1.0, true, false, null]'
#     ruby = JSON.parse(source)
#     ruby.class # => Array
#
# Use class Set:
#     ruby = JSON.parse(source, {array_class: Set})
#     ruby # => #<Set: {"foo", 1.0, true, false, nil}>
#
# ---
#
# Option `create_additions` (boolean) specifies whether to use JSON additions in
# parsing. See [\JSON Additions](#module-JSON-label-JSON+Additions).
#
# ### Generating JSON
#
# To generate a Ruby String containing JSON data, use method
# `JSON.generate(source, opts)`, where
# *   `source` is a Ruby object.
# *   `opts` is a Hash object containing options that control both input allowed
#     and output formatting.
#
#
# #### Generating JSON from Arrays
#
# When the source is a Ruby Array, JSON.generate returns a String containing a
# JSON array:
#     ruby = [0, 's', :foo]
#     json = JSON.generate(ruby)
#     json # => '[0,"s","foo"]'
#
# The Ruby Array array may contain nested arrays, hashes, and scalars to any
# depth:
#     ruby = [0, [1, 2], {foo: 3, bar: 4}]
#     json = JSON.generate(ruby)
#     json # => '[0,[1,2],{"foo":3,"bar":4}]'
#
# #### Generating JSON from Hashes
#
# When the source is a Ruby Hash, JSON.generate returns a String containing a
# JSON object:
#     ruby = {foo: 0, bar: 's', baz: :bat}
#     json = JSON.generate(ruby)
#     json # => '{"foo":0,"bar":"s","baz":"bat"}'
#
# The Ruby Hash array may contain nested arrays, hashes, and scalars to any
# depth:
#     ruby = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
#     json = JSON.generate(ruby)
#     json # => '{"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}'
#
# #### Generating JSON from Other Objects
#
# When the source is neither an Array nor a Hash, the generated JSON data
# depends on the class of the source.
#
# When the source is a Ruby Integer or Float, JSON.generate returns a String
# containing a JSON number:
#     JSON.generate(42) # => '42'
#     JSON.generate(0.42) # => '0.42'
#
# When the source is a Ruby String, JSON.generate returns a String containing a
# JSON string (with double-quotes):
#     JSON.generate('A string') # => '"A string"'
#
# When the source is `true`, `false` or `nil`, JSON.generate returns a String
# containing the corresponding JSON token:
#     JSON.generate(true) # => 'true'
#     JSON.generate(false) # => 'false'
#     JSON.generate(nil) # => 'null'
#
# When the source is none of the above, JSON.generate returns a String
# containing a JSON string representation of the source:
#     JSON.generate(:foo) # => '"foo"'
#     JSON.generate(Complex(0, 0)) # => '"0+0i"'
#     JSON.generate(Dir.new('.')) # => '"#<Dir>"'
#
# #### Generating Options
#
# ###### Input Options
#
# Option `allow_nan` (boolean) specifies whether `NaN`, `Infinity`, and
# `-Infinity` may be generated; defaults to `false`.
#
# With the default, `false`:
#     # Raises JSON::GeneratorError (920: NaN not allowed in JSON):
#     JSON.generate(JSON::NaN)
#     # Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
#     JSON.generate(JSON::Infinity)
#     # Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
#     JSON.generate(JSON::MinusInfinity)
#
# Allow:
#     ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
#     JSON.generate(ruby, allow_nan: true) # => '[NaN,Infinity,-Infinity]'
#
# ---
#
# Option `max_nesting` (Integer) specifies the maximum nesting depth in `obj`;
# defaults to `100`.
#
# With the default, `100`:
#     obj = [[[[[[0]]]]]]
#     JSON.generate(obj) # => '[[[[[[0]]]]]]'
#
# Too deep:
#     # Raises JSON::NestingError (nesting of 2 is too deep):
#     JSON.generate(obj, max_nesting: 2)
#
# ###### Output Options
#
# The default formatting options generate the most compact JSON data, all on one
# line and with no whitespace.
#
# You can use these formatting options to generate JSON data in a more open
# format, using whitespace. See also JSON.pretty_generate.
#
# *   Option `array_nl` (String) specifies a string (usually a newline) to be
#     inserted after each JSON array; defaults to the empty String, `''`.
# *   Option `object_nl` (String) specifies a string (usually a newline) to be
#     inserted after each JSON object; defaults to the empty String, `''`.
# *   Option `indent` (String) specifies the string (usually spaces) to be used
#     for indentation; defaults to the empty String, `''`; defaults to the empty
#     String, `''`; has no effect unless options `array_nl` or `object_nl`
#     specify newlines.
# *   Option `space` (String) specifies a string (usually a space) to be
#     inserted after the colon in each JSON object's pair; defaults to the empty
#     String, `''`.
# *   Option `space_before` (String) specifies a string (usually a space) to be
#     inserted before the colon in each JSON object's pair; defaults to the
#     empty String, `''`.
#
#
# In this example, `obj` is used first to generate the shortest JSON data (no
# whitespace), then again with all formatting options specified:
#
#     obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
#     json = JSON.generate(obj)
#     puts 'Compact:', json
#     opts = {
#       array_nl: "\n",
#       object_nl: "\n",
#       indent: '  ',
#       space_before: ' ',
#       space: ' '
#     }
#     puts 'Open:', JSON.generate(obj, opts)
#
# Output:
#     Compact:
#     {"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
#     Open:
#     {
#       "foo" : [
#         "bar",
#         "baz"
#     ],
#       "bat" : {
#         "bam" : 0,
#         "bad" : 1
#       }
#     }
#
# ## JSON Additions
#
# When you "round trip" a non-String object from Ruby to JSON and back, you have
# a new String, instead of the object you began with:
#     ruby0 = Range.new(0, 2)
#     json = JSON.generate(ruby0)
#     json # => '0..2"'
#     ruby1 = JSON.parse(json)
#     ruby1 # => '0..2'
#     ruby1.class # => String
#
# You can use JSON *additions* to preserve the original object. The addition is
# an extension of a ruby class, so that:
# *   JSON.generate stores more information in the JSON string.
# *   JSON.parse, called with option `create_additions`, uses that information
#     to create a proper Ruby object.
#
#
# This example shows a Range being generated into JSON and parsed back into
# Ruby, both without and with the addition for Range:
#     ruby = Range.new(0, 2)
#     # This passage does not use the addition for Range.
#     json0 = JSON.generate(ruby)
#     ruby0 = JSON.parse(json0)
#     # This passage uses the addition for Range.
#     require 'json/add/range'
#     json1 = JSON.generate(ruby)
#     ruby1 = JSON.parse(json1, create_additions: true)
#     # Make a nice display.
#     display = <<EOT
#     Generated JSON:
#       Without addition:  #{json0} (#{json0.class})
#       With addition:     #{json1} (#{json1.class})
#     Parsed JSON:
#       Without addition:  #{ruby0.inspect} (#{ruby0.class})
#       With addition:     #{ruby1.inspect} (#{ruby1.class})
#     EOT
#     puts display
#
# This output shows the different results:
#     Generated JSON:
#       Without addition:  "0..2" (String)
#       With addition:     {"json_class":"Range","a":[0,2,false]} (String)
#     Parsed JSON:
#       Without addition:  "0..2" (String)
#       With addition:     0..2 (Range)
#
# The JSON module includes additions for certain classes. You can also craft
# custom additions. See [Custom \JSON
# Additions](#module-JSON-label-Custom+JSON+Additions).
#
# ### Built-in Additions
#
# The JSON module includes additions for certain classes. To use an addition,
# `require` its source:
# *   BigDecimal: `require 'json/add/bigdecimal'`
# *   Complex: `require 'json/add/complex'`
# *   Date: `require 'json/add/date'`
# *   DateTime: `require 'json/add/date_time'`
# *   Exception: `require 'json/add/exception'`
# *   OpenStruct: `require 'json/add/ostruct'`
# *   Range: `require 'json/add/range'`
# *   Rational: `require 'json/add/rational'`
# *   Regexp: `require 'json/add/regexp'`
# *   Set: `require 'json/add/set'`
# *   Struct: `require 'json/add/struct'`
# *   Symbol: `require 'json/add/symbol'`
# *   Time: `require 'json/add/time'`
#
#
# To reduce punctuation clutter, the examples below show the generated JSON via
# `puts`, rather than the usual `inspect`,
#
# BigDecimal:
#     require 'json/add/bigdecimal'
#     ruby0 = BigDecimal(0) # 0.0
#     json = JSON.generate(ruby0) # {"json_class":"BigDecimal","b":"27:0.0"}
#     ruby1 = JSON.parse(json, create_additions: true) # 0.0
#     ruby1.class # => BigDecimal
#
# Complex:
#     require 'json/add/complex'
#     ruby0 = Complex(1+0i) # 1+0i
#     json = JSON.generate(ruby0) # {"json_class":"Complex","r":1,"i":0}
#     ruby1 = JSON.parse(json, create_additions: true) # 1+0i
#     ruby1.class # Complex
#
# Date:
#     require 'json/add/date'
#     ruby0 = Date.today # 2020-05-02
#     json = JSON.generate(ruby0) # {"json_class":"Date","y":2020,"m":5,"d":2,"sg":2299161.0}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02
#     ruby1.class # Date
#
# DateTime:
#     require 'json/add/date_time'
#     ruby0 = DateTime.now # 2020-05-02T10:38:13-05:00
#     json = JSON.generate(ruby0) # {"json_class":"DateTime","y":2020,"m":5,"d":2,"H":10,"M":38,"S":13,"of":"-5/24","sg":2299161.0}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02T10:38:13-05:00
#     ruby1.class # DateTime
#
# Exception (and its subclasses including RuntimeError):
#     require 'json/add/exception'
#     ruby0 = Exception.new('A message') # A message
#     json = JSON.generate(ruby0) # {"json_class":"Exception","m":"A message","b":null}
#     ruby1 = JSON.parse(json, create_additions: true) # A message
#     ruby1.class # Exception
#     ruby0 = RuntimeError.new('Another message') # Another message
#     json = JSON.generate(ruby0) # {"json_class":"RuntimeError","m":"Another message","b":null}
#     ruby1 = JSON.parse(json, create_additions: true) # Another message
#     ruby1.class # RuntimeError
#
# OpenStruct:
#     require 'json/add/ostruct'
#     ruby0 = OpenStruct.new(name: 'Matz', language: 'Ruby') # #<OpenStruct name="Matz", language="Ruby">
#     json = JSON.generate(ruby0) # {"json_class":"OpenStruct","t":{"name":"Matz","language":"Ruby"}}
#     ruby1 = JSON.parse(json, create_additions: true) # #<OpenStruct name="Matz", language="Ruby">
#     ruby1.class # OpenStruct
#
# Range:
#     require 'json/add/range'
#     ruby0 = Range.new(0, 2) # 0..2
#     json = JSON.generate(ruby0) # {"json_class":"Range","a":[0,2,false]}
#     ruby1 = JSON.parse(json, create_additions: true) # 0..2
#     ruby1.class # Range
#
# Rational:
#     require 'json/add/rational'
#     ruby0 = Rational(1, 3) # 1/3
#     json = JSON.generate(ruby0) # {"json_class":"Rational","n":1,"d":3}
#     ruby1 = JSON.parse(json, create_additions: true) # 1/3
#     ruby1.class # Rational
#
# Regexp:
#     require 'json/add/regexp'
#     ruby0 = Regexp.new('foo') # (?-mix:foo)
#     json = JSON.generate(ruby0) # {"json_class":"Regexp","o":0,"s":"foo"}
#     ruby1 = JSON.parse(json, create_additions: true) # (?-mix:foo)
#     ruby1.class # Regexp
#
# Set:
#     require 'json/add/set'
#     ruby0 = Set.new([0, 1, 2]) # #<Set: {0, 1, 2}>
#     json = JSON.generate(ruby0) # {"json_class":"Set","a":[0,1,2]}
#     ruby1 = JSON.parse(json, create_additions: true) # #<Set: {0, 1, 2}>
#     ruby1.class # Set
#
# Struct:
#     require 'json/add/struct'
#     Customer = Struct.new(:name, :address) # Customer
#     ruby0 = Customer.new("Dave", "123 Main") # #<struct Customer name="Dave", address="123 Main">
#     json = JSON.generate(ruby0) # {"json_class":"Customer","v":["Dave","123 Main"]}
#     ruby1 = JSON.parse(json, create_additions: true) # #<struct Customer name="Dave", address="123 Main">
#     ruby1.class # Customer
#
# Symbol:
#     require 'json/add/symbol'
#     ruby0 = :foo # foo
#     json = JSON.generate(ruby0) # {"json_class":"Symbol","s":"foo"}
#     ruby1 = JSON.parse(json, create_additions: true) # foo
#     ruby1.class # Symbol
#
# Time:
#     require 'json/add/time'
#     ruby0 = Time.now # 2020-05-02 11:28:26 -0500
#     json = JSON.generate(ruby0) # {"json_class":"Time","s":1588436906,"n":840560000}
#     ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02 11:28:26 -0500
#     ruby1.class # Time
#
# ### Custom JSON Additions
#
# In addition to the JSON additions provided, you can craft JSON additions of
# your own, either for Ruby built-in classes or for user-defined classes.
#
# Here's a user-defined class `Foo`:
#     class Foo
#       attr_accessor :bar, :baz
#       def initialize(bar, baz)
#         self.bar = bar
#         self.baz = baz
#       end
#     end
#
# Here's the JSON addition for it:
#     # Extend class Foo with JSON addition.
#     class Foo
#       # Serialize Foo object with its class name and arguments
#       def to_json(*args)
#         {
#           JSON.create_id  => self.class.name,
#           'a'             => [ bar, baz ]
#         }.to_json(*args)
#       end
#       # Deserialize JSON string by constructing new Foo object with arguments.
#       def self.json_create(object)
#         new(*object['a'])
#       end
#     end
#
# Demonstration:
#     require 'json'
#     # This Foo object has no custom addition.
#     foo0 = Foo.new(0, 1)
#     json0 = JSON.generate(foo0)
#     obj0 = JSON.parse(json0)
#     # Lood the custom addition.
#     require_relative 'foo_addition'
#     # This foo has the custom addition.
#     foo1 = Foo.new(0, 1)
#     json1 = JSON.generate(foo1)
#     obj1 = JSON.parse(json1, create_additions: true)
#     #   Make a nice display.
#     display = <<EOT
#     Generated JSON:
#       Without custom addition:  #{json0} (#{json0.class})
#       With custom addition:     #{json1} (#{json1.class})
#     Parsed JSON:
#       Without custom addition:  #{obj0.inspect} (#{obj0.class})
#       With custom addition:     #{obj1.inspect} (#{obj1.class})
#     EOT
#     puts display
#
# Output:
#
#     Generated JSON:
#       Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#       With custom addition:     {"json_class":"Foo","a":[0,1]} (String)
#     Parsed JSON:
#       Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#       With custom addition:     #<Foo:0x0000000006473bb8 @bar=0, @baz=1> (Foo)
#
module JSON
  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON[object] -> new_array or new_string
  # -->
  # If `object` is a String, calls JSON.parse with `object` and `opts` (see method
  # #parse):
  #     json = '[0, 1, null]'
  #     JSON[json]# => [0, 1, nil]
  #
  # Otherwise, calls JSON.generate with `object` and `opts` (see method
  # #generate):
  #     ruby = [0, 1, nil]
  #     JSON[ruby] # => '[0,1,null]'
  #
  def self.[]: (untyped object, ?json_options opts) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - create_id()
  # -->
  # Returns the current create identifier. See also JSON.create_id=.
  #
  def self.create_id: () -> _ToS

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - create_id=(new_value)
  # -->
  # Sets create identifier, which is used to decide if the *json_create* hook of a
  # class should be called; initial value is `json_class`:
  #     JSON.create_id # => 'json_class'
  #
  def self.create_id=: (_ToS create_id) -> _ToS

  def self.deep_const_get: (_ToS path) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.dump(obj, io = nil, limit = nil)
  # -->
  # Dumps `obj` as a JSON string, i.e. calls generate on the object and returns
  # the result.
  #
  # The default options can be changed via method JSON.dump_default_options.
  #
  # *   Argument `io`, if given, should respond to method `write`; the JSON String
  #     is written to `io`, and `io` is returned. If `io` is not given, the JSON
  #     String is returned.
  # *   Argument `limit`, if given, is passed to JSON.generate as option
  #     `max_nesting`.
  #
  #
  # ---
  #
  # When argument `io` is not given, returns the JSON String generated from `obj`:
  #     obj = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
  #     json = JSON.dump(obj)
  #     json # => "{\"foo\":[0,1],\"bar\":{\"baz\":2,\"bat\":3},\"bam\":\"bad\"}"
  #
  # When argument `io` is given, writes the JSON String to `io` and returns `io`:
  #     path = 't.json'
  #     File.open(path, 'w') do |file|
  #       JSON.dump(obj, file)
  #     end # => #<File:t.json (closed)>
  #     puts File.read(path)
  #
  # Output:
  #     {"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}
  #
  def self?.dump: (_ToJson obj, ?Integer limit) -> String
                | (_ToJson obj, _JsonToWritableIO anIO) -> _JsonWrite
                | (_ToJson obj, _JsonWrite anIO, ?Integer limit) -> _JsonWrite

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns the default options for the JSON.dump method. Initially:
  #     opts = JSON.dump_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :escape_slash=>false}
  #
  def self.dump_default_options: () -> json_options

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns the default options for the JSON.dump method. Initially:
  #     opts = JSON.dump_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :escape_slash=>false}
  #
  def self.dump_default_options=: (json_options) -> json_options

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.fast_generate(obj, opts) -> new_string
  # -->
  # Arguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
  # JSON.generate.
  #
  # By default, generates JSON data without checking for circular references in
  # `obj` (option `max_nesting` set to `false`, disabled).
  #
  # Raises an exception if `obj` contains circular references:
  #     a = []; b = []; a.push(b); b.push(a)
  #     # Raises SystemStackError (stack level too deep):
  #     JSON.fast_generate(a)
  #
  def self?.fast_generate: (_ToJson obj, ?json_options opts) -> String

  alias self.fast_unparse self.fast_generate

  alias fast_unparse fast_generate

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.generate(obj, opts = nil) -> new_string
  # -->
  # Returns a String containing the generated JSON data.
  #
  # See also JSON.fast_generate, JSON.pretty_generate.
  #
  # Argument `obj` is the Ruby object to be converted to JSON.
  #
  # Argument `opts`, if given, contains a Hash of options for the generation. See
  # [Generating Options](#module-JSON-label-Generating+Options).
  #
  # ---
  #
  # When `obj` is an Array, returns a String containing a JSON array:
  #     obj = ["foo", 1.0, true, false, nil]
  #     json = JSON.generate(obj)
  #     json # => '["foo",1.0,true,false,null]'
  #
  # When `obj` is a Hash, returns a String containing a JSON object:
  #     obj = {foo: 0, bar: 's', baz: :bat}
  #     json = JSON.generate(obj)
  #     json # => '{"foo":0,"bar":"s","baz":"bat"}'
  #
  # For examples of generating from other Ruby objects, see [Generating \JSON from
  # Other Objects](#module-JSON-label-Generating+JSON+from+Other+Objects).
  #
  # ---
  #
  # Raises an exception if any formatting option is not a String.
  #
  # Raises an exception if `obj` contains circular references:
  #     a = []; b = []; a.push(b); b.push(a)
  #     # Raises JSON::NestingError (nesting of 100 is too deep):
  #     JSON.generate(a)
  #
  def self?.generate: (_ToJson obj, ?json_options opts) -> String

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Returns the JSON generator module that is used by JSON. This is either
  # JSON::Ext::Generator or JSON::Pure::Generator:
  #     JSON.generator # => JSON::Ext::Generator
  #
  def self.generator: () -> json_generator

  def self.generator=: (json_generator generator) -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - iconv(to, from, string)
  # -->
  # Encodes string using String.encode.
  #
  def self.iconv: (encoding to, encoding from, String string) -> String

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.load(source, proc = nil, options = {}) -> object
  # -->
  # Returns the Ruby objects created by parsing the given `source`.
  #
  # *   Argument `source` must be, or be convertible to, a String:
  #     *   If `source` responds to instance method `to_str`, `source.to_str`
  #         becomes the source.
  #     *   If `source` responds to instance method `to_io`, `source.to_io.read`
  #         becomes the source.
  #     *   If `source` responds to instance method `read`, `source.read` becomes
  #         the source.
  #     *   If both of the following are true, source becomes the String `'null'`:
  #         *   Option `allow_blank` specifies a truthy value.
  #         *   The source, as defined above, is `nil` or the empty String `''`.
  #
  #     *   Otherwise, `source` remains the source.
  #
  # *   Argument `proc`, if given, must be a Proc that accepts one argument. It
  #     will be called recursively with each result (depth-first order). See
  #     details below. BEWARE: This method is meant to serialise data from trusted
  #     user input, like from your own database server or clients under your
  #     control, it could be dangerous to allow untrusted users to pass JSON
  #     sources into it.
  # *   Argument `opts`, if given, contains a Hash of options for the parsing. See
  #     [Parsing Options](#module-JSON-label-Parsing+Options). The default options
  #     can be changed via method JSON.load_default_options=.
  #
  #
  # ---
  #
  # When no `proc` is given, modifies `source` as above and returns the result of
  # `parse(source, opts)`;  see #parse.
  #
  # Source for following examples:
  #     source = <<-EOT
  #     {
  #     "name": "Dave",
  #       "age" :40,
  #       "hats": [
  #         "Cattleman's",
  #         "Panama",
  #         "Tophat"
  #       ]
  #     }
  #     EOT
  #
  # Load a String:
  #     ruby = JSON.load(source)
  #     ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # Load an IO object:
  #     require 'stringio'
  #     object = JSON.load(StringIO.new(source))
  #     object # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # Load a File object:
  #     path = 't.json'
  #     File.write(path, source)
  #     File.open(path) do |file|
  #       JSON.load(file)
  #     end # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # ---
  #
  # When `proc` is given:
  # *   Modifies `source` as above.
  # *   Gets the `result` from calling `parse(source, opts)`.
  # *   Recursively calls `proc(result)`.
  # *   Returns the final result.
  #
  #
  # Example:
  #     require 'json'
  #
  #     # Some classes for the example.
  #     class Base
  #       def initialize(attributes)
  #         @attributes = attributes
  #       end
  #     end
  #     class User    < Base; end
  #     class Account < Base; end
  #     class Admin   < Base; end
  #     # The JSON source.
  #     json = <<-EOF
  #     {
  #       "users": [
  #           {"type": "User", "username": "jane", "email": "jane@example.com"},
  #           {"type": "User", "username": "john", "email": "john@example.com"}
  #       ],
  #       "accounts": [
  #           {"account": {"type": "Account", "paid": true, "account_id": "1234"}},
  #           {"account": {"type": "Account", "paid": false, "account_id": "1235"}}
  #       ],
  #       "admins": {"type": "Admin", "password": "0wn3d"}
  #     }
  #     EOF
  #     # Deserializer method.
  #     def deserialize_obj(obj, safe_types = %w(User Account Admin))
  #       type = obj.is_a?(Hash) && obj["type"]
  #       safe_types.include?(type) ? Object.const_get(type).new(obj) : obj
  #     end
  #     # Call to JSON.load
  #     ruby = JSON.load(json, proc {|obj|
  #       case obj
  #       when Hash
  #         obj.each {|k, v| obj[k] = deserialize_obj v }
  #       when Array
  #         obj.map! {|v| deserialize_obj v }
  #       end
  #     })
  #     pp ruby
  #
  # Output:
  #     {"users"=>
  #        [#<User:0x00000000064c4c98
  #          @attributes=
  #            {"type"=>"User", "username"=>"jane", "email"=>"jane@example.com"}>,
  #          #<User:0x00000000064c4bd0
  #          @attributes=
  #            {"type"=>"User", "username"=>"john", "email"=>"john@example.com"}>],
  #      "accounts"=>
  #        [{"account"=>
  #            #<Account:0x00000000064c4928
  #            @attributes={"type"=>"Account", "paid"=>true, "account_id"=>"1234"}>},
  #         {"account"=>
  #            #<Account:0x00000000064c4680
  #            @attributes={"type"=>"Account", "paid"=>false, "account_id"=>"1235"}>}],
  #      "admins"=>
  #        #<Admin:0x00000000064c41f8
  #        @attributes={"type"=>"Admin", "password"=>"0wn3d"}>}
  #
  def self?.load: (string | _JsonReadableIO | _JsonRead source, ?Proc proc, ?json_options options) -> untyped

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns default options for the JSON.load method. Initially:
  #     opts = JSON.load_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
  #
  def self.load_default_options: () -> json_options

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or returns default options for the JSON.load method. Initially:
  #     opts = JSON.load_default_options
  #     opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
  #
  def self.load_default_options=: (json_options) -> json_options

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.parse(source, opts) -> object
  # -->
  # Returns the Ruby objects created by parsing the given `source`.
  #
  # Argument `source` contains the String to be parsed.
  #
  # Argument `opts`, if given, contains a Hash of options for the parsing. See
  # [Parsing Options](#module-JSON-label-Parsing+Options).
  #
  # ---
  #
  # When `source` is a JSON array, returns a Ruby Array:
  #     source = '["foo", 1.0, true, false, null]'
  #     ruby = JSON.parse(source)
  #     ruby # => ["foo", 1.0, true, false, nil]
  #     ruby.class # => Array
  #
  # When `source` is a JSON object, returns a Ruby Hash:
  #     source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
  #     ruby = JSON.parse(source)
  #     ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
  #     ruby.class # => Hash
  #
  # For examples of parsing for all JSON data types, see [Parsing
  # \JSON](#module-JSON-label-Parsing+JSON).
  #
  # Parses nested JSON objects:
  #     source = <<-EOT
  #     {
  #     "name": "Dave",
  #       "age" :40,
  #       "hats": [
  #         "Cattleman's",
  #         "Panama",
  #         "Tophat"
  #       ]
  #     }
  #     EOT
  #     ruby = JSON.parse(source)
  #     ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}
  #
  # ---
  #
  # Raises an exception if `source` is not valid JSON:
  #     # Raises JSON::ParserError (783: unexpected token at ''):
  #     JSON.parse('')
  #
  def self?.parse: (string source, ?json_options opts) -> untyped

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.parse!(source, opts) -> object
  # -->
  # Calls
  #     parse(source, opts)
  #
  # with `source` and possibly modified `opts`.
  #
  # Differences from JSON.parse:
  # *   Option `max_nesting`, if not provided, defaults to `false`, which disables
  #     checking for nesting depth.
  # *   Option `allow_nan`, if not provided, defaults to `true`.
  #
  def self?.parse!: (string source, ?json_options opts) -> untyped

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Returns the JSON parser class that is used by JSON. This is either
  # JSON::Ext::Parser or JSON::Pure::Parser:
  #     JSON.parser # => JSON::Ext::Parser
  #
  def self.parser: () -> json_parser

  def self.parser=: (json_parser parser) -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - JSON.pretty_generate(obj, opts = nil) -> new_string
  # -->
  # Arguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
  # JSON.generate.
  #
  # Default options are:
  #     {
  #       indent: '  ',   # Two spaces
  #       space: ' ',     # One space
  #       array_nl: "\n", # Newline
  #       object_nl: "\n" # Newline
  #     }
  #
  # Example:
  #     obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
  #     json = JSON.pretty_generate(obj)
  #     puts json
  #
  # Output:
  #     {
  #       "foo": [
  #         "bar",
  #         "baz"
  #       ],
  #       "bat": {
  #         "bam": 0,
  #         "bad": 1
  #       }
  #     }
  #
  def self?.pretty_generate: (_ToJson obj, ?json_options opts) -> untyped

  alias self.pretty_unparse self.pretty_generate

  alias pretty_unparse pretty_generate

  # Recursively calls passed *Proc* if the parsed data structure is an *Array* or
  # *Hash*
  #
  def self?.recurse_proc: (untyped result) { (*untyped) -> void } -> void

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - restore(source, proc = nil, options = {})
  # -->
  #
  alias self.restore self.load

  # <!--
  #   rdoc-file=ext/json/lib/json/common.rb
  #   - restore(source, proc = nil, options = {})
  # -->
  #
  alias restore load

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or Returns the JSON generator state class that is used by JSON. This is
  # either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
  #     JSON.state # => JSON::Ext::Generator::State
  #
  def self.state: () -> json_state

  # <!-- rdoc-file=ext/json/lib/json/common.rb -->
  # Sets or Returns the JSON generator state class that is used by JSON. This is
  # either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
  #     JSON.state # => JSON::Ext::Generator::State
  #
  def self.state=: (json_state) -> json_state

  alias self.unparse self.generate

  alias unparse generate
end

JSON::FAST_STATE_PROTOTYPE: json_state

JSON::Infinity: Float

JSON::JSON_LOADED: bool

JSON::MinusInfinity: Float

JSON::NaN: Float

JSON::PRETTY_STATE_PROTOTYPE: json_state

JSON::SAFE_STATE_PROTOTYPE: json_state

# <!-- rdoc-file=ext/json/lib/json/version.rb -->
# JSON version
#
JSON::VERSION: String

JSON::VERSION_ARRAY: Array[Integer]

JSON::VERSION_BUILD: Integer

JSON::VERSION_MAJOR: Integer

JSON::VERSION_MINOR: Integer

%a{annotate:rdoc:skip}
class Object
  # Converts this object to a string (calling #to_s), converts
  # it to a JSON string, and returns the result. This is a fallback, if no
  # special method #to_json was defined for some object.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class NilClass
  # Returns a JSON string for nil: 'null'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class TrueClass
  # Returns a JSON string for true: 'true'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class FalseClass
  # Returns a JSON string for false: 'false'.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class String
  # This string should be encoded with UTF-8 A call to this method
  # returns a JSON string encoded with UTF16 big endian characters as
  # \u????.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Integer
  # Returns a JSON string representation for this Integer number.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Float
  # Returns a JSON string representation for this Float number.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Hash[unchecked out K, unchecked out V]
  # Returns a JSON string containing a JSON object, that is generated from
  # this Hash instance.
  # _state_ is a JSON::State object, that can also be used to configure the
  # produced JSON string output further.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem]
  # Returns a JSON string containing a JSON array, that is generated from
  # this Array instance.
  # _state_ is a JSON::State object, that can also be used to configure the
  # produced JSON string output further.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class BigDecimal
  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - json_create(object)
  # -->
  # Import a JSON Marshalled object.
  #
  # method used for JSON marshalling support.
  #
  def self.json_create: (Hash[String, String] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - as_json(*)
  # -->
  # Marshal the object to JSON.
  #
  # method used for JSON marshalling support.
  #
  def as_json: (*untyped) -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/bigdecimal.rb
  #   - to_json(*args)
  # -->
  # return the JSON value
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Complex
  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by converting Real value `r`, imaginary value `i`, to
  # a Complex object.
  #
  def self.json_create: (Hash[String, String | Numeric] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Numeric]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/complex.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Complex) along with real value `r` and imaginary value `i`
  # as JSON string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Date
  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by converting Julian year `y`, month `m`, day `d` and
  # Day of Calendar Reform `sg` to Date.
  #
  def self.json_create: (Hash[String, String | Integer | Float] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Integer | Float]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Date) with Julian year `y`, month `m`, day `d` and Day of
  # Calendar Reform `sg` as JSON string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class DateTime
  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by converting year `y`, month `m`, day `d`, hour `H`,
  # minute `M`, second `S`, offset `of` and Day of Calendar Reform `sg` to
  # DateTime.
  #
  def self.json_create: (Hash[String, String | Integer | Float] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Integer | Float]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/date_time.rb
  #   - to_json(*args)
  # -->
  # Stores class name (DateTime) with Julian year `y`, month `m`, day `d`, hour
  # `H`, minute `M`, second `S`, offset `of` and Day of Calendar Reform `sg` as
  # JSON string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Exception
  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by constructing new Exception object with message `m`
  # and backtrace `b` serialized with `to_json`
  #
  def self.json_create: (Hash[String, String | Array[String] | nil] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Array[String] | nil]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/exception.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Exception) with message `m` and backtrace array `b` as JSON
  # string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class OpenStruct
  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by constructing new Struct object with values `t`
  # serialized by `to_json`.
  #
  def self.json_create: (Hash[String, String | Hash[Symbol, untyped]] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Hash[Symbol, untyped]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/ostruct.rb
  #   - to_json(*args)
  # -->
  # Stores class name (OpenStruct) with this struct's values `t` as a JSON string.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Range[out Elem]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by constructing new Range object with arguments `a`
  # serialized by `to_json`.
  #
  def self.json_create: [A] (Hash[String, String | [ A, A, bool ]] object) -> Range[A]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | [ Elem, Elem, bool ]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/range.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Range) with JSON array of arguments `a` which include
  # `first` (integer), `last` (integer), and `exclude_end?` (boolean) as JSON
  # string.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Rational
  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by converting numerator value `n`, denominator value
  # `d`, to a Rational object.
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/rational.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Rational) along with numerator value `n` and denominator
  # value `d` as JSON string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Regexp
  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by constructing new Regexp object with source `s`
  # (Regexp or String) and options `o` serialized by `to_json`
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/regexp.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Regexp) with options `o` and source `s` (Regexp or String)
  # as JSON string
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Set[A]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - json_create(object)
  # -->
  # Import a JSON Marshalled object.
  #
  # method used for JSON marshalling support.
  #
  def self.json_create: [A] (Hash[String, String | Array[A]] object) -> Set[A]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - as_json(*)
  # -->
  # Marshal the object to JSON.
  #
  # method used for JSON marshalling support.
  #
  def as_json: (*untyped) -> Hash[String, String | Array[A]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/set.rb
  #   - to_json(*args)
  # -->
  # return the JSON value
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Struct[Elem]
  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by constructing new Struct object with values `v`
  # serialized by `to_json`.
  #
  def self.json_create: [Elem] (Hash[String, String | Array[Elem]] object) -> Struct[Elem]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Array[Elem]]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/struct.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Struct) with Struct values `v` as a JSON string. Only named
  # structs are supported.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Symbol
  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - json_create(o)
  # -->
  # Deserializes JSON string by converting the `string` value stored in the object
  # to a Symbol
  #
  def self.json_create: (Hash[String, String] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/symbol.rb
  #   - to_json(*a)
  # -->
  # Stores class name (Symbol) with String representation of Symbol as a JSON
  # string.
  #
  def to_json: (?JSON::State state) -> String
end

%a{annotate:rdoc:skip}
class Time
  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - json_create(object)
  # -->
  # Deserializes JSON string by converting time since epoch to Time
  #
  def self.json_create: (Hash[String, String | Integer] object) -> instance

  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - as_json(*)
  # -->
  # Returns a hash, that will be turned into a JSON object and represent this
  # object.
  #
  def as_json: (*untyped) -> Hash[String, String | Integer]

  # <!--
  #   rdoc-file=ext/json/lib/json/add/time.rb
  #   - to_json(*args)
  # -->
  # Stores class name (Time) with number of seconds since epoch and number of
  # microseconds for Time as JSON string
  #
  def to_json: (?JSON::State state) -> String
end

# <!-- rdoc-file=lib/prettyprint.rb -->
# This class implements a pretty printing algorithm. It finds line breaks and
# nice indentations for grouped structure.
#
# By default, the class assumes that primitive elements are strings and each
# byte in the strings have single column in width. But it can be used for other
# situations by giving suitable arguments for some methods:
# *   newline object and space generation block for PrettyPrint.new
# *   optional width argument for PrettyPrint#text
# *   PrettyPrint#breakable
#
#
# There are several candidate uses:
# *   text formatting using proportional fonts
# *   multibyte characters which has columns different to number of bytes
# *   non-string formatting
#
#
# ## Bugs
# *   Box based formatting?
# *   Other (better) model/algorithm?
#
#
# Report any bugs at http://bugs.ruby-lang.org
#
# ## References
# Christian Lindig, Strictly Pretty, March 2000,
# http://www.st.cs.uni-sb.de/~lindig/papers/#pretty
#
# Philip Wadler, A prettier printer, March 1998,
# http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier
#
# ## Author
# Tanaka Akira <akr@fsij.org>
#
class PrettyPrint
  interface _Output
    def <<: (String) -> void
  end

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - format(output=''.dup, maxwidth=79, newline="\n", genspace=lambda {|n| ' ' * n}) { |q| ... }
  # -->
  # This is a convenience method which is same as follows:
  #
  #     begin
  #       q = PrettyPrint.new(output, maxwidth, newline, &genspace)
  #       ...
  #       q.flush
  #       output
  #     end
  #
  def self.format: (?untyped output, ?Integer maxwidth, ?String newline, ?^(Integer) -> Integer genspace) { (PrettyPrint) -> untyped } -> _Output

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - singleline_format(output=''.dup, maxwidth=nil, newline=nil, genspace=nil) { |q| ... }
  # -->
  # This is similar to PrettyPrint::format but the result has no breaks.
  #
  # `maxwidth`, `newline` and `genspace` are ignored.
  #
  # The invocation of `breakable` in the block doesn't break a line and is treated
  # as just an invocation of `text`.
  #
  def self.singleline_format: (?untyped output, ?Integer? maxwidth, ?String? newline, ?^(Integer) -> Integer? genspace) { (PrettyPrint::SingleLine) -> untyped } -> _Output

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - new(output=''.dup, maxwidth=79, newline="\n", &genspace)
  # -->
  # Creates a buffer for pretty printing.
  #
  # `output` is an output target. If it is not specified, '' is assumed. It should
  # have a << method which accepts the first argument `obj` of PrettyPrint#text,
  # the first argument `sep` of PrettyPrint#breakable, the first argument
  # `newline` of PrettyPrint.new, and the result of a given block for
  # PrettyPrint.new.
  #
  # `maxwidth` specifies maximum line length. If it is not specified, 79 is
  # assumed. However actual outputs may overflow `maxwidth` if long non-breakable
  # texts are provided.
  #
  # `newline` is used for line breaks. "n" is used if it is not specified.
  #
  # The block is used to generate spaces. {|width| ' ' * width} is used if it is
  # not given.
  #
  def initialize: (?untyped output, ?Integer maxwidth, ?String newline, ?^(Integer) -> Integer genspace) -> void

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The output object.
  #
  # This defaults to '', and should accept the << method
  #
  attr_reader output: _Output

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The maximum width of a line, before it is separated in to a newline
  #
  # This defaults to 79, and should be an Integer
  #
  attr_reader maxwidth: Integer

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The value that is appended to `output` to add a new line.
  #
  # This defaults to "n", and should be String
  #
  attr_reader newline: String

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # A lambda or Proc, that takes one argument, of an Integer, and returns the
  # corresponding number of spaces.
  #
  # By default this is:
  #     lambda {|n| ' ' * n}
  #
  attr_reader genspace: Proc

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The number of spaces to be indented
  #
  attr_reader indent: Integer

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # The PrettyPrint::GroupQueue of groups in stack to be pretty printed
  #
  attr_reader group_queue: PrettyPrint::GroupQueue

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - current_group()
  # -->
  # Returns the group most recently added to the stack.
  #
  # Contrived example:
  #     out = ""
  #     => ""
  #     q = PrettyPrint.new(out)
  #     => #<PrettyPrint:0x82f85c0 @output="", @maxwidth=79, @newline="\n", @genspace=#<Proc:0x82f8368@/home/vbatts/.rvm/rubies/ruby-head/lib/ruby/2.0.0/prettyprint.rb:82 (lambda)>, @output_width=0, @buffer_width=0, @buffer=[], @group_stack=[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>], @group_queue=#<PrettyPrint::GroupQueue:0x82fb7c0 @queue=[[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>]]>, @indent=0>
  #     q.group {
  #       q.text q.current_group.inspect
  #       q.text q.newline
  #       q.group(q.current_group.depth + 1) {
  #         q.text q.current_group.inspect
  #         q.text q.newline
  #         q.group(q.current_group.depth + 1) {
  #           q.text q.current_group.inspect
  #           q.text q.newline
  #           q.group(q.current_group.depth + 1) {
  #             q.text q.current_group.inspect
  #             q.text q.newline
  #           }
  #         }
  #       }
  #     }
  #     => 284
  #      puts out
  #     #<PrettyPrint::Group:0x8354758 @depth=1, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x8354550 @depth=2, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x83541cc @depth=3, @breakables=[], @break=false>
  #     #<PrettyPrint::Group:0x8347e54 @depth=4, @breakables=[], @break=false>
  #
  def current_group: () -> PrettyPrint::Group

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - break_outmost_groups()
  # -->
  # Breaks the buffer into lines that are shorter than #maxwidth
  #
  def break_outmost_groups: () -> untyped

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - text(obj, width=obj.length)
  # -->
  # This adds `obj` as a text of `width` columns in width.
  #
  # If `width` is not specified, obj.length is used.
  #
  def text: (String obj, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - fill_breakable(sep=' ', width=sep.length)
  # -->
  # This is similar to #breakable except the decision to break or not is
  # determined individually.
  #
  # Two #fill_breakable under a group may cause 4 results: (break,break),
  # (break,non-break), (non-break,break), (non-break,non-break). This is different
  # to #breakable because two #breakable under a group may cause 2 results:
  # (break,break), (non-break,non-break).
  #
  # The text `sep` is inserted if a line is not broken at this point.
  #
  # If `sep` is not specified, " " is used.
  #
  # If `width` is not specified, `sep.length` is used. You will have to specify
  # this when `sep` is a multibyte character, for example.
  #
  def fill_breakable: (?String sep, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - breakable(sep=' ', width=sep.length)
  # -->
  # This says "you can break a line here if necessary", and a `width`-column text
  # `sep` is inserted if a line is not broken at the point.
  #
  # If `sep` is not specified, " " is used.
  #
  # If `width` is not specified, `sep.length` is used. You will have to specify
  # this when `sep` is a multibyte character, for example.
  #
  def breakable: (?String sep, ?Integer width) -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - group(indent=0, open_obj='', close_obj='', open_width=open_obj.length, close_width=close_obj.length) { || ... }
  # -->
  # Groups line break hints added in the block. The line break hints are all to be
  # used or not.
  #
  # If `indent` is specified, the method call is regarded as nested by
  # nest(indent) { ... }.
  #
  # If `open_obj` is specified, `text open_obj, open_width` is called before
  # grouping. If `close_obj` is specified, `text close_obj, close_width` is called
  # after grouping.
  #
  def group: (?::Integer indent, ?::String open_obj, ?::String close_obj, ?Integer open_width, ?Integer close_width) { () -> untyped } -> Integer

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - group_sub() { || ... }
  # -->
  # Takes a block and queues a new group that is indented 1 level further.
  #
  def group_sub: () { () -> untyped } -> untyped

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - nest(indent) { || ... }
  # -->
  # Increases left margin after newline with `indent` for line breaks added in the
  # block.
  #
  def nest: (Integer indent) { () -> untyped } -> void

  # <!--
  #   rdoc-file=lib/prettyprint.rb
  #   - flush()
  # -->
  # outputs buffered data.
  #
  def flush: () -> Integer

  class Text
    def initialize: () -> void

    attr_reader width: Integer

    def output: (untyped `out`, untyped output_width) -> untyped

    def add: (untyped obj, Integer width) -> void
  end

  class Breakable
    def initialize: (String sep, Integer width, PrettyPrint q) -> void

    attr_reader obj: String

    attr_reader width: Integer

    attr_reader indent: Integer

    def output: (untyped `out`, Integer output_width) -> untyped
  end

  class Group
    def initialize: (untyped depth) -> void

    attr_reader depth: untyped

    attr_reader breakables: Array[PrettyPrint::Breakable]

    def break: () -> bool

    def break?: () -> bool

    def first?: () -> bool
  end

  class GroupQueue
    def initialize: (*untyped groups) -> void

    def enq: (untyped group) -> void

    def deq: () -> (PrettyPrint::Group | nil)

    def delete: (PrettyPrint::Group group) -> void
  end

  # <!-- rdoc-file=lib/prettyprint.rb -->
  # PrettyPrint::SingleLine is used by PrettyPrint.singleline_format
  #
  # It is passed to be similar to a PrettyPrint object itself, by responding to:
  # *   #text
  # *   #breakable
  # *   #nest
  # *   #group
  # *   #flush
  # *   #first?
  #
  #
  # but instead, the output has no line breaks
  #
  class SingleLine
    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - new(output, maxwidth=nil, newline=nil)
    # -->
    # Create a PrettyPrint::SingleLine object
    #
    # Arguments:
    # *   `output` - String (or similar) to store rendered text. Needs to respond to
    #     '<<'
    # *   `maxwidth` - Argument position expected to be here for compatibility.
    #         This argument is a noop.
    #
    # *   `newline` - Argument position expected to be here for compatibility.
    #         This argument is a noop.
    #
    def initialize: (String | untyped output, ?Integer? maxwidth, ?String? newline) -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - text(obj, width=nil)
    # -->
    # Add `obj` to the text to be output.
    #
    # `width` argument is here for compatibility. It is a noop argument.
    #
    def text: (String obj, ?Integer? width) -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - breakable(sep=' ', width=nil)
    # -->
    # Appends `sep` to the text to be output. By default `sep` is ' '
    #
    # `width` argument is here for compatibility. It is a noop argument.
    #
    def breakable: (?String sep, ?Integer? width) -> void

    def nest: (untyped indent) { () -> untyped } -> void

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - group(indent=nil, open_obj='', close_obj='', open_width=nil, close_width=nil) { || ... }
    # -->
    # Opens a block for grouping objects to be pretty printed.
    #
    # Arguments:
    # *   `indent` - noop argument. Present for compatibility.
    # *   `open_obj` - text appended before the &blok. Default is ''
    # *   `close_obj` - text appended after the &blok. Default is ''
    # *   `open_width` - noop argument. Present for compatibility.
    # *   `close_width` - noop argument. Present for compatibility.
    #
    def group: (?Integer? indent, ?String open_obj, ?String close_obj, ?Integer? open_width, ?Integer? close_width) { () -> untyped } -> untyped

    def flush: () -> nil

    # <!--
    #   rdoc-file=lib/prettyprint.rb
    #   - first?()
    # -->
    # This is used as a predicate, and ought to be called first.
    #
    def first?: () -> bool
  end
end

# <!-- rdoc-file=lib/find.rb -->
# The `Find` module supports the top-down traversal of a set of file paths.
#
# For example, to total the size of all files under your home directory,
# ignoring anything in a "dot" directory (e.g. $HOME/.ssh):
#
#     require 'find'
#
#     total_size = 0
#
#     Find.find(ENV["HOME"]) do |path|
#       if FileTest.directory?(path)
#         if File.basename(path).start_with?('.')
#           Find.prune       # Don't look any further into this directory.
#         else
#           next
#         end
#       else
#         total_size += FileTest.size(path)
#       end
#     end
#
module Find
  # <!--
  #   rdoc-file=lib/find.rb
  #   - find(*paths, ignore_error: true) { |path| ... }
  # -->
  # Calls the associated block with the name of every file and directory listed as
  # arguments, then recursively on their subdirectories, and so on.
  #
  # Returns an enumerator if no block is given.
  #
  # See the `Find` module documentation for an example.
  #
  def self?.find: (*String | _ToPath paths, ?ignore_error: boolish) -> Enumerator[String, nil]
                | (*String | _ToPath paths, ?ignore_error: boolish) { (String) -> void } -> nil

  # <!--
  #   rdoc-file=lib/find.rb
  #   - prune()
  # -->
  # Skips the current file or directory, restarting the loop with the next entry.
  # If the current file is a directory, that directory will not be recursively
  # entered. Meaningful only within the block associated with Find::find.
  #
  # See the `Find` module documentation for an example.
  #
  def self?.prune: () -> void
end

# <!-- rdoc-file=lib/benchmark.rb -->
# The Benchmark module provides methods to measure and report the time used to
# execute Ruby code.
#
# *   Measure the time to construct the string given by the expression
#     `"a"*1_000_000_000`:
#
#         require 'benchmark'
#
#         puts Benchmark.measure { "a"*1_000_000_000 }
#
#     On my machine (OSX 10.8.3 on i5 1.7 GHz) this generates:
#
#         0.350000   0.400000   0.750000 (  0.835234)
#
#     This report shows the user CPU time, system CPU time, the sum of the user
#     and system CPU times, and the elapsed real time. The unit of time is
#     seconds.
#
# *   Do some experiments sequentially using the #bm method:
#
#         require 'benchmark'
#
#         n = 5000000
#         Benchmark.bm do |x|
#           x.report { for i in 1..n; a = "1"; end }
#           x.report { n.times do   ; a = "1"; end }
#           x.report { 1.upto(n) do ; a = "1"; end }
#         end
#
#     The result:
#
#             user     system      total        real
#         1.010000   0.000000   1.010000 (  1.014479)
#         1.000000   0.000000   1.000000 (  0.998261)
#         0.980000   0.000000   0.980000 (  0.981335)
#
# *   Continuing the previous example, put a label in each report:
#
#         require 'benchmark'
#
#         n = 5000000
#         Benchmark.bm(7) do |x|
#           x.report("for:")   { for i in 1..n; a = "1"; end }
#           x.report("times:") { n.times do   ; a = "1"; end }
#           x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
#         end
#
#
# The result:
#
#                   user     system      total        real
#     for:      1.010000   0.000000   1.010000 (  1.015688)
#     times:    1.000000   0.000000   1.000000 (  1.003611)
#     upto:     1.030000   0.000000   1.030000 (  1.028098)
#
# *   The times for some benchmarks depend on the order in which items are run.
#     These differences are due to the cost of memory allocation and garbage
#     collection. To avoid these discrepancies, the #bmbm method is provided.
#     For example, to compare ways to sort an array of floats:
#
#         require 'benchmark'
#
#         array = (1..1000000).map { rand }
#
#         Benchmark.bmbm do |x|
#           x.report("sort!") { array.dup.sort! }
#           x.report("sort")  { array.dup.sort  }
#         end
#
#     The result:
#
#         Rehearsal -----------------------------------------
#         sort!   1.490000   0.010000   1.500000 (  1.490520)
#         sort    1.460000   0.000000   1.460000 (  1.463025)
#         -------------------------------- total: 2.960000sec
#
#                     user     system      total        real
#         sort!   1.460000   0.000000   1.460000 (  1.460465)
#         sort    1.450000   0.010000   1.460000 (  1.448327)
#
# *   Report statistics of sequential experiments with unique labels, using the
#     #benchmark method:
#
#         require 'benchmark'
#         include Benchmark         # we need the CAPTION and FORMAT constants
#
#         n = 5000000
#         Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
#           tf = x.report("for:")   { for i in 1..n; a = "1"; end }
#           tt = x.report("times:") { n.times do   ; a = "1"; end }
#           tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
#           [tf+tt+tu, (tf+tt+tu)/3]
#         end
#
#     The result:
#
#                      user     system      total        real
#         for:      0.950000   0.000000   0.950000 (  0.952039)
#         times:    0.980000   0.000000   0.980000 (  0.984938)
#         upto:     0.950000   0.000000   0.950000 (  0.946787)
#         >total:   2.880000   0.000000   2.880000 (  2.883764)
#         >avg:     0.960000   0.000000   0.960000 (  0.961255)
#
module Benchmark
  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - benchmark(caption = "", label_width = nil, format = nil, *labels) { |report| ... }
  # -->
  # Invokes the block with a Benchmark::Report object, which may be used to
  # collect and report on the results of individual benchmark tests. Reserves
  # `label_width` leading spaces for labels on each line. Prints `caption` at the
  # top of the report, and uses `format` to format each line. (Note: `caption`
  # must contain a terminating newline character, see the default
  # Benchmark::Tms::CAPTION for an example.)
  #
  # Returns an array of Benchmark::Tms objects.
  #
  # If the block returns an array of Benchmark::Tms objects, these will be used to
  # format additional lines of output. If `labels` parameter are given, these are
  # used to label these extra lines.
  #
  # *Note*: Other methods provide a simpler interface to this one, and are
  # suitable for nearly all benchmarking requirements.  See the examples in
  # Benchmark, and the #bm and #bmbm methods.
  #
  # Example:
  #
  #     require 'benchmark'
  #     include Benchmark          # we need the CAPTION and FORMAT constants
  #
  #     n = 5000000
  #     Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
  #       tf = x.report("for:")   { for i in 1..n; a = "1"; end }
  #       tt = x.report("times:") { n.times do   ; a = "1"; end }
  #       tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
  #       [tf+tt+tu, (tf+tt+tu)/3]
  #     end
  #
  # Generates:
  #
  #                   user     system      total        real
  #     for:      0.970000   0.000000   0.970000 (  0.970493)
  #     times:    0.990000   0.000000   0.990000 (  0.989542)
  #     upto:     0.970000   0.000000   0.970000 (  0.972854)
  #     >total:   2.930000   0.000000   2.930000 (  2.932889)
  #     >avg:     0.976667   0.000000   0.976667 (  0.977630)
  #
  def self?.benchmark: (String caption, ?Integer? label_width, ?String? format, *String labels) { (Report report) -> (Array[Tms] | void) } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - bm(label_width = 0, *labels) { |report| ... }
  # -->
  # A simple interface to the #benchmark method, #bm generates sequential reports
  # with labels. `label_width` and `labels` parameters have the same meaning as
  # for #benchmark.
  #
  #     require 'benchmark'
  #
  #     n = 5000000
  #     Benchmark.bm(7) do |x|
  #       x.report("for:")   { for i in 1..n; a = "1"; end }
  #       x.report("times:") { n.times do   ; a = "1"; end }
  #       x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
  #     end
  #
  # Generates:
  #
  #                   user     system      total        real
  #     for:      0.960000   0.000000   0.960000 (  0.957966)
  #     times:    0.960000   0.000000   0.960000 (  0.960423)
  #     upto:     0.950000   0.000000   0.950000 (  0.954864)
  #
  def self?.bm: (?Integer label_width, *String labels) { (Report report) -> void } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - bmbm(width = 0) { |job| ... }
  # -->
  # Sometimes benchmark results are skewed because code executed earlier
  # encounters different garbage collection overheads than that run later. #bmbm
  # attempts to minimize this effect by running the tests twice, the first time as
  # a rehearsal in order to get the runtime environment stable, the second time
  # for real. GC.start is executed before the start of each of the real timings;
  # the cost of this is not included in the timings. In reality, though, there's
  # only so much that #bmbm can do, and the results are not guaranteed to be
  # isolated from garbage collection and other effects.
  #
  # Because #bmbm takes two passes through the tests, it can calculate the
  # required label width.
  #
  #     require 'benchmark'
  #
  #     array = (1..1000000).map { rand }
  #
  #     Benchmark.bmbm do |x|
  #       x.report("sort!") { array.dup.sort! }
  #       x.report("sort")  { array.dup.sort  }
  #     end
  #
  # Generates:
  #
  #     Rehearsal -----------------------------------------
  #     sort!   1.440000   0.010000   1.450000 (  1.446833)
  #     sort    1.440000   0.000000   1.440000 (  1.448257)
  #     -------------------------------- total: 2.890000sec
  #
  #                 user     system      total        real
  #     sort!   1.460000   0.000000   1.460000 (  1.458065)
  #     sort    1.450000   0.000000   1.450000 (  1.455963)
  #
  # #bmbm yields a Benchmark::Job object and returns an array of Benchmark::Tms
  # objects.
  #
  def self?.bmbm: (?Integer width) { (Job job) -> void } -> Array[Tms]

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - measure(label = "") { || ... }
  # -->
  # Returns the time used to execute the given block as a Benchmark::Tms object.
  # Takes `label` option.
  #
  #     require 'benchmark'
  #
  #     n = 1000000
  #
  #     time = Benchmark.measure do
  #       n.times { a = "1" }
  #     end
  #     puts time
  #
  # Generates:
  #
  #     0.220000   0.000000   0.220000 (  0.227313)
  #
  def self?.measure: (?String label) { () -> void } -> Tms

  # <!--
  #   rdoc-file=lib/benchmark.rb
  #   - realtime() { || ... }
  # -->
  # Returns the elapsed real time used to execute the given block.
  #
  def self?.realtime: () { () -> void } -> Float

  BENCHMARK_VERSION: String

  # <!-- rdoc-file=lib/benchmark.rb -->
  # The default caption string (heading above the output times).
  #
  CAPTION: String

  # <!-- rdoc-file=lib/benchmark.rb -->
  # The default format string used to display times.  See also
  # Benchmark::Tms#format.
  #
  FORMAT: String

  class Job
    # Prints the `label` and measured time for the block,
    # formatted by `format`. See Tms#format for the
    # formatting rules.
    def item: (?String label) { () -> void } -> self

    # An array of 2-element arrays, consisting of label and block pairs.
    def list: () -> Array[untyped]

    alias report item

    # Length of the widest label in the #list.
    def width: () -> Integer
  end

  class Report
    # Prints the `label` and measured time for the block,
    # formatted by `format`. See Tms#format for the
    # formatting rules.
    def item: (?String label, *untyped format) { () -> void } -> Tms

    # An array of Benchmark::Tms objects representing each item.
    def list: () -> Array[Tms]

    alias report item
  end

  # <!-- rdoc-file=lib/benchmark.rb -->
  # A data object, representing the times associated with a benchmark measurement.
  #
  class Tms
    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - *(x)
    # -->
    # Returns a new Tms object obtained by memberwise multiplication of the
    # individual times for this Tms object by `x`.
    #
    def *: (untyped x) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - +(other)
    # -->
    # Returns a new Tms object obtained by memberwise summation of the individual
    # times for this Tms object with those of the `other` Tms object. This method
    # and #/() are useful for taking statistics.
    #
    def +: (untyped other) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - -(other)
    # -->
    # Returns a new Tms object obtained by memberwise subtraction of the individual
    # times for the `other` Tms object from those of this Tms object.
    #
    def -: (untyped other) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - /(x)
    # -->
    # Returns a new Tms object obtained by memberwise division of the individual
    # times for this Tms object by `x`. This method and #+() are useful for taking
    # statistics.
    #
    def /: (untyped x) -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - add() { || ... }
    # -->
    # Returns a new Tms object whose times are the sum of the times for this Tms
    # object, plus the time required to execute the code block (`blk`).
    #
    def add: () { (*untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - add!(&blk)
    # -->
    # An in-place version of #add. Changes the times of this Tms object by making it
    # the sum of the times for this Tms object, plus the time required to execute
    # the code block (`blk`).
    #
    def add!: () { (*untyped) -> untyped } -> untyped

    # <!-- rdoc-file=lib/benchmark.rb -->
    # System CPU time of children
    #
    def cstime: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # User CPU time of children
    #
    def cutime: () -> Float

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - format(format = nil, *args)
    # -->
    # Returns the contents of this Tms object as a formatted string, according to a
    # `format` string like that passed to Kernel.format. In addition, #format
    # accepts the following extensions:
    #
    # `%u`
    # :   Replaced by the user CPU time, as reported by Tms#utime.
    # `%y`
    # :   Replaced by the system CPU time, as reported by #stime (Mnemonic: y of
    #     "s*y*stem")
    # `%U`
    # :   Replaced by the children's user CPU time, as reported by Tms#cutime
    # `%Y`
    # :   Replaced by the children's system CPU time, as reported by Tms#cstime
    # `%t`
    # :   Replaced by the total CPU time, as reported by Tms#total
    # `%r`
    # :   Replaced by the elapsed real time, as reported by Tms#real
    # `%n`
    # :   Replaced by the label string, as reported by Tms#label (Mnemonic: n of
    #     "*n*ame")
    #
    #
    # If `format` is not given, FORMAT is used as default value, detailing the user,
    # system and real elapsed time.
    #
    def format: (?String format, *untyped args) -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Label
    #
    def label: () -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Elapsed real time
    #
    def real: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # System CPU time
    #
    def stime: () -> Float

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - to_a()
    # -->
    # Returns a new 6-element array, consisting of the label, user CPU time, system
    # CPU time, children's user CPU time, children's system CPU time and elapsed
    # real time.
    #
    def to_a: () -> untyped

    # <!--
    #   rdoc-file=lib/benchmark.rb
    #   - to_s()
    # -->
    # Same as #format.
    #
    def to_s: () -> String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Total time, that is `utime` + `stime` + `cutime` + `cstime`
    #
    def total: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # User CPU time
    #
    def utime: () -> Float

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Default caption, see also Benchmark::CAPTION
    #
    CAPTION: String

    # <!-- rdoc-file=lib/benchmark.rb -->
    # Default format string, see also Benchmark::FORMAT
    #
    FORMAT: String
  end
end

# <!-- rdoc-file=lib/securerandom.rb -->
# ## Secure random number generator interface.
#
# This library is an interface to secure random number generators which are
# suitable for generating session keys in HTTP cookies, etc.
#
# You can use this library in your application by requiring it:
#
#     require 'securerandom'
#
# It supports the following secure random number generators:
#
# *   openssl
# *   /dev/urandom
# *   Win32
#
#
# SecureRandom is extended by the Random::Formatter module which defines the
# following methods:
#
# *   alphanumeric
# *   base64
# *   choose
# *   gen_random
# *   hex
# *   rand
# *   random_bytes
# *   random_number
# *   urlsafe_base64
# *   uuid
#
#
# These methods are usable as class methods of SecureRandom such as
# `SecureRandom.hex`.
#
# If a secure random number generator is not available, `NotImplementedError` is
# raised.
#
module SecureRandom
  extend Random::Formatter

  def self.alphanumeric: (?Integer?) -> String

  def self.base64: (?Integer?) -> String

  def self.hex: (?Integer?) -> String

  def self.random_bytes: (?Integer?) -> String

  def self.random_number: () -> Float
                        | (Integer) -> Integer
                        | (Numeric) -> Numeric

  def self.urlsafe_base64: (?Integer?, ?bool?) -> String

  def self.uuid: () -> String
end

# <!-- rdoc-file=lib/base64.rb -->
# The Base64 module provides for the encoding (#encode64, #strict_encode64,
# #urlsafe_encode64) and decoding (#decode64, #strict_decode64,
# #urlsafe_decode64) of binary data using a Base64 representation.
#
# ## Example
#
# A simple encoding and decoding.
#
#     require "base64"
#
#     enc   = Base64.encode64('Send reinforcements')
#                         # -> "U2VuZCByZWluZm9yY2VtZW50cw==\n"
#     plain = Base64.decode64(enc)
#                         # -> "Send reinforcements"
#
# The purpose of using base64 to encode data is that it translates any binary
# data into purely printable characters.
#
module Base64
  # <!--
  #   rdoc-file=lib/base64.rb
  #   - decode64(str)
  # -->
  # Returns the Base64-decoded version of `str`. This method complies with RFC
  # 2045. Characters outside the base alphabet are ignored.
  #
  #     require 'base64'
  #     str = 'VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG' +
  #           'lzIGxpbmUgdHdvClRoaXMgaXMgbGlu' +
  #           'ZSB0aHJlZQpBbmQgc28gb24uLi4K'
  #     puts Base64.decode64(str)
  #
  # *Generates:*
  #
  #     This is line one
  #     This is line two
  #     This is line three
  #     And so on...
  #
  def self?.decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - encode64(bin)
  # -->
  # Returns the Base64-encoded version of `bin`. This method complies with RFC
  # 2045. Line feeds are added to every 60 encoded characters.
  #
  #     require 'base64'
  #     Base64.encode64("Now is the time for all good coders\nto learn Ruby")
  #
  # *Generates:*
  #
  #     Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g
  #     UnVieQ==
  #
  def self?.encode64: (String bin) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - strict_decode64(str)
  # -->
  # Returns the Base64-decoded version of `str`. This method complies with RFC
  # 4648. ArgumentError is raised if `str` is incorrectly padded or contains
  # non-alphabet characters.  Note that CR or LF are also rejected.
  #
  def self?.strict_decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - strict_encode64(bin)
  # -->
  # Returns the Base64-encoded version of `bin`. This method complies with RFC
  # 4648. No line feeds are added.
  #
  def self?.strict_encode64: (String bin) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - urlsafe_decode64(str)
  # -->
  # Returns the Base64-decoded version of `str`. This method complies with ``Base
  # 64 Encoding with URL and Filename Safe Alphabet'' in RFC 4648. The alphabet
  # uses '-' instead of '+' and '_' instead of '/'.
  #
  # The padding character is optional. This method accepts both correctly-padded
  # and unpadded input. Note that it still rejects incorrectly-padded input.
  #
  def self?.urlsafe_decode64: (String str) -> String

  # <!--
  #   rdoc-file=lib/base64.rb
  #   - urlsafe_encode64(bin, padding: true)
  # -->
  # Returns the Base64-encoded version of `bin`. This method complies with ``Base
  # 64 Encoding with URL and Filename Safe Alphabet'' in RFC 4648. The alphabet
  # uses '-' instead of '+' and '_' instead of '/'. Note that the result can still
  # contain '='. You can remove the padding by setting `padding` as false.
  #
  def self?.urlsafe_encode64: (String bin, ?padding: boolish) -> String
end

# <!-- rdoc-file=ext/strscan/strscan.c -->
# StringScanner provides for lexical scanning operations on a String.  Here is
# an example of its usage:
#
#     s = StringScanner.new('This is an example string')
#     s.eos?               # -> false
#
#     p s.scan(/\w+/)      # -> "This"
#     p s.scan(/\w+/)      # -> nil
#     p s.scan(/\s+/)      # -> " "
#     p s.scan(/\s+/)      # -> nil
#     p s.scan(/\w+/)      # -> "is"
#     s.eos?               # -> false
#
#     p s.scan(/\s+/)      # -> " "
#     p s.scan(/\w+/)      # -> "an"
#     p s.scan(/\s+/)      # -> " "
#     p s.scan(/\w+/)      # -> "example"
#     p s.scan(/\s+/)      # -> " "
#     p s.scan(/\w+/)      # -> "string"
#     s.eos?               # -> true
#
#     p s.scan(/\s+/)      # -> nil
#     p s.scan(/\w+/)      # -> nil
#
# Scanning a string means remembering the position of a *scan pointer*, which is
# just an index.  The point of scanning is to move forward a bit at a time, so
# matches are sought after the scan pointer; usually immediately after it.
#
# Given the string "test string", here are the pertinent scan pointer positions:
#
#       t e s t   s t r i n g
#     0 1 2 ...             1
#                           0
#
# When you #scan for a pattern (a regular expression), the match must occur at
# the character after the scan pointer.  If you use #scan_until, then the match
# can occur anywhere after the scan pointer.  In both cases, the scan pointer
# moves *just beyond* the last character of the match, ready to scan again from
# the next character onwards.  This is demonstrated by the example above.
#
# ## Method Categories
#
# There are other methods besides the plain scanners.  You can look ahead in the
# string without actually scanning.  You can access the most recent match. You
# can modify the string being scanned, reset or terminate the scanner, find out
# or change the position of the scan pointer, skip ahead, and so on.
#
# ### Advancing the Scan Pointer
#
# *   #getch
# *   #get_byte
# *   #scan
# *   #scan_until
# *   #skip
# *   #skip_until
#
#
# ### Looking Ahead
#
# *   #check
# *   #check_until
# *   #exist?
# *   #match?
# *   #peek
#
#
# ### Finding Where we Are
#
# *   #beginning_of_line? (`#bol?`)
# *   #eos?
# *   #rest?
# *   #rest_size
# *   #pos
#
#
# ### Setting Where we Are
#
# *   #reset
# *   #terminate
# *   #pos=
#
#
# ### Match Data
#
# *   #matched
# *   #matched?
# *   #matched_size
# *   `#[]`
# *   #pre_match
# *   #post_match
#
#
# ### Miscellaneous
#
# *   `<<`
# *   #concat
# *   #string
# *   #string=
# *   #unscan
#
#
# There are aliases to several of the methods.
#
class StringScanner
  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - StringScanner.must_C_version
  # -->
  # This method is defined for backward compatibility.
  #
  def self.must_C_version: () -> self

  public

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # Appends `str` to the string being scanned. This method does not affect scan
  # pointer.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/Fri /)
  #     s << " +1000 GMT"
  #     s.string            # -> "Fri Dec 12 1975 14:39 +1000 GMT"
  #     s.scan(/Dec/)       # -> "Dec"
  #
  def <<: (String) -> self

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - [](n)
  # -->
  # Returns the n-th subgroup in the most recent match.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
  #     s[0]                               # -> "Fri Dec 12 "
  #     s[1]                               # -> "Fri"
  #     s[2]                               # -> "Dec"
  #     s[3]                               # -> "12"
  #     s.post_match                       # -> "1975 14:39"
  #     s.pre_match                        # -> ""
  #
  #     s.reset
  #     s.scan(/(?<wday>\w+) (?<month>\w+) (?<day>\d+) /)       # -> "Fri Dec 12 "
  #     s[0]                               # -> "Fri Dec 12 "
  #     s[1]                               # -> "Fri"
  #     s[2]                               # -> "Dec"
  #     s[3]                               # -> "12"
  #     s[:wday]                           # -> "Fri"
  #     s[:month]                          # -> "Dec"
  #     s[:day]                            # -> "12"
  #     s.post_match                       # -> "1975 14:39"
  #     s.pre_match                        # -> ""
  #
  def []: (Integer) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - beginning_of_line?()
  # -->
  # Returns `true` if and only if the scan pointer is at the beginning of the
  # line.
  #
  #     s = StringScanner.new("test\ntest\n")
  #     s.bol?           # => true
  #     s.scan(/te/)
  #     s.bol?           # => false
  #     s.scan(/st\n/)
  #     s.bol?           # => true
  #     s.terminate
  #     s.bol?           # => true
  #
  def beginning_of_line?: () -> bool

  alias bol? beginning_of_line?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - captures
  # -->
  # Returns the subgroups in the most recent match (not including the full match).
  # If nothing was priorly matched, it returns nil.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
  #     s.captures                         # -> ["Fri", "Dec", "12"]
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> nil
  #     s.captures                         # -> nil
  #
  def captures: () -> Array[String]?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - charpos()
  # -->
  # Returns the character position of the scan pointer.  In the 'reset' position,
  # this value is zero.  In the 'terminated' position (i.e. the string is
  # exhausted), this value is the size of the string.
  #
  # In short, it's a 0-based index into the string.
  #
  #     s = StringScanner.new("abcdefghi")
  #     s.charpos           # -> 0
  #     s.scan_until(//)   # -> "abc"
  #     s.pos               # -> 5
  #     s.charpos           # -> 4
  #
  def charpos: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - check(pattern)
  # -->
  # This returns the value that #scan would return, without advancing the scan
  # pointer.  The match register is affected, though.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.check /Fri/               # -> "Fri"
  #     s.pos                       # -> 0
  #     s.matched                   # -> "Fri"
  #     s.check /12/                # -> nil
  #     s.matched                   # -> nil
  #
  # Mnemonic: it "checks" to see whether a #scan will return a value.
  #
  def check: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - check_until(pattern)
  # -->
  # This returns the value that #scan_until would return, without advancing the
  # scan pointer.  The match register is affected, though.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.check_until /12/          # -> "Fri Dec 12"
  #     s.pos                       # -> 0
  #     s.matched                   # -> 12
  #
  # Mnemonic: it "checks" to see whether a #scan_until will return a value.
  #
  def check_until: (Regexp) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - clear()
  # -->
  # Equivalent to #terminate. This method is obsolete; use #terminate instead.
  #
  def clear: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - concat(str)
  #   - <<(str)
  # -->
  # Appends `str` to the string being scanned. This method does not affect scan
  # pointer.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/Fri /)
  #     s << " +1000 GMT"
  #     s.string            # -> "Fri Dec 12 1975 14:39 +1000 GMT"
  #     s.scan(/Dec/)       # -> "Dec"
  #
  alias concat <<

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - empty?()
  # -->
  # Equivalent to #eos?. This method is obsolete, use #eos? instead.
  #
  def empty?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - eos?()
  # -->
  # Returns `true` if the scan pointer is at the end of the string.
  #
  #     s = StringScanner.new('test string')
  #     p s.eos?          # => false
  #     s.scan(/test/)
  #     p s.eos?          # => false
  #     s.terminate
  #     p s.eos?          # => true
  #
  def eos?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - exist?(pattern)
  # -->
  # Looks *ahead* to see if the `pattern` exists *anywhere* in the string, without
  # advancing the scan pointer.  This predicates whether a #scan_until will return
  # a value.
  #
  #     s = StringScanner.new('test string')
  #     s.exist? /s/            # -> 3
  #     s.scan /test/           # -> "test"
  #     s.exist? /s/            # -> 2
  #     s.exist? /e/            # -> nil
  #
  def exist?: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scanner.fixed_anchor? -> true or false
  # -->
  # Whether `scanner` uses fixed anchor mode or not.
  #
  # If fixed anchor mode is used, `\A` always matches the beginning of the string.
  # Otherwise, `\A` always matches the current position.
  #
  def fixed_anchor?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - get_byte()
  # -->
  # Scans one byte and returns it. This method is not multibyte character
  # sensitive. See also: #getch.
  #
  #     s = StringScanner.new('ab')
  #     s.get_byte         # => "a"
  #     s.get_byte         # => "b"
  #     s.get_byte         # => nil
  #
  #     s = StringScanner.new("\244\242".force_encoding("euc-jp"))
  #     s.get_byte         # => "\xA4"
  #     s.get_byte         # => "\xA2"
  #     s.get_byte         # => nil
  #
  def get_byte: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - getbyte()
  # -->
  # Equivalent to #get_byte. This method is obsolete; use #get_byte instead.
  #
  def getbyte: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - getch()
  # -->
  # Scans one character and returns it. This method is multibyte character
  # sensitive.
  #
  #     s = StringScanner.new("ab")
  #     s.getch           # => "a"
  #     s.getch           # => "b"
  #     s.getch           # => nil
  #
  #     s = StringScanner.new("\244\242".force_encoding("euc-jp"))
  #     s.getch           # => "\x{A4A2}"   # Japanese hira-kana "A" in EUC-JP
  #     s.getch           # => nil
  #
  def getch: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - inspect()
  # -->
  # Returns a string that represents the StringScanner object, showing:
  # *   the current position
  # *   the size of the string
  # *   the characters surrounding the scan pointer
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39") s.inspect            # ->
  #     '#<StringScanner 0/21 @ "Fri D...">' s.scan_until /12/    # -> "Fri Dec
  #     12" s.inspect            # -> '#<StringScanner 10/21 "...ec 12" @ "
  #     1975...">'
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - match?(pattern)
  # -->
  # Tests whether the given `pattern` is matched from the current scan pointer.
  # Returns the length of the match, or `nil`.  The scan pointer is not advanced.
  #
  #     s = StringScanner.new('test string')
  #     p s.match?(/\w+/)   # -> 4
  #     p s.match?(/\w+/)   # -> 4
  #     p s.match?("test")  # -> 4
  #     p s.match?(/\s+/)   # -> nil
  #
  def match?: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched()
  # -->
  # Returns the last matched string.
  #
  #     s = StringScanner.new('test string')
  #     s.match?(/\w+/)     # -> 4
  #     s.matched           # -> "test"
  #
  def matched: () -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched?()
  # -->
  # Returns `true` if and only if the last match was successful.
  #
  #     s = StringScanner.new('test string')
  #     s.match?(/\w+/)     # => 4
  #     s.matched?          # => true
  #     s.match?(/\d+/)     # => nil
  #     s.matched?          # => false
  #
  def matched?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - matched_size()
  # -->
  # Returns the size of the most recent match in bytes, or `nil` if there was no
  # recent match.  This is different than `matched.size`, which will return the
  # size in characters.
  #
  #     s = StringScanner.new('test string')
  #     s.check /\w+/           # -> "test"
  #     s.matched_size          # -> 4
  #     s.check /\d+/           # -> nil
  #     s.matched_size          # -> nil
  #
  def matched_size: () -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - peek(len)
  # -->
  # Extracts a string corresponding to `string[pos,len]`, without advancing the
  # scan pointer.
  #
  #     s = StringScanner.new('test string')
  #     s.peek(7)          # => "test st"
  #     s.peek(7)          # => "test st"
  #
  def peek: (Integer) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - peep(p1)
  # -->
  # Equivalent to #peek. This method is obsolete; use #peek instead.
  #
  def peep: (Integer) -> String

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # Returns the byte position of the scan pointer.  In the 'reset' position, this
  # value is zero.  In the 'terminated' position (i.e. the string is exhausted),
  # this value is the bytesize of the string.
  #
  # In short, it's a 0-based index into bytes of the string.
  #
  #     s = StringScanner.new('test string')
  #     s.pos               # -> 0
  #     s.scan_until /str/  # -> "test str"
  #     s.pos               # -> 8
  #     s.terminate         # -> #<StringScanner fin>
  #     s.pos               # -> 11
  #
  def pointer: () -> Integer

  # <!-- rdoc-file=ext/strscan/strscan.c -->
  # Sets the byte position of the scan pointer.
  #
  #     s = StringScanner.new('test string')
  #     s.pos = 7            # -> 7
  #     s.rest               # -> "ring"
  #
  def pointer=: (Integer) -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pos()
  # -->
  # Returns the byte position of the scan pointer.  In the 'reset' position, this
  # value is zero.  In the 'terminated' position (i.e. the string is exhausted),
  # this value is the bytesize of the string.
  #
  # In short, it's a 0-based index into bytes of the string.
  #
  #     s = StringScanner.new('test string')
  #     s.pos               # -> 0
  #     s.scan_until /str/  # -> "test str"
  #     s.pos               # -> 8
  #     s.terminate         # -> #<StringScanner fin>
  #     s.pos               # -> 11
  #
  def pos: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pos=(n)
  # -->
  # Sets the byte position of the scan pointer.
  #
  #     s = StringScanner.new('test string')
  #     s.pos = 7            # -> 7
  #     s.rest               # -> "ring"
  #
  def pos=: (Integer) -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - post_match()
  # -->
  # Returns the ***post**-match* (in the regular expression sense) of the last
  # scan.
  #
  #     s = StringScanner.new('test string')
  #     s.scan(/\w+/)           # -> "test"
  #     s.scan(/\s+/)           # -> " "
  #     s.pre_match             # -> "test"
  #     s.post_match            # -> "string"
  #
  def post_match: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - pre_match()
  # -->
  # Returns the ***pre**-match* (in the regular expression sense) of the last
  # scan.
  #
  #     s = StringScanner.new('test string')
  #     s.scan(/\w+/)           # -> "test"
  #     s.scan(/\s+/)           # -> " "
  #     s.pre_match             # -> "test"
  #     s.post_match            # -> "string"
  #
  def pre_match: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - reset()
  # -->
  # Reset the scan pointer (index 0) and clear matching data.
  #
  def reset: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest()
  # -->
  # Returns the "rest" of the string (i.e. everything after the scan pointer). If
  # there is no more data (eos? = true), it returns `""`.
  #
  def rest: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest?()
  # -->
  # Returns true if and only if there is more data in the string.  See #eos?. This
  # method is obsolete; use #eos? instead.
  #
  #     s = StringScanner.new('test string')
  #     s.eos?              # These two
  #     s.rest?             # are opposites.
  #
  def rest?: () -> bool

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - rest_size()
  # -->
  # `s.rest_size` is equivalent to `s.rest.size`.
  #
  def rest_size: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - restsize()
  # -->
  # `s.restsize` is equivalent to `s.rest_size`. This method is obsolete; use
  # #rest_size instead.
  #
  def restsize: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan(pattern) => String
  # -->
  # Tries to match with `pattern` at the current position. If there's a match, the
  # scanner advances the "scan pointer" and returns the matched string. Otherwise,
  # the scanner returns `nil`.
  #
  #     s = StringScanner.new('test string')
  #     p s.scan(/\w+/)   # -> "test"
  #     p s.scan(/\w+/)   # -> nil
  #     p s.scan(/\s+/)   # -> " "
  #     p s.scan("str")   # -> "str"
  #     p s.scan(/\w+/)   # -> "ing"
  #     p s.scan(/./)     # -> nil
  #
  def scan: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan_full(pattern, advance_pointer_p, return_string_p)
  # -->
  # Tests whether the given `pattern` is matched from the current scan pointer.
  # Advances the scan pointer if `advance_pointer_p` is true. Returns the matched
  # string if `return_string_p` is true. The match register is affected.
  #
  # "full" means "#scan with full parameters".
  #
  def scan_full: (Regexp pattern, bool advance_pointer_p, bool return_string_p) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scan_until(pattern)
  # -->
  # Scans the string *until* the `pattern` is matched.  Returns the substring up
  # to and including the end of the match, advancing the scan pointer to that
  # location. If there is no match, `nil` is returned.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan_until(/1/)        # -> "Fri Dec 1"
  #     s.pre_match              # -> "Fri Dec "
  #     s.scan_until(/XYZ/)      # -> nil
  #
  def scan_until: (Regexp) -> String?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - search_full(pattern, advance_pointer_p, return_string_p)
  # -->
  # Scans the string *until* the `pattern` is matched. Advances the scan pointer
  # if `advance_pointer_p`, otherwise not. Returns the matched string if
  # `return_string_p` is true, otherwise returns the number of bytes advanced.
  # This method does affect the match register.
  #
  def search_full: (Regexp pattern, bool advance_pointer_p, bool return_string_p) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - size
  # -->
  # Returns the amount of subgroups in the most recent match. The full match
  # counts as a subgroup.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
  #     s.size                             # -> 4
  #
  def size: () -> Integer

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - skip(pattern)
  # -->
  # Attempts to skip over the given `pattern` beginning with the scan pointer. If
  # it matches, the scan pointer is advanced to the end of the match, and the
  # length of the match is returned.  Otherwise, `nil` is returned.
  #
  # It's similar to #scan, but without returning the matched string.
  #
  #     s = StringScanner.new('test string')
  #     p s.skip(/\w+/)   # -> 4
  #     p s.skip(/\w+/)   # -> nil
  #     p s.skip(/\s+/)   # -> 1
  #     p s.skip("st")    # -> 2
  #     p s.skip(/\w+/)   # -> 4
  #     p s.skip(/./)     # -> nil
  #
  def skip: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - skip_until(pattern)
  # -->
  # Advances the scan pointer until `pattern` is matched and consumed.  Returns
  # the number of bytes advanced, or `nil` if no match was found.
  #
  # Look ahead to match `pattern`, and advance the scan pointer to the *end* of
  # the match.  Return the number of characters advanced, or `nil` if the match
  # was unsuccessful.
  #
  # It's similar to #scan_until, but without returning the intervening string.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.skip_until /12/           # -> 10
  #     s                           #
  #
  def skip_until: (Regexp) -> Integer?

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - string()
  # -->
  # Returns the string being scanned.
  #
  def string: () -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - string=(str)
  # -->
  # Changes the string being scanned to `str` and resets the scanner. Returns
  # `str`.
  #
  def string=: (String) -> String

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - terminate
  #   - clear
  # -->
  # Sets the scan pointer to the end of the string and clear matching data.
  #
  def terminate: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - unscan()
  # -->
  # Sets the scan pointer to the previous position.  Only one previous position is
  # remembered, and it changes with each scanning operation.
  #
  #     s = StringScanner.new('test string')
  #     s.scan(/\w+/)        # => "test"
  #     s.unscan
  #     s.scan(/../)         # => "te"
  #     s.scan(/\d/)         # => nil
  #     s.unscan             # ScanError: unscan failed: previous match record not exist
  #
  def unscan: () -> void

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - scanner.values_at( i1, i2, ... iN )   -> an_array
  # -->
  # Returns the subgroups in the most recent match at the given indices. If
  # nothing was priorly matched, it returns nil.
  #
  #     s = StringScanner.new("Fri Dec 12 1975 14:39")
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
  #     s.values_at 0, -1, 5, 2            # -> ["Fri Dec 12 ", "12", nil, "Dec"]
  #     s.scan(/(\w+) (\w+) (\d+) /)       # -> nil
  #     s.values_at 0, -1, 5, 2            # -> nil
  #
  def values_at: (*Integer) -> Array[String]?

  private

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - StringScanner.new(string, fixed_anchor: false)
  #   - StringScanner.new(string, dup = false)
  # -->
  # Creates a new StringScanner object to scan over the given `string`.
  #
  # If `fixed_anchor` is `true`, `\A` always matches the beginning of the string.
  # Otherwise, `\A` always matches the current position.
  #
  # `dup` argument is obsolete and not used now.
  #
  def initialize: (String, ?bool dup, ?fixed_anchor: bool) -> untyped

  # <!--
  #   rdoc-file=ext/strscan/strscan.c
  #   - dup
  #   - clone
  # -->
  # Duplicates a StringScanner object.
  #
  def initialize_copy: (StringScanner) -> void
end

StringScanner::Id: String

StringScanner::Version: String

# <!-- rdoc-file=lib/timeout.rb -->
# Timeout long-running blocks
#
# ## Synopsis
#
#     require 'timeout'
#     status = Timeout::timeout(5) {
#       # Something that should be interrupted if it takes more than 5 seconds...
#     }
#
# ## Description
#
# Timeout provides a way to auto-terminate a potentially long-running operation
# if it hasn't finished in a fixed amount of time.
#
# Previous versions didn't use a module for namespacing, however #timeout is
# provided for backwards compatibility.  You should prefer Timeout.timeout
# instead.
#
# ## Copyright
#
# Copyright
# :   (C) 2000  Network Applied Communication Laboratory, Inc.
# Copyright
# :   (C) 2000  Information-technology Promotion Agency, Japan
#
module Timeout
  # <!--
  #   rdoc-file=lib/timeout.rb
  #   - timeout(sec, klass = nil, message = nil) { |sec| ... }
  # -->
  # Perform an operation in a block, raising an error if it takes longer than
  # `sec` seconds to complete.
  #
  # `sec`
  # :   Number of seconds to wait for the block to terminate. Any number may be
  #     used, including Floats to specify fractional seconds. A value of 0 or
  #     `nil` will execute the block without any timeout.
  # `klass`
  # :   Exception Class to raise if the block fails to terminate in `sec` seconds.
  #      Omitting will use the default, Timeout::Error
  # `message`
  # :   Error message to raise with Exception Class. Omitting will use the
  #     default, "execution expired"
  #
  #
  # Returns the result of the block **if** the block completed before `sec`
  # seconds, otherwise throws an exception, based on the value of `klass`.
  #
  # The exception thrown to terminate the given block cannot be rescued inside the
  # block unless `klass` is given explicitly. However, the block can use ensure to
  # prevent the handling of the exception.  For that reason, this method cannot be
  # relied on to enforce timeouts for untrusted blocks.
  #
  # If a scheduler is defined, it will be used to handle the timeout by invoking
  # Scheduler#timeout_after.
  #
  # Note that this is both a method of module Timeout, so you can `include
  # Timeout` into your classes so they have a #timeout method, as well as a module
  # method, so you can call it directly as Timeout.timeout().
  #
  def self?.timeout: [T] (Numeric? sec, ?singleton(Exception) klass, ?String message) { (Numeric sec) -> T } -> T
end

# <!-- rdoc-file=lib/timeout.rb -->
# Raised by Timeout.timeout when the block times out.
#
class Timeout::Error < RuntimeError
  attr_reader thread: Thread?
end

Timeout::VERSION: String

# <!-- rdoc-file=ext/date/date_core.c -->
# date and datetime class - Tadayoshi Funaba 1998-2011
#
# 'date' provides two classes: Date and DateTime.
#
# ## Terms and Definitions
#
# Some terms and definitions are based on ISO 8601 and JIS X 0301.
#
# ### Calendar Date
#
# The calendar date is a particular day of a calendar year, identified by its
# ordinal number within a calendar month within that year.
#
# In those classes, this is so-called "civil".
#
# ### Ordinal Date
#
# The ordinal date is a particular day of a calendar year identified by its
# ordinal number within the year.
#
# In those classes, this is so-called "ordinal".
#
# ### Week Date
#
# The week date is a date identified by calendar week and day numbers.
#
# The calendar week is a seven day period within a calendar year, starting on a
# Monday and identified by its ordinal number within the year; the first
# calendar week of the year is the one that includes the first Thursday of that
# year. In the Gregorian calendar, this is equivalent to the week which includes
# January 4.
#
# In those classes, this is so-called "commercial".
#
# ### Julian Day Number
#
# The Julian day number is in elapsed days since noon (Greenwich Mean Time) on
# January 1, 4713 BCE (in the Julian calendar).
#
# In this document, the astronomical Julian day number is the same as the
# original Julian day number. And the chronological Julian day number is a
# variation of the Julian day number. Its days begin at midnight on local time.
#
# In this document, when the term "Julian day number" simply appears, it just
# refers to "chronological Julian day number", not the original.
#
# In those classes, those are so-called "ajd" and "jd".
#
# ### Modified Julian Day Number
#
# The modified Julian day number is in elapsed days since midnight (Coordinated
# Universal Time) on November 17, 1858 CE (in the Gregorian calendar).
#
# In this document, the astronomical modified Julian day number is the same as
# the original modified Julian day number. And the chronological modified Julian
# day number is a variation of the modified Julian day number. Its days begin at
# midnight on local time.
#
# In this document, when the term "modified Julian day number" simply appears,
# it just refers to "chronological modified Julian day number", not the
# original.
#
# In those classes, those are so-called "amjd" and "mjd".
#
# ## Date
#
# A subclass of Object that includes the Comparable module and easily handles
# date.
#
# A Date object is created with Date::new, Date::jd, Date::ordinal,
# Date::commercial, Date::parse, Date::strptime, Date::today, Time#to_date, etc.
#
#     require 'date'
#
#     Date.new(2001,2,3)
#      #=> #<Date: 2001-02-03 ...>
#     Date.jd(2451944)
#      #=> #<Date: 2001-02-03 ...>
#     Date.ordinal(2001,34)
#      #=> #<Date: 2001-02-03 ...>
#     Date.commercial(2001,5,6)
#      #=> #<Date: 2001-02-03 ...>
#     Date.parse('2001-02-03')
#      #=> #<Date: 2001-02-03 ...>
#     Date.strptime('03-02-2001', '%d-%m-%Y')
#      #=> #<Date: 2001-02-03 ...>
#     Time.new(2001,2,3).to_date
#      #=> #<Date: 2001-02-03 ...>
#
# All date objects are immutable; hence cannot modify themselves.
#
# The concept of a date object can be represented as a tuple of the day count,
# the offset and the day of calendar reform.
#
# The day count denotes the absolute position of a temporal dimension. The
# offset is relative adjustment, which determines decoded local time with the
# day count. The day of calendar reform denotes the start day of the new style.
# The old style of the West is the Julian calendar which was adopted by Caesar.
# The new style is the Gregorian calendar, which is the current civil calendar
# of many countries.
#
# The day count is virtually the astronomical Julian day number. The offset in
# this class is usually zero, and cannot be specified directly.
#
# A Date object can be created with an optional argument, the day of calendar
# reform as a Julian day number, which should be 2298874 to 2426355 or
# negative/positive infinity. The default value is `Date::ITALY`
# (2299161=1582-10-15). See also sample/cal.rb.
#
#     $ ruby sample/cal.rb -c it 10 1582
#         October 1582
#      S  M Tu  W Th  F  S
#         1  2  3  4 15 16
#     17 18 19 20 21 22 23
#     24 25 26 27 28 29 30
#     31
#
#     $ ruby sample/cal.rb -c gb  9 1752
#        September 1752
#      S  M Tu  W Th  F  S
#            1  2 14 15 16
#     17 18 19 20 21 22 23
#     24 25 26 27 28 29 30
#
# A Date object has various methods. See each reference.
#
#     d = Date.parse('3rd Feb 2001')
#                                  #=> #<Date: 2001-02-03 ...>
#     d.year                       #=> 2001
#     d.mon                        #=> 2
#     d.mday                       #=> 3
#     d.wday                       #=> 6
#     d += 1                       #=> #<Date: 2001-02-04 ...>
#     d.strftime('%a %d %b %Y')    #=> "Sun 04 Feb 2001"
#
class Date
  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)
  # -->
  #
  def initialize: (?Integer year, ?Integer month, ?Integer mday, ?Integer start) -> void

  include Comparable

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._httpdate(string, limit: 128)  ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._httpdate: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._iso8601(string, limit: 128)  ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._iso8601: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._jisx0301(string, limit: 128)  ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._jisx0301: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._parse(string[, comp=true], limit: 128)  ->  hash
  # -->
  # Parses the given representation of date and time, and returns a hash of parsed
  # elements.
  #
  # This method *does not* function as a validator.  If the input string does not
  # match valid formats strictly, you may get a cryptic result.  Should consider
  # to use `Date._strptime` or `DateTime._strptime` instead of this method as
  # possible.
  #
  # If the optional second argument is true and the detected year is in the range
  # "00" to "99", considers the year a 2-digit form and makes it full.
  #
  #     Date._parse('2001-02-03') #=> {:year=>2001, :mon=>2, :mday=>3}
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._parse: (String str, ?boolish complete) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc2822(string, limit: 128)  ->  hash
  #   - Date._rfc822(string, limit: 128)   ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._rfc2822: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc3339(string, limit: 128)  ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._rfc3339: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._rfc2822(string, limit: 128)  ->  hash
  #   - Date._rfc822(string, limit: 128)   ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._rfc822: (String str) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._strptime(string[, format='%F'])  ->  hash
  # -->
  # Parses the given representation of date and time with the given template, and
  # returns a hash of parsed elements.  _strptime does not support specification
  # of flags and width unlike strftime.
  #
  #     Date._strptime('2001-02-03', '%Y-%m-%d')
  #                               #=> {:year=>2001, :mon=>2, :mday=>3}
  #
  # See also strptime(3) and #strftime.
  #
  def self._strptime: (String str, ?String format) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date._xmlschema(string, limit: 128)  ->  hash
  # -->
  # Returns a hash of parsed elements.
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self._xmlschema: (String str) -> Hash[Symbol, Integer]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.civil([year=-4712[, month=1[, mday=1[, start=Date::ITALY]]]])  ->  date
  #   - Date.new([year=-4712[, month=1[, mday=1[, start=Date::ITALY]]]])    ->  date
  # -->
  # Creates a date object denoting the given calendar date.
  #
  # In this class, BCE years are counted astronomically.  Thus, the year before
  # the year 1 is the year zero, and the year preceding the year zero is the year
  # -1.  The month and the day of month should be a negative or a positive number
  # (as a relative month/day from the end of year/month when negative).  They
  # should not be zero.
  #
  # The last argument should be a Julian day number which denotes the day of
  # calendar reform.  Date::ITALY (2299161=1582-10-15), Date::ENGLAND
  # (2361222=1752-09-14), Date::GREGORIAN (the proleptic Gregorian calendar) and
  # Date::JULIAN (the proleptic Julian calendar) can be specified as a day of
  # calendar reform.
  #
  #     Date.new(2001)            #=> #<Date: 2001-01-01 ...>
  #     Date.new(2001,2,3)        #=> #<Date: 2001-02-03 ...>
  #     Date.new(2001,2,-1)       #=> #<Date: 2001-02-28 ...>
  #
  # See also ::jd.
  #
  def self.civil: (?Integer year, ?Integer month, ?Integer mday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.commercial([cwyear=-4712[, cweek=1[, cwday=1[, start=Date::ITALY]]]])  ->  date
  # -->
  # Creates a date object denoting the given week date.
  #
  # The week and the day of week should be a negative or a positive number (as a
  # relative week/day from the end of year/week when negative).  They should not
  # be zero.
  #
  #     Date.commercial(2001)     #=> #<Date: 2001-01-01 ...>
  #     Date.commercial(2002)     #=> #<Date: 2001-12-31 ...>
  #     Date.commercial(2001,5,6) #=> #<Date: 2001-02-03 ...>
  #
  # See also ::jd and ::new.
  #
  def self.commercial: (?Integer cwyear, ?Integer cweek, ?Integer cwday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.gregorian_leap?(year)  ->  bool
  #   - Date.leap?(year)            ->  bool
  # -->
  # Returns true if the given year is a leap year of the proleptic Gregorian
  # calendar.
  #
  #     Date.gregorian_leap?(1900)        #=> false
  #     Date.gregorian_leap?(2000)        #=> true
  #
  def self.gregorian_leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.httpdate(string='Mon, 01 Jan -4712 00:00:00 GMT'[, start=Date::ITALY], limit: 128)  ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some RFC 2616
  # format.
  #
  #     Date.httpdate('Sat, 03 Feb 2001 00:00:00 GMT')
  #                                               #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.httpdate: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.iso8601(string='-4712-01-01'[, start=Date::ITALY], limit: 128)  ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # ISO 8601 formats.
  #
  #     Date.iso8601('2001-02-03')        #=> #<Date: 2001-02-03 ...>
  #     Date.iso8601('20010203')          #=> #<Date: 2001-02-03 ...>
  #     Date.iso8601('2001-W05-6')        #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.iso8601: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.jd([jd=0[, start=Date::ITALY]])  ->  date
  # -->
  # Creates a date object denoting the given chronological Julian day number.
  #
  #     Date.jd(2451944)          #=> #<Date: 2001-02-03 ...>
  #     Date.jd(2451945)          #=> #<Date: 2001-02-04 ...>
  #     Date.jd(0)                #=> #<Date: -4712-01-01 ...>
  #
  # See also ::new.
  #
  def self.jd: (Integer jd, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.jisx0301(string='-4712-01-01'[, start=Date::ITALY], limit: 128)  ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # JIS X 0301 formats.
  #
  #     Date.jisx0301('H13.02.03')                #=> #<Date: 2001-02-03 ...>
  #
  # For no-era year, legacy format, Heisei is assumed.
  #
  #     Date.jisx0301('13.02.03')                 #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.jisx0301: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.julian_leap?(year)  ->  bool
  # -->
  # Returns true if the given year is a leap year of the proleptic Julian
  # calendar.
  #
  #     Date.julian_leap?(1900)           #=> true
  #     Date.julian_leap?(1901)           #=> false
  #
  def self.julian_leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.gregorian_leap?(year)  ->  bool
  #   - Date.leap?(year)            ->  bool
  # -->
  # Returns true if the given year is a leap year of the proleptic Gregorian
  # calendar.
  #
  #     Date.gregorian_leap?(1900)        #=> false
  #     Date.gregorian_leap?(2000)        #=> true
  #
  def self.leap?: (Integer year) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.ordinal([year=-4712[, yday=1[, start=Date::ITALY]]])  ->  date
  # -->
  # Creates a date object denoting the given ordinal date.
  #
  # The day of year should be a negative or a positive number (as a relative day
  # from the end of year when negative).  It should not be zero.
  #
  #     Date.ordinal(2001)        #=> #<Date: 2001-01-01 ...>
  #     Date.ordinal(2001,34)     #=> #<Date: 2001-02-03 ...>
  #     Date.ordinal(2001,-1)     #=> #<Date: 2001-12-31 ...>
  #
  # See also ::jd and ::new.
  #
  def self.ordinal: (?Integer year, ?Integer yday, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.parse(string='-4712-01-01'[, comp=true[, start=Date::ITALY]], limit: 128)  ->  date
  # -->
  # Parses the given representation of date and time, and creates a date object.
  #
  # This method *does not* function as a validator.  If the input string does not
  # match valid formats strictly, you may get a cryptic result.  Should consider
  # to use `Date.strptime` instead of this method as possible.
  #
  # If the optional second argument is true and the detected year is in the range
  # "00" to "99", considers the year a 2-digit form and makes it full.
  #
  #     Date.parse('2001-02-03')          #=> #<Date: 2001-02-03 ...>
  #     Date.parse('20010203')            #=> #<Date: 2001-02-03 ...>
  #     Date.parse('3rd Feb 2001')        #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.parse: (String str, ?boolish complete, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  date
  #   - Date.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # RFC 2822 formats.
  #
  #     Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
  #                                               #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc2822: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc3339(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # RFC 3339 formats.
  #
  #     Date.rfc3339('2001-02-03T04:05:06+07:00') #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc3339: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  date
  #   - Date.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # RFC 2822 formats.
  #
  #     Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
  #                                               #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc822: (String str, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.strptime([string='-4712-01-01'[, format='%F'[, start=Date::ITALY]]])  ->  date
  # -->
  # Parses the given representation of date and time with the given template, and
  # creates a date object.  strptime does not support specification of flags and
  # width unlike strftime.
  #
  #     Date.strptime('2001-02-03', '%Y-%m-%d')   #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('03-02-2001', '%d-%m-%Y')   #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('2001-034', '%Y-%j')        #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('2001-W05-6', '%G-W%V-%u')  #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('2001 04 6', '%Y %U %w')    #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('2001 05 6', '%Y %W %u')    #=> #<Date: 2001-02-03 ...>
  #     Date.strptime('sat3feb01', '%a%d%b%y')    #=> #<Date: 2001-02-03 ...>
  #
  # See also strptime(3) and #strftime.
  #
  def self.strptime: (String str, ?String format, ?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.today([start=Date::ITALY])  ->  date
  # -->
  # Creates a date object denoting the present day.
  #
  #     Date.today   #=> #<Date: 2011-06-11 ...>
  #
  def self.today: (?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_civil?(year, month, mday[, start=Date::ITALY])  ->  bool
  #   - Date.valid_date?(year, month, mday[, start=Date::ITALY])   ->  bool
  # -->
  # Returns true if the given calendar date is valid, and false if not. Valid in
  # this context is whether the arguments passed to this method would be accepted
  # by ::new.
  #
  #     Date.valid_date?(2001,2,3)        #=> true
  #     Date.valid_date?(2001,2,29)       #=> false
  #     Date.valid_date?(2001,2,-1)       #=> true
  #
  # See also ::jd and ::civil.
  #
  def self.valid_civil?: (Integer year, Integer month, Integer mday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_commercial?(cwyear, cweek, cwday[, start=Date::ITALY])  ->  bool
  # -->
  # Returns true if the given week date is valid, and false if not.
  #
  #     Date.valid_commercial?(2001,5,6)  #=> true
  #     Date.valid_commercial?(2001,5,8)  #=> false
  #
  # See also ::jd and ::commercial.
  #
  def self.valid_commercial?: (Integer cwyear, Integer cweek, Integer cwday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_civil?(year, month, mday[, start=Date::ITALY])  ->  bool
  #   - Date.valid_date?(year, month, mday[, start=Date::ITALY])   ->  bool
  # -->
  # Returns true if the given calendar date is valid, and false if not. Valid in
  # this context is whether the arguments passed to this method would be accepted
  # by ::new.
  #
  #     Date.valid_date?(2001,2,3)        #=> true
  #     Date.valid_date?(2001,2,29)       #=> false
  #     Date.valid_date?(2001,2,-1)       #=> true
  #
  # See also ::jd and ::civil.
  #
  def self.valid_date?: (Integer year, Integer month, Integer mday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_jd?(jd[, start=Date::ITALY])  ->  bool
  # -->
  # Just returns true.  It's nonsense, but is for symmetry.
  #
  #     Date.valid_jd?(2451944)           #=> true
  #
  # See also ::jd.
  #
  def self.valid_jd?: (Integer jd, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.valid_ordinal?(year, yday[, start=Date::ITALY])  ->  bool
  # -->
  # Returns true if the given ordinal date is valid, and false if not.
  #
  #     Date.valid_ordinal?(2001,34)      #=> true
  #     Date.valid_ordinal?(2001,366)     #=> false
  #
  # See also ::jd and ::ordinal.
  #
  def self.valid_ordinal?: (Integer year, Integer yday, ?Integer start) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - Date.xmlschema(string='-4712-01-01'[, start=Date::ITALY], limit: 128)  ->  date
  # -->
  # Creates a new Date object by parsing from a string according to some typical
  # XML Schema formats.
  #
  #     Date.xmlschema('2001-02-03')      #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.xmlschema: (String str, ?Integer start) -> Date

  public

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d + other  ->  date
  # -->
  # Returns a date object pointing `other` days after self.  The other should be a
  # numeric value.  If the other is a fractional number, assumes its precision is
  # at most nanosecond.
  #
  #     Date.new(2001,2,3) + 1    #=> #<Date: 2001-02-04 ...>
  #     DateTime.new(2001,2,3) + Rational(1,2)
  #                               #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>
  #     DateTime.new(2001,2,3) + Rational(-1,2)
  #                               #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
  #     DateTime.jd(0,12) + DateTime.new(2001,2,3).ajd
  #                               #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #
  def +: (Numeric & _ToR other) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d - other  ->  date or rational
  # -->
  # Returns the difference between the two dates if the other is a date object.
  # If the other is a numeric value, returns a date object pointing `other` days
  # before self.  If the other is a fractional number, assumes its precision is at
  # most nanosecond.
  #
  #     Date.new(2001,2,3) - 1   #=> #<Date: 2001-02-02 ...>
  #     DateTime.new(2001,2,3) - Rational(1,2)
  #                              #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
  #     Date.new(2001,2,3) - Date.new(2001)
  #                              #=> (33/1)
  #     DateTime.new(2001,2,3) - DateTime.new(2001,2,2,12)
  #                              #=> (1/2)
  #
  def -: (Numeric & _ToR other) -> Date
       | (Date other) -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d << n  ->  date
  # -->
  # Returns a date object pointing `n` months before self. The argument `n` should
  # be a numeric value.
  #
  #     Date.new(2001,2,3)  <<  1   #=> #<Date: 2001-01-03 ...>
  #     Date.new(2001,2,3)  << -2   #=> #<Date: 2001-04-03 ...>
  #
  # When the same day does not exist for the corresponding month, the last day of
  # the month is used instead:
  #
  #     Date.new(2001,3,28) << 1   #=> #<Date: 2001-02-28 ...>
  #     Date.new(2001,3,31) << 1   #=> #<Date: 2001-02-28 ...>
  #
  # This also results in the following, possibly unexpected, behavior:
  #
  #     Date.new(2001,3,31) << 2         #=> #<Date: 2001-01-31 ...>
  #     Date.new(2001,3,31) << 1 << 1    #=> #<Date: 2001-01-28 ...>
  #
  #     Date.new(2001,3,31) << 1 << -1   #=> #<Date: 2001-03-28 ...>
  #
  def <<: (Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d <=> other  -> -1, 0, +1 or nil
  # -->
  # Compares the two dates and returns -1, zero, 1 or nil.  The other should be a
  # date object or a numeric value as an astronomical Julian day number.
  #
  #     Date.new(2001,2,3) <=> Date.new(2001,2,4)   #=> -1
  #     Date.new(2001,2,3) <=> Date.new(2001,2,3)   #=> 0
  #     Date.new(2001,2,3) <=> Date.new(2001,2,2)   #=> 1
  #     Date.new(2001,2,3) <=> Object.new           #=> nil
  #     Date.new(2001,2,3) <=> Rational(4903887,2)  #=> 0
  #
  # See also Comparable.
  #
  def <=>: (untyped other) -> Integer?

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d === other  ->  bool
  # -->
  # Returns true if they are the same day.
  #
  #     Date.new(2001,2,3) === Date.new(2001,2,3)
  #                                       #=> true
  #     Date.new(2001,2,3) === Date.new(2001,2,4)
  #                                       #=> false
  #     DateTime.new(2001,2,3) === DateTime.new(2001,2,3,12)
  #                                       #=> true
  #     DateTime.new(2001,2,3) === DateTime.new(2001,2,3,0,0,0,'+24:00')
  #                                       #=> true
  #     DateTime.new(2001,2,3) === DateTime.new(2001,2,4,0,0,0,'+24:00')
  #                                       #=> false
  #
  def ===: (Date other) -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d >> n  ->  date
  # -->
  # Returns a date object pointing `n` months after self. The argument `n` should
  # be a numeric value.
  #
  #     Date.new(2001,2,3)  >>  1   #=> #<Date: 2001-03-03 ...>
  #     Date.new(2001,2,3)  >> -2   #=> #<Date: 2000-12-03 ...>
  #
  # When the same day does not exist for the corresponding month, the last day of
  # the month is used instead:
  #
  #     Date.new(2001,1,28) >> 1   #=> #<Date: 2001-02-28 ...>
  #     Date.new(2001,1,31) >> 1   #=> #<Date: 2001-02-28 ...>
  #
  # This also results in the following, possibly unexpected, behavior:
  #
  #     Date.new(2001,1,31) >> 2         #=> #<Date: 2001-03-31 ...>
  #     Date.new(2001,1,31) >> 1 >> 1    #=> #<Date: 2001-03-28 ...>
  #
  #     Date.new(2001,1,31) >> 1 >> -1   #=> #<Date: 2001-01-28 ...>
  #
  def >>: (Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.ajd  ->  rational
  # -->
  # Returns the astronomical Julian day number.  This is a fractional number,
  # which is not adjusted by the offset.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').ajd     #=> (11769328217/4800)
  #     DateTime.new(2001,2,2,14,5,6,'-7').ajd    #=> (11769328217/4800)
  #
  def ajd: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.amjd  ->  rational
  # -->
  # Returns the astronomical modified Julian day number.  This is a fractional
  # number, which is not adjusted by the offset.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').amjd    #=> (249325817/4800)
  #     DateTime.new(2001,2,2,14,5,6,'-7').amjd   #=> (249325817/4800)
  #
  def amjd: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.asctime  ->  string
  #   - d.ctime    ->  string
  # -->
  # Returns a string in asctime(3) format (but without "n\0" at the end).  This
  # method is equivalent to strftime('%c').
  #
  # See also asctime(3) or ctime(3).
  #
  def asctime: () -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns a string in asctime(3) format (but without "n\0" at the end).  This
  # method is equivalent to strftime('%c').
  #
  # See also asctime(3) or ctime(3).
  #
  def ctime: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.cwday  ->  fixnum
  # -->
  # Returns the day of calendar week (1-7, Monday is 1).
  #
  #     Date.new(2001,2,3).cwday          #=> 6
  #
  def cwday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.cweek  ->  fixnum
  # -->
  # Returns the calendar week number (1-53).
  #
  #     Date.new(2001,2,3).cweek          #=> 5
  #
  def cweek: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.cwyear  ->  integer
  # -->
  # Returns the calendar week based year.
  #
  #     Date.new(2001,2,3).cwyear         #=> 2001
  #     Date.new(2000,1,1).cwyear         #=> 1999
  #
  def cwyear: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the day of the month (1-31).
  #
  #     Date.new(2001,2,3).mday           #=> 3
  #
  def day: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.downto(min)              ->  enumerator
  #   - d.downto(min){|date| ...}  ->  self
  # -->
  # This method is equivalent to step(min, -1){|date| ...}.
  #
  def downto: (Date min) { (Date) -> untyped } -> Date
            | (Date min) -> Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.england  ->  date
  # -->
  # This method is equivalent to new_start(Date::ENGLAND).
  #
  def england: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.friday?  ->  bool
  # -->
  # Returns true if the date is Friday.
  #
  def friday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.gregorian  ->  date
  # -->
  # This method is equivalent to new_start(Date::GREGORIAN).
  #
  def gregorian: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.gregorian?  ->  bool
  # -->
  # Returns true if the date is on or after the day of calendar reform.
  #
  #     Date.new(1582,10,15).gregorian?          #=> true
  #     (Date.new(1582,10,15) - 1).gregorian?    #=> false
  #
  def gregorian?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.httpdate  ->  string
  # -->
  # This method is equivalent to strftime('%a, %d %b %Y %T GMT'). See also RFC
  # 2616.
  #
  def httpdate: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.inspect  ->  string
  # -->
  # Returns the value as a string for inspection.
  #
  #     Date.new(2001,2,3).inspect
  #               #=> "#<Date: 2001-02-03>"
  #     DateTime.new(2001,2,3,4,5,6,'-7').inspect
  #               #=> "#<DateTime: 2001-02-03T04:05:06-07:00>"
  #
  def inspect: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.iso8601    ->  string
  #   - d.xmlschema  ->  string
  # -->
  # This method is equivalent to strftime('%F').
  #
  def iso8601: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.italy  ->  date
  # -->
  # This method is equivalent to new_start(Date::ITALY).
  #
  def italy: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.jd  ->  integer
  # -->
  # Returns the Julian day number.  This is a whole number, which is adjusted by
  # the offset as the local time.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').jd      #=> 2451944
  #     DateTime.new(2001,2,3,4,5,6,'-7').jd      #=> 2451944
  #
  def jd: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.jisx0301  ->  string
  # -->
  # Returns a string in a JIS X 0301 format.
  #
  #     Date.new(2001,2,3).jisx0301       #=> "H13.02.03"
  #
  def jisx0301: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.julian  ->  date
  # -->
  # This method is equivalent to new_start(Date::JULIAN).
  #
  def julian: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.julian?  ->  bool
  # -->
  # Returns true if the date is before the day of calendar reform.
  #
  #     Date.new(1582,10,15).julian?             #=> false
  #     (Date.new(1582,10,15) - 1).julian?       #=> true
  #
  def julian?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.ld  ->  integer
  # -->
  # Returns the Lilian day number.  This is a whole number, which is adjusted by
  # the offset as the local time.
  #
  #     Date.new(2001,2,3).ld            #=> 152784
  #
  def ld: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.leap?  ->  bool
  # -->
  # Returns true if the year is a leap year.
  #
  #     Date.new(2000).leap?      #=> true
  #     Date.new(2001).leap?      #=> false
  #
  def leap?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.mday  ->  fixnum
  #   - d.day   ->  fixnum
  # -->
  # Returns the day of the month (1-31).
  #
  #     Date.new(2001,2,3).mday           #=> 3
  #
  def mday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.mjd  ->  integer
  # -->
  # Returns the modified Julian day number.  This is a whole number, which is
  # adjusted by the offset as the local time.
  #
  #     DateTime.new(2001,2,3,4,5,6,'+7').mjd     #=> 51943
  #     DateTime.new(2001,2,3,4,5,6,'-7').mjd     #=> 51943
  #
  def mjd: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.mon    ->  fixnum
  #   - d.month  ->  fixnum
  # -->
  # Returns the month (1-12).
  #
  #     Date.new(2001,2,3).mon            #=> 2
  #
  def mon: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.monday?  ->  bool
  # -->
  # Returns true if the date is Monday.
  #
  def monday?: () -> bool

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the month (1-12).
  #
  #     Date.new(2001,2,3).mon            #=> 2
  #
  def month: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.new_start([start=Date::ITALY])  ->  date
  # -->
  # Duplicates self and resets its day of calendar reform.
  #
  #     d = Date.new(1582,10,15)
  #     d.new_start(Date::JULIAN)         #=> #<Date: 1582-10-05 ...>
  #
  def new_start: (?Integer start) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.succ  ->  date
  #   - d.next  ->  date
  # -->
  # Returns a date object denoting the following day.
  #
  def next: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.next_day([n=1])  ->  date
  # -->
  # This method is equivalent to d + n.
  #
  def next_day: (?Integer day) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.next_month([n=1])  ->  date
  # -->
  # This method is equivalent to d >> n.
  #
  # See Date#>> for examples.
  #
  def next_month: (?Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.next_year([n=1])  ->  date
  # -->
  # This method is equivalent to d >> (n * 12).
  #
  #     Date.new(2001,2,3).next_year      #=> #<Date: 2002-02-03 ...>
  #     Date.new(2008,2,29).next_year     #=> #<Date: 2009-02-28 ...>
  #     Date.new(2008,2,29).next_year(4)  #=> #<Date: 2012-02-29 ...>
  #
  # See also Date#>>.
  #
  def next_year: (?Integer year) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.prev_day([n=1])  ->  date
  # -->
  # This method is equivalent to d - n.
  #
  def prev_day: (?Integer day) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.prev_month([n=1])  ->  date
  # -->
  # This method is equivalent to d << n.
  #
  # See Date#<< for examples.
  #
  def prev_month: (?Integer month) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.prev_year([n=1])  ->  date
  # -->
  # This method is equivalent to d << (n * 12).
  #
  #     Date.new(2001,2,3).prev_year      #=> #<Date: 2000-02-03 ...>
  #     Date.new(2008,2,29).prev_year     #=> #<Date: 2007-02-28 ...>
  #     Date.new(2008,2,29).prev_year(4)  #=> #<Date: 2004-02-29 ...>
  #
  # See also Date#<<.
  #
  def prev_year: (?Integer year) -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.rfc2822  ->  string
  #   - d.rfc822   ->  string
  # -->
  # This method is equivalent to strftime('%a, %-d %b %Y %T %z').
  #
  def rfc2822: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.rfc3339  ->  string
  # -->
  # This method is equivalent to strftime('%FT%T%:z').
  #
  def rfc3339: () -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Creates a new Date object by parsing from a string according to some typical
  # RFC 2822 formats.
  #
  #     Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
  #                                               #=> #<Date: 2001-02-03 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def rfc822: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.saturday?  ->  bool
  # -->
  # Returns true if the date is Saturday.
  #
  def saturday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.start  ->  float
  # -->
  # Returns the Julian day number denoting the day of calendar reform.
  #
  #     Date.new(2001,2,3).start                  #=> 2299161.0
  #     Date.new(2001,2,3,Date::GREGORIAN).start  #=> -Infinity
  #
  def start: () -> Float

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.step(limit[, step=1])              ->  enumerator
  #   - d.step(limit[, step=1]){|date| ...}  ->  self
  # -->
  # Iterates evaluation of the given block, which takes a date object. The limit
  # should be a date object.
  #
  #     Date.new(2001).step(Date.new(2001,-1,-1)).select{|d| d.sunday?}.size
  #                               #=> 52
  #
  def step: (Date limit, ?Integer step) { (Date) -> untyped } -> Date
          | (Date limit, ?Integer step) -> ::Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.strftime([format='%F'])  ->  string
  # -->
  # Formats date according to the directives in the given format string. The
  # directives begin with a percent (%) character. Any text not listed as a
  # directive will be passed through to the output string.
  #
  # A directive consists of a percent (%) character, zero or more flags, an
  # optional minimum field width, an optional modifier, and a conversion specifier
  # as follows.
  #
  #     %<flags><width><modifier><conversion>
  #
  # Flags:
  #     -  don't pad a numerical output.
  #     _  use spaces for padding.
  #     0  use zeros for padding.
  #     ^  upcase the result string.
  #     #  change case.
  #
  # The minimum field width specifies the minimum width.
  #
  # The modifiers are "E", "O", ":", "::" and ":::". "E" and "O" are ignored.  No
  # effect to result currently.
  #
  # Format directives:
  #
  #     Date (Year, Month, Day):
  #       %Y - Year with century (can be negative, 4 digits at least)
  #               -0001, 0000, 1995, 2009, 14292, etc.
  #       %C - year / 100 (round down.  20 in 2009)
  #       %y - year % 100 (00..99)
  #
  #       %m - Month of the year, zero-padded (01..12)
  #               %_m  blank-padded ( 1..12)
  #               %-m  no-padded (1..12)
  #       %B - The full month name (``January'')
  #               %^B  uppercased (``JANUARY'')
  #       %b - The abbreviated month name (``Jan'')
  #               %^b  uppercased (``JAN'')
  #       %h - Equivalent to %b
  #
  #       %d - Day of the month, zero-padded (01..31)
  #               %-d  no-padded (1..31)
  #       %e - Day of the month, blank-padded ( 1..31)
  #
  #       %j - Day of the year (001..366)
  #
  #     Time (Hour, Minute, Second, Subsecond):
  #       %H - Hour of the day, 24-hour clock, zero-padded (00..23)
  #       %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
  #       %I - Hour of the day, 12-hour clock, zero-padded (01..12)
  #       %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
  #       %P - Meridian indicator, lowercase (``am'' or ``pm'')
  #       %p - Meridian indicator, uppercase (``AM'' or ``PM'')
  #
  #       %M - Minute of the hour (00..59)
  #
  #       %S - Second of the minute (00..60)
  #
  #       %L - Millisecond of the second (000..999)
  #       %N - Fractional seconds digits, default is 9 digits (nanosecond)
  #               %3N  millisecond (3 digits)   %15N femtosecond (15 digits)
  #               %6N  microsecond (6 digits)   %18N attosecond  (18 digits)
  #               %9N  nanosecond  (9 digits)   %21N zeptosecond (21 digits)
  #               %12N picosecond (12 digits)   %24N yoctosecond (24 digits)
  #
  #     Time zone:
  #       %z - Time zone as hour and minute offset from UTC (e.g. +0900)
  #               %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
  #               %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
  #               %:::z - hour, minute and second offset from UTC
  #                                                 (e.g. +09, +09:30, +09:30:30)
  #       %Z - Equivalent to %:z (e.g. +09:00)
  #
  #     Weekday:
  #       %A - The full weekday name (``Sunday'')
  #               %^A  uppercased (``SUNDAY'')
  #       %a - The abbreviated name (``Sun'')
  #               %^a  uppercased (``SUN'')
  #       %u - Day of the week (Monday is 1, 1..7)
  #       %w - Day of the week (Sunday is 0, 0..6)
  #
  #     ISO 8601 week-based year and week number:
  #     The week 1 of YYYY starts with a Monday and includes YYYY-01-04.
  #     The days in the year before the first week are in the last week of
  #     the previous year.
  #       %G - The week-based year
  #       %g - The last 2 digits of the week-based year (00..99)
  #       %V - Week number of the week-based year (01..53)
  #
  #     Week number:
  #     The week 1 of YYYY starts with a Sunday or Monday (according to %U
  #     or %W).  The days in the year before the first week are in week 0.
  #       %U - Week number of the year.  The week starts with Sunday.  (00..53)
  #       %W - Week number of the year.  The week starts with Monday.  (00..53)
  #
  #     Seconds since the Unix Epoch:
  #       %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #       %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.
  #
  #     Literal string:
  #       %n - Newline character (\n)
  #       %t - Tab character (\t)
  #       %% - Literal ``%'' character
  #
  #     Combination:
  #       %c - date and time (%a %b %e %T %Y)
  #       %D - Date (%m/%d/%y)
  #       %F - The ISO 8601 date format (%Y-%m-%d)
  #       %v - VMS date (%e-%^b-%Y)
  #       %x - Same as %D
  #       %X - Same as %T
  #       %r - 12-hour time (%I:%M:%S %p)
  #       %R - 24-hour time (%H:%M)
  #       %T - 24-hour time (%H:%M:%S)
  #       %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)
  #
  # This method is similar to the strftime() function defined in ISO C and POSIX.
  # Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z) are
  # locale dependent in the function. However, this method is locale independent.
  # So, the result may differ even if the same format string is used in other
  # systems such as C. It is good practice to avoid %x and %X because there are
  # corresponding locale independent representations, %D and %T.
  #
  # Examples:
  #
  #     d = DateTime.new(2007,11,19,8,37,48,"-06:00")
  #                               #=> #<DateTime: 2007-11-19T08:37:48-0600 ...>
  #     d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"
  #     d.strftime("at %I:%M%p")            #=> "at 08:37AM"
  #
  # Various ISO 8601 formats:
  #     %Y%m%d           => 20071119                  Calendar date (basic)
  #     %F               => 2007-11-19                Calendar date (extended)
  #     %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
  #     %Y               => 2007                      Calendar date, reduced accuracy, specific year
  #     %C               => 20                        Calendar date, reduced accuracy, specific century
  #     %Y%j             => 2007323                   Ordinal date (basic)
  #     %Y-%j            => 2007-323                  Ordinal date (extended)
  #     %GW%V%u          => 2007W471                  Week date (basic)
  #     %G-W%V-%u        => 2007-W47-1                Week date (extended)
  #     %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
  #     %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
  #     %H%M%S           => 083748                    Local time (basic)
  #     %T               => 08:37:48                  Local time (extended)
  #     %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
  #     %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
  #     %H               => 08                        Local time, reduced accuracy, specific hour
  #     %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
  #     %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
  #     %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
  #     %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
  #     %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
  #     %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
  #     %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
  #     %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
  #     %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
  #     %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
  #     %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
  #     %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
  #     %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
  #     %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
  #     %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
  #     %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
  #     %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
  #     %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)
  #
  # See also strftime(3) and ::strptime.
  #
  def strftime: (?String format) -> String

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns a date object denoting the following day.
  #
  def succ: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.sunday?  ->  bool
  # -->
  # Returns true if the date is Sunday.
  #
  def sunday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.thursday?  ->  bool
  # -->
  # Returns true if the date is Thursday.
  #
  def thursday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.to_date  ->  self
  # -->
  # Returns self.
  #
  def to_date: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.to_datetime  -> datetime
  # -->
  # Returns a DateTime object which denotes self.
  #
  def to_datetime: () -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.to_s  ->  string
  # -->
  # Returns a string in an ISO 8601 format. (This method doesn't use the expanded
  # representations.)
  #
  #     Date.new(2001,2,3).to_s  #=> "2001-02-03"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.to_time  ->  time
  # -->
  # Returns a Time object which denotes self. If self is a julian date, convert it
  # to a gregorian date before converting it to Time.
  #
  def to_time: () -> Time

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.tuesday?  ->  bool
  # -->
  # Returns true if the date is Tuesday.
  #
  def tuesday?: () -> bool

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.upto(max)              ->  enumerator
  #   - d.upto(max){|date| ...}  ->  self
  # -->
  # This method is equivalent to step(max, 1){|date| ...}.
  #
  def upto: (Date max) { (Date) -> untyped } -> Date
          | (Date max) -> ::Enumerator[Date, Date]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.wday  ->  fixnum
  # -->
  # Returns the day of week (0-6, Sunday is zero).
  #
  #     Date.new(2001,2,3).wday           #=> 6
  #
  def wday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.wednesday?  ->  bool
  # -->
  # Returns true if the date is Wednesday.
  #
  def wednesday?: () -> bool

  # <!-- rdoc-file=ext/date/date_core.c -->
  # This method is equivalent to strftime('%F').
  #
  def xmlschema: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.yday  ->  fixnum
  # -->
  # Returns the day of the year (1-366).
  #
  #     Date.new(2001,2,3).yday           #=> 34
  #
  def yday: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.year  ->  integer
  # -->
  # Returns the year.
  #
  #     Date.new(2001,2,3).year           #=> 2001
  #     (Date.new(1,1,1) - 1).year        #=> 0
  #
  def year: () -> Integer
end

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of abbreviated day names in English.  The first is "Sun".
#
Date::ABBR_DAYNAMES: Array[String]

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of abbreviated month names in English.  The first element
# is nil.
#
Date::ABBR_MONTHNAMES: Array[String?]

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of the full names of days of the week in English. The
# first is "Sunday".
#
Date::DAYNAMES: Array[String]

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for England and her
# colonies.
#
Date::ENGLAND: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for the proleptic
# Gregorian calendar.
#
Date::GREGORIAN: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for Italy and some
# catholic countries.
#
Date::ITALY: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# The Julian day number of the day of calendar reform for the proleptic Julian
# calendar.
#
Date::JULIAN: Integer

# <!-- rdoc-file=ext/date/date_core.c -->
# An array of strings of full month names in English.  The first element is nil.
#
Date::MONTHNAMES: Array[String?]

# <!-- rdoc-file=ext/date/date_core.c -->
# ## DateTime
#
# A subclass of Date that easily handles date, hour, minute, second, and offset.
#
# DateTime class is considered deprecated. Use Time class.
#
# DateTime does not consider any leap seconds, does not track any summer time
# rules.
#
# A DateTime object is created with DateTime::new, DateTime::jd,
# DateTime::ordinal, DateTime::commercial, DateTime::parse, DateTime::strptime,
# DateTime::now, Time#to_datetime, etc.
#
#     require 'date'
#
#     DateTime.new(2001,2,3,4,5,6)
#                         #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>
#
# The last element of day, hour, minute, or second can be a fractional number.
# The fractional number's precision is assumed at most nanosecond.
#
#     DateTime.new(2001,2,3.5)
#                         #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>
#
# An optional argument, the offset, indicates the difference between the local
# time and UTC. For example, `Rational(3,24)` represents ahead of 3 hours of
# UTC, `Rational(-5,24)` represents behind of 5 hours of UTC. The offset should
# be -1 to +1, and its precision is assumed at most second. The default value is
# zero (equals to UTC).
#
#     DateTime.new(2001,2,3,4,5,6,Rational(3,24))
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>
#
# The offset also accepts string form:
#
#     DateTime.new(2001,2,3,4,5,6,'+03:00')
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>
#
# An optional argument, the day of calendar reform (`start`), denotes a Julian
# day number, which should be 2298874 to 2426355 or negative/positive infinity.
# The default value is `Date::ITALY` (2299161=1582-10-15).
#
# A DateTime object has various methods. See each reference.
#
#     d = DateTime.parse('3rd Feb 2001 04:05:06+03:30')
#                         #=> #<DateTime: 2001-02-03T04:05:06+03:30 ...>
#     d.hour              #=> 4
#     d.min               #=> 5
#     d.sec               #=> 6
#     d.offset            #=> (7/48)
#     d.zone              #=> "+03:30"
#     d += Rational('1.5')
#                         #=> #<DateTime: 2001-02-04%16:05:06+03:30 ...>
#     d = d.new_offset('+09:00')
#                         #=> #<DateTime: 2001-02-04%21:35:06+09:00 ...>
#     d.strftime('%I:%M:%S %p')
#                         #=> "09:35:06 PM"
#     d > DateTime.new(1999)
#                         #=> true
#
# ### When should you use DateTime and when should you use Time?
#
# It's a common misconception that [William
# Shakespeare](https://en.wikipedia.org/wiki/William_Shakespeare) and [Miguel de
# Cervantes](https://en.wikipedia.org/wiki/Miguel_de_Cervantes) died on the same
# day in history - so much so that UNESCO named April 23 as [World Book Day
# because of this fact](https://en.wikipedia.org/wiki/World_Book_Day). However,
# because England hadn't yet adopted the [Gregorian Calendar
# Reform](https://en.wikipedia.org/wiki/Gregorian_calendar#Gregorian_reform)
# (and wouldn't until
# [1752](https://en.wikipedia.org/wiki/Calendar_(New_Style)_Act_1750)) their
# deaths are actually 10 days apart. Since Ruby's Time class implements a
# [proleptic Gregorian
# calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar) and has
# no concept of calendar reform there's no way to express this with Time
# objects. This is where DateTime steps in:
#
#     shakespeare = DateTime.iso8601('1616-04-23', Date::ENGLAND)
#      #=> Tue, 23 Apr 1616 00:00:00 +0000
#     cervantes = DateTime.iso8601('1616-04-23', Date::ITALY)
#      #=> Sat, 23 Apr 1616 00:00:00 +0000
#
# Already you can see something is weird - the days of the week are different.
# Taking this further:
#
#     cervantes == shakespeare
#      #=> false
#     (shakespeare - cervantes).to_i
#      #=> 10
#
# This shows that in fact they died 10 days apart (in reality 11 days since
# Cervantes died a day earlier but was buried on the 23rd). We can see the
# actual date of Shakespeare's death by using the #gregorian method to convert
# it:
#
#     shakespeare.gregorian
#      #=> Tue, 03 May 1616 00:00:00 +0000
#
# So there's an argument that all the celebrations that take place on the 23rd
# April in Stratford-upon-Avon are actually the wrong date since England is now
# using the Gregorian calendar. You can see why when we transition across the
# reform date boundary:
#
#     # start off with the anniversary of Shakespeare's birth in 1751
#     shakespeare = DateTime.iso8601('1751-04-23', Date::ENGLAND)
#      #=> Tue, 23 Apr 1751 00:00:00 +0000
#
#     # add 366 days since 1752 is a leap year and April 23 is after February 29
#     shakespeare + 366
#      #=> Thu, 23 Apr 1752 00:00:00 +0000
#
#     # add another 365 days to take us to the anniversary in 1753
#     shakespeare + 366 + 365
#      #=> Fri, 04 May 1753 00:00:00 +0000
#
# As you can see, if we're accurately tracking the number of [solar
# years](https://en.wikipedia.org/wiki/Tropical_year) since Shakespeare's
# birthday then the correct anniversary date would be the 4th May and not the
# 23rd April.
#
# So when should you use DateTime in Ruby and when should you use Time? Almost
# certainly you'll want to use Time since your app is probably dealing with
# current dates and times. However, if you need to deal with dates and times in
# a historical context you'll want to use DateTime to avoid making the same
# mistakes as UNESCO. If you also have to deal with timezones then best of luck
# - just bear in mind that you'll probably be dealing with [local solar
# times](https://en.wikipedia.org/wiki/Solar_time), since it wasn't until the
# 19th century that the introduction of the railways necessitated the need for
# [Standard Time](https://en.wikipedia.org/wiki/Standard_time#Great_Britain) and
# eventually timezones.
#
class DateTime < Date
  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.civil([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  ->  datetime
  #   - DateTime.new([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])    ->  datetime
  # -->
  # Creates a DateTime object denoting the given calendar date.
  #
  #     DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.new(2001,2,3,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.new(2001,-11,-26,-20,-55,-54,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def initialize: (?Integer year, ?Integer month, ?Integer mday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> void

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime._strptime(string[, format='%FT%T%z'])  ->  hash
  # -->
  # Parses the given representation of date and time with the given template, and
  # returns a hash of parsed elements.  _strptime does not support specification
  # of flags and width unlike strftime.
  #
  # See also strptime(3) and #strftime.
  #
  def self._strptime: (String str, ?String format) -> Hash[Symbol, Integer | String]

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.civil([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  ->  datetime
  #   - DateTime.new([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])    ->  datetime
  # -->
  # Creates a DateTime object denoting the given calendar date.
  #
  #     DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.new(2001,2,3,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.new(2001,-11,-26,-20,-55,-54,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def self.civil: (?Integer year, ?Integer month, ?Integer mday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.commercial([cwyear=-4712[, cweek=1[, cwday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given week date.
  #
  #     DateTime.commercial(2001) #=> #<DateTime: 2001-01-01T00:00:00+00:00 ...>
  #     DateTime.commercial(2002) #=> #<DateTime: 2001-12-31T00:00:00+00:00 ...>
  #     DateTime.commercial(2001,5,6,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def self.commercial: (?Integer cwyear, ?Integer cweek, ?Integer cwday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.httpdate(string='Mon, 01 Jan -4712 00:00:00 GMT'[, start=Date::ITALY])  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some RFC
  # 2616 format.
  #
  #     DateTime.httpdate('Sat, 03 Feb 2001 04:05:06 GMT')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.httpdate: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.iso8601(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical ISO 8601 formats.
  #
  #     DateTime.iso8601('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.iso8601('20010203T040506+0700')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.iso8601('2001-W05-6T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.iso8601: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.jd([jd=0[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given chronological Julian day number.
  #
  #     DateTime.jd(2451944)      #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.jd(2451945)      #=> #<DateTime: 2001-02-04T00:00:00+00:00 ...>
  #     DateTime.jd(Rational('0.5'))
  #                               #=> #<DateTime: -4712-01-01T12:00:00+00:00 ...>
  #
  def self.jd: (?Integer jd, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.jisx0301(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical JIS X 0301 formats.
  #
  #     DateTime.jisx0301('H13.02.03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # For no-era year, legacy format, Heisei is assumed.
  #
  #     DateTime.jisx0301('13.02.03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.jisx0301: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.now([start=Date::ITALY])  ->  datetime
  # -->
  # Creates a DateTime object denoting the present time.
  #
  #     DateTime.now              #=> #<DateTime: 2011-06-11T21:20:44+09:00 ...>
  #
  def self.now: (?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.ordinal([year=-4712[, yday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]])  ->  datetime
  # -->
  # Creates a DateTime object denoting the given ordinal date.
  #
  #     DateTime.ordinal(2001,34) #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
  #     DateTime.ordinal(2001,34,4,5,6,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.ordinal(2001,-332,-20,-55,-54,'+7')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  def self.ordinal: (?Integer year, ?Integer yday, ?Integer hour, ?Integer minute, ?Integer second, ?Integer offset, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.parse(string='-4712-01-01T00:00:00+00:00'[, comp=true[, start=Date::ITALY]], limit: 128)  ->  datetime
  # -->
  # Parses the given representation of date and time, and creates a DateTime
  # object.
  #
  # This method *does not* function as a validator.  If the input string does not
  # match valid formats strictly, you may get a cryptic result.  Should consider
  # to use `DateTime.strptime` instead of this method as possible.
  #
  # If the optional second argument is true and the detected year is in the range
  # "00" to "99", makes it full.
  #
  #     DateTime.parse('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.parse('20010203T040506+0700')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.parse('3rd Feb 2001 04:05:06 PM')
  #                               #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.parse: (String str, ?boolish complete, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  datetime
  #   - DateTime.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 2822 formats.
  #
  #     DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
  #                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc2822: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc3339(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 3339 formats.
  #
  #     DateTime.rfc3339('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc3339: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)  ->  datetime
  #   - DateTime.rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128)   ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical RFC 2822 formats.
  #
  #     DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
  #                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.rfc822: (String str, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.strptime([string='-4712-01-01T00:00:00+00:00'[, format='%FT%T%z'[ ,start=Date::ITALY]]])  ->  datetime
  # -->
  # Parses the given representation of date and time with the given template, and
  # creates a DateTime object.  strptime does not support specification of flags
  # and width unlike strftime.
  #
  #     DateTime.strptime('2001-02-03T04:05:06+07:00', '%Y-%m-%dT%H:%M:%S%z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('03-02-2001 04:05:06 PM', '%d-%m-%Y %I:%M:%S %p')
  #                               #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>
  #     DateTime.strptime('2001-W05-6T04:05:06+07:00', '%G-W%V-%uT%H:%M:%S%z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('2001 04 6 04 05 06 +7', '%Y %U %w %H %M %S %z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('2001 05 6 04 05 06 +7', '%Y %W %u %H %M %S %z')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #     DateTime.strptime('-1', '%s')
  #                               #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
  #     DateTime.strptime('-1000', '%Q')
  #                               #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
  #     DateTime.strptime('sat3feb014pm+7', '%a%d%b%y%H%p%z')
  #                               #=> #<DateTime: 2001-02-03T16:00:00+07:00 ...>
  #
  # See also strptime(3) and #strftime.
  #
  def self.strptime: (String str, ?String format, ?Integer start) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - DateTime.xmlschema(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128)  ->  datetime
  # -->
  # Creates a new DateTime object by parsing from a string according to some
  # typical XML Schema formats.
  #
  #     DateTime.xmlschema('2001-02-03T04:05:06+07:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
  #
  # Raise an ArgumentError when the string length is longer than *limit*. You can
  # stop this check by passing `limit: nil`, but note that it may take a long time
  # to parse.
  #
  def self.xmlschema: (String str, ?Integer start) -> DateTime

  public

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.hour  ->  fixnum
  # -->
  # Returns the hour (0-23).
  #
  #     DateTime.new(2001,2,3,4,5,6).hour         #=> 4
  #
  def hour: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.iso8601([n=0])    ->  string
  #   - dt.xmlschema([n=0])  ->  string
  # -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def iso8601: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.jisx0301([n=0])  ->  string
  # -->
  # Returns a string in a JIS X 0301 format. The optional argument `n` is the
  # number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').jisx0301(9)
  #                               #=> "H13.02.03T04:05:06.123456789+07:00"
  #
  def jisx0301: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.min     ->  fixnum
  #   - d.minute  ->  fixnum
  # -->
  # Returns the minute (0-59).
  #
  #     DateTime.new(2001,2,3,4,5,6).min          #=> 5
  #
  def min: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the minute (0-59).
  #
  #     DateTime.new(2001,2,3,4,5,6).min          #=> 5
  #
  def minute: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.new_offset([offset=0])  ->  date
  # -->
  # Duplicates self and resets its offset.
  #
  #     d = DateTime.new(2001,2,3,4,5,6,'-02:00')
  #                               #=> #<DateTime: 2001-02-03T04:05:06-02:00 ...>
  #     d.new_offset('+09:00')    #=> #<DateTime: 2001-02-03T15:05:06+09:00 ...>
  #
  def new_offset: (?String offset) -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.offset  ->  rational
  # -->
  # Returns the offset.
  #
  #     DateTime.parse('04pm+0730').offset        #=> (5/16)
  #
  def offset: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.rfc3339([n=0])  ->  string
  # -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').rfc3339(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def rfc3339: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.sec     ->  fixnum
  #   - d.second  ->  fixnum
  # -->
  # Returns the second (0-59).
  #
  #     DateTime.new(2001,2,3,4,5,6).sec          #=> 6
  #
  def sec: () -> Integer

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.sec_fraction     ->  rational
  #   - d.second_fraction  ->  rational
  # -->
  # Returns the fractional part of the second.
  #
  #     DateTime.new(2001,2,3,4,5,6.5).sec_fraction       #=> (1/2)
  #
  def sec_fraction: () -> Rational

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the second (0-59).
  #
  #     DateTime.new(2001,2,3,4,5,6).sec          #=> 6
  #
  def second: () -> Integer

  # <!-- rdoc-file=ext/date/date_core.c -->
  # Returns the fractional part of the second.
  #
  #     DateTime.new(2001,2,3,4,5,6.5).sec_fraction       #=> (1/2)
  #
  def second_fraction: () -> Rational

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.strftime([format='%FT%T%:z'])  ->  string
  # -->
  # Formats date according to the directives in the given format string. The
  # directives begin with a percent (%) character. Any text not listed as a
  # directive will be passed through to the output string.
  #
  # A directive consists of a percent (%) character, zero or more flags, an
  # optional minimum field width, an optional modifier, and a conversion specifier
  # as follows.
  #
  #     %<flags><width><modifier><conversion>
  #
  # Flags:
  #     -  don't pad a numerical output.
  #     _  use spaces for padding.
  #     0  use zeros for padding.
  #     ^  upcase the result string.
  #     #  change case.
  #     :  use colons for %z.
  #
  # The minimum field width specifies the minimum width.
  #
  # The modifiers are "E" and "O". They are ignored.
  #
  # Format directives:
  #
  #     Date (Year, Month, Day):
  #       %Y - Year with century (can be negative, 4 digits at least)
  #               -0001, 0000, 1995, 2009, 14292, etc.
  #       %C - year / 100 (round down.  20 in 2009)
  #       %y - year % 100 (00..99)
  #
  #       %m - Month of the year, zero-padded (01..12)
  #               %_m  blank-padded ( 1..12)
  #               %-m  no-padded (1..12)
  #       %B - The full month name (``January'')
  #               %^B  uppercased (``JANUARY'')
  #       %b - The abbreviated month name (``Jan'')
  #               %^b  uppercased (``JAN'')
  #       %h - Equivalent to %b
  #
  #       %d - Day of the month, zero-padded (01..31)
  #               %-d  no-padded (1..31)
  #       %e - Day of the month, blank-padded ( 1..31)
  #
  #       %j - Day of the year (001..366)
  #
  #     Time (Hour, Minute, Second, Subsecond):
  #       %H - Hour of the day, 24-hour clock, zero-padded (00..23)
  #       %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
  #       %I - Hour of the day, 12-hour clock, zero-padded (01..12)
  #       %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
  #       %P - Meridian indicator, lowercase (``am'' or ``pm'')
  #       %p - Meridian indicator, uppercase (``AM'' or ``PM'')
  #
  #       %M - Minute of the hour (00..59)
  #
  #       %S - Second of the minute (00..60)
  #
  #       %L - Millisecond of the second (000..999)
  #       %N - Fractional seconds digits, default is 9 digits (nanosecond)
  #               %3N  millisecond (3 digits)   %15N femtosecond (15 digits)
  #               %6N  microsecond (6 digits)   %18N attosecond  (18 digits)
  #               %9N  nanosecond  (9 digits)   %21N zeptosecond (21 digits)
  #               %12N picosecond (12 digits)   %24N yoctosecond (24 digits)
  #
  #     Time zone:
  #       %z - Time zone as hour and minute offset from UTC (e.g. +0900)
  #               %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
  #               %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
  #               %:::z - hour, minute and second offset from UTC
  #                                                 (e.g. +09, +09:30, +09:30:30)
  #       %Z - Equivalent to %:z (e.g. +09:00)
  #
  #     Weekday:
  #       %A - The full weekday name (``Sunday'')
  #               %^A  uppercased (``SUNDAY'')
  #       %a - The abbreviated name (``Sun'')
  #               %^a  uppercased (``SUN'')
  #       %u - Day of the week (Monday is 1, 1..7)
  #       %w - Day of the week (Sunday is 0, 0..6)
  #
  #     ISO 8601 week-based year and week number:
  #     The week 1 of YYYY starts with a Monday and includes YYYY-01-04.
  #     The days in the year before the first week are in the last week of
  #     the previous year.
  #       %G - The week-based year
  #       %g - The last 2 digits of the week-based year (00..99)
  #       %V - Week number of the week-based year (01..53)
  #
  #     Week number:
  #     The week 1 of YYYY starts with a Sunday or Monday (according to %U
  #     or %W).  The days in the year before the first week are in week 0.
  #       %U - Week number of the year.  The week starts with Sunday.  (00..53)
  #       %W - Week number of the year.  The week starts with Monday.  (00..53)
  #
  #     Seconds since the Unix Epoch:
  #       %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #       %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.
  #
  #     Literal string:
  #       %n - Newline character (\n)
  #       %t - Tab character (\t)
  #       %% - Literal ``%'' character
  #
  #     Combination:
  #       %c - date and time (%a %b %e %T %Y)
  #       %D - Date (%m/%d/%y)
  #       %F - The ISO 8601 date format (%Y-%m-%d)
  #       %v - VMS date (%e-%^b-%Y)
  #       %x - Same as %D
  #       %X - Same as %T
  #       %r - 12-hour time (%I:%M:%S %p)
  #       %R - 24-hour time (%H:%M)
  #       %T - 24-hour time (%H:%M:%S)
  #       %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)
  #
  # This method is similar to the strftime() function defined in ISO C and POSIX.
  # Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z) are
  # locale dependent in the function. However, this method is locale independent.
  # So, the result may differ even if the same format string is used in other
  # systems such as C. It is good practice to avoid %x and %X because there are
  # corresponding locale independent representations, %D and %T.
  #
  # Examples:
  #
  #     d = DateTime.new(2007,11,19,8,37,48,"-06:00")
  #                               #=> #<DateTime: 2007-11-19T08:37:48-0600 ...>
  #     d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"
  #     d.strftime("at %I:%M%p")            #=> "at 08:37AM"
  #
  # Various ISO 8601 formats:
  #     %Y%m%d           => 20071119                  Calendar date (basic)
  #     %F               => 2007-11-19                Calendar date (extended)
  #     %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
  #     %Y               => 2007                      Calendar date, reduced accuracy, specific year
  #     %C               => 20                        Calendar date, reduced accuracy, specific century
  #     %Y%j             => 2007323                   Ordinal date (basic)
  #     %Y-%j            => 2007-323                  Ordinal date (extended)
  #     %GW%V%u          => 2007W471                  Week date (basic)
  #     %G-W%V-%u        => 2007-W47-1                Week date (extended)
  #     %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
  #     %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
  #     %H%M%S           => 083748                    Local time (basic)
  #     %T               => 08:37:48                  Local time (extended)
  #     %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
  #     %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
  #     %H               => 08                        Local time, reduced accuracy, specific hour
  #     %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
  #     %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
  #     %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
  #     %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
  #     %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
  #     %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
  #     %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
  #     %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
  #     %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
  #     %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
  #     %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
  #     %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
  #     %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
  #     %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
  #     %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
  #     %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
  #     %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
  #     %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)
  #
  # See also strftime(3) and ::strptime.
  #
  def strftime: (?String format) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_date  ->  date
  # -->
  # Returns a Date object which denotes self.
  #
  def to_date: () -> Date

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_datetime  ->  self
  # -->
  # Returns self.
  #
  def to_datetime: () -> DateTime

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_s  ->  string
  # -->
  # Returns a string in an ISO 8601 format. (This method doesn't use the expanded
  # representations.)
  #
  #     DateTime.new(2001,2,3,4,5,6,'-7').to_s
  #                              #=> "2001-02-03T04:05:06-07:00"
  #
  def to_s: () -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - dt.to_time  ->  time
  # -->
  # Returns a Time object which denotes self.
  #
  def to_time: () -> Time

  # <!-- rdoc-file=ext/date/date_core.c -->
  # This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
  # is the number of digits for fractional seconds.
  #
  #     DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
  #                               #=> "2001-02-03T04:05:06.123456789+07:00"
  #
  def xmlschema: (?Integer n) -> String

  # <!--
  #   rdoc-file=ext/date/date_core.c
  #   - d.zone  ->  string
  # -->
  # Returns the timezone.
  #
  #     DateTime.parse('04pm+0730').zone          #=> "+07:30"
  #
  def zone: () -> String
end

%a{annotate:rdoc:skip}
class Array[unchecked out Elem]
  # <!--
  #   rdoc-file=lib/abbrev.rb
  #   - abbrev(pattern = nil)
  # -->
  # Calculates the set of unambiguous abbreviations for the strings in `self`.
  #
  #     require 'abbrev'
  #     %w{ car cone }.abbrev
  #     #=> {"car"=>"car", "ca"=>"car", "cone"=>"cone", "con"=>"cone", "co"=>"cone"}
  #
  # The optional `pattern` parameter is a pattern or a string. Only input strings
  # that match the pattern or start with the string are included in the output
  # hash.
  #
  #     %w{ fast boat day }.abbrev(/^.a/)
  #     #=> {"fast"=>"fast", "fas"=>"fast", "fa"=>"fast", "day"=>"day", "da"=>"day"}
  #
  #     Abbrev.abbrev(%w{car box cone}, "ca")
  #     #=> {"car"=>"car", "ca"=>"car"}
  #
  # See also Abbrev.abbrev
  #
  def abbrev: (?String | Regexp | nil) -> Hash[String, String]
end

# <!-- rdoc-file=lib/abbrev.rb -->
# Calculates the set of unambiguous abbreviations for a given set of strings.
#
#     require 'abbrev'
#     require 'pp'
#
#     pp Abbrev.abbrev(['ruby'])
#     #=>  {"ruby"=>"ruby", "rub"=>"ruby", "ru"=>"ruby", "r"=>"ruby"}
#
#     pp Abbrev.abbrev(%w{ ruby rules })
#
# *Generates:*
#     { "ruby"  =>  "ruby",
#       "rub"   =>  "ruby",
#       "rules" =>  "rules",
#       "rule"  =>  "rules",
#       "rul"   =>  "rules" }
#
# It also provides an array core extension, Array#abbrev.
#
#     pp %w{ summer winter }.abbrev
#
# *Generates:*
#     { "summer"  => "summer",
#       "summe"   => "summer",
#       "summ"    => "summer",
#       "sum"     => "summer",
#       "su"      => "summer",
#       "s"       => "summer",
#       "winter"  => "winter",
#       "winte"   => "winter",
#       "wint"    => "winter",
#       "win"     => "winter",
#       "wi"      => "winter",
#       "w"       => "winter" }
#
module Abbrev
  # <!--
  #   rdoc-file=lib/abbrev.rb
  #   - abbrev(words, pattern = nil)
  # -->
  # Given a set of strings, calculate the set of unambiguous abbreviations for
  # those strings, and return a hash where the keys are all the possible
  # abbreviations and the values are the full strings.
  #
  # Thus, given `words` is "car" and "cone", the keys pointing to "car" would be
  # "ca" and "car", while those pointing to "cone" would be "co", "con", and
  # "cone".
  #
  #     require 'abbrev'
  #
  #     Abbrev.abbrev(%w{ car cone })
  #     #=> {"ca"=>"car", "con"=>"cone", "co"=>"cone", "car"=>"car", "cone"=>"cone"}
  #
  # The optional `pattern` parameter is a pattern or a string. Only input strings
  # that match the pattern or start with the string are included in the output
  # hash.
  #
  #     Abbrev.abbrev(%w{car box cone crab}, /b/)
  #     #=> {"box"=>"box", "bo"=>"box", "b"=>"box", "crab" => "crab"}
  #
  #     Abbrev.abbrev(%w{car box cone}, 'ca')
  #     #=> {"car"=>"car", "ca"=>"car"}
  #
  def self?.abbrev: (Array[String], ?String | Regexp | nil) -> Hash[String, String]
end

%a{annotate:rdoc:skip}
class Fiber
  # <!--
  #   rdoc-file=cont.c
  #   - Fiber.current -> fiber
  # -->
  # Returns the current fiber. If you are not running in the context of a fiber
  # this method will return the root fiber.
  #
  def self.current: () -> Fiber

  public

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.alive? -> true or false
  # -->
  # Returns true if the fiber can still be resumed (or transferred to). After
  # finishing execution of the fiber block this method will always return `false`.
  #
  def alive?: () -> bool

  # <!--
  #   rdoc-file=cont.c
  #   - fiber.transfer(args, ...) -> obj
  # -->
  # Transfer control to another fiber, resuming it from where it last stopped or
  # starting it if it was not resumed before. The calling fiber will be suspended
  # much like in a call to Fiber.yield.
  #
  # The fiber which receives the transfer call treats it much like a resume call.
  # Arguments passed to transfer are treated like those passed to resume.
  #
  # The two style of control passing to and from fiber (one is #resume and
  # Fiber::yield, another is #transfer to and from fiber) can't be freely mixed.
  #
  # *   If the Fiber's lifecycle had started with transfer, it will never be able
  #     to yield or be resumed control passing, only finish or transfer back. (It
  #     still can resume other fibers that are allowed to be resumed.)
  # *   If the Fiber's lifecycle had started with resume, it can yield or transfer
  #     to another Fiber, but can receive control back only the way compatible
  #     with the way it was given away: if it had transferred, it only can be
  #     transferred back, and if it had yielded, it only can be resumed back.
  #     After that, it again can transfer or yield.
  #
  #
  # If those rules are broken FiberError is raised.
  #
  # For an individual Fiber design, yield/resume is easier to use (the Fiber just
  # gives away control, it doesn't need to think about who the control is given
  # to), while transfer is more flexible for complex cases, allowing to build
  # arbitrary graphs of Fibers dependent on each other.
  #
  # Example:
  #
  #     manager = nil # For local var to be visible inside worker block
  #
  #     # This fiber would be started with transfer
  #     # It can't yield, and can't be resumed
  #     worker = Fiber.new { |work|
  #       puts "Worker: starts"
  #       puts "Worker: Performed #{work.inspect}, transferring back"
  #       # Fiber.yield     # this would raise FiberError: attempt to yield on a not resumed fiber
  #       # manager.resume  # this would raise FiberError: attempt to resume a resumed fiber (double resume)
  #       manager.transfer(work.capitalize)
  #     }
  #
  #     # This fiber would be started with resume
  #     # It can yield or transfer, and can be transferred
  #     # back or resumed
  #     manager = Fiber.new {
  #       puts "Manager: starts"
  #       puts "Manager: transferring 'something' to worker"
  #       result = worker.transfer('something')
  #       puts "Manager: worker returned #{result.inspect}"
  #       # worker.resume    # this would raise FiberError: attempt to resume a transferring fiber
  #       Fiber.yield        # this is OK, the fiber transferred from and to, now it can yield
  #       puts "Manager: finished"
  #     }
  #
  #     puts "Starting the manager"
  #     manager.resume
  #     puts "Resuming the manager"
  #     # manager.transfer  # this would raise FiberError: attempt to transfer to a yielding fiber
  #     manager.resume
  #
  # *produces*
  #
  #     Starting the manager
  #     Manager: starts
  #     Manager: transferring 'something' to worker
  #     Worker: starts
  #     Worker: Performed "something", transferring back
  #     Manager: worker returned "Something"
  #     Resuming the manager
  #     Manager: finished
  #
  def transfer: (*untyped) -> untyped
end

# <!-- rdoc-file=lib/yaml.rb -->
# YAML Ain't Markup Language
#
# This module provides a Ruby interface for data serialization in YAML format.
#
# The YAML module is an alias of Psych, the YAML engine for Ruby.
#
# ## Usage
#
# Working with YAML can be very simple, for example:
#
#     require 'yaml'
#     # Parse a YAML string
#     YAML.load("--- foo") #=> "foo"
#
#     # Emit some YAML
#     YAML.dump("foo")     # => "--- foo\n...\n"
#     { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
#
# As the implementation is provided by the Psych library, detailed documentation
# can be found in that library's docs (also part of standard library).
#
# ## Security
#
# Do not use YAML to load untrusted data. Doing so is unsafe and could allow
# malicious input to execute arbitrary code inside your application. Please see
# doc/security.rdoc for more information.
#
# ## History
#
# Syck was the original YAML implementation in Ruby's standard library developed
# by why the lucky stiff.
#
# You can still use Syck, if you prefer, for parsing and emitting YAML, but you
# must install the 'syck' gem now in order to use it.
#
# In older Ruby versions, ie. <= 1.9, Syck is still provided, however it was
# completely removed with the release of Ruby 2.0.0.
#
# ## More info
#
# For more advanced details on the implementation see Psych, and also check out
# http://yaml.org for spec details and other helpful information.
#
# Psych is maintained by Aaron Patterson on github:
# https://github.com/ruby/psych
#
# Syck can also be found on github: https://github.com/ruby/syck
#
module YAML
  # <!-- rdoc-file=lib/yaml/dbm.rb -->
  # YAML + DBM = YDBM
  #
  # YAML::DBM provides the same interface as ::DBM.
  #
  # However, while DBM only allows strings for both keys and values, this library
  # allows one to use most Ruby objects for values by first converting them to
  # YAML. Keys must be strings.
  #
  # Conversion to and from YAML is performed automatically.
  #
  # See the documentation for ::DBM and ::YAML for more information.
  #
  class DBM < ::DBM
    VERSION: ::String

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm[key] -> value
    # -->
    # Return value associated with `key` from database.
    #
    # Returns `nil` if there is no such `key`.
    #
    # See #fetch for more information.
    #
    def []: (String key) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm[key] = value
    # -->
    # Set `key` to `value` in database.
    #
    # `value` will be converted to YAML before storage.
    #
    # See #store for more information.
    #
    def []=: (String key, untyped val) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.fetch( key, ifnone = nil )
    #   - ydbm.fetch( key ) { |key| ... }
    # -->
    # Return value associated with `key`.
    #
    # If there is no value for `key` and no block is given, returns `ifnone`.
    #
    # Otherwise, calls block passing in the given `key`.
    #
    # See ::DBM#fetch for more information.
    #
    def fetch: (String keystr, ?untyped? ifnone) { (untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - index( keystr )
    # -->
    # Deprecated, used YAML::DBM#key instead.
    # ---
    # Note: YAML::DBM#index makes warning from internal of ::DBM#index. It says
    # 'DBM#index is deprecated; use DBM#key', but DBM#key behaves not same as
    # DBM#index.
    #
    def index: (String keystr) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.key(value) -> string
    # -->
    # Returns the key for the specified value.
    #
    def key: (String keystr) -> String

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.values_at(*keys)
    # -->
    # Returns an array containing the values associated with the given keys.
    #
    def values_at: (*untyped keys) -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.delete(key)
    # -->
    # Deletes value from database associated with `key`.
    #
    # Returns value or `nil`.
    #
    def delete: (String key) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.delete_if { |key, value| ... }
    # -->
    # Calls the given block once for each `key`, `value` pair in the database.
    # Deletes all entries for which the block returns true.
    #
    # Returns `self`.
    #
    def delete_if: () { (untyped, untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.reject { |key, value| ... }
    # -->
    # Converts the contents of the database to an in-memory Hash, then calls
    # Hash#reject with the specified code block, returning a new Hash.
    #
    def reject: () { (untyped, untyped) -> untyped } -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.each_pair { |key, value| ... }
    # -->
    # Calls the given block once for each `key`, `value` pair in the database.
    #
    # Returns `self`.
    #
    def each_pair: () { (untyped, untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.each_value { |value| ... }
    # -->
    # Calls the given block for each value in database.
    #
    # Returns `self`.
    #
    def each_value: () { (untyped) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.values
    # -->
    # Returns an array of values from the database.
    #
    def values: () -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.has_value?(value)
    # -->
    # Returns true if specified `value` is found in the database.
    #
    def has_value?: (untyped val) -> (::TrueClass | ::FalseClass)

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.invert -> hash
    # -->
    # Returns a Hash (not a DBM database) created by using each value in the
    # database as a key, with the corresponding key as its value.
    #
    # Note that all values in the hash will be Strings, but the keys will be actual
    # objects.
    #
    def invert: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.replace(hash) -> ydbm
    # -->
    # Replaces the contents of the database with the contents of the specified
    # object. Takes any object which implements the each_pair method, including Hash
    # and DBM objects.
    #
    def replace: (Hash[untyped, untyped] | DBM hsh) -> YAML::DBM

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.shift -> [key, value]
    # -->
    # Removes a [key, value] pair from the database, and returns it. If the database
    # is empty, returns `nil`.
    #
    # The order in which values are removed/returned is not guaranteed.
    #
    def shift: () -> (Array[untyped] | untyped)

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.select { |key, value| ... }
    #   - ydbm.select(*keys)
    # -->
    # If a block is provided, returns a new array containing [key, value] pairs for
    # which the block returns true.
    #
    # Otherwise, same as #values_at
    #
    def select: (*untyped keys) { (untyped, untyped) -> untyped } -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.store(key, value) -> value
    # -->
    # Stores `value` in database with `key` as the index. `value` is converted to
    # YAML before being stored.
    #
    # Returns `value`
    #
    def store: (String key, untyped val) -> untyped

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.update(hash) -> ydbm
    # -->
    # Updates the database with multiple values from the specified object. Takes any
    # object which implements the each_pair method, including Hash and DBM objects.
    #
    # Returns `self`.
    #
    def update: (Hash[untyped, untyped]) -> YAML::DBM

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.to_a -> array
    # -->
    # Converts the contents of the database to an array of [key, value] arrays, and
    # returns it.
    #
    def to_a: () -> Array[untyped]

    # <!--
    #   rdoc-file=lib/yaml/dbm.rb
    #   - ydbm.to_hash -> hash
    # -->
    # Converts the contents of the database to an in-memory Hash object, and returns
    # it.
    #
    def to_hash: () -> Hash[untyped, untyped]
  end
end

# <!-- rdoc-file=lib/yaml/store.rb -->
# YAML::Store provides the same functionality as PStore, except it uses YAML to
# dump objects instead of Marshal.
#
# ## Example
#
#     require 'yaml/store'
#
#     Person = Struct.new :first_name, :last_name
#
#     people = [Person.new("Bob", "Smith"), Person.new("Mary", "Johnson")]
#
#     store = YAML::Store.new "test.store"
#
#     store.transaction do
#       store["people"] = people
#       store["greeting"] = { "hello" => "world" }
#     end
#
# After running the above code, the contents of "test.store" will be:
#
#     ---
#     people:
#     - !ruby/struct:Person
#       first_name: Bob
#       last_name: Smith
#     - !ruby/struct:Person
#       first_name: Mary
#       last_name: Johnson
#     greeting:
#       hello: world
#
class YAML::Store < ::PStore
  # <!--
  #   rdoc-file=lib/yaml/store.rb
  #   - initialize( file_name, yaml_opts = {} )
  #   - initialize( file_name, thread_safe = false, yaml_opts = {} )
  # -->
  # Creates a new YAML::Store object, which will store data in `file_name`. If the
  # file does not already exist, it will be created.
  #
  # YAML::Store objects are always reentrant. But if *thread_safe* is set to true,
  # then it will become thread-safe at the cost of a minor performance hit.
  #
  # Options passed in through `yaml_opts` will be used when converting the store
  # to YAML via Hash#to_yaml().
  #
  def initialize: (*untyped o) -> YAML::Store

  def dump: (untyped table) -> String

  def empty_marshal_checksum: () -> String

  def empty_marshal_data: () -> String

  def load: (String) -> untyped

  def marshal_dump_supports_canonical_option?: () -> ::FalseClass
end

